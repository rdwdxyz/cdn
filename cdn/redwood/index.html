<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f08e360d2053d169cb9944d199e1c49ee7ecca08062f7f26e2dc28e623d47e59902a1171b27f91b5402bb32b6ae93770315adbf782ed5d132db119c766dc482da60b877fa4a231f97aa9561b2c45c7c5396c087920ddc50c30db9959a47f0160f7d496d7da7eeaae918a17e937434c313d07207a8bc8f09bf147f8d1922020ddc8569b7d1a9cf7824e478c8d8f0dcf7c401eaaca8421271b639b02bb5119e4803bf3f0c029ef53b2be9a67103702dcbe24a4367f1addfd3bee72db61e89f937d19bc9ab79a9ba3e9fa195d199826d51dc0cdab405155f9ca390cf3166584ce874477b1027e1050f33b617812c2ca65da906d9347dded79724a7b8d45cd8c2622896b71c841881ee987d3369c10675825e556150ad69ff4d14e171402e312b79ecfad8b1c1e09b36db3cd0b3e520a6ad3544a4c45ee77c6a57ebf93b9b59209fc1df0824181691def989353d5ce82fe8b71b05c893cdc86ac231a5d1cfc077eb76a7969fb7c4a2b096c8a09eb6b78ab82eaf0869ca32bc3dd99f324442d87d5f9af33a6aafc3c7aa10c3b426cecf64f861e831141caafc6b5c21eae8d15b007230ddf075788f151ee66a389ded82e2aa4f815d20937e380114c6767dd7bee67c854f17c10d79a8fac68f2a4aa6c1d4bb33fe8789e7ff2b4b59573838cfd0654732930569ea64dd35bd5725d6288dd08e496aecf42aac655e8f191a20b72e4f66494437b96c3c2427d235e4d449940e57deb404bd81003de8d68847801688d0748eeced542165f0ebf587060ed6605cb98e05b896998f62a1063fb819f35c7cc1784501413bf84445214a0cedda78dde13e60144a0cf0a537d0fa2444a0c6f8013958d060f695c480abb2b5c9d6d9bc42eae93e7ff2cd503a9542f92fbf39e84bbbbae50cfe653dbc2ed6a48c001d160525f65c0a27cffac1db70e49df5c44f4a4e4d1cfe84ef21c2c38e25e6dd231c1d567be815d84a86c56c9631e609dba4216324cfc3b2f494de3ecb3fd3efe236784fe94f2d3de55e05d574d46d02b408f66ee73dd4eb2f91985f41aa3bd4c3a013aac9d885076f7905b5e51fb1fb1253bc19592420e5d0fa12a01063efe58b9f0c4e90afbfe8e68ab9665ea5460a681be9401f7c9885f2fa904eb8a4f9d2456bb5e015197910c1622ba4c2a8389c5b9b5d2f2cb305526b7cf97878bcfcfa88f429cb5cd7e7896a5816b2c6f7edf50fb3f4e7b3227417a5515436d023b2b5625908b38090f414f72e888162c8a84771e5ec55d43d855dfea9a2024187388caa49fe99c9091bbbfc049667dca5092090616375f0433779f4291d07b1d991852c9dbb331dc4d2f338f65cd5ee222a6693dd29bdcc212792ff4f1331259e44eb58d2188fa382711c648e75ec8c3eb6b7e2940624d635b5951ad2e42b60d4720cc12d8b95249a35731497417f8275714321b628872181123454cf01cafc2b6415b04ab8773976489030052e01f70cd38bb49b1ce106f541121c12be9da41c0d02efb50ea56e723c7a7d4dbeef44961cf924a87352038c82d3039e13aef4cdd23141f9c8b1664c95b850fcb7d97af9a4bbf97cd9b8dff8496a56e0d5a890fde3eed8415f867fe257395a53e63b53371c7b31e8f875bc775e73f4ad23e777a4a4769bb19b28351c160cfa52d84457b8d76343aee00083c5386d27f28c52c6cb4390b9343bee3202986fb9b549a870a2406e0d2753647ac2af435422996c4f86d1e08418c9f3343aa6b9d09437d747164105ec17b76e1b5a7352319b4050ae921b799ac2aedbd3725df8dac1f0f55745f5816b8a1ed069cdf70c1fef973e214ea67c029a7e79a473cf4713687836064318f08891be94de8329f5dceb3b90e6ad14dd0049ec05978e504ffffb266d57116bd444d11d52fc66a5f2a18959571d4317f433a613e96577cc719efbc5dafa446d6968fff3969aefc1af67641b42c847ef42553297a7d2182d338102de104e5d81fd7c68f3c467cd0066fb38ef865556d65d26db2885a1fc84fbbb6ab919fabeb5322c8571e492d42ce6bc0294a8f33c5c34358489d352d651f8d9dabadbb6430abcc3dbf1a7293362ce2463b5d884b9c197f536189d828035dc62c0eaaad4280a5e1c6ad4b8d14c74846b1c337d2305301ac2d972aa5c98ab20bcf42306eb648b56f18f5ded62fd9418ce55dab5c3b88405dedad23f7b0467ca9a84980d16c35024291d54aacd188ed2f1e0bdb49719463f2bece219d2db35898fc586288ba605e04d05e22ad7bd958319d879bc7c1c7741001c6c0001ec9be4cc8ab0848afe17c8fd726fd89e506a420d40b2883013db61b599951c4252e3d2c8ddae254272e1ce3f2a8fc8d76f1b2f9589911ec5a836be51f6d09d303deede7f309ffa4f78e0be0ae7681db12e426398376fec6b7cb37777aaf113b9844e5b45d878e95cabe1898cc2839a7828ca04247c0585c0e8bbae82a86ddac894bbf91e865b4d910dfbcc08ee2726b2e06557abfd0c7b1e10902a3ca014fad00e87bb265c7360ce39bfe3c15b2a5fa95e3fceda95ec4be9d897f85d4c4daabc36ba5b4bb5fae560d51e6306ca1e3c5054fee12505935cfcf5a91a54754c3007e6c37ab111f0959b2d25d01111ac75a44661ec8a49301cb5b2735d14c00496944bb76343ac5ca244ba211a255cf358795579f6d47fb13df94dfc48246d73150da3674eba9bc9f7bf183b7451b4114491096b20e96669ac52c0e51b0e978c395e2ccae73f7003ca0f32c104b64347c829974ed39a90930defeb6f388ca0160b08eff43c846288ecda3f95c1bfa6ca1054de252df86b702ee92db54c63729fcd944838ea56231915d6e7e824ce33224d5989e3dfc3ef9586eb326d83f693b443e440f8f50d8bfc9cf695624c382df5b41cea7fbf3b28f64f3d7f0bfdc143bf86c1395d2dff73dedf4638efca1022ea70fbd81345d3e5e0cf7be0295ba6ef5de18649fa90441e0cd17e64107d4620e14627a93f17e87fe655211f09426d611aab8c9f33a7eb23c213ed74243a79c757ef9d0f148a59654fa89f4bd317cf37e7e253ac5e9aecc890cb0a9a2d280fe04488cda461cf9e2c09e309ded2afd90523f35a7552267812a2e46ad99745318366e4d70c366b51553a519ce131792c4b7dfe62966c02d9419855552c3082f242f029658043dc1506111ce897ac9e9d49dc8ccb79044de6f36a41ea8e38b831c8e2dd29082656c971c3f4c270f054a731c6329d1b244d00c74e90f2e860f571d193e62afac039932df112204e64f5c89ad2aabfbc0d30638546deae02bdcfcee93a36c0d5f130da3aa470f8ffe72da7444960e649b081aed2281b407a9f6be716ab133d058014ee1e7478d259b919fa5e37d0321914a3d31798a7cd3165a7b51a1622e7816332f9033d5d88ba20efbaba02f80a8f5aabad251b11654b7dc0318a14a370a57ef28427f871622e1604a4c5dff0137ffd6a477a7b00d0a29f5e27b4aa6f9e9c94a9b4099c40fd05873733c894d7e1824efc0cafbd5759b228376f33d2b04090134087daf72a3363380377d847b6965b911217c9d21eb0fbbb729963637e3d529b287f0e942202508078ad9d573aaf9493ef7aeb8fcfbd3c13a16f7f9d26936358824f79cb1ce66fc7a2dd78e309dceeab3b2c599b2ba56104266b940a66006a23b5666ed3d6363554e0439c1814dcd8bca27c1ba4f123b7c914bb846f75d95ea6e1941505288a6b61713af7d092bf42cc8eab78c7910cfef6e356d67e538f5167cf25bf5ecc630cabace69733dbc04585564fe49b548f75c26fcb8f7c5101000effb081a8696453819ea5d8c71e60775e3532fd9bbe17c430391b9ce79418c8bc373d6b205d65992f1f3bef0276d8fd75f2c6addbfa5f57d30aba13ae63e201dbf0778a02fd267520ec246c43253e4d93269571d38bdd7bf16dc5de6a36e60bf7a4653a53bbc34e41b6fe18925e420d1e937ecdd96db87b057aa85734676ee682fdfd80c7d41ecee35cef34f79edfdbe09795a5a6a10eed4b0a3771f4d030cecb7f2bcff70a9b6be7e707db91497f4461b588f0243a02f17687bb539178742b3882a1f7566f731e839206db40c044380e951d3f8f3eaa4037f22c6751a8aa6fc39bdb790db189f271345e611f79d06d7f85c5e49dcd6a125e7b8dedf471cf0e76829f2403a00f79ad81d8d1548557e11ebac10dc79f0caedcd61f503c6b732da555bdd3c8d9a27283fbe45ca4cb4737d668c738f9ef8d90cd3c6c87e11bfbd9f0e74866e0194244c40c27d472b0b8aad691260040923029ab1e2343b82ecd11934ea7e88c336420fabd883cb7b513fbfc491d97adc35a7e989f9a538488fc069e3d8fa5bc2b8a6a322bd1587c2b0eea45ef7f1eeb6cd2c2faf2aff6c4cf9c7664bb56ac55691c48d9ce411544f22ad74640d9cc09536fcf74d02f63a91380a80d1be2e57b7256b4a5ce6a30f047ed2dc0c24afca556d1820a3693c6529b76222615d08fb7aff597dbaf7aa9cab23d3d7e44d939014eff8f2597b4fd26e353183e1650f08dff0db30a07cdcdf2e82854a87a501a35f3f0fcc33e898c3429af3b92b37e2d377528e7dcda7ba0195e30e8016ce0c4b2cdf802389ba1fd614456e4b1b8fbca62505681ac5d5f7f89e1260749134e0cc4528386c954f1a79aeb9e2a0feca3cac17887d0f2a6f9369a5173d4990d2651ea912dd70fb24b19804ac7f5a563496b83da8d114962bc55189c1c9d149e67de6167bb156f15be5687652b6147c8a459a91c9e15875472ac56e2da0d47c73a4e0fca208943c52f2e5bf4bc1fd5e4cba16774cebf99df5332fdfb221df07296bdb1b51b2c587b8b8215b6f45a5fda699be55d9b48acff9202eb80660bd683ba87f960c2ab3f316aa3546976cd107f55f6e3539d4a5b8b8193c637bb2b0df0925f89b695074de573bf1742ae2ec0cfb3e5cf275940687ce25d609c685d0e98704831f96b9dd1383f4d9ade5e16b4e3bf12345569f2f094a92d7e9a0160e986c8d5d90e2c3e36f3bb3c06fcebe19aa002c664084b70f8430fd7f4f2d29104504753486661b146361519648e9dba7b54ba60a5e2346574392a043a652820c088a347235f3e80ef0ee7796aa444022af2f424584daacf1206cf61915f2c0889582094930f5b258a8fd82240fdfc2a1b473aa49eed7c511f3aaa0096f774d75dc771b2ba6f2791de1bb051923ef7dd02f9dd338254ffa73f18ef3e0e0a401415456007a6a4292d608b1ed2f1cc866045fe0f224331c432acb5325657fba717f7fdebde894ea37059012e92a90629d2b6c63619ea791d6626875abdfa306e0d4561b491967c1f4ab1cfa30035c48acf1c892e7ef6a2ab6b4177d27b78d447e8684c242b34045ae95545b5f84710eda08070358cc6e8c40cbca3cd8f9758b1477970d53effa1a51caa7c3a6c315164dec72f62c0e21c2a64b644b8fae0977eaec56e10735aaacf7afbb65f2cc2e6bcdf317ee48f62f56f7b0cef983c926f3ea16acb6240504d20c8561620357a525613b1888c466d9c2437cebf518a2038bb34665d1010ac857a686b2363ae987aa992d324051e76c0e444f01753c79ad2b1ab2355b82e5b49c018e78b4e68b14165507c468b23b6128de53fc9291dff2b946678dd0b47a17e601b9a085f91efc5c9581a910bde46de7232904b90e5819de1631f42d1f958ab0373915070035a427eae8a47c53bc5665010a4feb6e49d211c713a20c6cb2e78384583577de8feadb78ae7c5000eb899f9111526209c9c4464628b4d039663f2f11a10be2fd053beff88d6a277115cbbf5f000355a6db6693091e0997c261d795e5d684338667456bab8c4245db0984437af667a35419682b0b7716ed4fca15bdb0c5bdbd00154c8493189d82f59ddf134361ad4d42120eb2cdb977d7388c07e91e72710fce5a23aa923ea41b8d572b91cef59ffda913474a17fc05b6787728b8694fd5abc0de29bcf31628e237fcfcd8e8a70b05bc770b163af6fcdc6c79e99f192d11d514de1a0a186d698e80e4f5813ab8b5550a43e69bd74aafcf9503fd7afe636e129696466b3c4a583b60148f71a40d964f72f8b413d1697336860b7906c2dd8e42cecd7dc5b4dc288136af3fb5c9fc25f4f39e6e6bf08a39c5171a8d7abda585d8699d54f103de997d0de8cb7a9a796fa08c373297c735616509d3f52eedc79bff08cd57a1e21aa34f18eb9fd7e6d12a645a4b6a1aa2e2cf87cf8b6884bc7e79172f915dca5636ff12b4956d1944456f5d7d58110c7426581aeedd09ade9dc96299c647c134eb9bf74e3421aee5bdff82a572d36437775649333e00f517c1c73fcbe3f81d3baa78fa079ed7f6baf6a63beac8cd0b89f640d3ce03ff52c59e20b3d5f00fbd526e9240641212fbabffdab360b395845e7a78851e5bed6c1012af2fd4e42701ec6e982f0da3d95e61fb42e91f7a307f75996fb64cf8b3f777e964eef78408a446fc679a677651a4b56fb9a61a8e75a9a7c14db09ccef7e2acf4597de07e9892e6230d6eded4e47f85c05a004210fdea216f221996ff5bfa6ab221762628281078dbf357157ce69b0cbc01aa0cae5e440aa8a71e8a38cafd0c774290ae9eaabd98f24fbdb625383c43f21e1f8c60cd578c5baf521100ad1e821aeba44ff147070c87892dcbe51a44e54f2d688659a0bd82da1264b4767c86dd9483cfb29f5daff15c2795b135c5170ad92c932c72dfa960086b1c6b87b1464c29e6017461b5f5852ff5e4c4fbf0284c1151ee7339b09dd1dad22afe78e0dbc509cf1a75df38bd7c16ee8d2aef33198cb313ee9cbff817b88bdf9d4ba7f055caf23665f77f1a096f750f6bf13b0ac053350916cfb57eff59f004c14d0405085301dde41766f777986bd5a36860a02bb880e4540f76b9f7a4b432dc2208a6ddcb2983ac53f14323a82a6c474daec7b4211e50d318b7b1f1bc10fa7f1c53c46541d2c8268a6c5f585d95aa19cb797948da71db5d0d6a1a43d6601867eed596e42a6cc3fdaca544e38d792034707b41949e879ac6da92adc48ebe664f29c5d67e600a805492213a6dd7ed8a543f36b94379f8e39552412d3090c00f9eaed08a7a6512f229433bad2e0ff2f87d0567e7df24618cf40504a9f3659a2c707bef8d251d70d19e83c3b86cb638bfe0c093f485ada9c904bd41ca06c15e76a05cdd07ef347efedb796bdbd60a2a3303d10c6e86f4711f3ea5240cf8e87fecae4db7c99685a7e0e56b44dde2a90fdf195b53022a3714fcde691cf16f7386fdf84db79c5d50db9c5baa48d91aa88c4b7d2e83b428804a3135b324edf5a8fda2cb4e2a1cfe3fc240289f1f5c56f3eeea3ab5ac5022f4262f866f15ef263ba1c299eec58db614b884e4b58991ece22f1667288bf592f9061ad7ae672ffcbf25e544f79aaaa3173620c3c18e14a79983c38da3830b8c7923679e8ba0fd4e3b0eda01afd5f726207d1c0ef8a721497d5cc1052a8a5d82c5db0f897947ce1df72e2e7d28b3d36a811fc6571db5169bbdced0ec7812db1147305615b86cc8add5705b35506dd4a1ad03fa6f024b2141105b813edbfed532b7e9167e441765af8f7f25fc7887f8b2598c10b3cd80f2d7f8e112bef68ef507e1056093128e12191f2d4f9bf2be41ea5631a49eaf6378e776ef0f3890ce5a29d7fa290190d63b4e9d49292796eafe1a7997ddc5b3ee5260b5819777657b6cfdec1f0647a1210d53175213ab765bbc251bad5056a2168386cb9dc97597dd3037db9496de90bf47eec7c2b6c019a66dd48c22ef5a5ff0d90cb0186d42e3bce34c533bdb5a081a325c4660a8ce05ab0d62d0c9d731025a389855e8a89d8a87beda1bfe135cc7c64f2d09061d5cfd8159018c779a27359fc9966ec1d49ac89b9c67b14b236164452e30fd361a7fae74ef574dc701ef69a6733b791c7fcfa7e65808e653dd8e4cb9a9c1d67798e6eff57330dfa2c66249a6c1ce26abaa45bc40f099fcb3d5b00333654c78c33535dc02a5d5cf51a430141e5e518bbcf1085ef417377173153dee8e592506c7c06055963aaddb4887b644f03fc7b4b0f4a67875b20fa3164c5792068372e4775d7273b4ce96eded9e0f0d5ce41b6491b96ea27e279c9ea0177bd01fffda282ac66804cdd83ec85771207bb6a9ec2778c3d0e8e2326e57ba623b2d9219776bcf99e9380f3d78c6d2e2ece23a2bc7ce34df4012d16493fa23da3955faa0056e4597e0be712581b122ec42cb60d5b3e30ea28a6d35943891439db42175f8a9a45143e4ffa9a0464403cd1cff5567ce4699f2981982a3f891c701e6eb1f7664c8aa308c3e297ef3582c6da4d724ccc398c0f4f2a2258bdcb1d3a62f9b572f6c13bbd27100d77657aadf1a4aca99e5bb059de915fd0979ac5b9b58121389efc5fb29c033bc4307f082345acdb02fa9841ef16d0cea397a790e36d7b28a007c4d74ce9b1db3e2e3f14c8ee76cd7b6a60587973812286c5afd48812432f1cef23fbbc416237bc021d7900df0212f827745660250765ae450555cd46fbb1e7dfe1ba783be61b6b4f833e031a226c96af7e656eeb9a0723eff7b466d350855cd775242b97fca397e42033f2c05c984e899256e0fbcba74a54f55c7b337318e83ba512b50651206c972f0a5c83cdeef0da6cb67c4044c83c8d06d8a023a6547526810b882f5f8b9c62164a22cc5133a410efcbee231cb581a94a2048f4ab91ded311aa6db962f7b71b4bc399d7a44dc37dcc1e2429f21fc17381c3975033a11333859d12d7022dce65e6fa54dd98e3ac9d311ec80e888a76fecdd18a5280379f1b3901afcd9569345e13fc039a5b120e3564c1678ee3df42249a81d8c040e85f507f14295bfaa463804706eefbba716e660f90e8f80933202305317cccc4956bab968d4805260a4b98f4745e82470fe2a2173ec7685c818489245980aebd4b72069bf70a5132dd87f6ef2d24862e0204bcbca7e1b1ee08a8c74f34049944304e34228249dc7ce2477b69de02d814e869da14240bf40bfc4ec6ce0a5dc456aa1c6a4ec94eea49dbd8f887023994d5d73a8cebd60698636dee0bde9ad11882d726fc82df7c1069ff4ea58a691005a572b6734452c91aa55873ab4bd7e56fda1fc92121c3ea0ec65e10827623c62fc788a3d4ca111b49db609d53b0c3f8a9e4dd32ea0bb860de7bc3d47c7b8ddc44782f8259ea3f1bdaf123c05f650f6fe85c01a1a01f413146bf4fcc3c6c3e8d7b048c01e39946ee4e6dc438506a105ab52f1872094238f87337bc23632955ff6f39364f7c2cc5f7a10e39328db7ab0e342baca862ba7e7128009e9f4467b3370f0935905b47e5395a6aee154b7d110fc7182b50de1bf883bcda884d89308cad3f0df2c79e91340a4bb2bd2b0fdbb36f8c5ee14610bcf8b74cf44ede3ed6b87473c011758b29241f5c5fc875a76987d46781605f82d8852a0a54a0e538ad0d4fffd403a6a495a41adb8e0e3dbeebfc0d21424fd142919cd9e6a25acd37264fce1fec3145b8456f8e3aa27056192a33fead951c7c1eeb949a2594e4fa84a8ff5c1cd445c9a06e4c17481c24d129936e0beda3e3d8b3897d18ec7398ec17da2720d0de1a10472816ee2390d9beae594521baf26bbe63c534081bf9d7080a61a234cc881e8b9f49a8481bdeae30e6dc13214e093df4c435e5bdeeca70cea30dd1a6dcab64342ef3efb6ac2769759d03df8b96bc75f309c823145ee7944eded3a7ba6d31e34b336f07b639b6c9e24819bd691fcded8ec8d5290c1fc9bda8ebee0c9434d17fe3d92223e31251ad308d65416a0f7d384450f3adb3be5bafd65d63ea1b291560600004ddd848fac2d7dbe4b885862e16fd0087da7df9321ecd41c0bf7991fc8864af96bf4bfc2ec76be435518006ed7dad8d162dbf81bc8d584a6a4317de8c6d441e71c961ec07d1d28270e7d7908e5761ff4d57a7ed7de8219353a4b12ed6434aeb3e0bd1e2486ef00eef78147c5c4694873feb1a7360858e86304c39f9273c1f840b6dacbb55a9d5346cfdd126486e43a1fe8332e9f5a95684e1982e2396fdea3b91e65101602ac249db74963d030898ad4b9d65a6edf5748ffc1b2266fa40b7f73ad7b0970fa774ef787b81559d300323d058d1769e279ebd00f8fe6aeb7f974c5ae320acfc92e69f24369ac3be292e9538e05d9d95428bed5983b6de4e5d7772dea5b8f416f902561153a876f2f58bc20876adeb7fc5c8dff00167e1582a06d2c82819edb1abc6e0b1551e1659068e4dbdc2ab6850e0c838dfbfbfb0db2f6f569d3b82f7559874aae029681ca59a3ad183876ba3d5338979db446e88c12dd82a1a7363a110c4e881c55e45a1f79f63cbfe3f3896f9a6454a768ef54ff3d94669ba207a52355f3cb0c1c71eb1e09b8656ad2b0a05079b16030f2288401ac09b35fa11ffb0dc1894b25a140d776a7c617c1e6ba1ad5fbf30dc59f1a6db12f9b916a2c0358ca203e71d55955093caafbb1bc94335ddd734d4f0dadde954b545f87d847ae693c0dbcc1e1a82d2c76bf09e7ec9e3e19e2efb3394253e8b837711e2bbc60563dd7613389588debf3874d27ae39af77647bd5ba5f3dc459917c106e33690643ac83604ad1d619a4c3b477c7f883470b785e1e84d1567349f36bf1e66b64505403d963802878c6ff374b9bdb7dba755588e487f9a0e6a84ab57d195168c1afe326f39a66ad5f2e3cf3035de26aba43f61e68dd7699f85e87c1ebe1a52a3c65cd69df1de9eb93548376232290334cc1f9e8dd41465a39a69d6a3a5d031fe4b8a14b2e5d2cec3280f3352870f37ad323cc8a4ce35b0b2eec7f8c078c944c2b1f90e254eddb6ff5e3746d45ce2e6af1814b71a67584e7d407e3b1211c34e5eb9ae001a40d029066d38bd9a18653ea433337cab0c151013d781c04b4568c38a0dfe6ef5d1a0b419dc0912144d2d79759286269fd3e07deb7a0ca4d18bd22790f276411acdcb5e1d0c42b710710c1361ed25509fc57d3e73e3ff4e326ab1c692920f03e9fc63708bc70e91fcff48956d53fb63bc73384c9c72cf665b9ded4571ba2f0887cdbf14bd3fc3bea773cb4f3fa699ee1813c058c854b9b36c5f426ba1d4ee28fb41f7f2b3c29bb2ad6140a3a70cc9e0c6ea195e0531b66bb15a02cf55c773dbfc1e3124b580ab0722a7c504554696d7a9e1671e960aabd8e78f3fe3f96f5a517182e172095bddd2b2f1f45fc94dc33e4c2a6b6c031223915c499469ae4141feb94616f477e24bf2ee34f6b3fbbe214f0754d5ccbc149e669e9a5510f8aad19115b0bbee00f188d9bfbdc9831f20c96eafd9cfe57bb33c84ad3e187dad05817e5bcb4b51d94bb86af19295e250cac12039229c0053a0f23ab633c8efd16b97c4a338cb8533b22609fbe080aca18e9ee0f6c9ffdb38cf4af2d2808d0cfb1a5ed04bf4c59bab31b358451976c01bebe1c56f31015a916554b41a9201c3eb43490ae8c513b242a5cb096bc52a4eb8fe997b8b8c2c0b68c93c97ab078c9f295075580404ab06768bbb2f153c0c5a8d7888abad3bfeb920558a2d9465234f4b3ead8cb3529083c791861769fe86b47305918ce982b0afa5bce44545a5ee8f58095beb3c9793acde82609911bb22408e0586c876ca0b1682659c3a033652bb78a90172bb3198d7af5566bcc674cedfcf7ef9a651c2e43f64830983081fc3abea666cc825a7aa79509dbd0eca77f1dea665d29215eb11140b496834464a585951d9732f446fedccba58d365e7b24acfe9fcbe9473da6c36a39ffb11f3f61c6509e5855682b12f9f11531811a629de4674393f3d8a214cd7f60765213753e91369fc3f5f3ac4e6be650b9e0a9b5c33b6476f853bcbfc713e2d80345c37aa9aa5ba019edba720b109fc3387a0bb9a2077a5716b659c1cefed6a96e03c1706c3ec58e75db91e5f9d4e555f11946f3fed8562a994bd80513f5a3dacb4f85b8c1f69cee05191ad5376bd355a012d0a6d78f7d1de325505a5133d1698961fd49c4720f6722ebf989c343675aa65ed0520a82bc57f839c413c65d9db375bc1d435a802b2ac43654286672304cb7c327efe62f829a42527778c94865464a932b815932d22d6b36c8aa092689541e35a2851117134afc5c9c1444c9a38fe6f65f569e9e8caa3341810253fa0ba5974edf623d04e629240f651ed6a56581a4292491cf5a9288be2c942e09116b92be2f23c3404bc52190f6885de04da091ba0acf583550ddba63d1f3d77645c664837ebf48d031d668c352181518dcf332fa54642ae1a60e2190f9a5a45d632c689272623560ddafae830ba058ad6487737a3bbae3f21c440a517bc7096c1605feb9fda4b8f6225bd501dea6f286c2705c93830222d2e4182fdfda13da1db58e76f1fba788e06534071f6f6d09ed8bef9963e7a63ac852279a458c62e7ac09752d735a035c2e7161951ceb3e74795135f9b4ca703272f3f64864e1c53289e264efd90c690abb6222dba650bc39e888153b192796ef2567743e44216adabc7f97520b2104dd211e72a65b795a817a82864ac85b453de83abf1166698c56e266378c242b626a858c94ae49aac06e34cced44e1899b96aec7c64ce3cda8262c624a411df74f8c7b4a9730b6bde2b4e62f21155e5f6566dd0e98885ae694a02a57a8e9a0e2ce8bf9595614318859c6d441090f88145b840458df91a91553a3e44006d84c61e9f4072d386feea13810e81a2d2078aafd530893acbc69ac152782e24dcce7906cc53c3b314c0b2d349dfd40202367e5c341fba1b5d977e2d07d2e768e54da1e822c1ea628a39af3e196633e17e181bac1968bcda507cba9e6cf37102af57e08193a5552ce3d3c31cd5a428717a6e10552c615d600c4109f036ea97382c6f03135eb053fb0a5a7598ae5bb976c6df9d8881cc845d3adde0f504fef58305f4777b832a0a41d058a3d5fded0dc76c3d109ac22e49f56577091ced87898a90735dfdaee0ed2bcbc97cd809c13771b73dcbf4b91fe58d1568989bbe3ec925ce17e0cd66cc30b3f6f361e266f12d11e3d97f43c4ad75e3801b8341db130f880769b2c3187babc6786aee10d90c0f8e353b849b0f390cc87638ba30af44c4cbfcdb03e34da1edf4adaf29a845a0d7c889003a288d6d0e308466d8816100438f44779903a01a8ea71209147a415bfe28b3386202d419bed5067fbdff27d056d2bf602109c4d2e863b10272a0ccd4be926396f9d0fe3bb9efd09d6d4fc65b978f8d0073a3264d15aa655b149217cc0dff94fcee7c74c39b6c12c1f6aac9ba6a8fa03d630f9345a2bb316fb0fc2b38f3bf69d03b937ec0d4696a2373555cce6283ce8db700ef0247d299d897591d6c61f1d88db189ef716240cfb14a9576f1f3ff9eafb2551b71f8c249884517156ab6a2bb271b1ad6a93825da0399709313a03704ca347afbb21d000a10ec79dc28b57fdd439d23ce790bc9889a6b0e5d5b904b0308173dcae8d8ca4f3e1e8b72d15da27a11db4423f6b71218e17931bab5a5a13893599969426af9851b67b5c275f9b3ee4341697ff85cbd04a6018117cee7fd4b8c4416d0f83721bdc87e37c410f77c172267703be82d75c20f48b785335c2c176ba8f17ca73a12193ce2cb094ccb90c7ff030ff443c7c4d23b705b9999f67f4feaca9ab8e590e87bd2e6cb23c6ba242cc70708b1243a30f618d438fd471161e9e5654a895ea4eab4c1c381f984ccaf4b7c7079349ce6d608f66fcc2a732cb0294d524b13cff9e6ce51f245dc9d7a8dca8a0c7e8a9bed658da105cb5b864dbe1951d344a208e6846506e15c1ce11883b84a6130787d3852d2447268d2ba06f3e3436c5847f78adf5c385815760268515bd4450f445dfe7a65deb187b4c883f33245b1dbc74b79470cd1d754b8314e04bee7483a992b485edbea1ef62169ef6fb464e3c0928d2d5bf013fe999da587b038689659f758797e25b4061c0457ce8dad2a4407655f967f79c8584f9da08c8e0f8496b09b75b025bf4762c233a0c7e05ef1f18d5ec9fe052caea82b9f90c1366ffeec9dc42c2cc4c674f1292f2f9e9f9c969179c597852a7520035e0863a9914afe7ca502ac022d3e48a6e82a310c15971b96ec6be595d82a2f571f623958c9db2a7c49b284e55bcac71c55fea738b9083d64d0c8d5154855dcf3019f18c058dd5156b696d29113e99595f69657db14da88c298382832222ac3ac4310463e878e4a5c6172d6c8d3a2202e4885ef744f3eaa1cb606e9390caccd57e71012fef9243e1ec407529159cb14f5d55ce841c9b85c6fdc576cc50f7d95af9b6542382e151a06a44bcb86bbe4521ca675cc7dfc64e3958d731f28b697917ee430534239c81264ec1d14d6471e87d50e5bb6a2599ef563af29ea299b3f083ee19d30fdcbc3a358f5691128d606e1e6e1379e7aa1814c422243855e373c4a2d6a11ebab42391ad14a6fe34eb4b51b246bcc265ebc92ca0ad58699b33bd47660a47677be4f92bd8f65d4d643a7e944d980166774f4702a7e91b27e0a973efe480347bb78a080ad97bb2ee78f20771d313793c380697ab79442a2c10199de87f8a2add0e03795d6e184ad38fa78965f57a54a80af17539312f8e3927d1a6a05a49ea445b9387c5b31f0e448de38d4ee9819f987996e98d9551b2f1893ead9f98f8671a1c40315418706c805e0ba05c6fa7836f130d9b4aa0aeb96b186f3919999994f60ee0481001032fae0c4d05c699877bf067593684e956ddd2a3876952dad8da14387a64f8aa9d66b0f1d9561214e39fc2fb5879f9723ab9f3f229c62f206243660b5452b395e8397fb66cd14cf2debf912501c110089e8360fd7f3c0b6916d3d5b144da01d8a8b17020bc4aa4569635f7e7bd856639be46dc9c61710a7f0d2c113013f87d89f3ae1f9f1b6c5ff8faa51a0ebfa25fce28da2bde5915b17bc8652dd6ed38352e659744fabf35bf3154d46964c76e3f95a9a948a26be239342c1c46fc9ebe2ec92dbd718e06cf2d9e54cdabf1952f7457aeccfffe618f28f8834e0fcc09a90c19111d3eb77df4f61fa143c6fe6e6a15e5eb87104f37d6973bc11f944a30d824797df1de11cd496ee4140d51f4dd9fa371619ee43187dded3f06d0a8f4a4a129f2dc549ae4911ab748c04ba664c61b90f60197624be375a4e46e42d0721ab35cdaeb4fda3bec4f05b56ab70b87d4bb8efab5405feab7a461d81cdb0de443834a8aabdf30fc7c4ff7fa982206792cdb398af657c82bf1d3b460a257dac9443d41b401b02dc2fadac66a0138b4fc7873c4a5fd46b1d429d98573b2ef4091ffe7f0cc7f248d65f6af0b9fad5749cbe2b5354233ff50098965a8b02f3435f65fd54044aac6bb6246056707eb0d319258c429c48f32bb87fc7f6bf05dbb8855f4cbda7624e3696b0674bc64f93b4de37345248e3f76d09f26e98a0233dff5d7a8d6b0a6d5b24fc1fe30f9dbb2ac038b1caf2dc33f1fcac156dc8d5047f332f59fdbbc87d93bba0790b4402d80b009d3fad0519f9b447b2cd7e0c8223b19facedd18c6c5b009b7b07edbbfaf9320a53e76d26b12f4471582973994ff7eb3c9915fba6a5fd2ce8ba5b213a871e8022a6010f13104c7ee70581159718667ac2437f98670a0407e3acb1a3a547cf98684abadcaefc2f7873a1b4656fcf3c271d2da7bee5754cefc020017afc9420f8179de39491ba0cc97d73ea8f71dc43335bdf20d1da1728e5eabf2733dd1f5a62a0ba5d6f12a082b67ae17cfb206d0ee0964db2830f718f282dbf298278320a9d7df85c6d97328612e44cf8e5467382d558edff655fdafff67f2a52ec760144deecf68cf78b041f4629475a92e5d7e67febd7bc606e30f5c3f480fde4f31b9522df2e2e49382464161170a54c2b76007a47816f947e53db3239a6e0a2132730edaec62f16e4d3b89f47d1e51ae4ab192e21f36b12eefaebe9f458b3b0ab776b4f3b087503da164fa8827f24024318ef191da71d6b37caa5a723f29d5c812ec306bc4dfd8693cf39d5fe09227ddb8bd9c18361c7c2c56a361a7b1fff0e1d8ede645102bea78f38cfd37fa0c8a80c1a764e045b893718566cc74c1b2bcd1d44a31cb614092824eb057edf77febe2278ee2c854e2a2006be0de70e0914902712ba6a152e4c1d24697f43047796c1008dd7596b7ef14b0cfe3bf04b6de8494ba20edf2f2d1e375abe3401e172a80326434ad73aa97f9ff5fcc67d5845936c66cd81e68da4b5bbc30ba53ad367ee62c591a0fe71799a574ab834ccf16d36f1abff8b7e4b75482a1bc6bfcb8f2d027c85916131659cedad5c73624cc378ff602e5f5e8708f14656f312b5ecdd3c54fad06d46f0d9aa21b23b609b7206e576694b206e26a157a05d4b51c6b22b7692af1de76c1ee2b81194ac685bc52b8b9841ee161929e4b19164c25c8a50f839eb6c6154c0d37ea00ecc3e878c15279b5ff27e82c21ec1e69b07729968d94bed92801e7cbce1eeb24f1ec13907ff8e3e0ac27d7601222401c8dd1482c1cdfdf5986e5018893e1e47e27bb5444559bbeabdb246aa07bc01ee33c77ca1c0439defa0f42922c5df74b25c927e8a9790b096e9c48499a94e0cc51b631367bed11a9bdc24e561d3b5ae6a381f78eb8c7ec4ae4464e417bf0470503922ecac2581e7971aa9eb239cf9b6090dc4fe07f88bed9894ad4aa121104485bbb5b807f9b297958e0d8c70776c372dd45f7d131d77f1543e97270c17c4af3dd83876e9d3fd823e07afe6bcd0890a7a6ebcfeca8b6bd6aa118747e50d847060319448718a8522f39566e3de9fdf0c25b5dc2e889358168c0aa21b7566626dc89b25d0377f207f2267dad42fffd2a6133b2721f0bffa2b9bc0cd026d4986f2f67bbb3147da849ef41a338eccf0c9ae33c78f855ab877a41039559c5cf7ea260f6e41ec0921b5bc083d66bff94e43f2f5c13333f2c8f2c273b5c8547aba5a2ea1a9aeabf7f2328567113ede4e873aea1b8681f58b4004675d15ba8bacd0b858f6547acf9cb9da0fe817c124af9f27dca0d070ad920a421ff181a6b58871b959e29e69794a9386ecf09403e161d660d2875eb31e31604726c03ccbde7d89afa59374c924d0fc59a91f03bfe85b7cffb7ac6be8718bb1bbda566dfebf4ea3a11d011137f5168bd2f2e6d3f199ee0575fadb9d6c1c5e44164195bd4cca3798eb2121a3e2d5a378c726a9ff0fa5b5007b73ff5716dc5dce52482870ed73a5f4b27f0162d48b4309fd79f138698274f7330d209f5f5de4b014566bd4f9e3237831b24ec09c519f85c101d3d939b617a6a04a22a5fa150b46b45ee723b898b1e0c6d6fd81cbde2cdec1ea30beafffc1bd458772e6dc7c2ca7b31bf881fb1b8d2b36bf863508865fdc1acbc6fde72502695be087caeaf5c5447b9fcf87adf044ad0e0913ed54fbc7c60f101350893aa8109111e1e2d765956d090a511beb9edb3165e84f876e85f77b74938c4ae12103dda4d55f68e49c178216e7e1d8e25058727cfc8aff290b12cb888f4c75c279a2b967361c7a3bf74bbfddd38616951fbd0b3fb7f8b510abdfe09be55c20c24b0ded09ee0134c37913d18ee123835dfc536dd4ab79ead8e9b22304820f4653d7ba8ac9a03bd45b49c4ee4d7373f5292ef4e8621fd87e3ae6ab7f1ad2d11f8c01ccc9fc97b9d54c81869536e52aa7ff3db7689926de0806a4bbfa33c6daf62fa972fe10a27f53e2929cd6c08e8ea623514b1a7409f614fa5fdeed92845de17263e213a2bb61e102774f359d0c11650eb67a7fdc685726fbf0279c5b49ec1477d2455dd752eebb239e09d3b21b637429e84b85c1b03cd9d68b8bf9ad1f6aa7e68517c324fe3218639e789cfebc16b1134700b24a7725d1b4e68c9417edb529181eafd08652b9f027771d7f693bbeee6cd2915120371996da5700674e419bae76f0c22e9054bb2e28963257961fe1d20c84aaa3e730b41800a934b5a8f0e1e5d98f0c9274a38a4d2f07ec0a2c00da340e75ba368624a685428f6a92eae4bdb2879b44e11dc0347f11b53ab8c20ba7d1829404","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
