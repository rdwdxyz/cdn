<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49f98670a16ca501f4c4c6f65d13701b3188a6812298ce9d7e218bad42ac0970825c615bcdc68c1e4410206efd76a795c9b565d3d735cd6bebaa3f9c7f6f631358bd6ee3b22711383fbc04cad6babd1277945b61700f773fabd1a608a3d5cf0c9e1f7a4e9666c3f61988b254a198dc7c1e7838cc95ec3f1de12373b73fbfe814e27b113d51c78e096c14a51731d28ac9b40c159ef68d4eaf4d22809185cc2ef3a54166353b939ebbc8c2ef29a6b41e3c909d14b8d182e0a5cc7dab5480aba772f97a85c8d582bdfdc7390e7f0e17d8c3b140cdcbae530ed2fdee9ac4bd4f5e12eb0fa52965639b2d28687a458385f09365798381e577f838abcf907b0a575806de7d59f0a8bfe9401249f9ff299997466f19c9c162a34af127cfd7a0263f6f9ae653032d4508d5acc0fb720ac77167068bd3a5823cae764823ebd89c7df5cc58e51639beb90c7df2faed321ce6cd0ea7e8d13156c7d3b2d30ea9345f6cb748dba2fc8a733eb9c121a07c46536f668614f5c7f413aca3b68c8907bb21edb474994951d81a1bddb0014885d3d115809479e509608e70f2de86cf290d41993d4ab1a433f78f293749077f3ea46f3533c7d8b20c5d81a06508109a7f51e927cf10bb3b978e8180471c0bd6ecc67f93e855af68c2cee3f2715e9d7686e9f6525b8a5a3dc9834ae581df8c350d5e78ececb7a60bf6cb607f0c759af6c9f1a19bd36fb2c2620de815e10d3053ae76e88063b205166112d3c436dba12d055912f74ce3d72125a434b7eb4962658678cadf04d4feab494f45f85962aafc7374c7b019ff7a795304d7f9f9a68c756c5a0cf3437bf2819df8e8a6ddb37b70e44ef333fb7416cd297ddc7c375a27b8ec9eda801ff993346dc0eee6f57a413e6f4d454847d9e7ab9dac5202b6a17662750f350f11bced49887cf1d458d2123f53851befc450d3abbf39bb862857144098d4d86f7c4234858be1207fa964609c9f3a03a87ab6b07a99328ab5b1d93553ed6520e52402c045c0cff6e01f93fae60267c72cf04294522bab1a645a291d5f34d1a2ad3035374adbb4f19347c1fc838f195707cee8dc93b90d8189c5b4276d828bf011fbe6db6bad6a29d5a67f20fe529ea509b6fb4e364f49bb99520e86377746357694587a59d85ddc42a390a9ded96544babdc1f49f6d7282515e1168bfc44ead7cff17cf763cf509ae73dbdae02eeb0a5e396170947e614655f94fabc8c280c24dab20008ad0ac224a9c46cf66387e16ec63a1e979a0db731db217df732551d2faf51e155c5e90eea42fdd7a3771c029171a897d0e988ca8fa732ec6ea32bf5ee8cb2d7ab1963bf5442020957c66770b170ec0a70d7ee78d226e27a6f83f0cd635564fa81bb586bb685436e8dfe450611a6aef31da2d28b6c185d4aa021653bdc298c43b5766a69ea562165542fd4b40380caeb6b7c5ebf8d77408e25f27a6661bd4572550688b1b271af4b3c411e814c6dca27911f9b8c37709dcceb6523e8259b4dd2357594f4c1aa3d431d85f31ed3c55756b2615f2db0a45fadd49da56368bd2f069c9d33a1f20ed2f0531567f3c6e3b0872e387346bf15ff3ab3f63e164e2385e956ef506032f36262706b7ed30d2ece0027931d17e8197aea1bd1a2f6a2c6a8e2623ee105bb4f550f57b3721e902735ee0955653cb638145d64dd5da69f4006533c2fc0519448242a120b5b8618132a6a82201e3203e2ab33dd85e16bcd1603b7f0f13f2d9ec9ef2b87d03010e75065b66b14d52bd09fcbf52bf7f37d1ca2c276323032c89cceb1827873a7713562887d157c145a7eaef1670f200188b8837c427fb4aea16a138dd140cdf3daeab254ab8000fbe919ddcbcfcd4100cf4345436c513de6c420f017cb8386cc528422b96522fc26f2553eb6997521579f3845bc92b335b743808a8e0cbf82ef449cfb6772a0d1577b5007da4ad8f3898bc857930b4e5d4f1ee9f3be9f5dd8530bb640a39904854ba62d942b6d5003c6304b45260e163686179d1693597069390f443daf60313ba034a0d9345e283dddd11091fd7a5e4129ad72fbbb80b588cd67de6b1e15eb2cb1a871237c598d6e69229057d5c870bbb4ab4af3faf8994a6435f9a42c5c56e7da8c0ba6ec370aef98b55a0903022f3a58f7a47e5ad5e79a6c3bc76f4ba94f85a949e7550f2d860f51e1893fa9cea1af39f235eae6f8a6eb33c07ef2adc74fdcb0ab28b9ac713cf13e2c3239354aab0de0c816573eb501a6c165f9321b265dfff49b8143a8a96f249b7dfa5d02cccbd7f15804eb6d478e57b2ad52fbe5b8acabe59fc6ae6751090684c54b4a0c3ff1e7cb97cd1ef8cbacc4b45e0b753237d96aecc122e648086de09a3460442fc6ad3b3e6f7cb2fae6b9148f2df21af755fc3cb62d4508e9261f2e74efaaaf8140b6448f558673ddeca0ad253e26c8fb16b86fe3b02dc9eea405e7688fda911f7c0fe05b4e66a167a9f4aae67db8cbaee2c5a5617ba3122e8ad3c470c90685f514e2b312345f896cb796ba13a2523b3dfe00f5377d96549e484788fb9d92d05d98f5fc569e764c301fd8bb412a78428ee3552d907c93beb85e46eca54162e9a19edfca45bf3e67127ef69480b016c334a847b89f34ecd156ea9af1e620fecd0e9ffe18a1b8f897ad734258d653374d4163c0924813d9aaabbd0321f067e9bd57d9a6298aa97b46e9ee0240b745940e969addd7a6bb67ab3530789d7ed6b0aea42a2719d67c963f15ac81a121462411b977ef17a9987ca50b4e037b7b0024acaf298c6a46736ace52d9cd4f99825b4806eb544863c7878823b46b9bc470501e47bd923d460506311b1cadec7390d0b01a11280f6e8f7e3dc6bc5dfa45a155e14c3dd54bcc3a5fe2344badb2b1db36c180153e90b0d18952521058356f4a7453e79832a92ed052168f0d1570ce4517610aabb20008e8ab9b49cc52e19c6ebe29cd928a67b36e4b76f51ac32607b0fa116b845ef6a5ff1f8803baf753c42be595939dd978da133f91f398bf56955e94385d1ee4815b5c5088d38ea0bd793c732aab2c2203af4c8f4f995c98a279a02f2f65dcdfef7edbda00a0628e7da7eb61be1542471a374be2375492610602b951f4158afea23e3eee295d5b284bafd8d427e5acbcc10f8a9227c42e75a29b786581c78dc207ac5f68008636a2a14e0785ed75d44d1804c8d8338e6db52918e4d09cfe5d5fab321094de6990525665679683d59271c3ff966b55923f7aca7bd4733d01b0dcf73878f22a50fa554fa9af81e65dbf7d579b311151f1f6fdbd724d84d7cde5e6545a2167f0d2c248719789ace6ae10d465efc9b0ab182274e2de215ad0aa3521c4b119d8bc2fd710f801110e00fa85bbd4b175744ddc0c41acfa609c22c445a59842293e28e77934e7fa28365db1b3e38f195230360c1a381434a7ef2d87bad1bcf2df4925bb9e49916692f0d994170183cd73140f4cb407eb83ee33af268294fb18434adbe6db0c09031cfad97a0a76a030c6a5a357840cc711f8be8b6324f39ee15fa5eafecebecceea531ae6bcd3021e34e57291b7e6080038a6a37ffb1a690567543015f97510c08765f30128b22f6dd2eced292e35bec4912a1801cfe8c73810366c5e1ef51d49bcc8f77905a7a4a44455d1782bdc47a0c9fdb9ae98aa5a04ffc2cace1210895d3a12f6adae90e49146dd0c4901d7add2b448dccbc65b10bd1a2299cb7606d1b01ed824f841e8b1a6699b7ad6c8b540e64f8c57250ee2d128c3d000785f96d54b1ff0b00b1cb398e3e88ee128149dfcc8e4530c38e7a021b608010168abc6a1fc9eb91c0c9555eb23927f9f7eaf8ae58da71cf48461c47bc7d50b7da4ae802740843fcb7f0efd2daee4848f25f7d86b7d0d6845bc0ca977b521267233e15306a4116cbfecaee40f71e69c1b94dd1bfb4824c66aac798ced4f390f625c6083f759391664ef32371cc38d95c74b735e7838ef185d8d0081f84a60c71bff6bce2e4abc229bc5bcfeab41aff2e8de67c85424d338abebab1fa536bc13e578e070532a84324b8ef1fce8827ea11761f4e96d3f0de2572f34e101169e0ef8371ef148300eb9fdafb53ef91949229bd88df75c039b278693b7f2e238dc4a556fa72a9d9bee19b3169e0a40c9487401ce373bd5ed71acc93f895ebf42fade38f211649ec182eb292dc3757ddc4f14be257b5908c179ca2fda4cab42f58f5d495a77b0dc4d4e9bdb8d4bec78c4f8adc678c0e33d3089ed3c26f09607c3c51272c832d68ffa66deaac80070c06021e9daffe98262d740f47458dc1cb97df73f68aba86705b1e66486b57a227be01143aa540411e63341f6689ac48654997e30e20ecce8b39bf844f215dd16d13fe0dd0a89aee29126580fa331dae32bc4f78a45449b87dff78f506b56bf26a455ce53cd0a1e2b80755c7190ac032ba9533995d7ceb585e52ec795b86c99bb17df1942c3f376b56b641a96235959077b879be517ad99bfc8f2b404bc78eefa7c5bce010e8c2de0af06e9414095631c8e122d3c1ff7089a6ed0cf08af014246244ec981f8e6454e83c56bbc760736284dcb11fc52ff991f4cd7b24557543fe14c12fc9f56c7eed13c8e3a0cbc4911a1cc487e216349397e96a59d1726f0aecbb412078330ff1c6ac1ccfc111c235aaa2dbe6c1ab042c1955f92b6e5fa4d01951b2119425300bd0286c70f513d1bda59361494acfb3c7c5fcd2c6688654a400a09f449dc8dae90789e6fc38a2b327f61d460384034e8900071140e466ebb8d2efdab54b6a3075f3ca7c0b8ae2691ec0ce82a200028cf6b9d25e97b36284b6fbef329ed4850a68ead90948e3294cb710ac44f7ac939b35bcf44c51e52138fe417ed814db44ae66353b21c51f32da1755ac0e2f10c373712ffe39daa7188a9e756e1eee13439be1190a25bd8480c4981fa8a09edb9468cf5f758a69a4989db88a9711542a3c6a3dc4a76ee66452f8b694614aae70b28865be285e39af3350d7f925d2ffe670bb4fee91141d1f6c5414df68266da8b63b221fbdf20fd10a87c97979108c990e6dd0b4e9a59df095a8a77544f209b29264ae7232f6868ca04b8b656abcb86f6bbb8b968e87955b293d7b5b06ed4320e6fb8425cfbd99d4bf4b81589edc1b27079c2c1678a8d19c16c87e1cd27d9ba6f18c8413ee52bc6d63dd2e94924bea7dbe044d1b1bcdfcc2e3dbb47a8e40cedaa59c915fb0c75ac9d266195c0c332ec47d3177129c5703a8e5d6df7a0fd38825626da5e4fd9132b731ee47c6bd423dda7cdb53392d501db6ee1d7752c7cce9f025fa482e0c98fb7c9b92f1fccf3d61b0008361649f0c75c4696131a5f75ba223dbf8568a70a52eedf87d5f25fc9a6e9858578e363601d00909d391c75fb4683ede8647f2d29260592f1e713292024be0744145d9bac57da6a49d67beefbd0c59f87625eb326afe0ca5a92c33f54b8c3cc5f46e6f45b135b2979c01c75152ee2b202f6fa17ba3c26ebd95cdb4c208b2e0d1c64d0c9c27d4d5dbb02c225d1649b8e45b6e845a476eda179848a1290de53fca3b061e84d448c4e1771b36c2201bf7c1418fd5d706c65e897633c44b33e89bd156e846bd40e27f7e7508299e53cfbb396a8eddbba30c002c123d4b42e8dc883f01114369c87562cf47f2aeb5286495446e6a69eb9ef73e6aad8c5f2e84bc8b18cb507b8859348cd5d9c53ac45972530add3f2b38ef4e14141e8c56de7ed2367daa729dbe32aff71acb85fac2ae0ac30fc6136bea770f278a2605d3a32013b7f3fd48ce031a5248f80b3ab64a02e1089992d51222acf67f73edafd1bb5d98f680a6da2b96607ca6af2073e511499597f3d31f45b26814e138fc762968b36aaa3ccdfcaf571e2f991d0c8286a4bc38d64eec7a8b9e964ff6c67c3befdf5d59bcefd6f2701b728273b50e35b2a6c961f97ab9c27fc19e553dac3d50f4f5593f62fe1e865412a94e265fb29f83e3cc4b44cef91ff35467e01ba7a9256b7e1db90f1fb290d10d7b2bb158953bad9fcce5c8d1ccb3f4ce4f6b670c2479c4e2c6a2bdd603924ccef80f39230aba2c3ba1b7cf3daf8a9e2cac47c7ecd5237df243f425c78861f33dca1c7b8f0b92471f6d1d4cf395dc8d839b731d0d020d3c2294996c67907e657c18ede62190571b48930bb1fe14407a371e75e535989af0a31301df3cce5f773d4e364ada3c459b4073f91c3c02c6a123514ff2cf2d791d00ca5ad82e583e2cfffd2c96d94cafdf276173ee6c503a44c62ad489371d718faad3f8a5779c5f7e78326b128d131215994f1de42161e2dc7d13db0a8f34c38319f1fb841e73e9203d59f1b092c6f7dcb63ecf40823ce01137c75d5ac8695d3e4ecb8a4d0f2d4e370e38343ca244cd76ff1a2b32bccf4e02c1e148554eab2727b8836d888493325a8f64069dbdb6087a1644ae9feb3f1fa078810202e86f81ea69f9481e9bd69e5f2511f1eeb88a51de66ffaa96c10113d1b2c40e31c4bc153155c4e6aae05e4149b724e291bf0e9e612f3ceaf272737548c636c4fb1d33d0c667ee271abb197d6ae7a415fd555bde411c62d134417e96cd452f16ac3e04b567e0a293cbdff2ceaff2f63c0558c5df3bb37135728e829abcb3a8396a25532f1df8981daa7648d29b5e685deb3d79152069f9793520d9e6f99caa9a9538831d31307f797904691bfe3ac8b2b051b251509faaeb118369b981b183218fc97a24028a8379b7d92f577ad01be13bfc117f8f5af6fa91ccb8fc12efdc0bab1757d6feebbdd0c31e23a76bb25c27dc1bbf1b5fa7c570ce01e1ae6cdb7d6d21946b426222436cb8ae229b8c7eaf4b6084fcd958069b466a1a3bc4f26e4e8bcc77d48ff3a2101ebe238b42666859a67975897c3417c96bba7968df438f262a7e7cd68a13e49afe8a6350ccb4563512fd4cf1a51b2fd3d26e9d132d2f98be51b566a6a24e8ca8c8c5325eeab1b69c3744c223a9f2024a8e77c6f0808903c983db31eb67c98eebc2c661a72a04f1ed15b6423039e3ab4ec035043e109b5467bd26e3a044a58525f097824a3203643f94dff7758408be0bcdf7be740629ac0f84fde6bce060d35b575f23d421728f5c2a4f3201ab4e3a3c73c402b74679d534efd673e77ed64c66b8057cdfde051070be1057b1c10428905572947d9e75eb95a61a233f8d56c474ad281422f9edcbdc7d1223845661e9dbfa449ea5f8ce0a4e9e9c6555a2d9647ccdf607c45f31194c871e72976013553d1745cba74b608a3f70f69d5ab06bc8b1965e6a9ee48c1b1acb0f2b9c4dd518ed4c36bd5c710e475e2e6fd10e0569cee0352b30496e87852d8a6f0b69d2088145bff3156a91ad5ae0c6f683fb7d93c6cba61d7e448a8fe2884e6f3ef70a8dd501d48c4b3e60e961fe9c7118bb87aa1447933e3f0a869c9cb514f9e2f5d533a39d8f4a83a81907726d4a4f16a2ff55869a7144d2bebacd2061b8f1120927dc2db801d4fdc1a301134ee7eb9efecce823f9c16d4e45ece9ddc54b687b878b452b98faa241028ad9a21f887bbc80b6c72b45122ba3d8216f09303554abd50132260e4cbc08888e75aa623ae27ce96123ac5b4337869901ebe47fa704a7748f1a56c20ff2dfe15b40e34bfa93f715f7cb7b3b7bf56de90a4f0f9b7f8c74a0a896a243a04f8de68fae8e295b24e2e9f99bad5008422985db687a4e0351df7c336026bcb55386c3a362c31259920a53405354f90d1e739b8c874f264450ac650776d28b303778f70b4b0be5e2f295649ffca8de2ae0f01762a74dba5909d1f9728543c025e1e48d72de2f675a9427c2a54cad695e7493194f2ef3cb9584a9c9f84cbedb078660884237a19f3227f6355be7d06354ee9e36f3bdf1dd5d0ce9c14c8069e043876875ce18d3a5f9975ef66824cc17e79e6675ac6601c4b8f54ff7757964baacaa842ca9affd77a19a3e8bb73f3f8b18be1faa41075b40901b4266daf18b6d5df1ac683248a7211497e73edab44ae00b44bd635cce03ccfaeca8c20268a584badcd8fad124fe3e810113dc13542f3e99d120fe737fe2ee193ee312c1f8f366d228345be7e3f431d1f76739e7efd59c41a6027596206427cf87a15eed75f6723cc8fbbb721029d65ae22b411068617654759099055b6f42488cb7177989661eaac99afb3b924b2e54e104d9575ed5ec71e200731d943e5975d700f9e556e7850318b1c968c03fff62b3240e15bf1eed753c789a3b4db9f9b1aba692858052beff503f590fd04eccb1067c5635342b14b919a29deed7f9fcddb9045ce0841c6572e9ac3028def5cb094e006dd4bb43b47a8d2bd7567515d0f87c16ca392cf5c26ca5af269eeaa08b92ecd04ac629a6bbc0a6a5d89dc1b925add5525a5f1577c16863717dc202c805d274a07958da7269af536a18cb57a0efc92d2190674d7e71fa20968b3c053bd738c2bebd16038f095dc12a261f8398e47736a3897f56d3f1424c15191399b58eb0238d2da35c844ef6cd2bd2612d0ca429c7fc1253d1f41ad3c4cf070efdfa48c08a1bf5d91b2d40596998c782d4caf6a255f22ec69d4a76bd0904144f8124a565b75c971b7aad4a46135a86648e899f816525474e2924063457304dc75688ce5a219c5afb8ace7caa3ff9748b5fa853fcaf4fe9af1d571074750d8e6404d26d649c3460e5cb25f9c6a6900f65e15f60d4d52cc1b1c2fbd4583b91e9a024fa82e0e5e46783fdb98ef7c667844383a463633ae47a081bc06c93a5e7e6167978776fd279a1a66b3f82c107851854c90440161ad4e14f5a54908b06d30efef55f2dc495bd03eab2101d3f3e3adc08e74d988e43665a5f57d84997fbeea3bfdec21208acbf9d83d2c2682af1bd7de7686526fb79ba04a46f2dbada58e413443224053121aba271696fbbf484d4c2df9fe4fc815e8c0bbd000d4b2e891682ca26ce187562ef93d3340fc6190f1717258bc5aa5f1e16c348ad02de5dc31150c3fc0fb39594266e61418fa318fe34bac9de529f35454b16cab9b1a12596c9d0b66081871485961271d7c4c80044819177bd2e3ff5756275ad826c91158fd09b8b64761687737cbda145d3d3ede39c981ae9be68bff0fc8641e2f5fdf176f516b1cbe84dbd1ca53ba37a68032912f715dce96f1c4d93969dd0d85294e7e9248576b6c0441b7a74a9511b6295dd98fc80553f6451fd9baafcf3fcabbdb5b67963858c77689fc785dc820d87ff5dfd23ed34e137a437ccc55ffe2348898835625e7a4f3cdc6f46c43c41da15dd706d37a08393a0a44f2b9df398bb3daaa15ff5bb37cc50400c0a2235a59bb44bd46547c1b87c08fe6f503943de416c77babf0869c7baa0aa5124164b86a9613980bf035af7cc72cc645c261f23f65c756e6d9a5ab75a4474356b2d51191cf11ffe07a682c3c2cd30f6f41a682d5cc32fe54e3219414a8f2a59be736dde1e760d1f02adea917b1680ace79723b29160cedd8da3b8881ea2214296c0964c3587794bdccb18c52383d5552bf82a3504323045be0567ec09639b2000ea3c403ec739b9b03c83f37cae7210bb56b43c83f1aa3bf7c7a271486eaa966a31742c0aec1c60b53b93527e349776ab5ecb73bd1831c0da7add69425c4cab11c6ca2790ec7ea3d578347e7b2fabadd0fc1186e75c76be11609527d216adab9ca01884578c59a83e64cbbc1bfec0d694db2ba94eae5470a98a81b4914f14bfe3b5b2fd8bf25dcd96237cc3ed53b6787ce021dc94f0f472a67a811c242eab4336a14f54d051be5c0daeb479a30d862d900021f170546ea0bff3de02013cc14a53180015830fe17fdc36af5f22b8d574b8200469464987e25fd727552205a1a13b5affd6a68b14754a8f2370f1f9d9a794213e248284787361336aac2b6fdd626617ceea35ed0101f0a14f675e58411e12d61d45e2be70c690643503b6f3ff7d2078f4ddfec5206d616f24b540abf33970bfcda7ee31486ace92e55a777cf3617a83943ab114237e0f883b43a972ba42346fae9baf5420c0b44f7514eab119c32533e7f5d29dc80a6599ef69db5be990bb1799b76095cf245a27de373f3d625b2eb89df8298674fea56fb48308d1ac37d6061830e0de434bc6949f78aa7b72d3652ac4126877020d5e67711be7fa23bc94dce7b0fcc20402074105f99133052cde6ad1d9799421360e32a34631d21b48694ab71b6a0cc149e3fa67447b6c7a76db48ab2094b6f7d182305fab597e47f72a05110d2ffb3b31a8d5b2a60a94faaca682adbba6dd6bfda994269a7dc88d6202d19a8f2d724b01ce306d2eddf10373f32f2f566e6793c95612ea64fc6f487a6e5b5f0c83fdd81e115e0872a23cf178f35a14ab6032d56b1ec0d21cbfee6f02b956d74f96bdc3a2d51cd7ea594b88fcae5dea6fec35f6c7110fbcf8622c11bfb6f741d1eddc1d85070a57aac66c22372d6dcdf74214d45c12ec42db3af42a2b6a5652b6ef962157e253f514bafc247137c3ef50913ee6341ea63b44de08198cfa4e70e9249722f00cdd359c55209ecfd693081f63024e3eb4485179cf463b5102c4fe9abb84ed9594a27a161f294cd67bc73d1c43753f299e4b1fa6550f0700f31cbe9cdbadc20cc53d1b40b664e0141e4ce9cdfd85036212492bfe21d4812861b7bc1df979b0f652c7b869b04bad9cf82fe3d46d51b9c52437d728e873ba92044f2d9d644cc9f6d6edf3e2a784de53ab6e7de0ee8d98383ef879fa5d68adf2bbdee746bcb4f3606c338658cab0ff7c5dd2c301e78bf84fc3e3c18a5ce32da3e570e472cea7f56c53e055774ae67e3add9a98eed1f10aff5938a3edc318a993c74924179e36f961bcd780527c49431e83e37d15b29150116ef3e927c99c6541c79eb4a1ee4851fbd47ff34204da55e4ae68d3a33421a3d5769682faaa249a6fa1c1bcc681c52a6b666127c7d24ebcac187a28015909a50ef30ef6bc2aae0d5846eb87a19db6fafc15e742bc676357823de0c55beb0b15d531a79ef465e0c1d83d1354957fadd5ea57ad71a4e67be332c744851bf2867c589b72250726840ef63293613f4a1eaea47f98779635d1f024fb0ae3df86d3fff02482a8ad54a03a239a567bd58336aa1cfa93deab65b4de7e7fe45fef3e160957fc055983b2feec36f0262527fbc3257afe6ef1e9caca612b21a5b8fd33f938c5dc2869dcf64b9671d8c468a877b1f7f87af62a3e26a9c88cb81e53870611da285d5969ac2c725a92aa7fc1043b68fa97835f1f5de7c44a2913ec99c95e6e48caa0903b969bb45351ec0f64c61c8c3e77e0fcef1bdfae4cc613c34cc633445fc8ebca363f1cec37124f9ce7ebd6a5756a5febb7e1032fbf7a5a90af76b86f6de200f37be29c4a62096b8706c254812d3a1a24fb173a9aa9c5f549ea9ff9a1399795eeffa7f4df93bf9681973de2f9b88b058437f8e6c81031afe39db9b6261183a03d58a1fbcd0628e24774edcb43b3af9be72a438ed9ccddd559d05ee926c520bbf9ce86bc50196c8167f016fe690314b33eaf191e1ce3ae555c70739347e32cea53d1dec424f4ef3d4999a60667b79fd96a1e0423ca0d67034dbdd079bcdef60d1926377142653919399d423596badb74f8aca0efa1b3dfe732f20b674e9a3bd9ce9ab381d4dcdb286d6dff3dd6cb8cccc6418b0b129d0289199f52c4ca56ea018111e5009be29237c6ecb034bbe6e9bdf7f2c79b523b196e319c6ea22a329daa0ebcf38d04c0e9a48ca3e40fd3c89b6f36ea6fe4f2102e2754b55dc0b5a562f40ec68dd95cd3810a0a158cd34512db80c8d64e39a6807b94890e40d10b10d8a299c38ad23e78f0fc43c1b426fd2fad599a15656142ea8b12b2582a266af45cdc80876daad46eb8865799eee2ac7d031a24deb85f6189f0fa69d85f464d0341e1d2041fa7bdba627b7f112cef872c1ebeabbae381e3da38185f1d310120be289787c8cc7d8b28d44a644fd2d89c1a151633d3a4c1cf434719c9ad6675e0ad288ddf05b890a96398516a13cc6d3e38c17f5f3f25cefe08c0da148fa7d5ebc582ca9c2f5d2fe4e794a54c5bfd394d6680bfedcac9f8737107f1529b325bf56850cedc21fbb2986644f8235f5a536f31ee5f164f03c0d3f608a66e8d87331fc2942a35e37dd070ff5780f57f0e09ff88abd2397d54355e2c683cb4f2d6e2539fb512b5997c282bec7497d938fdcf794b7af737353aefd4a2a1f222e6c99639deedb53afc667d9809df426ac2d2c1c25e0b4f7d4836cf32ee052781eabad16e20c091be39b2cf4fd431f056ad23fd7966056b8de84e1f40a78d21d46ba1eb585fdc062a441473f0023f0330fca59b64846b590c469a588db090b5930857c591acae6ffb20766a5f073c1a1ef1fa1e55e88089a269530344ac5ed5d92ba24f27a42605d16dd2462627aaa2bd6c482ea42cd50b253732764f37065ec7d1f27360be05ecce42cde93bf8700e755d720b948dff364c29043584f72de2bb97771b5163a7903bd18e361a364a5086f4c5de8625b247c20c7fd61339eda69e89c6d2a539ff9c4328ba81514d06fbb363e5cb1cf97146ab4d66438f2e84b71ab931bb88f3a81a1ab971749960a9e83c5d15cd75b34f63b507f438ec91e40a73c413e5527ca4ffe4340941f249b1c23367776f4633b4a687e119d49d3343e4fd9e363a367a846987e2e57f57848d19fa27597e87774396ebe728041eee29ae8dfa6445f907c30f81c792e64b32e0cc210a8fc843f4c0c40e9cefae665048b3c93c714e274a3e85f8e1a210a00aaeab2b819d2353bdb0faad381f34dc95070f819c810d4e832682ee0c2bda942fd34910b0ebe90b7c5a00835f57b463adbffc046ee1058583c1e5f9c795264a3c9b9c97b9f86a9dadebd208014b32ac2a8e76cc85d11e7aab68ad5f245b7935f749d12c52f17371750f855d33ab9468306e11084c77209509f04a73f5a80b230a2de5d0d4fec58ee56eccb89413db98d54904b78f4d66d1f39529bbc109b2418b454e542633e1944aaffe60345b273034325910b1a88605533c4f1722bdfa000e5635f7c7072cee7da8c2ff00f04bd3d6d914dc82cdbb44dc3cde2aa6c28b6268f0b77af36fcdca4414344c4de6f55a8981204c1fb99ccdc9fce4fa7d46b01763d71301c14113ff8d575b4c615f870d79a9faa6a2a11bb789aa76b37158c0de1070aa2f0207be526edcaf845ab0c3caba4f4ff3ab097b54f513eaef42bd018dc2cfd9c8b262121a787758bb6fc51bdbb9f6fec3dc4e24e21c29e96d47b0db6f0ad329f643179594be5f9fc1cd896a9efefcf3f5c3d398323373b9feccf641492873643ac119361d1b2645d1f0aa2b246208d4c62dc6d4005bf6cd54f8ca22756cee78c8cd11aadc681d5c34d8061fcd385ba80affe6cb9d7665e854e8a4cc8ccc62ab42e59875f967a8317924aa520ea13b9b7fb39ad51f8742c0307b339f51fee3d4c4f1472c16c45c46262ab143f827d9ddf9a5b16e74839017a195acd567345f57a7d5f0144801a4312a7184efab24245b4543a9cf0773d2885d07c60698544c799e253e2da7d18b294d8fe58ee030810e4005b895c70ea9bd5553d9d4cd16b8a11fda7d851fe439eb3ad88feb532f6d4940ffff6c81a3f3c16c495210281ec588a0b3bafe4d256183af99701407d1e42429ce849e5343d950d98aca0811aad93acd0e13e34fd477055045e7dadad5c95a88fb4bbb12861d65ed13ae465c89aabf7a6061b756ed9a9737ce00c695d5270bbde13f6ce14f9723ecdcbe25a730d25b141923ae67dc9c5c40a90f37320e69dff68dc157ba67c660f361e37961f177068d6858d7a762a229d54678f6a3a2bd8858accc4f108c236ead4ab98f41c7fe4f72709f04d0ca2c51720e3e76e08f50ab76308436af701eaff8d32a5802991a93b5bcec2e96a0c505d5ba7973b4c43f4695f446baad7afc7ad36f53ae78c45e527dde5358b44810d43c68b41e6ec44e48b5e32663430bcca7b90f006391fe87871be12a31a658f6b6b762679e737eef7f433b8f7ceaa004274325bcee55059b5240f66fedfa4558d6df36236f1adafb9062cdcd7f3f09cdc4dd9023a558ab611d0aada4ffeae085c7d42bc513892306ffb747f52acf542bede03c11b3df86bb24232855e1523120b0acfbfd3d7276cf8d0264c02acd57a457276f3f2cee18c55b00225f9e762b216e6a65c4b6a0b057d39a5711da005e23fce78faf60cd513df36805bf5119bd3fd2aeaa2aff21edd10a05dcd1036dca234869e08b413b1b306eac95a3fab1e5ee848ab7417ba499d5d07d80534456a689156b47672360297178b447729f8e4033286b16b85e47c37b52e16949832bc88796abcf1851b167a8b069ea524d4139b648e338658ae9773b6a84ed63f1319f5baaf2306000f80135e6553d1be89f327a4d7531ab3d6d38f2eab6984cd962b135b346d37fcaed328dd985e87b64e392611c9cd8cffa17d9b6084e7381863d8a1117ab24aa05b800b973d6e705d35d1edcd470f512306a58cd6bd93493b644f67971c37023b5acf4862e309a0ff9de9004f691bbd086e4d4bcf4e891d261feba0aa7d21068dad6c8e7db5cd8df12d9eff81863fd2f939d539e5a0b90d222221e421a9cb260d043ad529984c2afc05ebebbee23d53836f8c6ce2015e26c261af082e8dc7824073b2588ff101b6188e29dcd078ff49ff9f8150714fbcaabedab5ae80d07085f2351c0de742ab6c888993eaaf3d665bb4ad989cead7844e850f5cd141625a5396775e473f5cb412e9b202ed00359ade88094dfe5e9e02e5547806f01743a15a8f8a5ab6c6b9be3cceae72b3decad1a2a3521b5a7caa1d215f7b3e4d6f91b4d0a6ceeb7323226305ce0aed7692f08514ea9143dd28981b26363e5449129ef48d18510992dc96cbad4104544f2cfb998a91f9632c2a43d946d6c21803b233a345842612fa2a20995d9d37e5c70ad9685f259cdee500e9c8288a7b05faf9bd0bce49726ddb70146598a8871da58bf8293c7bfcee54ac9f720f90c6f536f46a53c1f6abf6920999574ce444232a0ac253da89834e1e58c8c182282c8fc139585b427b1a01bc8291479eb87d98231d518efffe56291f819b942c3854b6fa12368fc483288b015496f61cd23d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
