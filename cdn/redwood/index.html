<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c27cee184b2d8332028592929fdce83020a32e5377dadddc1c2a8d64a031bb0b3c56909339c916126ea8c6a2537f13ede7b9e7900eac688977dffcb2ccbe029e2476e878e3b313f4cad889de4fd01d9720ab4906bbf86b014d9b5452ccc1b8dfe6ba2bc09d86e72c7e4badbaa968782a08c875b25e4e303c18d24cb85d8cd3cd9a02a94dcc7efaf7dc2b65aaf09841c6a9eababbb39685e328072b6edba0b721d44b08435bfaa266fdf10007551748db7e43735794c89142a70448ce83a542177eab9cfda8c399e467ed1ee5fe5aed5e0d3f1323609852ccdd375fbeb54561fe8b30734a4b264664a821e8cdba87a6dd8f02444deeea6ab70a6831c0c63270b38575b8ce7e5c84bb8e0611572457717b7fff24c798379fc0261b7487da938dde8ead4814caf1fca3d6cc6545bf70f78713431aeab4999931a718c5ea8ea477dd5351a0ee9a658b61b3a3ffcff2adbce858ecaa56ad2171d441fb8789d06535afe24488426ffe4ca910b7c7b3e9809207f55e5f0ebec0d887e0a915d630b29ed51486b75237b3d58368b756afc79ce6badf9e209d98283011ffb7eede55177702b82dcbca983191867a143b018539a6a1c9f81b8521957b32892710ef1fda9160e57201f028049aa8fbec0525a26a291f3e6c59490351b7f4302ba86ccad237a0cd5b909dcc30798dcc6b0d23e418157217b2de979fa71dbe1fd96ca8d05ee599c6afc92e9278fe8d806599d3501564732b7baa8cae223d0972514256528dab6abd4cfac032fc2aea1a56d50b8abcc0fb0e60ed95e8668fbd2cdbab3026ff541ca45ddde56e36dea4e039cd18ae0cbba8c32f9e02bb661777cc0312caf66aadb9eeb0c16334c74e8a4b4e74b8127b2413d37bff21e0f88d71c7795453ed7cc704523443798fbcdba40ddd6611dd08ca4e79d77604149fae950bdbc139ca14d2d2961d9d93a08d23e61a562ba1b8e52c948589c149ea7f2cb09cef0ead32cd964ef7fc0bc5017b95a2153fbc3095294b4e7a326f35e7658f61ef2b333bf1ead49e1c93786554e35fbad7a09c714e9ac69896c92f24dd73b23e907dae03467c9d5493ee4603c73f4c868fa1b57f341908c7a9832e2fe264c5a91eb4e205988052ceef20b4a78b2c7c4ea05e21b4ec51aee92743eb56352e62323742bcbb3b425b93bec199c2dd288f32896943092f41abf9afd74741c6166e2413aeb70f2180cbbf080f6eb3bd585eff5b17dd5f109bc2733c23281e0c9542b164f4d0095dfd06ed68e1b9efc76a3842047a79a3ba7b6bb6bf49ffb75d452824643c019085d9d4d8559ee9473c172fe2289b02365324577ab66ef3a56f36ea2daf769fff941819f90011450223fa8e61dd28d7fbf32505ce7871e1e7a3a8ae8bb8bfd3a60842003f1be3a4d6ed2dc3146fb95e0d14d3647bb2b29e4f4ed0eab77901f6337c6bf97309c19582729b6d4f39ff0613780e2f4b32ae02ab44a3fc061e480a5e9ef3bae04a9f5f8ef53b2b7b86ac82597204e7caa29acb64761161397d2bb7e1330f6e330c7ae712c235d015a269dd00a3ca350b9ba8f7ed891f90f5e5870d3b764fbbec3e65e1902b35bd7da040adcead815c45fb10c092bac7f96b58cf1f27c01bfe6d113e847e5cd56a1e670ea23e76bfbb580ee0541b71f154e1435a4aa71b0dc4ffc5340f195a8db6783fc45fa050faeb6be947c861f434749f7e220fd89720a33e65dc731e99ace5a4c4dc666dcc9f8e33f3bcc2048a24646030c115dffa25b8beacfdc15375dafb7c7053a313bebfe27312ade11e2a4dcd1e1e67803c7255342c3b872fa23f9ecc6394394912132951438c31ddd6de14472ff923f3a5d3f215c9e586551d99d8962047337861e50303bc5fd2cb1638166b93446757610a215795423fcbe35b0d9e86df59c79633c3a4163e4e77538d7fa5abe2aa7aed2d3298d167edbfb81e31cdeec8089e040416f06854602fea4a1893da483a17c1de810d38ad0e544e830c1a7bbd3a68f949531d58c11d0932e17624e6b8863905d4586a9530c2ce05bf3653859196f1f7a54526c83e60143e7aa48ea9776ba876db1671fb59290df92684996b0504b7911556fcafc2c941b7fb15563f11583d694f618cf8693b616dfbc20a7398c1bf5e2fab37419decb2cfe6a9f43de409b7c11b49bede9fbb8455ead988a2a1dd6e2ea8f5ad5b4180e90fe479ae7c2c943921e6c88866202ce3bcd44f021868a67cec6ff7dee434b67b9a053b9c5ccd76185e0073a6059701d282e37ce12bcf432c962e639f688ea9bbcadf66d781837dbe296c51c48f3b227ace5624b36c17d41aac1762d9e23a11ac0b24c4e8c2a7693c4bf326e0e9a1407d59eecb5a0e135327b016a10819da9cd35bd79cfdda9ae00f2f8e2279e924172104b84171f371bd950761cf58954ac5a77e5d33888eb4b37ede8de30da060745dfcb3961a0370d22445c4c87b92fbfd89cdc102d4baaff088d06afc4c367bad1b6d92e77d28be66874ef823d09a01e4ba5420b98b13130d9e6385f659152d9ae2091d0b8087f39091ed8465fd3656a228e34441615ffbe702a271356b1da0edc87aa338b4215249cfe702f32c0bbe5f2aca304500f2559d40fc4a9e3d5e9faa27c040408207b1d8db56c36e5c5d175e989c29fee7c8b647e59e0fc6339614754efa177a74d8e1089310a99c5f2fda5323d7b1523c6557dca238407cade5a5e63b9b288ca849323ace9398ec30724462c95c8f1ff477cb226e9edfde6b3c13aecb890982e9256c7fe8cfffd42a3ceac0c8ac39bd367ec79c9cb9083e859d9a103b18219e52887f1e35fbde020bb9b1ef0f68cf40c4072e3bad4f718f4438b9524af57b8fbdb9f504488592576ba6635a4722836c0afac90af516d9237c60e2983a2c9ca8e469014af6570ea6833e237b0d1e0c7603831430c30b80d6bf22cf8549645f90437e306d72e0b7c4925b49b26160da0358c7a2bbfc478901b20c620f90c17718b2e8f995cfcf78c09e4682b5c755da86202adb5ff434f3dc085c3bf3ad87ceb24aee7ba05e287ec0f3d585c95b0653eaaf1e68b10d6db36837876fca8183a6f2e8edf41cdcac2b3f25a43c2d3be56732e1d89dc7a8a969553b17ffa07e5bf02e6ea1b1dcca4bf810092eb07f9bec77fc56285bf1a1e0cf7ae92f003a70dc4b95b303245303a15276d438fb48dfd6603eea9c3e0634e824543d048e66acf4c50c4f0a1d81118aacfe0861d05202e878f6fb7cd68c1296e1385dff46c3e6e5e25c8255c4ab4d4c56f41b89fc597287b6751e6df9a736933121d88ec75554e79f081b204ba99191c2942cd7740f7d521548c6c8e2a43f4c3adcc742651e754174eff0aeea8d8a9cd0a82c9e4b6ed2a60b5094141d10ac8e39991f23b227db2ef91370a9afe7aec81dde6c293c0e0a1cba4c06020e09f02c8ca926d6081906ac73f3ca6dbdc5d09affc58d2f744667abc91f6a8540c6988f66fe85ff41d791af779e284aca1ec6736f50fc4451b0273632f3b7f9ddc70250ebc24a0719743e9bf191c78ba9825ad92061748befdeece95072529072474a798d3aa43830eb0c1159a15597b4b0dbe881e680054dfba1584e08dad5dd5b17885a21d4b329121aefd27064b99040ed697f1bb29fa39a4564719cec7a32c4776c6f5aeb1fdd81f0d39570a7584c655ae357cac14be3f93833d6494782ef78ebbd7eef354f8803fb47f388ec9077c766ea2806cebd2d39b854b3d5f5a31c0b2ec0cd4a2dfd8dad0d37d689caa921957a9624d4d818fa661a78f001f861184834ec0925aeab9b7cb344b32e7cbf98e8aaef98a77ecc36fbe54c30e2afd79caeff142b89a16175d3b74dcdbd0028946b491328ed7510b595e1aae66b0779e523caa9256d7ed9500895b16d43c2a3fb904c062f6b568cb6289d7394180750bd92c4d4924d497b70e38154da6ced7b0b233f798d090a8d61aa11eccc06295de84e873352e65dcc4c434d1e796cd6128fc91017d2281af63075ec8f28807f291e7cd3258aedeffd0b3fe0a2e0b12cfbed984677c6fb82d9178fd9a62ca3ff69513c0ad4471c9a4e9e02b1c0d5ef0536f38f9cff05e44d82967cfd903d42aaf32a18587b57e9717f84530a476a5455f660d2b46b4e84bb4b0a5c984a524e1e6fa922d20cf1cf1ff0634d46a0ec14e5af756edc66466d1916e2a6c0f58d4f6b1ace19aaba8eeb86ee05971e5025c6c0c81ea3dbb6f9ff3375d682ab1ac0e95794c8f14923ec9c7b81518c87b3c03efaaed85a7f1fd3e6ef32e2f9e36ec55a87d74cc43ea55802022eaeab4275c9c10633cd4580d6005ce462a7a97d3b9afc3ec30687506e5690a4faf25a304e0dcf3b192ca1177c950f0d17edd1ac52b36327c1bb7697e58f16197b198db9d64099fefa5eb246d9f72c28cab4156c2b58be21a6a599a9033137e0e4e2a4179506402b4366ca417f662c6db0882de385b8082cb0ae5d545c7944545e224d9b6dcd24c91eff5c7db2d9f036ce256087afec195d82b825ac84e756bd4a0fffd634d6b4f2c29ef47908a26d1d186d2d3b9b11009063c695e4fbe9be5083982d033ad1e150eb84685fe9d2ae7703b8ae224278040c092e9d3ba890ccc6be2ef71a39b1e8f5b013210a14c6d07ff652029fc3dfb204b09f0b5b4b8a4d329e9ecba8b859e1843c186f1d74803edc1a33f938dea672e958c27970aa0b8ac0ad3336240cc755bffff77c93fe199bc65ba49dd64d2f36596c230157b944a5c3ee1986095786a96070d4703dbf7b435bb78207ed5226f7a388bb1fa515a6cf15dd8e93a8f195c495b86db1134042cd34da151562a7188912b57d7f7e325ffceac53a252bae5e543f656bf547e590dc9bba1ed3fa438d83d5600d14ae534676824a33f4268b19d7c26a6d1f084c80cdc47ab56f47e09f198213d06e2ca8fc1c6d2f8c9803476ce530f36d386973ec7e112e7c64fb10abe948b8e9213d49eda08491e72017531fc34e24cb99920dad62ee537c59f53b7882f63e0389837e049509345f3cc05d4e2321fefc53378cd5bfceb9efbbf159d556dc1a416bc9c3b815eb7234d52db9a90d452f014cc8a16dad795bca121db5159344b2dbcd7d2f126416347c46f528091ca0dfe7482db2432c3eee672d7f971d3a4929e8f6c361f3a6b5caf5f7db55f07497e9b90033c6d394c9f4a46fda258a8bfe9724a5fe2b72351a53c5a6383c71e27949cadbbb091f2e12d779be82861b6d6b4e4b43d61eb3312f5acc5cb8cac527746ebd7f3588522e24875c02736a3f202028a94edefad5c1d046f39a3fb1cbcd08d4fc7f8ab69902055def8822a2241bc23fde1e937c738e307350821d0d0598a220bfee98c8a2eecec27863b594dfc359d999862eefd7c1a4f02773e876941bec33c28a6c950d0fada29b3799a7cb046cdb5f4b2fb265c2f936fc9ee9b1566faa987b13dd3759b3ac3905cfba0f6511251f2623857c82e0eec728b2fd9eb5284d2c99cf8c1ef57cdec1e143dcfaa4a819d3dc4a7d1742210ef6ef42dff6343546641bc2e2a335f5c37e86aad4fba8a5e943a06fc823275f9751440a3c9e551ac078d971a3cff2cdb595fdd0d041dc54c374fe90e1cff506c50290d88d1dcd19f7e0e0e8c86c3e684c5ac7c6230568893d392f6e294f3a09339058294f2e5ae847fac51680e69368e98b24c5ee7f61cd04e41b7252ebc5442830a3cca9b85a41b18926dad7d66ecfe122c51cc0f9ef57da0d44d6540631048bd2f64b106ed2af749b6eaeaeebd717e15b2bf418f87597a5668289b1a728db2dad8015824f0356763f58371c663ca6d8a4b17aafef22c039b9104a28e2816b26d27b6e021ce3ba50210ee64b3b94a9c76de6c03c6fd6c1a6d5f2adb06f85a4587933867186a5833fff9ec2040cab459e7d468a966237263bf693bb333198e6eb924d6fa99c4d23d2afe772ca79c7e9ea4f3b7bccdcb541be9b4e67fb09d90d8239a5324fdc2acb0cd8248a815abe053fd38eede7cbd54093f9a6edeb394b749d1896836930eb5149897c1839c01a92bb2c77e39a65b3b07df6fcde70c351f6db6e1d268ad638d2d5dc4cd13298d74772f4de535bf534d8a3bfa86dd4408490b417bb0feba3b1b70719b0ac6eaf5354dc608e608045a8e77eab8594e0deb3d402e9b4edd3463da21525d7f4b3f0cdc2b0c62631bbff53249abd8e92ae4556aa0bba1ff94ebbba8d65acd933425b4095c332888bd7e6f270123c8c5ee554d13e9274147963e1d094107517186fed628f5b2a0f80a68bc6203c51e36e006d64131c109ab93a53c69d5cff8a3a8c95e370d61ded33f984d7db3effcb775980256b1f44e1acb0638b0e2e361b5a2900dcba1e7bda922b215c25fb24d59c8ce08b41bec11763a8476a947a518c5f54ea2cc18c228bf27b16be0e855523960c273e3f3b1eb1aeecfcb056c8c2fb079c00f7f653ed35b5e4120fe5d69f54d90e7f37a0b34a072ec001f43d81dc268eea4575cb901c7c695fed47760618748743f56724ce1a1077cb3be6c2f0476a0026dc21b5c84811b8daf709353b5422e6043e5bf9ac1f213bc6b3622865d6fe2bff87ff463700add3c75b54f7dad79c8ae4d4b064baa8d673582417ce40ee1b6ad2274163500f036d001c22ca369fb1fe0cebff583d2e493125f4d15bcd46409f5d618c5c69c4ea40d7f6d9bd17495611c96fb7f3dfa8175ab8f8b00e45827a1c802ebb7ad20f35a3778993fd734fee770cec5ac4cdc597b4bf55ce4c7c14ed42275fee9454af611a85fc0284453295e5937d8e4a13a6ed3a4ff224357ab77403095a41fb8ca4313fb4eaa874f12cb745756ce79119531caf58b85a63eed64932e7a49a3fe52525647980e8b32135b49ec45d4ecc1f2003a7b0775cee740f1c26ca53b36c7051772742aaba72815297dc4408f4d2c11bd9d06819e90a02ebdceb29b9356859735fb05629f177d009934a965c440c58eada33cbe835db16cdf1cede9a0b521290c99a78152bf2d4167ccbfa78de703f74099a90e1b8c35b4567d3f65500766d54d1d6f24196c8e3841d4d4e358512912021dd8b89ebca0a2fd52465008d0b331b82257016994980e0077b585856912868516a3b6b4afd03860d877b666e94e260204e7f26cf5bea945df8fe249143c27a06f80d5abc51390ba63632f94de3c07d13b1863a0bf41a1e131fdea8d2ba336363dc3ce2bf3c67694724f5efef94944c77bae79c8310e778cee5857e6cc6b6be339b3f368325b19d2ab7a0433898966347cd995d306aa37ac0b8741b59c01e1ab8836b90e03385a2d6714caa50cb2c3655698803ac7eec9f3c0ff354c4d52ffbc5038f0a40644ad41146cb99dcf3bd61ca9cc54cff2b73a5c49dbe71201c64ae484537a43a947272a5836d3c807027d5cbc74b8ecc09005b29ab78a2ae1f898c9301a05b7fd7e688ebf8e3d27e6c7675ac5ca571c48223b15f22b0fcc48a9ffbefdeba994620e891ddcdb52e9998788f3cecd634ce4fb0df595f885fe19ebd02fa44997e5e4f22880aa41cc0aa349f0bd58bd6bf996e940a06c7b430c00be2fbb6c8282d3d118b583fe1bff8382dd9a8101900c29eeda708fc36db50d308efa63cd4819d7f503bd9136750544116edf7d00a351e41100f84c6a5c461d03205bffdb27011b34ceb4db5cb31e97807d54d9778a6ba1d56d5413452673fdcad98c6ba05ea0e5ca89dcd1ae26386aad06a86f90633359632f7f616d53812b3f1e7267e84dadda892b3a65218e54a5e868bf9b413ab46ad524c9b1954886a551c02a49b540ce71f14002bf94a7736dce24002efdb8f60845168e1aee741f9099619538d7aec3fe678e7305482211d0a99c389934664f16c0613b542436b415345a395c1dc2e05bccd619c07230aeaae476930122653edafc46005eac7fba0fa8fd48ec0294f2ae554fdeb863b9a4ad70e4bd44d54a5aa4090e4aaaf58aa08373b79dcce2f1af70cb1594fb54ca3da81363cf9cf7a4b2e565c571acd1b5de0809e10d312c58d552bdd6e290522393d1999a0defedf709ca065cc15025296166a39f2bd612f9771f2a2993cbfd2707f18a7c819b7ee4afa853fd1f5f08162c8de2c3a33253e3456b2609ee8744fc68a6e0bb120873989aed71ff208d28971e7c22c07546553ca1456e72162fd8aeba25a7e3c60adfdefbc888c531801ddcc40f830e90121c01a8919e6d14d35f9a36f0d0c606379420f06ef73e9ad2294f76ba76c6b469854bc2058a7e57f2555483bf641270f89b21cdef29f0fa79c1e547d36d9d76e2e455174b1cfe46f3b07c5779317661c65778c3fc50d3c8804b998aab0703fec4b4ad1377936b0c89b5a67660443d6e77873f7f5df93808193595b8d6ff8d95f255563c5fb0bda862f72a3fe9974baaddfdb0c883b94e15b505f1049dacbf7aa00ec5a3a3debdc1613a983c0ca323924efb6aecd96380b1a854595146fb5b914a07720ca5b2213eae695402960539875f0a5e92044e1ec8f8a20ba0ab9af80cc879c1c4b4ad1aa45167706e7555cc09254aa86ff55ee57dca7e493bd0f847c3a72bc55830fa31562b51c38159663fa044cbff01cb5045c3f6ed988bc529fd8bfd6b7fdcb7cc7a178cc322dcdbbcf4bcd0c2e21edc91e02644658956242fb1cd0d84cc918249c97ac9682037e6cedb10818ae30dab19d15701853935f2869757ceb77900793668cdaacec2dff4a875c941784c5e1f7d46e4d1fe4c4d8357a53d42cf06969e35b9c162efa98a9c8b7d2a8f577b94d6e6dcffce8c321d3886ebd19aaf70ad3c8f0f1ce78c978fd7433e3139d39e4bef36e8e1b27be1576109221435352eab1e570a7318baeb2b37ff2819544abfdf4bb6710611c19ab5ea30091fb62f88cfaa8c71be1c6887568a8e65a2b9a3573de80be5ab82760e77c013ebe408087eb2fc73f4657c24e09c091b2c375d2df72caf17acdedcf77923f7544440395340987b28b8f805ff2bb242f1162189293430bd2510dc762bb7fc3755368febdf04b7ae59bf7a2ff34d758e36355b5aed0d043b07f343228746a551a8fb2593f4eb645f7e3db7012ff98542f3ed7cad112536b4033cd3fadcecb9af78093dd4152e5422676cf6f6b324f3a0a635a1e88989b8957ec2fccedbc8ccdc49a5eb211f4ab56b838222130fef47f206ba5bebd1218f5f460a0c2b503d646230c5a85fbcbdd6ca60117a0ed9dc3c6b16db51f46ec0b8e4f186fb11c5be0b617e1a57520904b196bf56b315f932f8c3f39435dd67bcf83315cd3f2ef63897f50a2d7f25e6d89640adbf126d0c3f0be34ed0c8ffef8044f2e30ef4bb8934513f09e8d8d18189058b12eb4de253c3141cc7452398ad7cb0771197e748ce1018a2e9617dbf8ad3325d9596acb88c83248a700f1a4a777f25fdd10e72517c6b9f789574056b8c2fb28c2572452caacdebc84cfb5bf22f974da24f1a5419f6e36d96850749e2049a61e738fbcaa609b91ecbb60a594c430994c082dad98771e2831254068aba93dcca505a38f79d0986e07fa261ba1e9ddeda43ad233ab17e895fc07158841c3b0b2f6a3b8c7ca0f3b5a0dd9bfc03fe3fcf75be12af9ad1c057b64974d4b3798b0d1568a84564a0ded66ad219dab8be1b8facbe89e5f51a3455a9f5850aa15dbb18dbf2b690ebb46c90863d28bc9abf2dbd1bd86f383d50588e7d963f1a2a503fce3e7a5ad9d6ca98b06c16e5f713ec3658a18ce79b27c8d8270804f050445671694a4dca602b5d8a94b8a9cd2055f4326bfecfb802f7c9302b04f23cffe8758a6026b5f60029cec099ec5bed1453dbc427b281527e38d67bcb8cd63488b88a1de7c84a58b5fcf1672923afefb875ab7b3291d66c721114217af05417f3daa3476761918f5fd7ae75a9d1c41a7c8f5b0769ac20596b752cb92ab6e0e18fb9c974dd1e8a6b9348c857f06d2d2dd807e1cd7173bf05066129d2365e84d1db3271f16f0d3cfaca38dbdcf64029daa30d9e715f091fb13d084311e622983cf05d1a6bfe3200a19ef3614fedd7c664c052bb8f8527abeff1bd32eb27fb0c1c14163e5e6cfa767bd25374cb21443665d0009901ea60fdd130cafd99fb7a4c654166b4181ce1b4338c64e7e7a3347530cbc701df8506d0694e1b15640653c02d7596e25fe04624dd2e3d3de9f177c1d5fe2d6ec89ceb4e11ee597dba194a1b3787646b08ce50ce93c63a948482149725a5e753e655e5b6e2e4d6c510bf93d291a98e48373d342d90b51196575f607adec935ecba4b43ae2eb2f3f3313cbdb46660424cf6dee33bd09015602609e86e0e73a56399944732c32a3a3ff78019e2a67dd4b741f58c8231e2a5fd2b54df92496619d68f8005da886bde209343daed8d75c8cc9129d2581195b5a6c2c23712758fbe64ff729cfbbc36203b7b5d3ba49698858b23f26d62d9afeaba6137414ea46e3c9ef11d6e518846129ac1c2d5325f370ab7abe27eb71d8831b89c7a0b5b0e43fc127b3458b6d6f1adccd7da35d058ad73472fd2596158834cc575870b6e7c506d11eb4277599569179b415a0371ea84643353cef8c92611e6cefb767c2263a07b49219d7c7f6cd70dd6bfee8cc37a65e924263c3864f28b1cba93f3cab5715e75e1ce626b6a7e9ea39bd172d8e5da2e5a4af12ad1aa50d19fefefc705775d031df3956a0bc7327e36e9b9095a7d7c58f2c89f3c9b02d34628415b74390c1589fdb4b26047007fc26ec242e7bdaee00959f437de80e63edd6efa37a65ef843106e9419d366a96604a9a0b91c8bbf2e89ace99d00bbf829874be90bb9da81cbaea8033ac787e3289ee1e6ac4e575e8bb508dd173e136f37a9577f0596d60c93e35109df41f0acc16b4ac94fd259567d5af79030a0dd36dadfcffa306423034d7478201c9299e07ef5f0810629b01530e02501d5119bb0f1d80c0827ea436dd35b6aef2b5473e88182d714acedf79a7b983af9e5d252d3a1c486f4bc8dd581fff152a86d71e28bcee4b4ec83acfba52701c4fb22ff383627cefac7ab323edc08ef1beb40b34cb2b38ec80e2f072d4afe47d75b71e81212b9c7350c2f584fb905a9a4be6536d6f1551e7cbfac9a2f01fef545133270eb7a133edaad7a4bb2415afe630e10d0f725b8892c7925e766e2b9ddf0fc8274d60f9ca7757f61914f8e00505a3b6884ea2995868b9c819cd2d0c2b9b3a80cc79900e5f6c705073fa2a08cdb8c2bc74b8cd976a6cef4192ba6bfaa902b3f1489f47c051ae16cc14518f694b6199a12c1dc0891ce00c08ca7722425a30686134c73e5df8b4f0643ce586fda1b5826ad5f7fa7f18805097512521edcc54e1c8ae077c40a7eaa3816b36a2bb9ef0609dfcd98361db75db11df73fd8fcdac8369b24ef033204a458f3cc1c785c89a8959fb54569b98750f58de5f929cfa57fd1e2ed055f077a52823d3f7d926bea0397e1995818388d4eced2c251088e6285befd7bf76d8dffad8752c88f7075a21e9169ed42fc9029f84794d2555c9794566a2adfc7bddc720d711e729b57b71b19e6f9710682c238378270091b41843bde6d9b1244d3f9d2c23d0973e5ef85f7290d343ca8d87e2940a5ec881cad3aa2e6151bc42681e37de6d1a0e0b200e5bed73e2b2cbffa4c9efe58f311ba223c66cc54c53a18646e0052feff93799c8af97d04c6e9a74d3d5195befc0cd21e34b22cdcf235850f3c423c0dd2261a692b1481dffd22cb8d2d99777686e2b4cf7da25f37e0af93ae56f80bd8b707e94106c36f180074add6a2393df60933ebd2d3d1b0361e96cc133e31be69c28c5c562270b354d206e602a39f4e29b5503a50afbd8e648b224a0238c27219f7bfc3e20650953258bd1135a1d290cb4af7862b35912f9dc377197a6e2c4d191d0efc3003e1c252bc14b9d09b227347e86b1ea8cbe5f85cdf9f626167531c3d3f959bc03d0944be81348f9b3c8ec550b33699c2b64f8ff4dac5392a415d4fbcd90b2ed43c9b8f013e13bd3a2305a2994203185e2d15d0975540c12532544334cd879d251ad488d8aa96dc4062bc77e6851cafcb84d9f38a09721fed2061c1b3f92d970851e446fe1464624c33978c38335c13c08035df4162be5b9f1da15ae768db8a2fd43c32d2b9b2c6109ba09594ff964fc9dea9f586cdb812fffb5ea17d520e9fa83f776de0ebff4f6ad3791e73c9a677bf7b615a799c56c0c25e4637788b19ff8d436ebe20546dc5dd8f2d09f1fce061c2ee988df4e9c051f076e9eaaa761d9aa32e51bb7885c38898968f2099b06b072c330d46bd723b7639481d6b1b18c1243090f8507fb207d5f6e3fab3fd5a1fa67afffed9b764efdf340b1caf4788c3941231c5e2469e5881f83c7ee9e5ca52eb02c969dbce00b13c7e933be72aa566c7f62de46ee10ffc86804f84c29cc5e24e4fe98a70d9867cf373418a34a707cf772dfa37b7c3621012eea721c065528f38f1e07785eead40f0a43379733b7fc5f24233d1e13ab795a60547bae4bfbd624b99ad447fff6c45c9bec634f70479d44ef9b3ad64fe3e6d75f9b8d2cb590cb489e93c838d37c0861dbaa630be24e86aae9025ba1f590a4f249db46b2e21286f4a4a77da8bdeb4bea07c03d7e5f42aeb33197b2a588458302d75d70c7bedcedb70731535e1ecf8ced09653433f5c963eafb133ef1014dfd9841f09d07c71ad7ddeb88f3554cfad42c3762dcfc2d61194e2447fdac986619f837f3d66c4934c440b6c1d2e9921e99067bff6588d06edd5570842a909b53c8a00c020a239808780f8eaf31df327e7fb59cf0ea5c54cf7879fc8f7af8a3d60a15db4c66dfda296c1f58986e65a1b4e7abccaee7ef671263ea27bef606b6a747bce2f6c5778ff916b145e0f26d591a8f7a08de91ce352eb45a2c80dc03d1c2e93155b3e91e1e09b06695e6b17591cf40628bd9371ec4e79533af20bc2b789b70fccc22138888cbe1a7b6ee87ffb461b1bda00708237f2d9908b19a625329f45b5eddd2613dea51f992e7e7fcc9883b5f6f447ebdf6fc4841af198bb9cb1246861a6d2a07b10b8caddabef3f903dc96ee72196e7ffd6e208d6a5834f726eefe46c1eac8e3fec1c1a798476474ccac9ef0285eb2395301ad4702e249fececbc4ab4006553571173e60ae561f1b2e17e49cf92e55741073f00ebc0f662b1204d3499af847fc41b434e02c4f1ad41efac88a1c8901a0772e937f15e112890ce25ceb02bf18ad2491367c33fde6891e873ddabba261ce26db27794e0ea5eb398688758a0ea34d92a3f0693b437d65d0c38c4fafce7185a975d9a290b7c425caaef1bdc2a64b9f474d8fe9e330506ad432276b83076dba55d6bb2b4ea0db646b04e4364917029bfbc7c2adf90c70beab9c367b3f371b550e5feffbcb0376430ad689f03f76935c5cb128d6e9f4a042ada6b3cffa01250dae2e4c52d029ee8809edc8983ac0fa2647429a0135fead3d3642861fb4b5aa33901ec96df7f93e66213e22fbca9ea1354dccbbce331b8fe9bc5226a551dba9285275f8113c3332fadda0f569b02a321bc54c330f5b1884015071634f7225c2a6eac02424ea1a745369b8ed4f80e27a268bfc10c01b175e5a384607449ed176ab1bd51b03069d79a8faf5b39025eb2dac6b2aee563a6cbc4151f4003896ee16561447123bfd20c8c01d7bc7652d43ef48ab7708182c57acb22d92e56355262bffcfb36153b1e53e45fb394b01af5b20a3b73b67835e7155d089cea9fc7e767a02980e65690adb2a9dc3885ff21181b48c5804b2200def5a043b1f53848f70a28a980d6093f985a89cca7338a1d3145661b5cfb4d685086d70d4b9ba8ed9e40adbb2d686cb9f054a58f68a82c1301b4e8de3fc4092198c209afa1ca1783e2bef10bd8a2bf05e134b1a6988532ab09a84ac729a52a8f04194da45cdbdb5d57c0dcf0f9c00fa57475738693a362b1eda7cd1a9252f09ff8a2cf4a75995f53e702ad6448a771e17bbb709cc07881e6598907b353f56e064e6dfa02194c100505536b084a7e8d240bff43ca395e72d0dad9897f1b1803d39b162de255981e86b8ba649ad337b9cf765d5a7fb0210a8c81723195e58e83dc2aefb0bbf3e89606848637d8411203239e251698097c57102876a05ec456e7e5b25a8d40be61223ff1ce5f9bd961caf66d0c812992706e28e08f8dfa0d46fefad8d97fb6946b8cbef1c84b2e5e269ae703ca7ebd543349039f43cc35314c969a4cdcde5f8373ea7638ce269823c416cedf5fc5fd198a92864e1268e99a78c09259fdc1a5de5e3dd6553b2e91e72e99fb0bdbc826dbcdf03491905cff8b8ef450858cf296ee988754b87f85dc1d282fadf10d08f28f7c9390a0b76bfdf5bbe3695b70ebcc00ffac627b3175599d10dc856940628980d4bb393ea92e765173c95ee7e4306c84678525e2f501e66601e4c245cf2af61c719a4d3c0bb560144e02afa4917f0fb3844d7ccf39289155b7ef49550b13a4abc7079f4e85de9fe152ad6519b599751af0cb8b000be0176055f3fec7187f811f33ece26e6a0c89a1c031115e51effde23e8c83356906292f2e39cff8572a77979e9644fe7b0835524584532e65a83b66db4256be0d0b7203418054a2ddb38778ca4bdd4bac6468ea7153132576885d920f2d86abfda59e644bb8af1c3d5782596e5b49f90da3229821fc4c27a10b7d067ea6dcdff7505353c1b9c37ca72d3c8ea966cbba9850f13ec62c3305f181e4e0915ea1733958849083c0c9e9385866062a8e8f73205bbef36b4d2c269592ecf14f86f8063baeca84e72e77f909871b29e8dbfba9ec5105e1ca407fe273793cf1a2d5a3566ebda2e97424262c9981a608d8b24c090ee474f908556ad9b53496da340516c47a7d4373e964626c2b23a51c9f9f05b82e69b779b5c225feae86882d02c649e1bd556f3242cd65ad11768b5a10df2d3dd69ecbedaa0c60c7d1cc0c743af537b8de458e1c93179b42e8a69540fb2940d7e429d64b35a3211109afbc12ace43c87f44407538bc462643040e180cb841a24baf6c1a561f4462954392df18e693a86a32b36f8bb6baa93ddb278082d5f834d84d71c8da98e7db80b71a62d02e1672cba4267de24486ba19d84b1113583137a89d95cf0010d09bc09f3b7b005af027aaff4565c7a38bfcbedfbd146fb57d565929aabc0af2b0f11c5ab8a7db638b3c6c39552e61eb8e314f2536069a5172869b708baa41bb316a4aebe614b13b92c60d9ad0624c73b62816f05ada53c705bd5588d265497bf5ab75f322664e5e019fccc200a1aed71ddcfee646c7890fdcfeb770dadaec6ed73344b7cdb793d49eee2b9eab2861108aece23ab56c14a4da8844bf95afb3c39a3695d13d7595eedd2f7352bacf146b1b6d3dd4f6a56223922ae4a2337694738e22575bbde58bd86c2a539277c4202acda8951b4c928741e73ec58e3f3f3aa5bcffc46efe7de131ed1771f175f7b5c40122fd363e5c77b970aa15665e02aa38749b971f23e032e3c56c2020d67285a4b67e1c3edd5ccdcc14ee28457a2fe99da57ff5daf26da02df4cad4b31e3c067fa8bc5e9c746149e2ba2ea1473053c751c898d9aa7d56c1215a71f654967f20438918ab089428b6827893c52b6af62f4b0e603cb365f9fc78a9a0e6fa0e3794454ddf75c48273849afbabfb3a70248ec343dc8abee4c3f560722e4b76207a422816e5793eca2ad9fb11b2e3d0cc5580f01ffe55fd760c8d1ac01420a9cc1cc2c7ccd0a982a13d07992c4c14acee1a0143467bdf2319168e64889e10a42c5ce68348ca9469e69e9275aefee39a44e98657f4b6d580fe1d5cb735db693fa4c3a4feed47c87f9fca5c3da84ee2829e9a4b69a128fc33a524829962f24819f6ad36b345eeb18e8c79886c492acab52892bf6c11eaa5db04c60b4fea12357ce1ba1587a6eed337927e65812d3fd41cd9dd10bd5b2b07aa19ba1d41035fa78f38da39288543c81b9c92f0bfb026c6e01c6fa972450466211e1305204680d09afda0a03c2aceda09f1cefdb250c0c0a50ade14a99bd6929e7f8085c1983097efa8c950640315d3e3ca3be07a211b3c0036c887ee44d95d0a0cf6b78ef94bbd20e287b9bde95e5a4a4aff148607cf003ec43b29ec4ec7aa58e8ac0e728ed96af9434f8945c880938e49ba911341560923ed1a14c3a3865a49c26b21cd886429724bdb79b83e66b70167d5c9a008aaec49e1fbf756b421df731edb70631e6a9296c960ddf86d7346e28ec86ed079a9eb4464bedb4307c052991cc0ce73db7f7691d6b893b79324eda5a57063c7afed9f5b063e579a53af789943e8015266042559a5b7fa8445d23c1086dfe8b3373cfdaec2430753f201426e4b1bc6af8a1263eed4fdf71638a4784e9bb1ab8225ee3e7c24e382627a6ac25c1ddeca72310edb17ccb9f81f5d06393e8e936786d582aa97a22bb64899386e027c48b5e4d04b8fede228215720bcb8a7a55d5b4aed06d8f975d41da4ef4b4f349fe0b235e6ef9cda6baf3a6e6d580c4fabaf8ad960f238f6c6d6b08f991921e1f7df7fae4e2037f3a31017411042ab16a3c5dd20e7dcc4a6888848cecf70d9ffa1b1c8f01c5205d9926a394acc775c268e6d85c29781a595173d5aaf8473802bb5f9cf81c408a6ecf759afc801963a4884752df5466cbe61e534e7d035f76dc7c02ff083d1de46ef00882f152544f2105ea87ca1a3d6142585f17f44323ee2c96112e900897c56b1e68ce3c157ce5f3b370a4e24b8fbd174f8ab6d46e263e951709162c3ee886b3cc31218dc6a437c7b61f0e442450dabd6ba7402d3ea78d738f2eb91b24e90b73a9db30fee9f6152a3b24459fc108cfe8e62d8900bee0bb0efb2b1ee620763d4f8c6ac4d4c72a80a2d703c270f362ff7598402eb24344b5a8e7f4d2c2cd64b5672fd57d36b88d8c20fa14c77a2ec32b42efb4ce742a4268260b12cb39795a6e2df88059289c403197d2f333b1fb20c18eee0464aed66f0ed140077f3a87f87040744824198cf7d8d90cedb9066ecd219cb8c5cd94e10df04b024a3cbe266bc43a87c4df33a314340d1f58628c5683c6a05401762c0d59ab2811a3e336bfacfe3e6d2fcff2cfdde5659dfccfd8a09e90c7f9528a718c20e1400735b73b1682358c0defee99891d682ec184373a5479850c35f65d7f5f105b7015253882db515640bf7ca727143664cad743f7b067c5e77ac4ac9b200e67565e91ee511017bc35492559fa3eb02de1eea650e325d27ee6b67543a17f6443edfe530d9372db9a98aae8702ce156bdb260de101a7e2586a882b11495a4e50d736aac0cd30b00b0b916237184db51f572ac9e1a5f67c76250b5a4e8d4b536cb3f2f55f0ccb9505143003f076e6e73aeb933f67a9a7d71e1d826587b612313a310a7783b4550af0be8f980b81b509b6437f02b36522d4bb10cec6952fb2607b356738aa5f8b555c3a6a84a5b68c58791613cf78d389626841ae5160c169e3a0b0964bb8eddc30eb590206af2881cea600a6bb7f37236ea86e445650048d04eab5e7ee8989668ddf9042b93e6f886db89056853d433e332d87a6dbe250b8cb5e42c0cae09b07ef92b75a02bb32105e3e85a4a8a99264697196e0e3fb56679c1d2d76a8fed2d4048cd5059051da5ca9335d3eaf6ec29ca8f7bc46d29061ea223e3536ae29a55e1c3f56ffc16f16fa2e89d319a9368ad2a37ebffed488978ece5f6eb60019d6b67ccdbef0f444a1c4f7c524c3dd4d2b19bab13cd69b8c7ba11cf0c157fed8d6d37f5e53cf21c8ded49f077a63ef338541cc42d9f6c2c38d35c2e3e3e98240d90bc3c16fc897c70af6269fe3d1f02519026cfccfcb2568f6d6622bd316ca7ade0ed84c740843bb89fcbea097d12f5770af235fd226dd0ac7675837230dce71168c34bb1c9521c188c597016f3d5c7adfb7cc5ddbdc3c86dec2cb5ce93294e6034d92539e8edb0ebe5c6d7220f41b8565e4cefe02555f318358be8adc23a945f248ba9792fa5def50d76ba55507ec481558b7eb79636d1d113564707ac93d12cba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
