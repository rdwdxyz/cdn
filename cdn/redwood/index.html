<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b1fd41f126bc99374c9e0e841f8cd8615a601a739e85a4b1ee82edf15d16188124d9d2c893073c7aac024da36d64b686c90f005781613a83cca4441b5fc66abef91d3b104d399ffc60b71d11e87d4d62deca06ea89a61826836a90111b59c275603fdea556c17cd3a51b16cec70a23f6273e3e97291cf2580de114f55c89a9844aab23bcf9e0cd877ceca6c1e0055c1c2d196f5493e0d21b0085a71747900a0ffe32950e37748b2cdc4cb75bedef6c2a587eea08717b7da39311e850747aa6a7fc9d8a1ac3d065667f5d9fe219ecf17345e8ba83b554508e9d637c665d8e55d1b9931c64745f8c732ce84adc2921250520b44988303cb07c249e41b43eb109d6c4b580108989ef7e154343970adb2f6aca755678c9b38e95987e28448e04f3e9b2737102eabdaf137e45cf00999fd20e17315d2af29d69da5fbb64f0df9d0f85dffe171f1e3a107ad57b0908a72028927fedf65a31806d3a8c6333b3f9549c31c7e2e56424e08307d290f65948578401e148c097bfecf14b7ff58d7fa4713f5d3c55af491c9a3fe583a4c5b333e1c5d2cb355b4ba6c01b9bb21aec1d5a85e780e768a6448724fe26ddf5a93e855a8d8d9c5cbdfd61619abfec56398632ae5412f57380c1857325fa52a56e3d60b2d88c1fcba4460719b619c0aad7d94376025229d28325b7d5b60a9e340e4d2f3b42639ab81f85db4e183564005848d005124ea68df15f1896b92b8ad92189ab4b01706a8b2a2207e9f2558fe9488df5b9a838a6a1f298ce961385d6efedeb355e4bf6c0be8a5a092ed4a16c013b7d177df29ef506f0f24d0d80342d6764b4336f5036405c839eb551d0ceb315effee178b1ae95a2977986c4245a5b4c15df996278825ee98c5f3c9b2345fa5109b0590be197606a19d5ce0a7684718b93a800f342874f57ced64252d6d52507eefa978af3fb4f3560191305f636adc749bd56ae4e62ad2e5c6c732b819a1d1fb9c96f79acf04dcd995bd26ddf90f49d9286e6b0eabe684f744dd31c338c92de4e087301b1f9cc4ba3645436bd1219c2f6e805cb3332f4628bbe37dfff95b17fd1bfa2f8194f65a3a2b361a1bde78f8e28ec42a7dc788ea727552d6f2a75ff3f6802e8ecda36d29e06a0e4b0958111a35017a612717142e5533f5233ab3a21bf9dbc6bae69ca0ce7728dda2bcc3d1c6f9e1b9639dd5af4b98f65a0b04feb5da82737bd1df50563a289bf74c3e61d1af9392943bc0299ca65dc01fbc68e0c564e7d12081af4f2c8df713fa575d58e350a5dfcc7e00363b7d7d54ede200ad41ffe8a639c5fb746fdb1419f1d100c965a954f7fee7be5ba2aa7926a30f0f9a4aed096d5f0e5c47cb815f3de1a646a54e69b7f4c0d2235971f13e45f4c86a0ad73c4cc8657aed954b21eddee025d083dd1617ddc41ce99e41c1e261fb2d54b0deb432380ef7896bb7ac8344ef93d4e6bc0188e42f3be21cee53b3497582fbec43d1c464a4c15b81cec92444ec567f6feadfc847e8025a1f15c4c35e1660c355f0f59dbd3428be43a7b250d3212b1fb710b283b3ae6ea152ae38d82e622a93d607d469032cc5bb31b711eb35825bb2e6d3935c361ad404182012f5984611c558e3345afe75f523da2f8e3218c5f6bccb298b7e3d167675dea628f0612ff99488510dee8190ff7427e9cf341e545132533a8839ad84016ef0d7092e92d0fc077588888e02a181a7f269ff68cc0ab94e7039ce643ca0beb492112690cf931338caa241593afaf8efb755d93ba5e2c07244a8481a477551253e7a527e9087e95dc2c90115e46acece0de5f859ffd80ae61ca82c7db053b629cfa691b6e36b60bd7f223102ff3b3a3f57bdf36cf57d840d20a3e15eecaf3c507fe2273354b2db684ac580d31ead04eff843245f9a19ba520429bca73b1a1495f530628b957d212d08fa99f38418f12dcdb6c22f831b7622f9473236a90f11c4c54e5035ce0dfa4243dca9b32bdc7f2aaaa72ed40a846999b8ee4fa42477736ad1047a0736f6cd9c384291619c512ee604416f5ee08c626f847855f733a0b977c59ffff4d42ff70aabef32e8339ed03cfd2c19e7df242c0935519bc204ea391074f118fabfb7080f7ba0a26f373168d8fab771f880b4cc0af0c11c9da3599eb4ddc37962a4270a43b7f6b52ed3183c96721456e22bba2467e1e5b7238455dd55bc08dfc62b0fc54fed625c66bc0120aaeb148c3f098a61ffbe0b19db4e5b7c83318f3c395ca1b250de07dcb4cc12cad46c4f22cfa4240279fa454dbc390af5bb3928f733ba618dbf2494deea9f9270551583fd8bf734687fc919c46bf99471292803a2433fa0a0cdfa3e9e3291a9f150f29c5d3c266dcd0662e2783bf71caef15e6d6e50df8f1741bc45b0c752aefccb5d6fdd5567b7943fbbbaa6cd1828406d59e3676003a0c21cbe620870cabdc8151c75648085f2d85d1dd89304323f3291aa1ab59cbc73827280889ef4084ff1818d861479a76fba17b4b80d16e0a865d2dce4e2ed11a4b7b1a447a97f380e2ce5f4077e9baa2c288158e1b86c523bdf24ff9ba1c0818563f593601a7c7cdf9d04677844e07454856d3681cf86c7f39c737ed572cb73bb7d135b15758b4ab7e47ef6ffdcf41f3e7c85c34fb83fd05af2747ed87a1ee80118c69c571cbee2f451f4d4a58e964bf183bf3f03daf806e97a3fcf2a460ad7b46e3838000647ab5bb9a7cc89662e7ba12c983fc28f28be43b7790f4a6efd2f8165b6b4dc3988400ac663c2e0067fbd57907f8ef3f268cd7b6a070a1b6133bdb1156bf58afa72c3bff1a32d4a74b1ca82e4b9396bc6a1c36c0df46476a83815dd899e6c6372d988accb15a7a41312f1e85e5fbcd3416da50add99681bdd6c9716ea48e2386cfc42e31b979a4aa53c417759874b887792e6fe73862cf0fc495b0d034da158cdeed57ca7e1c3131d463da92fe5305711a3102ebacfcf642e0bdea25255d70c0699abccb49d3365b5e1f4f998feae0d47e7d6e401f1637177da692e142649b48f04e2fa9369e9c4aa16e1f222e6de8b29fcfc84a5a4abd2804960b1a7ffa0f6476857dc6e1a9510fad8b7d37956ec63ac30906a228fb8512b5ae7e39de21d480fe0b0c49138b1576973eae8bfe8ad48fbf849d0c1aa4bdbd82979d101aadac05d272f19d955893d4c5279c7de33f199de0e314417bb6ac08f7ddf444cd181fe6a3345a23b0ed276f5f143e7361552ba0729a194ce0bee86011838c918bb4a15fcca9351809c7ac42f340c6ad2a76c56ad48ae00a1c80ef99ed0a9a73914bf0ae7fd1e15eab5c20fb84946311a2a2ff7d726d3b6fe4a745404ad9548edd60c7eae44e192356140e15d405b3af010f05ea7f27425139dcafb50304a2eff0b476eb75540ce74583249f755576c142a75e832c79728f4e6c169568e3b9bdfb768aec4010137bb81bcf7e42cd5a50875fca1be062d6da671214c7fea1cba70ba7dfe12b8a32623c25a71100e4871ba20ee2f1ff1c3e8fc4a1bb19917fece114c5ce6eb37c62a8fe2a404bfb37e2fb994a3e61b26db0ed3c6ae074be8eaef75a2fd5575d6cf3de86e31f6d02fa60658f87fb3ff16105ee55bf945d2a4390ddaccf9593c015080cc7de41ec0f84f3ee5cc021bee13e5aa25d8afa297e7df4003f567434558045c5d9c7d729ee5706916321a3612a8ae15eae7aeb9252129fd2c0740902e9d34884c6fed97f0e7eb345b84138239674a7c400a49d4600428e2cede1b8c1d0e3f60ebe878a4e6f50ab3d6df82e4fabd0fd11a0b00555db4d2f2d454b9a8e886c2725600d6c1e8f7576ac88572ddb71f7b8b7f98517ff12ee6bfe387ee8715267be7d8e261f9224d9814754c170fd61c3e7b6c28d41b3b206661857ed1abda74c8e383dede794f2905a9227bb82e24a436b21636f8229601b7efbe4c851571cdaa7ccd94f92b71f731310cd63c936148c92621360adedcfbf44bad2b899da4d9f6e00ac8b5ef1ade900159a4e130171fe6e1530da83ffd839a1f2e943ace846b88eac2bbe821838240c867d3f6705bc528aaf77ddb7fe4f6d079e60bb80af0ee7febe9ea6737405fa2061148a89f398116465e8ab48b1191d94d9ad9746a9709efedcc8514a44783eff8e1f3bfeb3a42ed13c8740d8760a6d0ad2d50509a1fd2e8f2a7c49d47c73f38bce1a4d020d0e29b28e32d12caa495680e4ff14c2e4f851bfcb87da7bc77a7767f7202df62f30f1c620b3b90c731e43ab566ed0fde2a4e49ed67144e73de25fd0fdc9a8872d378008ea4411990f3950d2825de4c9e4eef0cb6154f15d11ad1b687a6b1b14e907de7e50677d1da62d278aee866f8456df87bff6d3e95cdea002cd8003181d1ba5a0a9da7f62ee5f944b1e2deacfd626940528f658965170ce55e4cfd497bc5900c6a4ee38a230561407a5b0256eeba9d37ead2be3abb469e0967a11fab5c3dc421a22f8ccaf5c9da851dc23828ecfb019105320c638b531dee629f42d9e440154af7b56b992d7c46291669fad401b4a939a43bc7e6086cacaae006b93dc99feb02a3cd0e34b16ae2d845dbeb98516ad2b0a591c676599c10af002fdc43dad9de6feb750cf11ac02040957630f14de3a5476da97cd0db11d1647b02b164a3023efff8c263bec8076e6c1c6c0dfa0fe8cf8bb068d9483abacf94eea733cb44b5986e5bd70dd20cb580f27eb8a9cddb66ba5ba58bad8c7ba1788acd0d61d61f414355f0e840a5ebb704a0304da4912695121025f97a6a077de1068de9938fbd199e3c588ad7ead0e5edb6c52d47bb0c9b713f84db2ad5c4ec3c14e51d1a762fff086d7c5841d56a11ed0cf7265da2c187b379e1df8fb454c53085b39d014b44191d29aa63032109675125e7f94580eba703d64fef654136d783aed37c176b39a35c585e01502db94d01332554768a95d5f77fe7b7f544ee15fccabad9e733884c8e73394a1d742191b20f9f74070389412d788228a6e146a5a4054ac2c6e9397a7129f0d1c439320558500abad4cfa16dba36748bc0914e09b1dc0ae34727123cb52faec61c996c9ab4711568666b4ae9568ef437569128424b97b33f2bf9967ea8c210e76f84bbfa63b67b3a864b2c65147cb8b94f56d9deb538b4044f045646148b9a259e322a00e3f823b184bbe03ecb10c09cdc3a0dd6db9fbeb2460af1a5acc0cad8c97af0359557e319cc6628a88d1e25f9c52c56d69e0cb7b2c424741e0cd49ca852812d187af2e4ff386156d9ad298888162695184cbb20afc158c1978cefc576f6cbe896d16d584fd39fde59b59d69c0e9014602a70cbb13b2a16011cbe8b1b6d2db9cb5d8f6e12b0a69159dcc3befccbb347af09b2a3f73b09ff4d63a83af86de6782e0528be5fcaa17148bbd52ef5db4765bc6624f76af830a1313463cf72d5837dec4c772a932e75c9c64dff22aec7abfddbe3a99e097026e494912aad515a63fc25b6cfc7cbddeb2e6a6782ea02a8edd9dcec7461279b2f682317f1a43af18b1fc92a20e3324b20a079b930a246e845e5c4e0a0ea222fd70e9eb4dabe9f1a42c4976893415036f7f384fba7181412b68aaeda3dd962adde8bf9358f16b41b9fb64ec3d0533d8e64b80453819bbd48f5b9d3f71b3e34b35b34603ed8f5c160d1b6a75ada703ce5a34ecb5f85c06edd58f84d94d2e85f9a452cbf06e1997e8fb6caa017d3614aa7669f4697e701c533c9c7868b570c59c2d66abdc9196a5189e9959f93509fab14bf393841f96794eebbaee88cb574f62b6db9f4a5d534443fbdb84a3a0f296cbda0647516464dabc2c7a583401370c6a08864f6c09a39d4be88b03a9c234dd707144a4b2b501adcfea82e4cbd3d8f5cf3afe133e554e120fe735fbd919537e8b74427388b8c6599f202fed1a1daa9ccb9039068c232f519b783829a077e6d7425d6640bc63d660aae9e31b947da0f729668212329f8d709fb5f419df730ff98a70760904e3ba9cf51935ec6d367cff200d8d004bcdd36236770bb0da522736cf29eb115d6330874856340f1b4775790e74192a5f8574691a16b4a6a3d4fcfe7ae284ac4bdc59b8ee42955561592f289e31a8e746a7ba14d6cb91f3b80236f8883c11617744cdcdf8cd92ced492e5b95d87e2b8d1e1704223fa696719c2dfb6d5138922d80e287ad40fb1aea60aeaf748e2eeebfd41c6db1b54fba064edb26326d85f9224b869a846aa7f16eabf797c9e29f2c00a2e7bac9b56f7df2179e4c51e087b9367c381cd5063ece3fd49ecca6814d6791d719b4b1aaf55327a129ea0b357d12c7942efcde3d9203bc2cb72d2aca3440b96ad206c9d9cae14b14b5d37b98f619438f0ad96f4fa5e8ea216fb78f6d2c1d4889acc1ded98571f699a547308b17cf8358c01433484c4bd97a4e28713f79b6615f5a78353c92261a6dc9dda2afbb486c11d89e60215c091c2f7f3f26e2d87a508000fa74454076f8c8324988403725af5094257d36be9a474c7c24d48f7090c5fdf5bfa72b85e13fdd18668cd6dd22713fab639bef288f95ab266a12ccd9b4b7bb14716e9d2bf0246c31d6eb431695e66efacda67354968ee524763ec866b1bdaf12244284ee1261bdf3601c98b4a078411d84891440d9a4067340a369815e7a853e9ee911f741c49a0168754d038f34d4a33a25ce6143888c1dba8d2fda7fcde348d5bd934d8c251b0ad49055deeb2138b952d5ab57f13d1555b899721142b8d5731e1390521f7bb488913ef0ac821f72921dcc1912d00e00d73e82a99992cf21787d15bcde0dbac487d0ca03cea54480864c964b2eea5016d33de1d52c0b98161163db7e6d5ed33aeaf01275cd5f91f404d83981d724e62c0e4ccda17cab51e5e88d64317ff725e2bd9632d2eb0413937b67394644f86b6725be7e8e9607bc0383f5390dd501f472286312ba7cdc1af6216037f87dba47cd858772841cb8d9692506e15b920309f7558f95e90a03a529f0d61daf1651e9c02f47ac9cbf5c664f536ffc0eb11bf1491065def630ec39411373ebca3e76e3463f25c2529644eae10abb85ee0593b3664ee3d6806442ef108f44895fc98765da014360fa4355b585ce6d673371d955d98a804956fc5a415573f03ed97c0fe1e649de5fbbedcb25ff092c808e9dc453eb6e9178ad710683117d29528d20a16009e6a080255f976162079f6ad79f7fe12fe540994542c54b37a6dfbb8c9948ab5145cf02535bb1c6ef2bbd14dff44bd9690bf5fc2c8c87561e06edd947bea2d25222c530858b38881820d9eaf0f2e3a2138d909ea71a9fee6b6fcad0b11cc15886a9e8e6284e0fecb67d098b5befbac39ee79b53a61e7cb66f7e96638dfdd0776d342937138acbea04808f9df737f2204347873e6e8ee8e5cbb96b7b05df86e2592a5119fa1ffc16ff8ea2cf0b23a64197ecf16408efaf5451bebe5f8b1aaaef3b17ca509d64f66dc9dd7102142fbf903595495fe2d55e4fcfe95873c8ad76c0989f789e54d2e6f5624ef5ad29da8d1d693c558afb97c44cb5bdf157b6169bb0e6738f585c088d0f3fd9f19db091f281b105742df844b00f4a940c2ee20f40b66d6d6fbbd6100681a5d588b79e9c722b259aa815c687076b2ae8f53f5529aedb8ba75ebfa1843a1b8e287d8d807be8e61d0f30a4c87b7b2e0d52f51614b742d054b2cf1d0385b46437fbf3e56d1df9be90ef97997488ddf0821ef355d73cb31811657df33fbf7e5cbc0efea469eb3109b18ddd690ce21b8117a053ae3507a2e92992a6078052d05a7116a586f5099efb945d61900df779c1ccb7b01a1c6329e1a47e7647a0ba8f77df9fb0a306cbbb37a06bf5c04d39b6ec9b66525ac537c62f030f267f4351140d9b2038012c552b584bb5c0df494d1093e39f2680423d6393df73fe819a70d01d58a45e1a011683fb5bf7fd09d48f91ac7e1cca9d35d5af013171002a545c8496c5d8d7a5b56aa2f9673586af1a895415ac097a9c41bdc1d7b1276afaf55fb38c979cea250b03d27f76dfc9de0b1ea7e3fa4a872ce0991262ae2a6af45a145dd6a5fa64ab52613fa3c5c7fa0f02a17cb21e2a1cdae97bd8906597438d9382c1d2e80541ce1d39cecc5ffd268ca703e8b8309e124432a364bcc2e2689ca23a780147ec83cae354d13e263a157209833d12f5de9b7d753635cdc4bd0e902e7c74148391de5142b709a7f9e5b1040d619b3d744b3c246f82b7351110f23d8e05cc5666101c3845bf49a3099b067bfa7ee43a0b89f24b3ff99fe1e30cb19cc88995f2df2abd0552c7b5a177019e0d60b338e0e99f6d6ae0baa44982641e527e3bff6f5a360e7430883eca2633c3b3026e860dcab35d26c9fc72ab9fed39b717bee97913b79a2d674425c7e786f85fd34d8db76f27e0f488199a5240a02a7dab92298da984ba9f5722407d61cf04cf95b3e7190e2cc9d308c0dc248396ab0109357f452c1abe5a186a03b57ec179e3861dc19ae4659ba43047b3a62dd146683bb9b717e4472bc1047a819fef69fb827ec8c414b9066f50fa1de091a0bfdebe4c47847e706745cb352b5b874ba268c86b3584c2b0bfa1d2bffdee929c122e2835e9ee1ef97518a94f7fdc954be383f5b23d7c02d7436f43d19b4d33c44dbf6ad203495f047135134ff816fce1c55dabaa407414fd1037cfc942f0f613346a72b3f4a012d19a2b724fe3a35cfbd5953506cd05c45910475b2e88b7e50261982787f08f4533bcf5ccd53c0cd63fd70f54c486bf51cfc77e33ef6cf51c015eee34883267845e8212c15c4998b924e6c17933679d32abccea7112c1c4b1ed78bb5ae45c9931243b99f59603c34ac3bbe83152b3f8bbfbb97c7e4542fe4cce7915dda15a7fd4e1aef3f051aecbf10038e2bcee078e4a197a4dd0f350832b91854106299c95190645cd07650542fc731af83fec57662e98c55a485a7f0ed63fece8dec8b32ce9012b94c456d6612b98de1eeaa6dd84d9a581ea8b12e55af58365f78dd67f9c53c4af6412428baaa91bcd5b69e14614a5bee20cc5cf4ed69ecb75c1a29ea39a81570bec986310b7058ad0d1972b6ff0dd349c45a18cb8ab740306e9d4ad8ff11825ddadf3994da5f70762d4daeff9fe61d064308a3c8b08707a75e71c65c91bf631d6db1ef96c6f99e23116872ce85db174a59083e38b1d9f7fddf3626ce83c262148e789c0c8a8904f17fa9206bcf0747868427ea12778859a7e5295a78f118799055faf7beab9931db435cddc926987453062084f561d94dedb4be4bdf88df32465702113a5d697f6a325ad4fbd5883466daca16056325cc7dc79e39ad64338cb149ef53805b2d7dd60b3ee0b9b483937bb1848c58df8d58d241891b3287fe63e30aebb0c7064085a7b110d3dadc68a3257e2725380bfb8036da8fe2e243651d503c97a0fb32aae73ac74d9d53edc66af61f510be1cca92725aa92c2de71c134327389522c801ace4b15f7f1bb13469197c13279cb503263a3521e6a558d1db6161cde9fb7f3ab1a6b28d97c7390ddf7a6c5d75cbbe72ab29b22148ed5203e6a80f0457fda7c166ede13452390cba912e863f739c17b547b16cfd4569125457641c827d96032ab4410b10305fa3e384f012ce307b6a8d1292316c121033f3b629b8c3e6c4cc9f497ae985eeb3763030accc1fd2a759852205557765cdf3364e858e3a82576141d552875b5fe1111894245ef5555f97817992fb31b5e49523e4d716dc1004c2fbe46673859b38c5b18094cc1a600aee37bb9696f0e9aa8691d7de9f9e82ed40a9f35ae64a2162e97a1cc14429b6d0d72fabb6426d9f25fa08b470a97288c139460923e8e88494d93dede159c536df34d1b56b3b2b375602992984e64bc56720aa7356ef92bd7cf774b822f203b220b2b6582fc1a104f94802dee34429d23c23d483f18aeaaeec78f34427f28eee08b0acc6eddfbd85066b4f581634514b499682cdd8f764d76173d11f743f806a3e963bf68f9496eae8679b6d38617760db37ce9f418fee4f3f1fc3ffc97d2ad50af1c54f2a96728cf2d6a8faf3d5ad8f9cbe759ecd54f870fe409cb46986f83548f5390e84aeeb8117d9fcf40138cc3e44ea392990ff9d899ca57d8ad13fb4feb58b2db267ada1ce4eaa5ba9405c8ddbc7327c112c9e707b71770d5413686be9366ff6a84ff8048e31e742cdf641e5c85bf3e43be2d7722774104e43cfed06031a7231aa6f19ab339543e01c45831df2529bbf1e6b1f1654eadd8da89aeb687dce07d6017c2b943fe9493a2bf46ada8ad56a8bf578e80f60ab6cbfad112c3f6b1adb649030454a512b2aa83fb0b386ae451480f17bd562f91f4bc5e06f6867a6020c54f6c4c69338f6ea0bbe34402531835ee02a49047ba1b278856b114dd2167f59e9f472a0218ee6dcc27b3614916319e2a6bed1a5bebe8372e2ddd2c14c570b038e00eb1f5fe560a8e1831b926776273c983ca2410ec81d0c1bcd131b846561fb8b92fb97cae2ce5ac4c6e1a8f52a4686424c35ef966089436d45adab6b6514c3d2bad510c07d4f472a893acd93f8f48087a1b3502b98106e2309f1cc0f7192e9e2fe9a21129bd9e0fce8845eae210328e20b8214ec528c49832f989f40e8f572faf285f809058a4280b3ac6fc15751294aa9e5da525ebdf68e8aaec3b5c2de0ec51b2220c35282d06e56a0c943edd09cc291d6b777cf061a7907a56f72057429eb6e3bd084a15bc905dfd638db7d6cfa2c9ccf342d3d9be6f7138453995fb196487c8a9ba5e2b7339059df13f8b1a0f2cacbccbc2b61f523da1372f124e98cfd9392f3a6d8f52bb961c5a00bc36b012431ba416e9cfba54ca8beb0d11d2f4bc0afcc446e2ce0bf41185a6b7fd17e967c4fc80a73d0d934316b03c0994af4a499a012d640e7950eeb0372742e198047b87a609986dd04b0fe4bdb841c171291d5bf49bf531597a5fab86223d8de3f34ce6f008e399bd53cc0fb07317527a5784be17fb209e75a30197d57a56b2a6b3cf108535486753715680df17bd9b8ac09074f59f25ec629ec7c9cdb59ff96999d37566124ddc04a539be94df79598c0899c9b37fc747f3130d8a1701d5a76ac8ee07531798a47900300e24fbe28766d5205c927d89a62eef281dd13ef72e45afe4a072d505f193b128e08e4dcd1d3ac0d80d84f950aac9fa51de972c6794c46531edb74d36b072a9f4a38cb9665e91f7e94322d52ec5e7908069451d5e7bafceae82fe6f220092e7c87dbb1081b5c231e95567a591947c9acc426b4ff9550e5b777d8a78c249b5df8f2480021493f95de6010a7ba5f72715ec3cdc9d6f5e70c65ca9bead2fd66a87ad8cb720f1a202ee144544a30464a80b51bca6525a86f5836bebfc26c6ded0a5f788509b902561c0be678c6b6ce0ec6bb62b7015c089dbefed5cc72a11c831ea3ceac264cdf806e97d3e4e010dbda5ef3cef12b600f1f9f683f2bc21bcefdca63a2edf3258ce0f4b86284aa5baa738429cf1439233172f7d58fc3ad56f769ad4a73b54ffee959c3c023e5bada277ba36ce8bb052818cebe58c97c708520e8e3e5584289d0995b56ce76c40220e74d5ce65a58f6d45f8a72a47f3f27d76ada7f8901b41edb3d14a716fac253cf5be262cc966dcd727b237dfd04dd6c5ab207d27bc6853b00d8c3f74273de27486fbe0923a941b704f390c3cbcc970571aa13e0a99ef2ca9af329887b79b10ea1faf7c721a90b22fe2a71c5d6202efd550d2f657d90bd8a9f035627f3241ff9893ffd10394d75fdf26945fb0550ac88bb36790f4fb621c48842113301c2df19860011c89852d91631c3e69aaa4cd066399facc6d619893c0cc9d1e4b1fc3b67b253160def4739ad8424158de4ca6672c2130dd6243d3353b63e469b69f3d62ac88df9df3d87fe58eee84298772856deaf012537d525228afc7c24f1c77b8776ed8d0b9456492e57c03eda176cc5d18e6ffd5063ac1016c632af26810ca2d0c0cad1eb6f5db5e07449cafb5420f64dea72886856c1a88ccff9ce45fecce723127dbcb7bfbd49f8ff576ebbdd118550ae9a7d0763eb5d334f3a8184573582e73168117e3415f6219b91f3ceb39311b3345ad753c83d119bb97e68aca767e0d387dd0c77a8ed8f0b9a1bd4afd5ec43759690f5bba81cb42e47a649659a70710bb6f57b9690a7473a618f3262e6a8c27a40ea4fa94b799d1d5cb27621452463e6a21a19eddcffc4330a538843f2ebc8a965ddafbdffd8a51972d64810744911ed89040d8e32067a0c663ac70ddb366e48fa3243a2bcc8b60b3d43d3bdaf73d576e8dc9482b92e03bae44b69ad0ff72d77732a1274ff84f674367a30b91c88a07d676a5ac685452d95afdb43c20f043e7aea42239f60531e45b1628abcc4fd78845bc2c8e182a5ea4a5769c5f2846278c2683bfbf97db1c1a73c008ff2451245140ebf9d298c98aa303bdb4e0a6fc395a9fb10b26701b74ba9f067856095bae45ea38484f3b69484ee1da455c43da9ed4e6070bbbdb4cd1e662fb377033462f476f3b1141896692d83be02fba76534911a191420af7472f86bda70265a72dbc3c8089a44f1fcda96765144e4d48eecc03f97efde976c7644631a39e50796f2b96edbb1efd11c0ec6e42d1b1a91e7b2800476faaf834d54f7c199d8aed2c1dbe71ca983cc3a05cafba634bc75c22656cc3d959fed7da9b39661b66ca0c6636959871b6938e64781f7f73dc3e19ca6510025103cc5bb64acf997b52509d8fd3b45581e3cf206be3743a800bfbd6e268b75e14323f8c1589f39f3238f1a3426948400b554401cfc340fa5a336863f267df5da3e7a11ab6f876d8f189b6ff6e20caa22e77c7ec6f4ad782175dceef440303d2f990c8d713e8cd6b8d3fc294b5ce01f66bf65f8eb3ea18104f6db29f5a6a3ec7e2e78ec824b5783d9725bd96b9d54feb8616df4db9d64deb0d55da42e3e40ad60e231aee14a2997d277212e522d3b2e20bab599ddc0e9f07a538e5fc421bdae9be749a6f111195db3ad6c5ad68e4c5aec844edfe7c3ba0af2d5b8d894fa43fa59835fceb211d2ca04ed66829956f530491207795b0d9e2e8ce39fadb8a68c278fe161d6e1647e38d6378f4f7c07c384bd6ef87a1081e0b34049c9c1e665e6113e7a5d1fb76dae27584d989efca8440a8284227b346453547d554db4a69c30f42f5a6d19f9f4ce424747aae63cc58c9a4ad7fdeff4a090c2df78ac6bd1adf78b6c2a1d0b1b642945a932170685d001e15b02836acf643c12735b9b676b816282c56c8b0d0aeb46c77164a5990a120d448978eff130f146a59dce09dd90f9d8f8b3fd49d52da5dbc173ac9b386fe4b07ed277cb4dba60a453a30b350d15bb69fa8b5a6fd7c6d83fc985d59d76d09eefdc7681b8b6f6d6ec9f19403e55c63973d89c35f475e8a1fa2772dc84db5629b3478b415e119b1333037bd2cd5e4c8fcd13e6fd0b3797390bcb42aac1efcbb7d41980aa5cccc20d5e921632d1691d48ab18489f0e9b2159af59eb7109933882694973aa0a672013ab5c544b44f37b5c26f05e52ee42647e0800982c44f422e1f8bc133829118c5c8179daf00b7ddfec0fae587b004276eef6567b9c8c001eba0a8eb45a9d4becdc6a5834334fb661310f5282f7c7c22ba1994cc0144ce552584c8314a181c8a398fc8dc84ff5fbf5383a818c807951902aff5ad77160b7eda21896b703370ecb57059c2b9e97dd7e91e2e6fa947df30f2c4ecfd6ce2e3e0f0fc2c4ceb4df635c498b25414474b784a8f03382c528d619c1b4d2645aef589e1a3c5ed057b0f911f4fb24f962dc36ec8e5c745fd7a136ed82632ef8b6c36121ac5208f01fbb5e4a8ca4f8a91c48bb58a32bf77769c516ecd991dedf1a26525ae94f3b3714604f6f748a7f954cb03370c4c3ea8755283b8418fd992be973252a6473d480f0ebdb3218481716f457adbf3bf3fdec60cf0d751d58f1181f03edc11a10b70959d14852a11e9efd18fcc8f775faccb1a68dda3381222fb5e06cbde6fc7c8715122f2a482673e80ff794de580775a1ceb263f14d470b7c697e98ce6675c68bfa37c3812bd3e4b984b1dbd9fecb231f2bc13814ce23cea79c485f5d90d366ecd8c0dbe4be71afa4fe65719c433c4a2ca479cb6b0bd42643d8054205fd49b9ab6eb8409bdd819f2cb23f928fa780dc51b4f6659082e07dfdc2b0ff2a6471bc8bea2da0f921e79818f89638854ed0143e2af8546f83c5a2d1ffe093bd478524c6a765cacf7b33f0ce8c30ae6a2e1f133a582048ce47e0ac74fd87d75a6b3d0389258dc2bfa746a8be22885ab15bbce2fd22e7122d9fccab9fc5abddb9957c8ed3000a5dc29905546a5a912c40d12bfe3ab5a64be70838216f996a6ef60042de297606a967563d9e90a5364548c68e73a9aa2fa4f53b8ac85a87bc50aa1c5e37e8936796f2c316cf97c0531d93da90b9291f3a1384b00d51bc0171b2ebeae92f0f563d8e2e882c55621eeec7c0f94d7b2ee5f93da217f062a4ba0e8290e540c457655ad85dc8e7290f074b58033f088c755ff219be3336a12df8a1e11c0894455ca477bbd5ebfea72bede40410c53e86acfb82f44f67c5e342750ac105019b92dc75d1856a1d13dad31c5d7154a570efd058cb2810c3f3e29e40d872738e1a7a63c255ea8620f8171348cf767b1004112150ffbde097f5de4f70a3ff44a3dca161b496edde4c61cf2932d68e08f9ca043b0d7568442cf045535ab8f90d4778ba69b189190175a0789ff24bccd81483ae6f5870f2cf217603d77b18232784f945aa1970a84ec1235e656609f7f25b10752fb9ab23c31feb9f576ab88a35edbebf86cccfdb97fa34cf5e2a0c4e2bbcc0dd1a1862041d0aa3fccfefe263157703fd31502b93a0cfdc80dfb3dd9fd48208fe1e3969df6ee3595478ef21502e7a53f77985c5ef796f07e5916023f956b568c31a118ed84249d2c473dbd7106a8c6b78f6f62640649f786dfa42c0658ca2cf9a78e2cdf8b1f2161978398dc80e09a7896a70435b1870f1e699089d68e584c195d5deceda48f8514ad70ee5eef9c5bd241ddc67c6035bcca15d0d06260f9d66598cd258307e1188dd6ba0ce2b4c8e53accb04dd7155d6f14a6b7709218449620f54289e8f9d05e795de1ef59290391d753273d44cc864340b4ca167918031b0bc82c9e1f249c9854ad01e338851e5f7d31b2bc5ef0f96cbc848cf2ab232721f2a3a6b525ec6cbc33f4145f8a0f8ddd86e8fc7b92d412dde274d65442e2a169624aa3c7cbb5f32a64b05c6ef8a3732071fdb4bd5eef6825b34c4ee3e65fd3bce61b3b95911a5f285c348269c6bddec2dae7302b2c526943e9ae19025ac1540e646e90c8337174fde4721d2566da697d9974c5de67f9cb9eeebb3739e07a7572cfead3e9fa4c57fb3b50b7e452fc31943ce07674688a70157dc9488fa12e2549a46af613d403765bfcbb1ea566f3460b966e0df66f5b54474919779cd04f3b39244f776d3d1b2b4c26ed117ab163630af4c476c56dae9dc34f7c587581778897c3f717d10afeddd680a600f279e0c29f3a8544b105cc2435d8be91db9fa9f8990ebb316ee682012dfbb93e08707d62fe3b8a640a1c78d41850b4dc65b4bf4c1468e19e0de50e81dd0f93466b03a0beb49302695f19519fce042252d44c57029b3159066d906b92bce7104d653f49b8611610f3071e1a6f2acaade4e412119b6b75bbe75e16d0927ccf7bc9ed41bf830e94cd728a578b36c11fbed969a2df09d5e5e2ba69821854069e7f002010af692b7b918025889290fd4fafc68da2ddfa7820580f601e800765536681ecca5ec36f55f0caf7c00163757924b8fc2a521353db1e71bd6e89e573247efd583f7324abf64e647eb78968ae4577e3b3357a5901169d226b07ffa256486559ff9cdefe19358e29bb5bd94964e81ac4e2d136b2e727bfc0ab7f69cceb5fbb864333c9dbf53ad1c20f7c82731c906cc61abe5d141f6ea674096a0e56080a59d15588ae58495cfd6c325d77316561e105e322b9fed3e9fa6931300f78f683cfc3fa78d6811ba0ea6a0e098eb27913ffe35859e626d69abe9b3d2d651dab17cde14a04e1e2d98d2f420b22e07dfac129e9247234a119319838a8005eb93c48221a91dcec663d96fdb07929bc4889e74eda309e9f40a40137dc432e88381f2567e6b5e55168bd656de7f901aa503ecd1dd61add127be7e51091cea03687b20b8a8c5cbe7998dc1f68fa1ac3d3e83c5c65e829698b1b710f1381c617c32963a3a85c91251c8c3388ffb853e186e315648844537c13a28f879f02a8342cfd8237a42b35a5f6b83db0ff5ba6b0d34afb9cd099b1d8c0e9aa70a4955db3aa9eb24f7d9f9eaf9f07edb6ce552b97413cdfbdaafef867ed9f8169c751c8c6d8aa370cee7665b5b803eb730dab15506e3137184f85bb5a71416cf649717d5651e90dcf8c25ffaaa4d720ade3b918d69e6195dd460070b8c44734235f49b33a5b074f634dd21499aea0b2e79992a8c515a6f6e6a179c0ec7068f170812854879ce74922a9f4efb8c188cb91615c585fbbeb4e825fd1191a0f1805f3ea0f0978621074b184fe5bbf71fe8690b3ede2b9b7de7f34cc9caf1bb631bf372c9e6e9b56b2b114c2096d8e47b4a49eab015c57e71543ba3997ccee2ad82a060bb454f53eaf5a46de33d5784350b0522fbe39912a9580538dc6474d90b3db9dbbdf7be4244ef03fe87fbf54d7d924beda5547f83c3503129e7179d5fd92d4e7a13452edd1fd33b5066cc5a7e541904e577fb4b10568986d7a3a408a10cb395f808de41b0f0002a03c8a8a62f1284766d02e7f02b54148f78909230bf07db83c4e9a80ecb37acd48273b41bca03ffd86181230edc56b0610c3812046621b1049836c2dfcccd333852863657e2ef52ebcbfdca8f2139cdbe5fb7ee232a0591765655a2961b84e61f46b33e9032ed991fb9b2b0a2d114b0e7bb8017a92db60d6910d07d05ae48c44448727cdb9415f85c688f18ea5055f3fb251c5226d83f9d0a671a7abcb857080b6deb55917d183f71efb75d877b9def80134a57f60cbca826a21ea77d37c18b013cd700b66078023470ab31047825cef57c36a60d4afbdf5432d705be41c7f42b9c52d8953e06bcec68e2de8a32088707143f7759204166b2f6713ac4e3b4b1cd76e875a501ffc1d3986818dc96728293a662c2f037f4ec16d111d6e4d1ff55809baae5c162b0db95792de1556781dffa8ab12b361f820fa017cb135f9b72c78d53154e185212e9e86d766b8ca074b03ee558d6c7336775bebc452b39b22a9796c4c938faf54267a668ca8e7cf75c773a36703f0ea74edf2603ae85516b0ad784d53b9faa43cf0eaef0ffd37d639b66b1cbb16b6610fdace7615694698ad172db64ebbc59a7e8b77a8e7ae6ffbefe8e0263647a2767f05c5300231773b7ab781d4401c3d23a0a2f50e6b6d428b0f8bc36b13e4491b9cfe8456dc8a0b91b65daaa8b26e997c0052f4ac56630ff78eeaa0dd18b95ffe4861d1e67e7e036c08dae653fd9c9b2d64130c5e5686fa9641d333eb1f1c01fb43691ca553e0351dd372ccd7e5428d11333aea00896067a7a8c256730804daad61219b47d944d723085d9369e5fceb471849c659c8feb746bdddcac1b3b47fec58c4b6a521c785af4efd646cc81c8a431beb039f074f90e21c253f299f371a97ec57ad79a8dfb1088340d690e8da4d9eb01a47d5512d1a3273fe902ff1bd9dcc55d807e1b7ea4c7c623bd69e6a159b370207978c56e419edd300b1cd9c0b3c4312195568fc924fa49384e077b2cdd21033b69263bae9f9c3a0357016e5f7c928fa7cb67a1121db35abdb58d589fd0f2c324a842c726a33cca1e8e8815582f02c5d487f7540a58f51a0f3f815c24278866e2f1254f919e5a76f4bda05cfe7fc2741a7cffd6e6872e0ec249a5efbe96b211db6d856f5c87198d69d4ec9035c94004d9bd6f9e126906a634cae4dcfab37cd50303fafd2e051132ba4c6aa567497e0696d20fd70e32911a02af9c87dd68cbfe1cab7c5ac37aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
