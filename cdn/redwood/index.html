<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"785c79b0a1c362fbc76ba1b7a476f3f1aca09abcb50d3892ab576eaebddc5662202b35179de4a3cdbe900fa4b4ebc9efd323fc571ec5434e4528799eefa51c75b398840a5706840089cb7ba53e215599d3590717ea102f39e8bcd9c0aee052b8598e324e5f7269a3b76a732aa3c89452ff26830b2b8eb0e4df0e7e4286a615e31cc55c6d27940c5be5f44d6eba12fca1a350aa9bf20cfeb7b1caabee904bbe1af1c1e1a28aaade5c4497303094c6b18aad1e8be13f13d4b895fd387dd6ba9a149aaddba3a5bcd0e58fabede8ba4fb3e4e15013bf152865f2a0193be4a5020bf578abc2b17bf91634f1903c44064b9bc24e64ac4b656667fb834bd5657bd824288618f41ee46ddeab89d5316ed7b5163bf676870cac1d76ee73890679fabc1a7f0c7fdfec002380dea2d2582e62a4f4907bc1dda6941766595893cd9fc333c41249ab59ce8571268acf04143039fb07d824384bffe5e3106a5385fc87e375f46930f875c53b73d6000ed2d825387f4329e63feb2b727043c4a3925f8487f260443a4be35033ade8285db6f4321f55fd4d6d0e9a394d150a23b9afdf349742f61eaf47ef762d9c3ccab18d83ad38278b1272bd0c88c8739f22dabcf444314ecbf5c824d0f51b93117bda352ae983e758cb22c0018788000502cdffbbec8586d20523d8320229cb53d68d84cbfcf76b3d44af44ee965cd1e4d459abf379779b18279fad50ed612fca4da16a18656d2b0d5dcf39b855b8187e0be1aa668e1619ea44907d96bb92ce6fc2bb4ab61295378f7dc1ba85075031c254eb23d02927a04188c64045bfcf4345d34609198c98fcac3259062dd2b4cdd53a4cf7f034006c650c391892dd0949a185a39293ccafe9c4e3e7a941e92ed784f79547c5ef987c6cb82d56f526dfe2d662cebf243c0f63bd98c7d9d7f9bd79377e2b87c4dd1bd5c4e52ea442fcb5808ffe7c3bb44cc7758761985483b12bdd7759e7f4fc65238daa49dcc3cd112c55e8b18e4c257c4fef9593efa1b0e090108cb0f163e5e584c620e9577484113c65e05e1028c12c1ffe4360e1db770ef799792e7d4a2c4fbafe43ecd66113906293d07440ffdc6dfdcc7d256b553e18602f7945867d9e24825e8dae08ab27c8ade29f56f85ffbf9351ba5f870decdbcc19e9d70d4149e2fb9eed05a0368b395607624baa3f82e39d0babee32c46af47c17c4a7452f35995b6a8b2b4bb6109a3867f66e35428cc047c93a30e009c5daa95c48ce84c99d412e0a5eb9d7c074295118edd66ac1d84b0a84b32a5e2e134c3a7eed18b5c8c8fa4a1692fff6e0f1a9408b53e52f789e602cd7f229070bd8a7d1539590332a0a79b34f65b571186b8b864a9e14690ddc37042acee8b703baf9c5ac47b4f161638456643e50a578d8250a2c53eccd3e49e05615d6b34cf7e9c0d50e709d5ad18fa9e8cb3d74ea5cd808cc8e36354881fe7a0b15d2aacb97e76962bba39beecf17b7d7c005f43fdd2e847fb084626d654002c959af3966790d34dc9b7620983b5a878066767ee62f32dddabcd209c3560fe216e5a075143c0a1f0f21c180f4adc6b3bc1e0b2e0c7e3aba11e1019ea9ef295187671cd55439631466301dcaf96cc53c10cbc9e16dba8cced9295bf8f55e94db9c0d7efb3b779aa0b76d4ffc49668e0a4f61f543b6cee59aa191dafc2e7ae7ce0945b5b7776e375ec671f10a2476b7536c2e86595c4efc23c09cfa29fa563d74694654a748f2c1e1c07b5e0260402e1837def3acc117a19d47099aedd8a3e9d1250a0901cbf49fc7df29d32b3681492510da3c318985d1cc32b4ac5afbe83a164197d884ec55ba7ad9061301d4f8de57166b82ad836549a310047be385847901bcd6262bfcd59cd7590cdcea4abf96d7fe60194efee79694cc8477f0454507a596a40f21bd5106655da877e27999a8428aeebade93a4e350e2d521e23810becce41148def94f3f7bcfd6a873ae3a7965d8b8d792f4857660083e1ee8e263985342049d4292a6282b4135b2fa01f50d795c1d2610352155abe354dc4b2bc2573debbf8be6d7856528789a14ffc739dc5c2d2b238b4e25e21daf74c6f43c62f235b4f6685fc2ac01b23738922975eebcb591f4fd87a557be8f35eb586743bc7a04777db1858b8f2dac5fdeeafbcf36ec65b67f56a81776f637a882be05e9184569a042d46b47d62b2f9298ac1cfd59204e38b6b354256ee71706ba709b2c41f486feeae2f5e174f7f0fb8b017d0c3a41a44c03e7029e3e1adb5c1cebd3f06348dbe23ae060516b43147fe67d0f33068dedfd45399a9842bc80eeada63d544e9722f4126a6c7d6a35eb97069d4b4bd6a3307f34c569a756917afaf8ef3ab4bdfc5ccc4fbda872efaf85208246db045a203d696a7c544fccfe60a686cff4777eb4edd5984e247ef9a7aea349c1b185227018548a64754911d04d67e5286fd212f471a00cf6d40587a27663f190ff99f81444af3565e1dc30228e6e873d2125f0adf88de5931c0f455901c7bdad36aea97e241aa1ef042c17f0055559cb1c5353caf3e46ad1724d1cf691c6eb400bfbc2c3e773e8a641341ab378b81802f49cede84729d64f24f80603d268896072c5d4001df22182c7514ba28cc150b7d0aecf61df102a248502a70f9128bd9c8c28b1c79fdce0bc5c1d4b5cbc8fef7b33e0977a3cfa04195aeda24d6a2ef6e23044a00db4199de15fb2a949eca8d6ba4977a6040c0f7c8b67dfa71a88fe581f02d48ef6a97b3870dea1795bbb85fa7410cf5e9252fc5c1925f412b1348d97570edcdaf74ba528a6c11ceb2ad84dd1c40508e20859e6a126c18c9e9279b47736a0bb9c96150b56c3e98af5537f8d6f819dbbd3f9ca2ed5ace7011155fd33ea7f205415d714f3dbfb3c113b0b1393e2e164cc362c78ef03796054336aaf211a04ad6130cbb8f89517cc22a43484f3df72f76feb69c98abd91043e296e0d2d6a2e72a97d1d0022b9872a892354e93c381556a26e9c4946dfbc13b447e21561b8d992e86b3df49817f432a55768e94c53cdfc0a30e05776ebfa3d668978224d7edcfa81025865d22649e69d8b22aa6f3d3200190b2f00bfc0ac8c7ab8a78a19b288549187e1d6bb7c17ab520c08e336bfd2b58f58f1ad858f77fc0bcfb426613641c5d442cbab69bdde8247e664a23f2348190737138d6c4f6fd65a7db84785449712ad1dd8d7e468192743151932eb0ce3f2773b6d6535fca4e6e399204526377d3cfbb1740d9f7b1d68014b08aafc7f288348f4cdef553cb2c0432f579471643d0405c195e4b06b9ed008452f94691e4ff2e91ffaa208002c571d32fc181e8685ada6d7031befc57297ee0a0c01ed21b51850b8eae9a162cf2ecad7ae3a8697e6e4c1e0cf23cac8f5871e48a45225daa4708c75b1fa4f9702e4a4ab053e6094451a683f08e29e61f8fb8f7f70ec000d6861344d9d917deb85b22f1e543d6a7cc0799c0045c6702aecbdbf60b65521171e734678b4e9245c6bb80ca31e69ff0559d605f416109502d173b099c990c9a84df5dba01bf91ce759d19c5cb90999bcc937f9df8412face32937ead0670dabcbc6c83f4be32041b70f86dd4cef22a720171ede8fa7be35283b9f48b1099467f9ac4951e0855bcd4e7c8b898f30ab97f8890356fad54db46cd898a1f820032157f6817754be59b676560cd855feb4befcaed1fad26d69acd5853736fec6883746a374c5d33856c2ecb3afcfd4f9dbda7c49b41926ea73527916bc9f8a8214b3480ff5a9ab0ee6b599b6c7f423c54085c434cdbd1171c1b3e7d26942ec9ba47f01873bad08ddb37e7cc898bd21df535160d6a9bfd552a5631b57f85ccdae9934c60a39be62b0319dce11707594e7057ddbea1da2ba4fb18877bdc981a6f726f1316249f028db03db26205b6b453b7ab9037da271488cdd6d9bfbbfa9da10ef401e4f8bb26e6ed15cf44b4498f3979fbf26477dcf1bc120339a1923661fea9cfcd73fa24e90faf741b3abe5438c525eb9d379db1b7effed6c1d80af2ebc1d6ddfba8e7980c1f06da46b098d415da707f63b660f7162cebfcbbead089097f47267718cc56b4e9d06b1bdff137532ac95f235462891f135a9ecc75cb84be8b49c3bed19325f42b7c68a6f42795ee46dad16112d308b7772352ad454b8c0bf99b4e2bacf4d3cc150c23922f5fe8143ebce360e37d5a352f088bb4282c4618d0f0528e2652ee15dd760b05619f1ea5f75b6ff314b1883820c07e6ec3ae1c3b4c0f6fb5a0989c0ebd653be1775644158a2c8a616f4944dd417c736a2aad9f21fabcfa0c7cb4c9f2392c5ec50b41e5825d88b4877138821d3ea3c7b96a7e03060317c28d9c4f68bd9349b9d5511fdc289339f95e7263226dfe61980cf8c3ea7b6b9d0d7c17f062c0ee04a061c084c9c179dd8fcb2dfe24d89b6cc868079106520e9868348db9f12785270e1bbc54e9ef3a694e40d9e0f6d2ac178ff53e41cc437888a452dafaa22d3153cd659fc73a19934ffe9a084bd165b6b5603296a5a68cf4e6c8dd51636c1fd983aad20d6a114adeb42a0d74a17ed7a5ba9beea7ca04b2f91ce6a0556c038a778f4500c87212bb46ceb2dc4c7ac4baa1f7e516ff0931b461a217f68fbe2f1d29e3c0eddc8d5c1fb659bfabb24a0e97b385d1990c0b00269389569942648dfbe147a6c18e79009f8949245312b6aab22ed73e99015f5ff9c8507e49b7c9b5b64bec402d1ae5bfb645c251ee10835abb74059b2351bd5a88a9a6596533d5e6d50932f870ae04e50093cce3c55adb59e88ebdd934b2e3843fa7ccfb97441ec65908d67bcded61da1336e08931223435693721a88af91e304cafded6f2e31434e77fc5f502e8d881ed98e4d6f288fe5ccc6d3e6df5c94bce01df64c393d265492edf17b744c8b0dd2a8ef61ecdff0f07847e55cd7d167c87d1ab65bde814cba2ff258ab611ffea10eae35f101a28578fe53a8e71db2d6c602e6784ff0edf23518e8c8e0d0e6a30bb5e2b437a35ef9526c4a33724c4285bc5157e9f76aa7727ce21514513926fbe412008bb731feccc2b17b7d33a08eadea697fd191b8c2bdbb2f5af8023ccaa0ade21a5a31f7d28ec4e327b9cd18ae474180229c19f5d74c6e8dc9274b5dba9acf883f703b550a3cf86ff4a02d2e4f9a4ed9c97fe525e35d11b6b1856388cec13f0219767c0e7c94660e90f5ad60631d05b2519282cc453b4949d8f7d51cc7d2d159065c8057b0e3d6c4598498fbcb2c928cf06921195a013dae91b2a1a11a1becb0a78c4a7fa88cd15e26efb3fd363ff184750553f302a0cb7a713444a2ff9c93bd7915f22b588aad8dbed411cd869878f3ad50b5e94bdf07b3bfa4c1e65212f07147017e75b573c549f357870f4aa236bd2de0a63757ef5c340c5bddbe30faed891e076b6c58a4709ab71b9cce368bb36d70023d55c3d9b6fd55cb94bd4c06647e7a6b12ae75442eb84a50bc3878d21007a4b544b9621c44bd8c51a85c4f966ac6d681d4364d9219aeee3d4f874b0041984b6dde9a68e7581f19a07a8f11d22b79c13bf9429cfbc7d87028865b8e60c11b8afb639355d4fb1028c485f1acb51915a35203144d873379e3b6b2627197b21c92aca5eefce334c92d52702c83d93790e5e989d23d5a0ce04134ea7698f695180671d1c0c007c01ff6bc324da91fa5269c4f6fc7bd52c2c328b8bb6572f6fd3f6a4be205f54dbd29b33fb7afea86bea137ac2aa7d83fc5eabc2e2ff2fba6171153e34092490ee339a3f7fbd6af78a42d23c7e6091634dc492b9af4c37d39a2b2ac441e9a3b10ce501eda2fb45b295cb0515249b2d1f99d5e97e304c596892a7c73ec45121bf0e2d70d6985a70d643944a8ecb854eacc321e432ea485536a1fc790b4d5ad042059c8b39d44b03ac17fc0f6e558aa8b490263de985f4906a5b9bac2ef99e2d71a84fbdab414e3304c35a5a7f5049fa08486a0f15b395d40ceb35e35ba5a6b1aec347c4a5325ed6ac77c026f437d4e6bb4dd9658e64dc24eead2bacd421c714cec6cac23d8289964a3389dc993d6d15aec13fe3fb6acf003441ba5ee94afaacd6d37ec336fdd96b898f0654f35a22d609c1f2ac617b2ec327a5df3bd9b9c284eb9b480199544344f2dd7ccd53727aea606d1877a2402067c9000587a2888c32dde90ac5a0a9dcf6f30dd8c56e14df112914ae569d788ba07f63b1cb18fa021f712d30aab9eddc897dba5a4d93ceb33417a1fe03cdcb42bd1b794577d62db57a35953ed624ce03dc08e46293c9db6ad60cf083b0aa62958a649b95e3973a9e69f54819456c5241c0fe16b61865c023441971264a2698bcf8f1a66fe9d681190b2d535bc42dde8dd2180fd0cfeb22a605ffce90afd5d12874263ddfa2726be6e82e5827dd26bfe3d585c70b51c2c90305e8ec20b4b26d13583b8bce3f3c681edcb7e3ff018d21854bbc740590655f44e1c349c3a3a8e32e989f17c11bd3ad2b151f5b2f48f117c6b11459a7ec3693b24e9344d2ad61c814946e684be07cd810d7c3bdd5a23284dd1a60ee71292baaeb345a94186879e927e2464ac35195b7df158adb48c096f1c4114de2044bf12cdf4a2af0f57cb4aaa110a21a91d918e529ce3946db057bf582092a70aee790400e809210d49c68a5fd4d95a4c221b79e27442fea0c5049b981f8562a5b9983385e9f0bba942f1237e28a12ff1812c13fd140089897a8820abdf1f13eedf260e2c04b70b1c2be7883637c8e5c351b74417f7406f4a75ee5110cfed639ddea356c0bfb1d7f1f39a26ef04f837acddff5097dc1e066b23462234823ec385993e28c56bbef3692bbbce8da58c1a0526c6a1fe1eee795ef8dac013ce953ed7ee883d63b7592d5f4bb59a7d58360c9c38f1ae9e7a1358e7033443f44da21e760996be6c497269b822f357a4e3709b0db2848d61f69361aaf353c45037a41a6b76af1b43f5dfd92ed813c3e9156cf3b9d19c36cdc39324a3e43dacda78288da88664f3754ca5181abed3c7d122e0a9e78245c11e3aecdf4fdce6d9ea20155bc0c43b27b5c81ccad3f91b09a63f51be6909d7c9c08dd2d8c4453ec1cb7d552f500e0f89cab6664e17eff17bead5d3363f4b4570f1ba9abfcc13d3d7efbcd0f69704b4b875168abb13bd9e51cc5af60c92977d4a61825d709034fa137ce632acf50086277feddc80b361aa2117e612847a1c055071a7c4a1343168ccab04188efd3685ed112b3251d98c1ed698ee5566e2076d8e30fcd1e6663b6621ea6aa47a67ef2c2559f175e5c27a433ec86b5c76e379c55f3dd0bcc53619a4bf7f6e6b69792c33d00a76a9c33771638cca15be09d7be7d70543c43c528bf50f09019824907d4c446525fe7d339408cd52bc175eec4d814ced4ee7580de149505ec0d741aa473008e1f4e3539b80e1b59c44af3cd75ddf6fcdaebd4c2ecb9056ef3844ef45a3bc823e08ad6c70acbcecc3500cb4b1796adf9b6a802ac57e8c7dcadfb100b672b518da57045febbfe992412b3f4f4c140ca4e1e5206ed89e285161cb8707780ee50d5ec1f245f7e19dd00ec1fa4c95a18bf2911226090826f59919321e2f47529db33d410e30d98f05799fad51d17c19b87f101bfbb4fb7ed3b9ac601b862025a50a94c468f99559e3ac4c32429bf42428045d7c82204fe30a394e2e762cab7880e5c548d21b186c91b88091849427f90e33aabce839fab323a31fdf25ab6b20222c3ebd0702c4a1e5c3872e17a6795280976b452ca887ee721815c75bf0ae309f9ab2c5a364b072dd64321d43bb35f1387e336a378e2dea5db708653bfdb59f5b4c065b8adf16d358da7cdcfb6c14ec2ba3856eae4ab87eea3307b16faa328be9f50d0039f1e6c359b6360e4f1dd43620e7eebc9de351319b90d722d8b0a292d087afb4b0a7fd35545a538dfbef0dfde53b3bcd669c8e0dfc1bc9232f154b9363355860edaec436fc2cf42b44c445549bcdf2ecf50e7fbef8c83a34c361a758847fe0de76e061e046faa9196bc5021d12c188b3582dc28e5615e6cbe33299155b9f648f03072fceb6ec64de9c5662c285cb394b9d95078b0252333a91df6c3fcfb9ae675a8feee2185cd872f3b7e16dbce34a49c1c7b88f65c1ca9c229d1d64580cb6a57e4c25d730362c12f65c63e8c80581a4ea7f2bfb88e52b5465dd9c810d8ec6948b23d87a94bcbd8a83b6381a6bf784a8b82f0b2241ae186e206ee58543aaf52d743cbf2d7abc3482197d1c612338fba0e7598eafbc07abf1a9f1cb38e037e4c242ab8281712c2ec7e278251646c372dc7fb0b9aafbf15e7bc5c642826c4c9bcaf42e9b036d2ffcdbe6f18a779b835cbc05c9763cf7cf2c8bbb85ee8eaf290375ea77b91acd584b16d0784ff766202209af66296fb49802cc88f7ee17d448ec069a9d673577147b11e9e9319fdb18d9b461c95404d931b953ce78560bc0160235cf32f765cce7a2b57a11c74831f86767cef055d07471316189d0c23d83d83da9ee09704765beaadd71e4db50cd86232b0fc8c8965dafd37e01531f2874641ca5b35d23d4a56c292ccc282bcc8f4591bcde911f3ccd9c4fcfa6afc79290c361a6fed40df80e2502b987ee4cebaa3848e3c7ca4e1e1fed338d8d7225b6c0d54217ca26297f67cbdcada18e59d0a6cd639e77af7884fb0b5f05d897b42a8a73bb22d9c6df086f391b930f017dcfe9986e27ba7e68cd53ed0ad02a33e03f0b255aca8a52aaf4ee9e358bff80458fe4a04b9fb8797cbe0018f2bec29c509d299a74c5191e2245b25042505a60b17c0504c7539d0cb52e7d922f0ce83c22b7b68a0bc2877e2a48fdd38b3e345c1d27274787476529b91921177f82ab64d0b93f597ed9ab853b392547d5ee4daf08ce1e12ab6bfcfb836b19c6b5714b68e3e8a562f25f89884d5fbf22a0d4020227350f6c3ebb2fb70efb7024eaaf44eaa9bda764d8e7d5a595bf9d29eff4b0490a438023cc7807ed84a0ddffb199cf6d7ac13b6c1085c3048046fdff58783d502a3daa475b2b1fdbe66a54d42d2def65ba25d602d9c397c9d8bc47b3fd7180816ebb4a3d23450e81a307c49180310cecf6ee933a4a83289b8feae2d8b542552646a8842fb57ab2267096bc8943390ebdbe29d48b060ad52b130ce7b67506f6e033a9d2700fc12439d7c86e8c66e6aec642864df0059b0aa48ed308f81de9e60229fc007297826a3bed49f877890c5a096664e3f018654d0e454ac06d0b1f29d0b3cd3bd5d78902e6be8d42bdd952e9ba7a87d0871b08ce5421c9a59c82ab4b1c9f0d117b899a5c7b5d6f101dba2d6ade987df8dcaeb9a8c90f6d7d87b09ca8efe1e02dea51e41216abdc4a95db5703358d3449390da139adf4e934b3794958ced950cc2704bb5df08ee0637f6a531734e7bc616bf899d052d4aad093d3026b336ae9e5262d17347bfe744a36eabf18714ba64c4af53bc4567af3cddd57b74780d41c794304859c20d9f16f20e113972e624806784de8eb082d39213f6e880b2d1a2f44783f907017c103592e90ee54029d961bf6b9f7539842032d490994338e20b337c7a82fc8f5536313222036ab988a64675d5d8844062d41224060f28774a990c462a8499c6e920fab4060a9f39eeb4290117e1c7146aa8e66f26ccdfcdb27c4cf8d47162fa4cf768e9b32d1301342f2f53d2c7f9fd219956e81abf3a9c8fa5b40f4ec98be26cdeccba0c52d04b5f14e6ae885f24dbfa1aa9eaa82c897cba1733c8ee4354be9ec188e1e1fb2610df8f90ff534281a6ff1d12eac23462806e7e4c375336e466bc1e5a5ebee1df328ef870aac6d311568e055917f1ebbd4bbbf34e2cee71b79f61f939cdd84ffc65097dc6e5b98a5e517ab76421d8153654e2e19c876561318a5f92f033aa1bc14f245d3acaeefad05d8c0552959b2090e4e83afbc211306afb6432070efc74a7190036f6bcce749c588064e2c677ccc3d1ad594164224823a1bb2cec94c86c7ef40f4148049df96e377f08686a6cc0269c1c2d7d16e3c05bfc8608b463304d458cc49bb46f24f7b6fd5d8577b19a5b441e0204fe73efd5c13f2dc318a3ad71cca6ba8481222002e5a7ed372f718994f2767331973b77eaf517bdaa834ff02b4a2a2b2039e185fc58a9ca8909f8540989dcc12dd80098eee509ac0c602c1e400ecc74c271df368111e582b91188129ae33747ea79f7f5101ffc24ea4ea233050a004abb2a7faf8183f8aeefa2ea3609bd179fab1eff60598a1b52f2b7b105297259c672dafb50c2210dd140052d55c2a7a958857f67e53b41af0c646e8cab02586ca1139eefcd39ed7f394523d7583878d3a96caa0d1f47d89b90047df02bb1861d33fc08e0231560987ee3d84c25660e91f4bf5f963d7aa2577fbd36d93fa5aa2381ff06293a827e9a1bf9fa2283c596314b45beeef60e6909cdd6ee796134a745b02ecee4052e203cb027cf22da2baecb9153b739dd92cd891766fb3bdf956c28520ea13af57c3689fd28477fdf7148013741a31fb0e95d809ecec9987b861f93b01b6620e722e83763a63a5cd7c31ed6c5731ac88ccc754175a27a5387ebdaf2d2e1d2a0143f6b39b4c027ad69db5cf0da60210b65bc17bef9a9c66ed1c8e11f125fbe0c1d8d2bb7e18240c06b6f1c7f071e8c98a935fdbdf2238e46cbddacdc2a21ef42f93061da9ba2825d83af64f0436ce38b98d242c85829029803a4a24986f6ee54cc12ae1d845597373f03d581af120f2fb388015ccd4aeec985ce5ed0fc5805a6f3cd3809947731e7bc3632deea373e1565cfe57a4943d41ac05620acfde9a22f84fd3032ca5df4b731762a6c2088bb96158990bd770f51646e844848ff80f797db2d7239aaab6d9bfb56e365ee9a1be98eac6d13111287ac9821ec3702e75ffffcc3cf959b9d00e2e46f22d733a30876af8f20c0da5cdde3ef8e2667f0d6ac55615038f12df5321e93331f9b209835a63d90d0e80fd4bb6706ec7740bca9f10cbe1c9bb041a7ec245e347508143b90d89b5b6a1735f3d5c9272bc8b28dac37e52232eaa7d2709f26597ccea9c21348e5ea89c746c25bc05bf1c5e3c88a5568980bd2af73360307856b72d76ea9c543f038bba4a06a273620a07dad4dcd91a8d27040c3f9b8048f82678f9789e8cae825ed9739fe989f87a508c8fbabb0b668737c8c99de41daa31f888e5cc4dfce039de65e606a58155dcf4aaf26115435bec467b897f9a124f71e502b26ed59a04b1e5e2b4acbfbbeaad21c3f54c3986134400be740164224be8728e9b4ab692fda45bc61444c16709540f1595ea423b5479b75043cb152c7faf193d984534d65176693d874bf5906dc76f43f3677c6d30ad60016aa3ebea5eb3c45365163c80904d1ab21e5a1560f3828337848d2dea734d9f749bbbcb980b2c59056a844aa94bac6917854bad67449610072be751edb55e0628516824e210ebff2d04593366833e0b42ab8104020a8aada8a6b6ded9f360394fd6b9ac0f84f56655a7cb5fd136574e2c6566b2c3c13b5af71e790222c14aa386e9bdbe1c11f659cae2c4d7dc7ff1b7f9cd2166a537442ab471587c20104c0e03fdf968a5e81ca5d6c98564eab9866ac7d09bd2095f2f005adeacf70acd15ef14aa059bf695466e0dc7e8dda04c643354b9bcfd7f87faace6939ba4bc873b07fa28708cc71819395a509e05adb465d89a7ce5187a9e3861b0942951d2e323f1649fc976e7a9c9fb536c09eabbb4836d92fdb9f67b3290f7230cb4e5dd67f4bab7c4560647c00a4c7f96dcb9b13eeb86d3d664c1666978e675286c9d7c62065a3ceb4c29683259adadeb4a520bbcec0cba084178e94977137f437b34e08197d2848dc993f5f873f2aa429abbe4f670a1b735e0fbd6d76c99070ff843726b12951879a8f54b312cf30153e13a5cfc6838882a19862708fe3ebd6012af73d491226571163f39a003262c16f6d6f1f5005346c8f8f7d6ecd3df3f76c9d101adb126cf4e48c4e32b3e775ff4e5345ba24f38d361391b8cc1f041fc308016100d1e7a5a2c0d35b54fb39fe9559c8892c9221750ae92d6d3325dcddfc6d6dc97413e26349677678543eced059caf4abf9cc72e90f1e6cc157e43437a9a8000bc45385f7844bc02b4cae57016a25894044487f64f52422da7e712f82a3ad34f22fc71501fd014fbed2fb0f34de5a6fe8ebe230d3c3b40e26572243008e5d27af9c81a2bd7f1516eb99db592ea139c5aef79cc371fb021991cd72dd0aa823e05c7ad73ac78aa34a7fe6e0afa1dfa30b949dba4b8d946e629b8751e06a8395776a5cddb6e9ebae4c33395692cd6dc33d417f8ca12c7ba6f88a667a8d985d150a4886f8fe3518107e23821cf6ed22a009eaaec288eee3c6aa0c0b8792d5681fc9363127c5ba9ee7c47405d1c7872d5875a051a7f75397324f2e13fd213ab0825d87180c3fbf18731cbf3251f93d78a72c257399459818cfa8f2194c395cc1afe13c9f8baa66bc780167eddb2f04315761eb515dcd6879b30d34cd8a98ec8486d03b337a7248c117e9a347a228e022213a44867b2f1e06f528e4569f9a0b68c664058c4e139ea16b6ea8f75ac18079ae474dac506683c17e363d3dab3837a24319f3fe45dd952c286de222aab33e1b7d7ea7335e6575d1d724348575a45dcc327a315d5c3440aa3b929225c12a56f651939a2f1745c9e6c949588c9274a926ba8f59fef955df7c5b3fa2abafa8a0dc45e3560338704dc541b4bd42c2b3419b4fdeccf45d43e880e6f61039fb344c9950ef0e14c19a86da229fd13a14bdf2dfc6ebc37bbae174ff2e6d1b61eff262996bd955c6e57e6338c19eadcf1847586ab32f94ce06704bd890519a732d2b7b46816a18974e5e8f5c56f3e486d8a449e9f82287f4f0ebdf68b6bf8bae1fa8a9f15e670725dfc9389fe3a5dc9a7be2caa36f096f2ed10d750375d633b9c3d15da19ff4f734756635c2937d43d77b0a6581f608ad9caaad6c91c8df8b823198b4c7bd9b19879632eb7e4a9518b87232b51267887b1141a47b7f8f8fd3d76ce32c5e3391be51aab1eb1549afd90294d3889066bd3b927d74946065f3f0daeb0c131052a8338c423a6b742fb026aa6a59095637fa9e832f0922fc19c0f82e7e349d2dd3e3845c4ac1ea69bdd065665781360778e00a67df24ae7f4f8fa9ba18fcb00d166b9f9672933ce4e0390e33e030a4924d887752b2f7304167965357a3a72e2fd061caad6b8decf69236d8c6bb12e1e672674ccc4ff0a426f6e807ff09b34b732253381f3189a098872d42ef3bb836e0efb2bba64b1e3c5273691aa436e8016766bc112e31ab23f709a1eac5c30ad2686b2517a9e50a1566f9a58327ac7f63bb9ace9a1c6233700d5ef3e09e300a1cb3d46039596cc8cbdcf1f1eb42bbf2fe20f16cc8575177a32ef91258c2bef24f5b026213d65b1e6fe1dcade96e27323568b5ab82fa6e7f3b405fc0d228dd48d4e40d24be46d6b66be3f0505e16a6ebad265d35720c86f2c9c32536862f8b427b32da9598ea4a0a210e3f88d33750d6a7e8d662516c14906e281bf6383dd146619f5b91ad004fe658f765f47164901081d27a7e386a2db372ad0a5081316846fd402c5f207b224440ba8b41ee219abc24d15bf3a8c0fb2493f20e66c3da3f0665702bc647125ad7906e66535d304cd12dde509b433d8a458ca7e4a04c0184e40f5b7602f77f065a113de90812a68591a05e59c6eddca3a27bf5840b13e0a0908415a292c33a48153b9289686e5f51f01930720d3721f6bfeb7f3d3b1b5f7e4cd9771b4c2b03713604c87daece03636b7e8db5ad98b9128371016576b1c42ff5efb46bc75a7ab76d19386d1774fb29522d8c6114fa81d4a9c91775241a3502943a2876811c7b7a972f1bb59e81c64cc29c1d32b9fe65c10f6e927d3e0b236040da083f2e186299f9ea247c671fc5dc71e2cfbb40b4f5c292fc54bea484cedca07ad6c2132421f0e9c07b1486db6fcec34f13e65ba655670e6ff5e4ca437d2de74af30f900e9b3c3d7e6b3b455e5fb2bd41fb255efd2b295a988cb12e3f680a1c3d2c8067a166b75cf839c9c3d1bede93a105d7e871611d2e1f57a470045780ac30f5e30ca7c42f771fa977ed7b8888e97cd7e701c01430f8d5faa2108fe787c70d6f81b45285ce9218d1449578bbf353a86ed14941b0de661f78bf8fc0a1603b89ba2a704ef7e17df5fbb757ed93e12164499b86b78756ad74aa910f852dd5825f3df5b5b4f98ad04a22cb6d66a64b5f79e627799e706381d905a4b71ecf63297e9030e011f06b791015c5430f0b9b0143fa9526d3999395a03eac9645f036b02e1aa5b3dfec4c9261ccff5b9c80c433c08f008381a84a3925b4cb2a9fee614458de2182ed5167df0d65fd3a1c31eec5724860d8af6b9889749da25d14911068dd7a1e10abd87ab2b285c53f269257038dd9eb694ccd620154085640bdccfda06f6d7632cd6a5b0d6d7a82fe8bc57122154f0a15119ea889981d003b37fdffbabc7e8c7b4278846fb720f9458f6139a3c8ebe881cc0017b200ed51c4d419d8ac3fc678708d2c7c1bde16fb03abbf50005f2f3f924ef620324ca2115dbabbaf7c27bb7d14a30a8f156b9c2885cc74363a9f2c9b898b0d9dbba93f5af2485ea0171e1f74940c1647075cd499468487dd6b055029a3b17e1e88a560564d564b336a2b24cbaa67b258aab55d84b722158519b28a85e5d16a3e508d36bb130e8edd8296a549f1a8ed465b484e4e2f4d9a6d3863637bce35938b9d20a55cc4e24e85b02118f37f21ee2e2a9dbaafd8198f4f0759525b593a630254d45512309928b99bc2a691fdbb7a109553b8a54d6e93b93d0a485e29ae8dfe3e1f77f36f80e9c037308dc1d3193a12d8fd149f255541342fa87d7582217fd038525a472aefa408e797b0c43d041bd701d3113882d25300ebc7837346146756dcb3d2c17ae501b06907c73ec8e9a36239ac6bad9fb0dfe7ce8fa3e53860ca75cdc8a08018038f5f3efe2a7ea19b067aaf88566bcf0de9ff983944475a8f8ec7c98d80c7ad3ce3f7d6ec4768bb19c65649f52ea6c4f224f63f4ec7a982703abc567ca1084c038cf9d91928f619d0047a446ce2fa245e95df709d2789b29aa72dc297af248637f7e7d95186ced15ed3420d88c41e01eb0234160dff4e677cd40005642ca24cef6e44062d8aa16df133437e143cc6cd26b63a85c4bc580d37d40b13526544ee9e10de068385dbe8751d11a578ae44603e3c081aac9481914b2ca1b1f56113fb1b25174e5d674b0398bc61d2feb64821ed52755093e119324e0e8027cd6e0fdfd59c09b619aefcb97fdfc5ab1f9ba40bfc06fc95590411ded9bca648a5f21eb0e7173fc8287c697aa86eef715f45343c10a79557b92b24f195a61db5bd08cdebf0af5e72af6b99054b958f287fdf66e5cafa4db0eec492e5dc3d09e8880768f11aeb54f263c3f824a43dea3c07f3338be6fe9367aefee376ae1fb8ce32d1d4a9ba9d7fbaf98b8e616e1ff834c21a562ba3aec6615cb3c660ba047c67146c931ef98db0d9657b5d7ade2a76dbd7d9de09f23901742de3b05b34c1ba060137c8a1fb08504259534f84254d586fe17c01ec0a9a33b449308624d7d03bb05520b7d02ae64034e91307b3c3b2d6fccf85f9ae238586b526b43401731e3a17fbff2665ad904157beb9342a0553c763c88dacf76a4e39f4f22d225c2dece77b88a0d0e8796f11bc7a25d116eca0931ca91227cdad55a15e0a2cab1c571a5c77367cf5a2f6631e8559025f4876b9544baf842c95ee475eba33ca770042b90f432ff497ba51adcc5fa8dfa76ddddb4fa0bea013d8af7ee0b8559c9d6c89f269133b35643894c0ef44a95869435a15cfb490c25eacea158702619d3f0c84250f33c51237e60b1bc867b4090bc20e13289670498d987ca50bcb6754a79bfa04e0058a79e14bcf6d4fd6e8202cf2adc79a0814591b5fff6930a5eeab59f2eaabb2a7e852bc936dbaa992b384ce08b1c70669c410bbf6fab37dd6c97d1b82a37e7f8ac2f47803a4b0ed2c2214416b44ad9eb18bacbbc2edf260cc86f96a6f56c80e52d0555aa54e1646674f8452322cb00634962e3c07ccfa47489679cab3deb0e0d812752afd31acd981c9d6de578d40c11b7ffde0e58e056714c79fcde8352ebe428dfb42d035d5ab3bab2523419e2db4bc9e096638042401da80635c63994c7c4da6baf290485ff2bf448f197ce4a41e1393e306c12d4b8229a1b03cc24c7d42e9e6c2b7f13dabb1347c52c3d44c442af3de38fa261966ea7d63fc8ec5ef92080afff6bb65589e6f6b8eda368421c6d4889138fd7725508270311c6cf715c49a954dd976a9a650740a9c1de1d287e52aa1ad9dfd77c7abf6dc65f34ba0708fea3f6a80dc767ec0495a07c8c09fdea71e8c3e998eeda25c2286de6c842cea2c05fa766a6882e85032452109b82220f6a8dd26619858ef1e9a0598eb1d54acd52b115723f44d7742b7cc7ebe39f6afaa1cd287d6009f60bb141f06a7e5c0bf67321c95d4a0d0228318643832c2d8b4efdf11b7430769e2ef4964e69df05b420a01c78ce8eafbd45f65477132fbddfe410a5eacaae357dc6b70e0cc74cded0698a70c38418c09e7330e91c29954e35ce5fb1515897cda90fa5eb3ac761e08781632ad36afe4bddc6a58d517b9aa2e1f2c24c7dad587b086b6d9c2a1031217737c2b4b56cf6658c95fac738a749074661fec1b3fdbbb3ba336e5c657029331e44d123c0a481f533eea4a35f796f67708d987e676e6e2bf28bc580114f4b90049d3c87439d28f8930e695ff449b09905e9e9801bc6e1673f0e5399ef5bf8c2ba654fded4f74fbefc5621d9aada4e2a17afcfe0641b59374e6d8deb5cfca08266679173592cab49ad6b351283ed7a8c885aecab6b6125ab0b1471772a15a25ea90f103de577300b6edfde41f4969214247d10e33eeea287b675aa7dde5cd8ed55baaf5cdf57ac1d708a4c744dbee3ea8233340e26ee8da7aa41592f3742495768f89ce4cbfe981847f1d30ffc60630dfa10c77cc371cb8fee23b2928c549ea6de295c2cda3eaba0b32c35e71fb9739595083a5869779b5f6f34d0741b3766dcbdedb875d846bb42acd535681379a4a4b7a99c5154d625370836f18e9ea022b259eec4546574e05e8334bf86e70b63cdd797cd707e053cb140670493ac6261edbfa879f67a747a84430a9c0ab5ad65b93481973f290480f3b73b1336a91be26d4b2637bd6b9293a6048c2173627a9e8a0fdd0940941e385fec6754ff35e55167df338ca88b10feca13684a9bb3d990dcb7bbe75290018a367555889023b6e5c70c269738120c0925e10c95b2a8488ecadf384007b56b47d4dd5e734204f2f40df765d535de5623cd176481d29b6793ec0f1686b84be674ea61c5ed4c869a84ce5e0279540746ef0c51d4280cfdb6851370d052b29b9e9381bf19356fa1fe8776f578aa577b2f8c075d082887e56436b3ffd43e1376837c964a9322f77688e378bc742d4de25cb939d88a7524032b7d3b3d3e3ed34ef139932bfdcd744f0d996735611f8ff238fad64d1a1270dcfaf29a3fac38e430f0dcdc054bcfe3b5accd33494c2e29e91ffa3ff42249c28e63b0f9a2e10efe4948bde151ad30301dca54e9b8d957220dcbb2d8338f9dfc39f0e4bcf10808e708e882a39f4dca192e8561c84149286a3cb8ac1e8c8dce37cf18616ae23a69446b59b73127303aa3cca4c071703d7023b1b7c86fc91b72f5592fffff32fe2e183cfa30877ca9b61a45c92ea16431e8bf476346447c4f850e8f6bdef7766d00cc0a503b4bcb386ab2f58add29668c5c3cc0872e0ef06d04c1d9016fcb06582b86ba095faab4d4a93a0085b98d4b9d7139dc66367c8bf3a2f07eab2b590df5beb1544bc361f567def23f39a4a7af1531ebae86bfa093986900f358dda649b3d9b4b152f6136b209601ded74db14aef72a8e5504407ba415afca2af8c4ec93ffd73f45e82fb05dcba333a8b5ecbbc0e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
