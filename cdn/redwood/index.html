<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d49c4f425eed65a85695005750b19c26419f3dc4b82a1855d5e48a90ba42bfd29b61e5143d3cf0543d4f70bff36b06041511247294714e4be93d62648c25a3ce89b27d1d96587b794b6476dd9f84a82beee6730acb40539efed78ef548319b10d897137ba5ef878b197caa6258c3e9984874c83de77caa7c4749c63fc3c0cc4ca7b44c11fcbc591c6aeda23d3ab8b11bb4b74bb4d4b478d034feb41acf3d6cbabc54cb3c594b9a12da951e927beed1e45f80cfb1545c759bff151afadb66ee57cbda656638f7677673cc4932e24ed4583eb1a63d1f7726bc863e88301582c120df172aef697147107ce0569b0670fa51bd7c2e71a5d39303256ee769d8f60579984468a68668c83f5d4056af4dcd4723700d25c494a23860d0ab8856ad0f2c5b2d1d8e04763b20367540029792a9e4811bd1f7dd45ead8883474960f47debd790b45d52d59250d36b75049849463db64d0a1f0a7d88d75ab66e32becffcfaa07c65e66b2d7da172c173498e1846c6ce571d0addbaf8e73389dbdf8002d2e59d027bc1d2f9f40d9493bc47a434dd73d8e268de8c955a7f1dc27647838ca5e954279b5639f5fbafe0822aba935cb9c522cc7744344f7306ecbe0fad6bbfd20e59f7ad3fa1316d77c4e3bd15798bd20f2bfbd3a3b38fea74c8382918306acf7f3046e36f46eb43d24c970388dad0d22502c81b33545b5e01c8fd916a169ea331b7665b0173028c9cdb327081bb83fff8760de6e9f26053e9f0a4e675ca64a6be1fbbecdb39966e9f2053df748649b50084be0e72ab49edeb3d8445f48d129deb4ab6ee2285edc3f40ae9c5693f5211ca144115fadaf6bfac938044a3560f96aa8d88e430814554fc725e4dfdc411f0383b265abf46c78d2452fcb6d55e96c333644c4c2d2c5cb29c844bad9f9a46949a24976d1a948ebee359fcbba4439fbb526cb077ffd9a6d0cc4e811559695a1fd0855901e99e48f2f0e06122a109208f2f9d46aa8d71306057f7ed27bf134ba8ae8ce394bd2a72c70185e07c651997d91e7caa665bf4d22053fa0bdcb5c338b99c2f3e95a30d4cbee3dc5370c8dd46b53d304658a88280b698c517e9570d8da5d520a277a0cd6ca78d94a126be8131fa9e2bb4825cb15427d7424fd151cb1cc6388b8661f04734e5a87eed44e00c0950b372b70ed30498c1634497c37da5e11c95b34ebd8f41afef7007e370ceb4fc137c00621d184b3564cdf4b6416ab917e527e759148b7006e001f7385886cf80b11a5cdba2ee3eb9cb24379b7844ac340bbc20abe1654f5bd68d6425aee24ca8438de34105ed07629b02791ec0cb147a54b5b3459759060a87c3dec860719872317b2d2bc376c8e250f249fb686d409bd238b3f7016e9b500c66795ff992dab75cbe5deb75d20a9c8e2345be8c0ad755b779c032404b368fde878e12629516b28b7fe69b85fb260a28ac394ee6b063e55301c898327fac097f8c2f1a1b73350edb7c58d4c7ce3588e9b925c1b0ad0edd1b8463d93d4d44fa4f6d03911d931c759f4df12c80eb7bf4ad3f1008bec43cec685c09d8d8c8d52458658a5695fbfac76e9ee8ea58515800a8dde2ca6a04796015d38b6c649620101f166a6ef4bcefb634e5c0350a649337f6f1de41dda0915f27e22dca70c22094622ad33df1374e76179b41442548457af44a833cb97a68074eab49b1a3fabc03514c53af5af8a000fcaeb365accabcf6ed0d9df76d03c77dc7513e97e2095bfa7816deb9f5baea18e31ba5c8827f9d3cc5f256813802369a8f9286d776589753072be7bbb2df5fbcb241477f908496e19c21c56bd251923de056b4b009c12edef9b95493f2d065707d912e2b92abc383df1253c5b0a49e224a7ca99a3472139e138500fdda486548df55b48d82d0e4b77fecbd18bd89107d85d0b81d63627d7f5f449d78d1eca3bfd00190a78a33aa08fa70349439da24db0c5ffb88e9c20ac47a3698557c28be4e2b28092c6f0b640226d2e6d6f63b3f04f8ee3743923c58697ddaa3fdd832d74db9bf8abad561af917080b86773fb9ae70a90dbb24a8adcdb17693e665be66b50bf81596fd4e2fe24fe7e3e926d5b82b5e855f319af1f3c48b12cbb3454d2ac6cd6720932bd2402a593b4662afa100bdbd66e49781fd85946fa1f743b70c6b7a507912f0809d5542ea3b781dab54cc6e6218ba496e8fb7bb5a6dccfec69aa03a8e41262c7973af2f5c899bdc737a879715e76bd22438800a7f9a5635f061f0ecdf1dd631f72d7f3f0f37dc69c85c6b2549519d0679e1a865ffed2b07bab33140e8c6a8896d1cf685a4b1abcbe80733f9eb48f05ee4643c4caf43526ceb8d4926339ac0c4dab18634259fe778fea9b68d5e0eb29a0e7ec9ec19bf6edd83340baf0cbbfbd3e01b37568802222178fb6f5442581cec4b40034d44848182554f8affb4cbd55c75392a37504368a8af942ce1abffacbb271c0eca7ba1c1d0b83970db11eb24a5035c7a2284513196384dce6ef6554a24a84badf4979f3421e84efa56ddcef0007ac49fa2b0bc52e55df8bcf967368da82fda444fe3f76e4ac4d841faebc54b7e731ffa27b461f059f12cf97b4833c2c80669198b09cb060b50b598556ae999d4220cf2cc59f065ab213dd00df3f4f90d3ecc9dc036c7f13d6b9590e9d08b902f431efdacd38b3cb17fa67d1c31a289ab004b38c7b40b150a767ca4b8ca0f3613b9d7bb7f30230eb405154600728ab60cb1ce047057fbd38f54f605a892899217cfa98d02aafb45aa7dd4a73f2a9a193fc9c41a0d8ea92cc2df028bf8ce13d169c6388d4d0e12b2080bba9f834313a829865aa144ccfbef183a1746df387abffcf9edf3d156e513bc4bbbb7acc0e751ec50ac6fd02bb3062d8881cb8e0d3d8b8e76cb689b004089d955b39b89fa814ddcc61f0066744b6eedfade19f410856f2bf77e04a797aa727bdea0c692eb8462785134d6bf8a7ef0935c43467ed5e9899056cb0db5c7588fc44f95bf712a183b3fa73ca614070fddcfacd802949b82ce9f38f1e1b9fb95e676ed9e06dfa02ede761227b48ee2a6404a2d2ad5b88e7f68e4a4596a91795b35ae0b23e780848ba7e6bf99eb055f5a998064362ecb9b568ac4ebcce1e2e33d6af502ec2ed865ab8eae835214d6603e5fcb1f94bcc6092fc653aaaf552ffc3837adac946333ff9bbbdf42dcf13da5b2065520716f9af100212ab92c8af3fdbab638d1dba25e7b00cf428493926c13e2adf0008cfa5bdc89af92510c13e5ed6cdf71e77bf54fa67c367b6aac31e47138b2300f3e17a34d03b0d0d68b3862e13a36a44539c0f76d48add1e5837bae47707a2f866a70afc1442c4774ffc0d39acc2f3262c097a3c6424ee0003ab25a4dfdad9b32c4334750211ed25ca31ad0cced76508838d1784e09ff1f02d4ed60077bb713a16c27c1979370b938e3d0c81ac8926daa89b6f91ddc3e958cccb8f3509343f1ca3dac353238dc04ff18a4ee52a8f48fc31e9282042e8c160a68f066b5ec813b69dd1b808ffa04f2950230036135b02d2feedd608b712e1a62ae4b5505e44b2fe95e81d7acd8871cd4521ad4349836f5481b835302208148878dfa786f283399e3f5786cf7a1a8e300ede9889b4007437d3ff7b538c5ad98f5d4c0889e3bec461868fec34e3d7651b684e4c2ff6c157e4ddf192ac9dfaed7cde312a5161824d72832214eb91bad005767fcd145e4c55076eef5f2807f5349aea228de8500df9a0e7f9408e02e79c0baf02f000547637ce08088804d3e726140601dad2c93b2d06d59c5a1a5dfaf9c68712cff9bbef235f7da6b2a5a053cc24a4482ef5385f0365f2a27d8810ed3e0e5a67bd501bfc51d0b8d1957ad529970d5e66892bdfeb00fc0783f603428e4ee72bbceff6c01327f45fd751449ffa81e7ff94a9dfe15dde3d19e98dbb63b03e1a7e0ced4c7dd902fccbf148d6fb9ea4eb29ea17ea370e4c6de8c4c662ac090c8e7b6a5b76cc4d687b870d637abda6a0ea75e09e6d6f55815d54bfffdb4e861880778db4dbd06bf3ef3559ecf8cc1cd992f15b3db20dfcd916e7e3d07e6c60518514055d44892e612dcaa1be70f71c02a5b222dc17ed2c55768e575cbe5692991f48a0c0a04da7084510aaf629d7541af6020bcc28d6eff539b8bd6411ca2699cdfb6eb0922f6242c052294792c15177fbd070a814ddee0ecd014d8fcf3129a2214aaea84f9c15490358e4f30f8be215b68abcb3807a0d70af25f23160aaf0a1317056a154219a080df802aa8f65487c46d3f9486df16c235a8d8adb5f95dc7ee144d24f0cf5a11866fa7713702ad694f3d645ed454cda430dad902aee70c7f808672f68df3eb14c0bdaa65b411ff3dd481bff95e17986db17ce51c48ca673393f33e0f16e553f7c2427815c78c16587bce2e80985be84c8be9a2bc4b9ed35c966e7a4fba21aa697f699403286f7fc03c2d883bd5d99f12b65d46931cd1f440c3d974b0bfdba2a8c02fc98590c6d0631d45f286f13ccda7f823cb33a66a0d2fbbb4194d4faeaaa54d2f4f5f07da8933f44995f3cf723d3d9ea69cdfc4a78b80d9bce35f89cbb779b3349490632b301bce08feacdfa3ee887d1fbf655aada4d20e54adf5dd2bcf22358a64adb99a98f6fcf265e2419530d3c9b0d4077f0537e59093a8dafdf41e63fe85be1483236c863c55c1dfe6ebfb5c1d3baed90b119179dfd1c536e2758142cff42ab7569e80a1185a0c8d427122225085578f4285d3eff4c6fff3c269ff5d7f6461539787ed4adfe73d308208651a26b9972508968356007b7b8f4554387d8aeadd37f130f43b07c5bbfd32fe5ceded5f6547951915c9bb5b617ce62794636eab823d0835490a8736256deff4ba999fbbfaa33c0778beaf65ffcd05b966ec11d9f0110b6c5f9dd318c660f16be27f1210b2ff4cc896d1cf74808e9ece485e0345f0718bf02da9d9e413407e772e8f4cc6848ea29bf477a9159289e6bd5f2ea6562cbe73fa7f0a703c7529e9e2a26f0ff6b6d915d92dc9e5ad6d507af0bcaae30bdea42e3ed064c45548258149295166528503aaf3683c08635529c4eca7ec07c1937f33cf36dcbbabe84bebf79c9442d206ad02270d07891c48528d4c513dea9715a21eb9e379b2c78006baebd1c255fc88f1e9859dec72cb3863f64f084f13f1c9f062d1e97fa59b519ec416be663b873b82e82e2ab1b9bcb5353d20850851a5bed9127d197c37cec07b98ab261f3328d36d8f40f0bf4e484ee66336128b1bad79e883c3c29939625b284a875a8b79e41d3d98fecce35a007e3de0da63857473aadcb395e54a209a35e40d7312867660752426ed66d20d17a3c2cf7b8a2a31fc78798e06f32fdd6e4c8b837980399357630d73061fde034111302ec9f47ae6fdf96501dc84bdc5bf8b64973ec5d23fc122c8994564b3eb32c9644c9cf3ed841465652d6d7f2323a47b70fc20a4d900cf54a4fe050d8df27eae66d845f35e12c4b6663bab1e8956c7e2e050d145d5ff60c12f56ba091014f42dba7c3c0f0e47587467800d573ed431d146d8c5b34653158a78a1de1d6e29b440a2534c78e049976236f09d6fa9f5e33e09511979a307641526cbef44abebf66a493f5652bf6668eb09928bc9a082fbe7d349a561a38efba8a020128e224cf4385d43ecf4b2aac2188941cf21277e3d19b3f67bfccbdd4ba24caed473aac64dc3db308180fd2e46707e20b400ce06ea43e8a8b44f44a95d619ff21f0e35e058a849a1fb9709d92581e15774c1a11d88818a61073128f7bc02332a6970b549fd672d50ab271af258179d5e96cf981ba409e4bf6e49b2ccd7a5fa7bf542dd7e4027a98e0a57e9bafe1f055f1f559cc2abe014d9d1538a3bfadb0ab926600f761a7a132d97173b4cce1362879c24f857d565757eb8945a57fc77f08aaa28c7906709f3f321e6bde1d7f0e4c264cd23b390c12ee701f49eebee0d2136c86b04fae63bcbfa85a28191d99527b4d9cf5346479b6f433b1d415d3b477b86b687de63d541b595b564f1a721832c540f242cab789547e9150eebb46ba835a52cbeeca5329bea5373889fd2f76f33d6247e7c2439608ad5dcc258110c9de7b3874213b43ec973437c6ea677e566c4ad8a5ba352cd084b7ab8bc551d23b1235a15a2b8a93c34206550af649a9ef6f0919523f8581382dfa4314ed9bc42c298c0857c36aec6369d861a4a5102594b9492c9527fc10717f20f16bbc0eacd4730e554e168e4ad44e9d6c2c99524055824b7c06d21b46ae165c05c0ef54026861f36232135d4ad3d79eeb97249acf6aee4d35a286d540b078e2dd0748ed022b43d6e22b8ed2af14b82e8112ec313ac0a1d801c67e706873e55bb66c4a1c61476f2639779d7367208291f3de73488f49421fe21ff9956ada50d6c982b6a5c63375bf420ee24568bd417d78a7a3ccdf6830cb42b8cf0157452a717075d6f07c29dc6d97c794b15d5d716e86ddac5c97de1b2e8695943299288416ae823ea4972ef178b43c879538f6016249c06566b0204f00ce6723f536b7940dc719ae51dabe1a411b4bc6cb93381f4462ee8861f4ed9f9f15cd650673180fd53032e4b34921e69e12e4bc6c69a0ba2fcf8a0726c9a71d2e0a61df2f46975cf5c107bb5c7a864e7ce896ab7b025dc57eafc1c7ad0da4835cac80217ff6e1eeaa9aef6479858d0d8b9c197c519fe1c894ff799123e1c0cc6205992bb540b8a2cad5c9532eafc9cbec441ac062e0ad2a3a43069bb5db1d365fc295bbf621680b54004bed6e2b2261c5967aa2c4b7fdbdad222a90856add93e41c4148797244783bd093af783bbee89804c00bf71034ba651f63db0977a1092c086287667345c45c03a52869c68720c27994ae6feffdee7fe2011c27fcbf6b3a8284005c50140d647d6549b30a6335535386706532cbafc108c7eb50038016249abd02e32319452c45c0e192b2bece81bb5863c4823a6feb316a31c661e6edb745224fe32bee7e74842e8baaf700c221982d7834f67c3c630a53e985614d3e1f0a401e4649f4adbff8d872f98b1ab2bade247c21eb7377ab02bb438dce2def6a49f1a091143d2c9ed4a24a489d6dd5170795e4d7c2af09bbbc932c4ec1afc1b2c0a2241b945ea73be340a34ca55f4e384e40c5bacd335216b298d6ed6c6b7835ffd52472ae96a62dd0f9db373055d994314cf1af057fa93409caa8e18b21132afeda70c7b86929d3efda753bdf851ec8ca2629d38b5f12524fe33709eafc98f6b7d3936585ca6194132218d12183b0121ecf025f4bca9e412e1cf5a730276c76223c014b45b13a6fbf37a426228b21af0e3243f7e945f774da9b267bef325d2494a90af94697350e11eb85570f4a64814f6acf6c728ed12a8c401dd5e5885a1c729782fe0ebd770f1f6961b584b98792a0788e7a168435c100423ede2ee48bafcab0bd20961f02cd080b664816dbfa01ff186fdbd363ae996a3a44298926964423ac6346ec4cb15bb270c249fefa633a8a8c8c0f2289d3c4bb7593a194a0db239b2a9fcb1a73f0b6b0b9498f673db44e5ba53ea35f8e6abcdc1156b5b972a2d34829557758e02b081b3667774e0a3d422f4933ed21a55cbf96c8e7a10ade31d64aee35dfc135f5a72fec7abd49eec2f230178b4ad45cf8192bf88f5a8e0391779721a8ed2f3f7743d077a389db03d371b402f22bc79521f03e7fc7048869aa5003ee2b7d9f6b6b1c9f3888bdc1504db50c83b28d1a8b075cadd4bb7f4e565e418a5b52af19d182239bdaaadd30fb768aa5c4140066d6683c9b3262988e12bb1f684d63cded57242562ad9fdc4f55407e3c7ceed3c95006f24a896d713ba384a6d033c922a320176bcfe0bb37ece995d7f23b5dfff0f17f66521e03b86c874d38e63b3029dc43855e458c4872ab26f06dac00018dfe5c1190f2faf73bf73f519a26e44384de30c6549ef7bf8472787c73270232b2884f07437054587674e78a0df4cbfae960b4ae38dff815458a1943d8fe1a8ad4dce4100131f023d3f6342249108d8932c5d18540f447853b5a584a1cf32c996ec0fd3606cb62f4f93dc24805cc54ed7bf4ffb64cea418032eb3ece76bd41b0d7cc4b33103ba423893de3aecac2418b3ef4e9b472076f41e1344b0c744a5634d7249a7c714945d822157c90d845aa9fc01ecdd052896946ebb1eaeb91c286a624c4f01ca076984cbe11cbdaf45b2271f3d6346f1cdc67354bd85a30dd94ddb21f985d175f5b86f1a422ca7a5fb9fa11b4729b5e35e9e6ecff34d63e94daa3bc73baa9f98b3a23113249958dc3c11bf7a0c9f785aefedc3a07d4ac4c3537f656daa73d78fe78f5496d7cbba19e8f69f4074b6c31074ce76092eba348fc7f4762852ac9be8b451c75aa165e58e47a264976bd2614bd86f7153c2036e645815097014b6cbe0cbe01979253cb43ceb1900680df4dd0854c61fc32b32b1caf0eee9590b8f795013e08d250a52bc1b7394a5772a16fb5ef0e39698de405102747fda643e02fe8da92307c9482228e7aceca8b9cea9f4977fe639397be902dcbf1dfd1288daf7a580d648b495005273268a7c07b1f9c5fe983ca44bb6919e7d9e7a025c0e60e1c479f42505207c1fa7bb017fe6f6b40e781a2f5dec4c9ce849f4c77b677b867968a97f3241c59b525eba0e7917929421523257b8bd664338c309624e6659b01d8e04a195956f897b1a8275ee9df034f7a012924382d163ec7a4783cea54fc91b55a44ec928736a4f4b6d6deb6f21cfdd4a384f12be502bb6e704ec8a437640027c01aba4d5ed4025acf95c7d017feb1a01fcacd9895bdac7a826cbfc00c4be345dbd385da2bddb50b5860f93dbfa3342273fe39ca2fd867167ae14647184744e73819039e3ab817e246eaf8026831d45580847b4c03514f6ac9657e081cd133280c1619746a111e949a800641cfc8e8076bdbf2f2344794cb34c28580d55ed818407e59cce4390a441b8c7343d93914cd02f1edff083ebec37c0919ee04fb5a599aeefdfa0f862d3b279803256b9f71064e3db21fb1a451371a7f0e0fceecd0f4519d53260684c109306753a021961fe4050df5b9d082eb82e36dd3afac788abd263661ec3825ce318e81eb093be1da30825a46dd6fd073a9ff377728038836a1038e5515cd28bd6ec7e3d6c1928d562276eb240b3fca5c569510bd1391c454dd73b05e3132e11f4506917560501c99154520e73c36beb1694ef6d846b1c2e6f3fb5d05888b25005ee251a2724bb7ae22371c92dffd96859aa378e5a8bc3a543efb2817c39601563f7d6ceabbeb0ce2c1acb0e693b4f4122817fb457c2d96be2932a18a28adff833fb1d4cedde50ae631cd5665dfa10b44affb07b03f62c11abea96b4a3590141cac116dcc0f63684fa836b6e875bb201f15c563daec4d5e0581b7a399841a0a0b46977dff2a233269cf1fad506851291dcc541a6a8aeb4c170ba8396c43dbbd2784e7badc14df84c434188f15fc6fc5920edafbd258a33f965ff55a6858bd02d9315fe408f74729dac9b7ca4d42b7d66ded150aba3e095c98da42bfa339b2cf82074a89bbd56abfd52aa7ab06181d0189a9260e7f9085f58e16aec5d240a78fa78a214683396be73dc238ae78755087bc445e9c5833bab6ee72c4fdd4616ddfd6631270f88d6f8deca7d959cc915258f5707e328b159163ac99b633ff88a6548a0e5a5c7fa55518a96bb04f4e4d8138873982640d622c14661f2b9633b652e780b22365e7da4426c6a64885f69183ecffa96849570dd6e0cc3899b37654130fceec1fd8d949d166b8c01ee6177d8be28c7d4849d1544346971aa65b8c0f36e157f6f0329192f6add3ef4e46df9f1abc884104994123cc8446008ea18facb7ff34e8e68125f055973655c28c0c04085498687c28370f81913821bf96fe4f96af60d6b86a1378296dbe7cea47603ae11135d6d8bb7de27ab750885dfbed3192b6163d523799657c3e6d4a2d08ba350e3e7c1c5bc99bd8263cc44a410bad1ec2acc891e18f8e8b304dff791ad2d587520edc03f550f4a832af9192f0220dd4f5647f9efee3f7ba9ddd85c86bf2657d075fd3996e245ad0480e8ad656585edc8c815caf0b6e2df9bb1515ee54468eb092d86b08e933912272d12acb87cf3eb2687f87ba87839ef4616330af32cf876a12b5efbd599e5b65662cf73476599fdc12bfaee6bd85ac23d8884013b1d294852b793ed5b0863e2a39d04c91df5f9f10dff58e99e70dd71631d8bbe476b15a038995bd773249bfce4dc36ccca6ed206231a6903d7a61a97eaf83fbe3c3ee02124a07ce813fc8e742a33ded6e5db6e0f0453386a38a42fa8e389490ffd2d0cbe93a23640770bb9af6bced28fe25f94ff1031b55daeda5c174ef27c95a2a892c924ff76b5ca2832fff3a12c9ab52d61271d06acba1b12559f87364a6ee2f48e2af05133c712cd58006b1dc01bd33f783219d7a1624367b4ca75fbf0a910e8b336b6d6aff5ba8cef2a7644831a66b22a4c98b64bb07a413ca9017d766bd3f821f5ebae34fae21a47bc68eb26dd2ccf1611bf7b48ac101509e56a4f5c1e6d19f8f5a2cc21f1614c28bd453a3d7a229097e128f02745b3b7b8027a7eb78ce6ab496fff9c814c9efd016b6c382f37b8fad2731e382a6ee6a0a2cd0c18f7aacc408fb673fe8d9f571e7d685d9d78120e8cfb5c8af026b57a05fbf505b3887a6492e710d2499e20676ddaf728df612d57ccbe0d515c658a10786e228af859fa0f3526b764624259103e66721d2fe9d50787506d1d8d058b4324b53a693f3ed21df3c1f306c43a48e7e9f1cd7ade0f9d598e8cd3eec6bad1e8cc70fa3a782879c31f62085963b6d9f95c855365e2b6aacd94e029dccf036a3704f9aac6cf6017124165a5d43d55ee7be7b678790d97527dd237dab4673138bf4233a9e380eedbfabe7f7f227a36abad04a49cd3885c80589394385b16f8ae87350f8c6cbbb2442cabd751f9ab947ac226ac0b0bdeca3e1275a916bf916d89c01babb123a212488efe1b2f856df86014e9820e6a21c4f7bc255ea98ef967c2edcb4e9b460ab1c76b9c31b68733e590f561e64698855d82380cb3994da706bafd769e0f1ea09c09ae4bc2fe5d66716eec22dba11bede8789c912a89ef429a5b3ef5c07ab6f7a3a824669b0b2c41a54fcc2736e73da15e6707d8998abb12436714dbea51ea0954f46c2035978bc8e3670c5922a4f847e0579da6a9a81f80fe95f7310936857644f659e758fbea3aca376cf372310dbddf9469d7c7f6629b6dbb21c4f3769f861273a61f7b4a6f33f35f9445ce3d9b6b5ded90014296777b1b7bd144342b0c13bcd6d289de9a9423d219d85698119cd5ed0b949dc37d4441db3e859de711c40f7411ab57a30862e64c0b0d2e74f3bab4eab31e082c9c46f1674b34b0e8aba15bf3dfdba81118b18a00e310b9f93c0443fc21f57fdfc5dd0043797a7896e7935295e3a471cf7919c8a3744ca7fa6b6f93314476d3690b6d5507450df16b7da453ff259eaba293e40b387bda7d8247b13a922b980ee762228d472b6c033feb2e4a0f1e0216fb555bfb8badf43ebaa280185a8a6811028c2e5bc626791da0fa36195d03caed1ea54a3e94adaaf2f816c60118fecaa541cc8333a212e49e410ef3c204ec9b00faac2e0b79efd3994badc6ea8593b5af255cd0f35c331dfa54326c366d9de4c1d284e540bf0954b2f60f9c35d54ad29c9d2e30020c736025c5314a8e7e7064a3bb681661bca2fd43cd7ea5afd7ae2225ac5b08d34306ec7da2788e6151850cac8faf12eb4cb62c09d5dca4b5341f68de4643f5b6d957ca56c3e3ce61ec3b1b30cb7f874cf2f993b184a6d4bfe6b43c988b64a42a757efbca50e53670ec10a9d9f31711cd1f6e32bf9354d76b63d342082b6d889590c5b78f7971e41e8f66de2784cecbc2e4d8da53fa77ba7c26f9d53df2570e60847d32f8f5df7edda9341db69e6a7648cf419374bb25a1580a0e0652a21de808e35655c3b8add2f6966132500e48f4fb97533a194d9920dec6af63acaefcf93d60fd88ac19c63832b368a5c84b2433ff9ccbefbfd99abf53c20c2d74b27750bba0fb21c4cf6a1cc92673fcfc06c669ef594c44a9718908f18a82d7fca367b83f7186bcfc57292a270cd83a7927686f3137c54807dfcb9e2b7e96abee125fbeca2e791483164a0b07a76d55e1ce5033c0dad46ed7895eac24f78b105748f6652859d49a5d32fb15e57f4bcfc6bf2e03a6c689c1e512cdf86111bde2ebd52fc3ce646591d4b444a9a236bb474731afef1316977ea9f1f54684538586bdfdd81815ea63c3339ed8b1cace1742db608c71de356a6959f26adccd1678e2bd7cdef4bc85ab3cbe8310f048003ae141293767078e84d17d67903025490b23c6d5c7afcf1bedca57a69abeed5aec231ab7f48ee748ae0d7dea3ffdcd577a0938cd046314ce2109cc29ad180e7a16635b00ddfc0677783e35d84706900b58a899a7403d9cb8b8c9e8c3af77571cc4a915b925ab280f2d69705062e0643367546242ee1ffe8a8a9e217a044c280690312db870fe75f2305ac7d93480dc14e4f5bd2d1335e1e94469db7a805e4cc0b4b27996645889d3a04e133c7e54376f4de79dcac097ae42c3a2ae761c56732f0e200f98d24570e77a83b223258ee642578fc648a1007516f61d6117f55558a435075e4456606bcf1f994ddc45c3f3f66e28374ddf7867bf674e1bb477be4b7f6e9601485c924cc07bd0750d766408617027ec8b69f67d686640f7e97667d3893934387f84c41e933d832598c68e9e3ff8146b435dfed85e869501900db4d55924534f9878dad12aab2f61e1dc39238762c9f21328139f8eb14aef720ba2b4e0d004967417ebb83e619099ba01fc0a4d89bfac41ae674ff5c695c033591e8e04fffd7e0b59a1d55c9cf54f09887479400b0f9b2ea60de04ad222256d76221ce247df2df75cdea9e51d2790223c920e1d02d6a695c0a72cd9bec258841b8bce4d5f42a0d8c3cff639ff4e3fa2c51ecde092739d021b133f3cad2ab1ec78d238d096bfeb3bfbe63b998ad7ba92d044149d9c3a9847721784ae8d6f80fc205b77dbff222e5faefe7bb9ead2ac284ee76ce16716eb92b3be0c9e6aa99fb3afb42027182ab8270a3fb0659dd04da447855006a6d6c29e4342dbebad42d6844bd00dd74005a0f54de0dca2c1daf935a05ed30d362084b7577faeb9f1b83b557fef7abe9135c6ea6e30fd791cd35d3053044ceeb88746e32c0127774a1a9d4110b31fe6e965dd835b74fc7dfbb656c03eeb5b86cea5cd720c020ca5029947442718727ab1c67c4c9a4bd680b6304fcc9342a593863c1a0fdcc7e5ea7afcfb0c1177018847c62980e8636361f3875cbbaaf076c7ff6830091fac18b807cf8d57e12bf8fb070095072b4acd4c90e1ba6f30666198d9f03a006a21b4fb713ecf6268d78c47c70c8ce288f786a192b21f28ff099e8a3597db83f42f66cfb0827b961572c5019bfea7950c8623563b3ebd9f768c8f8b25b0c9f38c73c2aedbf0b3abb943b81911fb590ddf7d8d5f22a5d67babfec0a3a7e53e3e76c75a3fc5593067f783790fd58cae98f3cf019c56b820849d04af4c2f17a6a7b737b16f727ad8aa1f006dae647aa8958c47c6f523e91d3ec5d52be438c1ef6d548635401e5b4ab0665d23e8d510c5a759e5983f66d849853d5f84fbc6d9527882c464d9c849105c59fb553e0d1bdfa6bd24821c13d4b9a5c2e811857c1df18600ec4d33c1c84a3c793cf181ef2745430fbe697497a9bd968e20b3e06c957674bd072dbe456208b8fd22bbdccc3096cb5e452d36e8db7c3f897d908901a4299eeffdcdd39542c69fe48d5d6fa22196ba1e7613085951053571a26015879f6eab74e9a1433872c23ccd4a4404253b078c5ba7a4ad5fe2ce21640c8cc0b506e84b6097365f881f513758d78a381f77d922f7ae150d1cd7595337436666306df758deb0723d6327313c95cab83d4193a22f2f8d3b4f19943ae7123abb9163b242db12919973753abab5d0d8118396c984912d1b9944ce56c90fd34e600b6c892ab887cc7a31908700bf7939da7e5a730eb70dadf5ba13d785e34a38f73f528f4a924ca88d9c089bdd1f653bf53d86fee59b8f6082c243c3dc54f350a0f1aac7c1fd453b70e104e5283df2091d873dce678959b176ee706027d002bf96b02258f7d7d1b7faa99f4fac263b890935373b80e501bafd50a950e4e129c281ae34ba15316b898f0153a23861bc4a404fe6a600c9cf498c0e1d2ecf66e0578d70c252db1b44076fa64f2875d7754546534291c3477e86dce4a6c1962bf3aa0437f9502d9ac51b70d3194c747ec39216d04aeab45dae11243720304a8e732461080f2d01bd350b109e82b86cd3549bbaea11710d261a241a29f0af180b652655218a8abd47f526ce7a6b1610caacaaa96e96ecef09518ef3b2da657ccb489bae8ad6500c1e6c6d76912dfcf9dd962285f808535bbc645135a481bead4f299ad56ba32f3df0babe284a06c5c31798342ffe61e2a1df8b4af717ba67d5c72ed3c5d144fdb9aac5712ff8a9e37ad6ccf6a4b4a719cea73199cec141ee7dcdb855e30e4954fc3e185d43b614024e597db6519601a1b4b670eb7ccc51ddd134f5cd713aee8888a1090bdfa1b6947786a7837266640410bf7873d05b6562260f2c1358aaca3d78789c924df78259f09210b92feef07b4147a653db0c8c801057e93c5140248375bb304042d5a6d77924ff2ec290c513ece9e816c1a84150360d6ad1cb50cdbdcfd0c235e3d133d55528f2933ba2108dc3b6e9c2ba0947177cf3bdb4753054ddab6dc548ce18b17202be90d4cc3a7fa280f335a731f3f3c95200cd32668d3aa9dff9baf74a6fbb7b7cb7b237e12fdbf3da3234c2fff933482835b1caed769b05a54930fa27cbba386ca67e4dfe6d8958daa22ef6947901d2f628bd76b6df65367d5e750e5b0b01628354b77e85f781e99abb18390f5c7a8d2426b47dc23b9b8ae3b93d1dba78d45a5ea7f1c811f33edfea038b316f3bceffaf5e075d8a3758ae8c269e723b9ea09bbd9fad8e61499ce82dc962704227e6b4f9da971cad12dc9392e947ceb15635b5445dea24f970c59571f504eb2721145da92bea691daa26fe42c6ee2f46fd1ad7e3c7bbd85d1e0e3da70b01f0f05ebac343504b1ac4e819ef3c0da66ea828ee08cd654e06bc4203bec9fe2af2bd8ecc0e565f3634f7d6c9e7de8895b0c3485f3faeab16d3174e7374e41daccb48d05837b33784dadd6db423357c6d99491d84c40d74e30504871e8c014411ea20569ddb9920689b54b032e094586ccddc062a54d58f1351eb469cdb1c6d57fed70160cbac5885629c0195b60bfe2908e8f4e7ded3066521789765e94b8c9d2bd681f35920cd18a6c723db8ac8a61259c4a7d88352d94c50ce277d34d3a88308eb933e608a2cb7ce65adfa59ae5a88f1574bd1d888cdcfe9a3152c8e7bac960f088d83d065125fca15da2050562608c480de354b30de0cf0c4ba82f9cc93cf7b62d1884eb606baa67e77050987b58a6071fe0cd66a9ddb9aaa34cf9e25b82d341d6844b1410a19d3de6ccdfaccd6c726316f07971a5f3ca1fc9d64d72808bb6fd366ea998ce905778ec6e9296f3190f1a802f7cec7ac0df7f9a1845c08d72170d3cced25a5c807fe501f2c08e381c75859439bb0412c99b4208da082585ee2924986adec203bc88daf57275b12d0db612c13d34a992310692fe50701c9b24b441e7ec3c524884f394833d37cadc03420800580d0b698863af094d0897534390c9770fb0b5578927b735274fca7565fdb6940ef44fade3cb60bbd9e7a24397ddd8c495da519740c9e74b14d93a82568d06d936dabae31205054d9bf21d46da67498043d8d33925f66b94bbda7d656abf99cfa3323e000dddfc98f7bfeb4ebd0ed5edbc6d342b6fd7926c624957acc6d929462873fa6c11a68f3f85eafdb21aceafcf4e0d08bc3c2ae050a3f59ba8b50d84578f6f3577752d865c446b045b70ac641f45278123e5770aa6f50bd862b697162ecfdcd10af15ee3b289e86961ffb789d10b8d4417fccf35669e5e8407c0cd0551b4e2846c40eb63ffc02e8e9268f8043127b762a4f4f7acc91f50d760c09aa3b61300b67d7285fd2ef7b42dd8866170c0d4ae9917919c17168721cac16ee33726e77328e280722cceca47686ae890c4f888804088e7849088887a1c54f3070fdca76f53f057a60453f674328c9da15a22f450853c4b43183eb4847791f5a69357881b6740d511a41845a03dbe24c51f8f05292f873b627cb79edf618aca5fe727a66165e40b1e8e1b1f1b721f12b97a71807cd8f5ea1e0254f66f104fe85de0f837d70401ea741299b40489d8e9e5b643ffb47625f125fc3c5d3edbf3a6f1de66df578081ed3e6516f536f4ea971843cbe4914dff75d0b1ced6ff40bf98abb06fd744c40b2d865824a68c4f465f62dbe4b295574563c0705d744cd5db96da1d592d423a0a0d8158d10592a2e81285ce6a6a31d496d14100ef42b71e016b2aa11914e3056371337cef65a7fc6c20708a727db1c73261a1dd5c8141d22b9b07bd041f2caab6afc67aab4d43c6151adf1a67d375ec0c3ae901f5e57dbd322e360011a367d1514ba49039d31fe1786dded7774428a29dd6467550635aa27aacb7b676e7497c4f48d53134560dec759864661c41d5750998f88ca6713495488593265bc4a7a877ccfe7396faceb92b88a6d44c94e269909535239270bfb2193a889056ee244b3695da91de7682c84500162c321cdba7191f65ba71b7e31609c4c7c52bc085e7417fc6285edf1abdf4d0c695462b56351ad93e3a693bd55bbb5577a7df0756a7be2980dfd94921f1dbfb0faef49f0e37b0774cd31f0db587b54d82c8c6073f1282469a7b4ce4404d6868601aa646b966ceeb7e9fceb02861463c25888afe1eacef3c9aae002cf7926666e024d840b7a3d951582ca8ab3ca9fe28a05669f95e788389887810fc0bf37c05c752b54f046040a6cac51d2698113861fd6ebecb62c037abd30a854afe83e6a022ac0d2f790c13414ea1db49dcc9c227d31c91776029c2a768abea5f872fe9e8955c5c0e488b5430042c7e2e85563b4ae1d2462d1154cffe73c829cbb4fad8fbac9b0bf02ac64ab260137f66d11a14621bdca506f763d0db8a4d429768e98a8d633a5bdd1bf0e9403db427a35180cbcafd2db104287139f425debadd347489a732739f5c323191b6d924799a49f7d16a24513b5df92e2cda9ce9beede2d3e8c3330659ec2a1f1271d473c3108b1ce225f78399b4f8aa9bd13729838b56bbc9bc7ccb791253f19ebe4b816f126992dcdb7c4a474d842b7fa91f64a8553172cc5c40f8a6576224b736c4f812db37ee12e702c67ea904e34fed563858a8730101e6f5dd24765c37d55eaad130cbab6bca551a21b1ff330bc818f4a1f0ffa07c4eefc7b5159140075e8f30b8074478e2c0eda97b8fe2399326fa9db92cd0221e9c2a9a1413912715108c41996e1245da564e773fc6c64c22850d2ca864f9bc7b6a47a9a1d28140c651e8a20c0ffb087aa80ef3b1b90c2041f8c627b70e8ac71a2dbcdbedb7e727a0ef3905f623fb550341289aa250ea3e21ad45ff060c50eb73bc5f47c6546d176aed96941e79a5f9cba817cbdb21a1bd2e1502cd448a624bf6afa95b2978b8218d11217329ab0377bf6ffbd6d2d66edb47418a9e0a9d5a74611c161d03bc5a0377e6d61dafed3c595abd02ee65ac833dd6b34769024e4a3a60582b11387599e49433581c0e90a3b7861a5af5096c3c3457f9ffe5ce31ee0d6315ca1f416e12dad84dcb96887c2695b761840ce1209e46655b8dbc4788a983be0c48c9cc5965e9e934a3fc1f7c90ba09a93904f10f718fc86772d98bfc94942d588674d807c7aa03113095fa1652f8bf5f93206f2347529b9e64b2c4ae5baad760b5e29cf6bfdc4c95cf83e59","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
