<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf195cd2a25e8c321f5132d50b4a69826cfbf5489cdcc41db7cd83e94df30cca5fa18781c275e9ba3bcc5c3359e42ed8c7e540efbb8eda6fffde9141d81dfb75669760f1464c4936b39b0fc4487201698e48d220eefe1f202354cddac42efb54eba3f8d552bb6b0c598dc8b542231dff124d805a1ef62a1cbbc259ef2faeb00fc67927d4a23925e3ba35a560ca062da960774edb26b329d8c8dbe96030bfda7dc971056d831ec4c8e99c5a8fdd9628d2a570f236d3a51c0446b5d16bd0eb5668fe1802e0c33eeea2af5725ba4ce357e35c94cc2bcf232cb2788b97f6840ab99842763358c0bb0a94504e379f00be1050a0543080f5873d18b25f80d363c3dddc0036dcdb6aaa6bf1244c81ca66ff6ab53361a945466370a07ecfa938f9f97c3cb37876ab30fb9a242c9753a8bfefd4bb314746efc698d57a366be88120bb6773e8070c5940da0fb0600d242f0620b1cb1bcde99bcfb05003fb1928fa036594c0502dfb9f6ce75ea49763b0de7b5f6d93f8faf0221d08b8b07fa5e24aa68851a015954438c5db2ef232e4b4351424c8497f76c01cb03b4536ca440958bbe38b7d32a883755e536b5dde57470fe3f23e9d92a9f74ecf34d524fc86dfbcbf7fd20e8d2d1f3f7c213395226ae32ef5b31c3cc31276fa672e16f2ba3ae9ae8118f471758047e700f5f20b8e288473a9216e2cae02c85c4250d7d9471e7f1be65380a59a05ad4f3d7dc13bc639b52f208a21ab6674095e4d5e0ba17abf9ea7832d6c40354f588a2ac20cf10d14f37d28e54976d9a76a73755f6a07412f25c1bd1e1695052dbb11bf62d7d578811a5aba89992d342d6834a8eed1b4fb36de9a9fbb70ce8e1b140fc7b4d40ac8e2b790b8b4a800d4f6ccd441a656d03870066cce5b5598c7270926986a6f2d0143a91a94dbfcc659232e08e651a6f6802172c37b72a1b47178c500f3500556508a071e3d0a41b1e796300a4754451b12cce9001080fbb9474c13203a651eb84a1d8af5d7fb1dacad666295e9f89c5eb23c3fbb9571e7c698d08c25f371780633828f2fa1e3214121e26f11e474bd20bebe86f401ebf3f3573f2c99b93d852ae1289fa69b2303d509c0feea4b9a30d1ca439cffc8a0a1f0fcfea46e30ed7b0c61609419c8bfa1e3433a39f300fa137a906ad6cf3d902cbf5c0de1ffa21f199c1726c8369cb58786602ab9d96585e51342ad4cfc5f5805d3ea01951cb1fa5274d93d8d0f5e246344266f0a8640b43c519b1c2e2cf4805da2098af261f86def21dab5fbe0291831d7d5807f21a01104f00c23ed7a3384b36ac3f4969e9695c9f4dd9465d8d85028dfc7096d850bc3355e2768a4cf6086b2c6b2e1a293e37ae086aaeaaa503ef1ac115346dbdc7653b2ac5001086ff8341640844852bf500724e56674e80a3b576781df99c70029c37f13823138e900871887f7e142e1a942bdcaded25de40ff05f0fb108f0236d26fff93bde7f5bf4f4b2f0eb73c31b7bdcd35cb4a3cbd7ae88055da1284d3743d49d864d36b03bc5612ec28aa01515379a364a5cc74f2d5a154ce4a99147cc2315dc27ab14162b7df9f0314aa4177a74a0169f6c2a854852c82a1bfd5bd63e44bfe36a97489d897bedafab8ad83d6bb70d6ed69eaa08b97c9c947fc6474cd786ef907560341a6a4509c1288532bc52dbdd077855e4a7ae52e517c3b4e2f17a60313d33f5df97cb63c3862d5cbd22a7ab34cd629726103fcab6778f8e8bb55aa4c6afe618b90e2b5043487625fb6ae129c1ad70581e2e529c137d79a3154cc100fdf729d416db5a7c2d4a16df28991d4b6dba94bed73e444df6ed226629fcefab5393f9aafaad4169b72733c363f6f17482949c8470ae907b3a8dd0bfb30ca722ffa899acefe238a9bab04bb6a20c51d95969c1df56edef61817f642b4fc2d4dd83f28924b68dd234c7f9ab7cc824f8a9a6e380db04ae42eacd49c342f2fa607bfdfb6d2146bad25eb3d5c4e7878401a8bd6779db7bd3f0ad7f277a54246158a3d362d3a82ff1e48569cce3ed69e3f4308475d0b13e1cb2510064a9ec2eb0f24d7698beca27a74f8a1f1c66b7dd0ea8fdad751ffb27c2702eb4aa401dc76577135fe6d8cb5a9f7681170e27a4a3a1b664ce05d8f73a0ba77786b92920928f9fe907dfcc0c44d6a1101c4a6eb0b840f28ee328df3fbc5ed63e46b3406b851f3fc7448b31d1d4b8b1b7831014a83357276ced6bd4ffbe367b4edd2a9d4e49d16e2b94242086715cdd95864fe9807fd9a116057db83cea638de2e95f53818c9f7674ddd5a8d49a1968a594270fb433830cd632d0bb9961c97550bbefac04fedaa4519ffde6a0fb0e4952e3530972400dc6add9732ede78dd6d1b54f2686e70da672d1cf9db30fbf20a543907016fff7d113086b521edadf119747fe0811e35d7a47034d74d3f70aa7a29e81e90cad2c23c0434363ebac1fe1c88ec7b3323ff0af78a6f7e297e1a555f979898fac2c44e5c44cb623063e4f6cc64c9a19c020093125a3b181294941e9620c84df263775045bcc896dcf342ffbad7faaeddf438d0ea313fd0c68558914aecd9f0925b2ce7cc27c2b6a8347de19a26b3386ef231c0a2e5b13ad73903076c9b67868d92fe55bde9281336eeaaf08daad2860b2165c3d734569637c0c3b8c9b19267b2b2e3da61b0841fa569d956e84c29281e08e88b1cc700295d1a7946c54b860eb1004be8bd1d294ec44b2b12ee8262e146d77677c0d16aaf49a18f27b7ca50fe77b262573f236fd4dd446589a95e249dcd67b8597f205c2e49ac839127a51e233395a6298c999cc03d8a0daf20c31718820bfe73e81ca0e9dc6104b321d57a931bdd022f04ed10e87b6c8fa8ec179575e2062680b5209b75b6939a6b2782608cbb98d31e374ff306ae3727b0f3b70bb74f2a37e1b9817ecf66a18189034640854708aa6d384ffed67e1a8b67d84f37d1c5f330e959cb4ef52c429c3d40e823f6136f1b61347079d98498ebd1a5028abf906d0bf11ad1e2ed99c6bf451b8fe3cf99c164a8c799c1343d13e2e080ad3f56aefaa5d794d3a4f513a6fe195c023e776deb677c0868764e438ce798b5713295345b5773ec0c97d0c0093ca0b709b83d5f1fd352fa5c0f9522b01c45c286bc3b581f394942cf9e1875de6aebb0e3f14f71f9b13a71b52832643f197ab7b47fa8728d7d320f912102b61d05f619c8bfd23623bb03bfd32a783e623a2010e24933ddc64e1a4a7e9a6310244a30f468e9c4420e6d44eff1539bb8a1bc6c39870ea31f11f7739c3fb314341b6c77885eb6044a0d6e3a5ba593f7ee0f9957c2b5a721451bb37ef09fb54f3b544194814422d06fc1a09cb4763c4617c7d77485f64807955e9cc9c1538e6c2c86137095ab61944f0a74951f50779fa7cd2b1d31c797122a2d8367e14ec5da914b2f0038089b0ee8edde56436a6a025d6316d885e403a2ebb1c6b5800580da9e3eae60fceeebbf018242de15bb4f2a5b9b5c93e379a1a172f986d69d7f80ca894e7a5bef39fa2b4d6f86e0b14350cb3a24e4a1eba1a5680f64dd713d90b483967ffecd9c15d7bcc5a059f1ca15f69332ce075dea21cd38d5e46f5fb50f1a05883f4f83c00783eb285187926f925dd8af7cbcaf68428531ec45e066ae3c1e98ea3e2865b027e66bf6984e6d516f25aed35fa9e500b0e1dd5439b78d9da499fbabe056e6ff52ff02c832fc4319e015b9c1450bfcea7bc3540586add2e6022d3b02fa9cd6ac986bee40457b1b890794f74e7313b6b28612d3830f7e82d061cab21a4d03ebca49b6146f0e5c27ea9a1e3c57c376692df2e65c684156d18ee68d44911b8abc7d2412497690c5ed90362158be7f470d709c9cff699b27609bada7bce81abf35ce1721532d30cd94dfb4a549af3a1f0a75f7d2f52e6129264ede9102cec11407b4645f2cb4fd48f1e0e7d7c4be8e1b6a84b8f424d90f941110f11c814a62b93100f5cd7dc7b3864bc04db99d6b794c379e5f67ae4c55fa90f7162b5c58e06784d81b5faf371792ce5354a5ce66e09cb69fa79d9ceb7715a5319b66d06bff8d5de0017b155fb5ad36e74b3f183df0bd9ceadb19cf15e023e1229b691c3d2d0d68e0fd6a3862b333da7e3ce8041bc9b426b87aa3342c08e367a9c2a89b94ca041b965ac108f8781984caafd2646b509ac127c1670f3edccec52667fea8b62198b6c16a3c3a269e0a1bba435aa73d749a2be3f9fca1ff685c51670b4dafd8e6613c019abf283aad415cf569b785fdc0473e2f84aa96dd583b5a3ba3a78bead8486cabc08c0c6418a796acde2023cf4c8c685afcb38620fc517cb814d8322d83a82628479ff12b02ba334a0e0abfbeebd066954b2d67a854489f4feed53e787dbcad481ac90a8f5911d145f11b015c932ad4ddf4ffc606421f19abda61f41a60a3cdbca8ee3424045dbe31e28cb4de658c065e8394bb5a74816591c7dc5a44e2ad92fbf95cff8922421756382dfa38c5eb771d048f5cc02f1a0c02a1847d63c3d4ac065e4fcc1fb8266e47a048913cc0ddf3cf5111b8ce2206714371da3b3bb26d45785780da22354aa569e2f261d10db5b313dcaee9c4d706dd376d40e6511b7d95e2924ab807537ba33075dbf74425825cdbaed7c6daadbcba79bda8d2ffefa56e8ceaeae647df64c7eb0f90055e0a5f9e110ac509a84231926c7c00597628ff359c54641c4d71fae4ca7d3abdabfd489b462ba79b7c86abc1838c1c33199f75910fc222aed9185972030f458a5643982ca0c02adb6fbf5bfe3d40cec11176012947f9ccf85d205b459e87faa9a5343c9a18f5ba3b1a7087c23754103bfa25de69ddc66cdef134c3c79cb789b4371270e318134f381ae1e80500b40c01c6493ec8ec4ff49c109a4eeba2d799994217a0193cb852fb489d3a1c6651754ecc886e7ba6887db18fff47f2c79996e469c3491f1c0da6681b1bd7d84ffd112f2fc27f351b262c880024148f6fa7521a07198dd529658ff5f2c39e755a2a5f179979f1174d78130eab0fd00cb5e546ee6b68104f64d6840a993bf084fdf94a4f4aaf0d30bb257b15b1b13ad8f71729704fbe7e86d80231fb2feef800848f979f90142c880bdf56a094e06e35cac9d38ea8393ebe72caadb6873586d24d2e1f3185543e305e2e9ab966180bc5073b843b71a409ff4ac665e1bcec902e7acf0d7cc904ca71029813a0a16d31d549c4cc7a7d5816c94d72528bd3d37c031a1d965de0277ec88f698b8b8f46bce27e94198e0a1d387730ad31c2fdf4d7b4efbaecab9ccd4eb0f62f127234f2b08ef25fbe4011b795ef73fe49e5f693467877c8471492c4b4a7c6b35bc009e3097bb0b88af80c20d6efefb5a28038921c931e18130bd4d427035eb56dc5b084e2c7fc52271111d5cce3ac399d37bb7f824924a76269d1d4f12c202c0ffeef55635e090d2206b87498053c5167d409c677466f7835c66b3f529943df1319d233c84f8b3a7e68f60c1accdaf51430a1b2a0c4f177c7975b2898152901b8705b979cdde07852768d440ce5f76190c74c1af11a25867f73d799417874785e9fcd186da369c1978f1d76ae166577fb4de3dd4f58ad49df806adddd3037a613c763feba81ddbc6b1876c530eb253958f922db2985e4852ddfe9d76caa9b46797223871069869181a086933dae3944ab12f379494c05747acedcd90fb53649d3f7f272add025417ef37f333d146cc1020168a28ebeed8ca905b8456b9b6186f79ffe5790721f4bd3e24b2fe766ddac2bcb67f6fb0241f9ce3183324ac2c8b2742468eda1f158b22ac1eddd296c0a17570f366d855851a06e48636fd3b45b5aadefd452cb2deb1e43c4b9916017566cc066bddbc4313d0cfcd6c23ec6d3b3eddbe63c06c30164ccddb0639ae5a8f9b019150a8b899271410c7220d927810500ef06161625c9e6b4d5bc7075ebf569bb736d92c72833eb28de1be678e3a4a4bd7cd71ad276c75801a1038f17c0f61903ace6cb910a105f7e8d69581345288527ff914081a0a00717d76ba5e584b3b014c27bffd26490e7701dd422332d5025e7be46bd377ece745a182cccbf5ee836a3df36d5d5899465c10d6a96d0cd27a6157def095ccaa595d543493ada74a6d95f449f3af2d627ab40ea6471789ee24999b01c50bf65de5225476f3287fe932fa7639de9bd30fc98b42aaa9f597d698cc22b5287ef8ae1f7bb95ce86b5be8f3f0f4c5c781694e43330603888a66bfeddd67f9f429cfb59e544c736d05e7c43ef98ca7d7721a5ae2d95fe0a9d9179f67fbf6e9a749abf6a93b0b035c9dcd550a70c92b754e0517ea92b033d9cc8cf00c0caa23b99095ef2223f0408bea4acf61c97b124b21eaace642ab99b101a851cf37876953ca91c389b0215ea261ae36d3e1dfad947defb268ad443fb7c3357e005625364bc8bef1c055bf6b501f80ea949bae392827fae256557ce5bef9053aed6dd741a6fda5323b4847fd6f664167b63a15824c09bae5ddb174a5df84e97cc2ed900bc9d3a6eb23327de7d4853c888e1ea66f99c5c8e3020cab6209fc5dcd10e7d6779be0a197fc68b54adf8c1ef15d372e9cb578c7ee81dcb77d2a79663b727126ed2eb14fbf22a17291ec142c20a0cd374d3efa0c6ee3b1a9a6e89d0b8eb17b5b33c510058c1c97ee074ac49e1a030c0df1ab56e12c8b0781173d340096d84dac7b3ff6d32ac1139550fd875c144992b74c93a3770d91e7c33495548245b9a1ed09240c9e0d618e41938d02785a836aab3b1692c6a8e894d7140f09495f49fd93eda9e4c1caed260b61c2565688c73f40f33cf09a22466ebfe3c61cfeb61a537deade1319af5f9c7c16f239b3f96ce6fb406bb4c9ffcaf089e5c84cdaf5f5328a7430a774aef09cbfba2614b33374fc244ee3ae408ab08c8852a5d7ea2ec9e5fe6c416f74dc36bf5d2dbd6baf37d21c97ad75f465922f2bbf8256bddfa18b7a4c7421e6ca1ecd285b48d979ffe362361ee22098bde8988bab7521f48e833ca8f221d627d455a18b306f889e0877d00a0961a3adb6c2014aa1a23d83aa9df7efb6d68090d561b64609542626abdd8582c24d68097c3fdac691cf672d4ffdaa2bdc036559aebf7da85ef2df0097bcf8a3b37db6fde3222549098ecb4df79006b9136dda911935a1a1c818046f723245057e113f71623d7e949dfdd5a8e1bd132afbfa5b2262369dc0d88e21d0489154829f943ec9c386802ef1bab653161886eb98b1596e24e4f04bb01c16a5dfe6b36e848fad263d292980fdd18f7338d19a6c292cc21b897afd43229c0f4c995985cab4847a5d6eaadb99bdcf062142c25a2546637d49ed92a7244e71134b4a58b63b295b3e7ef476acc26d25f783f43989bf74b6d754fc530175b2115e1df1b1d6f0eb512a1bd5aa74467adf02d2b171e017422679b5bcfec3ebc2fccaeb8323eee1971fa15e7380cb6db073d530ead571550458c0de8cadaff76a4e4dfb0b386a94b99d410c4d3e383e54a3f9f2e4a8188b54b3f2f44e2d14bdaf7c6b148a9fcfb0558bc4428661f0391055fb7f5d4477b9b0d40179ac3e34279c53437be7d8376ab57c1f03455341e9a326565d255672051bc152567a7c18338cc48d05f86fda39a1d1369da3e7cd7e9b1d3cabab0548b4aabb69374884dd6eda2bfe36bd0455ddc187461df2eb6fb3eddccf843da1dabe6fc30c5d9afda4a190be6df55ed7f7b18660f81f77c688883a189b7ff40255a891207c66498fe239abe5a56ae6fd6244ebd036f51bff6961ce5d63d0f79557f980fcfffc2951f810c252eb1795976a8f5a0cf8e1f63a63d579f7b66ae5a3e9e2213eb4f159c859153e13e9c78e4ebb4ee3168e522a6fd194ff094f13668d884053ae3e599e66f12a1ad0ae3d7c563ebd6c9bb6eac208c66fcc1b8254dcb359f0e79f651f7ba6690f6dec6165b2c8f60094afa4795f5895d18ebb311b4af0ad4adc63b01ecf2af8343b5274527ff5ee8b46d9184b8585f056aa566829b8d1d975194b64cc6488e9ab754227c47b6ff2afdc86fbcb88af79397dec0a32c0c93bf2c36cfc7e5cd9e5ecd0abf324dfb16a410895ab0f5351c7b7e8966c90694449bfd994060510c7d7073be686513865562239f1df1c1ee01216df31eb5f7c0aeead7b60e50ff12a2fb4f8f197a5409ba82201928dc37659d1a7626fda988612249e60e3ef3f2d3c909ff9c0ab0dc14fa2deb548ef5dc2f5f35cbc17b04042990a535c02f1e80557e3f357273b7cdc9c264e41b7d9eeb8d7a0b6eddf0d650607e98283d14b0a50197a645bb2dc7aff8113363d94fab24b39bee8fee136d127d7686c456bc341615ffd648ab8be9a0bfca29247fe53c27be4909d744353ec1cc170ede52b94f2a5feea53736c4fbb6ca3915276f1d4901ed7c06698eb6399f5ecf5ac40cab9f52dedbc27af2edf6c7923f26da2040b5875e919a756c7acc545cedc7377de38c3b796943c229244fd38eaca4a738d4acde2cb5336e2f781c9804f65e5ce83b92c34b06bd0eb620eb82b6c9e5922342cdc2451bb10161ab2bcfd3743533b600d59472a4dcc7cb27c573c8e31cc4e550e19fe57996f1429141fac25bc4a470137414289ba34222d19057c05241221a3a66e8f9ed17cdca7e9511aa8c88fcf472de7094ee6e6caf9d27e6a6aff2133282ee76e6c55d1a535effc3dd2d6fe4e86acb8ec071de2abab6998009561e2c3158fd733cdbacaff63c27dade1e6767609b7e3a8831e55ed5646ade015a6d69845ba9ab9d210fb2d043ad15e7cb9e9f8ada3dc122a29bb0d675fc118d453fc6f3404692ee6d8c55531bea9bcdfef5df50c03fae2013347be8581857eaa26ebd93e6bec3fdd0231baeee8b87d10173a2962b612ab648394843c96a35ab6cea5dbf65bbfc2f6244952b1ba2574a138504b06fb75b98cfc29f33784e7f037ae3fa71a7007de60e541b29caa56ea2266118e6aab6402e291e670fcd873d010470bad3485bb6fe768bd050d99fc01779b4ec021210ad86508669c8ead3c7e7ebc2a220d5098d7609a4c0df133997fb339d6e1d312287c14ee27fa51e60b2a4c73194189e77c78c8ced5535f7058d067eddd078994a240e854d86179af2c52fbbd1c6ecdefa455aac2d87c60a7cabd522027a39a0accc77180fcd721ba3fabb0112ee7852a98b4ca74cc6250206df41e3f27bd4246f74eae13d1bd13fbd2d91a82dff50955a44a6d41d993b1ea7da0b5a6a280fd297b427830e68ef0ffa89111a60cab0b62e2d261397ef26deab937e93037f18b3f6a132f05657d3414ccbd67419482e15c5c20336e423f8b3b303b8551b4b6b6ce64391abda52dca7d13fb689bbbb637ac031aac6cc251d4f68550a60cde68ccbd89f42f75bbc74e417fe399e30e6b3b0bbb6339f8921bf6bbade6e6b21b0a6f87d9ba7afe4d5e7e2d764a49c0d030165dc24fe57cc532aaf66d55d4ff1b2ecb9471d28d7c5e16a41555bbe8167818bd213e62628f263290273dc4fa5dc4fb7c8f082c4ecf430fd3a0938bdc95e1407588afcfceccfc16872c440ac877fa8d44027f62cb994bfc1f8d015df962fa9796c712f3ab07ae25fc9c25009177d0354dc1eaa52110c59ea920b5d72224bb398b8284cd1cefeff14a49548025e925d85380889eae50b95aedb5a0e367977ef12128feb77f0b7d29f1aa0f14bd3f30a65e0ecf4a9e6f3c689d72f4f692526ea0cd99d0f7cd4437bd0b504bfbb5939213a16204205b4c8e8dca282e4bb28dbe6cf8051e00cb93208dc1eb7c88ef1e968101b22e6b3386dc067f6b35f057ca59a50e8ce8e844104aa98f46ccf5df3d21175480fc11c512ac52ef23cc7be41d2c38aa26f9bd2611dc4423abbb000f2622335afde235ef9258a6bb39256adee274e67206a6f7465e9c4340207712a3c0b8f88a93326236c64489840a010d9fdea5f4c155e8d973c7184e864b6a85eaeb6c3dc59758720eb9fd29888bab3e22cc1e6176f364ff60f756c39e74bf7434d4eef984c298ff01c3c393235be10f5ba89eccb48013e35272e732bbebb5b0d06a1fc618025a43b9bfa44da24e9f648f9c3fc07fc9f8fb6bb17a30bfa49034bc0640ce31470551739f41fbaf3bd735e1e0938a4ddfdd7cb57736e91925ba6c2e008e1ca9d2b73cd7ff2853e1671014f4017d660a699d63e9d7634153e4170ab83778ad542e16e75c276a51ec6dc451a32b77ce772bfc186dcd7abbe4c31cc6cba3c52ca54278b9b8a1b827f01af95ba0c97f134aa667827d0cee58106d3a5af9c74515ba4b54bfe2b43d00beb2e688c6e8126cfc2733df9614596834d9583f3050967744e80636260d52402595888a8882f3f462892dcf766273807a222320375d78850e9f2c27f691d0dcd9f592db766e342f30871a71dbad66265f8c7cd6b914e35522922f00576277bd01cb3a0d894b141af2d36d725240e252bbd06694013808e5dfe8314997d18805498ee367ef9896cabea7458c41ab5e4d2e881faba7f8a53b61eaa893ed84f5f122a4542212ce3f43324cd12a3fc070fabdd26338a4be4e8c44a6c53eef736ac55c3a62e281d87b69dc99a23b8145abaee064a5762fbafe022c5f7b4f44d81740370c42a5739b3cfaf963276c9c963aab9d5fffbfa155e1c9b1b73281103dffb0d1d640226e84894f895759a4769a0ccc8c84fa61c657add6da019b466b5c646a97e3785bb9e20456d7b0bf0b44c3f89659a2718df449e47f3f7bf125c147593ade20016a7f7f92b3eef6649fdce520bc8361afce25052c2598dad0313acef278f9ff2fbc54dffa8262dcaa16b3c32c2be0e398b13d4ba1614856fc856d47fdc97c97aefbada8c24ea58e4966375ee7ef4b8036e889db7760a0ec65f685a734c3f393ebccb5451414ae925fe29b810255c82f38c65a409ff6f6cca8ccb73ff23e54e2cff45e19280c13b754590b5e037951fd3c76cfeacdd4c75dddd4ac9c4718b7747701472babbc77e4f90ac78ad5c6bd91543dbc53ba7d6a5d2a7bc93d27a755d3c18e41600ff57d45c20fbc023a643abdde96a230b4b1bbbeee8e528992cc0231164ff79fb85572b023b8004494acb34ab1b87c75184aa3e5460d74e2bd86d80ae9f9c8eba8d68a9f3aaefc9ab2b301e39887f9d06f145a86e4c9087d7be5bf2b96a4902595ea4d0def2465f9831731a34e2f729d3736e608f07621aa907985672e9ab5d7913355f42ac4eb6d1c57e7dd5329b087efdf88de516e8adb5c75161db2d845580d3d9cd9cf6760f8a9af052fdc3000b384306076226e445356b869a3a446aab9d3cb68e4c8f851a4f9d23e731766ac116a07976d19345ffe96db6514289963b9e79a5e9b5d181146002a4dc87cfb96066124369660d36ecbb493eccf204c1ac1fc1139c96c36922ffcef808dd4dc6ae9842cc14804e13117b9207b92e7e33a1070b532fb664de9988fb27b75084dfb61c1112b7af97b98300da1074d7e4b5aa381d90fcad746317380371f47e0247b76be5c24c19edd93c65164ba6ca2dccaf64e8b31b0cb615e27f5f943e1bfeb63dc90024e469e8c57b7138b70151e5ddfd1e67c69d699ea59033f636e87a4080f7c8cd7bf530d0b0cbd139747eecd7b509bd8f3f4e19ffe6c8d36ea16e7999734ba591244ffce99ee03c7f919625be577a5194d652f2cebdeb59cc9690499d0b71352ff0b1bceefcf2ea4802397f53725d0e61e81765f08b9a68c4e249d7cc6509c3cd5f13f9617d1bb90cb4cbf013ccd571fb24c9382f03c41faa590ce5e9acc44895efa8f68048f2c410bdadc6271c1ec8f4cfc94e72a3947524dc8a84e2a951b477e2e76d5e1728a03a6789805f3708ea4c963b1aa7c820f3c882e9aeee632fa011831763643e5c5352456c2b652d7d89da3ef336c1193aaaa5fa03f23055f5d783f2322d0be17bf8fad857f3bce9e0f304f8b1e893f9758d5cc355fc4143d2fd3a16b15a26c22857e842a02d2f095c1271e8ce4bff0c90520334b970ab7d98dbddc62c186e1943ad6bb98278a522f07efdf711bf06a6caabf2f93acbe26c9cc566eebfc7e73f033969fb27545ec24e1335bf21ea3a748799894aecc32a6b952d8f763d51837ddbcb33bd8c6840c47eacd278584b7a5c6645f1af6ae806ecb7b117634836b151f88cb1069f4c1702a474ba13bcf369c5204233793b598292a355ebf0caf9f1bd045fa5ebc52dd7af29a07534d6a3d9f1a90a13abecb6b21526c973dd551e492d7b002d26cdfca977d9b94b88e76305b9bb2f2f87196aade770965184dae62cb9894f7018671183d8bc4c8ae4b3886ae06b68689a0e68fa3baec8a3b73f601cb806069a0c02cfa74399d7ccd9aba3bde5a78b8fc3cbc11c307bd6a94e407c16be8cddd870b57e6a0e0e03ff3977b9ea6d5c3f4be45cdf6d49afeff3969e64af1951c349f014beb7ac74a067b0cb33d3f9a2f0394b6343f194698fed043be53bf535068e6a94d1b16d58f9c0332d3419b5b468a9193d72b8d4be994b25b0036ec703acfd93b3d4eeffa4992f3cdb92ea6b653b1dc86e2b92b8a2277de55575a5e76ddf258f219a51d208786c07da3f32d890b80fd1d58bf752e199d490639e1147a8dd2f1c9889db9ede3339e59f2d0eb8babf05d3e7b2f5983a845073f76fdd903a52cbbb2ed6fec58e5c490deb6d91a08847f1b7bbecd1fca1f545f604fbab47eaacbb04f8e1e5623215cb578743c5bbbe8c8ea05b78fc351b26a3d98381c5aba7667166a3465286b1f22951e870706d113a24caec1b34ff62c901f9108b1732cfc4ad91bd1d9bb658060bd7bd76dfbc0f77ed68c1d71f4f46b33c5a966d483a0659e033ec074f1ea65a74be4ae3e0c22384e7f9694635b4ab1fb3117cca3a7c8847e1415fff4b7b73a9ca74c8ede8caec72a6d1f482f1efe03ec54d666b9229418386221a7f206c0c837c08a04f516c389a037ae70d4502935c2f69140d442dd076c44dce180cb8097f1f0153e1422f62a7682819ca04843cae2ff83301658f6f8d8bd70cf9f473b971d2dcedcc7ce0ba080887009b0a2d40a8d44873222a00df9a6a504540f279f192aebb6e1aa3839ed5ef4db0368aba96727beae4c96c1f83048b1ecc2dedff57e6b2ace0df81452d1ab8afa29dcfdf08069992563ee94f3a6c324896ec729aeb4e628a710f432cee593f53116b5df14f34edc2f3e05567dd1d277af5699f8b5054fd06933bd5145967cf6c0a91e922f7d59f3e69bec9d8a0c1971e5dcbe5ff5535d648663f6d2ff5bd51941178acf806e36651b8ded2d73c2cd21fae178c5dc8428eab42015140e9bca7c9ca64d02543d7c744b041c0a285150b6bcb57f0e4d376643b5a19cbfbc00b5655732562a18fbb4302f8361c9ecf02f689757a2e375e96cce4625d89fd5ef19bd65e7883609b2cb26f546cc23ffc5a4cb49f9b096505549b4c80bf5d1d605667e3316c320bea30ecc8b457c2a3aa30c698296879ea18e5faf58e0df87580a8093a4da29a5c1594fd1a1addfecbecb3cc35b8a9e1f713fdc1f0099153d9c8d10500653bd11b1a905fdf729e768cd91bf65ad2b1522e5840aa732ee2f2df24337efe2e1cc2da04ebabe250ade968377e1eeef5a8b21dfd91c2067f60706f18aa1dbc8fe037b454780184c9571cc5fe03ee20b97c2b984b421144d16494c7233b27643a5e5a11e67e499533cbaaf109fa997853ea5f6c06891304c9dde0f0a54956478faaea9eda756129b79128981630ef25f609d9671ea153efdfc2ce3830b292a479f4ab63dc7c796bc463320c99a7e46c060d456afa94f5ec563d227a29c536440da96581e23131c7adfcb3f863997b061decd4042ac13006558fc8552a9893a7e099b4f15b3df29ce4fdcf716f2d42eed044832712c1c6e4d54b33b436eb822c5efd7953dd3492d77e1eb099b0be716f4a49c5b4318c3b8fae79b3d013b805ce142b812ef39f10440bb7b42294e6ad1f5d415063b935d59302d2b9f491201e572a3fb3734e6ecb5461a0ad43d6938b62d9c81376c7c23fc35f81958dcfa1e3ffbe6cceeeea5de300088b166b4d785188593384651731c6a6a1bac25880f76cfe2f00ad775f173dcc06e41b87a3fc7e688c47ef6cd5383148f286c2aa9d9390733b6316f069047b641a82a2925d050bbe73d6b0bc2689736d6c699b17d4ed7fa57a7338a5c42a88be914597c458bff3acd0407e4dcde1f19b4ab37d93e74d17c996edc330796e3d3434c9a92ef05d19ea0d7fd33f941ca6b6a1a48d65de8051522f098db2920beed8a0c16e09cb5b1eb63f05bc60a254f5391d5544ceecbe346eb7cd27165b2dc64eafc8170245dc37d654a0630dbf6acbe8e9aad3a35a03e854d096820e59da445205fb7e8eebd0d5d0ac6e745ca71f328f03505fced5ac68f9f3adf4ce24a54b4338011bb512c7dcf8b4a56abef13cc5bd3824d3f61c4d56779492ec63b1c59ccb1b15bfcd80ef4440854822e536bc1c45a9d5a317fa3a2a90062877b43cb4324e173706d776e850f0fec7898c7aceada0f01171c458dfff743e565e4d3f117d93d15ae45e481fe9b2725476ded95f0e5cb476f98e045d56ff762f835457b1aa0cd693bb216489c04236cae63026b496bb72211f004e5be596555257ebd3a4e23fae3807207de8912631bdebd0e2b8ada35ac8602e0a1ec8a806f9140331e245d8156f8583f58ea37db95e8738be26822a549390cc1c8234f14c25dde53ce90f3db7c44b80140c5d2bffe5a73ca3566f868c18cd5c0121923faed199df089072ec6845957c80b590306f1c14664f7d467374c4b45ed8e049a223f275b0cf8a7790a974b2c69e8d9c1f47e25ad481aca7c4016f4923803138ba9f8f9610b93db116f97a1ff80f40f342c1e176b7b5d020751f45675250f37446e9b2c5d900ce83cf20224ec53813aba7574338fd54c48dd9eadd1377eb5a6022bde9ad715ce0e3003028837618ab993db24350d44ab13da7b7ca8dd0a819ce361e179be7cf63efd3225603518667ff10fbf3c9ce4b75e395a97ab9c95d1fd7a810d74b164cb628bf3080a7e5e57f5df966292d1b6731260125f1d6891f9ec72d985a9995623533400429b069150b8a9ab676cd88eb61ce930f6a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
