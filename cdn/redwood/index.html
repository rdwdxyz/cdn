<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"44fc9861426da4a23059ce773a170472873197f7cfa3a4a34fb1bc9aca4f9ce197144556dd58e9c4640bbb03a06fe6ee8581ca2d074e26ebb8d79bc12248dc2516a9cc0228993d849d5e4946b271216f9565f07fd670961be3c9847ae078c317e02ec93b9b6e38041faeab3035a74cd83d5afcf56904913eec3e544ea355ddccb325663b810895c72063724587a591fcd08e754e74ed9c68e8ebf1a369a280f9ea0ecd69d79b0ff03d9c1d43706f681f784cd02a130cdf4e72575996eb47ce77b441ea686a660bbfcb850396f813fc2cb0e0c4788a154223208734a9e442574eaeee8310ec871ec87c27d62a95c9fe15fafa5811b1b183027a359edc92320780c27df9ae42c5c104b8d441de097422d6cc4f1af0c7671409ee0bcaf8a2ce8faf128da1a966de64b4530346ca1c391f2a8c02828d5886d383c342127e3f5ab53d75e00d1d62ad1e000c3a19ad00d8b84f237cf78e7751dd67deb10d1887c7be82bfe8a685e8e318be7df16214eb18d8b9a79472b7d55f02643b5713d13bc39f6bd19c8fbfe5190c4fe69a100eb1f6d6083303283c06e63a96f33439ae1a4cee1cb35b54d2d087f0fcb022cdb78db84ca1c059e203b80e1a47e9763b37b193c3770334b6275f59b307ba9f5f8542913d56cd189f4e2fa7358fd1a7de0404af634ccb046cde2483daff3bb051e1c7634bef5a63a24a70478d12ff80b482a631e67c09a0d78b0b9804dd2016d8d3c5638c78b4a6d2d129b0643e8e177048662c2e979b4f33f2a1c246e2d94fe7396acc6939cf1fb1a5af1cfaadfe533f7e49e8d3dd0b9b29120eb04c79bd05c4bf161ebbca032faa67131b6218813b5af430194ba0cdd845bef0f275563ef27e3fc0234c0d5e6bb3003396ac2c46351b5ced94dc1a42777c22a64c9ce5b19be7466a2edb236f89962e1e6b547be2f8e394c57f59a9a3b5a0d132f0111e5485505f29dcf43665ad3b7cecc0afee89bde66f4b5d7747dd0642e856a194d59c87fc8b435dfe17797a91a45693137805003fe6a1f298b5b051f3860ffb660f5c580776e142d8f77b4bd0263811dbf03679c41dc081aa9678179979fcb15dbffe6d3bd0fbe84171ab7b0bea0c02548bf71ac2566c8a2f2ad657bf8945010c4b0bfcd1dfa0abb5d0d0e8116acdcfe92abd9f9573f5376a4f08792715913ca75dcc3104b65681aadd8f98c8bcb371bd460c1ffd40cef4344f13761aea61d793b0eea39b94f934a07c6566ab243f5d7dacbdd84bdb02981003bf4dbd09c98e2e6eaa637c570f114f641ef78df960b03fe9bc985418d4f795767fd5a270d3a4515d7932258fee96f6ceda6b646015d7ebf3a04babcaf4fadddc930a0a2a7dade838f68224ca61fc9aba37fa5beccc0c681e96473dd813a01cc5b5dbe463ddcb0cd99f8b172656c83bb1da11720712deb3e8b2e337dfcb9cef8dc9de5585632fb01bd0371b022ee7ec5c56eab95368c8abc69e140837e07b9be271f8c9871af5b0b3b4015c1c91b3d68e32f18fc0f55794b564ede93edd733dbd91a094839f49277ab12c1a95d837f3fa7a4bdcae01ae98836cb899902a42f42379f79f8bef5eec76eca078b78e076e0951f8ef6d15b41a1fe56dbbc1840173ffe0e1273ca4dc31ff6e3aeda2e4d68a4946a9e0f7628fdd11b40080d5d501d45ef2b78a56b8b532e54dcd9cae5e6b6aba9e2f7c0572d477a8158c204d019ac64ef6d2430f5dcb556fce4fd675d1aa9a1623f31761e4d71d8a2c503458e67ea73a938c38de04c46fc5f995a77d1912d6504105070641b752a51639cd006b6d485489ed974aee60d268b1099116e9af0813b23a8f4a10d823150a332dd8d99c289b0627a0b2ee9a948b3474c11887355c719b64084e1b9e53c7ed1ba650cf9c210e979bee14149622daf20f43d08c66cb3830d913ab07199d43d6d66a13e8a504b2748b96c91fd03d9e2968794c0c746384d3a37b617a9b03423ed0ad90ad2e5f97360ac98fb51fdaa4ca86ea883185ee2f8b6e4c1e31aea67b78f384240698d204e74f410cc35deafce79bc8815fe91b98d79445ae156794f344019bcd545e52f25b75fcf4296417fe553cf68f46bb9e76802df66399fbfcaa89275aff0711e8fbe2f9c77b36ea4f9d90a84c86ab3304f7b8a5cad27a36e4e5aad26bba29708a54c524a1907312fb30413980caca3ad6c0f3d59c2993716948c7304b7c7121c2d457ed776ba66790bc37ebd161f96e0df4c286c4835685e685d14ae761a5daca10fe3ed234ca8c6b557423aa64682e4f3d74421ab242105f1829387ad5097570f3008c37b7aa4dce8b1d907f77a0ec8115fc0f3c80ef0ebb3964a0ba778d530e1b98b91b16f130c64c8205848aeecdb39de8272ac67347763221eb69c8343ce127b2ca6bd3333986153e63edfbd66d19374678b3885e069d39dad5f6f845f5cc2c500c3d63301904732339a91500e7ab62d75007554452929448dc68cb99be731280e0f0a63d3419b17a3da52d90dc0c7918ee0394584ae6e9d79d0bc7f8328d9d735f804ffe4f46ad90dd04d02e132411edb32edfc4e8e53ce4269ace2a22725419f9ba7e529a8a3e4574eabfec4d28050eabf4e6b4ed35db0fdf901251a0dc7cc403c16fea8a1a2e54e9d8e9371a115540dadedc3197f9605a77e214cdba8d43e6d45a3ae96c5d54234ea48b1290bda28f09bf241540b40357918bac308aaf7b7e12e513fabcbe3ce2f026ebf06b42c9375c87a6c6e015f0288a5e8e30468fa3d3e2df1b02aa97e9c746be8a37487ff32387b4924ac5ef435ad3c3dce347394402f5061654f3e4ba55ca0d4ebf544ce8aaea94fa97e5403c92927950fd0f5b7d0bdad3887faee66658228bcf38dbe9b7319812bf5993084852d6962b773c6b1ab724808598c47f602f1ea475742a513e8db6508c80ebfb3b15010cd0a91b5a292265676ab2e9d3b99ba6ca4da58e09678fcc29f2509346c9dd0f4104181cbf8bfa0f3bf0efeec5b63950c59b8604a0d8a24a82bf9b8af8685653e3b70550e6670d6c6369e4b2ba7513526473030c3f5ca61e3318c7b4914fdeb2517cc04ee6b280aa0e8204bdd2515bdb5b8f581d6edef2df91771a886266881c6a4c6a69bdaba638a1b7d32aaa1197dbe4566850e1591bf58261a0cb37f5d64acddf6081f1cce1fdb30392bb16671cd95345c5b8ce9fefecc791bea39edb86f4f13926a4b76899df657f968467b6e6bf8cb921c30337ac87a2909cdd7d8629d82d2ec99f12b9f27a3c473d359d544d5b837c364a1820db00e0e7f6c09548b4b9da6f8e662ddb4ee8f358a8e3a72e3db3e3a3a2a043e8810fd251c94b1bc38497e78275f090ef975ea0292443bbe5f4792e3aafa2019c81a0d4252551e851ed036b19a22120fe9c0abbb8610546648a3f066a55aa2b9ec1dd6567725193d958953c538ef1e54b1f37af5ea3c134378c71d4c38a6e9c70410436a4e69117c7803652464f38ca4915958f09792572378c7136e10fcaf002e1b555368553bc9464e23373bc4fd97ac800ce37d25706035b20c319fda8931a5d1ee81f1a9536cc52a94c172332faf692da1ebddf68650ecc231ae662190a6ba068a2cf21fe31fc2049986192e2b7b9a83bc922769a846878bf6cef12f5b218e886a0d3a546962ba5b223165eaa1b2ea0df2639adf63ce97a111443b5e425ea8a00f3513b6a4ac9c47b4e7d21b3410f92f689967d93a5bbf157997659f302373e508ef75846c4c52988af4a247720a5bedd466892b7ef785d83524cbee56ca606261527ef79e275390995ee9920db95fefc59421054ab99c06f73eeb800704cddd23fe6b41a27b9a2ffd644546cc107d79910c1844e705d2725639ee9ce199994824fc70bafb2872c07190dacbf708486d651517d386e0bc653b8ad2e6b14c56e3c8f4b00d87e21f726e185cae2d245a1a86bab023556d3b08d2d80cd48f888922953f96ace03d579659caad6e58551e0812e93331a9f5afde9a0bacff0f4651e29fd0fb812829bbba5db8a4511204cf3fd2ae5821de8bfc166fb6f3ffd02457b5a035dd42473d43c4485f97e4a16fc114ec203c325bd9d114cb6acd32f6c2c55081164e0df7b4881a02fb5edf98d3d551ae32a26135aa7f33003d4f31378cad42eeae2cff133bda0f49b1c3fca2f4895c446aa2da3763268e4114a928042f3667bd692123678692e6d7bbce19f99ea15d156d8c90ac6627b9de06aeae714c70759a32c9a9393d6a9fce46bf6b1811283f0905738b17f1bd7422b9c545bf84380bcd1be69e4a1cb5443fd7e89a9b9a6319ce0253f07fa82ee4ae9074be5d4b001ac013230ba4eb640634b222024ad9202787e586d20d1f3309a8179c5a6c9f45faabe40b1fd0e703530e3f75815b37f24d6a40269f2ffd8cd20660de5583dea5efdd833a8d30b8e52f74d81ba0894e867afc4f93725fea2a141e907dab07a3e6c061bf5c2ddb0d41d7d0eb7d537df09eaf727670f637506f0e4a2cf3e79a473af43487df6f14e91f87f73c38159164dc0bd17219b4b73ce007db80acba8807801a106d4556baf4b13ffd9483032295dfc3b6e6d65479a5ac750d9f0ecada23ca6f32c976f3158235400586965a24b4a533abd9e5ae9921d3a78462fdf0df80cc0a60a4695e0b497fcede3c15bb11b6b228fd12cb034af7dff575f1d357023640bb543532f364df904957bc1f4802c78deefebf6a0d63b121f3b597cd71bf5887ef11e1eb709f68a0f85e5f702affbb744a938923b08e7b74d0fc46db007a7f8f387368f9c14cb577b3d233afa4404645ac576deecd48702d1642fa2f43608ce8702444400f9ca1bee9998badd06cdb4724cae0cd0da7205015916df78b7e2c48400de7baa7c4afa8a32d5070a4c8a6ceedf6b26f381dbd604deffb08c989310290c3b7d5fc7f2149b27c20942515ffb3e4a36dbf64fbd4b52df66bea87ca1175814ab84c9db4d8693bf243b1cefb7b9e202b8c04d9dae1a134bac01c6e0be27f6780f88c850d8368abc850e65e75f3f53d3d3e80c2f497fdd65e103fccec9e36b393ec58062d9dc8d492aff01a713af581daa611f91fc5cdfba51fb79e58cb5d7d5a199600f9730f7690f67d93ef25cfad411cd0f8a8056fdb9460b0b9fca7a629a81fd5e66ef40eeec05f611f96152f0b4ac24c55f138c204bb291be43dd2fa2f465d21ffe26acca2ad4fe11aacdd362e6a49a62af463d71d5ec21d02f8b0b03a20a1505d11af75684a365c4fa6d4b7eaefaa625cc4948041cb5e492391e392b037465fc8c23f6324dece23921aba51e8121cfab61bc3099f22ca7319616b63b892e574d3c23080562e770789513e594bd012737758d5bcb6e143cade76ece4fcebc9f6455661cef5cb5155835df7957c811ee5415987c4c8af40f1b38260bcc86ddcecf46b3a604b06d266c231ff9a085b6be8bb931b3f21514b684ce3d2ec44b0d31154193e37f5e64ed48414cd3a08bfac8a616445b91409e17f09faf0fae436c98133699be3e6758ead3caec5923ea9509f7fed1f9dd2688a8ba6d5627e18ed02419107cc7a0f1b9c42fa7fb5efe85d0bbbaec6e42e1a16c03bb4a6e6d3f9c945f4bb1c39077bd6c5e8410c4416c29324d1a60f847c15fa2cee35a1cda4b07ff5b1996e0e2caefb20e24482da2a25ebd4784ce2de30e3c9a48b56e329f6de1b918aacb038c6d5d4031ba6699092dc99befb373ba03126f053ff23726c28d4c4559a821cd4f7f865fb436497d9c8b5ecf745f1d173e8ddc2155060678230b2613d605bc4b7258bcc9e729cf119a6855b86b7b31960947f5a7e4136b2c7b5e3b6d4cfb2b1bbf03d4b8f98bf94783531edc94400d2c853b883576ffb746de0ba3cae2f3b30482152ed7c1138e382593432ef7ded60d87fa2cd64c2d486480d29364262d3ab34898c8ab12dec62f67f37f794f50d0b6fab2cedbd71d8b6794733e917a4afc1878e6d33af5cd60e9bccf916e166a88e7194dbc51c3b88eb5b7e9ee6a9c824231a3e730424a0f8835aeb4d8611cd43e4253d7180f95e010fdecd6cdb2ece74052daeaa6e970f80dfde7247c56fd335264da21132f35bc1cc9ba724f786a468370b6a5cee0712cfb9d996154d940c01ef809ec4cf32749740f8acf67a8e8b92b136b5b0d78bbdfd421f655f8c3e2cf074fe689fb39217e09dca07b97bcd7c689f3f28baed74bd251d3668ac0052aedcd7744e236b7c1b4fa557d76fbbf45ed6cf204cdef439ccb8e5b544721b4c63034bf62d89c5f39348a35fd1f4f3c4f5c263c193e69e1a4b51adb812f01b76303c89c9ecb7c2cc7adb9dc797246a39eed0912812ef097e981d7e437e7365995352f36daabf83359f9ba4fdb5a4f0d102a2ed4fe0531a6cd6cf09db303166996962b39ba829bf3f38b19ae347f62c3b44e0f35772ac250926f9b053ea304b7f449ce432eb14c4886cc946fcf9ed73e05c258f609ef7f2babdd6bcd6f8e0c2b278733d0a423c76de5dd649289483e66dc84b0a3eb3e4800bced277a5cfc80722174086cd347f2e2ec3108737d001847b2e3e8faed0cccd0dbd22837e7a97a77749d69c91351ce9438a0f291c254f0897629b086eb2da2551cf167dd51dcae87ff9cacc305400f707bea1bbfa450c5e1410a25a2a24b350758f3bb6aac97ca62fc2fad6f1b27548591f6667b21c793670108f306c162af02f3869fb1e57b864c0c34097595ca3e4f97dd349cadc4862118d6d88a538741558af30039c8cbc7103b1084365060e74334c97c3135ab792320dc473dcafd23e125057807147a0ce6e2302be1dc4b70caaa27a061b814f294a01e7a184bd040ce6a13c2e13ee3768394b299ff23e0a7572c334a27898c439641f50a60d0c6c3f48624de4a902080cf2f918ae84e8d06b7fd7d3a86f2b3af268e6a3de5424e97c27ca27c4505f2897d6c018dfc8c23d41a0a114d789989128bf7cd0e75530497d810e1b6f7820f0d132f859e93e4c4e677520143cd6af7765f7c8924b69e094df3b782bd8a9e0ce9499c5c7cc109e046e991248bf5d1b48b4e6f2cb92704c699e3b00a090fd0b4b8f37e0796135cd9236cb432f52fd9511f7f0987cbb8b3f3e6d93992d621af0d6877c6e0d443a1e1bb608dc3cd09ee9117227a4ec7a65a7a0ef24ec1fb9ddaffd9679cf6e4af6438a3c1c6c8aaeefd4543d2f2f57efd86d4a4aa45cf70d7fecefa4b5dc157ad11b66de354d146a11d7f78c5d3541169cc42825e07fc4adebcc9d1ee43ae5161cd3b0b04a355496028de32803a073a6baa9360ccb99704e59dfe50777944cc484a289fd5eb8c6939c384d1ad82bd87d374572e0d190b237c051248ae715c3285da47f5d80f31f4af72e79ca6b7103a08881f9e32c8c439c6dec09a9c0313d08b819df0b9ecd79a6ea044dc2d391c5b40eb73435a86428bfcd7b6d98b510270699f053df3e9b2819d1523b024afa4883c7834b95c962300c57e3e5fd82da5727f2485ec44d1ce502f60128879b0cca13cfc0326f58b940fae681843079216e90a62fd6be180399b6fb051dc17160e7060a67bbf709dec23a5c517b7d7cd1220a735e109ad47700d730f414b14cd9f31dce06b0d90dd72d4f8748466453975a7348a64206a9c3bb7df000b128b38d5dc4cc219c2438ef23b55c7cab253bdbb9d122d07991dfb6d8fb82e91f62ee66684e49de16c900edf954eeac23db1e708ead30e0d1f8f94926b976616ddf1a8c93a02e26d7979dc392dd46e84cb7457649fd4b8621640c3e4896530b2f66d90dce6a851985995272c6824b2095d4add9c74fd9a4233241b8902527c6031dec766456101d776a13fd7eb8060064c8516d73001e56fab0800c6153d442215003e9278e01ed4a83020711a57455f3907fc46651dcd5ca6ecaf5b55ca6d2a0dea9d47bab4b3ec7e0110f6b041b17a5dcd15c012c40d87cdc1815df2479b061dfa70b5171a257c0ec7e49f0e96d3f9fecf76bad4c4477fc3e103799445f8bb6510dca1dd606027a25c3f48c659666abfcd6dfdfd6ec2cce5d4833204a39097218287622f3c45b67fa53927a9de703cae5d51c033a284ca83095e7fd9535ec94fea5abeef930d78b5b798b848a736e27fdb551398203a1a2672bd7cf2e6a35c7ed809016cb817f9886368de4a49bc395fd78214602d0aa4315a3faa4fc14e421f6f486ad8198740422f11a40de5aac57107bfd33ea9ea3e5588d343a8adb4e16325e721f26ec8467ed8c5b40baaeec14cba317c093ddfd35fbe78d7cdc1363fee6e80df9bfbf1839fedefee22d4d0958b388332478bd80518fee7cd9c7aa440442cae9f8dd669a6f3966407081e3cf98c8f24968860dee2d8678bf107b8f9ba8d0c90faca15c670f384d2bffcdafebc0539f5c00e2bbb34f6bbd4486af229b17622cdc49878cf8a398e2b6aad3bf7237da0618f4aaeb1c5c8daa886f6af6413934132327804486b6b2d7284824c8ec7d1a7eda9c4e54e26cda5bbeb0c0512133f088054c8b9de271c7862b9000eb5fe593d582a44efa3287a1b964e22a530bf61d6b7b05cb4ec32a092affa7cadefe81ca5abf6e1beff9cd24b31ddc1f77293868eb9d91a9de3a3ff4f25d0c60e100c54dabf6be1335d94541322138dc748153f9c9023ec0187b51c2df8a608ca32e2e0fac8395f5177485af16fa8cb3b006c4dec86923cd3cfe1a88659ecaa1d604175163b7bafc4feee75104015e388669c6cf24cf077b5070dd96e79dc497b63a18618d2625a781f5a76e08add113cfd18a27bf438ceecdedfc229f0bc3f2a4aba88c6b6dda82750e5008078b2b5f78d5efd4e5b884d0f26b0b74509c61e7eaf50fc2ddc00b233b236ffedeb8a79a0d25d662097b8bd61b99ab14ffc355c71e0037efce33f0c72bdfc58badd8123f1438e8c8770e41b52e3bb5f9d22e1e760616271bb5eb4571871dd1687d7a32496c0c88a7d823c93bd850d6b7983874a9339ba01dbfae84ef3fa5d047512667f73ded2ff3810daa9c742547a8cfdeb3b0277d4313605fb98d7239f34fad58f50543fccb766394dede4b29819f8ca6fa31066fd856f82c5c7ef76d9e4f5a25a841e714cb92a7a5feb1453ba5259b707d09f11695415387765d7546b54f9117f19e5ce9ddf1407cebdddd8d5b378cd19e07000e65bc103202a7986caf4397a51db63ec3c3b792069a988d32f0e354e9ac84816dcacc78ceee6a4b78877b69d9238d8cf1db04b466f74800f2bbd6ade583339c73e6ae1d3e6015bbe3f56dd8ef75635c7461209c8966ab0bd86dbe0bcbd3a473f7286e20ce3d1c2607221027f1e8e1ad855008a556db308963bedf7083f6803d3d23847a61f13867841fad6aaf15e073c2cb708ae966148c512aac4d11ecefe12b0b7b53083e95e06c34fbf6b32cdfb9343b4e39cba4ee7675470bfd64aa1e413762cdae49d9e9cadf4f841e0b6780c959341e82fe51699aa3764ea46184cd061bc8ab2e514ff126f793fc39aafd87a42f59dd6e2daa843c46bfbc3468e40765b7c20ded21adf8ca0b71d6bd582d81edf9e535e62273a38918115153a241d799925b4d7028bc5fb647ee443c88b27987866a1bebf0ad6470960573ad7dc2af978e901efea59cb17056e5c1a02a29713963fba9d0441b27384de43338aeca54a527b120e0dab004c3980728d35565d4dffbc5bc50618d186560265ddd3d92b4a69db1ac6f9378afad28781edade6d711748daa36758acc98b0e3cf3237dbe9cd992ceba137b968d1a0922b0c199d7c499cfe1229636fc3d795f80caf588de2624dfe2bcb8fc831e6e6dac49c3aaadfeca1d3e99256c8bf4aa87653cdd2e1fadcee05c235f36112629812e48fcc0892e85fe6b66547626eb1887ab4279c5d6b9a25231c4c2195cf8460831d8d59bd88db3607389de674c218c8e8b9a197d5f0891b782fa5af35f937603416f340c945dce8f9056dd4e1bd411d15fd3de51ae30f80ded138ef050ceb86e98210cf768ad8cb273d2ba496deffd869651ca9b0e93eaeb53229afcf5568eb4dc2b854ef61b2648f9a0a681d6145a3a78a5eb5ebd1e441ecd9828e3937986095e11ad301a80de58b7ebbcca16b8199c46f3fd26a8ce0f2ed0abb3f692ddd1183814d37f816f2c8d30ad7fa9ff5cf0d9abf64b5015887879422a89eb451eaa859eeafe293fb628329421b84e5b5f535a233cc85b6c321a0b5ed1ad84e3b5a1ce35aa2dd210633f351cf15911c8ae285c9c25f996c9a535a0e52aa196a7cd90f2dc6603a336bc414c4696e7f9d7a904d1d1330f56993a43f3ce514b146301b7a5fb9b73b0a1a708058035904c8237ee48cd797bb408973a1c990c6742419472fdba53cc0311889c74206854c1a1e313581fdedd953bd661896989ad103c7d5caec0c984e57beddecf456b89a7081a3e766c0a70543e8850fff70e407eb8f44d83e3a9e6e982378d723fd2d9f5337fe07ab01f0e7b3d6d09e765832c7ec1b9d5301c6574267453c2bf72d391a67d58b68c3fb61e6ee1d52f6b212fc018f538fa9f300c78554570f31574e34434393496a0895712fcd01b8ce0681e27b1c6e4f2ac3fcd065fcd569fd9911836cf23087c11dd6dc1b4df5f098605cfd4c8365f1adfae8d9834390998c641fbe9c2cf2012d3244240c7d9c53280ed9f1f8667988dd9d9f16b8e78fdeb41d7a895cc551eed5a54fd6c4459c83d628a370cf1929494e7dc84e0bbd6c3d58feb2dd61e749f8042fb8e96648d4f53e3ec5be2e64d2c6bfbc868348cf9f093967f95e78043cf8787f698d3b8c847a9e537e82dc38fe0d0e4fb6963d8a19bac062611de9b78c3fda965d8e1f707c18c39cc4236888a9c194bd8aebede9b4201f558df2058f625564284c6b939b57e3b4e6e30ab5ee84fb2e6d35959a12752851fc0ccb3fdc079b0a1f521540058f181b6a874a3a2fc2ddc587a4b8c2378ce0343c2692b2d4f43112e60bb13d99ec2d173c075c736df26fbfba668d2a25708746c7dd5f189de3ab5ff1b7eff6ced06e27316d323a86cb1e92127410419073f5a0e0d1f435a68a8da69c097c974604b44b3877e989cecc115d79fec4230f1c0a52679aabf971af98fd8f23a18746312cca0d6d4254a79cbfdd25aaa90031a39e4ce8c7e744f66eb9009ae628c9c37d7af685a48ad524ca1b9661fcbccb5ccc1154cbd767bc0ef75b50e38b40061c0b01e317c2ac193273484cedb5983d62271a09fc24f73ba98bb49399e9cf6e516cab683a9d227ea3ec231f28c64c969cbd4773f6498222aa4962b2704cbbf73f01da31d0be05a11d3256560d5dc3881ae10af12c600d6d7e9659bdbc75a773f91bc35685bbdc5c426ae13a01804bca5a8d4553166ccd78a8a6170a2b94ecc6c98363bddb4d81390c59001a1c8258f40262787f129b58245c1df639be8e6f97589fae3983316f3f2803d66a29da0dfc6ded7bb4ecce42fab5d46bc3806c4f500974d775a88c44bdd6bf155b7f4932e491a9af686b91a227a838d37190309973a8fd63a6fa8fb77cc22929fc7e85c28535b0c7460f20119a21f1532d21df21fef483c5d18a42ab5afe02785a1c17ee384f8c7ff4602846968ab71cb6e85f0635d2fbdfc4c7d5c8522b5d480b9f4b10f65614f9a3613deacd11afac65735233b7bce8ed71a1bf8687b88ac2f195ef3c56b23ba51421f6c7d4bea6b1f19f71fd88ee35dcbf25f6cd6317fd569fddf2da06f451b0a95b99cdd3eaa59e0c43e19ab713a5ef382711a80917f7d6e1766b3b5d0a67511ce5b862180fa9f6a6e395f7fd61fa4042c89174fc97e143dd032594915ef99441bbeec5ca21517ed56d46cbc6cff99079b30589c988774f68c0154d6d015e33f4860d00fcfbeec5980e48add549de3c88f51182bead40267f205e51ed533f45504061fb1ce2b192d7de87209e87d0e4bc81f4c42a26062b6e50ca0e2774ee5fa70e9ee2d9f11abdf1a735f6120f14e21d8875896fe280323a09d2c43e9a0cdf287afab34b8b50770b8c5860421ea833fe43fb825a2769e1782e26f58951d1088c011de38247175552866a47b55eade2cc64bee1dfb7315681f170b881ba37d741ba1e465e2d6da45dd7d2374b7b48c5f82feb9159c017d5dcc36618391ab6313110550e2150ceb78e9c79d90524c8b171192f7e7b883c201e89aaac105584933178f9d3c1f6c87f927972ab0e57d41c9d8a12abaad6d882a81420b09cb273df66a76a5e6a5104e356034c907847aacdbc491ce805fe30e5840842b3643a3220aa731a74b39b499b685a917b2e8636fe9a5084e59a8d78692b18db984f8f52f4a22bcc52fb7c4f42ca288923ce5086b93d9ef8e0bb6c8af510771d2c27fcfde40db1f72c4be8dac12772b489758157fce6e0d153a13bc12526f0d0c7e7a1d19827dd0da6da6390d8d79f936cab60c0b470c5c5d525007c0fd294964289809dce1b0ee61ea7bcb4e13a62aca53619f61ef2275e07e40210f9e58cf9cb1387ccd10064d28944ec622fa53e1fa074797e6775631fd6d9fb1f41cb95449ae7bd6e2bb3a0904dae5411c3e83413a0e57bd4d75693a0793affdccd9805ae0e08900d16d2f30d2f6c50aea3418d788349a0cde0302370e459c9a065bc78ffa39fcfdefa302bd6c487e26a9fc7c0af7515340997642aea0297bb13b18de2b8f452fdb53de35b9c1291ee18569a3393bcae1a5aac3c271246e8b82f2927145f2911535d3ba7b86110bbc619ab935129129c71b4372fb3b5b42f529ac98f304608d409f88c5b67a8930f42290a5dba898e43a8cdf15f9bb9d16cc1ef595162869e824f5f26201418bff84dfb66cdd3cc99bee4c2d150d8b83096c174e4c47e821aacf41649b2e0936e5c1dfd883ad8090fbeb8d998871d0e7dcc565b9451b5f6f32aef43280def45268d028194fb0388b16e1db8ddd117309cf526fdd74842e022da173d12dd5eb2a50d38d32d71e6e8ff03f1d41fab2193b16d2a7f247c4b23fc9db33859e1a19fdb9122e31a9917fffbbb2015972a3988c25cc474baf24f57b8a627d0a277ef6164b52130bb01314b345089b90826000c638876a4e9f4dffbceaa32dfac5464a00d978e9940d02aaa407a64871a90bd4c720db82015476d4109e8bae6ae726215900cb2bf9a8b20723a722a7c1c61e5c771f77295dd27cbf9d2b08823e016bafdc5f002aaba5865d1b73201f85e806f99b32b92298e3ef12eeeab349c0ab387f882afd85751324ff9351e963b270688165dda8772d1b5bbcf9d5f5fc0980dfff4ef50dc2c3d48e8d0774b73670e603fd33100176ffce18991e917f0ca94688db3a7a76beb2318bbd3f2d91c466ea29e4b6e06c6ca3db561bef564b10ac7ef4a511a903e19ee047fe8023bd01213eaaff89a01c2776d8c1ea3c73f07cd5c3e6f74cf1c17df63d5f9db292c14fec5f36561e3e05e368f695ecfc92c0c73ac02176b566c8701e4de75fd57f399fcf7144baa3a276c9953025b06c87d4b55a120092510d4497831e30826c7c9a70282f4e66a0e1a5e430eb09fb8d41780f771bb46373db1b264e587a8dfd60301ef87800cc23a517861b293292c284ea2ae467d80cb667ab667b7bb84fccb7899c1a85a3b58af4e866e16e8b767feff0ebf9e2fe9b4c4787474adcc7b2b0b58f627fb957cdc7044dd3ad367a3dd9cc28143cbc3a7e3986809547245f0fd64ac6a575629a006d39a4dac486462e922a298350c3b79b746e432b27746a6853adc760fb33c9cb242b6af7377abbb1285b95f68210a6d2175720ccfdfa3c95216bf1a9e7c086e421ba0e64b234146f377c8f5cd85ee9cb81ad7744dd6764abea19c730df8a148ab66f483e2eac7269bf35be59307998c6908c597ca71992d14d1b9c99a341cf7ec44edd4a0aa358a8b9ab0169b76f44eac89410e6e82f0701cf4fc430def3dca0395b3296104217c331af66571eeae786861c154c4074f1d1f7c8fabaa52b61999a11f175401f6d117648e5f479554b4fd313cf0423a0e9e42b6e6b1aa0d973ba95a8b63658df096c12b193c23a2f967d879af89be3ce5ce9f5e8354552b997c2a9b1c6d73f67d171c1871acc69af32810e55866861df9363b08b80fd4340eaf569211f28dc756c7ef346add67c7c4d82d5ca92fb462f58f565fe4d274f9c988e1334988e433875b4d9a87012da05cf026efe761eef4838277de4b8aee3a81b7f595f429686da6a9a8a16008fa18ad87c89f5b29a037f47b0e2d94818d54ed62dd5ff7e65f9e5c36759242ef90fd4c049c6134815a12e0db3025c3bbd7f4bc8a1fd936877b3ab977d0807e24ad5e12191da2a0a823663871d21ddfff9c72b899c1d0ddfa086642b234425f722e163330be23bc97a7dd400a5da715caf3e564066a9e4c186bfd065ebfbbe25d4d744e9f4476ddd7ee9cc3fa4d5d8b929f449fc346abfcdcfac0b5e68773c9f2fcc10db639ce8fa27d08a4a34169186ca1ed6455d0d86a7ccf60c74fcba81acad9441cce7968fbb88aeefa5821b7577f18d1b44e9a864f3cd23ffddf92f7db9e4473801445b8f955d26381aaca61c3a61aa00347f278c4cda2c05702855844114c1624e17c89ea642da8abb99efa701f9191f7dedcb8aa53014c05c9143893c3883091870b6808ed0ed0bbab77ae3c25a8b158977cc816f21a16595186762fbfe21a0a8ecc86602e80cfb0ecaca3a0f71ed4eb073690454971cccf5f85f7e60ac47af498df0176e663bad3ef858e8e1affd491d8aaabb77885d2f7dd833e2179dd908fd2321338240235ad2d2e4ad328d82867518b02e1643f7ebd7dbd681051f069bfa0587f64eccc72cf3887a7ffd09f2d4d3cb560a0ec0e34f4dc5e71b08e38819b46d620a1774d73cd02a972b40a72e4f5fd4a028fc52984d00d7615d948536f282c2feb549134fa72e6cad48ca70f87813e5a66a72aa53e16f23d69939ecab4d96539b0687a51326f8555d3a79ceebd49c28d31b2f50a54bcb110543b3095ba5dfb833efeb28d4fb101b568fb3d62fabf40e000d880e8797f1297448eb9b9796625d3202f785ce9c68867bb6ea7c00834b59ecd0ac1368b9927e0d0a387f8f5ab919cf93d881de23389e9cf126f200bf51bce885ed39cf4a4bd09b5d1a12f98f22ac27042a0902d636a248282bcf0a08fda61ff3a8070086ead1828a55a8b3e08e8e160c59c2d73928e08c34dad17d9d0b25a7913b74042576fbe9ee59d221c6c4ffae55dbc8f979eb8b0c84044c55261543538d3b558c17825ddeeac1ae9a740012cee765c96056348080a1b5e196a9322754dbbe34e8fab70405beada115fcb8f240adaea205c1473ad7db5c300314bf88284301a8a47edd6a1e1d0d2f365a1702adbd01b754312e7fd08f837f00128bfd22c744590ba13b18b4f5d55b4f21fe8e77039bbab1af35dec075ca9363071d5c323fb9770f5bcf2e4821c7c5b771166eec27122c1191723d2a505f61cc8fc5d31f104245fc8fb71484075d7ab712b8ccd2e7e71ee5b606dd0dacdef638e6e1d1b8c2be0d827c490321299761fae897e7f783b3f4f4d06de1a048d2c04c90b2c7cd21589579d8190abcbce45adda13e80c4f2f6c1f21c93107520cea54cbde0a7083ccdafbd164e6e17414c1678974093df365da1909b759a9e6260dc09ecf9e07a4a0ac56b1e2a742c2a06aae6498a5ef7c01da2b9ed4c46046b641933b67a75053fbea39374b9d0d94f0f3b14ebccb85932bf510c504a81d067827a9b46e280f01df1110f6945ee211c4c87459830b3562851641d024bf7ace158b2e9643bfda25445903b7aa43732fe41ed8cefa2c6324ce63b2033b3d0088ec670694d153a7883faff6b54cbf4eaa82759eebac98e025f7340b03b814fa497f45f36cdda9ae38eba44772c56daaf9451d95ba77d5b1f18d4401a741c60b3e91316817bef3aa89a87c4d6d6575f14412120d3d84f1477d26582e10f5890b990d7e777a6f846fa3bbbcb908618266093227f211e36402c8d0bea703aabcd788b67e378bf80b84c3f2a2b1c2ffcf690c3dc3b18eb33421b5fef894628c495b1531a25643459459ff2a2099782414889707e0d8d2963153cad495ac46479e806957d56db744d9761c7d6956f38ca68dfea710550ebeccc1c1977985024d0fec7f4f920000fb6b89e0ff6cdf0bd7d8a32f98ca7412104d84b469e37ca61ae0221fc33f7fb86d543341ef60d51c2d2b45d32ae02e0bd63389a95f8502974a18909983b8d1daa567a57475fdc2a6274147ca4b85800c8e207f454fb98ce4ef62200985848d62651d3f98bae3fdc8c1278279160d4dfbb07b54c738245c09efb900c59971f7e21cb39cc44f62367a1161d9a9b769ab37ffb3dd008f646fad6e939ed7364ad2c270919dea70b03ffd613a233dba6670c9d75427f600592bb90a18cc178f39695186a81fe385c6a412c9ef380f430877777bd5e01c5470c10c5c29c4cf8200d5f2b8308d7821845276d49e6474de0c6658b5da7eabaee76052243d2b44d72df8f7bb1c81699893f14556e65ef35f56735e8c4fb07160b1318435cfcb5d2ea6f581914d0d6251840d10f14e818fa0b81a306a3ce4d48a9a2e6be30978ec73621146bb25b0f4270f718f1308b77c58f01890465fe2859ac9c5ba9efd2e7ed58349fe4a742b5a7d7657d5d16023c04e853e22e87dd7ce417eff82527cbe6f9f698eb4c1a6eb3f41b5fe877cf36a05906f42fd071c9d36bc03c92907baae5b2ac981f05ff3254a5530d3f5c147e675da5b1b0756b24f12c5776885226d4b6013c8d8e64b3ddef4e97a3d08e75ca441febabb4c9b017de1ca63fbfbd6407845a6c3a7de99d00e44ce9cfca0e6e7ff981fddd7011194a657006295f03692167b49996eb9e7e1d910c5dbe4280338a0668fcdfa66422e15fcbd44d4301722102437f11f624fb432a32a5ee0ba0f51b7e5d60ea82cd6504c6e47d85492d661253d43f0c2ea15c0cebb9e8d4632e7c5d0b88c37e2f64a05fb2fdd9a271825e34a946f2b8f2d7267da1e22ffc52d38da5b1730c02b0a3d503005246a746cfeb80d625f202d79e4e90171bcdeea934275b49a7abd851824a22b8a53e1155832b6b4e90a65d1d0fc3afa0ccfdf6a6fe8626102fbeba6847ff06d1ac9a20cbd444d6b886b20d29cd1bf3db919a20e5ca10616a679cd5e4ab7aae103889ea629b8e2ad1851456471ac1a4e187175cedcf344e4f0ed9a2018916820f7275d5d626d1841ef2bf083c51b6ef4b27adab7701ccde9c37d886f2ca9d58d06df2408eb10cf7bc1b477c7f0d1207b11918cc9f414999b82f778a6e3073236ba2fb69a11b1e1303f90f427b84fc7b6b4eac5293aa7684f805b31f137a6879889c11ce67eeef8f2feffcc32d9ca8ee8aa5cc6f9d21c1f7426bbd0072f105835979446866470537897aa485c817cb24fd0f03361a596870d4ea9bc3ce8ee375ad6f1ce61a15c6236e29b9562dbf0c4bb745ef6ec7ef8485300cc0b3d874e4d53dd7c7b2f760d7910e7ed47adb9978b605a28671e797c7ba91b4855314858686e54bd2b0ef7243bb6bf1e2ebbdc85432a3f2c3538379fa9451732b53c7a21e9b748917363c20bb904cee9bb9953a3df18fa0cbb2f1a5282098d27032522e8690bb5ec48c4f8a942b5da9170428504d61c93fedade5622b5c53fee666395e7d9814ce86ea4cd02b54aea448b1815adefe27d57bfc5f681ebfcb88d96e67978eba0d771223e110addf3919217da726f8447c7ad23aad309df96172d612388a41e2defebaeb2784b22f615ba162bb550d2bbf22f89d66363a25854bd2914a0bbc87e9dc8624508148dcddadeb17e046a7b3d6178ba4b6248d3321b01fb5c7295f6cfd84bb0e5b5e05d0e3ea9e6a6c56d46405e32bd7ea48077a0d16de62193b8545bf12dd6e2db003ec4984d3853b1a7e0a2ec0965137000938e2775f20af86b8fbde30228a283ba09be517dff15cc03362a40ba932663212e5ab8f3cb54ca689788f45f7b4e224d1056d6d81bb139b53b5ca8af53759c236bcdca378ee5b127d012cfe2afdf10e51129908d187f5d5d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
