<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d6fa0e4678a046f8e989126ab738a35359ca88d1b07cf97a416aa13edac0ebae2b541e34b645e1db0a88cafd9810a11dfcb428ca21d3cdaf188c20ac7f6de6cc89e838b629a79da08ac3ace9a2a1d19fa978fecd37c73ee9405012e5ee9a867b75ac3c1345a672847696fa9889de0dee77318993b38cbb8be2d3ea519752058a61d3a38c50434b287bc07ce20879eb84d26c22364b688803184ea4b17bd52ef36b6fc0e7f863aea77ca1c97600cb4e44c8dbe9be90e2f2851268519f49b63478b0b62acb70518f650ac74825f3cc5ccc6caa3a13667c4d7c61021c4664e6e46dbf7cf7c9a46c1c6e5beb9bdeb86f3575205cd41e0f7d83a52a11fa5168da1b3143675b14e8d474021666dc550711f4143d009298b60a0dbb416546ec65cde9a683ffb37ec61a568826036c2291074bc71eaeea876ee11b94a577653a27355f12a15cc2b685af09783feddeb01ecf8c17a300addd9afdf72691e77fd91ff3f8c8d83b3ca8fc3e3ff5add20cc7039d07945d583d3c010159547485b42a45dae2d1ee38716cc7b04acbdaa1bfdcedffc387043b51aecf3e3c20f2cc42cfc5e4bddd459ce6c5da2f28b4149433f25814ae1c0d2842b56be56b554af4d0af151b34b6819f39b21655f1f8a3430612f7d77578167af2630a7552e5f04a98a7b11a7cba77a60acdb3e742aa28bea78e072f385fa71c90dfc1df83b786ca27c1d8e0fb8f8da76c8e1dd21a517c89e7cdb11ad332c619025655ecea2026e825a389bffd4e7948922cfd577e5ef70427f06b0623284ee8b95ddf0523e7bf6824302de8cf71fc371fca6c6993d5994420bd32098e766fc0ae27e8fbfce00cf9445d074b07dbeca90a86f0967daa83fc9432da299549a25ec622989386dbb2dcd0a44a29037fe168d57ed240b1d882d73f6c83abca111b6bec0ecb8620968524d906df2fa6b0b4073a2ef34e246c05e2e52dcb59a1623f871ea6df8a5f6e6d2ba58014f2d550db3ef61c53cff678252c5917b742fd36f663ed6f502a0a7e925294678482e1c2f11429c7652367fa74ba46a585104b332510f7e224f929cec0f08f90ad5dff057ecad7534c91320755ba4f8872f11a83e26a5e932e54e4dcc45b99c6f01be322d9301e461f23a43b94a51cf37fb6d5a872af2351df2add76a261eabcc42f0d8bd079f64c9aaaf9e4342ca407c2e6c5b9bcb151f0f36555f602090cff910cedd0898156c5d2f5d8b67c060b9303957b8db6af7189e39313d375312342955171c7b7ab4f8cf32e9b07864c3161e69d1179b64b311054e4b6b03fe3da749d269d121475d692a8930f464d66a3ac7a62830bc1cd063d7b1dfe13978d37eb9ae73b20e45188e6450bbc99b4cc6f5e9e96a8a6e16f0a9221b45746e6bf660930a347d4a63d7e6438158b30813a907ba6f7ca91c2130cfece4a0de2918038c1a6b5e67d606b888da4d7e5172adbbd1976e6cb9b1691b3b13324009789d241eb1bfc252c0dce2ac5140d3f859bf4c8d176a66a47a24e8327efe41405e42373af63ab29bc1dc760acbf3ff97b2b34ab85c1d8b01746fab24d4e64f8e579d0b6f7c8472ef7b8f2ebdde2bc2126c40ca2da93d523258b02808458e2cdd4bab0037bb0166a2f4a8c1721102b01c28a8aa9101c32386426e7c0457e4263ca2875445a3b7ec23d18e5a8495f5e22834d3a6e7726a8d5eb62cd80ab3a2e2e884257fc3c9c15baa7410838a41a0ad903a0c68e9a4514d15349becb7d1953a588c8ac78be7047648ed45276404feffd6a3ccbbe3369b2596adc25e42956ffee75535822755d0b7bec3615c35c1d9f17ce4544571d3b29ff98bef6a91d8b463daebdf4c741413ab5810bddab8304fd50011dcc928cbd3bfa042a7f709aa0be5299b7f9f9b84103748f60f361edd9cec7d5d5a6dfad5b3197129c6176b7b1a286f6c58c90e6c6fb33ee56533d0e9cd4f9ab4318f12209ce559bf271e040355e3e12c1975f9d3966bf0a62888f1409b722518112619de1362a9a3d13c2d090d95013477c146768aabd2cdadb94a06ec1e9bd5c04f46614e78d547ac05d3beaed7ab8fb0205261d9abd44503a43d990c376626ecdde8b33886dfb8afb891294daadbc689e83c59941876c0ac768f7ee85efd3700d677d1522eebc860431a8875eb5dddc78895956d0adf9365c0deba9e08c8155102d4667d8ca5c16923ed329b744de1dca940076f95d8346e6781148e46a6b20069fd3664b22c4cf3ef5ae5f31c14c75cc416394b5246a878942a36e9cbaaadef9b5d110d04945badeb13dff9dd8efd8d98ea0966cc40fd00962ac97f579ebf59ed8be7f1511517e85d8ea78937efbb12b08947af13bab76de9143132e20a8ed2e11ac807cb623c22d9fbf4fa5bc1c8036f35b55b4c5a5de783fd3ab049883256635194506234524a762d17cf44902e822ea32cfd9fc1edccddfb2c6e705b035ad4c53457212b335a9a270e4a1649f3ea14150b34fb6eac8d90f7e6a59801592aa01774bce754430ebf705d665533a1041d5c5d67d0d72746be71ca456b862e916fcd90fbce5d1057e4af549867cc5ffca78eca268c43bc98360feaa78059bc3d228e61c0e9f02eace654e90670efb5ba780820a4544dbd317c3e1e2c1310092206901fff3f681d81cbd3075308f605a72b0552854f4f60bb9c60561d2ad191db119ed003aceb2cdf740b2797ffeb51d34c4786900ccbfb0ecdc0f70aeccd99598f61066d6db9bdd0fe3d68a1cc3b1b4213ea11c8c154bed9eaabb59eac4f167bd9a81c8c7783b97205157c9ecab25b13a613593fbce4d1d7c6b3e95a556e2247090d85ce54eb06d67af438635e17a666a8cae215414be5031f57eed43d704b0b239739fe6b980337e6ef157058445f06f300353952cb9be4823e7964f1aed19cf1cafaa1c1e5b9a3788b986df0eb1d95d1487fb5e3e3041298e0a4e9a75011847bc6bdf50a38b476485b828cfff78f0eac7c689113f488a70c9e230ddef8822d43ef06fca47973abd1e6da7b83f714d9f411a5929022c346cf937f0eb1409cf4c5ec75bdf1bb9121886b328a88e81962ad9f7a35467448d2769c325f009c7ad32cd6b383ed00119aae0f0226f6a50e6d5fcb38a649dde3719438814a778b9101c168f84ae0f02d2167f76a7188d05cc196e0903fdd152ac0b917e08d0453fceb89ce1f9c8339a26fd6bc0a258ac67212f5d663e96cc5b1d00a28cdf3db2cd1672774ef7e1f6646f1d31d4f6a50d33479c9e8622d8d0806a722e3119a6896b3656c46a7603f7fc397025df204d210163228283d53b5b6c99206c37c8084c592e9fe54953e37aada6e785d8bbf323abcffce28f2ade936bab427b9b198f9d997cdcebf75cc4b20f90aa3995a16be40fb8df04c44e7cb4e7bee7c335a71aa4af9ea96c168401de63c81d119390a69c43ba4faaef9af87bc84fb7827b6cc4fd91f843065fbc5ed5abade8ffcd85fa91f1254f3f16fb1a72ada10d07ac810bf7c5a8f78bba57e03975110c4b29cbe5a6fd5a96982dd8b9c3d4c1a514b076bb3bcca2ec203e946f766ae9ad8d0cd9adacbc0d46559717fd57df4cf7e0fd1636fb36f693275a89dac35561ed7c4dd10e7e865afb277ca0bf029c59296280d1aac48f74556a3aa77f5f28a254178d480ee1adfa44e993201ec5b44fd08ba63f89d19b3455e270ed1e6b301f94e0a121b601ac56071263462300a98532d5d51f7f51db24cd3cd76b9ec0d78b9bcacf4fc34660bd8aa8a4612d74fb8047670af545b83b63af3d18d72072089ca84c53be77cfd7ac1f6217727fd8fd19181f60a674d4cc2a8a51708a87a23ee2fd1a4b901e73f00377b44405adcafac0b3e6ab2ff9e5de4051e5e4cea607b128d93a753572d443cbc185e9a2ef59c65eec889e2517936c6db4efe10e1ccc2175d227014843585cb90892b67cbec5661b7d16e2bb1a48f776f0d2db7af15656dc11f68020fd9d8eac81f4d7c75495d80f2a31ec975915b17cac179072ce2f74310a136f6ff7fb67132933c6a25916cb6676272cc3484f2ab1f290ad38d8521d130652c182293bfc1f77f1e0699ff98ffe23c1346edf84113e9d0c70ef9e2ca8dd17b08c1b4c6209cbae85768b5b6c983e375d058aca7f75ffba0d0233ca26f02e356447d1a3a34cd99f2e6464e88ffe0d7fc6b48d2f9b7dcb69de01188198957b530956e5c6dfb0e3b725f589b5f832022a4a6d9c4da29d9d3e73e5325f88b3e048ecd6d62baff9d869193f47445533de206c888079685fce66da105cc12c3d75b94e90260fb0e4b666d988dafbfa4f954a6d970fe32b7ffa7fef12091eed78421772dbbc5176d4ca3f39d3804cd389bbe907fe2d40857a7a0790aa63e370c06f2bd0ab7ffc894c3562f55397cdc91d686711db6b8509b4ba08c87977722f64d4b19f347b9482991d9906320528b2ef6b8f7da7cae53c0e60d5fc9ffd77ff250d9f0d560efd33a6e33ddc104b4f6c5b5eca37b35d6657c86f120247c1545a46edef93a0db3bb5ea11e25cc6e79db8dbeae0de33383323d64cc3366025a86611504216ee56a7abe611b0e020688802714763129b4546776fa13bb7f3ee2ba6ce1adfc2d64b7df6cd740811199f5e5cb7981f45bd561b6fc8732396a91dc53519cf5c047934fa8fe00ece8b7ee0113e68b984c98108a8f3634f7aa89b242abe85f5c90e43c0fd88779b6103bd1afbe9e4367dbbaf6b10c558cdeec3c25ca3600b42a854c950b51c226b52ef81edf1d746625bda9f3e5190c9bd92554fd27aac1a4536c294385e0ea75152b34ad48048d9095f04f754b0162934d4ab2b535e6bc5578fd764c2964bc434424f4930ff7a1a78e27e1f9ac226164af997c3444684149928d8677639ad5cb305591a3295e9aa86c121ed9babf9bc8ed31374bdcd9ab946986e05ca44bbbd13631ffc0e1525fe4a3fd2c63cc2440a15399101e6d597bebbd5d210ad1dc9256db8ba111f42f743211ce41a1cd4d15167623c24522a779d5fcfacdd83060564e06cb7eec2ce87b7495e6b588c8c20698ae85ad50a210e536e0775a689d34b47cbc768fcccaee327744e183443081cde59bdc3cbfd015ad346f7cca7948c68abbff75e33819bc9034e51539ef6ba77802d7565cbfe2f3f97fde65116edf19bb89aae564421f979675e81266cfecab7b32fd9460b3457b3dd98331bb52703e9c02ae0b854924578ba36bbeed881c0b50ff51e05c004054a7ccfe0b65d66dd8f1bb20bebc156bad48da268a76b7a0d2748e3c33d1b3d335bc50e91a366f8cfb4b805338c819f42ad84b3dafda6018293d6988b4294a6e0b9109b3010acd9cd670956f580f441cc443f049b354aba03f229118198a857c07727dd8286fdf65ab1bb47372b2b02df4c0e3bf881fd9ea5282ca9a50f311834f8b7bd58e1e2a0022912266233f6749c30422e0f6525d091cbb4a5b0b38c71e0619ec9a48d91c5ecf31758eb98e32e3d6f01750391ad92d508fc2579f83777302bd57cbe5ddb047cdab26da4bc6fd179db63b99a5f8fa8f153cbf2122ffd5b42f00164188733a9e2eeba187a5dfd1e2e3a322c4f85034d4e29255dbfc324861cbb91a976f0ec0454bf29ed58f969f2657d36be4a3ec9cc5ab74334410b04169c2540cab0fa052fb23ad7df82b5b5fb0eeb5383f88e8e04e66d24ba56d7938a34b993e05ffd5e8be6036f61e0cfffd42c792fc972ada7573ff7bfa2bf254ee58963339c54438a94031b43dcff52cf3ebb6d54b2176e671e889d5cebafcf77c7671cdd3b48605eb4c7cf423405d43393c2b073efa9cee3b72ddbf2804251bbcd883e2ce9ac1553314d4b3efd7874e71ea80ef838cf2cf73f64108ccc48941f6c4b0ae0489af603ca5106e0311a3d598be58cdfed8491bb24f365c37f49e86ef7b62639f6bc10e5642d9104f1f7a3718e25675a878e3de4d78c1396342129a660f118e6e7b49cda8a260d6a50b540df8bac4622381d03cbf3e62a708e1eebf46689af78cca08acf4a2307bc6400aae6e11ea11bc66ce1b5758afc795bc7446f6d894d1ea6db3a37ec77dacf02b4cfddd2b2a3a0962fcdc08cace91ba52aa34c3985c8286bcb39121ebad90f26c1b71fd26a896a56b41fba07e313a2384e4fea823c56a77ecdac77fcd6badf4a64fed32cbf4506d47c17180597d4e0a41d537e3380d2b2a1472482b94f362f1bd99d97188a3c18a17cff164abdb76fb6d9db8483ef54ce9c4f8dd55454a332722c8260c7d3209ae90a628ddc2857a6f46a74813b6af2c590840c9b663731b329259498f904c0abc82c3d4c5d84d39dffdb150eae0ca182604ce40e50bbc8443d3cb415c35ca7c9398c06a062bd1d54a457a2b394a506a0ca3b841796b25bf1f707e2a4256f5c38a5b7cacbdf9fe890661cb2eda7c638927702e6ee12c61a4d12fab9bb7df7680a22109cf4fa849df936b1158d3238d84e757e2c926d3c42c03139e064f1c3038fe25a11b4ff97d1616c12b2d7fe1c25451f102c5815b93c3de94597eb5b6d657530531be3e6bea305cd184d8b0e5b9b0e5b9a5155eadff32823a24ce3cb1dbff729cda1fce83f2c6f7bebb28f7328094f3b3279bc4d398df209d0b7327a0319367f576160875f6d0d4dbdbc08bdcd575feab95bea3d4324d01064b12bbde022dd878ecd7f4f3ef76d9f7c53cb6a049dbb210458dbf58abc174c1c946aed1b38dfdd4a7a494eeefb64a22e070075995151f07448b01a9f217cf6ebcf86cf3f44f9db12bb46ee6fd63d5ccf965625698b05fe1a65bb29ce33537d6abcf0a489a66c43078b14bae223a46bec4ad4718a29cbd7a01389bdc59e0eb594a91f573b62b52a4f729a4188bade345d5263a186c24994d6ebde9d3f71cc2e7a3b056e88ff12b21af193cea9244550fd996c9d17e59fedf33547cb7df4d5396f8105108725bd61cabc80f197a7db2de8d943bc2777ee37b67bad97b06e92feb5213bbfaba8ce1c8c1a8bfe842d0d740333cb00f00ba8564520d65a7b786e8a06a791303de331a37c57bb70bb969e2014d64a683cbb40596c8d8ab801094e82384f7aa45d9d6dfe96405ce147ef3b1148d4dd5160242dc5b0f8ec05651a987744329bf035a1d85cf44fc6cde7728257429007b3a13dce038cbb20dca3c6bd829c4bfc0cec43b439bc1f7b6bc9a18ba2fdf8517e6ce4a80daea511c3ca253ea9d2bc65798019c54d92555a1e1c853a9914f10d0615db25cad7f6d1d6a8060dbf8ec009b3fabb7fca58d82c5194042787e6350b6a73ecf92b53372908b853c28ff5125df70fe8df3e59aa71f4e0d754cbac935399d6f342d8949ddc70c95ad8e8aa447cd4c6ba29ef7bfea06fd81f99b2389d133b776f424502c2b6b6b7b164e0c0d6d9f5f30ed214e84922ca3838581cafaf176820a6707cd9cc6ac2b1d281b11ff11521a84d64accfc05757051a3df30d7a08704d22df8e350b615b6d78f138980ba9a27946100fb334327e0895b6eee716ac8e54db27dfc1435717525d010b7e6b8509c3d0973f8ee9af3af1603e930279eac98b969f13fa7eda283a862c8d9c2bcaba451881196bdaab10242783dc53f668beb3496f10c7ef9dbb42bce5eb403d2a707a737909179b68713f73cbeaecaa8b562c6a83b778d20bc7813e392d9a9ef010b33dd45ca906ad3581dbad3b6d7590142c19610a2f9881dee852529892fd7fad651a333df0e9b93cdc3573f87b1d0fff23709c4e4113ec23085f033acc279aa3b7ac7093b7bed0bb33d6eada72598d5f268ebed88d11309f96186d6642809d44d2dd5faa13fd82a82b97085668a0b5376c801edf98ae57f1ac29ec6e2de42a83d7532b9416eb58c080aff09847c5cbeb10b6714bb87b77672a24dda147932e2b0e7c9caa6f6e4a247029fc878582273787be6db8527010faa6e81e67878ecfb7f677f2ac6a25fa4a3a5dd737902ae812534e7bf5e8a745d49c513df95617d318c44ab1389bfa7196c4deac610fe953e2d3e57349fe1a1a4a7738966b42e8eff1ce5a6eaf401ea1ef12b0448f07466e8b9bbf065b335ae7fc64a4c71400f0fa09794ce9d37ba6982d4c7d300a586ad74d66bf9cdf647102dee15d5290d44c7b2cb83b2569a254e83cee38fa9c0eb5f085d7811edb27c875e37a800a22fa50d886e98fdb58da128234f715191711de091b627bbe0bbfc54fac6963c59a339dda9523cfca8507600d2f8346bb18691f4c5e554f2780046458a0328b332187871640cc40887765e86e58c68900c6874e2da23fcc4b8782e8bcddf54530d23591e4b536804134a3936aea52a55dd80a7978cdd92bdf246167d82359264f1914192341c5ba54802cf69d1726dbd4ea4ae0d40f4b6e4bbd8c6b4d69a348c0d2398c2c4f35576fa613e471332f0d0dbd3678863bb1002eb69b7adf6cac47517682d599f2fad84232be7e23e43947cb7b4adcfcc5a1cea8895930c5dac76df8b7a69a5f0cf98b52079d358368f377552c7e16e5efdf63886be46086b2d317fdd7caf0dfcc8c4c1e30661054e8476eaad107e986080e4b0df5469a67fa3c7be6557bfa6fa40eb8bdc8cfb171c02f1b7d272b9e0a9bddff41761a889b3365cc96d44631aadafaf41dba790d8aefb7393f9bf5846a6ecd056d07ac5cb3bd316763c7a85393b5bd68c2773fed12533566294963dc5019426069c78ad67c9d25121f1ea9aa47157104d321110149003356748382d5471377aef9f40a8cb538a6f6edffaecdf42ecb91435db1051d12d2ac0a7488dc38e91763ef23ac89b5a7377e35a2eceae7a01df84aa406d202801d4ae3d3d2bb3c319a7ba658e090740724db6feee54372012a630817e12ae11fad2a3cfec0f590f2cd676fe968bf8be5923bc68bf5d55beb8e23842ba6dc223c3f14265a1133092c87f36f83361858fcaebcd6a3f830185475a96d730182d165316d9deb43889a195bd84383961c047e3b5fa6919d6c66734105c7b6457f009f03a5737188147fe21fa5ac0c397e2f9bd885c1c56107ece48bf1b6a9c97803fc8a4206be74fc8916db26597baee99dcf6e9356c29d6b061653ccf7294906ed2ed13ec2a6380bfed63752088827f1ae89a94a0b8295f50a557e2821f8162a9eb89e04d1e63abc29e80fb0ba0723cac019aee24c371c1a7c19f08ebaa2ebd92725c00b217274febd4836ff0ff7b476db8b57fb72323f43a03361ddc0ce2fc8ebc9fb6ed4de40c7736350be0b200eda370b5b725c59b8faf75490e3b1c272cf85e3fcd42409a076723be070361f82b4cad7029f4f1421a2b03ad53f6ac8f3e7f2c7800288d108d5ecec19e746ba8a2a6e89c43fb861f964f4a96b13d545d667a650fd6e07c2d192ca3fc42e2e0754b2ee3d84da6992911b13c3e359b08507e63360a7358ec1d065723d47da8e3d0323eb67c5e4435bbd486f60debbe68cae4a05e19396c60fa95e71af544e7ae9461460937a9dafe92be3affb15520126ed6a54632807515e50cf6bffea0dcc97a318aad6403f0fe15ba82275c290a7be42687f21358a9c3882f45eff1c7477cf3e710b7444aec4b1e9af590b532857045ae522801daa0ca5640ff9cad4bf7991c4b391a2ede05ee87136276414fb2d5c884c5d78f824d4b5f9a6743224688ffec966d8ce09afaab75b28eff597a4024b7f3e8d2ef9167a9cfe1007fd0d4a6d22fd43fc53b3b9f504491e275c483feb3fa633cfcbcfd3aad7c8d0490592756e9e143ec90eb666967f25cefb47a280088cd1625ddf03c910466b3d7f999e29f91b97d403073c1eaf86dc0c3d3133bb4fed14f6084833e1711abed7948e4b02c1ac77ba86f639b62f15830ac4286e0f881f3b29ab6cf09bf990f6d03159e1c59e60d38f8e6b122bc8871b3f8d4b12db155d958f515cd0b34ae3c68581e7bd1bb716f3239198c0efcc16706786614964ffe7f98edf3e8a09f0d87b1d1fbf50018af25f5c3db3a2a5b77ffb36b02c9eb9fbff8deef0f3aa82eea8b71a94a6513860be43b7aec691704fd1b1d0def7237a6ca392a6ebf4e10c283114b893c01704d1f7a8a3bb2a00027ec44643dbf495518bd82e18fe06063c40a98ce5df36891d8dbb75b30b02d3271538fe79fff7c1e18c863565f27b67a60e9e0407bd3aa83bfb6a711e48e2e991f643bf415b56c201e715a93f27253e4dad82a9afba0d6720746dd9a7372d7776ef489f42b763ed016823f1b828f2ca56ad3197251d2ff4103aef3c53057b18bef724a0f58e1db83289ce1ada6c965df0e3d8ec447d0668175310fef89984911d865511ae3e96398f83633fcc0f6266010042167398a2d0a883617659ab58afc7dffa821e0a9ccd220fda7be1438f04956aa0549337a20490a47ea9381844b1dd868f7a3771205f20fb803f1ee739f18ae928619c9b0097798dbab2232fc2e4acd6e57ed05382e378e986eb8c162fefde2714d50ec062e03afacd2ccb34058f4e161be7f02696fe114db76e82d67b0605caa39ffc64506489fe8e1c3cfa9b98f0f47fcbf388039524222fa6c2ea8dbc0fbd39b71faef886b0f0a5a1a030efa13ee0763d53f0c9689e9ceb83ab1d3711fb0c9441e4c0f83dee4b88fdf9dc22167900828ee03a13c650db80fc896058d7cf0ced5aae143fe6c71105cad40cc5c865c89cd675c3d219d1ce02f3c03b2ab81387c3bbe876685f7d57fa4befad41bb8f9601d118de90df16e6027c3be0c916a6dff0b8389e51f94f460303d9bdfdb5befed53f743853939336825f45c75640daea537c3f5d19439d19e2ee06e609d4ac70920fe0dc1ae507aff2290b2c9d6196dba1c1243ca7cd16d0e63d00132cde7530b365b100e2efe3f624299fe44c86e9ba0a72192aa1f592446ce3d761f09b45559d3be31930f653f7166e5adc1ab20c2151557df0cd008c989b72b898c16ab31516d68c95f0e4b7a15731e0d35afef9a5c8a920a57b3f5487f02f6c6a5b18c88d0f1ce407a7fcf43b84e260e8b50f944d5526697c82cb37cd046693a7afa0796929f799c610e855c00f52bda07a744d276e1e94297f2a3868a40c80d330c0b8c4d3b2ebec4f77615630ca68e4e35186b3ef310a91276b84bb7b7dc01570ea34aa022efff91699da10df6cf88d671080f82d2e369450316c1d924e2e69cd8f803599817fdca58419ae8cbab52d3f91052a0968540eda89926500c9364809b904e6f0c6195042de4acc3afbc82c8414722f951fa3517a69377f5f7ed36e93949efd96c98fa441dc6068e677aa30fdc9648999f10058c5078c46693c4f82d44ab7b6e0e022632897da530e8bc3eca0569383800c3a7e9ad1b479937b39052439fc877706762a3dd77838ba589f7d09e78353edb882cb967c50298e06073105429893504641e98a5a955d5bfdbebe790b81a77e161b61b3730a486ddd60644731234ce818d07be79dfe143fcf879b1f66e30005b36f43e62f83acb128d85af4045c65eaec4429be4daebac42bf1dd753ce137bc74f066fc71d246947d26fa31c75df030d587cb5678ebf8225575050ad9f23cffbf30cf874de7b4ed6b4d87fc9c9623b31e454dd99709765c8e3dd6447e5362e3c0fb9dd30bdca7e3938037f09818c5827aa6f25de94e761aad68b21b682bcfc25d546555f269ed71b41e546ff520641a20180651ca5c74feab229c6e08e6e0a8870b2ff696aad379e3a446b1f471fc015fd90967012cb63c93121c95a8c5d5eaa4bdb501e16575895c527c81726275c073c29288fe9a3f959376525cfcec5eda26ccb9c0aec50b9ca12b9e34535073ed0cdfeaa86ff82fea0ee3d1ca353e6f46693984633719f9ed5bbdbeda75a689170a8c996b3d3bebd71d77fc66799c1270583900af29a54022f18e1550801c7018f4d8e67439d01f3c3c614fc07e62c428593677dcb118071223aec9ad108bd6c519cf0af3f5c687dfe1aa06b273158dd2d80ede8493fe7543afebaa045eefd90e87e696e17224c3962949aefa63482db3385245f907bc0b81e2a8490a58ea1369347c79b9f9cda3b8a92ade8bfa24f1963aade64863229efa622bbd44a413ceb7298474606f8ee896b7db212e9c995e304e41a145f7f269a5768dda4404e6907b82aa4980d21f1009de9b16cf783ee460942082070e15c339d9c5c3cd7fd7cea44b657d3f8741cc5c9e107d9af5344a4819952c1780526957e21c719e744c0863ef824ed59d0e9a6c55e272fdc42f2466b1ac6968e539cb8a844f4e7e94c01585f47e0193711b76a0d47571d0332b0731347284d2daf0020b3b9a3ea8d1295abda2000ec429fc2365a3fa9206abbb82b33cc5464ab0af065f997fbc152b0543e0f2e76a3b261a93ef8a9f53c488a2df5d456da7a7af2e39df6fd09af26d72e052e4531cc82456d011b4ffa9615fc1a491dedd43689fdcc1e2e4e742130731ddc873cbdafb3c950850027722e5c75d757a40d654883ab64e8bb2a2c216909013d5d43d2e43d5c94d5f4c459079fe510ce16ce7c5e939b133ebe602819f415b03edff1301820bd6e4e0a84864c29941503fe4115d79e8fb8184efdee508575454477b86e48d415b588c673b36a2b5e34d5e021847d5b410611ce5fc15c5fddcadfcb65af7968fb9776ec5dc9800c5d779f8866bf9fcce9030912c2059e3f7feac48bb7a660e5bc75f3fc23c3b9c69faa7888b5a8a3c165b5756e03d262691837d0ea7f236640a900ee3d4e8c7af30c794d3024a0d79ee88a62e8b8067a623c4e93d3b3f55c64e97f0cc8681c25beece905a3c4a600d47a75c6b83f30f5f3cc7f03ae26e0853d67763a2437d38030a09a09d3d740ce874ac492872037bc0a03bed91d0652f571810555fbe0ae73fe9ca4aedeca3c956dfc18b96ae48b4badca8cf74b9ea6f8c0000587b1b68bba20d4f49ded229ed33b419c3567a7b78fd5919a9d886796029ef08f36d7c07f62286ebdf541da93cf9bd37364df9f44d9c96a47b3df706139a8957cf0f9a54350c9ced7269d1c0acb510b2a3ebc562adc106a97b100b8602bd79630bd2ed2cdd729da5668389373604a3e20452552858a3fa3d95cec31288b866df835f56377e8b4d96833a1f4092daff5bba35f51d7ddaab7d14bdd4fe790988bc94d7fa8b930bedb42b92e657ac595d44931eccced55102ded2d20802cf99d5904c48843e9534ac1fd239637122e168bff8986f83cf1c16e2c2ffd9d3248fc2ad4e147b8c225534229f3eb5fc1d3478e6e3257933e30695516d716b53b3db6646ccf0182f8c365c7fc78e43566fbc49afa0d42dead526769202f6a1344bd105d39b81069c69e1bc78bbcdf6aa266c4c11752da2d20fe5df0f12cba03ba14b97d799406950dc616f84e7365887e1dd0bbf8799aa8c741675943a7a32e5c72a06dea70b0699246d453a8cacd743b24821cd9585b580f4d6ef5da9a325d216bb82a5b25a49c0288ccd2b943011eec68759aacc0a7a8ea3ece74afcf16f67f967808113d61323d4630caf8ccacd1f0b0d0ba47b36fc5be0bd9b6194aba91857fa677dd4a1bff216f7ae1bb43967bc073cbdbfec5ea83747a5c1346e7fd94126d0ad72b52b55607eb14448618f5ea614018079d3721a1d7c28d7ff9be8be16f76b500219f42534a016dae6ba68830cbdf522f134ea53cff5118af01d2b00578e2e75844885fc0356ff32903b53951f368793a9013afab40ed5fd2e1422eeeb4a025bdeaa9ad47e3c2508f9f6d1e2e919e9be6b0fc12c6407c5a7a5bb77a856101b56e42d961136f45e8218faabcba66a68293727d2f8fa8b270e92f3914c1d42eb08ef5a3f8db9a60e942d7ce35aba04b19af3237c7aa49860fef009849ab793cc0314bbbd8994c5c29c5ce365e617cf0c69101c22e1b9050475f949b64e58bafdb2a8e453f846444cb02903e4acb72c5dd1f953593090a0fe31b676a2e61fc40937bcbd504bd119be0d1f0d7598316d74ea3361b1613dbb9c7cf8540ff177f56377c50929a05f8d615a00f5c61d3a80897582098df29b9b8f73572920ccc8d6b2facbb1c9faf1d0c130cfca2d8146762fa9348a3150c083500bb4b89da894b868cc85eaeacb322f9d135fe1156fd6c6bca25ea7ab9e840d0a36bbafbb5268ac1e4b5899d33c71f445271a05a7494313b3eaaf5b0af0ba0cfb88d24f22bdeb43e2c54db490b489ab1c144f7ffd06f531147dfcf0762307208feec11fe04a14ef5868584e711bf8578365a343235a6eb3021efa83713988af10207f6f211a37da5bd6b991819bb6489582280dada1521973316b79781b01e067a04ad2999b869422c7e6480b252611045dec260a13839d14f3a507f7a59fb045e15ce5e5d024beccda8cdbbba5d48a5eaf9244722848bbb19708c167329e807a20d58837168d5afd2142bfb4f4176fb5d56979dfe00ff66261f5163d8963d4da89bbad5be15077786dae48e3e49ec035291233ae7bcc38224702b5a722eb45aec681fd836598f794ee99331e158586f130f73f959040ae53e2bb6ca3b170a1b1acbba5bba8461cb4a99a7fce0e2a601bbdcf59763e4c64c81b6c804475918a77823f816ada42b870c88bc98ae08569e4ca88d1cf38a0f8f9d1a126ff7fdbb9c37cc47f4bf0b8ea185164151634c662d563c32f8d68fddb84ff0b4166c7b90e3e7acef8f86cab8622ab6231977f650138f0498e58e36887b262ef0331c6f9e4b5a118807ad99b878f1562d34a7b3bc7db1f703317c9d8224cca4415a84c87f09e855fce970dab12f4e17c98e38bbd479530e4a5ebba4c1a8038c62a0695bb6b5536c376298cac8b3ec5027d0152baf722ab5ab9c6969451045ad68d82ee17b0586a2bbc3d8d6748f1b9ce6b0a3540994098eaeb2fd9f6478b2653d6069750898e0c20d84ba101aa64c28eb00417721ec87236a4a89c645cb5fc17af7ab26f3a33d9cfe4d7f157d8c11740cef4aaaadeafd1783d7a5db9236521a6897f695c00f4789ea9316b904e8b902e14c8f5ce064d3d70ff9a61d53fab3b1f974197a5a27d4b95e68856da28f55945ddf22bdc3bf4d6ea60cf39f2b61ef3846fb5411d4754a8f0fad0a02400fa343ecac75cc61a8ef1609a04dc406b5f4ac5818c9f41700678624a6b2a214f95f144f2e8ce312079156289407a09ccf0f9874","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
