<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c11027cad839cd9ef30a18546e58d4ee397f523dbee811ede2c32a2235e38ae1ecf73ea67f51fed8d5c5786b1a7115a26d83a44ea69b1c2438d5ecaa4d9e832cc2fcadc0dcfddf4a8533d9102c7db27e57a17160c65b5cc18f601547c619630263a9e1377d58901494cd3233b22b7e054e8c3936857cc3b52c0bf6ec5385e137f8932277c2a902f6adb1a57e9a2366bfbb70550f68a77c5cea9df84da70b9e93c628cb88488d2585dc0559b71ce23068e7ebe8cb00dc181fe1bc783980266e7018193f5b8521e74ac03429a2b577db89ba41d570a229c332aec9f2e10a4390b4bc902a86068df215c832fbcbbdd7df8ce970319a1a658bc9b9baff58a5a89c39b583d939ec0b2d5d6daaecd9e74eafa4b6d71bb9087bf324d7c892715473b0c71d242a052f12b8eeb55f6b719b11332fdbbf073259d0697b1960f920c289eb8ed0eb2ad862f7e54373c884f81a64982edfcc093973552f0006b40a123f871053775bc026c7e09a9e8aa91c2e2db4c652a2e94c2944e82f273f3cc838a5a5642ecd6d8baa80c8a7869ddac87a4c8dbaebfe9e2b06d4523f226a498fbf973610f210b4d3f6bdcc61a63543335c79b6e91d4678d6c4589ef6a781eda2cf686d008267765d8c0fdc069f21d43c5f71ff61d2bebd03a36780d2f95f281a57011f6d97337d0a67a8e9901d8c7ad5441ff58dcee6764eb865da77cb287a5e634b23d82d373bea3e9694609db73f4a47f0329fc4968146644e45f6dcc2aa426bc345def79ed6738c59802b2fd6f06811a0db80c6f711c1e17d64f4de0e3ac6d9fcd2579e6740e133661db2cd9f8c3aadf3c069e3896a47405d0725f0444f7ee135a25cd84b2ddf04592cf7e3c4e30b1cdcbffad493e7d0191a94522cf49f90d89efb457691323f4d54eac8aff763f5b8a2bc136c62e65df836d911422826ddf56640000688f63aac9fd5f0d5ae2f18278d068cce830a44ca9c075efe6925ecfa0fc5693b026c7d104996ef3e26c73e7093d65d0403f1adb953aaa4f283191b75945e3f0f620d6210a13068103d5705e25dfa5e040ed431b2cec76f92c6f8e9c9ef5158f6db04a0bbefc595c2ea7a52d02cb318fc49c57e522c18f8fe44fa64af8237af4d108bbab94a43b500bc08a494473238b3202dc2efcf11968dddb4edb83e2bb3a8356450bd49e25396c61ddc178bbc3963d8777142ab87917bc7dcdb894aea2a4970858cc7866fa6bb912b5728448de4af9c4523cd7c5bc16aefd5147619472b6b330ccd31b4b4b519f534c69334f449bd62495383c11f8cb5eba8ed2e55327ee5d70d8756880a85f61882686577608b18654b1eb50fe6a8854d973e49d873492db354224924703d80a3e7e2f49057d110660be463e869687aa3b8f2a8da43cc1537e1360032dd96d43cfeb20951bc6b73d2bb809cfd04163a4904bc2d3d7609f455023e5a7bb05005691fc11f46f5874e2ab628db6e09866eda41f6e8ac6a6e6a9fee4d29b3431ee68dbabe5036cac488c647b120375a5fa76f64b52ece518cdeb782d74b6b59a6cad4ffb9ffa8890fcd1528dbac9a0661438c2cee7644590293740444d345d4368055c57078c81e9fc2f7c174d09560123f82d0932cd936c7903bbcd65b984b73a8c03f2326fe0237c707faa478f43fdd26b6ced39ecc3fe2be5beaecdbcfc32c0537f83b81e977191296f7d4e25762f6d30c35e03c5bd43e6a1be5cbd033f4fa9b09214601deba2a446e331791e5a79ed98f26cd84182635c10db84f1d1f8156aa98b2b77b41efe4b492d7a2fd5f5054d8b2da06a6cc2f5bf938b658ec27b90ee046a8f72a898130d08b0c8d46f9fd9333f4abb733ccd2ad21c6973411f550e10b48b9a48061b1de864dc6fdc9d22339c2ee1a8a3ff7065a9f0bb567fdd70644cd8f002fb4b8f99e22a7d65abe84806e91e308b1972caab07a23f39e42b3c1467afa155e2d8e43123ee937a4ab34cbd3e41bade0e9eaacd5f23b928e2f3b631003737d98782129fba2927aefc67dfe0f2149ee2d45b1cc3f71fe86ef2073ebc8cc0009db1dacf8d783b1ddf8ec6b44c40e1564038b56fb12ba932522c78ee3e97481b9bc20acdfd67c1296bc978fc1404ce5b5ab07e8dae3bf92c1db43f40f2e9a0742db084a8d01dcb019421423da726027df9210cf7590b4ddb33bd792feec80dbfe69f6ef8b8bcf3fe64d046d58d52410b6130ff17a70f56391219ad4d662d9ea8602999b851b9fcda55539398601fd1b7a248af7eace2fe6b15b37ae2312c29716b33c3ed14f33548e109a855a0023e02ace9cbad28d02306d3423f9b85f1d60f0d0e95bcb152f2e990d93855eb29f8f14b900d5ef9e7c9a30bce5fcefca7f31b28e446b591ab5d8a03d93dd117f96c67e78a64b718b065428183ad27b9350e15f959355126d7a4d29c1bb5209a1e7c6e6ebc4eba0dd6a885f9efefd8a9636f4d3866d332e9cba41e1f90a15763ab6d0cd01e79fd719529f3ea6aabc215420458b3953444102b267a3366cf3f7defa86152f6c7ffcd221545d36bc4baa77a9e48cf7885980428050e8aa57f8c07366af334be3b7456ee1ab2db5a092da76c3cabc14de7b0ec48c25b260f455de93cf0ebcffad20831c7b7b9f03d25b06c37473f4f82c3afbe768cec93d5518f75b42d029e6294e4f07952d6f2c79ba84e8813fe3c9e68077eb9c462c1d1374038f62ea963b8c34baa919f42521a21615e8f09f7a90513bc63f08dea0f0d1d1403837fe2f3873a0ed98c7969d9097bfa4acecb254ef6e7b8ef2f36974e73f8f714faf3a7498524d4d841f4cf7e0d00b8c9a6db6400df491e98225f64060957d874f4b29d8682b0287c2c98ba84c9043e863343644bde5475ac3ee9555fc11f2ae53f96545f577927b85047198f6dfb9dc75d0decf019ecf7e76b535539ec7c3af684d77728ea491eea15428e9416929ffae6224446665e7cebfb285bd2813b5c4fe9cce1a80832f03a4384aa7302138e5bde379bf27237c8af6f200caae4408934fa16e964667e7015903f74eaa75360a74ab61689ef059989cc0142b0c6bf6313fb4283370431d9f8d7a7551b883a5250e3391da7f9a0e289e3fcab4ab8a3d987966371af6b3e9ff2cb3fc13fe886b6a4c0f15f635392a180f54f720a7780187744d3e79d8745714e03215e8eba22f19d57de9103ffe6322773a9fd91b2b09fc4c6f92da587cdc09270d209420531f18d025d6244ca3105df53761efade6dced0b66593b00508ba0d3fd5adb2ebf97d72779fa1618802dae3ac4c38183845445c56fa88e380633ae060b169a421d79a182194e7f932f294fe79c9256fbea502cb631c42f9f9f6034bcf5a142a9650a1ea502f2235d7b060e3a9143f2ad092d63f55bb18bdb4aaba3468437cce427c42a9d75fc50efcfb5f46930bf4f4161a3adf19e9cd26537ab6cfce3f1e03cd72367f2975cdcc1c5592a419ddc2473bced77457560c49c2bd430990cd65de88c6180336b8ffb06d70b7ad05c84e8e78798daaf38cf88cf3e98d2d590e1b10d65d7734de55c05e889f72180f4b1943d16bc4a171269cb0dbac5debcc6522fcf26c9d3a66ecb21852222e7a515b4f18865d532d6e0bea8e33e89ab47c57abe54d3742207a04a7e539b6f3bbcf091b0bae189943a062f2753d9e3037667b67902f49b8e9325840b50f2deb9063d481a05c259e3a885db895d308b65d74c419a93a2645f69815ff36b10456cbacf257ae2fca279622785cc424174974bed2bd90fd43adc1c8c6e05a7a185b79f6a4b41abaaea6bd78a64f36e0bd601c4dfaf505fda02a8e16bad0faed0e2e22017d6c5eab1c9ebb296e060fd5caed87a85d2bbafa2d5bdd5130f0784412481cea4f808516d0e72739a527822d4e8322b17a7ad0c98f0887aeefbef246430a77cffaef8ee6ab6ca0ca7f00e1ecdbc9b1ce3da7210690e489f1c618ec2709bb6e90317d5a39a68ebcbb587a8fafa84d41c71cda4175fa098c373c148060f2a9f588282fa065c59bab727b2f0e608b4247679c8c117415546bf7e7262de1ab77c7fada50d9aa0d0f45f71cb4da3e72a0196849f8b1118d141c78bf0cced06b90923817878c2ef2b597e530ecd2716455090b835ec7db6ae44b62115a5ad85ddae1b474f2102465f74dc8854922d425d4fb20a64405e568cbddfabf95fa53c83080a9851bf83e81a4d53dbe775bf709cb7eff505a17a44e2f3266536335c2e86cf5ae2f388b38cfddcbf5441455ac40939b98227edb321f46d12ac4e8bcd51e30917413a1bb5cf258ed1f2bcef6a5968ba6812c01f9bccf5b2f6e0a8d85389d7cf4fb1ba2f78c06a7fc9e52da3a206d2c583a0b58fe271ece7c0166195ae84aa770572f55cc810381fe61f844c7e5543de76721dbc5b58affb845dc38b5bb4474486024190ea4f68c4e71ac004d4b7cdd45c843ff0abbdfbc753825d84a77ed56456d719980feef730f2d7cd70b0bfce72d1369571914acfbba1097db9e075e28d512e9a5feda78649034206b2dd2a91d347c08b27520f348646b6b5f302a12b63dc72dea0b2c9958d1b7173dd5cdcca721b7b9ab068d3f81fa7eeee949fb5ceb25af82f1a6373344f802c40b0e2888c96b9d77b71e37d02fa6af8e1a0d4ed87990f56b7f963ff760815aa9fb0becee78366d6c975e612e252d100ec4e8b4b73937cd764621f4cb03bb2899ed480f5d510091e3dcd43b829efc0ebd2f95ec9b47428609e0442cd856b0e8f9e3e214d6d350847ccd6015a61480b55952214e4f0c6cd75a07173c3a7ebd5468ac6b5ad828757ff67c1b1dc3f2942068e054b83c53fbbc63b6117d390ca183c778cd97b181ee0051b22e66cdc9be3bf67b5ab82cf6eca234add47d86fa98ef26d3bc6c85cf44b87c4daa85d84f62e2b87f68eb809bc07b3528d0e6adc4318adac6d4a877523a10474e119dbfcb3f6ceb1554356b4787764cc9e3a54ca3408a09ccca21f3a857160038cbf94fbedd7e6bfefe741302ef466274b3e803c8ff2913db739232cc17404f8480eac837f3c6af637abd1d680fdb0fc0408e07525eabb9d4483b03f3c82a79b931e218108e022348c30f627c7635d830094cc8c35321c835d765d019b60df7d98081e0c8d1b60bc4d6a62f1f1f09b6d3816a68d5c069781370e22143593c87d353a9e73adac411fc0333cef37a26ebf42c35d9e26b2b9a77bdc80b79a535c02cb0e30379dd415b40a502fc72bc8fa62482962399a2e89d660bc91f1a540ec0269481f84740685ef2bd87beff2d714e3c4d5855dd2672d2d834b90e6b97c5ed7a1fe8f4c9384e6e300574eb35ea69a4537c4742881b525f910a0924b8a2087893d0e90d297f228ea44c3396956cb0a523b8e607bea7be552bebccf427f6724899e4c7fcd5be42765f8a87fd3a21844f8fd5ada42b5a32714ca4012a7b034111fe8d2db2679fb78350feb1969c7092684b8faf7f3f179fd6787d7746a063c1c955735f082206e762a266d2fd2372b9f8a085b0a66c825fa4c904f2bcc18319110eedf21f32bf513faf7838cb0b7419f0c543f01e0313cbe6d9e189cf60de8333896c693e2d664ba11e9ed8acc5983c65d1f29688984a270c1fac1ffdafdb6d608f53f3dda808b83dc33f5b833ad00dfdd578efdc2a4b8f6ee91ed85357a89c400bfa7cf25b4ab0906279bc367b3b843e305a8baa42d466f2e83da25647cba28d87b913b3ab5b15de41c38aca9c96ee5839d039a9a870e7da5e6aa12e496ac524c9fb856c3f5e3ae651248071ca0f39e3f4fe8b4ae8d64319ef0e0b02fcb718615a248bc0e2332a137f19d14509879d9486515a1091b07d44160b34d7e95120f82ceac3abbb5f2bab8168b326c5a40085e9e74179ec6cf35b095bbf84651cecdfe8644397a63dba3a490cd3d2161dd373d4200d7ed348bbd975de9d4df9d7949fd1cdf904db22c4df828616fa5d76ad648324f2010604f5575821dbbd741c71b6bb94ae031a4bdd3cb3995d128caade5511dfc6298747c7f63c2ae030cae3612bf36a9c9d2eabdb835859f3b746fdb637f0e83cb9f8a569535ce38bd2561a888d5cc5a5cb75fd465307a461909992e586ea04f4d4eb16097307b16ffcc76b8811e5f3c7175598bb10d01ff8c9132f74ac2795e9d6e963f31a42b34c4f7c8b2476a1af9c25aed00b9b9e93ef21804a6fc639ab31cf5ab2ec21978d2f153f7c822744e1c2a88f58872de50601949578f5c7081c4dd5f74ae1f624861edcaa56dae1eae941f195fa5bc438dbab8a349d566da0c14a3fe5dc56062d3c8ecc5767f0643616c9f0daf485dc0cc8af565b46d973de335a0dbacfea15411a0992a4bf29cb2d4c77d31f19e2548b3f61a4986aea70c7ebbf33fa46536c821aacb34e3ca1963b4bcd4eaa014869b187cc9542122e33e685362eb48399cad8c5b2277875d1071bf175850d1bdd4db2cde45ea5d4feb54359eea9124bdb8c723544bda2cfb0d6944a5fe31dbfa0e568747341a21efae43a9b1192b03b85951893f42472e5c68b19720f93f76aec1fcfb98493fc98d26a0b13a5ad00df6b28b086ac587808db03514c5eac58807ad1df78998e9d0c78a59913853230237fa57a8641d6a8ddd2c9782bc44cd655ffaa36a165567cf4ff72e51995503a79725ce5004adbc21246bcfb3614d3fc4393d8a1d53ace8893e5f285f3eef2e930874e0ff7949897c0306aec706fe6788bbbe6f45ede35afc2b9a1f3c79055f19e9924150c92e6b1b5e48feb0d80514be6a8aa62ae221dcc7c945a75810d9313598ab4c9d985440072bd10d17db5131aace36a78e6a4061183be9b898cda8fb174607b18462187c5b34d02351220b8111b2573f53411ee7ddd781c74083b1d80ce6ef0c91b55eca24ce081e186bb765b27607efad55dfeb7c7072d2794aed4b3d5f56542420a86788869d00364598e324e943af39484dd80a0f0723e207888bb54c191b10c678233d79f14caf88ec47dd8cd5292da56652a4215b37e155970c975ec483f302042bd1949c1691c4be0f5a7edfba52e818bda62f0f3386695fa8bef81aa2c8c7d0dabc3dd7d7693307bf6ee01a9c15209d7194a14aec305ef0edc0ef500f4a56066fcedf9b095417482e8b5604f816e5b900e97acea6f3d133b0ac996f807f10047431bcb4f58d3ea45d531b8f8b4c2d61285a8f41b2f59b4c4b6452499864c4ac9d4aacfaf650be675d2b08743cbee92eeeb0546de7330ad914c83a1ff449baf45a13c477535b69effcae0552658ea48d1e22fd4784f571977bcecee597d3b98962a8208fa3b24178c9c3e08b3d7cd71d3a9b30817800a75d9904a878a54b5f89083ccd2503d123652f9e97ce0dc3d1c223f5a7064583db6f1dcadbaae60c2a52296378a6c468cc7fa22dd7a57cd5bfcb8fadf76a89b2b9b0bf1ab7966b3927ddc99899fc74476b28254a8cefc00893808f7198eafdc9431b618c9108b3fd967cf2f1b538e3e43d48b9034b75d96c020cf20d67fe5bf4534adac33e9a176eac88850921b982d1a4d013174b42313b3a4d0baec5e537d86deb32c3e1dcd80b56773b9ec066224e0715c9daa813371577961fa0344689c4315f7c0826eef9cfb49367238595c8fc8876fe97049d0a0d70df2aea934c0cac81213653feb607e80d6bc8820b0d6751461376a0077f28180573ce5e18a4b90bce2aaffd124e12974212cecee69468525ef3dea641e4f5612766a3c36f88697b095dac25b56149f496883fa64c6e594126b86910653b8a8943e0e22d6ffb28629940b9822de08c3281a97111d627d01930414aa8627302b52546fcbbfaa76c93be361fd680e4662ac5ed6d7209c079ba82c753cabf94ca63d540b01b64be5e735e9be266b796bc7d4f34562df2824c6d0c4f5d7881023058ee29ad504597e6030e6b8326977cf78a519235f8339de44c58b8235d760b21cee7060aee2e0463dbdf3f14a97e94635e5022d5403470f557c0cac347843efe3d40bb3dc1950a02d5ea6361dadab31fe844225f6b2eb548456283bbbe0c0cb38b8ec623b848e2bd7c67b07bc4ee3ca868c3f5ffc138545a7940c151a10a2f0d0bb559f84add0d0f205c080d4d35986a74c1adef545c5b936a85b4d4a2564630d36587841290fee5883df8945591e263a143d1c36dc55a428a69d4b0819042fe550399c43a49e76e780306f9219dcbc4aee0af2a3a78a058e7d2722b860703ad33be6a218711fb1e47f57bc81502408938d3df35c37495de3ceed3f196bd6c102da46a758f854cb10007981f2f44a729a14af67a9dda8aa972cab1047967b84f8fc5bce1f18c43e70deed69825023714b7798ec49af00910e9bea7f25db7da260dad54bf66fd5f2faf5e7826bc2dfc5d9e40e830f0944e1371fe0d8da7940953f7b995bffb2c4cf0040a24464df9aea2011bed765268c2f3143191368a901545cbd24ad8f68119d33a9f2070b15ca2e19a8f065eeb0361747caa50fd8dc03c130185f54b71151e6a6b5523d5ba7c3ad3b388ae48064409dac63ee9096d6a147873a7a1f850441aef0337699faf78d7de4fab173f0497cec65c638f11f6182ab7b887f2de42cdd61e04e8c43057ef347202741703def9ac58a037bf2d57f8771c8f20b9d27d15c205d400fb1b34b23523055b0188c264c80a586c1bf3ae177a1e90597df1b24da1b436b707768d6ee1755888d9fa395d29f2fd2f03ba126bd4f5b5584ee8d15d13d8ef96e768577f5f293320e0c4365c85cd36fb0eb582db9ed4804c30d091d331d0b9e87d282fb4d4f4b53428d5d862858f7074748c2fe84233790db9ab158cede4712d83b39a6f16e7c0690068459df5be113ddc755d9e76c355015e793ebab1ebfaa8a7acdc51ac9bb50340ff2e0f3d927514a783bf9effc4eacfe9f2c4bf63d33b8654e7f9bac65ce3e27147b62ff4bdbe067316fa05ee6462aaa26b0dbc63d297d249fa3d5cd77f72c326bdaec112aa39bdffb4468e1d5ef9bc8d9047ad6e86124e6891ffc773629163e60aedbdafc99d19d1c518ac8251e82f55f4b23787a027dfe4f5bd6d6ebe62b20cf6fd5f8bb8a034b2418e716eac146a28d321b78ca889992ed5c415e050696f12a18ae4d01f0bd7faf777dc4c80cf06d2cbad53a14e8491dced73d10f75b763574344112ec2820c5df6a08de6f8cf6c415bbe2783a93455dbb450feb3f7999ef94d041b0faee75030155884c47d4964d2c7a7971c5a46bb810fddeea4503416b88572f8e473e550b6b9623924a3ab46cecf35451c23d9c6033b71b9b8f6d03f701aa44033aea22373d4817cd1dc1d026e2c5b6a0290ffee57c23720c46df4124ad9162fa0418962e071d710cc3eb97f86d765b158f034204ef96a1ec534824c3b35de5beca65a8e0e0d70491d69dc265bbe4d8ebb8428165cb90f688044efbfec062c04c3c77fc123682ce2e66c095d2c35bf4f9392ceff4864c41e62ed151e0460f240ca9e899ae459b4e897bc2413d2faab2084ba50956208c54a4a637cc7c82ff8205aee278b29f30edd5bfbc6f704faf44be16d3061208033086cbd82460156ad19ac5ace9c5dc258953ce44d9c7eb38704834f170b10441206d767bb0fd783052b027aec0c91e54afa19e12606ee77a72edea761a17858da6498c9cabc174f56f0a6858cc3478a2fea18c4d28b91b3d376a81d4afe96a42f80f93ffac38039222bb2bc0b6028262fd2e1bb69cf71d408f00e898fa559e2fd351b8a0801548b0fa49e43ef20f9d4aafe6829ec2161f97c2c2f8d713376050bd9c3499d8a12c05e6606984794f9c66d8730c3cac3e93a65536a9c929760fc0991f7b597ce698b9218255cadfd71bfc05b59d8a0f0ab66aa0eff88a9d541a72f3294f1446a066d09310e4b00850001eb42d07e842c29aaf642bd00202e0b6316746831a73adc328a3b8c46c523189564d98706b316b0a54d56b889bf1fdf2185a19d7d74daab2b5443dc9f0ae60311eb488cf35448a3eacb6988d4f238d2c2b0f1ebe33c1a3d408a7052338b41cbfc7671069a59aaf2f4d293803116f779fa996dc88d0c046baf5f9a95a8e5ddce28415d02307b2bff19fe64188f07ebf708669f6620da150f12cb31eb9074f2ba083ef4b0d40d063306f84d5bda327f18e145bc498fdc86af1509670edcc6e934143d92d4e45449af63b0a9b0b5f26600b658b2fc89f3f9aa21ea75854ef0c17ba34a440d9cb119f76788cee2da88db97463cda9eafec706557a3b3adb76299311319e92a7861fc3d266e301ff0847bd56e0cb01809d8f02b467fa3b161a35e27642be030443aa73ab135f9421c9b89c558c5c9c5546e62731f1bed4f671e28fcb913681fac2c705844fb5618647743eb06fcb4ecfef05595b5995090e6b7e0df55090fa8faca556f309cf62d3a97f1f91ca0931a8eb4df5b5db78626bbe04575eaa3dd102269a83f4260547bedd5d1f8c40ebc05743e90b933ce1ae1277f5c8dfd8089b0a56d52585765adf33313e846335570da9e9a7fb5b71d604b5b138d6a26143ae4234648497a4b0b708661e9714b58ff78aba4e051e2b79020b2ba27360b96126789e23e6f4d19fcd3a14dbbe40561e02a0245f44d3dce94d5278409d572bc9e0b8b10ed92befb75a7b6553b430523d05d4c61391193887bc929ef967686039f98a2f4773cda274b7fbbf56a6588e0bf9b7a3644ff61e1557f876d0423d7a06fb8aa63085737618a9eaacac71e24de6f2ae9f5a0279309cd08ad80bd3bd07f2b5df3b4419052701aa08d532524d7b42ca6fb9594b32e844a28f2d823c0de55506d0a509da8e59ea20ab46981cb18efb17df58dcb279ffbda223c5df4567a8cf5f243ec6d016aedf5a2da73f89b9de28b7b72e45d7f5bc3648a42cf05df83ddbe39be7b4026d69c9d2185e327e8c10cb96e869c69c0e9cb203d426c514d4045fd30096adc04d7e83eb6ac4a3c0d47e27d1d59aeac242aeb1d32eb44f2a7f5b241391cf262a51e7a10c59aa8e0be9a9e3f7e44878efa96e521527f9afbd39848f224d495f5adfdf4dd5c0bd7ad1fc4ab75a805bf186fc3c6d64419f5fc6f5fb3298effd05d045c7ea19bbe83f6727fa9ddd8d718aba2f557ceceb18c491761dc5b8793c2d0d012e0f5f750b078b30323846c9a5acfa93b793382446c66aca20395495ef571db49aa8ab4b17b9822223083f10721c6e02e830fddad88ca6f83508e1153812cde3eb18471b551c95da6abbeb126f1491c29919aa2f8d1ce23c8ada6df578a07f344f4ffe4d3cd0f9cc5436da683fdb7e92a6819084cf54fd854bd5acaf22984457dca4b338e08e77b556d85468c14839e4a47e91a440ad01f21adfed614fb145c9ce87ddad91451c7433a1c6df1f5161e140ac1de16c3c4efb2af8065dca260d111cba7361d9a107ef96b0d8a1df8a4bf958a7cf2d3039c183c0dfed7acf94f531e3fd6fa17d20555b6aa5d455992d58ff5636015132bbc3f489839984bd2622ff280d0421c9ed3fe9247a568ed86dd28073977fc9e455cd4498348111ec8ec7efe9352ae2c5043c6ffe234abc5f4ecfba0138970a443c70ad466eb812d9c3225c403e6eba22ca7060ad1f3eb5872ebf541226c174ec4e49c66f3467d0d9f0fa41d44ca09b0ddf59e6e4c2d160b132841dcd53d1347f6cdccfa28ec498769a9f466abf7448c3e0e3e6a09afd26adb856103535a8ca5c1beefaf350c4973ac7d3539f3b3cb45bd564779dff87eded7cedbe149caf6a774cd1b5198ba5816cd519f82cc0501ab6b8fa1e051dd61f99f3868c87a4120a4720a7ff6ee059b93ef16317a6db2984712972a37ae5c0d6b2d1f8e347a1d9cabe20046e0660495394c9cb30bc4ba5f67bc1916e1179cc943a6a0ac10bfefbc48b315ae09e3445891c90d22460f800739cacc9f884eff6d6959f5d99d6ec0dedca016abf044f5dec414c7fcdeb52e16df0d3e62c99b5321c88fd758540636ee7580504d225e942dffa9a3a301b3e98adf201f268a43123c16f5e74e07a65815282bff715c6a5bb482ceb95b5febfe47fc15ac3bf034747f95e2b972180eb68bc4c168f9796988431fed0d032e4df44bf1d4218a8fa5f16cf2722ae93e5cd77acb12f1c2d03a797b6464bd50fce01739cdb353fe3433b249dfab92f1c8f4300e2eceb0bbdab30f3f62ed7e56e0486ce7a318778b37236806c4dbe471a9adc86c16c23a81d5998058a0bb9c4b63d1d9c0fc1792c3efd448accbcfd8daa546c0b94a2ec31b5093645d83c6c75875e553c6f9e8c5b5a9c46940e2414713405080219affc80566a9c4f38faa5f370845c83775248af839a5498330211f5908bdc7046c4c7ae2ab9805952624993eb96dc9cb69f7511becf3cdd5962f57c9fd7a52e8b66be332e057e8b71283a56ac5e2ea0d0783e54f827cba6b65daad95c7f5e7b7d1d7821861cf18e90251b4a83f680bbce3a86a59d6214b98fb93c36b169112eb7972f4871dd5f95f0c12fcdb8fb62000b79dcd3ee186fe1675ef8bb9ec5738d71be0b19c4fc0b891e253bd5d8561e496f63c4bd65cbada09c3a0f838938d6c4a8c992437473091de9428bff807908ec8a6a6706a659ba47b9932d89361dd0c57c7c96f5338312d3f299121adb226e80e74cd9b4ed942d984bb561de241b54287abb28ca24ef5dbfadef86ed65e9f26b70c79d44354b1273b077fba8cb08b55b3bfc836ce35839f96a69e6696123fb24dd7af49a4cedf121fcdb3b1e3293ec3acd70a83bfb0aac0249922f58f13ee2912533ed138b0f81c5fd529b64674744dd93977b4b120013d01ad1116d489e4db41a3d65c3f60ac05c8ad7fcb70930430313b901e0d67c0f49e2a9b515684a8c003b33c0c18840d07ac849ab9d876613e9c87c97dbe0f01a4c25edd9b4fd2d818bc00277521fb968c2d1f61e3433019a8d56a086b4d3dfb7c365b04cd28263ffa806cde6d15f11f24aa60eaf91f2b7ceb56149680cdf8d5d9a83c1b4dd86fa0d72a0ed931c2943b6ac5dd62ce7025a5b0e1c9b2beadf18b1883fd698fe0fad84d80e1923c748b55a31699a42b6f5beb7c7e9b26d5fee3019d69591e7b484888bf892801be126374288c56e3a6972cd3b71cc97bf8aa747633ac3c081e4c74c13a08e52445ad832ba1640284fdcb6d7d4b64aa61709ca5c9c4dd1b58a4eb0931bbc01cec5966413d8194e9153994df27635a2c35912f41fbfa2e7c119f1efd61dc00744bf97ad36dd67469c13145c1809db110087c4e866df3d1640a8e808c4adcf0875965e816333e18f3d0d5ec38a3dbb26510762cf89b7b0e737ed144638fc4e19558b12b0ceca8581d89ffa6b61c4e0c6f0af63a0f789e5514149b0d555e05acd467925b94a88930b50a15ec87e5f205dce01dc965cd6183fcbdca670c9843cd9a32d48760aa5995d057319ded213a931f0721386e6153cf73206a1b17f6b0a5278ba11fdd3b07c3e3564d233d741c17bb9b41521a10ba80971af0707c7e4ff6e8ee02b1f6667862bd02e705655a9a427f4995af6dd70e4378da5694750f0722e43a6be4fec687cb665d4f663bb279397c9e870fec08e47dbdcb106025cdbed414e459bc23aee771552fcb8d42f93bea22cb8974c089a50e945d2c59b6a7e2ed9eba1b1227bfd5531668aea9c922b8b1547c3faba95759c71f86ffd9320b985faf8da476151a65d630d852a1e60e69a6b30cc67dba7ef7559f1dd0d3b8ff75a6164092ad53e658a8b4864f41bc4f3d400d88756cedc004be31d3a06dab6cc8dde104d5859084989b89754c01779c46c7facf72d1a26259d2cc350d6e5a84ad69a9729387b1c062a58f9ad8881d25cd84242028acd79b5863b83cb8bb1d26d0c7a1d0fbd379414d0f9accb278b5105de42f06108e228a6e4e11d4b5b14a64e74e7a812f5b6a747d7d1ca2b555b4bf38d45110a33bf96291c6fa9522d995e1088a480386331bc4f26e13964412fcb0ca522693bbeecbe5bce77b2a31b38da36cc3dfd2950dc2f80b41c526d7d3125b5ca3576028aa759e899d2d5cd4ea8473ab1e45db48bfc14a01b7295f854a46a1d7d6a068b3e28bd77065e46bec800e51ce4b2e3869553ec2d803f348f562141ee85d2ce32b4e970282bd3c0647abad6ee08f6ea0b4881c1d12c39bc5740b1dfac2b0bac84fe700120ab9de18bb77215f74c0755d8f182fd536e684dac183bbddd700c94b8eaae505bbd7aa9940cc9ee4ba25034fbaf38a1263a229e3e92a32fca162d00c1761903f97ce4168d5d24a0909d29f63ee57b4a2c8fef959d8f0c4db93664c1107454d959ab3d043c25ea14823b9db139aeee3350036f86afe289a02cf8c774c15cf1cc81d7ab202996d1ac30dae82049b18446f1354457611106695bd59db656220358f45158b34df5943f14b94356586dae73066ffe951cf83d0868196b46c0e761aa6448d8c198d9da17ceb0ef9fb67063dd55836901462519cc644c280d43333aa2b614d37ce7802ef2a3796caab3f187e4a20399b2b7196f0ebd4dc22a5f6f3945e560dcebf6a2498a1283fdebbe95866bce6e592b22f4946c3e96f50f2ba05484b6324e62a9ba615d36c3754bbabcb5ee15be55a59a1fb1496bba423e8e74578824ec89e0ab95ce3d036ce9ea8347a5a2dcc0d25ee56f28bb5f9c2b14031e06e42e2add2aa25886c4e9fb953ca3deb17520dc1f192a24ec8ea30eab18b40667b87826514865c76652e2341755afbd6fa91f3ca30377f525f780a842b088a72a3685626bfbf57736cc4acb49aa962d13e07f1295de143a7c768083fc0f34e1c99edc032135e00d10d9419c870ed37da6ea72fd868f9e944bca313ea52379b420500b3105acf92b3e4fe48f95dac8991ecc1aedcd960754597cb3abca1ef3c3b4cd5d8f276310445b973a09d20956a63b93cc70bfee9d4835882ce1d3d47674cd8bd6e38684355957c594a0ad2b33f7ea965336107a9ac8d6a9aa712006ffbaac74b284a527d2ce363c2595fc480b3fab441447c59b47cb93a4b69471484e7ac9b26656946e619b384ee909f385305f4d888271c9b0fc0dc66a82633d17a06347aa62641b109fe38cb2592bed2025eb36a3afe9e6ad71bc92011857f53b63e284f2b484cd158b3f8ac1bf7ef8b7f6fb7ffc202d573e19db1c9e4e2ffbd5771c2d73dc6d82115f15cf0b46a98261c129321a335687ae3b4db50a6acaf50dfec5a71432ac8c84e96516b2cae12fd69c1b5198de1a34fd962b8eaf816ffb1a0dedf2b53bdda043cc69a818d2ebec8088dc85614e30258c51a3e19fa47d8fbc6afa2d243b0e6263ff630db88558666831e5ee208391a348de3dd0446799687cbafc9e6a954629e3a72afa1532bc1cb1d75d2a33c83099903416b7f9b6991d6abec95651e92fbb9ad290201d23ea02e675ae46b555079ea0918c0a8e49cf457bbb618f58feac129944b0432eceffdbde6e57ce40f8484d30044a914363fa1850782581975f9033964715c68d6d2047b02eb57811dceeadd5fbb519cec89918257847a0cf02f4aa046da09083c008741f045aab83064892cf41832eab9c77a49c58ee95853587ca9d736241481ad6dfd2a8ea9be6b79ffd8089ef9538dbaff34a2e852655d9f5b21e87b8c925eff69e98767ffa068759edf9618fbc5d99e38289d4455932a961133e7b9dbd004f79d336e4d893e85a8796fac344760447e082dd31e1405fdcb4693b3fc24a4c3ca5555b8d5d58a794519744ac69bc4ba14644e2a1e8cd00065c03830306db632002dadab56f8fb82941faabe755b918ee7635b36af0264ff0fa45704d0b6784d7e2eda8b479181b091aced5306e0e92fe9401e4545a4a81d01e05726eda7e8d69dd68d24a7c4c5b4b3329f830f8e3f11da08753de5aee0d1323d75b85648fb43ab986329ed63ffe9b93a7fa5f0e5ffe556ff58d07db9b3c15b3213ff2a5abbd22d4e614b52c3f0f5929cec886a579b1bf6129deea56d186c145b9e93077a2ff46c4617f490bb2172891643269cbb2417b0dcf4bc2e3c15a551e38365b49f239d9822bc256a0f452fbaa7a6a94312bb6f94b59f94da51af9d7ab19c16598c8ed5c5691dd8567cbdfed72de112b607d2cde05a727422e2fdb2eac2eee2ac165e36e43c2d6b49e2a5b5b3a30c880fbd46f4086661af19b831fe05184ee3d0a6a1f752385e1b314b9d9f202e4c9940595c8ec92a32f3d5ae2082782ef95e021ddbf8c224b957d781ba54b939cd8781ec866292d497ec5aec0b09c6684893e0ea929f5a3c76e13db3fe01c4b9d84049e816bf1f9d28b15c7940806d2fdfbd74d707848bcaf7247b88b34b1d8e8a8a5aecd0161c5dd68c3f6f92e71acf58ffcdbe22a456113344188a071e2801f006403519fc3077aa9b92e6a7f23e8df548ee803612ee59e2242566f1c5436cc2a351fbba80b6ec352a5014664693f24efb21abec274740beaeff9053c076f99076ccc18832b3c21d776010cc6db37452999ea9c854ba316f1bf53db916677d6be973f153bd5843341da8a2bf4b38a8c39e7ca6d774fccecd4e2a2bf54ca65143074964bec0a3425bbecd6f78b18847e531b1481b47a93aa1568afcbd226a4d1181211f060f057eb99be94b916c78665e8fc4d26368beac0e98ec6c5d3c8bcf8d8d1f3e4afc5624c619b874a5ef1b772ed2245b331d6feb9aaf1f3b888cd45e87d2e2542f92ffb81a12518d1ac84c20c2c0082d3062c36f06d76b36a82b4521c54556a95edfff32605100ec4c91a7fbc2e32c9ee70a75634bcbe93fe2a468ddb4e84c25d134c08c77bc50eb31496951c866b0fcbc12ae3050b40bdfe9068b89f9dd584d1c72cf8690c0d54c1fdd9e6c92d08d095d122c6f823520f081a5b0108dc01f43150a7b3dc47afc5bd970caf24d877fbe407f3bb37de7afac923146c5d0afda7ae363f23957d1b706e1eeb0973c8e560f99d5c7b7e865fcb37d8180ab287f07b75aa425456df3ff56b614123f67380000b49d625d2504a2fb63fd6164f8ff1873eefcc62781d00bfd31ab13051f186b1a13d4d2f1d7370e60b1ff188939dd5d0929885643b32f7d1b276a5e45f06e5042a036915a8ce3d5d333ecf898b8b8b06d0c8f2d795412829c2eb5c0de88e98b25f6c764935517a378ba5fe95939dc6352587a6b1e541b94562cdff4fdb546c1f479b6d00afbac0b2add3b1ae153a11f4c050b3340b0a266b88f5831cd8395ed93c44bfdada590f3b9405e4b7dfef93590d0a47e8db83353f07c20a8759eed63cd223f9373d44f6064631cb2cfc4e04a46c4d9e0e0b9495dd4204e39fd15bc964679c4b765da945aeed7a5bbc9daf6518c75145fa85a5a3228b0cf30a42562dd994830aeb007cba46da3efa7cc1b5d41a9ee5dfde108ed161d0191c9f153dc79d4d9c449d302e10967fa42b483ffa182045f26173017f4cada707e5f04608d6942d88032b2863c9aee5dc63e41409192825dc5ff3f026fa375df857801f3ff00c1ca8d1160d88145815c321bb1e4dc16d2eb88f7132b28ecf5ada29bfce3409c72c2e803e1edb44937df77f29b256ec3daa0db9a01ba32b7870ba344e2f1bfdd22dcaf1efe4201adce664927a24845bc7e19005a42a9e89a920d62b8c3f0bc9320f21bc699f8edbc22a2857c44fef82dd82777cec1c5e13189b525412f9aaabef06dc4c060c5069c123d101ca36553b2b3f1749a3be77ca19fc5a98497a6092ee8db46df425c56247d40869f97b1290d518595f915d0dde3423f152b62281577dd42d9182c6da6e73501e8e76e8b32343453871b6ff0a7ba959f838b0e07ed48c2e3bb7e04f36bd7c10ad2fd0cb2783996c0b6730f56708a5ac16f8a793b6ccb9ebbac4eac3842fec044eca3594e5b2d3f268dd4c9b69e8c01ae5b5c17c02756f7f341316bb3d0ca2e0bb0fac66ed8991ffa2ff137d9665e6156286696f65fe58ad2325e72934368335cd6fe5b97d3bb8f42d1588d9384339d736cdd314ae65c56566d66b0de855e7788bb084087d1fb50efaac2851fe5f222471c13a23b3d9cf05ccec7d3eaebd962e2833a74787caef49d8f959b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
