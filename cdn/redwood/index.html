<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a057ad76cd9750fffec2d3e33f2dcc163c380140e1c558202d731b4c4e5815025b19725ce69c17dcc0225e53c897663e3fcb7e7c230778f8db172de76936e652ed126c99f13e4dce58db26a80873ded1ef63260cc43aaf296f1cb8bb7aaad18ae57b4a37340dd4fea329f1b125f8a5d69d1ce4804cc6fef2089c52af4d7ba60157dd0c1b7dd3f11fcef395d6d71a0b5bb72066eb62b3ac69e7a6cbe6655e4f5c47c3c1c54f41b62dcdc2c6d1771c54de2bcfd21d746b674f1032b51f98b22fe0153ece5cedb366196da525aba3c16a6e4b040ec5fcdcb11d5e2d0f75f027d828d4a57ab7aac93ecb27d0031188ea7833f4bd81288e39b0dad1c347311283e49deace127d1b4100a9df91f632806101f131dbb45ae4d6f7ed822aab5285856849165374749e80829cb50ef13cf6dd44bc98f6b2d60dc847bd39ba8585273f6591467c98ea574af5a8e1caefe27277634c41f29d2bd893dc7ca009a06a86e925c556f50cdde358fcb2a4b1643f6bd5f085840f26e68ed84f7aef78d90b9118c11ae3d5fcd1d71add6e384f7f34c87a6d7542f12230f366d150491cefaea499857a60d1462b432c9dedb5b0a34961fd1eb269c36452441e3dd5e2efe95baf988469c7bcf38bfa4f2e034268d4f0c63bc88d1a2c6df418131b4ad434090ff8bdf43fedf19c140ba9b78186972b58c924579f4ddc6f753376f0e9b7b04903a09a19a961286cb411c3394f6f276e169aafb928c5afe00c5431b8e6d768f29c2a07bbd2c8b3d5a9bf9fff652ebf232b22918788f5c54349fce4e1a069c84c30857ff984f51026f15d633819f0e05bae431646142055e032d055aca3c7e32d22aabc99f6c72a4b1ecc8c0daa4ecb3895cd79d3c81b114cf51aa5d1ba7f1395fef7598ffb822be5d14a64c07977e7e0d40ed5ae30ce082dbe8c2a54b3527c90de83db7b4dbbbf17f8a2d30a3391183a14194df8254d618f8da4bec3c01979bb025e5e42ac6b0c9013d352aa24fe4134d5e080b0da318e09be51f25ed234000b860259273d6590965370a8ec78c49de37de74ee11870d3d70b5c6bda42c4166407cd646df280879619c90093aca41e0ccb0306d51638c42fd8180ec9b555f6167283bb83d0cb29199c7cacad041c0633357134ebe6e1a416aeef4bd3abe9a8bcb9bee9a4f77ba5cc59b803963cde671d9df5303f3e7b2fae3aca555a54ed6ccb602106cb5144cd7a1371060905b3494c7e81224a6768ae78bbe99301ece434f91339bd99c628b4175206b98f2a25d1cda4df6aa68e2d8a5bdf5acec221cf5f72aaf2037ba92ca0b928c865d81bd41f508d41279cdda1ee646057c7ca12d9f1b88fe1456d887ecacdc6598d2e1022ba59d59fb39d6fe11b372b9dc1bcd3cb74481ced1b8337ad484fcd06b79412a86075f99f078f3576602dd7b538ab3db9da4b362f65b6451cf8074d5b23fbfdd3b82d46a9b511567059c548ca382d5c5692472a9721f45ce3d8f537a493675a4e038d2ad81524a88cf939ec4a75eef206690aa04a356c3f0b1544d01ed294a1954126d0d25c4fd9024d97190120df6eeb19de0b4fdfe73f2d1e511166bde42bff328ba0cfcab6e7754f53c76849ee00e4a5c7c05619993f3cf4fb5edb90301a358e7cb228216983c28c95977735d48c47998d5fb43642cae098e35ab764d599cfe55bcf6248e8d68f3914862c486998a6c3f5121ed5b964aebea7a9590baaf5c7ef1440d69e5af0f51626f7742bb702c1a3f2e804635238b25021ebefd119601dadc9317c6e9c94045f25c1a59ab3bd76b98c143f4f69bd45a120ac041b30193a78a54ec834c89fed7429f591f0d60b06a1f16e330b4c26bb21751122e13205e42486b368aac6fbd6799330135815e0cef685aca67720e6371693267c178d25bab6cf4f8239661329c1b6ffb9baa8f6dfca08a42ec21f633cf9ac1a73fc0cbc6510e5cd2949aa58b5fccc940dd90a8a2c34d32a8508e3317cd64a05040777082211228598fd041e57bbf9b9f428e75540bcbfbb27ec3eb06fb6264f14119f4b6c0ad682195d3adb2852f88b256034279575aa707101ab5fb024b685c5ebacec708452055d8dde783677adf14cd4e10db12ee951e9795bade87a46648877b32a57ba3d8efcc316eac655278a8c339c0761ac9099d4a523e3aba5f14d872a53a33aab890b6c8e3d76ff80ffe368acb6340e5ef918d7bb9bb2dd9f9a070e9a481ac2a804661357423cf848502ded33f69e0f1e18be990ab5122472d670a14007190b2eab1104c3b3746bc9f0f21b33dfb757299805e8e31948809d9be3295e998ee6b68db477db85fa29b7005716e5fcb0ec9ce664195b34c76afea3af38ebaca9f790b9c0bdf1e8a31a9b9096917c82ae980568a31a49b4765163bb05d7aea77ce083e604324f23fe06656edd7db4e692df74824fe21c32da00b7df99909040d31dd80f99289cb6f52ba066f9e07e080f8b185287057881129bb3619eb9117bc0fa8e666a69eb722c6927067abdebdee64cb5d937d0dcf49a732cfafe7aa6a0596aaee025df34d593d497fe6bac00839efc7abb5498f6ebaf68f30b9527460adde1c29259ddb9a77ecc298c15434577cfd17630e3bcc703928bf934a68bdc93c2934a89aea3010291b0effc101f6c8d04b581cab0b9de2df8fb1192b32125b1dd2320bf9911dfa328b4a1a68c9985392dd3c932b1803bdddc4dde94e646a028c5c45a39a3c1d61f8199c092816283ca5af88d7d6c2bc2d9f5723eed5089f841ac32442330778395c1d723a604a02c9c57a27d8cb990d7476cfec600394b433577c6018e00bebd30af108dca7f4b11a9b8998d637238ab5e8a7f19e50657f5a2c216c7362ef5dc9d668663e2867cb38c12976e21209ee6d68a4dadfdfc9951095405893363a499ad2c6a3325ac9568eb2b9bffbb1bd89e52b2338c29f77a47978457df21d034abd99d6a13de0547569f05f92125c740d07818f747c4afdb211f27c345f9f5ebece1dcd5ce3097fe4cbf7ee1935b4aaeb8e60e130aa24af0e37b17b01a453cb4e9cc103ca2020dbce01498d8c403145e9b64f679b4c48483dfe49a3c8c6fbd53037fa1f97136c03fc845c825f2a180f4190c2fac2c57aae7ac0e62c1738a091acce8ab30dc7e9b12e45279d25334751126aa712ba5fc08f35681c17dc01dcc44ac2318f26d82c837f9dc260c4e3aa0a044f2bd383e0c4dfe6ac9dd9767da9f9ec6fd7cf5ceab805c2939eaf8dca534a957cdfb7049c0512cbab3b57b7394263532ebac7a7a02f2635e138541c38fa1318f81cc00da448694cfc8b74a14ba8a04d1d25a1066551d3be9e282f8ba1c0f2003cc9359d56d88ce396f2af6441efeed3e511edc2cb97c5c3ca8d81fbe6de20b746f29f7bba51ad5d9803e2eb833598504792b24146ab1a8b7ccb5afb8bc89efa8d5df4ac2e41946acde25f66ec84bdbd065e0bae7f9083635426b87d4f772e1fdcd39abc925ccdd388b4f25beaa4349d2bfb826aad93046b074aaa2907d46a11ce6e5d1867abd78a11e16635bddecc2c66b5f44a2afdc663b37b6a175311fdf4a768e8eea06820ab2a8473acf6d8f755773e2074c98b4e87200180c5efbe096adf85a54438cf8a89d349e58fc823af739c774031691516cbb27214ad36ae72c0104a9dec0cb1c2b06eb1f0f96bb0b8b7051c63bc9fcf0738f431f6fd3eac1508457a57b786b63b2fb28eecf6289e2bef5e7aa1606c22854959a123a5d4580972cb9c8394405a9a71621ccb49208be7c928ef84b5a0d41413c578404be61cbe0c826ca553fb632723a4a6b65e23307d6cc2debab978baa347ee966027cc5a31207c28e7002f1bb7b10fb14ef8ac3aae7a5a307a59dc1b2da79e85f2aeadfaa99b4e09877e512f28e7ece50f90a302e7bfc0c1757504b087a676c1fd0c0204993e8701269033fa605095533fe294727a50ab44e19c9e70c689790aac347768ecb5b2cea99d96a732a1b58ba63b7026067e318c4698d90d9adeb8241ec03b87e4e8ed18881fc89d0e90f3e1c7157f52cb6dac3141b4d2b938140f548040a5b683a961a69eba95f1fcb0b5cc735e9a15e559fb5134dc020f2f8cda6a794b4a648e67640b8187868229288a85e69f035532cda5c717c27d48f15b7f75af4a2138fabd7e6298f066b1c44117fa6ee773b6d51a1d0afa94376faac89ba73b6825a08545762d58d8ad8afa4db7079accbd09895cd2b0178a00d6c88719de595d03eb2de3e488d0ad5c9e067a8e6f209a81903c06a6329e7f5f375e989f6ce3591a6431cb6b4eb4eec4dad87274e06d9539a1d25fbdbd0b1be102caceddf236e17e9e52f58ddd6198aec925193bf666ac792126c2e7711cf3571ef9534a8d0ef52ea670729411fa0462624df44e2c05f1aea8aef79c898bb950f869636713531d24b09d312c6740155b4a0bb8b42dd4f830766a35b9d0dbae56e663e270f2c52d10429976a7362d98a7e007006a0b2d04ca119e1e713267a4ec24b09c6302db8e5089dbb0508b87867163e45ffa496c6929f0d8e88c7a8b013a2d01ef71e0a300ca2cf96b4c6eb38c6b5b5fde0e67d5abb6fd22fef16a6331b015ba2a0816dcaf760ecc190f339f93c74353cd56ab41f5c66065b1488acdd3e63cdbe509d3131cc59fadda15d53f9750931bc0c812483b0633b0d86003e14a691825c11a9362d0f6329f4a300b92bf3caab4a03ad31ed8d47dbd40a80d2484c78f835004865dee776cb687a2c476b5763d20a48fbdfe2d64f167e325e47c1db0ee42c092b5181edc736cc079f65eff5dd7edbd477aca57afd7f1ba928ef028df1b31b1003a0a0e949827d574f4a8fc2ecd1fd56ba66d6b468ed7839197040a7f989dcf753ca084726dd9445884f3167187c0ce6f3a551812fb50c9731ced660e7524de4178767891d282079028ffcd118d2f0b0e0d74093e572d3d1d7aed31208eb1364fb8692ab2cc27822e6f4cf62f81cc26a9e783a247ff6e1bbb725c451d2770ae1995c261e07527f3b2a5d5b5ee74fab02e1142f8f89c99f258f27cf666e317f76538dfd623a253c7ffc2dfb7730cfa6d3e4f70401c352c5fb6a8b3ec866a3a8dc3e4a683953ad75b19fa6cc206b7e8d7489fe6f2390b7b96f23e44ecc7c99319c2ff12f770672dea512990d643bf0cc27189e9ed25ef6b394ae3d63c5fb51d8ed4bbd7797b78dfb0b53415e4aa9d5cd1ab6b4e485df7796745df85adf4411a944e652273b3a8c1276a2593da153e6d9dcfb9f20d57ed233a7a78523382ae1d781355bad4bec2a083ed82018dbda73567356bf2c3ac3d9ddea65d4e87cced4d0e976295d114b9549e248cc55b466496334e57cfb9016f9fc2b8642cd235d1da61c2ebf3676bc62a69a9086996dcb4a9ae30d2955605ade901622aa18e4255fec918f9119def7dfc563a38436d7d9edaa835c34c364d84261856a419e67711ea9198f308a39ed4771b7ce3a3d4445c2f1f71de7fe5dbd096c72adc0aebf2607295d315ad8f0a4c8354b9f56205d5acd43886b70db0c740035c0ecafde10a39aa86bd83aabc7b44598b25a60efea3e45d09ff13490c6cd65e1a10ad00fff92fe9a451bc837a46ad3d74ca509ca1cea6369d0108b825b489009e935cfa1b2aa07a5c43dbed1e576103a30127037ab42a897bd2ab10e4ba6fcf5568f6426783b7ab7f8be2c2bfa74bd487d199c85372c3f4182e6c63b0f7fe2d83ba60ba2a37ecb6b51a3724c179c6c5bd7c4407ddf9d36d071ed1e5fe668a82b9e5eace07db070f2abb256480bc8fbdddccc5008fc4d86ef1625cfc95bf48feb43645eccb7d8f3715f328a95d1595f34a3bca1534e16694de6c02e328f6ca1ee76b50f3083d43dbf36d2b7ed173fb43222cacc93d2c780287296c6ea4328d552d5b74baf75d1bcd58975b9f0bbb95b92ce0fc14fef93f13af1269317fa3f417e1a722bbff9682a4320258053817860c4a3fcb8ec583c4515001c8d47dfc4c7b54f336e9ddbe50dee9e4eeb2db4e104abeb91d3a1ca86efac728f279c89d8d19b5dfcff9f497090141f2bc95a2159ec95401d0bf46143a279a0f6c29a8f2814eb9b189cb85fb87fcc2ee7c765b86a86dee9f860a83deb869ff1827ca8b67ef5cd332446f2f8b6769c1bf6f6a9cf1b0e890bd7660cf151b99540a403a11175e89456a0171f7e2f1b52999052cfb6706a7bcf854c20668ac33359930fd57563861fe3767910a129337b2c1e8b73435d47268973f5313fa1ca893768166c71fd31aa5a8c68c1c6d313d46aedb944614cfa29f0e8ff511b20af10c0d27efa7369f4f2eb9f2e89b75832775fd5cf7a4a92ca20fed40dddd6b8cd863c59f779044dfa21166f8415eaf632016b8c2c6e9f1dceda6e20967c1b72e78c28b1a9ba21fe9635ed4061f45b408d40b2b443f3b0c00e13dc773c957dce9bc22742bbf0622c4dd339fa1777ea3bb62452dde3bb292f135e0e22ea4eba25d9ff2256c380027eb2cd63a6407277503cdb93e8c0982e1d87da5c9b96939feb39fb903edc54bd5d614fb5bf1825c18c2d9d61bd0296afb96675c4930a67fc30dcb67fe2c417231d155853d9e51d032724ff3f414c96fc7d468ea5f4a60c85fc63a3aa598b5e1ea2ad8f8ca5e4397c6aa0c967f20dd2a7feb823c40836abffd98cdb49c3966748c520df5ef557eaa9607a8ec5f12728dbcf5ebdf87de25f09a6f7a256f2573a75a66f73d364ee7f20df7329f06454fc364d06cacf08e1f9db143ae58f47ac56dffde04c5b1f646fcc0fc7553429821efa873d9064ca80e221fb03edbe02e597a8d03c57eb10320f4b0fe25fac8c5917513bc16812ab07ceaec89aa9e7791411418c0854f009ba3ebdfadddecc8e79f2d34cda732d1e760bea201804d936c074ed79941366dbc54587a2b88434f2e0165901811a74649bff72e9b0cb72bc398a8a6b771ebbbfdfd5d918af3381ebaa3359693bd3650181765585e1bbcaeff6b511d706f6f42acfdae319532214e02e1f6f5334a39510ef2ed4533aa0eb7b795e19bd92e277cd2ab0b5e3506a189ff6f88a2b9cf5758f5699659c98769a49c7d53964286a6c650cef6bf53d70b3c787c14f556fb274c5689f01024185d2e4e3aee16a02c7712276a105bbaa67788d42012716342b185bc4afea3a468c08857d437f52021bc424088865d7de64ef3066566f8cc7b118f0bff868448963cfcaabef6183e536196de4bc210c79dbdd62d774900d314d1d7384bb9d7940fddc6665e9d20cdf450d597b5fad7a3eba3b702f78d9d6e1e661d737307336abb91c42d5384367e03f6bd7075645af845f757f05acda919d22418082afdb6486bf470ff66c56997e5a44672b93b79ac3be87d9445f3246b2464db6c253a2edacb6925f8aec2fd9fe7aaf2b8e44098e8ab909b5eda6dfd1def179d7218567ce6a55342b5973523c7e30349054ecd345a51814b9e024f71efcb5a6860ba5b35c31d946c3ac566ca402620fb61e1fbcb73021c91de368d02248f61bf499da72b322146c910e72fd4ba31c61cbb4759c9e007360147ba6c2e5aec02c94e1b0df3eb9378d712bc55461b799ce38d84f35a76d891b88615e67fd4d8b7ce0be198ae4cc67b751c6e9ac236aa734130ea7bd56791dbe9ec1cd252a080ef698193adb5a84eb380ef002acaa736f90d0250a77cd279e19863dba54b0deb4975b6c2559b8fd2ac3793a81d58a855943ea54203c9383a7f3f664b36bb73763a35ae785fe3523256353a7eb7db2207a48f536fe1acec482d092c6ae231f2c69163c1b713554515bddd9d9afd5146ff72541be8abebc36d237e2e2169333df07e1ba0ba28ddfb6c35a7af12bbb54e17f63ee13a66684586babea6fc78da66522a989dcf02dda97ff3d86e779eecfbe545a5d8e504a2a8f6219cd73bcc6c2c18d193ed12af9d19590162df8e3a94f9b3f60b5528fefb262b54f666423164b7566df659964e335a578561ac17db6d07a96b7f6338949b6327e92c12d57b44d1e1bcf5c98cd7de489711c18537f527b7c4a422b138e32d69bdd68856d72c9dc938f4c374de555f571e8c68c93e774d8845665753a2a4d7140e537cf64ac2b78f07cacbcb088f85d972e65ca6d1a820cc79517ca6127e5af1e3e3976a1019a944e445387640e0cb3ef0e089f1b1c5a67a09b4feadc8f142d9243deb4a7f07e60cd09dac9254bda709d0affd565c68843a565142412a4fcf9cab26695535abc80c27c7749d4ea4a133125da05a755a8a827dd7a85b7758599a5a010bac42e4d521be23b128174ef1cb7255baafaf932e01e5c8bbe4f8eeb6450a89476f495360a0974d1141cb6512f27ea42411649e2af12cead1187129f18768676154f6f602f2452ecb50c5eaf8bebfe819daa6de32000207df183748c3a5d543ec54f1ce611ba2127957f41327718f59030d392d7b084001d838f3cf6382ebb2c5192599588b69b727ac02a0c37206b9d58321d1058a19157c4d3f4e9565031f0253ed8ed5785fec6fac872c186206ace43eca69240c727951d7818ea43038d8ce421c0dd535e739c49f050d5973a5d0be9278bccd26c3179394c62ab7266842f0825b181b5e57ba0c92c02df1e1bcafe640971a5560ae825db91f802e7cd0f7677622df6d2470e601f383e10a957f55caaa9f444447a710c7c4c84e07e8a94dc7c201ddc81b4bad037fdbdba8050c3b4ae018745370be6c0604051bee35d848c094ff986bbbb3e898dcd42e148dd2affa36dd9ed3074cb9de593af6bd20d9e16d5eb868a4992c8fc679904bb725c9f26de4f9a332760cb4d3ffd5e5498540d692145627b8322b3c7b720e73f25431025db9a0d02cc2595141c58a46bd8d0d0f16bcf3588f96495a0c9402a2356bf4160af5b241ba7d97d56b0bafc3b75f8d671e7cec38bf4c5ad3a5bb64c0783e05846d6af8098e58ac013d1704ea5e2e67bd1a83d0834518cf87b4efcb4618d9501d2a417e2dab800b4f8d76938ef17213612db10bbf18d4224a8e3978a0f119fc2ebedd95c1fffd928adb2d363e01b94aa10786fd8b75d93c56190d2668dcfdb4c04573def8a6a1838a650369db5a16ced5c38c5c19baf3729cff84b71348c27efeb433434e749ead9172b2d04991dbc4e69d5b9951c0be233165036e74fd10d3e04c8a752be1f57f6d0cf881ab8d1d044cde9cd95d3f334a5222267a5c65db384215d1456b9b86970d914e7a7ea02e2fa64a131cb71f6814e87cd1a69ed078211afe7cc0e84edb151d38271edea1d4857a4adfac3c7806056453e51158d3bbb888b4e97cb2e3aa6d95bd9dea8723d53a9d8baeb938e4e4f64c486f76501a0830a7d0726acc5eb99453f92d06c04098eab2f98389d54d0b9ec6a8a8c606e64e6e722bb667cf504c696d18d65de00092b074f1ab800a16bae12e5b281fc639c8c0d0d60d0850a5e75f84ffa473e9b91008af64cf320cb4a421712b1072e263ccbf8e7d719fac3d6e6cce877f8262b337a8be0bc523ee4266096b19d3f3cd805491937d8880f74ec64917444c695da67e43e39018cb63c5ff4240c15b1c1e6becf345d953918ad635f55207611957b8ed776b817368be5154c40b6eee41351f50c4214d246993645ba17181a33d6b91fd3fa4d5bd55945c39223b8d045bc1d8a39e45efa9472079027a42aa6ba423ad08a21483449e3e278c537265cfbf8f904de7cd657f2053cb3d12da0d8103bbb5e40199dc8ea8a0ff04f0795a425cce9cf322e92b856746cd826f11fc6c0d57a78f8ad9c1a6cc32e545dfe86ff650269f47da16a8f79688e6068175cd63cda672e0729bf335023353e903c4db26554b3e8079cacc104acbe308782af972df86ecae6f7599719ffd236835531a9ce9c1354a9a5ef3f0a113ccc873361c815cfac2666ea16712e4e793c6ec0968b2167b723bc2f4eb25c02de9e26f04c09ff77cb044ab320384aa1b1fa2b680c249086d84eddc0fbe4dda6e159955ba3ce1af884767a369f4b0cf017aef79f36ee00010b6156567a6117f649064f85c1f5101404427937404e578483ea5861c9c4c84c5537a2551609546a0560f72d9230a8fafd440823048d7110359fb3bfc28540619fc2381fdc9f160f35118aa2b55aa7f13183eed4d0cb20fd7d253f2c64aeb0a6ecd9c2718e2407bc0350db44e57ca74fcbfc0475ba358366f7273e37ac50b30165178359db8c5fd4a2153f4ecba107f7c72506d641ba4c6b628360d9d745a9a0e3dc83cc8b1d77170d395597782e7de7c72fe91f7932ffe873cb41243a8fbc14d55a9c51718e7b9b340261da3d0a419660aba0dbf262f2d5bae2555fb4d66c48407f933feccecbd6f8500604759a20470748a637ca306f3cb9bc649b8c3969f7d7e772fbc8ca7d0d4b8a774817ee8bb6d1dfffe64f5fa30e2d5b3caf1c4738b799cf99e833db042b3100c765f1dc400a9ab5cc85620644449e49e0d0507779d4d60998a9133ee226f7e9b69e365a0d0dedb737704298366ffcc20b0f118d550625dd90bcef9564cc9aec3d9fffee17298fb3f33d4fbb52f495100e8f0a9efa1c64e6071112784c71da0615c1c56810d7effc61a1724238d37299eb96b6e708df7a6ac1aa95c1a1e30dca4e6b5d6135867fd0ad4767035f922ace3822ccc48cec99e53c8070e0227ad5c77c110b245417cbb9b086009ab28b5152e2a174774d7c079c955775f5d7e977d29f76dd0cd04c9ab49d6ee6072478d48135fa07a5627f33a3c8dbbf86b4b0527137bc3753b9f621cc3cdf20bf2ceeffd897257e64934821f72f001144a562bb045eb65dbdcc41a3a808428ef1255a9a335fdace6fac64f8b215559ac748cf76d109e2f4280314760fce5eedf09de66d450b6902af8635bd7d36606e81390fa20e8a0524ac128e76482f77ae644d7da858fbb1995a4b33bd0141c9e58503a837d98f85d188d727509b48ca7ab3c442444e9dc88f18dd66bde025ce8e49cc5fd62a6e40d6dd7ff35b40d5c38e3f6b40ae77aa32a1702d01f56f862ad076525daede65ee5c788d0aca243a2d7171dccfc47cdbf836bfe183d5e8f44ebc2ba84ae54d92269debbb5ff960086f5b9154cd8e073be563cd432397bcba0a2e583c35da74b5a1c8ae1c914098bb9bf4e86b92a2c42aeecf7de6b41b44d0f665f0e82843aee94f4b7174b28637f6b8196327a414be456b51737717b400e49d16346d3ba0fc2e0e97fb62f6e364ac4e5ebfbccb10d4226dcd2c24166e4e8a0672f7da090db2b447f434e3bc24365687d93681395ec7041565f2fbfdcb7d116550bb62b56eb6341d1096b614d27def67285cdb353b1cb1b332d876a9a4f648734280f10aa16ed2ec37d42d685468d36b96ed6e25f5616b7b1c6541ffa08cea1cfa3bec21b81e543d801f09d1e08ad27fa244027b6bf399b33a7ab5049d162bd469e2eb451a4c89b1a605e70d3108ff2b15ff9c23b869690d2c3b9ff8ffc9ad078f2d70179da247852c3a1ec82b5a01014f9f4849d253684830b5be40e3000f09f0e3e26741604a580f9afcb0c001b867997953314d8d1cf96afff7a5bc204743ee9168dc291ed3d29956f791b745abe77d8b18382eba4082165a969dd5124d72772fed62f8a269b32006de6156b5ea9500935008d4c7725bd9d74ff7099512c8d1d7e90acb3364ce9151a8e3a185e3f54aa9386e4cc747a2ad16710610c18d01f0b3e0cd0fdd613de4b990a9c3dddba6544374799ba79d280c03d48a252d7827fd6cdfe92cc44c949e09c092ece1b6ab407bff1ac29b29024f37c9de6ef0c857bf3aef772cdf0c3776bda7f912cf654b5d02fa845af931dab14231a2505f1383ad110344ce6aba386355bdc8512e940112b3bf2556ddc3cb5a097e878f32581672f7eec75ec4f22c1de7cb12958193211b4422fb3bcd9d6bd17e2315fef8f3d41f09111e896899d4681a199d6f5c149d7bd67f1c848d62083d40afca675fba74ad377403368b7b64fed9d61cacd3a47e90c95fb9b9a568661c4df7f236ace1a13e0cf491498e6d3439019108bc3a354eb62d9116050f649824c403ec0d4c4abe38bf28ff45fbe58a0c78f9404eb9d30fedf227edda109249a8d712c43e15b64460bcf8adc67576c1deea8f7692c85194ef9dfb5ae1fa78b02e6aebedd1183e4c1a33409cca59854ffd83f788aad51b89b85f124006d506094a02e821384c50461eb18451eef904f5ef6d8c98ce46f6f8b6ff42b63a74f7497ca562b73533519c57881242bb07fbcc76db53a1db557e9fa211f3e9efbbac0b9e7a5bf671c96393b9135c6e6edce37709ea3f3e14f20b4af75f702bc449073f25086a24bcb26f21b190ea373da522cf7bde0e2e3493a6859a85e7063949cad75d8f3f14ff6d1cafe0f6a5d9ea868aac153d2cb76dcf4e3da588882e3c2ac5eb931056654de469d26ba35303ac1a1096a50fcc53b2d291c93f1dd93a3e3e6d8e1f1a3822ceebd67d7658138c08c9561a57e420661772d9dcc2fbd756d9b4ae31162822916074c99ede3026437f9e26301ac1618f09cfcd0b9adeaf4007393684d66798bea8d8f00822bf58f3c9c2840620189977ef153d7de16a2499864c6ab004a751ba8735423a51f70f2b75fb09387b730e903b84e5e5798b9e37b116030a9ff0b063755b6e5d2411a4277a3ec94f5e1940a19011f82fb8947767f0d5aa18acba634ed522448a98b80463bef7416d7aed2a4937924749132d09ad1f9adc1befd152e5bfa50b9c8f7efc86a7f9f6f373d754b09dc83e3f385304d0e0091a502b6cf9137a9a4447d9840f87d4f83e55a778edb913c0218ac2143c10dabc084b2e27ccef76eb527f21dbf72b6f59d9748b66760a6d35a93c3a3ec9dc3df8bc5328b11ad10d15e2896108f8252dc70689a9ef357cad092ec005b1fe63055a9bed5616f6186685188fc5b9d370617bd118fadf21fb7c441e8fc36e024eb08090477aa8091fe1064707c80b5f65b458150a3ff0051dd70119a0935c3da89add50ae3ee869dc92131d9915dcd5cd2fcf9d43395cfd17ee87c0913b8fd4751566b9eea460a8cadb64a99a60e7ede66e37f74a0d64361ca44218444046e6d6e93a446378f67fe72026dec152af11470668215414758fe7c3350434fdd47d4f89e4713b127fc59ebf4a3c674042a159d5f5b2427391c04f2733f5500b40ce3fede71ca6f123185096201f3a174d81229f55720411059982e20fbf8252ae66a48c4bc84caf5bd4fad8758d5a26b7f3cc5ee5a7ef022be8f8259324c4973c37cba5fb33d655aeb0f2a8c6d2a9a3896dd7a6d82d1a608c4e6468b9b84abf6caf639a1099ec5ba05a90593f867cf91c8424c917806b901b1e102f7ef2d08b0930386d31d916778ea7937d089007fa057d6d6ea660f9b27c2bc79016a2942c1a5c8699126a28e73822498b6e148f3dcb35465e13cd028e538d2dcf1f68b10f6ea80d37d79fc055e53a849e5011dae71cdf53a32b1118ab91cba8d9962a9644ce15eb3176bf0a70b9a580c40f597483a7af85e7e7f6088109b7a09b344c5e7bbc70c3f0fe728375b3f6b900e32f0d9391ee74d3e88ec3cb9b176ec1201b49c993e8b4cb8729421ace53f02fabb7686f6b2722b4c874aed4f3a291a0bed222e88e44de0da3999bdfb9bc7e1681ad5858922e3c5779440249ffeaf4b9117f3e8d87dfa9470adec79367a879150786fa369fd609b4b8a284688cc95e487896ac28a5d7e56f35d362282104830b6ce6d7496f142ab75ec611c03fc14838e148f711e7665f9f835d78f9f0cf82b5866bccc287e0fe3e21f599bae9531d6b7d84b82ea01db9c07e08efe8fb5a356ce40c1feff8c109fa3f1f307b0b419f1e7e9f82719dc70adce1f4a7d377f5a5bdcbca44f097bbb18f7f8fb2454868b09ed95205c4c6e66bc0e9ec1fa1885bfe8104c661915c7850f030fb90680cd9bc7af15cf9858dc4cee1443a911af26d8da8b3bdc214d3b5889aaaf5226db15ca7f01fb21128897e143723f7350eced8b0d58e3787fb1e4fe0852d66bca961370e0455325d285e7e69a08980c64ca8e90e172a4b316e81a2f8def6019700a3deffc2f5693256e12923a9cfd695ab414f1d268e2aad9aaef2564acf0f3bf60791fe41875a7274e11455f750255567f1967301d6fa822d28385e8c0a3072dd04d24e4bda33ad62a3a678b546335e8e57233789c270be4b1f15973d1d3f6fb8d7d5c08b675e69ff3427070dea6bcd2a0625de0650508e61ed8fae29a638b00779c2cb3f9fd3ab01e94fff9a2631877efdfff6c0d793485d533d78e685eaf9b6d07cdec020a954b831c564d8ee46ec0de3d7bb09a0cbd36255f123b078598a5104d331f6693498ff4df3f2591b8ef1613a11dec77202f4030f435495a0aeb825eedf673fb38aee16074dc0d2d500dfc8c48ce7fe5fed3468d5b4ba4d67b9ab4df0ea95f59659cfadd2755006c71023c0b3843934b68931304bdb21b9c0ca221fdb08a4e46747adc68444192327598de1d8b6c0a0278ca671b33719ece7fd0aaef29846d72a49b0380ec7f29ef8603fc356277ac2ad7dd82f13a03f84eecfc6e19746ef81a71982a697ba7525b2748d1de8ffc1bab8620881b2bd6dd7216c3221cc2d5be07d1d6b5d4c5eac4067dcb53ad5240b2574efa7e8b864c768fca248b73f745a0e6af0cc3b3b73498de3cfe5176f34c42e3b7ab58819f4a5638a2a338ee4ffa75d7510d0920700efec0ae7870b2d5c43c302873af805d2747af236325035be1abcee37ae4dd9899a5e164d577253ac995a18dee4bb59b1e05be07dba484e74312f39570985f7dd3e104e3bdab234cbe3af311747a891f5b0d273b1402edbd798beabe2aafe7b3f11141f20e2af9746c93e7a7e7c3aeb6d0abdbb521ed55296584a6a4ef4c6ffcf9628869d3bc7cf0d19aa3c3a8063564cc32a99833abf1893b8e6d763ca459e861a8b8f6a0631279e686ae5e66578c23457c87679299c92f38c58a33628e5ab8052e784228949bfe1777a03d816d4e9b6a15c3a71a5eff0802de530034a0a7c9e58767e3e9da97cf04ef698a0211628dd4005633aaba7a9ac535ac29d6c28ca31a8b6e816b4c67a6efbad4ae3918fa7cbf2b566a61bcb6eed86247d750d6c1181e2bfdb6a75931f641f4f7b4e0f3fd8f5052a5d4226d2a7a03954eb61fd0e6aad16dc3207d3940448115b3449c9dd540b642a8058f5d4daca44336efa192a9ee36f15a9d180b292a7cd32161f90c35c39c83c7293066f1a3da0c3103bd8f4a65f0ac114b5f2007ae5c2dda57cb9df6ba8f307999324593f5cfeb6a0f040575f81cc4a9bbbd9ed44b8074407cda4b1616f427e0e5aca233aa8e29ef9b3d564a58d3c15a0ea71331d371ede0886ad785f4579785164335013acc2b26111bb8122737c5aead1a128d58c3f6445f802d4a2ef585f79512ac8fc614b4783134409ce035173cce2eac71aba90d447d4f4df18cfb8cabfbb805d8fc3a72aa3216572ab7c8874eb8c15b79d07739720e8a69fe47bf1815e7c0d2d9e8c84f67e03e4860b97b41ee1d6dfad1c36cb5760747d99140b732b7f6205bbb0f040fb96bd5cc49c0df67cc5d08cd62c2e1f91df83de839a9930e77d0dd2675d934c230073e136ffb3c8670d69a2ab43e46670e2eaadfb817c2c0d18b63f0267326785bb65153047cf647605eaa02e9e0aa4465bf4dd13001951db211b470ac97b7e883ce644a7c98cd77142038d3921945e3274c789ac254bdb904be30a9d006f72f4e101c7fce05ee640e80ab591ffb1f427f0a3ac57b0aaabd38a5da844ff8d6f532a53098bcb3b82dfd51c0e6fa332a3cd1e95663afc2cd68b44b80913ab20d8b9a8e2c594cf1e275e6a0584fb89cf71c91c57dd160d0758c0de90cdcb05c4b7637813e61a9e966f65afb882e2c761d1dd679613c5d24d5eb7d761e9d80433f28aaa4d3392af756a7372b6ba9cf4f99352a7748631d82fdf9354cfda1a6ce17f175940cb97af06e6fd31b3ead7185c74de6c3a6c70305f12c0e3b3ef2ef6df265797e9bd84f9e2187a3f8132175a6bf9c27d3a8abe98ad4d104d914930a48ab0020138b17c60df6cd23efcc3ebd760e09f9d9a5480c382e512b74885322ad390d0ae124844e78ddd7f94331eba5e6b76b2d3bece017bb88eabf4f8a145fd4c15154d5900ad15b9b4dd4ebc7364bb58a43217bee0d769082eeaf1d1d3d8028122414259c63690c1042cecbb776136ff2919c011a649c1c0cf750b55fe8040204226d06dfaa8a591a9e8197affe7398ec8850c08f9d17e2d966cc3c1d547c2d8e3ebe5bc75dea1ee1135bd6d16356a4ff880356f3d16e14f1ea8c5ce43abea23bfb11d2dd463fb048a75e6d10c5e81ad32b1ed9b4849373c93c8e701070d7fff6465a9c30a2738991dc6298396e12d055a5fc837df101b6a361d88590bb611cd10415e40085c5e90735e53496e94d6e07015a3221835ace3cc326cd8e5188797708e7336500b56ed44873bb1064164e41c5e30d78de1e4e8a501b045fc0325b1adf05b9338aad9221d9dc032be28295206e139dab3b2734e121f63fe8a1bb6415af1289b2eeb4d3678a1d3c5036dbc1eb1ce44f6a8aff969747bf142e2291f6ed39361b240137f7d91d72c5de13899ec6a8c0e70a88294fbd273ccc13fa8fe3d14ecaf961a122c2b7a541284b3c1337a23ece03b5a2d4f28d7dd417ae5d3787d9e4c3ee99ddf1baf9fbbb808861432d5efc146f81a925098ada6765008d21b3ccfa200c6dd96323409ec6824b132da1e753e946235981d6bcd33d5d4b7a1ffd0e2e8679a82cd8c875d2a9d26646e280929049f841d51c88b5a57e1a5fd18e6e19d79dba127f0d22a994169d397c8292e03691f5a412773d508957d540fed426fc2cd76de455cea067e2edbb6b760c45375eb35bbef001d4281d1ae41be63595d34539c2995e1bca3309e130cea920bc93d84b58dd3bc06a9302e4957d7dc259e6c1e33d1c2b96e34d070577302c0d5a4f1dfea8247e03b09c12940ffbb35845de53b2158dafdb1a49d4d202d744268ff788fcafc33fca001788a67d139ffd7e9b98b129b0175516007f2ac6436232e97038daf04dfc561e8bbcc930cb224b2e2b9d57b5fb4984fc123e3e7baa9c765c437a1f7e1bceedf1a0b5b0c4412d6a700429d9959f9630a15e7f36c5595d522d6f9e0cedec8965c63ab61cc2977ebda6e2c97d2add79ab031a3f0c95cda36a39e77822019385ba412836e9ee0fd4cc1702f546d9e586eec71538f029a7db2b49a06e21362d7e2588e40d67b870d9be83fef681474d786951442f367aca01069952f6ad868ff4b862d44c7019824b132d1b08d9b18bcd047fcd8f0c4484c1b2803c0e0ca392776abd31a7cea714d9d0cdea7f2e0b20128199bd48221fce368d5479ebe07b1e890600b19a743c0cc0807425985367ad86d3c561fa0472bd84961306895a3e05021c3135db6a0080f824b0e027efcdfeef16cc2e1c4aff32b3565c43cadb848c986fdb06b223f3b45c12047a8437d46ce244b4266b96892420f7462e018dd0c43a99c3e98143503116e604dd88191ca86588c1375c3486a9c7e6b67eb7165b667b8d25664e9328b99320e348f3beca0f603b2ebda9039ed181c13930a3b20ffc353f192afe104cfef97c18a2a7e344d55971f87376ec8964b9b82dec2eb6a3f86f1d62960e44037b6437e7b378f5b384c2d125d1d422f74fd3ba7f3590344040bbbbb9a06a8ec826918af75b957c814025534c2608512dc6fdc3f4265f556973002ca403daac6bd2b56d91f3257b232b89eb726bb073b15f570be6d42d38f8e779b44930cba5faad0193988c8fbf8519a3cb892b38240fc29c7fa538360ab3cc606f54db4f965912f2c1e86d715067f9a2d608a5e20f3523aad5d08e33087a40efd91a3ffa7134c9e4ebd1bf2893701345e8608f50caff204483b9fe052a9f14ef94360599dca6caa0dc1aff858bc9a52257fc4f1df2e5b678eb1dffce42de5f4a095107f8035990eee19269424955c998938feb8b44e37ff6333cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
