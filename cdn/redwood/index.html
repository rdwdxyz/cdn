<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26683cf353c00124bb5d13bbebe8ef72acddc22e50d8fd187ff525fefd2138252919bb12a958724f9d7375f38b60e1ad5059cb63c8c38a572865eeba7793b4c61a59ef51febcd22cd25108cc1c34ba5c5a9d69aab64a1fb38056ee23f8933f39179af106ad6fe077b3ca8bd6d42d89da6e67fddd56307439ec97bb6e749286be7cc976fee8ac765aa398cb1678dd0246370cfb114d7da83ee75b963b6871ca2019a96fb7256b336a9dff2b7e556cb5018f571c2015033ba0aacd85c8549ce19d38b9ae411de391cacc0fe15e9e52bd16e7871c2527967d5136f1a696fefca039b138f9b9174e1e83aa0952748bd83c118583eb1a3505b644639f81e6bbfab414b883c8dc8050c236a812a1745a6dbefa421b3334f38e181d834f937a3020cf9fbca8801600659d3063748ad5cd83a6af5b28a84944faaf853044c9c2da3007416eb5643d76adbc6a451c16e55902c34dd9d27cb9e94428603e4a94d26649f96d2c4b633c76fd9201f4c40016f4e56c9d8d9768c9c82933b2bc02f440bf0be43325c103298fe0925a121ac2ba1f3c4c32bbed355020ea21f313ca2be552537a9fa8efe0c42180be9e62d69ae46fcde9ee58e5c10baf81cfe0282e9159924cc9b190452f680686de567c38bf6e37e448fc14fa2e7fe7f9cea62ee19e3de8e732e44989db0d94bb7272fe68ca96f2146d77e039206b5c70b35c35a6f7d468aa3c4dc7ad60b19c7ff631ab9587e390b28b6adfd6b207481f2d8b9f60cebcd17c0eb2700aab8c2b509f0d69b42194c5c56267ce409e1b61f85e6cbe32261267e566c77754ef8ac67192bc620828961028d4035abbf1395614bc826b91065b4f1cdce3a53b4ee5435e9a1c5153984dea12da63850a4fc06b4a6bcbc4ac2046ff00ceb2d08c0ac2b4db7a6581599fad999d7f1cf12ee3fca644dab27308a13865f2ec0d4769d94371bd5f5b5a0315a7495e40d31e80e1f5a7adc72eea24558b0841bb6651994c7772179f3cf787455d9114321631954adea32ec1fcd794c62652555ef6e32bcdbb786ebdb8d808da196476e4b227e3b74cccb6b5c77709d9d7ffc34e0ab5e05e61d721eb1b6be24a53eb828fe31885d07b881d75de180f4bf1dad727a2be477d8dccb1b2423c177ea9d3ec13e7286a8c636f606896aca5eba828055f8109711d8bcd0849eb04612517862adcac0573564083eb6047f4c74b404a0eb5d7a882ad06cc44cc1817fdbb2caea1b0884fa7e6b9f8688129421878c1d5e4fa00ed535b0d6d8d17f2475470086f1a38d6157241ef8ac2ebc7e4e097b448716ae35d4aed716e6688f575b569da9663346fcdc465596870e2d1fce7aad695e51ace56eea6517d90896dd1dae2ddda4bcb6fe3510a5a8937f0e3b82cc94ca6dc5fc2409c6f41d8865115a7fcd5dc07d209998b1ecd9e7bfe463311b0d9b3c0eeb3f66ac97f22b6e5fe1169a528e0b45b1ddfb82740b5ba6d56072346dc344514b7eadc97a905a53e42ebd7b70e8edb150de20b49b658d6c5edff4ff7b41bdae4d596e4ba492bb292851e3c465cbdaaf926702ede02142b97e9c1d6652c360fbb863ceadc13b88994f31fd965ef754b5040980bfd3a21e5da3ca1a0130478c87a76c651e17aa27daf7c903ee7cba4a0fd11b2350ceb88a51473e36f4625dc7aee1f4dead5b8aa2943350e4178cc23ba33ab479ab7d7e1f03b099c888282a4f439e50dc75507528b80e65740a36b5ae9a77b6b5cdcc519aeb510e5c6e78699357515db93681f9b0210545af0056c0c65d504d69e45d572d529476724ed24f572ebacf08ea9c298e78cc6e8433bae5b73879c815b4dea5d394e409f8139bc6c25dc639d045dd3dfe33ed051aa1d888d8f85db51b677acdef23c689f15686febfa075769d49d902e5159ea139582e4fff60f47788e5e2f11c36622200b3466c6c810db0a02b643df4b5feb1b5f6010ad8d1db3c1dd9648ef8e20e1c3a75d3e2f7a4dbd3b1eb7f8cbc23667735380d0eb343416369b94068b8f01bf075e7fcbd4e5d86b182212fb897f182a71bf296eeef173dd89218e52b03c372b9befb189bb23dfb84d122630398591c49e4bdcc4ba8b521813979e23fe7faea18ca07d4245b2d014548d2436c733c484a377455a3bf04b6ab7f8dd27c2a167a882ac9586d42c9a8872a63889ced2593e5f52e0ad5e657140d0f1586e86940e42ec1559b95b008c5703e96d2ad74f81dc10be0d5db248d7d47831107a4f55b06b63a512342781271010c6b1822350d359a12c420e76b057aad3c16fc6bf35598388bbc0593f4037143aea2b935680acd540619a92af4bb0f4f21e280ff7f22af38a26254a25e82a0af73fab696d9b25063221c77a6430f1cf0ae6d202aeff32295b3c4286e32dd59f97a812fcb38df3644b8c601829cbe24ac7e92a0951b0e6df0f4a38a8c0257549531f507ffd97a510e3711d287535de754005542ee87d04230e8690621db21955c1c15da156385d4d9bab4e6641c298e9e571a602ef7dc4d3955b32869e7b26d60df783f7a25d40cab5ffdff859ea29bf4befb10dcbbe50971fd9af50184ebb9f6c6e1a8fe37dbdf7bfc47ede42162f8da7e014e9f16e83b7f8c34069c9ec94f6a1e0306f30157d9683d1e1c37b9f003cdba1a9cb019f7b889aab456affe285e40544f08434af859bc89937f13fe8c5dcb0013dc2819dd86e6789e437f56be2dc10eeda8c2eb9424fd6ad1a23d3083807e6c6fa429d16001f32ab3616213dcbccc3e8cdf544aafb89ab12b0fba55ef16aa478019fb4957a53b6d555e1997097ac191145ad00dfcf10fcfb01f59d18136c2f37b02748ac7fbce744dab5c82ee0910c7b505a274b1382e8f88c8336d9831954c566f7abdc7677d5976c169923b388bb5a4882018e456750aee73371fae3d7792ec00048227e93426c2b1792daa418540d7cf6294292e6fecb935f41ca496778a1bd13eabd5073af45d4a31bba6469dc35b6c0cf53968df209fe23d4bec76d1ffe08e8ad6edede18e701eb88f0c8e15868e9f839f412601e42932a1837212a55a070b62838c269702ae74936578a539fc6d186a83f749aaadf3f28e9b245d88550f5f44c766d3f4d9574fb964b4d2fd56683365b23943ce6cdde4e4367e63ce67a07e979d50316056ea699ac9f02d81a5af146ec244eeadfc97602395726bce870f07d28a1530d1f53f0d5d1580868c22696d3d4fc426e634c669b67a66bf76af9039d2a7c6e2dcabaf1387a2575b88fd741ab73e02c69ff54fbe0c0342202eef8a9b6b0148fa19f26ea86e17f12c7a7b398f35eec352b21ced835fb372c241c6810604c01e3a65e33194851449eceef0ad5e4f555b6908b4b36a622843898d4854de53478f1c6d824fbdfc3ac6d17ef63b823bc4429e7d6b42db228eb79cfb892e9814e36085fca64245003e9d84fb6d0fae8526a46e179d365950ce5dd11c4043213da4b81f17c6e8cf5543c45ad10c8f915c463a21fcae877974a3196bbc389861e7a4d0185e0f7977c2d0b4568bc132fdfe3ae061836f4f1e10fd8f5b593abd9b678b8a75ac3f66a8a19ca473247037bb3b76b64cbc3e9f273179c2b3b9f91218e75483a5048bea7973d18c23f39c55f1c7360db993cb5a0c0105c0d361691889a961a4f2f0eb4610823fd56c6f68ed99a17328ab5893912e1429378bc8efcfe9cebc8130a651ef504f7be1e52408beb6eae312df68ff5b1c35e2040148d5d46009a0243c7b82ba8935f4049ffd6e8ad343caf0cc45291c68c146d8d5aeb5cd2ec5f1fc896f2c5f98855ee81ffd47603a9e14d1baf4aa5837fc96f0716ac5ef5a62558c123cdddcfff13fa29ee076efb12e1b3fff91647e2691fd4c101e878493d882b4df8ddfad2d9fc333be9b5e54864cbfaa483d7b438f291f95fca1b530d5f5f8be9e928a8ff008835895233f409450a896239c8e15e63f957716bdd18b0f1f837d901d78d3aff29db29706b6c285a2a9efbd83ba8e8fb49816d184719db9cb3d4e8979430991083b0235609a12d9fa9d32273a820aa5a02ac966550631745779255debf36a0d0328f9bc22b13d670e553dc605de20d7241d1e7040a046db2da25c67699583a90ede83d3cf10857383131625e7bbce477481593dc69c22c707b97f0dd25338abad00e6da049f7713f355c12fa2daaacf0f6de430b428948f75629fde583d29ce4860b138df0d32b849c8ec5b3e9b97d26baf12a8ccd643ed9df020a3e1abaf6d6aac7b514825b9d3e55d5e2fcfe8ae6d0bcf637de3c29202faf9273f0deecc13f808e899955c29e2ea22fede2be7aed68a169a5990ff6ee1d5fa5caa3e5ff5e8d9a481be9b9ddb750c8f681b279fe2fea19beacbde2449932cef7c03c11fe90cac4bcdb0615665bbdb9e330171b8aa1153d7b8d54332ffa7e04b9f1d2930fd1497b9162020e0bef8fb9a455ad1d3cb822be3beeb883de8a552edacc3fa492a44a0c4c15284271f65a7fc54cec3637e2858b303cb835a4cb62a4cfda61dc58fbcc2b8f4432bbf1144e409000bb3a8ee646df95663ccf2094eddb65de9da0c7a4ddefb5ef61234bf9ff98d9dd3629aae505c7b7d478dc930770832a6e3fcca3040b71dd864b189241c5d72270f09aa79d991fbd64d66cff74a8b6f1d9b70aa1dfcbd15ad82c83db7b52161a7a0eee8f453efefe7d2b5f93fd8d24f67779c4c5c555c7a419f660d020e492b2355eb2ca69e6c56d286e656faaaaf6c9313ce6f4f20cf0c7e1d31550949a3f467160528e93edc836b0cd0ac34a8e3fbe0b4caf72f0aa53a2ee8f9ab4c7a67cc3e92e56b81aa6499054aa13c306a5e2410a7810c23fc98d1a5b13ceb819eebd9d360c285baea400b3d8b0c784c4e9b8ed04600514658bb29cc3c57b87629470c48a0b629d19d39f8dd1d4971c7b19257e768af7e640b4805690f98677f90e82229f9be102caff969cbf3651b7807b55e35afed45a892934ea1f5f464aa0d81df035745de7dc03b4be458ba2990943bc03102f1b673ca807b56f6e28e7cc12626608a2554fd5cd8afd76acfabf8ec38c55764412a0e27c488a1243c2e98ee0c9e52c17c5af87fa2f420e9b1dcd96a077120272323dbda7a373b93adefa67964166905eded4645e4eab458e6bb4c0d54e4b9a5f95c0ca3cf58db3600381db56d08975bacc2226c5b2340945c1f774dc7845f209ec393a6a7f86af05822523f57d7be5bd2eaac83a311a13e98ebfd3b9c2337e1c945932c8f97cbb86257fa15290df08cdd7f95247f6ebb0880b035e10ef4c53662a9e325caded24a144b5a4ac8be40b9220e032a6d20c79ba0de074a61528a76123e60d0d15c3c9adde4e5ce7b3191201073c2b2291fffd00b255df108a0c2fafdc997d45a09ed3f45f8b74a3ed636a146f8238c661a971bbf3b38088d2428bf308d332704ad8d685494ea3a0fa8e786ab244a3c37a47cf6d13dfab34370ed090870b726e8254795f904ae3753855500cc851c4fdc273d4c0156acc431842223bbe2f00f1e750260178a10a81dab5e0ef002b72d92a6d255eb6ee6982314fe1dbef563b772669e202bf50edfb99d41faf133190155eb3d52b289a0f69f8dd198835eaf5e054cf4e69ad7d6b132b9e6f7cc726585b11b8bd7b683bd96ada17c89f6514479bce37594c20eb4c0f724b761f3176f79157ecb89361e497f4809207d20233648dee72cca538a9a312ccc5211b986a677c60d17a1edbc736e3aa5c62a61eff544e1ec9715fb05635643ab40e3976b6d1a7e2b19c9936939b16b6aa6f89a80f3b70cb695936c2e686128959eb18da3564e0be9ce9d54ae96a51a42f22d1b20a3737fc3c642cebf4f1638241cffebe1268642eba136c9cfe426926cd2127bb40f23ffb4e7f325fa6e4823a392963b43fdf8ed2220f6eebcc7efb0a44a61f4bf9fdff3ca75627d8ecb004ce7f08022b22afc563ac116612225c1cbb27196609b73dc3612e15c5e43b63c3c0491e54ea1914fc049ede26e6c27ff11c5651e1024450ce5016a2064eb3ec4ce3948858ebe7f84168ff35fba4597b3aec0a5d6ff721ae46962bfad5fb5f1a1c06744a3e3dcbee8b3b8aca0f324b033e718f0ef30a2ca5e4211cdcec53a24d0f6426d8bee6e877755ca074de0157741ba81cd915246b5fedaeaf75f41ad0f537d034fd3258b3b6df4050c5bedfe77c7ef7d42465003927484a6975da13ccc5682d21deebd5b8f15d06c86d96bdc15d6535c145903a7bef2aeabb522a239d09d73b196382b78d1e5c3c58f36a5e840d277d8a814f6b4d604579789c551ef79aac106e6e89239977766281bd2d9e78c2f4ef99cfdf1a6a3fb1cd75ad035b45ad600ef5d944b0a872e30bc131e2e221b8f9392a75d6b2c0f0c1798067166628a78e16f7faf59f7b731d1295dec20a074b10c7f6adee31869cf50307ceeefd37f5f1d29511568abf6a8ea6b376eaae799e03a49a8e051f05f65eded3c3377d0d97d15ac3c99ae7aef5fe5e897961c3604d8356d94fc8cd93af8c9be2772b9a1aa70eee0c408bfa1b5e3882051f655e9752c0ae81e56f8ccb59618bca8f82d85d33268beda36604b084c1a630521012ddbbcdab6aee9b228d2bcc70ce3326900335e878e1dc8329c7e670aee30f13c72cd393b442ffd278cea3b3c0b43f22b657580e467076cae264e18b76967b37c772f88c89edebcb5ca55eb593e3a8b0de0cbaa6f154bcaf07ed0437844f6dd959ad1ff9d91259c15a91296fa967cb29e5ec1f84c14c3a1a63e49b59da079be62aca5c6f8fdf724259dcb4015b7b445515086f485dde9a1e32e1ef06f8da87ed1debbe35c8a02ef5f9b083ad0b6c963739ce695ff370771f9d64d2ccd729817d8ac9842157b3a585f482c6ee8ad052544ff632c540354551ab58ce0ef6117cc3ea35aa3dae581516aae5dae19a33ad5f552f39ad45b8b2ad500639d982484c0c04d812bbef57646a32dfb80c03e1daf05d805544347a53c5a43cfa4c21c87ac958a7ed25a96db00a1b1f1313ff9d80d457d501026799a4af6eea3ec2ba1477b5ecbf1c7d4035d27ed16020390b918af1c0cb7b4b2f7a7e2a6fb12d2565cafe206a606726a0d98bd6f4f934d6c7c6ac7255003440c47dca5b4e5ec5de65fd0df8e3058a02913231e8d3267eccec2e8c668fcc5b0af2c6a7e150c8a85172c6fa9e8ee547123f6a9423f3ca15989695cbe1f9366904dd0be3a1b0fed2b5fe7e5b7f9f02ca6ffc183e5a27bf2ac4ada8acb5bad280c2230d62da95facfb775e0913bd2a4b9034c5f52bba15de2505d24011175c1e9f238539dff9db1dd0d53fc161bf16ea9bf1beb54fa694198b42abfc91499cc76d360c6f72ecd3733883d1bbb3b3b9d19b6300372a0df2ad6a84bfe35104af7178ba09008e924eb188a0b8c20304e324738f1e50797d360798c0e0287d7f936be9e9cf3ebc172a230f1bd07459e93aaa96e86232561fe69710277f96d9baf0b56ac6c7b256ee6de9d685ba386c7d7831fe03ee586bedf26d897402e391afe2dc2d299f359fe7a1b52855ca388b9ffd39344f92a0ee7b2b36dc62172cee22beba8f44c71746b82db41e5407ccafaf1dd19d7fecc069ed4c48f71447ca4385e60c5eb16341afb4700944f586e989cf1ad79cc40209fc6a7709823294deef15d1227f0b84a232263df21c4372590203332185b7b6c21156b75ea9599aea5f7bd93c5f815b65fc90eea42311b55579d542a222bd86d1283d05199d32fd27723487661398e0ede36baa59be649e3dd60482ce2d946bbc371582ae07d756b033d1b8de28ae6f438ecaacab1a592a95b48ce6e146ea5aae8601d9591033d7d4860fd49e3113c12126798e99b9fe5e744baae6733985af7f7cb3f237d89a0bdb7ed6ae92cd387d188175f1037016d3a9730d92e7a11c77157dc2b0be431236ec87e14e8acd6f9d8ab61d051aff982f6115a55d0fae5d92e877caa9f9b9980b82f058ec3bb32bf72699a3c508379a570589ff65195d7d1d7e713e3824cbce1a79ce8f550b8cea1556a8f2c6ba98098bc04b582fc621435c4851236f324714b78800dba3ffe2553ca8e3b27498e53e2b0613997cb2191491c004b969b36d0c2be70e06865acaaf9503b703060cba18bebb1d2436d7d44bf4588ac7ec79739c0dae878166e982f06361cbc4d7bfc29659bf1a4366f869ccc6d6da9fa239a89437702863f33c2fc59b0ec3e7e865e9eb619bab8338ce290975e8362faf5bcde216bf110021317abfa1de5a61d91d363184930682d2400ff89762138de938cc1d20d11dc11479d660105fd3dfeb9ef753239b57e324109caf0530b04fcaf395f02c4de06eb9da317de90390fd505873d676334c993ff07c8d5f728baede2bc26fc1ea575e2f623d482edd1fb6a60c3bcc42b0c32dd994950873ebc25542545fb3c65d35175fb7e757564f6c7a0a792e383efdada964f3e63c198f7f69fa397b9c282f3dbe5a3eb165a6dce8cbb5d4fed3ebb0720e37550aad62578e647a73fdf51a97645d64516b8eb6ed7bf7d4e8c2291ede3d8e1b182b71dfc29576b22ace7663f8ddd19674af1872ba5ea7de976ae1b9321b1a221651d64ca7a15e0715678b460831bcd91872165d9118045f5b6ac0f651da91a739cda1fbaa28dc070d923c731cdef605917dd30f23aa2225738e09f18df76f5b5d39705b81222205181b6d9e760bdaddf557183647ce628bfe5b9cc76ab0b2f94cc712eaeb32fead6bb9960f3d1d5aade4355e4ce2e708aff85dd30cb53e05e50d5fd4a849998727225d6076ebd8f79e7ff179282c34961473ffc8ef34435643164067f5c4265ef6fd2221e0ab307b8bd507602635ab5b529ff89c812748b519bb8764dceba8850d7602add81dbb73436deee5d48c9343b82c8ff87c303eab311f30b21ebf213e438828eddc2d315bde1cdd8d626bee07d288d80019981aca8ccb2b825b1fac18077f5b65202b64c4c43794a55395190d1c43628bce1f94fc72b48aad81bace029037ee98a83006ddc8a718c73a32551a41f80800a6b76919a166a6e63f7576dca19fc0592210fe4ef5560448fcd86ce3cdb300733dd478d00ddf5272b95cc8e5c8ac2752d250d60848f0a3040347e528402355de0c84354e7b4ce9ff652faba0b5818be3e9e301b464061febfd27865ee9a4d7a565b64f3a63ccec71e395fbf7e6bcb069fd3f08626fccf70512e8a330d22601ae19e593ef44383612f9cfd765d15386f8b9eee8b231d0ccf6a482b7af163b1e7368c5cdbcd7cc43ed96e6d58f49cbc5f25984afe582cbcbdee3259f85954708a0eda87e3809188c60228f36119a84a48e5ee63c69f39ced5495c160daa3a818351bf14e521f2edb1e5096dd8f6407b0261753af20a331d32e5472a98197a1db4c2672499c6f4a670e2e01b4f515679b6d2f070f0888249d84e5d767e162b959c02f8a7cbaec689999ba393f73b03588fa63fd95d653bb4ae2af0f33e9c2dfe4a04e6374fcd6b96e50c110e9e288bf0c721056787dba61b645768c0fd9b19dca49e1e932caca697afe063fb1815226e64c3e739ae1bda93e4a704d5b7b527616b48fe44dd9fd8bdc5029ddc19c81eff46196a02c06524377a2c4114535138eb4920ed85b87d1ecac63c1fb8d29a879a932dc9acae1ce3892c7c818edc96c13eda941e1d2d18a33677f56862b1acf0bc350373e2e16e64f88b80a197a127192d98fbbad825ea59117bec24cc7c14a17abfac4b74c0f296d769c2a2e3370844b546719865767ad2f031ef5731036c6708f0b4f24c21cbbc01a6681ad0fa9971911c90dfeada4adfad8394ee995ec06c95b1b42676b30d6e597a78ff9ef5c0f9a5995e02ae2a2774509879960ebb6298d4da82e675b85a7e328aa03b2a9275bc279dfbdc9f7a538fd470355f27d74efe1d545e0322badf89cc7c2f466c7491057b5477baa159dc1a2eede63ca3f84e095f4ba26e59647ca8df662e6797264eb102b3164655f0c39ed5df2d97f3425bf90278c69668098964a1ebe28c6031314f586a3e52b160d400af9812e33f701553132dde00cc91f047c1e2e2d351e6d398643909af6bd9ccf5dab9a5ebef861adba769bf5160fc2555058b5ee0e4af1f5ac07c236c72581ce9ac556c963e286b2f1a41e8468ea296a0f13feb9cb77cef3e16b3cec722ab87d378d5154c4fef9f9091342a08f70742f051e8bcb5785f2d6ac48f26d53f97fe5574fda8262046d54b0c0bdb35b87666385d5f3b90fb6dd2b3cc106023e32f1e6bae8ea192bf4d076e8f51f74095c63eb9c40bc97930fb43cbd6f84912e20b70a25d9abca2730bf4ee76021843067f7bcd0fe44d6b34d0fb82859eebfda78c15d27040fed86d7583160215ab3dd8b6cc7d23480418fa963eea48434cf927437ae06df5e8e3c9c51fd0fedc4dd1b72bb93d9eb2dde446d3c32d7feda4ce68abf2acc74763e00c50ddd6f6c4035c5f8efe5e13e0e828f070b1676c310ca48412b2c6df508a9a05d6ab2b489e333ccf49f67614e1b8e61fc670d54d65c4a5172c692ae371b5b2c1a7747767310df19983ee8a87699414f3b7837303db8a0524a4450d66de9ae52326e6d43d1376b9d53ed2ef31b02f9a01ea6c326a2023797cf54eab67ed322a2a111eadc002c670e3f743581be0854cad50d0d43bfd4dc26a4dacfad33544a7bafb32faf4fa0ad2da161f74d9702ea7241d82df737acba50a72529865f6e33b7f231ca375d6d1be1f72200db745b9147f4dc07b08001030ddf9d912f225afc1021ec47e72315da25a319a335cc1ba51f5cb35947a37639b9934cd3688ba5cc4eae137ed5fb570a706f590771e51e7c6580857475e318a6c1fb92149c908e3156ccfbc1f52325ffe11a91799fe3c20e52aac8c2d27a24e1e85855161975b8754d84bc6fde7ce8313b57631cd008940a5a1768fbb16493582141ffd861371ba86b1dd6eca6e47328e20ab9368c8495815f55be89e0e984172453f8bb15fc012d89e33e8904cae9ef2eec3a6499f251735702bd29a1359a05bd937c9437fce41cd23d7b6673417e007ad8f3feddc44ce245ee1b61e4b592c5e009f08e80d7b52ecad0050031d9b4e7af9581dcd07fad079e29cf92327e952991cd7d854f6551da041b7cde0aa303dbf4136647d9c443bc574250108bd32b9bd3e4174d23711edcfb1fa21c8ec26df94a3916310f0f981427ca45e538bb661712b15e554584156033409cc8d6f1e49ddfded214ffadd03ee7a6742d0adc2a78f67c3c8ffe4353ffe3579719f693edc67b2b530d4ec0fbf011f8abbe433701544dfa59659d821340b09a9b3a5a22a729bedfc02a4c2c138565bc2b7bb47dde4f46278e93d2a2bd624c3750bcb53e9a67b6f89aaac978587a81f81a21802eb57fe402c9f8207a166380026f0368e6c1e977bc130bc2450a3aae5ea2b66e42531080a142caf49f6189c9978b6176597b05f74110e58dfbb401cbf22bac0c4175d819e92666a48b1955b2c7cb35a17456432be79e2a6badebb4d3f399a6f0728ab004fe70c76d02cbdc029cc52b723dcecaafebf34670e5c04179a3c10a6e0861454202f0aa9072c36f30546045684bf47291631619122b40ad79d552c43383f1620143e3065ae650d978a408c27c953b26ebbc63c35c6b523de51fb9e7c495f16cc9ffcfaf768392d867301280dc89bac2d6d1834102c61c41e7b9effce93e6db4330fa8ab5e2531645ebf6487c49fd03da3a61c4d23777b2c01eb2c7f70feb354659328d62ad2964ce106e207bc7ed1fa373f00fa60b16525fe838532259f4a4ed0ed6f056bb048a9b99c331cfcbe9a1392c6d5c78e8318bb566dfae54b2b6fd6d2bd7e6285dee7c73948f8540c50c7da18352f3f1b97eaa1b86132a78a231d552e3a14bb0e4b4086641101c387ae857fd970d76ddf536ba3aff599b0bc6a5f6eaa65f2f43657105df75e1067fb68615151a36dfc9ed8e7ff0bfe48a3bf468292e5a45e2cdcc98621575933f1244052b20406ac03dd823f753be49883a650497b39c58d599ce66b824c354585746eeba85ab1de6f5d6c07a5cf5e1458fcfbba8eba28b87d13847e95e3b286766eedc7030daf9858c92e040e75bf37bfeada5170987636e3fae104d54c19a51f66a8621468f0c487e1cd65b261679b77af4f6b2dbd35c461fbdb77427720ad2db697ee6c3f9c59a1480fb425c2eaf1269d41d3b3e25e458b15b4ba8254db22a429cf675955155bede6d57112aa23b06ed64745218e9cdbbaf9ef7ad1285cd3821c7531dba1d90eacb77dde384604005cf5c49da6edec76c5f7421101d4987d1df159a612935077e3173db995622c24578bce3063a3e53b6b21bf8f9089f7dda85ae221878144880a2f058bd39990ee38d7e2d48d01a486df5e0007f67c824b79db632c4fa062942609b5acd091b3876b04078fd511a4c701d5ec4222cf2a2d38e8adcf563d573b59e0c164e971cee2d06e767dbd67278064c87b06ce635b2c1d750c3b6a3edeef386c5cda105527e9262bc957a5e671f96b1d5b1aba22c7056b5f9ddb2010f481ce52dfc650fa8f56772642496b21616d9098b61944ee1576e79f090f1f8a430c06f614fd2487c4bd174d696ff0732d99033fb3d5a99e5357596db05ef9490e63ee1a6889bb939a42f94baf6c1e2895b782462809c06759561d1e0a28021c4064d6e1979001a8680847dc2bef9f79cf1471c042aab4b2f4b9e40b92df33ea198e7c03f603028474833d2c0183f2050fdf247617c709cd31d7b19ae18fafd285054dbfb92474e7bd3d5ce7102fd5f2bf7db62a133242e95763aed65cd8fadcbd1e13887c87b2a210e097aea6572c0f61398a58e9205ba798cdd0dd9a070f34960b4852ce4346d8fde17bade360eaf7dd806a3e8f4ee9b196832e625b6e6cefee2af5679d786859b05215dedb4fe2ec13b092d26f97fee4d29475d7a1f6d1404bbc32d71a608077cd2909674790005bbdfffcf0cf6ea2893d58fbc7356da051cce29c0dbb43d7222eac20a2e36e94f845337bfc039c1a0e37c37547659776dc13c32eb1dcdc77ec57a0455258044c699445ae134936f2c9a2ffe5b271ef432c270358b416bfc77f0ffb6ebf0ebda0f20b936967c66c36bb069a8c00c0e2fd5986811206064ca62a6951123f16284fdaae1ce9488094631c6c2086bc07d0f70457a95ee4d2f3c50a7e9c34c1ebb068d26512172301ac687dcabd5ad009ad8901efa0f50835510df6fccee968fcda2e3aa0785951f70ceb0999f167c281bc87f2cf92259664ccf38593730ece69b252cf0d4f63e10c162ad30a837393fe8854fc7422483a747ce07b9800fd36e64a4c76e2f71cb6d884fd80c00a97252a5e2e6ee2146e7cd9219738b6d471510ac9c7ac0be354d0b2205d91f06330e657f895d0e41b63d3cbd20b84e5ff831390b4d4f0bd06207bfb26804301c80b094462af857a11a999db67ae5419a610b947074169572be3fec0f49cd076b22e5dc3832bdde13fc14a93a9d006f411a6afa1e638b93162e7347a9b9580563c06320643b4b2ab05e4224885b89e41ba84cf6e388c78b0eb24cd4e35b556295fcaf85ad1f0483ed996ae5aba501c2da58acf25bd0e9841dd339a7ce506f7f17129df2f3442f0f97db8cacd342f7a31e29aabb9b79427e4279d5c41d966039b3aed66b2dad4d32c4ef8d2a9167591098184b1902a486a92515e3f0565f7f7e582bf0d68b624bbfa0c71458554b036ab616570d8b90d436fd43b54932a2c64cf59603651acfbae87227ee8cebfaee8ec46360dc022ee385acbee521182e9e7dee389040c8674f945b08a2714f4792cb498046c3f36c56c3ea05e47f58cc83cd2744928518cc60ab7ebd6b85870f7c0e1996ec0411d123c0560b19ee7080cfbb4d0abf9af14ff4b7e4b3fc6f451cc261de9456ae7ecd551f45f42fcbebffb35649bc17281589d33ca6fa1f1696f0cff0f664a401d8e84396d442a469b5005e841151d2d921d4f4d32135049fbdf5f8f308b3cfdb17f959f1f26a6edeae34e8253034e27aa008ff387421998d0135a6af80ad02cbc7519f0782f9a08f4e3954ca71850ddb288252cff300620342debae02513decdef79438f671c04ab07fa2a9482d9b2aa6f61211dcf8c41dbfa89e6fa1264b2424942f70243fe803d3d8ebe12cba66e4671a85b85cca94bc59817abd9cc3f227972c5f14f4d76c93efaf7d3dede21689bcf28ce216784c0bd14304a7146ab5a32a76db937a4cc6d11c776f4845923aa412320fdfa2a5c566830a36c38dfa491574207311010608ec081f82a71f4b14f583a1da15dff5f5a4707653d38443654a441f2bcccdc9594f8a1480839e196f9bac9410a83a0413bd82e2687d0b96e48da873ba489380ecd73d318b963e3fc96368bd782be5eda86e43448ef1d1f76520371f05f9fd3c9514778ce18ce0f70038ea4eebe4dac4121bca8fb3ed8c1c993c807b0625eb296e5bc55a6132f58820318cdb4d82ba90f727162f0002c1793a16100f6137bdfec6fefe74ecbb4d3482f4aa493bead512bfa2477af2e60e9eb38882adc47ad162ffd7c1dd5b1701ef59c080809c2e1f8eaed540510be0c91b20aee4b0742367206b30e9a89d16ebee475248cc41ee54f65bece1f75b36c46927c0ae24087a20243f16e3c36cd496c46f4b7bcb0e88355ebb4777d901f14d1c64770b25561bd39141689d1e406da48f873d667edc128c1028e19e0015cc4b71e0773b34f4538d63d3c723820fcfd5fa8c4af7f604b024908c0267374bedcd45580830ad33f692aec02bb1db1c0ec0a6cc9843c0b07ea78b7a64298ab3a507a8f3daa377ad24186f84a703dbe5b96790fc87a68810bf9dc80bd93c3965533f84c0bdffd9219099e048bf3b3b0d2621e251961fa19c6902f38e7760eb0e475dac7cb018527ec34647baf4cb07e55a2057c391db658ec13fd29f694582852966a5956b14f83a716075a79061510537f39399c3efa434577580d0cc20a749e7e8bdc550ed4afbca815323feb226d17dc1e0cf2200ad1cacedf839d3222a017fb8e81b6bc57c2596646437a1e74ba15e66d472d6ac93dd8cb4b3c28d874bfdc496cc7bc5d8a5b02ecdc7b4e42a4471931831b4930944dc95118ded75bc626e1785adde0a996395b1ae6fa5713027bedf58aa86fb5f5de5831f49603de0048fcecba1a9004b4811c46918e3e10dffe232d07b2b0aaa188bc1c2dabf907760899490b1f9d985d2582df5e5d28ec00f1c29b830ec975de10eb2f89fc9b5e3aefd9e25e49a8f302dcf4830c7b175fc9d4756abcf6ad84cdfd8fc01a68aed91447fe1b5e686b793b489bbe143542845dedf8b14be7aa3ec45e19e035ffdd69b32d82ce0f705a0b53c2ee943ced7c9c9951c34fcc7d73b937fe57afe875660fcc2dbf847a1c54da8265f9644d98234ad8465d71d43ad76e1130933fc6e3193ce45460c5631fdc31b7c3e71570a1b84d7a41baee34ad73fe67d6c7e2276045bc4d22f26c90dd4ab2ce3fd75fda2e93026e99195a485bfebcaff24a0d84b419dae955afe33828f702c04e38416d36bb9a9fad1bfaebc4a07015cabfa3a11c91cb751681f20760f271428c159e90e8d7b5e2cacc61df7bff05a2b356d6981d8a6a0b2373ba5bc47cb3c54baed19bd44f2c764d67add75d788cb0f84214753f5bf96efb586130e89a1ebf00ab2dbe8eb583b1b8c2be7f750e6ae0be0966477299e18c9ce62f14b516b58040eb35cdb76e5371d78c04c113c704c7733c5d6e210de798921d766ebf85d82d53bd5f8a7eace7a3bc7db3b0c3ce78f093cfe4caa44c5dc7eed59706903b453610996fa56dff88ca3ca14ec962e7d2ba9a6f486be2260f858197d2d35225fd3715477a7555d5ce9a817bd649306cfaa4597684221b547170afe0bb7172afe9fd49dac417f4177b83f5cac5a3d42ddf3a79bfada0bb12c02accc70d5efe4871129d4f83ffd108a54d3e4475a5072edccaf7e3ddaf58401970e066334987f6a424129945ef6d638101627aba7373cf6a5f502bac6f98def08b6dd16d9dba81172d8ceb0f77c362788376228d73ef0a57cc6aeb1628a1da628e596b450223256417b8ef0be418a736dbba9ccfe7bb4c07668220566df7aad0c93ae7dc9aa01789c8e1e2bdac255764f48606ee01399cdc2fde996371ea48f88f992aa73d8378e463c57bbd09a732cc41b5f69c29405b13b1618e594416adbb60a45f6bc9d17a1c8e97e29d547e4d6a503321f10093f3b38727f4772f7509de611eb3c22787f7daa007ef4d00db506239b22196ad5535edc822bc65f4410e3772ccb2ca85a280b0aa9bc6b48162a26fb373c1636f65c4c879c97be29809e2c52395e42d3d08a9435b443aa16aa67cc755ea73a6790df1184525233169f9201a2523aee210935e5592b994b856923cbf8869fcb452674cf697b86d5618621eb4a7c00e01a88815576fe2193b5e76ba297d56d223c8533824f7198234d38378c5cc2a3b4a297b48be4c9a4a67854983905af3e4001e88bb141c1ac7d9b34195fe14e88c74c443fd373c3de8d55cd173eff130fb09f90796b6efb1ae2d0937f53602028b2a942e144f5bbe9c0f25f3fb8067d7027d2ba7d8289d3bebe18a65c4f13d62812f0d74af2944f2101a7e09bc07fc9063b064d0d470089c5c3193fc148fa9677a198d58db6821255c287bebe477201c7047dd6fc3e002a020c3f668cfa3f80ff645c3e08c092f4e5224f2389b322adc28b706248691efa4dcd6a565512f107b1cdf7976f075b41fbb5fd04e5a448bb98965e91a121ba6f09b8c1e1ea91a8fdea7b825ab07c7d169ff129ac998a92a04683c966b1d13fa116f57772c4be8bfa8a30344b60fb04d2a0fa41a6329bb41aa416bab15aee4d04057c23fa59bea67e15fed24ed7340b760b9b97727f690b64b34d2bae6d3e411783e72db4f9dcdb328f731108e38fa9e55ef972d6abbddb8a13e5421db485d121e88ddc572250ad87c85f896ad82feb4af221b8bf074c87fcc26b62e41a85d36708a76625a592125f360713e43c643da87e6a951355a369cd899497353678f4807829a5ca0c7e810414b6ae589386ecf47acda71db4afd70b1f9d029ca097b3a246a5d074837ed2c41fd76f4176bf683d67e510f6cc60f9df68e562373011595a8136bb07b9cb6bfba809ff517b474829ca455e3f097ad4c2f129cadd0b876d30cbeaaf69f3619154ae0b30c3f236995b4e32389f7ee46e61126cb1f9869db071c67c043cabdb1d02490fbf8e84b6e7432e3609d4bc2d9eae7929438fe34478ab12d9c99fe49604f95527c4504fd76406221bcdc223c0fb33caf2366716703537a0130e087fc11a4926fc6dd315540e4fc0ac5735c3a31b71af985c7aeb83ffff44801df3281e52bf8c6c714e1dfa0af8f4d450ef4520d6e4963ada3c2b35bcd1ea77608fb5740170f557f0dc2dcf3934803b9e2fc2569bc4cb6d6d94102d02b3ec89f6527b7fb8eeff25c096215accde199c0b64a6cc9820ef76faf91935afefc3134e655b324b8da30e9ab0b770fd229713679ae0bec58b97416a4e08c823758f3e2f13800977e647ccea625f223be7d270d4e8c7e6e9186cb9b78fb40ec9653e6827b49a718d0e291a8773376bdd02ee1da89b0dfdf469576522fbece8cddab7dd83f61991b55e329091789468fb01326f9ff1c523aa77519b825aaa2102c2bf8ac48824c823bdae47d21c76056a2db676eb2e89741356259a4c9f1037c6053c95a2382d11046467507d0f7e79a9bb69b2d5a09b985da4f57ccfc8e422ac8d6603c74fb93be0460b282b559e4761f72041c4a5150dc3b7d4c42070b5cbbce2b28e9632b19365edb31f64bcf30b43bce8cd969fbf7a817d8460b3ba3968c403aaceb185aaf91bd6d9cf57b6b3136e9b748259ebbe7ec51f2cf57206b8c91ea568da971d0010c91833e3c0dc6da2e942d741d0d49b6f1edeeed27498ba445f4224c8df06dad57d9136343d41ba495ba01ad116181a0907482dd711e911be28f5ed4b37096","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
