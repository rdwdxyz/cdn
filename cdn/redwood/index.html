<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c67ec211d6bf5b1469d3bb4ffe82b89236ecc490d70214972f75100a3d1dcc8f6758cae8148e112d4e33009b4addaba998c5631fdf9f667a6e048c929e8bab19ad8fe09b5883eaf3dc4326b08d2456f0524e81f617506599721939b7c5d74016658903644cd2ebe4cf0a7a631797cec5cbdafb6410149424c1938a6d26b9c8265a1a2c5dd6610e4eb48131424b88c5ba5549b8cbfd64baeb6492c092f39c1662e1e2f249d6218cb448ae03527329099f9c12eb95b6a117e6e4dfdd5b44bbb59977e3360e11a763658cf2330f7e2741eff31fe042ac661220684cfb520abca592703a74f5b993253a2056468fc8c370b8c2b3e438e5b07128cb30635a13c645a296a53a84a53b7cc75d45d129adde7d42f2c58374c4ecd128d896b7b6e677808b735a903a2d6220e66e35d0d30c97b38ef2e5092f90fe8de161dcdeb25c274a80fdd7120a20641729d7e86d1911a0989efd9224466d1acc35d1a86d6319a2706a932aa2bb1155d5812bb8afb76e02d4770d5fca1529d79cdddea9466f0ff3915edd931ccbe460909dbe764bf5d99e89594c7245bb6a4e8cf1f6b8ffe916fd15a72cd6bff514f21d5314d53475c2363a7812c15a3e165f173f91a83b7e5109214c1ed0e567ebe79ae86a14c2bd7c09c6e0024da2b681257b8fcbcc1f49a218c5bcef3aa39e1eb64c7d54ae1fcab36aae29a0223c536717b21b8e89c844892b8e8bd68d88d3f8cc2d858946a782ebf72eb9ce293b2d5608c2b24f8808c9c061b15117c355f88f20d0de9bdff4cf183277822ca6a8afbf5e0315000e144be7fcce40d3045766e261b817ec614a1a7a7d1108ca6fd216502881d5fd9b265fcb0eb1301cdb67c023c5aa8fe6e2d391c0b80cfa0f5f6aba7f5f6128bd6f2787b475de627df4f4bc2183a431bb76e283d70cdeecd75e3e1333523089d808d35a7a3448d483e735d9d46d74599d4e42de96ced047e7cc7b71dd55d7b66b239e6ce1e88af214be592d4d30b9cf48713d11b5823adfd43c4900dd51a2cf4702cbd13e0d7ddaad34218ad9074544fbfbdfeb64b24284f654c0e257d8002de763ac4128f6a7f1c37a4e032a23391527b796a86014f14426ff2d59c8a50eee6c5aab883a3a0bcf6b00db3fb22a93a70fe9149f09050b738b93e2e610e7bd2b79eecd83bd444f437be3dd78f0d6c2d70448ba0dfc76d17f8810bd31565f625aa7973cd361003acea9247d7deadc38c8887b346f901832f879850b919004695085f081b2600921d8219c0244df010823347cdf304ba1e9e8efa21d8716507c01f7787863355a252a6fe1c2fd57c6c6430f8e2788407bac973d389bc2531814b14b84ea73a338c2de1e37cbabb6082041f54228d7a8a2ccce91dd041715dd95b4a913f9198f30bf9f94e965c1d809f1791d8a512b98a7daeae53b9090bb01242a15bf2ad25e5a820cd8b15c85a76348350e18a5c4b90f0a0a74283a1e58991e17b6d8b0f5f2a7965af22e5a351e54faa399f73aab885e3a812548f2e1fc27914b19cbc7559b2a9b283eb8658943b44b898cb435608f227b7dfaf69ee7d0be448a822647620351a69c64999429d071623e3f8f1089ab485eccc400023ac44af8434684564759310fbb767bb89b918c5e95392cda0fafc50c95991f13e1094c3c2ef65ca9aa0c75357e38ecbebddd624d4f889651414e956237b235bd28559d5aa46899746da98a02d8d2984ccc4aeb2922ff813f2202b7ebdffd7c87266d09cc04db3c21c60ee1f9a8a3d75a08c4ebd24d988a9bb507f7b3798a006a3194647e6bed60f041039dfec9126850387d25ea1e4dcabc52d2f7ab6701f5acb5208bddb35f8202c230cac5acc8ecf279b20d42e4630b7d08a522512db2ef53a34ce362c0d91f2fc9081d84560921044ca227e17039c71d068c60238716802c037d75438c3b3b71ff99ca7dc63e4d10c93ae4190bd0c61b3dcaa602e5fc305520c4e282add2a1eb65d3a2b39a91bb3b3e9b661d32a798216f204ac62650b9a9fb19a02f7e4b60086f60f8564a14cde17efd0dc9f3d1996ea4a89b04414dc9ec3c21a9d1383f869103380d1cf3e3ea5f96b66311dde303ab07c501a4f83555e6ed18d1cd538d6101a1897a39b85dc2a8a80e4333c2c46c0a6844445149d0ba20d0f2bc68602be122bc2debc73016723508902ba079589b94470e878b454e327f64e56aaa8d81f4dc7c0b8f30a608fb0aa6201f8bea3d07cd6dfb758653f8076f83f6f8ef977817333e7afe55d7377ae5ccbad84640ccc8011843cd60a2084c1b691e867eae0f7f8d73f3e76ad92c5924547c1f6e335defef0993463c0ff01304f77742049c41f9ab097ae9a180a52f4318610bcb0e320bb8952a59b32d8ae1bce376ea9ffad70835c9341586421c05491f3a8abecee45ff7b26d8880b269302c7977abb8f7250227d0c174259b17204c7a9f9d5b805f842056e62c30622b98d335a41ee8846bfd2d06118f2e1ffa4a5bd25ea04b73652e0d12e8b48283b0ece96fb78d0f592125fe71445692026369b29a20cd2a7e2ad3829c1d244681715ee853b7cb9593829d72db0a190b431ba03c63b2e9d568477593bfe3f1f41b0f119db0a96545c53c8ec96d6718ec59a9ee67b949ee3d3c29df51a8f0c1653c19ebb7c4357c496ddf13a2ff3bf5b828323ad772d3e6d553f7600d879b391ddbc84d8709d20cddd8bc721146ed5d078538b17f68917f467df2a41d4c4b7d8cc801a2453258b257e2216bad3f9c5b540782195c70f0bd0e5d21881a60db3f50638597f2ab4735595cbaad4bb7222048353dc8df5c10ab6a878ee2f359ed416b5b1c755f73d0f4ae73fb31c8a4552627d65ce9412ad5927954bb376a289f909fd647d6563bcc967835f22e8845a6d70d364ad434ecf5bb9d3bd5efce7fe66943162bb3ac41da4ccb4c77a28765d7d7b29b77633459fe706141959b12e43351b283bf1fc904a9c049c4d732963e87fcd9cea852c05d974b8a00cbd3a0fd207a4ff889d2918eb31626efa7ae6d85ed357c061447bb4008ca52651942825b4b53acd4aeb1d4acd218c74ef42f9e07d38c57972ba74737b180068075b44f9ed1c6604aa822152f220b3e9db964cfb0596385f3f30941125135524e14c30358884d5eef21996ea08dd5c0e398824669c9f86a70a76e164629f391affe917ae06728982f03ef954e8d12d641397b89e4266e345ca16259914e2dd9239ef288fee656a9c2f97a04aa0531254c6ad2eb39c48472b9f95d345689191c949a012ffbecce51ff835c03a36ebc9b6bd079a209deb6825ed3480af0808c63f165bd1709063e73939124b5f403e74452e54126333759efc615c89fb7224084df52884d04a2f490c52065b8c3065396209f0d84ef957eaa366480bfa276ddc84fdae42ef0fd22c4ac8db6d608bf73ca5fef42a0eb77ea458dea362bd0075eded4ef3bc6d186358262192ecc7d030ce7edcf9c7d33d99a7fb01ab13fbda5407c0dee8891e42b8c3826e7ff3a52180c85a8acebc0185e6b3cbf29b28ebddf5e9e1fcc1f88e859a1a17aedfe1cfcf98488c10227482b4274ffcd29bebef7644401d2b94848faa8be8f792a891534dceb83f8cb48cf0dff521e3d0b4b9115872b1c1d57695acba1a759709548a8c8a00465b4174b681d3d6b971ab536331630ebe7c1692ea7b1e6e3cb881453fac052c7bcaa575803eff78b010b7233e51a687038da100fbdb73a8604e10adfbf0ab2d5fbdc3ceb6140d21d854e00c377a3e87f4ddc2dd40d84e37a38d4d3525058caaad229321b9b177525a0b686217b331937ff1a21d54c792930b232daaedfbdf60479a66c3b61a62182f86b5e0644ea743afd46ce68a4936d13f3a7963d3cf75d9df0bc6634bdc73b6723d1dbc78f5b568db52df61a0d0e95e6594d16b333d530a6b6baf8d261d11b2b956c48c564686ceec62e5c42ca870a79134cdffeacfdbfa44fa28d2de0212b71042e7a18aeb64ef496a85614619b928754120692aa8f54b6d8df2b60790d441e7ebb8fa5cdc1050d528f35bcae913aa62bee202ea62938ae9e9038a55cc194e9f2ac42dfdb55a92c378e1dc1c99d5716948060ad184734a4d9fb7cf1ff845fa95d55d6d69d2bc58655959eff868db771f1834d90c5eb902146bac7aebe7e15e61d560931779354ec917b69cda1900ef84ba660261df73ad104bb4730f329eade884124e4c0a19e608396ad7ad05b5c32d0061667cf6e1c246820f67a847b4bbcd660355385e715aa65c474cc13462028d065dec65592a6ffa8ee3d5675bd4c08688f31af024059235f2fa8cae8e3c7d057d93adc69138517ada3c4d5dad94e24696fb1ff408a1575dc824310eeeb11a7bfc3276ffa9efa4b3d167a90cf4b3e3d733c17077fc8c5d2dd3bd311ae2d7e4c78bb9899e6bbe03b1f33aa897073e2221f1c294e84d9e10cf9c8ddda67629bc86b71a480c72bf90afb89daf85959f4c7a14ba7a1339bd0e488be5530287f3a1d28cc32dedcebb83d8f8421961196195093b117c900505ed39280c6337f8ecf358a27f45954717de32604925e39b3ee6d50c7083fc98ec230eb6cc6b6e886877e2f729caa3b89fb0e93a9be3c3e6da2c902fbb94e777b71be4341a6a88e709f156cb88cad360c0d127087f374baf462ae72baefb5119241d3da28c7f8c88ed0cec292483c42ba020b5707b98433ec3a2f7406205649ea04b8a06efe405c5b66cf9e563c333f27829b433a60c4068efde198ea390b249836480261a64d5806c2129448a3a0c8688bd5940ac8ed3f7af4d00e58cfadb2b525816e3fb8ea3697dd8d64570dbb2c546c2ae7817ff9ba51cd7b8b631ff006b6623ce786189493d1ad3e84ff9858e7ca7dc7fb69411c10a77dbade5071ad7e7d1c06c4a356c4e1a66815df8fb4b42b9c3f3ea72010d0169c966573252e6b36deb837839edc28311b00d105ee35ff97d890b1711d6f7e29f79afcbb6d48d94e06682630a6d07e67e72d49d046413a03935fa41abad2f7d27923ad373dd3a134ab9273027f2eca467af8627bffe7d20e870e0befe756b63d8f45c617ce169135a65c3c837226949ac545b9757ab5ac396a450f267a08ae31e2889c91ca7adec94ad3a7d0a2cf46bb0b48185b028757763fccdbf1d9332a8f300a9064e35664b5318ab71aca4ca746e9961cbb27755dfdc7c8dc3ace226a8815fe9c91286b93db2617ca3dde306cb555a22a93508d0a1b5904a065fbc8a53e767b8d31fc975fa65b5bf1ffcce273468364e29e2c488c99e343f4c9e678c8a65fa1230046e4bbc801d8fc58149a8e0d9770e1c9dcecf7d1fe91feb85b02d1f94c0748f754cefbe66c878af294a495d8d21ccd8aca55f46db854d46d8139e84eef274d561d8ad7f01ff5e67da5489b90bd0540581837024b24fb6b1fd6b37f3d2e80417ecaad54c29100d58dc0e38d797e5b7ba6abea9342d3c3894ec373bdcb42733d21f8452d978f5cb9950811e9f9ff70863c985fc34b6c90550786f50c8b02e3c48d61c66c181e06b0f4dc3edceaf3d18141136c8b9e43f3eb65c8f64b97dcf00f4f3e9dd02c6a8960ab6a9b2040dc3db2537a17d3827be6277f0d786a0efc4fa5565d2878040d018f1e10707cba3d719422a596dbe0e090ce27aa70e28ddac863a1bcca6388ab0c6385a89f5f391939096370ccf792ce0c4b7a2300d10c4e4edb9639f11984cc7d821b698e7807004cccac17c65f7def79c8d662730a9a7d63ab63b8dbdc22fc66939ccbc45b45334972e6623807d36d01f7db0670d445030d213f54247016263cee9c36e1e973b391cb6ffb95d69c9727c545171820f9bec75b42ce1dd7601de98dd394987f9c003597d363eae0736def3b0f16edc12311c0877d3976084f41503f21eca3b0e06f25aa35d9965b2f2ca965ffdcb8c7ecb1f993a87538f2024a55f511a872423d5892a7571d706d2c4839a55853f93d3706cdf49feae05d105d73b17761cd6ff14e6c34a751336ebc403e63e0cde3abd887c7ff2fc9f95ee0e467d4a4f2b424593d076f8157649e5bb6000474e91a5667c89fdffaefeb56e82411fdda4238c3fc1ffd7a9c44357a02b831e27a8f86d9b825e999352409d831eab6237e76fe69d490fc8e8726ba61a874645adad23ed1fa8f6ab03bc4810ba6e92aa281fc2de4d34d20fc3b7a3952929c33b6373333d03d9c7b8d41b4093b499cfb19bdb347ee8e91a8b689d4dc474386a9283d5ac0ada8edb85455d56fe5f54fef7f9e57c3f6c6ca8098c2f389de3f40d9cb913444934a7a3a4283e1da421d1e6a0ed3497f32e5c68596cd0ff31050fee3475a6233ecbd84c9e66d97f0cb94db83c827b592627240a43efb770e9e460f0774b3cc4389959e57f0a8829acf5679a364283bf9fd6b0d66795b5d1245b25d6c723694bd219da7f1fa5ac00a9cde0de06cad5aa30edba3f2aeb90ea4353b34e7884962c2dee4fa5105af56c1220bade8419e4380232d0004575fb32b77bac065bef8e405a5d6d6fb709a1b360cd1982af47236c44533cae6960aed3956717f164da5eba302ac3e9687632798f83ed9c2cf62f4c462160f74a6ed026d4d42c7816cd0314294291153488cf8070394ebe5ddfb8813d60f9a01c418bb50724b091d7e9ae4baa69efe014fc87a2325668b8881444978c14a0a1dfca526785adf27116ebdf2e78c60f71b65b777bae402ee2ef62c4bd0e2fd4673e91f5d25e648c065b306793bd9c6a525a906e8b51493f3f879b6389118c80cccb04a47797952a7191d250e778a17f53e20724ea09fe87f61085ab8e4f81e86ce6d67bf530728673ee5614012682a5e209e8e6ffa195cb1fae73a2dcb90fa386682b287d4eae90596606a68035a632ee8fbc622aa80b8d94b68b807d4b358633889e34b6d0563930ee730cebfdff4de91de15bc5baa7c3cb5c120b5a6929ca53741fd3e4767990d2c70e0871c85e893e342c35e095c33cb41f98cc88818c3a5c406d45c57f109d3613effb4d05d27aa554c60a9ad00232b9fd4c4d18be5ee881bfac8a928747079e0024c60922151bbbb947b4d759bb93b9266de8482f7b807b6e569e882d59fe59786bb586543e4f1fec5f1442d5b19356f5489816e1b1b0593639e2cc20a768de3369f86fdcb18402339166543d0725691b623283824fc795bcc39ee4bdcd5e8ad94b0a0341f7fec270a99394bfed71536e722c520a76da62b9c05abcffbb6b25a59e622e86ee50e485387015f799008c3b8f57ee17a33e6351d1b816006c6255266220f16897aa3207e20c635322e5a874291b0027c6033db767e185623dfc20c8eda3e1d1b123aa15baf8817f619874ed9185386c76108bbd87b9b10ad2bf01342e6c4f54cf13017d23a84a86a1fe8329d1bd529cdf63cfaa0e82810f641cf19a30d7a4bfa672d33526d60507caaca399f03ab327a9026834c416b88e6cab4a7e3e94f9b69aff74839add1f88dfcb92a2dacde979d9d566ac338b1d669fd6815c5260d2d15062b13c6b750a016ea467bb18d2e1cca0955a7a6551f0fe8e40e3cae7336e25128a4ccd3c7b2998e248512175648b67dd1dddd29f2e47002bdf8f3c9c2fa392b42d50b3feeb572a5508c9e3813acc40341f41861504035bd2f36f2b0b0b49fa8f6d1b52abb824ded1690eda865947c27331eb654721ccf1fc5d81b68caaecbe8d2657b1db25e5dd3e441e6ede0253f9205d30717f5c1f43cee637a08ed634758d1c419dbf49278bbb178e9e57dbcf1547c96c3eb1f5a11d698924d988090aaf99f2c582f25ea6ad3642ef3cf9c6d0cdfb5ec7bd87d7990b8caeb92d7e1602dc7d50c2135058fd58b99ce86909511606b7306f81277793cda5043e37a6cf8b931750ea61fcdf2b25dabcc7fe194f2b40ecdfbd613d3f4f6313f9363c475350f6279fcb56216c81356297402abc347acded98c147cca253ee3cb732dbbc19aaee5b85557b51e58e752f33f77527bc2949787dfe80b441bc64923632dad83cfa8f37abe430d40aa74e0b9fddee1c158f2eae15065ba7bdcc63d70043462b17d7c0ce993e3b9bdb9711df9680265900de10a50bbb69ffd5661022998839f6a9365b97713d8f9288f355aa3248ab2b63875c2f581eda12756a27cfc8971d6d3fc02c9e5c9df340d4e9cc6e6733e54e35d9808893213e214bc522a68ee95e4a821cf4a489e325a142f43891bb0de84411b064604806e2b63f710a080cf8884f173f464901fd979ea8f2eee4813dc3b0b8de9f59302edfd593e34819e09d59a3e70c9c854d577b9401b1c0304bfb3bfd20e55949ca34c23a945772a7fb61e4505a3b32b164ce3aaff327d9f2deab98237db82cb85f2c01f7d2dcbc44c9b53cd91e6f2cdad46eda14fbfb38a6b90540274adff0e966399e7c255965e56aa0ff7868153de39bc909e44969fe73b096a77812aed1b8fa7d853d5b67579b3f0fc3797f028786422a59eba6de24f829712b3c94e28e40698f5ace75b07a9c48d817bb153f0b4f46be00f95fd1326644e797393f017a0f4006df259183f2a6215fb74d4a9582e8df36e81ad188c701db2e6c39ddc3737257934d3c7b8f521a1e484c2dd9bf449546304b39b7c9dd0c8ba12dc44416a9b3e9e5f30cd42463285f0981503cfb36706f0b4e7f05d5b317c4df39cc81f9d15f3f6e032f681a06edcf5434864c2229e3803f6738196d3fe655c41c8fd009867052fb59f3b6fb4d46695304c14e6cf8311b71f2e22b7ce31dc19eee9cd361d1903fa9bed4df889db0633355810cd7001f1868f480f3ff1ec7887bbeb581a796d7bad655844552716fb4e3f5d0ae23aba168aab94358264e4fb10ff9f341403b6a2eff6447f5367e8c316d386b248ebed61790b7a76c74ded3eed73b7db1cb826cb7a871a5d4033ac482980035589b7a4154836c0ab593de6f5662a3ff5193500c1637c5c08016ae205f7c85328f4b25bdbbca126991c4794a920cd4a9a3afe4cc45bc657c1bd2f77a2096330dd9acc2a47d2e58aa3da84778542bc22c2ab4b4a9944b780c1bd326b801b4014fa7fe81e80117eeffd103a698cb99c761fa98e43c32ef7d7c03c2a89b57a65806e5221e3331970396e3818324d6341abd36bed2e46e918cbbc509884457c39a5f1e9dcc518d54e3933f11fc0f342d76d7aa063dcd8565935c2b2526c84fe68f7050b7778ae2e1c1e8beb8c36c6f047d483e526f96ba967d6cb24c82bbbc161bd6afd267e0bfd4844885873ee0ff589e30cd0f318b7092cdb532a7ef7f1ed965076b98fdc73dd8140a924dce7101d462bf06e863caba3a3908128b762313c16d6c6b92cc7e71e0b38e806f0416732eb15e7d186d2f3cec2efb8d335cac1ce471354aa8a08bab9a162cb058a75be76bffbe789f21157f36219d938e5ab5c7f9d40c255b0a7a6355dedf1e98f773bd07d179fb8b9a63d69a00fb2fd102fa2008666ff9f24495e525ac9a53165d715b5f3aa5515ad481b05635c802b41b0c5a75e3063761cb5a6edb873be500f5c4e7515266e5e94b3a6c69380da61589c044c0ba192deb663031d6e340231c5ba2de8dc5e86d6ad90e7d652acc40acfcfbb267bc0e6c040d4c44f13f3a948e70225836d704d11b7cfc2e81beb0b72c36c8898045921d03400fb7b7a6348c75adf73a0e2cd2f1916af3c8ac852c3f82afec076c104baaafed8cc8b82f8de9ca332fd821a29cebf36f5042ede0b65e2f819d5b90548f7f0ddf9dcfe249cb0d2204625ca2fdaae2e64ac1f19f679c9a1e2d77af2f3c55addddd1497350883cd44295925e97895a30d5794840234c97124a8a7cf41b740c0d252392603c2d74c4850b01b4f0f5392df65a5aea18ad84af4c675965e204a7f8760eb8fcb1594040a2634c07733175d7df77b49caed6355ebcbb4193b2568d18dc520a28973be4d435a56041b239816e52cecb2f4c9e7a168b199c2b8239e8289e124bcca351b7159f81f3099674588a0ac3ea341eccc74c261bd25287806146b7137efca9d7569c88aece20857695f93917f9317c7377118ef0a0656105dc4121eeb1f16f53ea4d8cdc8816f60100f9b34b6829940801aff3db9225468e4853a5d930372990a75aad4893c36954b39957902eb376a29c6a7878891fa8410194c2364617b8c51c04d773df1df3c10bcb86a719f7eafce683dcdaa0c6ebc90677a1d5c58207e457a4c6b65bc78926dbfcd264061374aec7597b9558694950d9c6478527407a2d20e588fff45d24d369f0314d83cdf57780583b1b5e9ac16cd27a2fc7ff229a4731d16f44b35d313bdc42688eb5fdc26cc77f3c7f0ed64f57b4856839e8d7fe6cd2fd23275a603f4ba98f42201579e7f72fb907fe54627b1bf22b6da11a07920a650d301236faa55b4a6bbd5529b6c07969587189eabaa48c85224ce10fa86dbd1cd0e3d598facbd52a8033333e43a635dac32804808cc6273e510a1efe33000e3a93d7a9535f66c4b4cae94986926273c60b30df066df6645f24a13835d2bf7e8c8a756652d7b2786a01a91ccf8e2ba9db82c9971c3bb3bfa031d8778d1b0d9a31bed41cf20f20520c4f72da90fd90af7e36f3726e40a478695b3782532d01b04cbc9c9a34995e79b8a6fd8d06a6d7b98a70cb1786265aace71ddaf1a0ba0c2262c8638d336ea5b08773d54dc7dc6d1da17ce50fb031266f7233a13560cddb2c5867401b9273ae4d7e438949e80250593f03543ee75ba29191bf83f7a1f2bb6508e3989b10dfa551ee2390efe8860e2ce235ae52c4a2e1aa9201a3f54bb5449f5d6bba6f1e69ac4d5a8d70c3acfac3d385adf7625af6c7976457f6864c4ab4cb761879a02c1d1b5d2748b083327e1340ee1ef0c14d70738f4d05f256c6756098446d89517075fbe3f58f8f983b9df2ef9d1b85f0b58ee2743b3819f5b49b09876539a1f67140e397364a79ac1fa6995ddb023c3c866a6408b89008483ee074a11bb70430394e801d54e67e3adb6203dcbddb7d6e9500c2b5b1411573e79f01b9ec5ac063597eaa8f8af565348334ff5c3cb21e5d08f762cd2eb05b07f9e0a8dcc529cddff9021bd4e8e76c1cf0b3b5e6c4b6b917e09533f4157bed9d9a7b8169b7a3d72a251762fb370ac545363d6927e6f41376ff8caab061d3f979a4c5b185b89fec954efd7a3aa1f69f1069cab1e9a260e3a63b1b9b9445b1e76fd230577e38761df3d294c3da41134f15de3a21617d0b21a74809e98dcddd983f767c65ed7f6ed68a735e96d58a0a4d6f795ce8d70beb1844f16be8b7b27d4ddb0b01bafef8d94979e943412c5be1088fecd7feb9797c9c5a0c3b2473b5071c5a36774ae12060834df03a7b0be54ac850d33dab5ae426cdd22eb6107ca3159b44bf9b6ad05f69d398fd8a09625736bf3a9b8c24152bde373fa4e084b0d817f09b26169112c954743226fd5a16a0d1329d3c4841bd59c25924bc934560c9934b0da870803f53b4e1169bd50a29f21ec3fb7d0ba3df2a1a479fec580fd875cfbff88e71990b879059f79da19885189956367c1d057805e39c029ab7b7741c554d09744197a36fb6fad52cc4c9d2e3b6e7ed34a59cf45edc3d547aaf3fd1a8e55eccc9d8560ee130dede42aea4f9509a4dc5b9a1b792c0557b1659f8c7e644706dcb07ee73a51230fe04d839f154fb25eee400c9b7af905c6287b5c4c9838f3185c1b733734f9329bde65063c2baec815ec0d65c7e7415bfb9a4329638fa45d71cfeecf62297e61c92b8f9833c35932630d57377daf32ea323fe04ee17489402a342fefa4822bd78177c72521561586ca3859d5d77a4275e28820c05011273b18baccb4fa37bcd19a83af8f78d097839e7c7f26ee645320420fde74c7c8d70650b588d4953cb2a9df88a78548129361b1be0051a36849720ca1874097ea49c19fd7404cdd586c56763ed5cd248d8c98f6a19661f740c145591eab2d36352bfad7a91e7546bc75271efbfad53c92afac1d830f8e4af2fee5ca3e801f3d6096d1eefd74cd9ef7886c270b15d21f598c1fd7721d6809267530f2e5853325337db55895f8a7777e10cc94b422c85bdc21e8cee49d879006543bc4f7204ab602a37c3263b2eaedf8eb76636ac6a7370a80fbc8409b8d3ac311948f957a5b587f9e3b64152b152662f85c17754d46e9c5c2b099e1a3138eb7225f4c2458b269707d9dc884dced338466bc6a965969ab9ae39c46240cef88c2c1bf1f12b35d48c14bebeea2f35b788bd64645961c4176a922c027d090de280bab0d10004cf079ec680de8ca2157561943ac81d614a354948ccbeb904164aa2ffce34c98821a4b1329cdbe00b02bec661b32c9a280daea6184e49861678703596642b90153b6a5a3b1dfd2aebd06e0c5cdbf0cee10a5af04faa916ab1c9f9a169eb064a2a33aff54f66f71f7c9e759d2e63506fd2bc9e1bb67906d8c58dfffbc3f9d4817384e86a77e712327791c162aa0e305e69cc9310b5ccb16863c259fafad143d79c89a31066589b2423e9eeaa992b4747895519727b2a76d5d60f3e4e24c28abf6fbd735f5ce0c03a99f3ff34dfd28e793bfd4f3088f17e092a4b7cdf62a3bdde6c12d139318e735b105babe54f7c5decf787d9a0ecf457705ccb1e5b5f375de020c70c2930996ac5b9c30b5836a011ab70100c053b01f71ca4cbb6e1646ab6ac2aa9342f89c26fb1de0b09384a8d51547006ea35ceb77045da6ce20ca9d5600bc5e2f5a7445da127650f1af2f5ece1f691fe755e6d744d26679a0d47e0d7b7bdc646e020d5dda45b1e19a5e76a731f64a71af167f19db8f034b6c0a14d701bc69ec01446d5b0f0afb2188cf4825d67c682fec31e38e8cd7f3225242be4d6cd3146fd5ea2702051214202473c954159e95251a45ac8baf2718c8a7c44f3bd2e3602003be4d3c6b4ea781e45d6273ae50c5ee061eec42cd6681941742ca91159289fce8714c263a4a7ee855f429caa64d2c964976ee8e18994657428eac84b984628fd90e6712082734bfbd8cfaa520de0a51219bbba2e9702e917486d2b8f2a2fb571897eb94de54a08b16671b8723212dc32ffd4492a5f8f57575d05e5800f8f91c8ba1d3f27ad4ee902df45dcaf6c34690cd70eb12ac287998291c281bcd3f00f0f64020c94d998efcb44317cd78943c82d1ff4a9e92e4a22bf69324f324a00bf0d62b55e75e763bff22e060368a71e994810b5d4e0c3031037e122fbe12dde557f0bec56a35b79e23ea04cb3a2029e56d31b5f8f1cc90f34a294eacb6be415dc7937377871485d96170cc7aeb5937b08d1cb396456e0e4d551677e84a0afc22b0b194fd16e8bebedf11c25de65ada9fa7ebcfbad33aaec96dcddf72f0ac47373703b7266bb4629ded64129538e2bd2924ab97e3addc8e3ddde50f0d9218324d2e53ffb3f747a4ae6ee8b300a4cddceecec192f60a174b7f80f20e4974128b3b09d81ffc870738c2092bc0a859d95a40afb984e673e8ac635c39c85b99cdfad8b738e3b06c2b6ec581304f2750c42612313fd360888e85f30de2ff55f05ec749214bbf2ae0999bafa2780390a58ba3744730a72aa9088b30c4df6e5bbbde154b04bd86e38b94bcf691819766f73e2c614a08eb5ebfd3acdd48ec69bf61a6b9d17c22c701c526da7bf49ea377a524db9f53bd5a5cb98d460a361d36ca06fa394fb7671c925394fbadd8b082fba92ee513aa6e7503a73d156a54a1adf8ff581ebe2cb2f1a35684189b04d2a944acd2a3a39eb38bf2ba178eaf207235efe09ea26594b0da7edc4c2e47692e287e3468734171328a432dbe55617cddfff703975d91c6473d4522b869da227b85e2fc4f86a5dd950452556d4685a23707457377218a5aa59b749abe7dc0308a40a854563a91e785ce54ff20210bb1c0f91f37919d8367345fc06ed130e186bbec8ee0a27bcc56b0aa0c4c44d71fa43c63b5e0019009008c5574edba6f92d381120cfb1ff697081ed1170f7f148a6f164ab1d1d3cbbc7b35bdde4d769460c7eeb133982350a09a3670a5586a5257b82bf7addf4e76f89ed3a928bdf4258d1146015885822db166dd56b987fcafbe7fd70bbeb449cabdb6f7491ad522f6b15ef3bc2252f98316fc34203839e15e5dd63d30392791188ca49503c11279a7d904e6dd956d95c75f0745bfc664c5e14b85119dfe837b489e2583bb0a217bce786c321cd99348b6496cea608ce86939c11cfbcea01272bccdfafe1778d48d55aff728919957fed0b62a00f9f34c012d1550c01ac57ebaa30f8c38061086210fc160c09c3715098f9239f864f04849ffe57968e7f193959cd463fd46f7b0e6c57316baf00cc02179ee651240cccf55eb6edf55b80e431493e1e535a0999dc5709e5409d4bd301b14c3c5afedd8ae3d0153df56cb34df6e4fa9e3605d7e68579a897d925bf36b4ac872b1cb78540a3db24abd43a23a3762ae24257b5469229e3f73d1384f266f533014f1a1704858ce284728b5cd42abd3aa60f8eb5e61f9f0e5c47b1a18177ff6f801b94f98af7b2d6a8729e4c1dec3071485051ab91618d3f912c72b2c4985f7bc1e6da4a19c0a0c27e18e195e16002025c2d6ad5a5c44cf8cb579dedd1b6ad810599c67c772d7f4236c65bdb6c85452167d3854b8dcd9b85e8175d8cb122e42da8213449cdc6d019e845ec08298e6e71e2d48b3942dafd37fca9a52811f4501ad0f84a432011df25a4c976999baeea5a056b6c427541da71a5b302c5f00187cf2274b5f0bc8ddc38081168192da1a1153266e2bc1ab829684d679fd0fc3df3803db36af20e7089ceb4d88d9408c1daf8cf71aef5ca88c32e669a6b4a1379c6a3f58faf420dadd7b93253f793c0090e3f90652021ee98f9ad0f7c47552fa0b25b7f340f107cd1dd1a25a88fd8b7b41a026989613a9df85a96e7e14ff9de03948bd98bcacef53a6ac0b20219f1456c1cecfb4de787c6473d04d951f288f7aec863a5641d21d20a5707ba4ea97b43a37f771fd0e5cc0d9aaf62960d002a394ad319bf8eae73625e00a3fd5eb1268ad101154b4d631755595f5225695bdc7f09ccbfaba807026bac0a033d869c2f4ee298740569c74782c1c24f832fa41c5afb504a2c1a68b4a45ef227525eff29f6bab4c9d1bc739c5b6f5b49b04dd05783cea86b1e457d160cf9f9c6c75d74768b7085c5d24be4eb6ad60407b58d5ba61badd24e09b7b7efdfd250731553e9f5971713c25f923badfe540e706ddbdc109dba51e1ec9ff9a6436053068e26f3811dcc8f1d007eed2e3c02e41b61d9f0199c4157a5a7cfb3bfff4623e5412969e51909808806a2f0ca25b256d53bcd6005b2a87a789c9244ebefdca1c77e2876a3a449a82af8cf3bfc6d3d413361a4b5349fdaa37c359d7b1a6d60f2dec5ed23504524d75fb2d6dd235e3333abbf9e5302873478e12125f08a7a29c6bb4f8e176e8d59f59689f269d12516cb62a4b7b63672b46783b75a8f6ef942a9afe135d6cf4c327f3459b4c80d93b42f3d200c3a65bc8e8216e343519da3331041961d2165522f89e4e0b7876421ed0f46c86e1f0e49bff34f6051e8392294107a3506f88ea64c739b5b6c5803a17810b1c0ac8e3de38cf50389308a9ccf05c14684fc231110a5c0867aa7331c40c62a8bc52ae6e8bbbab0def1d537e6b6ee81b790232a83a3f9b6dc844f41dd1266e591be9ff7675c9720a2382c9dc482fbf456bd05b6ca84c241f900e46716754727a2060c6cc8c2feb68509117c5ef7b2fd8e22b16ba9b4e129954f6b3eb36a4cdb3a2944afdbe797c8d5a492e4f73002ae25e0169356590c3746f4581469697bb3eb5e87ebaa2eb754dee227c93582a686f2a74a8e2d8d97b554192f9da590b0aabfffb5019e4bf814d2130a592c491ea8983276b6a18c7d62371b52d373cfe925d77fd52a637491203883e7ab9b219eac5937c7455c05c27462a93b7f870934db586bce8d3f33259b822a503a9730292b5940b761136cc72eaa168c7b3c55ace2373b8e956780625ea74f8aab5a6306070e278bfc0a19c45c43fd92b9a7ade3bac20fc8524a0a22ef69d1e9f05193081d73eee60e12e411faac28f0b02f25e0375025ae28655fddda1f9c4a88f20674d90e2fecee16dddfbd7bc58ba77371d53163efbf7c372c69f956b2643ad9c8dc01b7110f3a49166dc99ea8aa31f4447faf6fbbba2cceba93d0d3481ec26649ffb41239b2a1b4d3e72f2f9eb96be7cbabe910cba40b72f600c387c04ad5a15b7399ab1abf08deed85419c435bd75d9960109055bb0c5d4e2e5346eb6e47a3a1af9cb29810189e142a3628d41923ac850e774933161a0c6ec6e27bb16d3f58239ebf5035dfec90ca2e972b1dfc4dfbc89f2ab00b7e44baf1d937eb9564b615f7c480c578d47c33996e8f5e603bb6ddd7d1aa5f253d9557734cb68d6d7a8d90c779958537f8a90bd9bb3d1ef5a6938a95638e849dffd931d5c90f60af9142cc4dc5e6b07f3229373cf095479341046b2b0efdb645ea2de6cc019cfaa1556a28c89ca121b70abf1b6abca92388633041f035a14730a1564288451a059b4eb657db5e626100584c6471e3790900eb653643a578e579a873688d8030a9bfc9ac56491a13fc83fdd08769b4261e10dbcdb3b5fc127b0d1332e7ed42b2c03f6121bc329a0339e09e7dc4e23bfbf1ec571a212048f25532e04bdb2d04099f59d9fc84ada72a0f797847c864b24c172bd2dae34b1f48857296dab09cfb9399d3475c31a8b3205384b72a2e5bd7f1d6c4aa50437425d42aa031e007d1f3c29010bc1033dbd2ec36a503d27ad0dcc41404c62358958ac58af28e7f0f23b537902a304ef71fabfb0d1bad37c42f88bb4f352e97482192ae3bddd21e38434ed91b12f95ea3ddda9311f98d3737893276ad282a4450d598660917528dda02632f0840789c3f4fb4186c61faf9cee003f6cb682007f189829ccb6619dd449e8e09cff79d8da7a5fac2634d7703502a159611216b54f1979a9969986bb5ccad9a338f7cb5605fafc36194ace3d6ba8c22db999e65a5d7548497a8bbd8b6de7ba872bfbb0f1bed1b608f3566c441cf3c4f275744935632ee1d13964ea4698ef1158161a1f9ae378a4b0a1011203ef2719b6db7bba036e294ebec9b4dba9c01af7a7dd7fabbb1aaa3935c454240f4376908613ec660b27fbe133d6ef7fa5285361d71f51de0d74bf01c2bd16eeb40ed641c9c495bee92d0802825bcb67390c729d7aead8d5f785defd3d6876387eed27cfafe87945b26cfea8faf81ca9b3836f5f90b6ffa2e7da4c582c9e465a306ef4eb36d63b65d1f0c163de2404dbca75f9709599bc4829d88734c1f40dd9fc8642d10212b6cdf8088a3bcd04c2c3af259238aa2508b23ad0a48f23377f3e0561bb9182d0f87eae18775c550c3cd9637a34fcb76ad2c4c5304d843bac639a392ed785bf8e56eab3a34315071fe36ca4afbdde23465853e1eb8e20bbc0f2f29d158b413d43cd28e62b3b951b188b27ab92e1c782483bc838aa395d051709762292dbcb9bf5eba874b7fa76734a194c2008b26e528064c498f2a836f84a353d4350efb92cb69ab0e768961fd293b412b423edccd1ee61732665907fda7d971c4aee8519a81a03f77ba506a1188241aaeca595d46277478a444837e72fe4633f8562a32c08aac3fcf470c5358c4ac122fd4466eb7f7b21666dc8e978f17c6d3499a1c82d53c85e093afd28b4c89b58493427d3f2ac3648d2d6b3f39ad20a57962ae1e7ebc2aadc41387d80db00130b8678e9c0a6b82e9b02f80e76310dc13c7830a4c668556b9576544abbf9e30044620bf666e0a694fb51b1d9738f27225cee13830309a3acd4eb18ecbabb339cb40a4ead18b9fbd5eb38152bde8f03695a2b53c859c9ef506857af58858792a7f588bece4da90d89fd05a91f3fd45ad6ac494a040f1b26396f7c7a58a9aa23983918711defd6b8b5c8fc73caa9b1fda76e4bbde2e758ef528e229108d294431e79b14962bfb9261f9229805fa622715b412b1c9a9dcb82fdeba627f7790e3a80273d5ed7b751ba62","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
