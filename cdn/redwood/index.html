<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ca1b603e06037fd43f2895d466b7af3bb791bc4ed216375ca717c5b4fb63996efdab920dd616543664736511fed2b8f05f65c5d6d1faa18e61fae1d3be02a010e578da01be40b410cb60c6ba22c16c5a3a77970da7b0531f3f89b13f3dc9a05be6c68938f3d0b61e284e8f08a45d7b4e8af2383dc348655871f2924a7b52144ba56cc327ebdfc0815edee813a6197d4aee8b1f83b5326a865d484fc1afe46d5e8179d2738d27b28e704e5194ea3d73df6cb036b4252b7ba1d9ac61a175134c4e4a7744591f3e7fbd3b03692a01a1f6d0b281175ff06ad79713ef444b1e90d28699c7fd29d79e3706f8bb553db96f9cb7c2a2e16e6b3225fd89e6b44892cf683037f0df9c31d16c39fa828a1c43b3d1e1c1d3e8fd33853a8c3a54211e155a2bd0c689767a69a906336a2f9aa957c1571f5faab21443ee1c990787927d2898a94032e31c83bcf2779f8fd0ebcb4fdf073049b0e96df8a298f715af36dda96213c6200aa26380f4eeea1c425d2cc4fb4e653a88907b32555f0114814af6789f44d7eda31d53daaf58e7b3e8d5c3eb6e1b44fc8f8d57151b9c1e410f292459b7f3a3e4cbb5ae780edcd9beb7f9d667ede2aec18645eef4c8089f95363b0b65581a4a37c374a193f3d5fdca9402afa3cfa0f56a20a3816ea634d2399526be333383d461f33338faa2d2082c0dfc6cd1aba8edc43b4b11429163bf73b3ed81bd71a588455e73b8e19d634cc8119b85fbc52bed82ee4db3ef895e0b42a9205c0c9bbcaad3ab9204cbe10a5ebab53d89cb8a80e73b63e8c2ca90bc0b1d532c34d899377fbe3a895bb73b0dfdd2377aaa610ff6b0a7e3f6d7f7ffc318e074f1bf4449c7d9d75603d65351a4d182b654ef3ed09161fd50c2c1763df78e79d5831db6c92d5e84d53d1d79c8df9768276b43975c21dee6a9ccaff6070658e6e8c885632f9d7a982ebaab5a15a790a30f54239666eb5ffc2fe8801c6571968168c7bd3176c09a94df34d5b3c11e8463a40fffc445c1e72264ae26bddd4fe9416e723a24a7d57029dee6ea4eb0c5148d502643023227508aad4c4cce492426a8d0d8f8ddb5b9c3d9091743aa37f15e238e02af186800d030e110bd5fb25531ecef8998b94b04c7d03ee3d272e4cfd4746593eb86616f70ec47b1499fb229f97233f1824538afb651b838b5cd13690d000018022ae4c922ff3e16ceaf5608b878f1b8ddb8e2e12938f6bed265c3845fd50ae5ce68767d08226ab5cdb657f2908f65d06b39e0b44ea5c0d3b982b3dc23889ae00b8011035fe94786aa961f690d61019095a3ea9684a0badfe060a94c25aa0b907641dbb166f5050f160378d59c4816d7df0a73db5945b3c1683c685c94b7145d4ce3ff5398266f079c1e0a2eb9c6e2044cf07689227c3c5993498c1c8bb376e521b6e2dd7bf4164693b6e9441af7885fb874b8689ed63ffbd8a5aeb6fddc718e926d6701bc911411a05a5ff8ef6e44de0bf1d10f0238406da97f02a67ece77c260717258fa62e1a8bd94ddef665be46e05b2b82a8f815d3123973c87f100aca20a282235664d7798cc6ddca23d1f14d2f1decf2b8a951c53843682246c00cc7ebb62c8745ceaa4e8c8f17c19799273b18237ecb941d7100d8c1290c30d83bc25249b509a68a86b99780870ca88904ea9e06d196c1f670bf7974abf0d59d63f6ffbc10a686e7a183fca67a4d72d4a270d75232823e57ff5885527c43c9c1b2471593dc915dae1b4a6a80deccb0cbdffb737487b3d5d443cbfd991fb5986f33a78fe604eef66a462e50ca73c5489a038bde35955d230c1e8f6bb190b7760d520f43cc84595e0cf1c2a031da7ae577cb692469a5d1f7a4f262a12675014c9d3e1404b75991028da17d1d86c42b05b17a43657f002f51aa374f5610813ae271ed9cd6ef0f9c55b2fee7c7175b579adf176f7858e6f32417afc39120404df29a483aca288bb3fbda9d06b05aa742f1efcf1bfb290e4e042460563f63185890f78d2cfbeaba2514c736e234b2316058448ae6a85e613d501fe94c1e6d66bafed0e12646071848b7f3b07bcfb625f0740f571d1add6297662c60c6461af090de45d4840811136af93cf6159b9668814eb2c2541a0d52d86032b2e06960cb528d30e040ea8dadd50d099be0cc2ac21f60879582c2a7feb7d16fec7676e4eedc12d10e82562fe17372c1f1e9b959d140f45cbae4bb94cc6bf4833e58ebfa0460ab07ecef6a77253a264ace6503c8cbdeaab87112c64639613d513f32c08d36f28a0057b460b9e051e02a6d55b148b53ffd5995685eb357340eb410191622b0dc4cce7c405bbc560309fbdd560b4b4f978ba842b7b8a4cf7f73f30e27d0aa96b236636f4f19ab51d8a6b7000982d88cc1b8abdebf71922cf91e46e85d6207132341e23750321b47e0c2a0f59f7e4307e7b473fa2069ab8dfd29bbb84778d87025b75483c939df2219251bb0ac3f98666e0e7c549bb578822c58e63fd79a1b678c4b3a17872eca2a60a96c3381928741003880831bd1f8e55f02d683c0e3661703b95c3b5d164c1c0c0b2f45ff9a0da10ab97d9b4958c5b695f4d49f469aaa166b10d2f4a3399cdde28b9b35ecba70187ccfcc6cf2eab3adfa45b1e2b2d26c03b4d12aac7a4e46a55c5e5573d91c089fa57b4b36291d38e1bde2b3f6bc1b0d03a2eca181af5ab57f3f11e4055c17581c9f3a77f07c6448698f01df480ab5f111ac7690b67387da20d4e7aca8ffb3efb77763f63945c6555a913966a2e96c3d4309976ece31ceac2ecc31cd008a7ea6226b3c31e10270bfed3ceab039a126e00e4ad88c16c0cb9645e2ca3549433ea9caf06a4fc38a499926bb0e471b93e19c3f49f94ef252aa117bbf13eeb051ac3606c728fc7bb66a15ebc02dea09a864d9ee14c71ba8c196d97a3c7a8d28d64a1dcb063e61b79a8eb755dbbaee49f26f9ef99caa8b07bfdbe8b8b794e0a9603ca5a4290ea3eee4cdc82793268f453dda0ca3c6dc5ff98b61dfcd877d7c3b6fc1846cbe6b0b93130e788f7e1c843641d61d6fc654788b2354930dff0c1589fe05499c47c363eddcbf5614b712b31c3e7fdcb2a13397d4db39a898e1de2f46aaab0a528a9997275df7a2de24f57f35380511e9ab517b07fe57eb445ee2d4374657cc16de3bb7f3c6f7daaceaa7989ca8de0f125124accef59e5a0d4a837f09f44f2a1746c7c249a0c16818343a0094716fe18e53f086bc88733513de25abe3f8b2a7ab1aa723a0cbb0f8d76614d379c0a1cf4d86fad86dc2215c8c46dcf86eab37935428bf8c6b4fafcf521cb4e6fa0165bc87d3ff08afdb2d3ba9ebb5ab4d27ac5c1648aff226c4b7423a75032162cb3d63b76733e95f41d9b7c66ca3bf4af9afb2fd46698bc66aa6b37bee1e572c47507052fcd05aa1c6a7b44c9da3abe9d1ac05220b8215b909165a73fb0dce9b4065a06e290af7872dd2fccb5602f24dd790041507f437e28fd1984bef28d2b219b12360fd8fc546a8fd0c0167659065ae4b673dd0a956022ee71e5f920cf8a48dc9489beace7717430641b7b125b9c96c64670213bb3cb2774de6b9f08eb247d3fae84f0c7df8162a9413d13b2c72bc9a5bd928924449d975cf0e6f8c5d8082a4b8e3cdd7b64f8d2cb2433463b6f3e135489a0ce29693d566093e2b5897a8f5f51a24a88d3e77b5b018b6a096a7456db155f0376f5ad03f887c1cba5e00f8a0b30c3c99f368ffee74d8ade3dda7890e8e9b593da1c71391ee0db5554fe623437a31db354dba7b47bb9f6f9816f186050a25a5d48621419f97aef50884c5f5a8f17fe84d5ea08a699349cd9bbfc6226326a12b974aa1ecbbc928cc4509d08c9d15f75e03784a1d97809d36af3e24ffe74dcd6446e1d5d77c471218734ec54232ff475390cbd2553e132bae291b36f07b1fcdb07868c1b4d4eb49eadcd4b01acac046d87f9cabfe39e40bfd0dbd62a2ebd789dfea172ff3fd47e178bb7120fd51acb27dcf5c95f817d078935d9e1cf86163d45d43046aaf68bc30c2f2543b20a18846b50935c7ec2390b7f3d79d4ab429b361d0c743cb066f6147bc7f15918f6ffa9bbdbf6bec043654e83234a699dfd1d071b48ac894cbfd03e93b7e86d3fe3c462645924db3c2cbfa27f23eac86b20ecea6fd4685ce9e9e18a7cd147bf29358a6eb22101f9972fd59aff84c52a2c5abd3a623c4ef2bbfef52e3d4a810732871ab00a9bbd918a1bbb3c132f7405465253325ab950920cdc73886de2612fa4c4e9a3e2ec3b25d9024edbaa05a7cad3a7c05aae9d9f64e67642293fd25477d3a2b94ca6eda5085a5a17ff57ef190691836d8fabd62ca41e6f7a208dc265396c9b6959880aef7c393a12f0f49f84d791ba9ba599596410167cfe5bc75b8bcc703f4389a41ff6ad48757feff0f1c97fced11e429d6295b7a293fde25b73e861efc094f5c013d35702ba0d08ade473dca5315da9edee47056d56b269ce0639c9b4845f1a56d9664b20c670b4282fe6882a1a6f6888f95a23238de72bd1aed41f5e853c02d3fe44f77bbecd4174495f1d5446097a71fcc6305a4ed9007a7cb7876600b58d9d8878a40efe594f758293ad20ee9683d21bb30b969e7ce5b19695afbb37d2ce81b07397f1b0ce0d2bb3ffdfd4c53a3062653c93811062fdb9c63fb964519323f055171505d0831e75dec65089eef124c71cc39aafb8b510c57ac6e008e43459d894f5c9041b314919b2e00f7933dcbf4ab97a958a845c3e4757124aef62ad1077f2e9e8efb552b2f47a5cf05b888dc15566aa4e5b3c5490a4479da980ee0bc7ee3436c64419a7b453fa48d190c65c0475ab0a6ba7fc4c2a2b09efa284255ff28a56f186bc8d4556b920dd52142eb6f1be33a397cb48c48718ddbff78d20931486c1c19b0e63198c2cee0534c0a11901f5964c25da17e99de106c08f86ec75b6499584dd55239aa540ce4baec38a856c4df3564aebae50838e8c6c3d75a29973350d38d9d4de3cd89f83e81f0884fe7e62ca5d8248b9433f22eca2131fea84887e8c5faedd3707fb2bb33317a24ed8a7be64bee6649f3551cf83de5c916a9de3386720c09f166cae8b75f2ffb00982069c2b5f28eac363fd0cdb7644aaaeee7948a6f74865cb3214534689803bf863aa63b59fc8209b2bf3d2e419359cf3cdf953928c6ddaedc140c53ac0ed592454147d9a9e67f1462e9d164b09632c019df404f7005bdef34a02a3ac41895a93af432e130a4edfaec58bdf10b1b8ec0a265fba8843689fd17ef9c0e8aecc0c1315f7a425085c317c86c142550c4e8ab23976c2d5b3736b03d0b346b671310e0af2c83dda263f4e97bfefaa010e0e2dd700befa3b634bc0cde97f4e2147730fc7c3cdf7a3c3fa1036f3bb1bce944cf8ebabc866c6dc6e6c2552632fa6ce077b2882a3f8e8c7d3fa8db2b0d1ba38d60993e9468ff7c955ca45c7e46f2f725b93738ccdc52e0889f980ccec05f7d197ebb66402501849d41c4fd9da5995f321d61c43ef789d5876e5934861b34e1303c5871bfc6592cc35b9c4fe6ca1320fea7fc03e31c99814f904e82d37f18cb5ef62e27cc46862e3e2dd0e082ae5b14ecf8d16c80083274e92d62a29325a58061087a45c79ec52d75cb857d3fe0a2e55652eed08d367370fb4ddeff94a38ca1395e18265e9f6ee6fc8e548a324091bf0b84bb52f9ff1249364e224487d75a2b3782d486831eeaa47ef1c19dec792236711827807c8fc9b05722063b2f198139b19bfadaf74b182f8d4b5d572b612f5eb9360752e7843895f5a4b0bd2bd696dcb0e57e51a865a83b390208d2f5304574cd0dc6a9f06c12b091f9cab9d75928b38fa79fd021ebabd9a00e38d7bd30d8c7d5763182d4c4119060bda07c4b5d5f6778008e37f843674d6836ad8c2490cd72945ba14613e96559e1fbb9a11748162b4546529c21d56103ed077116dbeaab3960e5da3d9ed78618a2916982cf029f32696f20d90139b8872f0bf2d8c373912c23a1e5588d758ec87f64b33d956a0b3756f5ca7d90d25c5e5e817dc1cee5997579baedcab21dbb81d647d87fa7919ae468050f7c5f1a9fe8fe7fc39007e6c5a59bc0f00a3462d669c7b80a8cf3015662f62a8b0950e3b46f5316346e355b71850d4efe3735fd3b89a10aa4927bf987198942e4b62a68b26b92d5b2be555d18eefd0579850ce55f1b1ade989590ef79a0fe3419e357c48f2a623b91470d646b31eafcfa256cee12d53049dbe4995a1f60ab8d45e21e03284d412b64f67f11f3c96f25a37d2f545bd9ebbd0308b21c802236a68052ab2fdb91fa71090850d05dc3c27694cfbd9c223798611ad5ae43101afaf9b33e952c02770ce794e8004249b6e109d5461bb9b1077f2c048853eadaa3892b7f394b729bb61c5a003a3ca1722c7d0b45458e162f1387c713ed1f54ad0a5db19e5c47842992b44664dda71fe61e0678afe933f7b377f51b1a39bc4e5d220c818ba4083e2f6b6d88b5deb345cfea0f3f946e30e4b11c07b10b005a2cddab34c79349e8012541e5b08ccffa45a7675e5631cf44a05029b0a8ad1a4a175fd88d1a9104e59f4d09bf2b7a98361b26af447eccda6a692afd6b993afef72b430a46ec7f2560d43f8782b55efdaaa3f5f53322c1effbbd229f8f3972b1e36aec9da17f9f1b17fcf3e9d410e43b0c00f565ccb433c2cb35d20aff401b72f3ed73e0e38f77296559641ee2682606574a9832c5bc47ec120671f725cc4a2a5f1ecfb838bc50f528d08d00e1b85f90e49e714ccd08cb4795fc50b7583c01a6fd5795ac02724de88f193ff45b69aaaf3dc4c50e24d982a74d7318f583b406901e589a3589a9552d393df7546fc11d932590fced7c25096b4c673258fbae0dcfd5aff09ba7858c7dec5e72703dc9d102665a55b8b8620f49a046d2eb9b66ba1312f8bef6d854d59b9b89c66d055b7efb9724617a0a64ee2bb2a483c48cea654e9f852523b630bda38b781f8e2692462318ba386d1b905077eb51cba29a9010ec581427c9d3cc5b5b17b182bb0c082742948b2928c444e3e55b132785ecee4cbec1e4d2368924143941f4d17411a18827525c95279dd1c4957cb02838221b7051af8aef74b339c2a86b123cf96d115c77c9cb9facb2847b57ef98a7bdd2d09e79cb40b0210c03988475455ec4b64aba06bdd42f9fbdc7f3192ebc5913cb256882f4a37012f97f8ceec9559d4aaa8eaab186815e1fe2815f5b609efc1ae249fc252fa7d80b036422f0789d66841f9a8b3879c13cc95826cc404cdc531c22fdf7122028210fc79773b3ba74bdde05fbe64b5b68772b9559e06450c13aa1131fb63fd8e1271d3939c026a3148047955efff2403a919ceeace6e0f599358af6363c8620eeacd7abb55e28fea86dc79596e37fd23a354a14d97b4e4a317af09497f2095eb5b9a4132ac35a3f6e4714da1ecb5117450617c89034ae799788d7c68ea491badaef1b02a656fa658077a3bed6021b7b6441e15c40b5b318c3dac34447f31df2a257c63ab45c5651ea03370f2e7d4bf3124b09331c829b669eeef6f1dbea78e84c740163e53e75dc8e495044db8bd7fc0d73ef428da0ab9b692a4a5093060fee572dbe206e1bfc3a0d9bb4b2080de19e1d88e59a53ce68d7a57bfaee22792032bed85bd2618008294a10b431537656bfafc42ae8dc58ae11608723e7bc2d5b6da007ffadc7a0d205b9a735a4cc427280fb811833a81c3acf345e4d952108b816f52fd087610683b518b7392e8f177f88a0ecddc5cb7da984c6da62dcb39742a347310d36db9f5292703c80b6821fd8e94c86d00aa10658246be629b3a1e5d198597c1cc56205048ea84379b4ab5f794283b743a2b54993dc56bb6569645bdd1f6fad35033a6da2cf441d5af5c6e257a8695d0910e485dc2df3cbd748f3ae8a9e834ac6783e695e9ed3c3bcbf1f1682ac8445355dd8a70475ce9e17757eaae241bea370d45408b4a190d0ca6c1325d185c7feebac26d2ff74a89d005b848299f52afb313e3b9fc9c342a2ded314454946ae736378cc9c946173f2107a58cfd0b892912c9d14280792b37602fb6cd7466236cb4a4a5657355167eb6ad6691afadb1d7acf3cfbd49d6419f713dd8e97c29feee9f47c17dee8bac8ba8b00dce4fdee5c945f008853bccbd83a7b6ac20d1dd2a3bb9fe92ea32dd9f4e75b1373aad0c9f288b07844bdfd9ce445fecf69b2a61c1b2409f943e6c7e896d86b0b7f855c1aadd30693101595848199ffa2b77bf03cbfaffb4e485250e31fcca4ec60f07ccaa080b01d33695d8aaa80027416778e09943bfb988f97b6ab0534f966edee4c05bac6dc3b5daada172b89bedfc27a3d39d3e8e21d8f5f3d06677aa8898354980278c8f20cf23fe8c45ed469b9e9c4676966629e28204e83444ac7e9b4be8823d42ead3f66c1b27e900ffc688d3a2d214b160dde3a9cc9364bce3ffb25a5cf053474d53c2a0d9b7580760a00bc88599b0391dd6bf3b64caf3fbea4ccdbd9ed5067467f2a2d51222ba8ab4459858e592830c8d9c75c34a894ffbc56dff0056d5541f0b3cf6d42594c776f178eedde833af8417c7a4045bb50a39bad862a1e032bccb2db88903d8c9f0848e8d5f10d84441395880ab5675f3ae8a9e72f381a8af15ac9f3b714c5e92d2b9fad87914c38b433402e4f86598296c782b6eb4564de006adc335f0b3d4a639aee438f678c09d92aeb662b2bef91f2501814b039e5776275c5dbedc085c8dae0bf3af040b7196cf0bb9e5507fa54f48dc4c08f7da798699c85b6492a013cf4941a04bdb45cef85346dc3262b682895d782bad047ebeb00592c56cbefb46432b7588c9b7d4d8831beea70b1e610352d58cac3761acc18f6581dacd942d279b7b072d5be0a133932649909c420be04721a94029400f502b1796fe9226460f7e75185048a4dcdc982bddd64c835efd7fcd7b1cd2d9dc3367ef37ac673e8e7e441f26ce9ccc2188bb39db221b9838e6d3b11cb5f265fbe04e329c639379cbf267581ae0f4d5adf1bb698eec4c69fece5550543fdd6d8c9c607292ea1d3b705628af69cd20832e1d3693cb451b84b855faa35f7e33a31ef26ac4a162d140e51223537398d25b2d8115e44114f23050b523baccb1b1c805931d06a151bd8698b548c8dca4a9dbc4db6ece903d239f075bcd570fc1154869cda38ed8de83c640040536d9b3e846d610e63bf0fbdf5621bbc5c09b5167b5ba7dafa8fb469c68f35eee90b7047cdf9e9493b4f524798a088b18babf6834a5f3af1ee35a749af1e32264c55e42efb198b3c7ceea7d6dfb904c2615852d4df6fcab5b25a1ed48ea33bdb30ce106c01235934d2d942e0117f1798713efdcbf63a377508ef90d8f11468a52088cdcf22b1b8b6c407f85da60a9e1428d11f1f53cd3a6367fc06907e33937cb933162f9c5fc37a9139162997a272dd066d36b6a21ea551ccd0dcb0592e148a6b3e942c87b86a1eeb06628c30a629b650d32a4d863e03414ac25175a9c510f91f8b29ca3592ccf54238c4d6da42791e9b484e8fd839be355b1858c5cc6ed6192394c85bf5b327e6cf77e8373c3f7c5e61868d88a163d7a7dfd9b53aa98134f317017a4cdc7301bff9e8082fe8cba43b007d81d5632ca7145f027af27cab9887d6828c09d33ced2fe4e508fcfa09f0e54a9b54da16aecff7cc9302b1e86d61f37f4590460ad4ad761f4e54abfa3054018360f78aaf415dd35fa8c3c1baea4833d86edd9c0efd6bc7ca44467b4111e1d86d202f7db53f58b6f259b5aec53d6dfe8f723a728ad9c12d845e4640818c7ee36623028a387ccbd05cca5640ba2fecc7b55c84914c42e70efea894fa6f7364d9d3fe2434f0d5b8a80b3923c03eff9fe3827954d14a551ac23cc7e8f694a3429df641bf7e4aed3f9de5f0f42b1cea37cef9dd57dd00f7a9a24e555d52b02f6a18d0bc5bfe464d36844f5ad535f8e7c5a34d2dac1cce5a520ecc6c3ccfc8ccd48a68134ad2937ecb980360dfb4e442789050a7e1f6e1892ea54ec6f99c9fd0150e1e351189b758190bc274690ae0f34e8f7adb1c0ae6a86d8067dddf7e00472a64bd00eca45b289afb2575d70120b981bb44add3be540b1bcbf447ca1b31f499e73e10401784320298acf771241a46051dfb1b4fa5956f3d4e0032f05be835c912b0e5c4c557ac4874d6452528841d14a11d1d13414aec7623fb75cbdabb87407e7d2d474ea0d00c96b2b6fa7ec415a4107fb9317728c6b09ccf8286cc7445babc029e7a218dcfbc7e8ac21ad4cfd19fe6a393dfb27f65adce9919dfa4a90d8b26931024fb5e13708b44dbeae65fa3014b54adf0c9b2cbdda7e81b395192dabceb299aa9b0ec7ef7717eca44a76f4bca69127c0df36eb22d276ba0b4bda4914eb545aa91d65476a7d83665934e911ddc571556982ce9ff8f2b4b85f653f8fb2c476b9094ffe1e92a92df3431f2f1c48aeefeb9e5cf31f309aa18db6e4e0508d2a6af1b7a56b8c01442855c9f4dd470f11cb5fff012d58b87600520cf9c4b277d9211608c50632c24e688caca00bd27fd1802d8b15f64808e60c80b4ccf63b22026cec74e3e9e8c1adcd89c60d475f54ef77ddca0ecf1908c395044f95fd27f12d433f0bf2f6892f35563936a74f44b3f1dd193be43b1f95ae0b3c1d57721a109e14222c658644c1e895a72e6242679232062bca699f6a00e4b9f36e686f2c8f3cc91a8e13ec70de4bd4ba689dd5a2bf05e0186f2d8a0ff85c2091739fffa8898a95c7d6c106bc36c8c9832e457f5a17d5504547437d67a4c02b53875b3072894e989be43b7e0889575c98062ffaeeae376cc5a20ff4f113a92f53e2b049d3fe8b60b16d81c8119085866b6a9b228a003aadf325186d2bb6887ca4f66bb939ef9c645fd525afe486794a20f14696e92066ff739263f0d2ca2216c5d3843ec71b163dffc55f1d02f9378fe0ef830329fcfd2bcdd8f9c6fc5ddc45c9426f1998357f88665a321b0bd68ae627420e043d5db1765395dbb98c82428d5be3ae62b3d49bf16dc79d4797bffa8af9bd33a4099c7092a1c28842df66c90f825d8b000de50e19c563726b8cfe78cbcbb1b4168f49f777ea502962dc624a48440ceaf0de32243a11016ccbd6a41cf56c05624275f5b49876f9374739d4eb5a7a55e57a011e63f366ae1f655f2263b10ab5d169c8024180550ea19e3f9f2978d95c927c474cf86426eeca122e1158bc8e1305e737562194bc07b37bee99d27423dd39a0126589da194b76a188225eb4d2fb620c3674fcae2bd3783df043c8612d704c81f7965bc392683644fc909483ffa568516b358e6e7f8007fe59fcda532455f77516d1e745fb42cc87cbfa0c88b6540d6746147d246f895dd771b35e94847363214e4073369bb45b3669642629a6f91ecf47acfd4d53e9055ec8cbb46ee4db2a7727d7787468494a7b40550164331b27021b90832a74a27c3e801fbd7eb4cfcf96da13f52098882c76c4e557aebfbba7770d23227d647c1db633c446839286286848ac89db02eceae71723e93f43376397c8f182889bc0ace96d83d6996fb914052a7af31b6dd35a36ec3951e6a898c6b1bb60ab1dcb0919792b6a50b171621441d85d2b35cd70988521997a54861788b03dc175f4f05ef9ab39e3cd25b1d7bd64ecd366c9fa56334ac9b186a933e9beef7b68c090d8fa7f8bc151d968397299d3d9ac54c589353816ebf2d15662fbfa1e09a37a1d30d3aeb1425a871a25590a8d68d7168988ba00b16d6e21623df1d1023e5020b6b68d9bd1215346222f15e1c3a8d528b509a8155b4d7cac6476a959a28adf74beb50cdb83d1df91a7326d615543e89887e8efb47e167fbb0f1830ea1b349f80ae3e74e07cb381dc31357b9df61469710b5fb24fd1d89c3647f2a359780739e80dfb500bfaa942e69cbefee4102700cd280ebd9f14aed34fc3e06fbfaff336e5cb3bb1a4e6c59dfa98e4ac34445190fefbf4929c17e208b2e55933dfab91e3a2033032ef4d7ab2f2d411f18039d96dbf45f947d980d56547d9e5ad789dadcbb2e3ad6fb0d0e2594356e2b34c54dd61bb69ec470d87fda36de3e492c5d316337fd5631bcaadd0437f77d3c862b281a4ae736aba0e7c6500c1cd7c36c3743e89acb5faa74bcceb1c5e0eba9d4b1020f4fe18c9c0dddaf9ca79bd33866d0e2b52c40661e661437c84596eb175814d506ebf698640c7038cd20cdbf8af227baf251b73073096bf982b2ce648f4ede2e1de001c068fab520b3c9568cd48463654d8c0c94fcde1865ab57693480530aafd121e4abe2c2ad2640772521c79d7db8362cb12103be4e4e32aa6b66b297c7801764bd62bb7990c968c96abbd6c0b4d39a595e742a9960da32dc77d77f795d5c2212589eba0b1ec716a4f15ea589f12459bc3686c3d1c8e461cd12215ec3f3fd1c61413c7e690c99212de3eb6ab9151712cab5ade6b87851f653ebe1ce9ec35e4742e99c5995e7169b7a9dbf992a43ac8f6a40f06f03a9bc40ae190fe4d5d8b2ffc94cf87f6a742beac2061af016d2363cbb182ee3f7062d86581a3d04173987446ad54f5e7cd46984451d4978de9a82428790c6e4d978b538e0feaaad1ba336c3a04dfb9dc4ea72c1813990b07089db6a7b9575ccbba95d5458aee7b679d332668732432c45edae1c0c1999593cd5c64316a3d092839db6311c328a897a86fcbbb6866669dca1a129bd07cb60479f0ec853e6a768c1e415fe5e96c30439349efb79e37a7209f32b4563c7d412540f8b15b7ee4d6264928ebd5721906c0faa045134450da5c26ebc9b688f9dcc528a0e9800242a51268d35a005b86e17f4791c10e5b975e662b8db46c81b35ab116e6bb9392a41df66d0b772dc5e3e7fe2242e2fb852d04750f333d71e55d25ac61af97d8f44eb554cbffe23a866ab36ea26102e75b404d26b3cbf7272ab12189d7fe2bc92362c34e3781d794549a04f68d2eede6d979033b0b6bba48d05866dc94f1d50eebf1676fd6393e2927664d9540858d91a84a4389297ccd3da64f26f85360dbda68d164dda066e4e55ca568680eafb29497749235bd0bf2520e07bab898ce9b367e0e10f99769b8508c40cd8a11f706e03b2e01eba1652c2942bcf09d855ebb806c1e0e6b7dd939323262023102a2c1839a05eb48ab3ac8821add510132587e06a56597b1c6a1f3816a33bb978067d26aeff11dda014ec27bf224c66dc79d2bee1bf375db9bd3df35dbd518d7b13ede2dfc5ddf317684c77cb8208b90e13c0f4ff101cc4558cceefe982e6e8703dda4ef86c0ec0cc741682c006e7e8d0e21209f8e273f3a1cbec2f4c807b860edc326d21f85b9288b7b976932f2b6f781e548f7aef7ec7494ed66ca34057090a961622057b5ce8061f5d0dd1dab9e39f28577935c0566918a8cc69110af39b1067659bc7b15bd3c08c94e5f0fdbe669b743d59d88fbaa10a04d3002a522a3722dc8bf913e22830e4cab8b99313e8a91807de9ccfef831769c723c856a65e29a096708dd9b98ef080ba8a24f7bcbcff7c3886542c6e99c6f20f736ccbe4a70ad8fbb5ffada7efa9d2370d1f1164e4b57e63278470b138c4ccc82cf33d86582047592add9513a744f37463597175c158b8a6fc90543d993b592d0619ee905ff508aed854f9ba45e05d9ed88db8fea4237bc850078717c5c1a47d2b10333ee51171dae68236e7c4e115bf5b6ad3bf6ee9ed5fd7ec5e0ab983073d8b1f125130299ddd4b62d9a12b7655234a8f0f9f87ccd35c10c0a798723ad5b54a6295872159371c74121117d294694fd13c3c9c73d36da3f83184cc75bbdecdc7028dfb646c4b3673f3145d43383a1ec7f8fc51c988899113693f6d47bbd6647690be02c1da1ac6a1efd412f91a9c0307f049a4b11c730a8efdc3d0b98e96c7376398ff4f89418824a9c84dfc178b787258f763bd5741b8214d6bf9da7831b8df31f0a6e746a3a09a25b00db952ffac10158cda17c483bad86e1512c735c86629f3a32b290c26a5fc284d81659b7f306835e01dc0a29a8b381fe10407a58ec89a8ee4af47ba1cfc557d160882aeba8cf094fd4fa5ce9a3b47840775ec6822327de67db50b738ed289b933b46d0303e7c7494be123565fd953b5bfa0290d91f1ec46db88656ef0bf177b950d369f4073404ff123e9c0088f66dfa1567784d75bacb41902f390d36ffbc257f2a8ff12811da850b5a192539591d4d1805d4826ff3e891965048f0740637ab87b6b47f5b631028b6a8a2ac8f30e53c069ae136b22aa14cd17a0f2a62ca9ac601552ec02e158ea2d46bafc5b71914504f0c658297a251b9a6232ede141da42a47d7c111e108692348f2fe22f8e6e20e04901e884436c6210064e85ba22d2359634cc0f6b7dc48771533e3df71e951b144950a0a3ce9cca9c14a3f361caf5b880e075c2fd06428cd3e30957f394a68d99517ba17606a9c2c514e4d711ccefc36aee63e6aaed5b7b5381e50be61eaf5bf7d493c75ce055e21706a3c08a4431fe739555fcbc53d37dc53c60de8efd7d66b5149522a5df10819cbd0c24f91eb581f2d7e8ed6ef11a8eb76a83f5493ae2178ee3abf754d0f5d51a9a847c24b10cbe3cafa2a3d1f966bc5ab8ef96ca4147cdd7f96bb26fbbbc428cb2d75b2391d1748459c75c99ba85679da8e311d151976821872ea450ca724ead53aa0ddd2b8a5f341388ce269f174923d90989f6f19fa50ba597c9fd47a099067793d13db882a6bcc31257c62e159d9b74bfd1c7a714375d66bb2775571a4804d9b38253054b90acc59c60f7d4878d20c77a599f840cbd7f13458fa04e7b87db984a466c6a5891962f3742675eb653441636401d71fa4d70d2ef0aa93c5e70f9b33d55af31a1f47308301f64e794fb70561b1b4ebcd178d436aa1335b824dfff45c62b6c8f8915c87439de72c2f062a040189a4bd9a59417061270b521b19e542577aac0a594c1ef5d4991d14664a2dd7cf30874b47d1f8e64e0b44cfa48988e3ac5355bee823b25abb80088700485d35698f4a378a47b893888395d919523400ddcca50353de521b82c1ae5eb92ece03783c04c7d963529fc897c38438f6e97f7c1829f641748bf41323a4cc82557428931c4980dc63b191a66c129d5a5f1436b41eef44ea043feae2060b039481b9efb556d0fc049cae6a51a2bee56fa7d7f4af0e7b7536243e487cc3e79016fbec29d519d1b71f80785dfd2ad7ae05dba73b523409a4f759c64439436b76acbb6407be1c14ceedbe349a4632d0ef77ef70f9ed1000f597cdb10d67ed0a617507a7c592bb451f6067cf0a316ae7f8e1b30d581d20be600237e270c5e67f660a51475881890bf9f04809a68a19e77dacefd096fc12c79db25777d0becb10908945fa5815d5a0ff56b69bff7b21cad41bfcbea971a2cb476e7fcd7913c0a3f514fe783a838969cba53e4fe3d34251a6f562dcffe0950392088252e365eb30ee1adfa9115702418a398feae7d827abce7fff452bb847db89911e7f6f4ee289e58868a2570387302eb2da603717bfde27d0049c132fa7b27e52fe159e9050a830b2618c03cad38131efaec57655e7186e85a7d7996fb188461a4b786efb0e9908b378d768606432ea30593eb8b8ef8646c4d3e994f7d59a202741c8376c7ca882f0cf1696a2dc85562a77b6c0d7c7add0ff4940faa6d8ef54048c8b62d9b4b65fa56eead55eb0e343ef37bfce2b3ed3da1f4419921c8c5476f8047d2e1c8f3610816c9d3dd1c7fbc2269eaf66da6c593775b517b57c6d862168495fa3ef6f0c0868cda8acdf12c1b4c6bb132dafe878391efe50178cbde6ce55507b14867b25bce80f52819852434c92e2ab3b5e28d6f0621f4cabea608af812ff9ec3ef5e2a15c6d8d23f92d405ba7a69bf7704ee40a31111762e47b217d34d74d3c1cefb1fa139cd66d111521a6dd00fc3923423a05b0ce0c7bbf013c1c1b7181f3010987aa684fd418cab487a250fba5fd79c03c8eba4dc9823726eb540ed98ea9661480aca4308d4b2985b6a556aab740ff825ebaa702328dfb6d8741e208612897e8ef02bb94f0a2454a92ae16f59648d34241d5b462d417984f521870ef9710d9b343650f0a9e06aa1b5ad1a9bf3e409d2c186c6dc66e97a9fdb99692e300c9e4b7c815eab8756e2a8654918f96d495a850b913d582f003a41929fd3fd09265dda3c259ba4177a4a7f716ba9526af08c2fcdd615cb557a8ea82f7df8896aa5401e6e9d9aea3c144a6d05e0ff5241dfb6034d3548bfac1b2aa5952a534508e3e3c4151e88ad7ec4ba996971c486c4953ecf78b35ca3754999f413bda1704b834d94517830ed3442fd4207db767297dbc211f4cfe7c87bbd0df8cf39666696d76bd720f9da144a43fa4334cbbccfeec3b6ab81db59c82ce2a15f9b9f24fdd6614fb97ca9d85b27079de27f24ce2937480ea63d609fe1ea4c032bc98debae31095618bb98d2501262628bc7e19dad1af2e885bab8f0ac81a061117bf1d4258342c7415c94bbc2d23bfd448a4a473ede07955240489c236fdf5c489559af924b832b8d2d831b341eb9752fa726a8daa813ef1a31968f6f498e8b17f50222286c6ba94d8934616c7af4c80c2d65865dee09e0873f4c89a63caa25dfe7e331909eb60610aca31bff8577b59c491deff8aa0b660a2af7420da97243fc4d45189e27f50a45dee6661db5775b3844ca71475e37cd21bd0ba3f7a9379c194a050f833078378c49ef7ee5921c8ca973a7fe426dec6c2c793161967f5edfa0e0c7c6eab139b77e55ca74b35e58d4e2aa44f5a178465dbbad2e5292b44462f2f83c4fa0ab449d38ae5ebc8ef0d3c3ec375691b10fd8023ebe90d742f819f93732f09fffc8d8006ade3d08217afb40f0dd140f8de991f79c3564d8f4b0b899ff33832b5ce48e3ba485ea601c6a23aca32063adcdf8550df09013d9b1a9de7e17c75b1f94a40ee3567286cdd6c002dd0058fbd340ea1d5055d702bcae39da39f4aeb33c9cc2945d9d355423c14b2617bad2c82c12c1737935c034b24761b56eba45ae7fa22b1032d64f65255c51f00665e9430dce9837dc590d33b5c8db47df2ffaa1f63247932d801c1ed37377ede220f0b285229398536718a0ba92ebe21da89f670c03e5a61e9e1f920170d31e59b32c933e273a23da873aa8999875b516a4b9ef746ebe097db08f19a89025d184a2909692517947a0ef91c30aa1148567281f880ff5550f21c853e500ce4853198193ea80384054290d7c4b6721ed1f1eb2512fa7ac27eb1abed1c463f8f76c5dcd02ed9b85302e41d1504619c37f1ceaf19c0586f567b6ab6e10fb4158f2ed07dcee5e729853fb90ebc5339b350777a8a1091d6fd96dc951831ad4dbc8d11c071a8fcaed5c3451f83f6ac4eda82fcf30383053ee0a122ceea0de10b5bcd3120aaa5a66a8c50acb91958cfc27cfbdc1732f9f2831346de2584b36e331df5936db07d8408d59ca1f95b677fa16b991f8294faaaa7af3c2e8c47dd886b7d6fa2422dc72af69a4a599c7a8605526e0881f4dc56a2993dce429a75e6727ee59c897ed25c1f374fdd4389aed711ab5648f5128c669ffe676ff1bfcddaf365bec41876905c369fdb851f4fd2f883fdd470a3935f986916bf259c93bd2f9520a518ed1681f74323bbbf5d1803a6de6afad4ebe6aa863b8ce56f371beb0aec85e7056486fd57aec336f098e2e6d300e1e6ca6cce084431ec7d30c55adc39187371753bee32964a7753bd590e6aa88d2ad64bec9624d6a47a620f10e80076b7c1e74fb556bbd1091420f05a2b9691dddb42f0533b4662cdc5680c798c2d5a55dfb333f611ae26cc60139db74885ea9a15951be52bf889e6cb42c7360aeccf67e03a1cc8914e4810b1b3b1afaaf6659314344195baef91929af3e9027610969fd89ee29198370ccb31ab070de8b8cab4d7ff24fe3b2a254ec2c7c64b8b801f2817fc7cc76f672555b5d88ec6a1b1b1d80454bee58d0ea40c7aa25d49dd2a1c7d113227a99bed33b259814c3d08","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
