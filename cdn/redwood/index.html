<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd007d946aecb6e456ff902987688492a300a28d37561bf7c6154a70a78a907a6b563b81022ada57cae8c16bd3a80f9b6b5b97a6bb05d76dd82e4edf023b3266b52f8e7780351f8046985a8653bb062fe61125ca55261941339e50609036b687e87e97b608cfc8ee3cf23fa61b3ea4d123c668a0a98a13fe0c5b52d2debece9c68f7e3e272e2eab250dd07c631969fbdc0eb47e6e576905e7aa8964d4909482c682718110a5c7b7cd1c2390a6cfc18fa295632dbf6e47a6598e82ebca0f35d63456ce1555b872132b4b1a7f7cbc931741127711b5a84678227bd0183e81e64c9b27ef7dbc7d8dbceb74cfd66d905144fdaadec176363e1fd4601d3fd756cae3b642f723e79dbb000d6300ffac20fb7b52519b7b2f247823d9abd08973eb698bdec634519049e86bbd385ccf0a339a307131959853903f0109134ddfe27b0096e83a22b776a401b39cf2e35b295883101c8eac78f370ece207696ee7f517b50660da232968e908490e783ba03f20a09b408c2bfdaa3e5fab62bd4ae464555948525cfffe5af2bf5a48cd7a03b786f1ea719a6990a61c7dbe6551806d53ca2fe5b915894b5aa11511d1acf675bc9d995e147b1f3a902b22556c67a37b7456bd02afbf1209d0e43fd067fa8777ba29f21f08b9c9861d9e06e8fc9854934918328aae9dcb0bedc02d97601c341bc4f69b02d9953ba33f64970d85468ed147a5b78f08a11230148f7cb7303a6e4fbc06147574a238b804db4383e4839c8823fd9d47ef0ea1d185724b064da0234e41d2fe9825ece92650ca700c98ea8ad4d81fcfd7624d85783b8f749d4b4290917ed191a6d70aa334673e37a8c76574bce8af2d337ee9721834eac55f1ff42a6451ffb73faf80b455844cf977e0918cf4a3b03c043f02c2fb57fc0675f92501fac73e4c6eb497d71bc2da5fe7da188852583c6997b55c047072cab6135e2a738e94162b690774e96ee6facf06ca0c2aefea43548998fd755457f79ab38cddf83d7a7ac37b8d4195afd7b1e2aa3476b0af9b450d78e1c4ec9125dc2454f82513570da315a5f7f12082e810376d1ef779c8143ca9b594a1fab62826faedacf83fb3205a0e51ef8b48bdce21b61e04699f962ad8c7e55b301a8c2d8aa54317e7625bd8201b581d648a50798e9013a5f06eebad915893260c4adb64fe7d9719faf256502c51913c0c1d3c9c4802c879c5ca28dd96e3b056bb41657670f00865227cb100a4675d7f2b7b567f60dd43c5730e74980d039b103425aed0309b5ffda8f0ffea0a648eb48c32ecca41b0874cd4e8d375a2c7cc6fe73dcdae5556d0260a3fe7d5b872b0f25cf000f2f677b7e1f49b7f7599afc5b1aa9e7d5f3f12beafb31445398891a9d49f39d03d7e3beddb8a4fdc2f118fb885d6a74b94a440d176ecefd4683f82cfcb19a2c2e15b8263952582bcde72dcc963edb5239863a3bc5203c22c978bc6ea54c90933b6aad7a72c7bcefe49180e77a016f779344a0797621ef472b3a2a4f175ade711cd0dd8d5c38ebcbc2d05eb8f16dabbce200dbc2e1de91586c013fe714e4ab0c8b9d6f7400c44104a185b3f7aca447b2ef68007cb22b43cdbbade3639df3b81e19bcd83c8e85443adc44e19e59535a5aaf58555590ba8087cdc58123e7f7186c81bca287f2158c25a3620bf9054ef6f39348edd97525bfa5987b159b8267f2d94b0c2db3b34c4ab6a0b063145a323a75a38a71568b48f7d6c227241b04a08e102e79d65ab3dd8daaf68a479e9591284862dbe4af27747443b8389cd7177f656e387a88a5120494ce90fd8dc7f0cce4b91a917d1a1cc6477064e2e72a40944b86bc05153ff3925167544725df10cda492a8010cbbbf1869cc20252dd4fc3b20d3a21581359083df0e49fbc310bcc16f1ba94e02a969e8b1f1f35fb41255619dbfa8ff5817d748b1dd375da7867626f1bede6853b2b8a96854d19c72067d47c78cae2e82f0aca999ffecfc4068b739808598d4723a33f5095fb0be53ed8727dbf120dc7ce11183e8178ecb71500cc1bf29f6c1b10ca6aadd0d88fd7e7fc08a1ecb1caf2b5840ad5deb9fef5559605b8dda9c1efd643af9cd6d4a234e6469aebdea95e8186c8f056c6af745723748f7257b07aa6d48e85b902fb7d369913dd83b2217d723f576e85f48fd45da4b8fefbc78b8a1345094775cb8b75df8106387ded073a10c6b68643536147f922b4d30233b16c933520708b269db75dd18c064bebe6c7ae53dad2075d8521d433ed1918887beea5c3a52794410488cf7a5f69807d56caa0eb0cb27310db4a21725d3b7f562757d0667cf9eb1ad5c8c3b687e81eb7874242e2c38109d700503c09e3610bc8a0f0c72e5c0fb0f844fed34148171ceb2df02be62b24c6f555bb3ab99c7a5a51c7fafdff1618580120c164b0d8865041b5f485e5b53ebe5afd95bc086645dcaf2366a01ed1804a520e412f9f88de2f68a3d9d8b21b5719c1d7449b9b9e38e2860987de42bdd9fa0d255ff4a2caa9a72e61118901b4aa29505598f258418813dd560d58b9bd789e3730fd4d5ab9037ca5e1bd36fab082e90ade5366ebfc48c0732751edf739399d0f8c5a7d20c9bbb2001960c2be0dc570ac59aa082f7320a4b23f4ba8d3c69b0a81cb9ebfceddd8342b65babf9efcb6f9852746cc78e701fdbf1aaf5e36b9e2740417c7e04895ef785707ca2200eb8ca1dbbb667ed8356d346881ebc1120de5a3785bf7017b54e99120dadd9ef64a49d4319d91e04790b76931f53e89973251ff78526aeeb96d44ffc03ec9fcdb8e2a2e2fa131050c92bbb1b869537502424f1d867c212cc87af6bf0540c6a959fc795504d561ccc312619ba3c42357661a44b8d62182f97c31d8bb66ffa593491e1a1024ca272081f9d57b7adf1441f741e5b294a3c1a9c1d6eb993dee965f3ab48145ba6856a69b48a8e013d56288e44e41f364b689acd0dedaedf44a520f982c87d9a2f20739e739bb36e07eed608c87861d126ac2f2b2d2f2260081a10e0d7ed9be4c9d2901b96733100a5193cf44533d608963638abe203c38ee20dfa73ae478fb1957037f4744f744b0ea486a2d68fcc6b381bdfe3e4e8ea2d94b6862b65c04b141c72db607e0b5c640b45ea89a4e788c559478e55ef366d8f6c3a5acf063ba10008065a1c4f8b79d48d8c8462eb95cd31e25da6be4168ab9f0dd888e843128d5c71de47189ca60298654ca9444e22e2f0fb73717c8e1432dee6426df145a83f907e7fddea3eedd4996601d703a83f9059d235f2253514cc846f8a1935b46a43cb3b8e27eaab9c64aeac8be23dd5df7d64695b1e6348402813c6b53c76dd4cc90db0da1d0b6258bd404092914f16af163a95cc705b89fdb9d6b707bee473b4ef54ded0ffb88114491af71b15f412359ded3d88316138a683be00fa1f7b912aab214ca092edf2fa684a52c7654210b7f79cbab180a5895387720feb60df755e209b81d916d6aab49608f3e14d1b472a695f5964b8c8263fa7c4aa20bdcf7defccc122c464d9ac488a8622f7eb293b04f9993e8a746debcd403d7d3500d220168afa38229122855f2ce0ea1332bca5ed6b5d596d8bd1d8075b91fed78d77a3d1546ab1f39b23586419ce73e868014bccc638015617ac4ef8b1204e7f26108442246f9852ffc2ff3f27269f2f34d6e9349f3533addffdf9840f40d0c4167abc8a02809b27a791c0198273bb4579bc71d6ea7a9b89090e968cb268968b09a1d7521ac39a3b8e3ad710e984088653965016e9b0d1a2d559b7e898e342dbc325512fa37ab668533607b7840bdade8f0a200d11118854a5824cea1516b27d361d80ecb05986c7209bac2cf6b8e1c63cde4b10cf7fffc3df9ed1a1c51c7a51deb53d9448288611d3eda30c3acaffa5ec4eab6bac2ac7a805c26baed1b33a22f8072be78d19035b25f04ef6c5ad215553396c73311506b62a9556492bd663af60c5dd8c76473ed990a202f501e3c42c2206f1e757d89688256708e1696d3fa0b25b390a37760aca6cd3e047a9a6be2eaefb0c00f1f1cbd03044818cda344f01b75bbdaebd56343b2c544a1bcd8361f227eaf4cc8abf45f915e3412c3c9763041c13287be630a9caf0c2788c4aeea9ce9a59bac29cb9c4cfed504a715d6a6751bfe8c0f5294a7b4103b1b10693ff8e297a54cc6432c08952c3cba3e4ca3cdc1d11f3db128849a835a94816f00fe698a299c4007438b3a6150b99bd4181680efceab1f0edc8b70b65f9a904c29186f6d02574560f829847a92b498e2bf9bc5374396b3fa7be40d8806c6854ed6f4bc9e30396752b3d9abe12bad044589c40ef81fb5868dd7048b76c6e89cb073d01c4d9d10e3f127137e35c446864339fba47390c97d858e10f8e0df1d548a62c36fbf88eec57df81e85076011be50c4efa7359f9cb1bfc6e20918f26819789c1b65530c9ea0575f26ee42d53532bd990f5a3b6c4ca1bd8120da9c1e8ecfed7f73ca8fd41f967e0394c8a8b394352c5c412be929cfbb963bbe2b3b68a6a2d0e8ce66023571b499c7b26c22a90cc49248e525bad8a2ab8e920913b2d942cbf1bf104e4f58d62095a96693c3256e40af30aafce5b1c7f97691eceb072b1271aa3e757b90ef188b1afc609b22e54850e327336ec8eee73df542525e3983005327f9bf5a5f1abba7a2ab4611d9a784e617743b6f2a94e6a6e37df20065878d7da6d529943cbbd2d5fac0b9d32ef9aa977e4e8446cffac1202e085844f94d6625af629c1b9851584c7b458e8f90395936090edd12453bfd1b1f77a559e84b0b897997e0d3134385fc98cb47b05d142c187e7157ccacd14472a7a4f4020c303ce3f5d10fa2c8ad1774bc972356b239d8128af26c34a2a010b3258946b6a76c4c5b41d30a8a1f4be874f647ff2d2f83b1de5c00848a12981d321969b07976c720f9a1d62253e7894ae671c4477235d77c1e870bad3c4b175dae6b045e4b82d2cd5ebae850aaca7f9ad43dbdb6e5e41eeb15920a6eb2cfb9596cc196cf68589f6fec0d2aedd1cd34c1cc805adb00e8f52f57ea9b080305479191d56811d5c73f3f18426d2a44d7added54eb31536e70f017ddd11a6a7d0b24ca473b3e7e7b97e2d821fccd1dfaa250a0439f975adbcc8791147845ef9229fae7a3e44d17ca87fb151331428a7d0cebaef6859221ddcdbb1a968368f1a7276e611b1e69f60b2b34a215e5058e925c5c61583415f28c2814f3afdb41f190e8b1f65789c2dc30c461a1cd33fff4c9dc27171e844323416844c3c26335cde089fba5f4145d00a17a102b96a3db7982d8925c2ddfdeeb074c06b144d0e674712e004e4bf30273f9ed015f56ac47c96617217cd8187be620aa64ea51db5fe5352aeeb554ad895d37b62e39850029113755e2488a96b31f328b4adb806f7fc4c6f09192d6d27213bd8ae64c92a075381d2eba0b05487188d80e8bf165b734374eed877a520683a4ee9a1c35a7cf5726ac6cd7e4e34f80116c004ced4e28b9b1ad3f42b96f93043d105aaf2325742752e06497e05bab959785c0bdb5ae50011ebb9c6f8eaaf2c3b1724fbfc75de045b5e8fdb3d329b72bcd76df5b4ba637b5b5ceb59ea41527cb3a7c4a823fa5a27c9451a9e2d37816616bb2624bd8d872ca52c7e10e553cf704ecd58ec3e9a57052207a4c4847179ca13cfaebf885795a30483c2eea02e2b8fa277859148634ba7addbb3a1d8c90728ba0750309a6cbb5596fabe8b1acd28acf8fd967f9a66b9597a3d126bebabbe49f4699aa6850226bf9be71a401a51940ee691ade63b9c01450e966a65f2e162ebb2c663da416e4257194e568e1305b689b0f345658e65ccca2ec38a918532b3c5faf1c79796855a566b27747db3ab28c4bfbaa7ce3136af65e20ae7b4e4245651a878c4a32fe1d1944f236d244355c2c78a354ec5256a4c32d8e833609fabd2bce9423ea55d24464dcbf90ea3bc470b4e43196c985c1c0c554cf1b88c72ba2854b0dc54c77306628295e747491ef3c5a7157d86e0c28cc23abc21f7c0ca69348b47c66d91257e89d05e21b3bd4e608d23733e04b2f324741be063dc2aadef73103fedf34af662ddbc8cd43d601a73d4bb57a0dccfff49fb0e34babdde3a57ca21a2ff43d0d070eba0793367dadad93e01e83e0f73cdee18af1d7c574d5f682c61162752074cfadfd697e4391bf138b01915893a1ad6a671f3d38510a6b32e6b2841cbdb8d716782f2f27be5b60c5cd29511d98579ec9268ce8045a8e3a1f7cd1a4d149a2962c5271f64ff01ef360fdf08fe8afe5ede62a8fc125e93db916cdb4e718243c79d9afed203b000f19c70ef22f2475278927103e833c7de1af8e264c1e255b64f1a0deec7198ebebd5418ba049593b4702502ccabb7d805b96372efac13cfd7500aede17f8f55011060ab072267c7992ac350b5b90c18ecf45688e38b10300820dd965aab64b2b32699dd5d7b9a4c101e535a7557c210561314e93ddd4de8ad69c717e35e2f6658cebe46fe0b3cb9b3e4cb0c2faa4d13b7178090d6e08d45e9f48dea558d829a59c68cd4ff9154316732883c1a56d8a81170a7dd87c46dc4f656fade071dc7c28686c185f436b083d5d143666054e649c4eb549ce3c9d983a2b492790b3631f6c461b3f876a20ba03d9ea7364ec947ea4623ed942b883543f3f19ed2303e7e17528db89fee11c10b8f5bb20823a8fb204ec621589edbebe0ddedc9a3f99b52017401dbdc476111de95844dc10551751998e83c3fcaa46c30a47bfda91f7cc058ea6296aa373a7a0394388b4975a735fed13b93d75a3ec20965196f644d0aec2ffec9cd0f4eed352b38da1b44799e0dbfadd7d5fed8e3defc0472c16c7783954dc982363dd4d00a7b6219ae71fa5b7854e96552d58cee635e36875d9f786b008dc9b7952e95e35ad27f7f9f4cc9b97b0277c77f10a1160b2d149bd9f477c032a20fcac6fae4460b000320f8b91c100191c0e4a9d49c1c4dd18a075eb535527e2bba17c0f0fc9cfe1e1a1ac2be2420c4b44f8f7938ae7eb2305d57889b985002c28fe4aec67eb50139c2466b692c9125677ee19b697c466f9db439acf23e72199d82da9a33ba69751f20f10b0e8282f6468059ecdcfb47f27a90f964b1f635f0b496d550ae634337f8d3b7a3cb519f512757ad7297f37ccbc45d17ae8f268999b4e7f6617b9cef5f9571466fd8bc1925eea184cc79a555dd4e3df4f3046b847ed0a04cfae1f68080f9f18502536c1f8490f1a3a59dca11fd8b447d764ec2a1a7f749da280bf83f1100621c4e96ae3763c7ddfc65631ecced1b979c1dc6393225ae58bd6a53334593a4f8e5a77ce5b1d8fd053750c32c7db0fbd0301b51baaf475a91c622d1aac798c503e0fc785dac5317ec3084ba2f8c470bfda0983fcbd806f42cb4bdf87fac789c8a6fd7f152b9fa5ae80ccc7f8eca98dffa1f6d7b3eca297401cdfe6e39f2d7698fee2f9a5b2fe902aa0348f1404fec580bc3ecc666cfe24b41e33667f7ce3455579fe93a571632592b383192d33c876ecb840ff9123dd54a1c4977d8153697181d40e2ea4535fecfbdd649e2dc7a885f5071f9fc963113df614d94701ce466d51ebcd982db2211461a8d364e3edd36c44bd34e421690db5ece7d18816d7776ca78f45b528326aa2ff39a5761091622450f460097fc1bc1fb8c03b4e57414955a349d073c477a50f65528c8196e9cc412937f6496d537e9059914beb08d104a735e37a27b14302dcebdfcd4a7dbbebc10962f12d917eace862469bdc3203cb689609769f1d4308d3b210999622619c09807b1888bbc4060bb6e8d369fd2b1c8314762d2701978c376da252c55eef47035827650bd42f728de12dd27d73fd595a7f903b5d757e3dcf5f44a5cace0cf605c9ee21b3a9830db853e2cb82328ed4f7b70c4fd22880e21e59f30389c929b0a4e867b0b33205a46ad1757a0e9465c793c2a2f0d95dfae7444070977c040a4a3cb16ec3c17f0df8896d83fe988dd6dd8c7052b53d8c10dbfb1b4e08a5fb3f1c5a2e3c0f4762b340af316070472cee5ae5ad984b16bc67244345986b7f6c8d3a684c36d069092e10e5eac56d6d448fa1125b1b0c4f27c8fbbb9946c575cd49ae3a5be98e91be6b535b74c4bc7c652d0a27d692be35d3d6e4a2f32ddf48bc962e4bf9c5c9d658a9f23ce7c1244f469655e3a2f339dff9714a53867aa50b3d49214eb452164a0675bc44253dc5beafeacb955838315ba433492a8ad5b3c951f25dd7102a5fbe5edc794041fca239755ed9acd8feb010970608808848068d1c9457aa061c8bc902f6b1d98550737706b4eb1b23c70878fe3f5a30a46523747136cfe84042ddd42c139110994cda6071405899046f9b03bf5ea6d41945bdb08e9d42716215751eda9de7d9afda445dc17a5869de0e0c2ed4285fde7f1b6dd89343f03253e0a669ddffac139ff89acd4d9fb56311dddc4f780d4c58206374aa17edc994776ab9e618ad406c0f0b5a9bbe17fae9ab68280d40cb40cb19f77da98579587350a5b08b2a22b23b154b9eeeeaeac0fdec0372b5b5f4144894996d9bb566579788be2ebfc5fa4ebe91aaefb0d1f85db4e4c9a473cc4a267b852778bfbd192eea2c94758b765e6a1da91d0f5b2f0a619ecfe5c56c0c596ff5982214d730246809b3113a285ef95d309e98381ce46a9997ed1bd33f9e2c5d1e798ed05e89fcc7887677a5aed88f242631e68f340962aea58226e7ccddb89a943793e74acf418d80504f2ed962fa561c674dcffe33ff1fd3816c3429de536a0dcb7d4478662c124f55e65c1129657e8525ba21d27303fa4de647290cb18cbf0dadb3a3d1e94b122962bbaf3110c0764f4b7de45fed756cc6194d21964812d22846fae77d659d45743119741b74130d9ddda96d0be1c2fbf66777f80be28370cc9e449d1796a0cc9690add9db8a5561392e4deeb747e03c1028355bc19c0249c04eb0a4976f56439d04b6b616dbec61d764d9189f1cfba0ea17b327f1f829460300bdd4be99217fb756a85243ecbddad3cd8a62b5088bc2a69155b2b6c17d5fc107e561dd29a320088c51154a2a1ade1e55c0a73edcf1e48fc02795f4bf2b26625c62bc3ba58a332403e33658dc0a3d805d3adde10a52c9fda13d67a4334988227972d423fb16dc3b609e6e7516fe7cac87afa2523da0a8388a5fa2b31a3c74e53353e1b883f0147c9db026f313c0ace64add353564455d39e0d594cccf8223eb3ae577641763fc18d2bf78e5e637c81a07d544d7f4a03ab61f2d5ddc75535a900b62fc167ce5f1ff96a4c9575cc3c6dafcd479c73ca5de3490190318770ca8ee721c154d06976355cd1503c069d6a8ad056054495b95adb6abaface5d152e59b346514af4b9afa3dc2a616b7af1f2ff4b26abd7b44b66e5a34e5d50ccd4576103eeacedd0a004326c3aa7a5407fbd10840cd461a15779aac063bf3247ec25710c20576cb5b4a08f938381bc14c490ca94eb377e8964efeb733ebf8ffb4d285a7aaa0ab1ad0dd6d07a7c353a0ff3010777af6694cea5575273797014ff5e853ee946d326247ebe54feb693b116ac8788c5a2fc3afb9eb8e569fa46739b1a52cf42ce0e8bb4ee206165137c8f7f0bada4380ab0909d86df7651b1c1435a8ad90cccf82acb2dc9e5adacfa4d71a659243886576720083ceaa66a2eea5469e602dcfcdf9f95a5c9bcb663446affac4edba1920654b0f956cdef6c1ba3cba34e5071b4d8e3b00d28a3cbc32a8ecdebe1ce505ea590602a37a2c3315e6bee5e79cabc04cf485d522824c1d58dd7b565f85fdd41d04ff02a0cf80ee35ec1f83cde85ee633aeecd71e97c51f728c3e2070baeac2a2c32cea257e81bb118654122524f855ae22bfb5d8a67ca2d2a1d69e828f3cbcb84399a78ed9ce0b32cfed4a3d6fb2bee37050b0b8fa255836ebdb115474c3d269a5f7f8583d6f115ed37a9ee4083465d2dd00f1c5c07f7da59bad62eaf3c492271bc550c4784fed9454c1819b650ba93c2af8cdfd0b7e17500f372d63ab0dea8b354abd61f60e2735f25f7d1f13af3e7efb6e8750bbba26e37fffd87a57d554de27a97468cd9e0e5c4750c6164f9664dce86d331f55be255108b59d23c8b96ef11fb9fbe234af0914fd63939f2ac95ea775df7fa706a23852ef98d288546eb43eb771ca87b9cfe43f905453b8b8d88df9907af4131de2644bf87556a507c0a0558634529c9d94d17fe3c80ac724e95deba6289c9e300360ef23f7eafe23ae5281ef3a854f399ca0fb37e01c82fdec51c7b69d485061dae0841660b055f90b8788c47a0152b7005666446bf836691c81a066b0a027a9a216a829eb14a7fe8fdc3ac467d148b9f63c9a229cd3ffac7206b2934a7c58f598432d7b0cd3b0f23b85e1968f36fd9c27a0e77f9b13ee38f0e483634a7962d73c54a8dc7823cc8b60e916aa0026e68b4ead79517a4d8f962948a9d3eeb1712792adf55936b9704a7a8e005cedc7a6cf3daaca74910078df8bf7dfd6f9a4077438dbf4f53e2c6f0f17b3006b3c04e81bc0ff617f56059b6703d736391382ab9f5be3cd66ce368fe480e8a36edf7c61ec66be4382a7d4c759caf9a7c3c5f709234f8c842e889c66c55d9e4dbba08d521dd9835d32b1eb434c49b0db138fe48c7bcdcd80de9a9cb4d4ee63bf1acf97b788749590801f2c9f5a0989e18c1d45583c7e8beadd11a586392728b1cd503bc4a3467b523f860d9cc27946d5fdd1adf8cc9c7cad1e24133e75dffd52039b242eb77deaea9b5f4213d121ab4cc11d6bffab5b6215949f8cbdc3a595f6806d05abd693c901d1fdd4fbfeded9c22b05b72eb6006c7c51e71cb779203e3d1fa93be7dec3401ecbfa4fc5b91a82123535226919ee84d1d0ddfb5f36cdba1fabba8d8cf5c37157127f5b06bb2f8813d49c93f8a86b8a88a572b1e7201d2df17f30698fba3671b3094a9bda926fddab24aecab6cc4ac8da522bffe255072f30e090c003786b10408fa9c3081649613c51526083096036d9fb2d8b913ddb74678d310d3681c976966885a948091ee05b41b52b5e0c0cdfc5bc463576bbe9316056b69a474e9c617a38588292970a95f3936873c7e9f548ac5bebfee5eb867d3a87ec30cd09a889badda1a08fc3754e433e7ab72349bb240de269725fa1aa0547817476622b2114ec38682f8e4da6bd93aee019814c83bacb700619697068ced6e2445a2a34618dd2ef209dd786046539093c9e68915c19b6758b0c548dbef28d2518b80792af93f01f312637752f2cd495529adae097d1d97a997c1d49ec80a8e70e0b2a7d4233c38699ec716b67adf6aa3d1f2488f5b84f0ace5cd4c8a7e423565e53a8fc1eb0b6a21458fcf8cb84d5ab5bcb4f3ccc3f3380e142e63918c71204ab33573f8d36cf911c2e3673e46f70862eff248c46f101cc5e62be7e1f3cf1e76091e17e83cea0d69477eb787212616c0d5b4b61e8ea02cb2e81991436cdfad83c2e1edc4c1f5a69d6f5e0f3ab6a480611b68bf0ec17c74d1f6a6159d5dafccf66e8266f5fb66f8a0e436bbdcf04ae4fc8e62dfac6224f8d39bee52c7155c366f03143e1d54399d2c4b9ddb7348bb7a320f1f84b81ae4ef78da05cadd5fc633cb0aff4d4b6c8a1e8993a65b529e679892b749f17ac251de9ed79a1d3f754030985fa9bb9d5820f1e0af8cf76add0f396d59063b9e53bb0fb2b7efe05ab6648ca2ae29931bb746a7446b5a76557db94cd62fed0bd638716312a9a3afd08858dc4901fa5cf29cecd0555f32c5192da0efc381046f4c019f92304f817bd514adc5e8fba611709a7c5ea11c8395fc4be8d23744b830817340bb9c48c3b54c77be646e9d0dea0fcd6a90f35ee77612da1e9444ee8d258bbd484bf801d5dfed8dc2471302a54df7436a2a35761973fb29adc21c7c2da34388666de6172954a1fc986d97ba713503e5c4820ebbbdb34e1a3fb7401144579854d137b5510a18ac590226daaf6dd29bfc76c0a07b9a9db47fd28ebf210f9f346580c95628c1c4df84fa13652ba347e9d70d93c3bfb437babd80a25b04a90e67de19017244d94e11d03ee47011329bfeb1bef2293c49d9e2240473b12fa1a89b0c2b21e468e7e39447cc9fc6aaa45741a723d1458385cb724f2af8f502bc65808dfb95476170226404513e96ed2cd68c37feccc80e7a86945deda6a98752d07d6fe1d1e28e681cf6671ee07a50647c41c19440f90e8820ea1d100f3371057585f80d399d228cae810662b420b5a0621d2d6b8d46f3201e5effd3efec795ec74492f28ca396d777683c2e5f95bad2d6bafdfce22ce38aef8bbfd1302a62a98af06d62bd1f65e80b827d8dbe45ad439c67242d18bea9e57f18a93f3f3124b559fece189e7bf76d40eb6025bef88fd3de99d534d0ffb733a16e203e37f09ea94300212547f550951711e1e67509c4798bdefd7ec168b2a6103bfb90a3ee2d0ce3ac0321e7dbbac9aa23126e7b8762f4146dcd5effba676f9445ec80b9d2e6b9b5eadbcd5ff437a1fa94773ece635908ffa70b2e7b50604ac75fa29d963914bee3f1c75199630155134aef7c6918bf683756faabcbeb9cbda3e065f8ec1c8c1dc40a29cc714dcb398eecf8c7e59f2a1cc72c9cc19b1ad686046b44b49ea3ca88d96632c5ebff4b705eec89c7cb82e450f1c86dccf41df72418dc85326ed89d19131d9ce92fa5e70f42d7c570765adbf882212b28681f93d087c43c4fb2e4049c894cc0f13b9922c3f30cf7ff1d65ddc71b5007783cc4a0e2785dc2ab32d7386af78ba06dc1bf6bec8e60923fa3c562406c1b283f75f251506de881c5b21d7229c204f595c552ee75e6f1de95de7250647484a96e32b573eb4d12992018a1fb1e82bfdfd7b7dc747973a6c85109b10b990f87e2d6e4d536f75da42d8ab44b2de16f544cb92c49c9d7c6483b41e558c9e2823a2456cdcad6184dd2aed42e6040e49440925f0ce66bab6e4efe8acf6cbcaaf8898598d8dc46a4758cd27f1eae2d7b1bba58ce92e8d0d0be0e8ffdf0139a481cef16048772bb9819dc189e92627786af0919f08da333532738b04fdc16fa57e814f607916b6b1872ca3bdb7d4eccd141b7848070398f758ddaf88b35a9260103e2ee582fab3ff387efc7f2b8662c7a45467226a77fa5f526f66ab0c6fd874cd64cc095a0a356376307ce32536914039e1074958f76d7440f9a5a3a3f41e31acbbe850741d40929fd93dc9573e1d1f59007916054f796d63b09a59d4d13651666910ed5adc1607097b653c3f4086b9f2fe55f39105669c831bc68f85bcc5c2082c661af214969a15cd1a1011f2dbb18ce9e3c987a007e748a0dfc3756923c21bd5ff22afdc1748529aa6a098800431b2e43f50f0beab06aca93e637ed8b2a4472f67627d846ddb5614d1fda13c3cd65414bebfebdbfa06086afd68b969e0ab4c7862f28fb87e76a045053871c08b950261feb06fbd9fa5916e00dfa23a849adde82c5469a107d0e97123ff8cac664aa04de5115c640c60755ce4220f282cef8ff21a72e0170ec005230773eba4f45b3ec7256254f28c7fef6298bfb8f4ba18d43b05ef2e982c7af01393cce12b3768216aa57ca66fe0b645561d9d4c68810bce440d698e9465b8fa0e5c9e969ce1fda9e1be0892195b87a17b019d2a786dfc058e3b0a95f0d33648c5890d9967f395662b1c63386d7f64ec9851053f16f298c1b2ac9b152dd08d00b75df451b62fe80937042353715b67656a59ddb8658447bcc3986a99ac03bec9493dcae1c749f88b2749f74cdbee38ad20baf09ab989470a67b934650f07284f2344b07ce91f0bc30f247761fc2fa724b4ea8007e5ac2286f7a9f98ed099b79e7b4a6e8a6b656648e18e2d5242745c4c96fb0be4ee89f68b1c12d2535275368e31b5cb3c14c1906fb76235083188617e39227eecf3ffca260ff482e11016cce5fe84ada06ee25d7710713218f5f31c47bc719bd92f55a2da37ce61dc8bf9c3658fa5f8b69551976a98c891eaa291833b9374e89e2f74ec741b1824473c9e1b9db036dd8af1e6ca8a15eca550897383770f52b53a39ffb9dea0674e86404c1d2d009a076a4ced211af58768c57cfd19d3719de1fa618162cc93d0182165e8e3ea8c9dac816dfa20dcc155d4e8da4f48475a33f068fdd758a07c50187fc5ce7288101150f7abddb0308819481183bdb4e3b9e55fa8e8756b23884b2099cbc7a22d689ae2aef12f8d6842ce3621edeb433c80bdd26bad5f9ae3c812326ae5d636c52a6bb1c4ed82c44acfad6f753dfec81cd17f6024670e62fd76f5e76fedc9082d1adfeab5c0f7d718d24cd035790242aea25e3f892c23ae567c2c9f074018efd00bba2a7d9b2a48203fc507ed8ea3239466553c998c95228c97eef6f5af691551544c781a4cc1a46e0b473eb5cbfa38e69e69b3fe46dc7be95a9606ffee272e9b95192ec01d582a72c191c2fa019b68808c8ca9ed17e05b486c8236337d7a83ac1ecd21eca11d89632b8e406b7dc430908a64c44908155fd6e424116659fa4d8f4ac8244a53be104860364ca458f5421864a17259f1044f8dbab2f1b354fb70b930f6429b7102a5c9e949d65fd8ddef59be6b8e8b83f50906c2f12dd8f64f20e9173a77eda59173351705536f0d4ce192fb47bcdaf9b8567327f12817a114b725533e8a8eeab0c7220b3ec437f344f39ecae7d39b32d9d81b7415e41eb953f1d17c48415a0fb18bacca60eefe1594f443ee3d7b59ee7d7a5c60041786b047bdabcd7f46ad4ae3fd053c10923eaa0f5a3cd8f4bba82522a8ce6daf6bcc35fd34a8789b173fa56c641c7a4510508147cd946d5b5497af25aa7b5c1a74e476166b754098346938891086fd58f210a240182ee1059b648e58ef02c4f2a64dcea1f08730b22a273da4137646090a4fa60e064d6436a7c1fe159afca51e01314be115c4f70cef459393808a33ec5b120fb89a80b2a999568fa75cd2a5aa73bba6a79ad4530733d9b94219a137d27cdc787a62ccb347dab584a5bd0915fac2df1fca553b603c1cc65427e417aac327e567fb0ed08eec06a186f15146294ab1a39de772c3e31aa6f95f661ba51b68f68e29aecdd0d391238960d105475f6081ef8b0057519ae212be5fd3a3e96c3cc3c9382a128ecd34ffd165ee6848d70daf59fd3528624725a195de9b178e8fa97ce4d57243986d1940ff29c88b5729726b8f01661d0ab99723738808b10986adf027c7f7468aa330243c78944d87f26be36e452d5256039d485ada76c11c084c70e2536462e93217f13f0cf2f8c027706e6da75e0092521e5e199af1b1ce23532789361db997b1bf0c3c3881cfab5f637a6ab7a842118e469171d6ee92f1c866ec758ce0cdc866663fed04ba992ba49f01800c488d139b25d693523859479ae983ec60ecb9e8853404e5635aad4080c295172a8877078523df8db3d7854bac6a52d2695ef4b084b2a77d854fb5326ce1fec3fabfdc21c760d55439e4d2ed2f7682737ca09bf9bae2aa9bb95a9d8b0c6536437606630b2d9540c7751838d1f4a419bcb42c3fef6e05eb88ff0e00ff30c5123700b72a1a4f3e3dad9e5f8943094a1e4aa418dd361389bf405534eb3dc2006932dee999188f6cf1a22c1cf61c231bb8d8ffc98f1c4046b6fb3cf73c1f00db6af230a97af300552e917d939d6dd0bd4fb22117576bbec6ea68f070b2e4f6ac3e5dc1258741fba81db2f4b82fb3a4742c0e3a4e09488fb7b6d0648891cae366cd25fdfd50b705c835f74749c014e6affa83c60451d9e0972f85c8253b13e9437921e134959aa1143937e6c1a39639d06a19188f1a9899014004dc3b779fa5344d852b56a6291dbc608be43ddd54c75869e0696b6b0b0ce288c43dd040cd63f5c090fb990f64df71b6f582df526f88abe9bcf9d0c40dc171c9618fe632847f5234d12367e9c9294c9287a761dcbc6694ddf4a68c42fadb2700fc98cff61bf9db7f6a6750f31988118ad965dc748ac4b71a0c315300a17ee9978639b1ec0ce6640c3f12e1bf37a76423c0f8fe879dc21397e3e0bcdf802340eb3e06de259b4a6930a27089e91e36a0082215078ee83997eda9e60ec3e8273155f1f2e87bbc2d99743337d88d43044b464591d1f73d3cf7124d02a03f8d7925b4a4bdac6750e82d0afb7dc39fa8f656ecbce0e26382905211612a4a8694f029297b0a837f3e7a0e987d84fe90c6346084072928f2c7761cdaaae2a56a9169d91671b73c36da5a791071403e9e2ad9b1df562e11f3856134c836e1de41cfeda8628c2dffadd87d3dee271c73bcc92af43f264bc7a60979bd509cd6116bbd9f844e4205a7524677549b54ba5100eb8ef71e791d5140a95def0a42a3b71901bdaf0bee9cffc7c03f4c352fffc533cb128194e164077d87745bdc2eead4a5f18947c5112d107b5ef374396c391550f6a19776f4afb511dd3d1f20144f2a0d019c3c14dfdefa7e2317ba382296c90749027db4ce607c331ea19f51053f6116918f53a024cbfd67c96b13f297e8dbe77f9e72d094ca6294bbfa0a0d89c7c9800b33ae2b1696ec0b3f671e3f4fcb6c4e8fa156128de0df02af06fa0167b34a10ca51b92eb4ab45612420cca081c0bd3c123a6adb7a198f550659a23f5f618ae774046d62bf3127ec66e38de47da085622b33669992007c35e37b25baf9e816e6011a9345ad9c249e71f503fd2ac74562e711b33f76f089d0cf2d0740b70127a8c60132e5d1300703d3bb4eef5c3ea8bd82a26a6d11ebb0bda68e38473393bbf1cdbab15c535e824cb7ab9e273244770406fcdc9d039af74210e75128934d7687d26116425d56a73286fd5ca4d4f4562a6dce1f6ac4907ffbc7d769df5b0481a7caa6d13368718bf901702ed861e2c82cd336484e049ec4c1cd895fa75550c9951eb005e9a13caef58efc994725e17fb021a3a70c6a838f9a83b60a26a63f83fef55b9ac7f9835ce612f819409f28066f78c555adf908adaa5366e9fb02633083fc10c1d52d408b47857b598547850510b4819c21b613ba715a0a36f887ba36bd61b18add9a95a455d555743002691b2f0be17396d25436ba700e178da69fc1695d5b7660f4cd21127d9431de0374e94f7e7df6d800fc4ff2c199e577d83486c560f57998038f621ecddbd58ce7af0120dfb78f2802e571715bd44a37a0e9c62439387b5fdc58bbc0e6dfc9093d1379e6bc6cd14c5b683a7545c75a04690fe70ed3a01956167652a40dd4032976be1a5d9347093d304e07d8db81f79612196c7cf7ea8f2b14b8fbf7991ac41280a637e436fc0011748c2dd401f92b120a49f84018ca3306af63fa77627c02165c7e0577e0a0196326b7f2b0c1589783982182edd02699fed6e937c5977df567f0eb26a99d6c0be3df40dbbd0af62ff6c4418f52d6527a82189bf3014ac1f9bf9b048d6bfe55f613a975b0503ecdc014853a551947a18d25214f2ad594b548ccd0ab32527f1c845e4e44b50863d36bacc14d346e6e79025e2b61f429424170a520b55f372f557cc172a5bbbb182f2edd6d5e66e70a15e6d21338337bd3385906b05eb94aaf516973417bc587dfb6b831bedd7b48461aff6b3d9d2be68e5cb0c80f53f04dcaad22f8c5c5e6532d83943f1896848486cf79479d47b2b1b94f7d527d131e17f873aab5fa72ed20f4be895217d77544668856923248b7c88bb2f2d61aa6e50fcd37d0c3dd4190d21cd7aa4f4066ad6331e452de14c811c71c7abcb10b045adaa5964117cf8a950a69910acac23795845e1d3a85f45ba311b27219b02b4414451a9a9b2e6267b7a030a35b75012910b5ab76bd090b4031a86a6829f7eac3e23c0a0c8249f76a8412392c3f36aefaaf1ac7fe67da12fb0fda7922bc5b0029398046b69d11a6f49aec1af679a69cb22f0ad2f04ec223aa4874e1c0a66a53ffcb8112f8dc69932c303fbc78891deac00c8f9831f9dc20017ae494bcc78460795ac884899a31404e569db0e5392f6cd3cfc4c14a9e1b1e7b6a1e021afc805f0c3a5458be","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
