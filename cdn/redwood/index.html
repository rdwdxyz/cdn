<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"19dbb35a1fb894ee6157b03656bf047622b929a6c16de22cfb2f5e704751eda3b2954f4643b426dc55de99377b1dc6a7a98603964ee664a3865bdb07801a8ab4e6f68a194014b3b44025520fc7c0fae368ee6ea3a1485302cf7e231d728375d61a66a2d70ce1ce997fedf33fcde97565507fe078d61a698bbe851af0e9894d6801bddddc72e036ad91a0b97758243d76d8d1cfde25bda870611d4dfc1b4969bca2e2824f880280f87ee2d7ba1b6df4c79d50de485f989a3e664f44b845740339ee5533e63f2899ed075109a2030c023b30780735baecbea6d842c4c9e0d298f59d45b5ec261020b3c1bf36d3248e389f7e1e1cbece05a89669daa4c596cf1ee8a93c4656559cda3e875650fd6a22c0d75b218fb2b5cc1a6529182563b5ead40c172406dcffdbd3c0a42043863aa5bbb94247df4aaeba2e1b947101031d86e727405aab354df32b49f336693400bc549879648fb5eea91a27147bf25d5216619d23c878f36deb028cdb108fbe14e7d575185404386ed8d0af9e96a0e114d27858e83facede4ed21bf168329032acda449a1a92d01aac55fd5c5b8edfeededbe1658533f52b9878a0e7c101a4c41f65d0bbd2a230a862c811b510d0e93c22c556cc48f967710ce483360fd3a75181c4b5dd6ce1cd9c28009b7b5a5575da7455f05c8257cc7934e23a02e172b8d3e185c8670d9ce77145a632d68a4b9a34ee4daa7a7bea2ce46a651f3bc2045901e5d9a7697c49b9df9e3893cf3f24e97e20697e0d99c91d85ebe26e252d458cd2196eb381651a9e185bbd03c28478a5cbb7aa34f46353f640635a4e04e72d725d9ea9fd962e33070d5e600ceefa59760fabef38cc96897a3ccece29f899dc40b2c119c522fdd77036133cad0d382600b55e89760dc39c239dd1649c672bba94bcd2bcb7b07ffb4eae3ad5000564051cd2e977ab585cb044f54944224d9ad1dfea4d4236e92e7a27b82f0f20915d62ba301562abeed18ee843b007a58b4b0e1c50bf333cf350340d1c936c2f204541999a5ed3a396bf920d52ecb039249221f06d82526fc3213aa44c43af8fb9f54c6cb3f7bd98e53e8dae4b0669aef612ea2524475ea67cb50cd1d6fe98b130ae262ee64f4b8ff4c93b62bd7c9504d911d047b17938b182bd188add93cb273b6d1dee0d0b200992bad8e38c0c1712f42b5ae1fe072e159165d0a6ab8bad3396c12b33aa097eff61cb87f0315b964051222b2035a10a270e9e6be72e018b7f67a5096352fe42517b07f7337b8adf1fed2d19612d8bb15e5a8b354fe4858d22c4ac7a5d8e858a8be7dd2bda95de5ca8f032384aabbd36400a3183c5019473ae22e4755581a83d240b7c1fb90012bc9f38cdd0927172b69968d910257bcfa548f62bf3d90ae2644a207f329795a91082764fbf4459cd848c93ced9b44730ae2427b1f9ff192c5574552cc087b2a72208be24fdac9dd0bee6a55733961dfe5c7f8de0ede5f1bacbfe1f5d73edd4c1ec4cc29f592f5d76fbfd310e5b350b73f7029ff68a4986b5ec0163fe6df26a9dd13b98b21300af796b728246223c3f2f6a0f8ed0b9aaa663648d6b2ec23f4dd41ca94ef1defda5021712971f5e12cd0970cd04612e40adecca412561644be4cf9c7face3a8cb05e837f4ac8d9f1234012a9491d922b5cc0b86d0b7f59db2af69fd85e0380965e46ea6d5bd7c76f6bc43309407ac3bbbe036b47ebd023e968987066547994f3625d37a1c2bc9ca4df8aca847ba2a14ab5782cf7a68ff2a0a89837f6d6251783107024e8f9a83a8bc9fde1fec541ef67670d51c91db1311206b8396f0c439b9ded1fea0a2530a36486cacf71fef6baeeb79c0373146584044f6971d5e8f21df249ee39eab87c384bac5e6ab33ae9fbbf67cf0dfa73430d89d718fa5d26f3080ea51dbc2ef55e14c7dd19dab31a30aaa315fd20f6031a19e690c087b23b8efe097d5c77743e84dafcb6a40129dc00c4a593bd31e38cf3d6e0ff2f3c35cf2331639730e22a09306dfd7dbd9e5e3e51de39fcb98f6ffc086ecc9fde256965f9ed2ab020d4309b3fa4c3016dc1a55806bc21c74c5794c45e1d80419c4a019d58c19b01fee3eaa3d9eb296644e95970a4548103ce4bbfb23d4ce02a29f4d1bec1ae2dbbd5a7d4e876bd92736648bad8ebe18b0bfe6f3bbd85d7bca51cebac26811498ca43a219155fbc338101cd42cd51edfe28602b980c3e0223a2526befc95e7697f60ff966a859edef20a60910a277d031da43a52e131a9556c9925f55d533bfd4767c473c34bd085c1291047ca62ef90ae2e6b00c8e0a979982e795b4ac220a4adc8da9a9e474f9c732cd5a3b0afa78f51d0c9ddc8e7407ab5826a0f44be0f10b335227d76cd7d118d5afaf58e441be42748b99756f15a6259f66efc96902f19f137d82fcb7226d386e316408d7171219c1b44e5c51b596a7036e110c03c5c0a33ecbde26d1a788adcd2188a68a1936472ef14017110acd2629893a614de0942698c5a3a4dcd6804cf04a4e32133332ae2cfa2e49f51a930145a0cc3b028c221a363e21a495f2ae9489fe9791b06ac959f021ffa0641897f3f34d7e3e251307fc0909e1d5b5baf88ca651c5e22fd8b73cca77bad34b3652dfa4290979608109da18e964f321fe5110b939044a7547c8b374b2db787576e8d0f8c8b7e9dd149b21204a05b436281d9c4acd871cf079ee13222e3804bab389397cce973cde0165ed4bd045012824a5b6fe1083682f42acb87f3a6ca49a645900a4d2ff0dc064ba19e8628a2684732a3d157c8a96f3aac0106287f5deafea2da7d04d159897170896e5590bff6beaffa3a3cd40be478abf2d75fb68468c65202342090ae8ec942348003de7350da1f9779fd0251d672747bb027d0706fc234343ce67ceb28690aa81c1bc906142bef71da9cf13aadaf5d5177f31e9230c357cb72ea743b6512adc8a50b74900ade36dbe421c4c461700ba2e2be612761aa2e566bef0a2ea1cf5e0ab2e60de61fec8b2118dc9adb1a17c50855cabe1b1b9ee19c1dc83d3bb5a5084f0485b4616ac897068cec7ab12c68bc1efd5e58eaab47bbbb3a236398f55c6d65ab154325912884b931b1780ba932fd59c95a9f4e0ea9bc1e4b0b31977d51e923a5553d9ba183888a72aa0142c15227c0593cc8346f405a29bb1694e99cd8120d33ef3109b6998dcae4fe95d240390f802e95e3a02278131bb39aee0b87f00923972f13c777d1641de5b02a49dc0d03f44d8592a7f788240abce9c1f1d0417684e8e4bd4e3829cbad02728a2c72ec616dee9804cd902a20e98d6cf0b52b7b1df9fca2eaad04e12eab5a929c9f2f17f81903915744b4b76b6c5c2224b60903c2bc1118f22644e61ae3ee61d1ee7b36cb328d1e1a57f4fde9bd2184262a105f00de89adbf1ea72fe551b83bceae03fbe69c2b39e7e1e5fa7538690cf62ab68db821afeb425da4f45e0d94bfb326e044f861526b8b0a47dcd5201d9738e7f7c5f757b14b16dfea7a95324a8c4b8ee74103c91c0f032c2582710d8014664406423ad6b942181ed8ff2b4256d87754ea8e5421e6f7ec6d16811508b41b9cb5584afadc73d69462410eb9750be94788ece67f79df6edf5cbddab5758e9acca46e4b44fbcc036e491f2e69d46cfb86484b7743d68178248a38f9834ede26ff5003410678dfb416f317522d997b0aec13ed21037b0e47dc60ef7b9f36668cffe77674e45c28c0bb97cab21d55f78e675935fe2173ed533a1eeb7c03de96071a5ab497e2db743f599b1aced9f0290cc56352ab880186352710abc2332e7759b922146a9e31ac1cfac73504ca2467079fd1de7431dfb877b0d471c84f5e328eb5a8d211c39400ed2bfbe0ee4253b35ab349b7abd6af3a312e7a3acfe73083a2f64cb759f2e1912e9d89ffb321a878fd1c758babb6235da082eb45f0c47ad8c1e9ac49d1e00614c4549a48cbeba2ffca6aedff7e71ff3e50f9217e5e73e34f64b944ff355574b3c90f7188d2b47d0729dbac7348d0232ac6e31e5a96f79e722ef5ac3f6ba99928cccec8a8cb9e38ced6b0adf4244bdba345a2e12a42542b92da8f05a71eb6bf5b19d6d43e278a52610dac0c33b9a8e8eb6d4f1afd8072a68b6bc3cb70d8861aecf4c33a4f6e9b996b0513b58173cd2546d7c5c6174382213fffe2186a2766b4929b829ed392a2bf6ded7e78d3a7a283ca6c713aed1019505122a40099c8f4ff904d1efe3ae378d25215172b3a7385c3f63d09f6e166393fafed8a9dcdfaef22d08ee20f7cc60c09b9d6502705c6e7c43f718ce3724e8471f27bb27140b85e11e8a969828bd51978b478d749649c655c105dbba0f95142f1a992c2c65cb526ff268ae2aeb52b7b1fa6e42babd5b5a4ced112fa0a3ec3c56c9d25db68928c63064acf87c447c412147046e9aa6465da769ad765a42eb0c7359805de85f730a8dfc3b7d237cd56779ca9b94cd52004a58e45011f585c3509622d26b311c08a197d764403da50cd4e661d9c70e6a88d35f50e4c82e7d2e7ca9b2f663fde7aaf8748c8a75d5ee425f9407c839b7aac7ea1667374384f5c03945eeb3f98a9976f5b79bc282b28324218ac3cd5b0ee5cb4332bcd1b2cc0f8a85306b61b91cae47d056d606b6cbe33f079f2ae91381287dc9067c8d50abe40ebc241570db42cc90722b82b880dfa9d6d4ba70388275140c5bbbccfa7ff73160abc9f4e32df76d7555d405a10ff42c7df41c63da3259ffab08c721614ea749bd2cfae58967e4c8084e2722f8c4b7c2c4a5f741d069c59a444f27b8b1bf67c8d7f83dbe117f00ee64eb1eb1380f35241dfb6ff57796b015179ef96648885bb8fabd2857b57570b60409de5561dbcd90772601a353679d84c2897d2275bf218cfdf361a4e18b9be044f8004dff494b2601a0d896ee1ca94c25822bf0158018a038fc1371b7ff0cf472c6536bf96111074496efe332f4532b469435c7a4ca1687c8fc2b57f83287dc96649dbad2e5a8c008663f62416be734be098dff7e96004773c5697bb8d603ba120e8a7dce81dd9c3a54e56990d2c8dccf469fec462ded4c8a5df8d5de2155e88cd32345f439efd1e118b82c0325ec2e78802073e57cdfd0c42f14aa462499e83f087fba7944529c4b96803a0f0b35ecf0877bbd4f33b52a0f7aeb9fcc7d4335e092a373b5667e4da011731ac6bef30942188873cec0b5f4e3447d92a3fc229e97b66f1acb7a155a8e7a803c0b9c150a35873c31bcced2d664f1c9264a060fb0569cffa88474aea744a4c2c0ac4cec260bf9f6a167f87c71d5eee4985d5e474ffef78503db48e589c146320b5e58bd5924f3e0484addf106d61162ca095eca6962be9ba2ae107e100244f22c8a9635a4a2a74d3ae06dd85e77ed629d7088ad079f50771b649fac6c7f7c844a45d90f0caf8a5dc74e24462b9ef5fcadc394f566cf1c1bbb7c23681e172bcd5ec0c99d34004f475a2c569763218751e4f0bdb000ee08c7efef40ebe7aeb421d6ea92963c75859da7ca49294859c75a124f56c636bdd22914044cd6616726f83c06f0642741e2d138715c8dc487beb13cf078256d7c547a038431c9e2394b5683fc7b6c7df6333c7a767fe3d340c7e6e1d06c93b6a30ac8d2f3dea89b2eb7d29eb0acf6edad3fdd1993bcad8642fc6264c6ecfb9c1249890be05ce5eceed8d279956c92127da322e9b3f7398c1abf0304235b6fb2b1fd339ff7abea39a375bca82de434fb0efb22727b9ee42a66c6b2f6f43789ce8ddb6c0bb2bf1ccc3f453a627ed68529d4aadcbe57d0d9fea81346df011fde5eb658dadbecf42b26cb25929cf05089bff6c9f1351c38cc627ffd305eb6c65af5fccc0bba1a057313584b39139c602b6fd33eea0481d5afee3e71ba7f084bf13acad14aff429dd51aa8409906013fbde9c1b880ec7ff216feb29028ce99bafffdb1c02841db0375618e619558d73bb77e5111a6a6e6c6cedc19ffa2f1734506e7246dad2192a023d6396d1e146a7b1a5c28b3f5d95bf5bb73d0074c4d5d95f462c57062316d7ae7dd95fa2a1424b653cd869645f4072780d2eac543a054c5ebb9c11188a5a758569eed6d34c0eace0bedbb1d21bad06dc1392b0efd550524ff77ec8647b124a27d19f872c4e8f516fd6511c5d5ba6abc1a66259d16c88a227cb3d1b18f585ef80e5561aca045afa337463446d582d38467b8e10dc9722718a9ea16cdf41497bbb6f89327e989e5a38bd0e1b2782b3ade159917997bf18022372f8558548d2072fbd782774a9d88c25aaef90b8f3f2819973436624b8d433b67000d812b055c4943fe28d948ba8ab85a211307f756aea6d0aff277f8bc9fd3c076f7990e2edcfb0578c704e27bc4a5d26b8bd7425bfe61d421fe1404811e58a75650d36d2d1d966286ab2e5da67c4738593f949a63f786afe2f89a0dcfa20026716b81a1e2173e50da8e65fd7caa8cc787d09f5a4ca86571be7fd2021d86217a615da643b1e47159ada402c24a041139cfe2d491e061a974d412fac5ff98d24c0cfcdda1536c9389a4ad20803eb46a758e11ef4d6a895a9a7455d5fe4e1b668e5306ba3cbf950f8bfa85c4af76e27840dbf0c7063a3064f2f772476a188a9a2193cefb18d13d628754c04c14652e642d6dd10d4f2f830d2dc4ef4f781a5ed5baadf78904c0f28af30faaa758699670105925dfa5bd91161e2c586639b542582931f94d4e25cb1ce644094fdb001accd58cd5f292164467b1b46f1ef1f0ff4d1eb61624f0fba812d8a95c332855cf892e94bba4b4239596b6dfdbd20024caebad2900ab76b69a1cea834e04181fa37331be7f722b08a8036d7f4d240fc43039e8e7450be69d68d6fc6a173afeee63037ab49fef82e1c4f5345532ed6e4d247e254a11bc4bce10168dc11a5f1f31f97d60766cb4d13031959439997ec51a3b4cd89bbcc86788e21fe520682a590d21a5afdc6769b5ab1d176913470ff7872e8d268f901719788e1b058d3ced072abf47335fb570fa798407c949cdabc14bbc83fa4d4be518cb1f0ddfdaa605a2529ad5bc24e780c3ac16b02afffb15fcb966854e937929074f6c96f6fa8fe9347671e16522a963b208da3cd827ad01970f1511fa6224c76bc6c1397b3ae6418455e144fce53c7ab8620f9c4a47d70038b8bfe441287e26f94632924ef11519e77272c27d3d1034110ea767914d8065200e7a77832c37d3aaf44271f522185005a9ac3ce677068ea510ec8a4ae5aa394c2c16fc16cc28de0c24423d719b171cbd92b6fd0f1eacfb01cd743dc8d00b792643f56ed98cca87637bcb771393de47e864be23777c72b9b69cb4605917fc3105c4e3ad8182665288044642e1325f3a7edccc9e26345c3023c4ab8904e2fd65e9a59b9eb3bdc2d42f967f7f3643930644a52858a7e606abd75816f3f97f5e70d7ef435eb2f273f32be8e565079d84ac459e4ee1ab0dc828d28d7fc87b0db3293458adbb26e29c2381fea3006ea055fd7afad3e36de90c180a0113548f92cc4b294e25cd23b233c4caf29c2541cecd765e4eae837df6aa31dbb90d1b2a975b507fc6f9d2709490ad74cab32c52de9844be894b0652f2b89eb8a2839e42fbcb3f82ea2cfc765c3776ac130c099096bb67defe97f0f02f1b904df06a295fa3d21f92a8a380553dc3a465f2e7528705ff336bb8094bb1e8f1476706cac40023f29136deb0ed8e2bc95517296bf60248b604995f853782b8ef67a0032ad7d4b4e3be66ceee2f610b80105e7e55be481b160a43fa866222ac90c43bf4e01770380d39164c7ab7eefc4b2250eb01416920e642ff5aa6dcbdfc883833307d1f853bfbfae076dc0ad5cd0f605f99d69a9a490ce82f71ae08e316bf73e18f4ce33525bc6634e273a33d4f5e83f76d3b123a579adb14294b6f2377a2ccf183e40e74e6dbaf548b9b38e65664152194c41504b48364b26bf775f8daebdb1c0abb7934a9da9df69d967b8cfa1bc4f7e534688aa4043d2598a1ad37a4a3407a0d692bb9d8746d22aae6aab9b99ac048c0fae0efadc97d7135b5cf50fc33d6e6fa8bcbc12b423e724c62b95738d63bad63be0bafcd38fed16809887faa5e1f63246491525f78232a2efa5289a81f1f4c1e73fa4dd6bd88770c5641e1b7324e406aea00835dc5af20fbe73975c93cab192e386fcddb52ca23ed7f20d53f80c1280f29577d1904477731783c08edee839325fa3e861f94e86e4e7f4f30025320fa112a8430e801e4e0ff654fd8bd8b680520163edfcf06af64b1aa68156334fa9ea517d40f444ba1ccd8dbe8a40cac178bf4a56aa8d18f8581a52f8c19d83ae24971d33022a5bebc67ef59d8d4430daa89de37a94b1460ee5caa7b3fd30a137588a578bcae3f79a8400ac9d5f2917abbe6baa4bd13c99b4ff4a389d82af985fcb6fbaa155c84eff878d16a0aa8b4dfab71430658cffd49f65f291ae75dbdce6f07448d26be250335d7b369a9d581fae93e5ceb724b62e144758d834e5977e221deffc761fd2c918ff2ace9f509703032f6764aa796abdf87a784aea24a905a750d9cfd4763cce31ba4776fcc51027fb15bd110b28288091504a8c9fa9e80915e870f7c30b979099fa20d8fb50f51bd50c1307ccf2af0d0654fa5395097d32aa50837965d6b5bd3dfecb776b84a30df29f18c2d4e954a37f319af9f080fc357fb416af7caaede432575e8333f726fad59694d0f17e62e3f15b064e6dd2cd79938ea7ee65c9b713a1adf42b39345a734f84e5833ff6ff1350732588226cdb7a28f1bbde93120cc9adf98b4d68cdefa5244e27298f3a5d24202c5d66dcca08a6ccd2a5b7895ca8960f5867423cb2cd121a13b2535031af86a7f0e641174b70838013055c7d818e1461b6c34050a8379d85c39260044ed10c7d652b442f9452fb4c227a36022a8d988e858990def578f61a33fe000da906b534dee2e243b71a218c2113cdd8cbfed45d34e6a87a6bbbbca33d1c94f25215cdf7dd69962668647799f5636f463f6a68f4730e205fa8f6e9130eac7673596dd761d275d06a6a06f83ebfbee790167f34903e4a4f23756ccc4e1131e23810c2459c1dc56aecdd0c646c3810f0501267e36960178414cb21354d35f18898346689eca14beb58815a03f98933de1def1515c4f4945c5d9bef7c021f69d20c79a3e28c8e3c29a7c5b45f0c665413951bef5358f78e4998f2f2cd51180650e67033af35eaf5b4d791bc86d8256785d5f3f0c58c775f5ad5c50e71a63dade591ee20c9a05cc42f1992238a4f0abff2238fbbdc27adff185874e704ba9c23c5f0b389622e11cc99f5923180f9ec68a3404d839b1f1dbcd254a38c960158de73d719677f18891c18180daf672baa470f46c171e4078b5702aab856bba511f235252c578948155bd1159843a89dc4bd33db49dd4c8399fd700b107b32e80db1967548eac674083eec5bbc73340b76ea9d7f45147012c8f633f5364f66f0dbc9c06ca3d5297d3b7c3f433b2cd2769078e776a841c2e5f39a4ad08259d418130d9d49680f7cb154f8dc6137b0245e384a2dade2dbc8d359d0ecf6874b9ccd9aa4ebfcf8bbe228e7d45391ee0692d52eca4f8b4a1a3f032b8ce76cde77550e7189b71b0848912210e39a07ff41c54cd367a567b978299dca02b69397d4fde584fe15dd741a05903b34b411ce8569f6aa16a159457c962efd33af44ff8ce49d85d4fc0372a5977afab87c20776aeeddb0e0dadc0617cd43590f15657f522866007fbb191488ffb062fecaee3cae6cc29491f2314dbac75f863ae8bef05765fce974c291c5400cc2629d97b70bbdc34ab2eda478c04ab7255c8c613847a59f437a3ba8f8bf9cb083957acc6620cfa09b9515898e6f06e63922f8c2091d2e9767ce10279ea3f493654777fada5fb75296c85b4e6f49b7bf4128e3b7eac966dad10e0128ca9db7816ba9e7653cb823c58b25329a0282ef85934afd6545d8c303309910bbea6a11ce29ac5ba356124b042bbbfb64b07f04aec5c4ac21de6c13aa83f02ca58d70d61bbd99df6b3c8535aba418981ee68791ab84ad22757b5196425722d748d42cfcd0269ba483906808000a30bb2e56916c0c48dac04dff4b757188c4ed70ffff00173ca629481fad6bcde3b8d7bb1cde78c590889a6370f7aff7ee5b0f09d9374117135bbb9c40cf40bc2e9199a8170be4af0c073756636dcc6444f37c26e89f9f1f335d0301864f91a3f7ec7555f744983a7e108099182c0abbeb4a2ae8d866fe7c1d9c5dbc0aecbd0377d049527efa4d1b9bb47dccf78e139daea23c9243907653b6bbe6555111ab5b12eedb9499bc722b8666affe0c5a19cd084acc55d8f80a677bfb9859cb94ed3c9d2e66a7eaa1665465f1f9aca153cc6f0cc42c31f90e719a9db5821a267a71d34dae83accc41beb13deea6f7352838e480d5e93be85c4a3a2033beafe5e7230990fc0ed93a25163a8ae05c2766343276f23a1532c2f5e4712e71f0f11d221db022c92b9f1a50fa04a88a292c920129c0b16fc27133d7d5d4701550ee319b1211299061efa0d382ae7afd90874efde9b71d13b7dde09b89e349da4a4a2040b5923349d7a59d163490ed6461f98ba31b3e010e7bcf4ba6789717de0a0a95fb63d8f274dd1ec3d519a6945f1e5a944bf5f1a223ebc91e925799d736b217d645a5cb75b8e87fd870a4b70b579c663ba0fdadd40059765e4a274592a60bba660398403a0f1593b0a95f381955cedc057b666cafe6c7999680534b7169ee24c33d24a82f05f87db9447085ddf592f3b604127743ff5f0d0a43f6526d5a4c610a979cbf35bc4b8c1b9fec93b5bd71fd635e691f8432dc50b5cf0d5e6ce34b16b2d71c996457f8bfb8c5154b7951d2807ad437f966daed72d62fcaa43b8ecaa82f673b59722924e314689c3eb3023f93d9b6488840a5da1d6a52e0d4446dd49aad922a33564b7fccaf23094206e3f302a3ff03c43503660ebc11d34a77bcf7aab96c75e5d859f1877ba08bb622f85579e22765392b91a9b953dad478260e829c682d1fc301420055f191bc784e430316ae8f9d7c60287f81d64c2b3a483fec2276970ecf9351174e7226a421b5cd4b662aa23ac9e4abf8b7aed76e545c01546ebb4e8f7fc54a8fa127407e3f29cceefcda50175f9aeac65e32e9d73d36063a8f48d79db70d78784ecc55b1fa0477e9193d0ccf331b1ecf2b1f25587bd1849b35fbe8d9dcbfb919e7023302475fd679949d8a30d9feb0bbe2a8e63bd83aa0bd42d9063577d734800347a931bdb88e7876167d76f533c2e8c064c36443e1dee21dcc809a398d6fe37f92ecd604c53f8ae7715cde8f2eaef106b83abb356004d321d05c3dcf14dcb8c73bebc14e4d6ff76433171cc0399fdf154a7533914c5ecca38a784fd999a59b9af0b7b23606e5c055fbe238b2f551092b677a86c4689ab6df2edfc1f0f888e41e27a3d946e9752b4f5ee7831e5f107923366a08b9a6053b070769acbf41269bc27d80feaae72324b8cf283791176b4576fdfdae4d0ffd9eefa73681a55e0fe25b7c021ac741a3a366d6a4fe26a837c9dce325be469cc19f39e704a02a1fbab69c4c32eb56b9578c2c07dc450259c024460e6b65984c41cdccb02257d45c09a206e6ec4ff38dca8f21621cc7c69c94a6d895771deb87b3ccfeb7f18c37917ffa46f3b483a3e4749ce0fe2c0914ac2c1503ae85875c08d8fbe280948a87b7881f29ec47ea11f70dda54c1afa636b5f4059b034fc9e3730dd4280c580d318d08ecf13f76b4dcb5925181b459e95fb28d507d6e6412f78a12f408e02fc1e48aa37176c6ccddebdbc7416e2110e6966fe49e51af227355f58f489abf5d8258448cbfc5dd639eb76dd58eeede963b3d942a173cfe0dbc3ed3bba0d0b9f251e5663d1e5c28928c5ca2f00987e70744f7500f42681204cadeb25904ba3e180325f1af4f9cb1d8be45e5556e10eb4df01103b597ae86a91a0b007beadbf19444b3f3c41a1f158fa42bd20aa6faa9a1d9e95edaccf01e5d4f34bb9d732e55d3ae9b3c2cf8b24c4aba4f095981a540766a5929654f9ff56ca1e1efe5092258b747ebb6c1f52770c0274cb9b97a366cd4bc0661586ed3d81bd5404f65133fe4af24c863062c7a1e0173ff3f7f7de8d8e9150ebf186d7a0db73e1c6d902b9168cb212a9ccbf365a9ac7864d75d8499b93f80a6eb2c7f9f03e087c92d52f501a2fb92d851bdf720a47b3f9f0c966e4a74bcdaabbbff00ebe2a0e5c320ecd13461505c25b6c39557b88e24b149fa0d82d0e473772442ca56633a9719d8b7bf65a17e2d99834e8584729e71e624a6961549fc4bfceb47bc1b0efc002695364ce50edc3bf0bdfea2f896bf526e5b23fbb4b050459d9ab7b82b3d5ed8c4039bb012debb1b85c332c9af4d81ec5803d41e65d8cc57a720a17588b84e4bc7d453ceeba4a99c9c8cc80937b191d4f15810ea4b4953a0681072937a61ea48d3a9d604dc8ecf757aa0efe74561e472fe139813a16350c50bbd1b2459620e5ff78e52245e3b9975638a6813994826cd4bcd3c33847821e1ec8a93dcf64bac4e6a8f3ccddb44f05edf426f59a3fbbef2c868e79729db00a80c28e9ff60848560168a2a2151dc0741b9f5ae94aa56cbc6dbd9659388a00fd0eb69cc82f4072ca948806b8013438d2afe7d011667f3121a3c65d1c2ad7239d2facaf3e82a04aeba3f569ab122af8efbd719661f1c0881a75500245c0ae62e89ba54d86aac19ac53d72b0a1dcb9250f7defe046f4abaf14104c90f198fb873be6e8fac2dcf4df6c37024de69a293baaaae52e309042ff29fe0ba6b76d45ffd9a4599cded4d5c86750289f584ec65ab0cf61a32ef9df438c005ea2c92bfee0d441d336ad0a94c7d8786be3b8ee0d4bbb86b75b1ed63b41c8486e1fab5d9a0b949d24b166546c87ecc245d06d989349763511d4d0854a437cbccc55d81e5cf906de6f64a87376edb6f44f71900a29746070af0abd0602723fab4034b84cdbbb1ddf7399f92255b6960640d6b947969cca854e8822f6bdd915e9a500532a6f120d74b4c9a6deef4e046fc7fc5b9e563bdaf33bdf2f36c13a40e5f5bd8501cb40126aba340f59dcfd474dd859378038a9677dccdcd33de50d73a28f62c6cef1172fc40a83834c26a7fa9413ac070d17bf2fc798d75d6b8853dcc3a355e766efdcf1845b6844f83598616cee608b2eb90f7d1b01ef65b67c296f246754071e96f9a05b1eacb1057e4d53efbe316bf835563c032543ab468c22e28accab95eb48e3da5a9f6291d2b9d48e5ab95ccdd0229acd515075ca74c6a4d870484104ac793422329ea4f53d4e93198c59f866c8ccd8bf6c2464457720d8311812fc80822c1db1a1e9fae75265046ba86f4374d03a6959270f431a0b745363b4ceb492302d71e96a8ec1a7030cc73e9443583002b88ed932c8d52306063d82ac70471b7e40c94339a6eaf1bcc3c9c16b5b7daf1083c6e770e71ae4e45b5bac469bf059566ee78adbb4d9722624a9dade72c52c399c650ed51d8c3f04baffc436b4242c5ab88dc1984f2f7202f7b58a1fcc1dd9280189cb33cd390ce5c3fff48d4413b7ccf4a2e22adc83551ba984a437815d0478fa6074451eec1fafea36e36abba39bf9bce98c1d34874f8ad5a24af6bf19fab5b4ff5aea43a87c172e634b588a71836a3ce60a1976fdc7ea502209af4b31740a5a20c820164e45e7773fae52406ccdf578dba1028628f948c3f8c6c480f3ea0d7053b237764fac0c6327c5f0611fa1abffb0dccc778856522fea4f34683f716e7733599a96d0f58b78cd0c80a26355dccd0df00c298654e3dffb1153157aba3f42708002a8a2a0cbed348d2f535d9a6c3885f2df678838e3b242cf18fc941e8d59984cd2837deaad46caa269caf35b84e46abbe5e0d914b3d99e3fe32ac253051008dfdc388417db2ec92ec24d9e901f996c1bd2372b9ec616090662980fc5136bb3d9069559783d34fa88e0c40e33ca4d0a90342279ae10a9ab50d17634f7132988704e42be70c69bfb9e0aa9e804e50e4aaaaaf1be529b9f9ccd9c64353bd7cefee40d972e675a6a5250c8c893339be693af4c6a71e4cee4b65d5a366b78cfdc5592c1e28cd008d7112eef511d24b6a90884d302f57b9eda8ded83859458183baa12043cfda9fa6248ab43a16da1fc28c941bdc8bd484803d863a6aaf9b23a7f346ed31c5153a38ad12d6fca0e603118e9288412c37a1fabd77fc1de25aa29b14176b66be6bbb60d401edad542f7ef1801e42a021e7e9c1bdbb8f7843c93ab4205184b9f3fdca995b923a0656583016fb3c74f17598e2fd5d18acf1506f6dcd9d413f5a3bbdc3677f9d6e380b46dffbc762e6e0b3ad8352910abee73e8f3ff2b5219e60d954b6572fa5a43c0c03b6655cd9d1959a31242ae6257f7b700aeae7c4bfd71de8b8a3229dfc91f10789a8bc30e5647086e0e17f41b5bce09f7a197afb9a6ab96ea93e41385a063b3e7688598c7ab69abeeed4f561b36bab27114420b585f5b802de18d566809a4c5bd18ff255a4f808132f296cc602f74bfe4a4a362ed318f4e1f00f2bae1443a3afddbd5d1abe6d78d66d8b5a0a549aee3efe707f846160435ab2dd360717f96dcde7f2271ac3521fa5a8c4eb9f8a4330359985abc2768585cdf77aadb963154b1b1f4b58f5d1efae303b479d63e2b13b227872b428ff05e8db26ca9ac7d8509af9f415ad031ac18a4058dbf3f28ad09372143236392c55830b8cf039f22c8831a0c2f47835cdb38d9d788772d161afde24e975010748d77581734d5383a207d85a18ee9de507cdc16a05ad5ab6e65f859875bb42ddd634f82326df28f41f8aa16f0c9ee74c1e9b45613fdff7104b9593f1243373cc0d9b167c959bd52b8a0fad2e8ec43de75ff9fe5bdbeab728b1aa495e8a5eb6402e2da2964b88b9b54a2c45f464db484c51a610e8e1b8f02e5b8b0bf9bc11d82f320034920a47895b185a790b52028b755a00f33e3f9583b7073cd0ca43f0166e7f41b73d5b399c1acf638ac99a59016e1fbec5e6443a64889da6997c1a2d90ba6a904c0f04bf29d9e2b4de9efebf486f79aabb24d0add70cabb58b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
