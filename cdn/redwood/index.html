<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"091f3edf6b4dd16d93db322733fac47cd24e4c793c63ada1c4557b02a96f7e60e6785c34a959ac64b0ac8536dfd47c7b8edc7c3e3f2aba91cf941a84760dcf9aad966259bf281c3d2d2b99533e234c8c2b4d332c7a9e9ca4b46b55d8c322f9a0a962f2a36dd60feee1ad6350a75e555ac1ea880b992969231365d1eafb0e28f6bd49d34714ff2462f8468e2fc503bb09d66e171c4534d11520fd6aa3381c8c36ca9fbacab94357cfe0199e1b41ff058b080c7947d4cf5c0b17204717d68f37a516144b78191013133e409ff3e62f85184c72abd750a8d2dfced514317c2d9756828c2264d096bb23a4286a74f8964a67c622c831913f91b7709b28bf5a0f46bf8070c9aa9fb5b10754630017891f3601099b50337225e16cf62af9a11c54fc6ccb6eef7847bb3237aad84b13e23df2a70ae080205e2659625afb74c02838da873fbc93cc2ff4b3d5f24947f684856402d9828033ad45be91147de1ffe12fd1be8e61478c7b445874461906b261331ae7bbf3f495eee74ef6aa35af920a32f49bd7d8c55113def45448c1d99b3c4c7e6d830bd7b2c23c471452c8399506e4b78a0522aa637f3c3555bdfd63f5c70eafa8c859fd2533160cf2bbc54648f810143001354a9d2c94859e0cd72959070f0e2fbf1586a76b04d4f064d52e1b7d80d882853516266bfb1deafa8da22f9e066437ef91fbdfed0fd7b61356099fd91026cd6be5767d68447784e91da824edd1d958d53615bbf04ac87c7ec4769c653065816a77903d88b2f6e95469967b802aaaf3150827dfe8978603585fcd32fc9c127cc65d767e198615963a85a7c565b105d88a4837c6deafdfb2655c7a9244b8f6391d3039a0b357f6d5f0e3725e5095720427f16d2eb902e779f1f5cfb8fa4fe29a29a5635c3d019070838e88e4bce5c58e28eae75133ca029730656c56a82942d0100e3b1f6997a8eb5273782c72f2f3361e74ea6248b8f933ffc2bd215e711552943d5cd8d679de2f0a3465e89d4266c1b55d2612306f28a3e72386aea9c7a9841b267974af698754baf3b2a09db1ebf144a5ebafd8712f82daed9180f2c066e5347539f5b05a6ad6b1bbbb07651870b79f2f47c3711ef139aff2757d8d4017b06a7234cfd55bfd210b678dbf7053628a080c99489e1d015f9a949c45169fd370392ef60df14ac6379d96ac66f8557305cb8ef6c2e5dd8aafc24d7673cefef89a07744eb76139aa9df7eec632184b87a9dfc432f77c3e9557a822c6d993732a7fb46489f3bcb280c424711b5423f236a81b74c60b217cc9b3cb17c55be1a97454c2c6d5435aeee3d4dfc0b153883de9ad396c850d5bd6b918fe50a3a050aa9d6733210309ebbd0c29d3867fd11c10b07e339c01f0df19daf8aafb88f7f315ca984266db69f35c68e1ea833a92549ed1706d70bc8c2c2165e77bc21e9c1118b0f59ad150a2953e6d41eed97d20cdc3b285e6766d9250bca7b97b0b8300d288685e4e66b80b6e50f5756e7bda476476772c9edffa466142f113ce396fd8cd757b249b80a22e7ef0ffebb96ad84040f621eea0161e14b396c3c5905da27c22123f586dafe446a96103d7faef2242ef74c4c8b4324317b11e6310743cf530d11d3e38b682519deeffb1b1046c27e1149254b4f4805b1cef8162edb64f413a50be6601d5944ecba14326bb29cae100de860ad24edc8fe67455820e82723cd4a4a4a4905d762385aa59ba821c213a6e7c64904fd21a17b48576288ca80a53839c0c588bdaa7ae3a7ae87ac137d680bf64a8fa13992ffff7ff12ba8c8049f8cf3b6fd485b02665082f345d5b7b66f6691b188baf81f05878099558c854a7023fcdb1ee2be56a32f6821f77efbb8fba8d49ac05460bd6b820dd71a4d2adb9001945cda5aa111d6fa6c12d60766589c9d64e39085746f195aa048aba4819b9e99ca900040c609d4dc4d83ad4cd14f70971e18fcac31f1055b9858d3ed61f6fb38117d9c41abab4a20bc37ff4513cc6362661cf163ec793d0db90241c772d556a814cd8453b0831529dcdea78777d0eb4e1982bd7ab3099e3dff7e92ce5e44916e7ebe7865721f6e336e7e26fdc9c3130d9527b5ab40865a119b36553f963814059be66435c6e6f6bc23e99a3d1c0440891951b5ea9a2250db051c53f47d4554616a2454e5c7ac81532bfa7bfdbb70ca1211bc68af6f1a7e80caeaa6aa0c36d5bf1987542de195c62f4c462048301f79f44286444a720e8b53477203b481874664a4d316ff95eac04ebeca2a78ff5cf441251914d2505e62b44a53660794b31be22cf20095445356542e014468927781cadc706ac0ce2be656125b94ba20c6faf309645800b3c50a34cf67d88671a495b8e1b1168ddbe8ba99702009a91386d2aafb3f8f768d30979ebaf981f8e170b322d7333fe1bdebff20305c774f3fbd68b073e9135675d40e740bf23c7fe3633e415384f441be0836e95814bbf3cac206a92ae4bf1fb116657139f1e3d732a17ba77afee95a2c9205c8902f254989eb4dee8c13b0a220b951674dbb69013c74dd68094e72cdb552555fc7e7271bf3ca9034d1cebbf7acd305a10e27ea5fbcc1a4b80e3ec44f4016843c1ec711f5b8454aba973ce8cfae90d772332210e5643cddb11edf36e054f357add374a5b1d88e43e94f0b984c18e7d37bc585ce370cdd7ebe01b04ad55a00574bbfafd3f91e932f8f270e3f7ec98c4427941d8c5c19bf79915779910754985bfb77b49a55b5290429eae58b54c778f8a00aca36d4d8862f3b4d31f97c4054cb42b5b37d56c71ab056ffc4a10dd4d1e58fef3686876460ac43530f7c7ba21ad39ec8f6570d48b4551f5e1813bbb9c114d63b09e3d6aeae88fbbcc646e944b71852e6f8227831cb3a69b20da75afeed83c97367ee60187431c4535e1e33bd904c9cdc619304db8df33e7d7a499880ad18cca1d4154652105c160f7b2345848d7c722dd417abaf5b447c81da9c15cafe2d177ba27566201444badf55b8f51c2e2735b4fbf44e74c119f9d175f258b5f03d4b7f9eae5820fab304699e50cfd590963bc290806e4237f00c5b3627a9f84d50ef54c3cfb29fa1707b2ebda4f45d5981af4955f9b44abf9f59cb36a32ef896fdcaf3f1e8ee4dcd5c8b3edd2a9898368392ffb02376cd7975b17b744495ead7c340bb4a6437bc8489ab2e7ac5d4aa2150902e16e2214cb60bdf4d48eb41d907874a5daa23a3f4d3fdb75e7753d692b05b98f8ef223ee60e2db308670457da3826c37d056497fbdfb89849a1660cbd0e855c3f91b3316c21bcf455a66a05b2490e408a6d4811e5743fab7bee2e37c506d0a40020577c55c7e91acd46aeeeabcf532f8ddf5499a714195adba4b34f9169f9f92c0787dd9d95372afbd138a88bc47e7557e6ce601efd74ae862cb047a68ae735177446759c6842c76c706a54bfd8ea7326722baa09cee25fb16cb87499ffd2e6434b32c635e6f89f827353c209ea028897d39e19fffcbe52b09a7326db4aac730515aaa1b4290e74fe1983fd341bbd42701362f5597e4f9109e6ac84fb1a8305a7fc418ebab8c148ab3974922d0d4bf0a0b82aacc98854017456e189d715a500691f49a392baa3431e934a93a5949a24e4ef8ca82e803be7feadf57dc888aaf10d10875fe452fdc02bb4a2a414a194c95a2f9d28b5579eb811eb0be828fcc4f2de71233962834d1d38d224555a63431648da557d14101bf7fee7fba896f3b2d1849cfb792e9542351dcbd9f5d93ee05778da869478e51371b88e3e58f3ed04279ed7acf91b3014fa9518c6abbfb7f2d273a7512cccfed148495df7d16bd671037ff1714d68d47f233b3ccc201c7bd20d6548a0e59217d24bfe712f5475c9dd490118be15b8c33aa80b043206f01d0f823aff6455f8861963cab05f6d8617c22c703012d98eac33c6fb4d97c94b81c69aeeac59d980780e6c087ab617d09f17a139d3f86415dce9f98a54dc0d860502ee9426e50f539a4ea9d92751a03d695acb6a692b93e0d548e565a8cf933451dc29af80437b0e46dac8e00c3e57e30aa84c18def2fca8aa944d740fd45967bf71cd2da1738dc964319a6ff94ca2fd575a2019f9eee09360a479ebbd5ec426aa2b1f1b5402ad37f15e89f6a544f88845b7b40ce698e8bc42955ce8923165aeb768289be0ee9e41210fce93667df5cdbec4ec3b0512d9d91fcdd3afa694de1c51d366198099f976e14492043bf1a8cf2a9fd5daddd22709fc50362d08c6430f06f5d8fd827000bfe6afb8d01c45467c6aab0ffd2462454f380328674e911375173ffcc08990cbc1a0a8b8d7669af1700ad6f2b1b19e48159475c5f006bc6c2ec16a90074af9de43eda4515d3e9e27abbb289526a57c754f1c0ebbba5fce1d1028dbe3beb64e1dc3e5e00345726764eb59464ff8c305a1158feb493ef54a7f511d397f8c227d66428ab0111023c252f1f1d164887b1bff00c09804f6c15550df879209073978fb27b451b8826aa40d9a76601fb07d5f2f2ecb15ea61b4a5ecceb9f296c03703ab7cd17b854a8b805f72c79e1eab0824f5c416301215f7df5e6abe080d01d8b830c21042584071eb935d03a46859a848916d9491aff6808cf2d64cd4f761a32c60d05b9c4be1946151fdc25e4eeac28a83e233fb04a25b95d3bd6cb5766e1b2cb5cd419318b5ab1d548d8604973804688b5d2300d9d57de684434d88fd9ab312863744049fc704b8d24518f41febb55ad275e68e27fe3d955fd53006887e401fb08831e8b87ad19f094218b7113dd430dfb445fbb85c04cf85f264621f45eab692b7c040b6bebe883b38f8604cf46958bcbb5be4304f71fb692c95d743190f8e8302a33fa1c7d36284187bf03a645223ca8b33b6929c73608da1f8cd4c0dbc8844783141c4b680cb3d1570ca55158800afe66686e7eb61717b58bb0c308807af680e94319af572eaf1065590cd65402a346df10ae0540c32e286f99988fcf175fca61037dd40d0d1fdb70b7af27057be3a17af73d98b3f2e1d9538d065b66247179dbc0bd84214c62a31cd82dd290a342254d62f19a60b7b580ab7fcb4bab2722f95d0650713d7e125fc173b8223b189356daefadccfd35c3158ecf35adc66449f774198ecc95da5df29a9ddfe3ca8158ba3f90acecf8213194c0c9fddf998e68cdd9a9cbec09b410c1b14947acae3e3f79e035707251682d37637155916dddf1713f353829c72cd1c6e08446c78edff96123266f56ca21b1bfcdeb2b5dab2bcd285e78ebb1a56d2d337da69c0c2bc376e9f027273798b56f8b0f573af563550a073c4f8c7387439dad1b3c979ee392ef36865fe0181be8208d590b418897f1ea916cdfb14dde80abcf648e3368951f114939fd70c913a6f6b1c1b8389f0e0ce5136ccbe7f1b6e63c9129412126cc01daa202aa905214983c641c274be7092c51f67b869e82d77eb88c7a31ab9eb770ef563b8c6f3b56668ccee3d2993a8e7e78b3d4d5839b761ccb0cd6ebc5dff2dbe143e7cdc9f855c21aa158d011a3e397755044d46f05161123af8454139f6f52ccd25453a9b1f3cea2eb197735dc570104bfb22340be89dbcc0b192f786029c8990e320b191d9dafece800b0d2474c71d0d15ca69e8becd3090808c164889aa123c0f177764a61afeb8ba770f159866dda1727d51c33bde9cf8c1782b385c7d6d966269b0449789349b5deb5e3cac1c65ad60bae24365462f4907016e74cb42157f92c9086b407afff79150295de9c6ec928a9bf82cc5c9fb98c22ec10cbda281b6b0c1ee9a7563c0372a7a827283f98fa904441d81879f07d02cfc0a52346dce7f6583f8768daeb2dc124d2001c03c28baeec3b4e30e9bfb01749db1f397057bcd997c08c1ecd9af29471bc7043f2d2525840e6c3b9269463e848ad252a4ba57c2038e1fc197be121d35121d33f502634c18483adf29f759d117f9eb668b9fc9f0bf39c895821c39af917da6380540c9984fe90e25b1b0c958aee52c0f2336042bacafb2b0852a3ae9f6022a94189707b950c7649714c679412618a0dc3781f7ae8140f3b48ffac1be72cf7f40b97e6ed14cc648e117faa61afb8453c2e6e220bdca76c7ccbe67df6afaeb67a86c3b8725729d5de016aa2a7c5475c9e4e62e19343e697585bd3c87cc16436bf90b0f71e2f153a6e9a7d15255b22b62ec995f14ab8f0ef1c81c5eeea2224790ce214903e319c7e7fd96c86575767fe9780ed3b81f58c8674b8d70c9c6893c15ac9bcbdbb9237cd219898d57aac85cf932475e025642263f8f6481c81a644c8da01baa916beb973ac442e24e77d63ec9ba2384f4e8e57dc186815b88916eb038b3c86cba12f6824bc4ef77502d6088cda6aaeaf5dc7edc434582ddd2691a7a8d27350e3921cd7d2d3bd0fa3a8c77ff1cc10adf97216f49160724b2b9f1f70134f8dd83bed9e643dd467e4679151ed1b34bd99458b5bc74133131ac964ef45678b84c40520b357fafdd1345eb417e5e60e7ad195b959459dedf6287fdb26c0aca67c19ab61b0cebdbe15e45aaaed2f38f1d94c46af2d8718784acca1f4d3dd7ef23dec899ce8fc4f4884c7ac2f0204ab8d5566c65d3c28c60bb652e57d5e7005a2322d340fc62cf43ce1be1a995e71f7734863f102555fabb5a076259e13028960460fa15cdec6596e56257d7fda9ffd61455bcda4c67a43776dbf00a55830f68f859965bb322736fb64051ecaa27e9e468dcd2d7212eab6423e3e3653fc5965499c6b3ec76052cdfa2860c5c1d55eb7421cceb0adf59e47cf437aa54bd8204283aab06792c3d637251b7470b1d57a571dee8442be835a508a12e653270df3776af1458e8422fffb4682d0f19d6370f3d26588c9bac3b5f254d5406037b221bbd931fa2e08272272e05c5e9bb205afc349491605b9147bb37f318c0666f20188e7bc9576b0e863e4cfed49479578c6bbeda8762581d1527d9387a088cbacf04eb514df6bfb3465366f4c8570b2ba80a716f9f638286634040c62774c7f00951a95b6d9b3ae13164f2a12602a37619386f1b511f9d0934560471bc89294d49d18f5fb6feeae143fb17f507f53efe0c38c62345c5be35379acb1ca62ec8b741dee917630698f896e2e80a31b0f52dc812958243c8b3b010b26cca8b784e35150d4a82250c4043bbad575e7a4df1aa348279cdd45acd753af3e71260afbad6ad493086b588bbb66a01bf2b59e886693518ef2d009d673dbe83f0463582ae41ef61d2a657600eb55ecb62338e2ceecaa2d35a4567d6156d32fd49315e91c0a03f6aec0b92f9d26607325076ae86236b9641a7c54983cffd11644d2c7f43a166b51e978dc4c3ef92f6c419385562696bb802afd8ffc56ed439ea3efc7a0d98dddcb40b2488987abb7e11072957c8df39fa4ae15cb01113b255de4bce2acfce001aafbc89945be47c10935e12bb7b57f0322f4f259e7aa4f4195ad08b1533978520de86701b74261472b54d9639d314fe50788f2c475685cf76ee48922c585d9852583c2cca1d94dc4779e6dfb9652f6b820a04ca08bb19706193b8116bd8f38355f995415785a94bf052dad5c89ce6fc82f31ae22b705ef605ebcdc2a4dcb7d3215d88ba8c38e5972f9466a9df7a12d5e3ae9d8fc3b8c76b29684671a3be1a3948a79ce7d232224545dac50fb04e032348c8e2914baa7d83aa27f7169a9966370d40b33351d69acd26535d2f88ef46033b9168eeaf3859fcb9fa5c2471b2b330d8706a07c44fbb8812980d6efa68dc4c817a5ecdefc9053206690368316f915afcaa1b2e1ee3d7d155990dfdfa16ef034dd39dcc515b0bc16296517a23673230d7d47752928aa3896c52a46e478d80bec1ffa8400ba86190ebbbd0cfd9dc5cb1a17f61f7988f70412ad9a8dc441bd8e824087fe233c3fddf98b63cfe01b83beb16e2bf8cbc9656ba52ed692531511eed37affe3973cd8a126dfde1da5e624d24247578a646746201a293e3cf152c7872ed4e287bd35b002cf7f97977f1514f5fa4ec1c38aa33a71e5afd437756ec43a379a65ba34ea64fa701c3718bf917f244b8dad64f296928acfca816382c0b7549a9dca80898077c3668b68b49313ca49392208a72ff17a2b09312b28f2aea4c0cda575641e55a99ff8d3e1e0dca44da8b5dd54c117d7ba73e9393a8f3585f073659ee6fddcd3cdb4c065604ce8ed7403b5f2b5647f40bd2918989c456938df8031598c67bb882ff02fb0d91510d9347767efb594e44e46171b47cab1b62050b442a1b82619df571b1d70bd4c74d0c6eed2879add4adc3ae63cf82b3e73a874f0cb4ab5ce6865059973ce95f37ebd26cc707ee5b692c52ccb38caf6c2f670c3ca5767c98a27f1478d740cf937377ddb9afd4b0aa1c143eb3403cccf8f3fa58b62fffb8067cd732738c31c76b807a5afa50f0232a050db6690e8315c5761ddefacc77835c285693b2d2852d4b567e6115c894b35cdbd51d496e7b5b1201f0eacc1f622c25ac495d8c88449802ed7d81ce9291ef4ff0198b24ffba7e645cb5a5f0d6e9d82d7a1093aba1e8639501c8c9f5128261ebe2ce58a4a89881fad3cc576cd4061cceca8b91184c18a2739d15b0c33f151ffe50b12be041743acf7623838f205f29e8ce60488e40d32b6555552e24452da4486c4b6f6a3c9a040c5d12cd2502a72113cc1b83103692b6069d900981baf07ceb31eac7b6d4ad16b4a13407582724a990b780b4b441a55ac3073f0b811a6fd0c0b05bbd55cec05d6918d1b5005e9a6ec510651c7c5d44490ed672dc0d59b36909cba9560eeeeb0064cf8aed55f94e52c4f6f82e8a876ecf1661c871a5a0ed98788149eaa816d3aba037611e3a280125526fa0133ef25cef5bc462b84f9a8475e6aa4efe2610836e05de9548f88392439edfa2c21ccca16d1f0c7af7f8534dbbf3eca7f85e30f60fa35853f3ac52b977d12c3c5e5748b9e9d32b6881e7f100bf85c26704617ad55bdfbc3bf8165b8d77cb0fd8900800d4956fd14f2cc52bd0a63969a6a36aaaa886a8cc90eb05fae76ff729e6731cd02686541cd93cdd6bc02836071d9ca129973e1f187bc072bf059b1411f5b14c859cdb33cb5f3f0fbb241fefe32d68e4e0cbeaaa90f556405ebbe1f56c45ea1013c30f7ec778b4cecc32394ed03c1b5395760711f2e057c3139bdeb0e3fc28380823bcc226f2afc1e67f154ad2d52fc01e1b5a4dd5607d3155b28f49c2b77e7daa7f3a581be438742ec1464993180b02178fab0dadf7aab784e9de6fbd719b5727551b8441a434b4660ce0d5e490b0d49931c7ada01a23216af2fb2366f057266341e4058e27508cd72047e8367c483cf22a18e16a24db6da9804cc192c61cfdfdfa3c05a8fe7b49f6944d56ed70e577cd80742315853f21b85926790604afeb0ed97a7c12def1b743ff241420ddf9c1ddd353478793acc0e37a00141b8fa58f1b08db6a0aeafb8fc084123f7af5e6e9804ddc110d8c2139944ce228ad8c018a90f9ebd7d3b4e12cbdbb9758172cbf6bf43de11c2800d1271dcc8f851317ed633d450cd1dfc7f6adf80da3d70bdc9a653cb0393272a1b5b08e55188fc7cdfed342c212d81a8ef13365fbf6d7522d71651aeb26f855c63cc6cc572da71518fddb48e05835412d79b2a803a7dd45a4dad85d116b6d6fb2a1100c38451c52bf995513e08891d85666ca072fedf6abf28dd46ed3f74ea9f7f846de90f8910ffa149c04a30b99014339a37d807e0e54d9dd49213bce61072cf5394f2246731d37bf7e479764698f4286608a3663e0b79c27506dc5c3a36fa28cd9fa819d08a12de1ea9cee72630f0614b3f380dd73d3fa7c160099749738795e5683d02bea86ab4d1bc14e4a46e2ec5a110c51ef25687c39082260dc99ce8c39bc59cd584fb21dac36ac3f06ac6923b2c1bdd85ab7c2b9e7611d546f8c2916d9a2ec018f788c39c4975262d5f6f129b2808b348db3b6af4af837e790abcb198430e02b155e0eb22dcbc81c755c830947309ed03dc579ab5db12d3c9642144dc65b3105a9c3688e528cf0e8e99f5b176302a32af7e8dd9f7fc25cfe19dae11c075fb37e1cdbe0a238391dfa70b75b0f39d85916ee884dfc8c928c05a2acda61dd7eba0b2d848c43c06436b9d2332a2907c61257dfb84074f3aaa0839745171ef0e9e2468160b9edc8ce8fc719cd5a43f93bbafd0bf6986b224fee1fa180a1b25117f8657351358e05ea6deae6d5887536d9eb2e0c58af77a6e6817100ee5546376dcfdee7df1d288f88bb54693292c643878590391d115fd184b59176186d833033730ae123cefe234e625556da083b47fb58aee05a6357da4c7f22d8588737c591cc9a75cea7243dd6ac4a02bc3ddfb93e55d12c864a67554ff0891651b4ae57a5d6776063dff4a22db5855e790a461c98f65f64a19a9bc51de0e64c9dbba075170eff6bf22c664363330791c303542f051b2c03ea96084531c10691a27718e79c9bbcd4daeff1e26ecae7bd38cdd181b2b3d1bffb1444d7284cb2f329c816c57f8dd17e6a519c147430bbca49b66254f25e618b24681adc4370d38d833cdb26c05d0c7e19f92af25a6a7ed64aab77cfc157945b8d5e2ce47a3b93fa8a532b660121d2657f9951940c227a74b0f8b841dc9afa8aac068ac0a986d868021c59427bbea36f94b380443c87dff4f661f09f827e07fda1f0b4e715807b31baebe80fe85964216ee7a84c42c9ea40f7e649cdbd9c59deaeb282c12c9445648937c986e5641a975067cabf71d47f5ac5f222917f48b61da04373ae22720a8ec8988e1a45699c0858fb0d7f8c2743a0bf9aaf6eb112b522506543061b4ea1cce8469e434a5a5113e05e62526a5113644fdf1b90afd51b7af71a032ce9f6e7cf7c168033bcf757409cb717a7d3c2ef41d9f5164335a830dcd5c96341d8dbf4c86c80ad2b016c0e51388fa0963e2b7a03a4cc9b57e3b4a3963b65ed419ca6b391242a0cda8a208bea8e53b96bcc5e5b0e91506e038e90e437db1c948f83720c036b080b121a8f22e2255f6683a3c680e41bcf52e44d864160fde85de3007301e5c3ea4a20a0dbe4155739650b5a7bce12a1bc11f5a76fb3b48349886f140a1bc23df38c6ea17d5419471995a7677f0fb836dc2dd3de2b78471c31e08b5857fcf6f0abfca8fc54488430d67ebaf3d3d33c9b4e03b0e7bb6b53a0a2a9e96d65c9580dee4f8d82d22350b58196d8cbae9ea65d06788b4089d9cce3e4773ad8dedb4e4f891c2aef39a2b884f5745d0733930842fea7fb4d95b13669eff89900f3c9ebabd1bdcd069013ef3bf7b98e5154d9515d459e6e1998bbd2662aca8d8aded9bdda097934341a5765a559443c29c992607ff2b249be530f0331e7751c7838bec5fe307be46ff0f7271dc74b9ea8a1fad12bb55b90bd049a078db6fc6f7de9e2e93e1757771e9fc9d555c146398f11aa3e7259e1970c20ae669ac5ac41b73580f6fad04ac6794e11e8e0f1af26becc62e3fab8fd60c9740dd6f7afebf1e6c3b868bc0041aef15e7f613e798fb32a2aa2aae649988fc88d3bfef8db849275ed48bc0ba3a4f56f636a121db7fcfba9747b37833a3339656a5b27bbeb9150d88e796409c3462380cee4aa3719800198d0e9ad8e1159d56c4316379e3d01c1e6a559a39912d03b73eb409c45a605faa691960ec851bcbf81377129bdd05481381911b992fa4e1ed23c8c7629ce5f2b09c7af1f340de10a3f15c3abd8a631f0c80c4ab7631a833d1acda34120c599bb76b215312658d1d7825efae9223323dfa129be6d24e030a82dd615a4df7453f1f385fb32fdab71226fae398464fc044eb64845b5c6d36cecd824a04890b5501b584fc17a97c5d334bdd7dd70a26768bcf24c55cd19b27f36425b269ad27feb39c09e79b16c8d4575a8d53fa8b8971c7983971e1dc85d71810e1c707ae6bedcf519e231680fbf1223bf0ce2be94ed38afa854e020f7459ceca363a87692b443ec743578b9b230821fa3e21bd3b509644e6662f03619af4865b58a917af6cf1ad9c370ef04b34b5c108ab24d913f9ce124bb73827894d42d39c92141fa207cf2827f23d3dc1f57e6a6c866034a8c70c0246b6c6ec3e43585e38b999b78d18cb6ed0c02b13c152b58db04eb1e8be08b6c68222c0dc253e2f29d2695a2e478e09480776bf0424c0aa77e2017078d8e1aae0ed46ddf28d78336404a174d6362753cdc63d618563aab76d600123bd9a35148bc3bdd3918db4bbc5d0618d663c988c154b414dcd9f8b706fa22e9ad196c29c6d075379077f471308676c57adc4505a12d63e87afbc8c1bb7ea5ac4c05668972ead75f834811e3df5492f725491ba699cb2db6384dcb6d362e09bc0f35ecee4175b87ae5048ee1ff0138dbadb816bdeb2055c8d0a7c1df3cdefc44f5d97a5ea7f48f5a4db2c61d1361dec4d54244c92698ef3e9b06fc4cee02ba41d8acd234e7aa0214611f4b6f8f181eb3cf9dd62aaf2be6f0d679d919265aa76fd8f665d63f7687e037629d5010cb884715e84c179170cefa3758b81c08339ccad7f5f7c9ee257a0d07c18ed51387b0ca95ab36fa4c1336af475720efe83e1a7b683ea2ef58c93d6f90b0cc122f843d4a45b19206c0b60d0268da8a63c0539f9f9e69ff9c84ddbe43efad0adc98a8bab3252bcd269fe3d9e530bbbed296193b6f4513183b7a67ffc5d3890c2b69950d6aa5cb71ef2dd112f226dbef5ffbb825ee3b14909aae31b69a692155f710950f6ac13cddebd94e01dc2cd1d448c32f53b8387c17dff3d6b308cb7f338c93000f38e4dc4b2e048af5cd0eb4008b8f16e54e5c970a30bd1d6ee9c00401715daf478ad0df29467c3ac883aca9692f035f006be3ee9a781a681b741986b540c823acd3446ed32d4014248af39daccaa1ba29af5ee14ee7fdc03e20f10c5f99b76e278a063e910531f3bbcefa422379f89dedaf5d71d796945df04cfc3c01bfe188a93401262e80299d42f51965f21ee7ee391449fb165eb187c8b8a54f91e67ae574ee2410a5ed55e6c2161bd0ce63b1adb459b6cdac2085d6b57928751e9b194d37dc98fa2073045d542666b3db351f6e1c24629c746eab30b368e6f8b5aab3f1c331507aa6e091c7742566b90a103c7d5393de9f6161a98c0f3a9713403cccccf428938692417bcbebffee3a2b7be6f34ab803cb7a1dca59237cf5551a97005c5d2ddcbf724310f2f44fdea39ca7a51ca31bb1846ffde2dd2b8b2b6f55e050b690c8fffcfad3dca68ff33f137d1f9490880471add7d4fe0a0c2f92c3644e4ffa831c57e107837f0e87adf3f304ff95cfcc7b1667a979e92a052ae5130a6a7d3ff26a5ed3fe062204f24d7ab590c39ce3ee80431e6f4945433dcfe6d5e6b83493b71b49de753eab4337d726491e3fd3915744df90767bfa9b387845eee928cd3e3ea1a77428b7998b908d3113f589c21d813eed25a7a84eaaf2b1b71a9cd13bbfa9506d7d5d6654203cce8bfbf4221ddbb19c4bc31c28f38ae866688ccd540c636ecc99e08f1a8ed34bb7dbe60a0e9fe1dca5638c3128d7a1b96a57fb55d1c4706f404b765399e74b96550c4f17d874e1d5960159780aaa1f3db175e7a9c2e4d2e37bbf1441379f8b79087031269e859e47b2bf2a7181921b8b2ef9515bd70979af4f7989739b0f10f194a46cd322aaec95032d821b25eb759d200b33a7efbae70b3c60d7c53713db0e6a0afe98e20f28caa9149354ccd6c2ed98d2dfaa38cde2c9e665ac7e70a324d4edd8d6ab14de162a0e72f5b5df83086b55e7438a9ee97e0eeb1fed005d97a4082983732a3c10bc7634f782790de2eb8e2be1555c42af151b3d8d7b93fd4e081a6b00e77067d6e0fb1a150eaa9aa1fda3977ca564b05da1c66849e3a8d406156f281c636fb98f8990266825e2d621c72007d0d352afd2dd61355796410beba36c00a244457f673a6e0f29e26c14eabd906faca61b9e1de9cc46f0322fa90ec140e81872a1f0ad3070ee21af1691e6d1491d935326da796101f61bca6d0f81b9b20780314035cc63e5aeedcc1d1121a94c819a1527f2bc93c88506ed5fb1bfbd97e44d2db2d516b11b04d9dceaaae762c2b0b4df49b59d2fb866a840fd943c5c1c2ef7b56d64d58de248e0da0ea9dd95a2677f6a9d528c7ab42dda55411083b698ec2a84aa161d11c7079546677489c0497000a56c61b64f58134d2bbfcd97ef1607f0b7b33ea47f41f69fa3d3c59a515ea1d8da5622c8aa132d345945c5fe26f0ea8c6f48d5468162a5e1fc36fdbd1308d9ea841e827c7f5192d815afae9a65d71f1181cbdae07965e70b73cdace3bb5c9d49af13a77eaca2b804bc440b7ab8c1dbce5d812e326f64fe343f6b030c8aaa5b33d1be13cde1b01cc138be8dd7afcdd3848e2311da24a7de90094d546c945deda5e8b75de4c06944c1b481a91e52235a2dcf3206748f693da20599ab2d1845bab5fdeed41d34d59cecbdd29666869cac0f2436483b2b3e38e991e723db0793466d91225882004770f5397cda6e800b42514717bb12b2e081222bea6a68051fd3d2c2d9de500436a4d390dc2d62389b7c36b5811752cd08cd92d7c08c91f60d047e1d5862d5f33a6001a8e433f26f1744adcd743b3fcb2425aaf86dfb751c004a2488a13b5117622b52f1564541209d0e40e848707415f279f1b1d9cdba56c87823f35da37b8e6750571f0671902237c285059ff741a0ccabc42fb10dc5c4edb151d3f094b8963784ab02e95a370e4003cd0272330a52ae152de061a981e982bb7f61390c525b4390ee906ffbd9e37aa0aaaf15920fb3dc6ae9635c20b0485aa9800a42c45968cac2bd32e0ea492bd37f80dabcf46b5acf044faf0ac251c4af4e57b598659b05a5b33c5f0685be9298ef448f14f389b0c10d754d28b234e09750e11838889f989f88a247a3a753f0889c9b1e942ae466dcfa3087fa8894aa2204296c4c1270663777c48a9ceab85b48feadd328d63c7c6bbe650ade8dd5d491a47599c9b9db9c67b44e53268415a27ec7222cbcea6a9b7a6127474e4fb265000cae42410c1d4650fd892defd6a3b64a73756eb5d8fccb7c60c4df0597aa4e48dfca27f844b995a258c6850b0d27ad4f5ebb608fcd0fc2b642612e63470f0606b629886f718c744cd0efc6ac394ef457004f7d90b9c42a0305c9ecc5d421e0f18bb4cfd16d410a41389b06367b9cc7900f4cf0f8bd68da47ac5c9a1b49b2d691715ea54f3043a5e0d95e64dca07b2f6e85969b713ca371653b9fa2ca48733c904d38d66e1cf55627c8f5af56024463f6afa9a9c9cc850aaba696846533e8a58f9686346f73f7009a7b795e9aa3610d2a65c8491897bc1091aacaa2f8372ebb55cfaa747668c2394b5e1835d3dedde73ad18db25fa472ecbe85092247531ed8286a14e58bf10f8e0f20c7c851d1dd72a0db52cf167b73d7fbfe73369bd3a1323426d8ac2abe8e9e49e0ab8d3a4abdee51f17922812f75a5ac5fd64c7e33b9170dcadff23cd1c3a3f747d8e207068539f68070f395cfb452a2cc9f42535c46898d04ccc1895206e293f12ba0e9b257bf02719e456d44fdb26bdbb56c569a3b14c61baba291f4ea24bb82a26a68bc62eac6e051a45bf7e88c4e1e086bdfc63f95d45d56bfc865e54f073403d9364544dde4d672bb40fea10a37f299f99b7cf9c8adbc762ace54eeab60a9f1862348ae02dafac3c6ec4fe0c5e57ae02f99fc890353d6e2956d9bc15b7948056998803df1175d4f6a2c82979e63804c781aa2a3954129de1b145c1bd0ddd4c57b4e75f645df85a6f0d2d03290a514a7a878fc79f853cbb2b2ac06987a9a0522f2bb1a4128dee71a62f8ccaf7818d11302805106b6930184af5bc1e178a567950b1ce4b96c94516cfe87670bad00b29b037215162b144bdcc04fe31f8a0c9f71bfbd2a889372f242c65b0d7190c9fee0358bd69ca4d45a760877c6c3906d5ba5a7dfedcf381eff51935472d241e926e2ca67d8226afbdfbafc2b3553d9c91acc78d135d98fd159fb40e4e56e6b697706063d68d5158c978c2ecf66bc5de284928805e96a9203da4951f075ca7e78866f358790b1a7e02d620c09087b5630999376a2e2eaea008c573b3508da29f8dff36b392a869993d72e9ef3b0d8f1d5eb6f9be6bce3d72ba79f5fab2bdd7ff2cb0e79a40398b3fa44260754efc822fd59f5de4a54981bd77f8d334fcd3a62b69cf76f2a0559840aed344c237345ef1da366491a2b9be687926044b16b2080eb032026c449f7a18d4c34585d9f2837927783774365f9dd496b4348246839da2dd2c85dcc12153ffd38480f666d31da0130bb8facdcd478a100515631ed2ece4ce556a463abe2451ab07247e340081409bdb4fb162010b232df2751beffaddacf350d754f817d1ab8d06830cb9f590d6e577b3a769e5085c7dfd7124e357ed8d6022b5541c1c0a683abcd35a7be8e59fe8ad7fcc5fc5418ff56aae1db066f7863ee09c8d39eb150b70d2491ae908bb7993c92faa3cb872e07049ab3dd3055a0c891252e80685cb38cd70f6b111cfcbd4174f48617b9ec5b2a62a0aa21e92c423df01bed8b81f0e0419308528cbfd9921dd6d1ef8df37d692cece7342557c8ccd0034431a5b5e770ecb2d4c1ff61fb750877951b0e2bb3403fa8981e77607b098dac14bb1fee9b46db5b0fcf5367c75cbd6990a67d1339b77605b435f22d7344ee835eb525a639d58dcc22bdffaa9e683128ce700da904e301934f265ae67b17d4aca8af8586b154506cb5523a8573f7017fc055f1c38bb3e67c98da8a7881c87fc0d53a912b4e8c07c64d129074850b6945e441054af921dd0d48b33da73a29f32d4c765301346c112d6f76df53487e711f1fcde205a285737ebb5ef9ac93c2671926a3a797f79ce3563104ef46e95fcdebf9376512136c2e4bfe5f2c72536d7b566ad4905a718bd7a436ace7d8a2c1029563af1f811046f6058c8df2928eca4bb1355c41b657478869d56bba28ac7296bbf4bb2cc07a313930e26fe21927c2e498f8333d8533b985ad73bcc701a163649a5e458df489289f243179bf13656c4d5ffbfe707d3aab27199ebf9be24b55b1ce2ad7e3a69e30ff2ce3b9cf243a21e2bd30284b21d326edf0c8da744e75f8f392b3b322e14a7fa65f501267b8cde3df3e47709c6a88f5a596522942c0da0dc0c7c4e55d064c4857253bf4a5f22283e32c9c90db7f3f63c4e324c9ea9c2d99b62ce66306dba5866be14fe2e6f58cb57b9f5de299cee43409aa829811af70979b0794a8de88c920953094d34dfb545052991ef8116decb462f40a7d65681ce026cd5a905a433947f5edfcad52d08cd444129b8aa9cc32ac49bb2dba30a365fcac9cfa15a68cb059daadcaa3c33f49b61c7b651217b78d1335aaeb80e230664dc949fb513575d7ab43fe33dfbdb669e0c2f1419191ac72fe2b3d69af29e9c6dfd995515f4972fe820d976041f703a91a2eb72e656b6cdbc1a039202ad81d28aa5562f79e3352f63c86b7f153d71a09bf42debee3656e0fcf3b6b05d7ca618799e1dd524d8ff5a313c828f398cb72c04383ea35741d8b82bebfbde51a53b662f10dbfff1d758c6c2fc24dc822476309d05d5d985f1fe03f388ffea8d4ca090007d708a267b9b9e0eec9884f3bf39ffe9b6552720bc38ae98ac4c44efebaa011703afddb8bf38201375561b28e87dbe69d3acefe9bfc8a1f51264b1ad3d2c5b2099f50a3ceff89d09fe58a10065aceb6fe494dc18af1021f6b28cb56e361e2f6b4523d0faa322ff1fdb7f0bc00232ba7889d2a1c498ae2e4ef39cbf510356a2c3b8dcba74c03bf26f71d1849a26f3bba35cb6d6ba6bea14dd30ccec9ab9651a7eb7842906c56b1c242fc23cca2f14d1657c7a10bd981e8641388d52564f91cca0ccb00c687c02afa38019f95124c0f055d48f07fbf297bbbe61ed734a31fbfc5f1e904eafc0b3ca807dd6f6b75aefb1c06c6d03eed525a7a8852dbcc76163c71a5a865234021c0c5644e1cd005e8c017582eacf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
