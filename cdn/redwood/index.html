<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"072c52d3572ec0595d279b2aa032198aed48ab4d60afb93303f363fb687d2deb2529849b6797a45bd350f6a10b4cb2fb1b218f1b5d4b6ae72784e80058c5ebc9ba2a59eae3002472d2ef6b7ed234c2072681731205cb0700c0d8cb880189aafa162fe7958895b9c8225298f301a6f02905c9d1ff0dfe7dbfdaad7433b861d39342ba6f3fac6d1bcaaad95aaf8464185cfde955cd17512dc1bbdb7b74f62ef44190bfd108bbc813221ae0cf32749de72882f8e383feb182437dc01806763dbf63f9db087110d4f7402d2c89cd5596216dbe0f433ae0496b923adf0c71b09dddfab5e0222d6639541023b79c79b9828140fb4f7dee49a789376945434984d148f970cdff64d90a4cccd2ca6cee0f17e225693daaa7af3d24a1adad6293ef50cfdef90b3657d2fb2ecc022c0de954e9f7203f0df598951cea96bf5d44d4f478e1e17f1cd59b6f5b04be9ae226f0f4660240e8becc91b414ba14f9c34331195851f798df5c856003210d324ab1314b437305504a38b19838cd4a15a9056fca2f0d6aa985e3364c5c23ce394721e3f756163d07fcdae80bc3169fa8602e899c2654e51b688c6c9f9d2801f16efc6a802c316a99757b1f9d1582e62ddda13f1d0738c8a7b19db1cffaf37a37490458343013110552e7133e5be86c7bd29ecc66d1b723e2f9976fa1e9534be4ba2a09bda8d0d3174d4acedf16abc1d524d8971c1779aa33fa9880c7dfb8362bc96c8dd708886dfd89513b82017cf53376258fa9a089534720bd5a3288276d12872f8c42e67e70f354f53d3cc1f4671efcd3f6c20c8576d2a0847c6aca3ca7f9412fa2c2c923d5c2bf6e3100a379014ad5f07dc83e31cecc643919257e95e555af6b9c93dd1941c8d06a095357ad656cd832531d1838400554a2fb4e20de4390df17f9605c4c6d230cf83de9df5c38f5b24ed005ad732eae44c2e360c58ce273d84a9e986b023a6f7059122dce543fdc3abec72a8cb63cc17084dd9a4b8fc41380ff1ad443c91adc44718f75717450c03fe0976a65f92c29a0953eeea5f0178d49d8f5aa836797c5451cc5f398ec67bbcff7dd97ac727b42c581075fe7257eafa9217e09df30bcbc5939b5614e1842f49f252b90b6c99d8d7a5d183359791d8ac29c660ab6b97cad5774409d55a4a797661f72a564535b2f87b7c6e396f928cced08de27bb9e4cc00728e7cb0cee40a5a7f558ffd48352a213ebc3b03301da7508bf60f65a71e658211dcc0481204b8766e8ddf44619955dfaf6c9a33f911f143c8e675f1d8fb5a9dd2c92462bdb01b44bcaa624994daa71d65a1730c88171027d3004d3e58c74b20bb3651c0e73ed00319781772c460d6ad933e4e4cf64113b29010d02209f34a4d73df8d584bc8e21c7d58bc3a34518539b02fcb1fc9603072bd199491bab356862b10c2c4e244276629c3ed5dd858f6db1e3c93e31d437e57f305a2c5c43e11aeaf0c5b2280b9bde10c04620201d24a2d3eaffb1ef221e2aa5ca7ea37a381a7dee75b27f2e28353d432719db2de71e543c657a66429f6c91ea220b67c0b47e634e6c9184531cebae7254e41837b275d35132d1112d291678b3619128899b9625f2f5b865313e0dacc5afb6279afa36bd3f1db66985ab025b8679a8b4f215dd6da5e68c592e507502118785c8a2400978b37068be99ab44d62eb5aa03a64725f54a9624f95a35d852f8737b0aabdfc04ddc6b5647c149a4c01170fde840a63f9091a4aff9e314b91ee68ec31608f85adc5d262bdc1da62bcce267da89f90d210b70117143f4fcd5b2d01e7c9800d9383b81d7191f426f2bbb09d2c3e98d2dd12ff3c92a66602aa09795b6e123415ebd0eeda030195333310e5b29a0b21a137bac801b1af1f89da97b6d8ffd291c871b21e4cd9b5cb60bfe76582b1cf7a113c7e9a1bb5e16f2c243acdb426cccc4bcd671ed2b446172b3bf2bc52f2df588c6eda917d44cf5c54d8a73d9cda792444f155b25f1232063a9c01322ae06319210fe3e587d70e82c75a1db381ddd1b2cfe43e9e42bc49d08ffa238a09b6953366bd28bcf02dae041c83370ee5fabcb7e291f4a1c13648f379b8bda0d11e9023f01d2d6795cbf7796761b470452bb3176b03dcc6cea64aadd79bff25694f1d7b7fe141981a8dd04c2c914283804782b300aba0c7875cf2a51cef5acb29ff031e431cbc59c4e3b0a25e26c6abd718d180a6f0952e5a0b6ba316699f3c6bd88858c2bf0eb0363d935d806a6bc67cb172fbc505ec9d69748abb257f66d2ad17789e110b2db133a3c62781dde246bd9d28ff11e645fbcd7a200259f5a2df47dec8c8384804efaad2eba41cdc06e737795d525f0146bd6d86bd7aacf378175c00460bfd03a64bd6d9db81fa49b8dd2394e4e2fc55dab77a95a5c6e2cfda3e00b96d77ee4667057b25f4520cb27d9a11a93aab02cdee6268374d123ff9f4f82b671b4b737093f5532d4699944c03ca28029f2a820043a327a3bb768767b9c00115d619a10776bdfbd4dbb2d353bd522ca109a8c31ffff6f72b28919c820874b0a8e4004115b83d504d1a5d350c3b52be3a893e6be3b670c2ad81869f8b5411d29b253904b281dc580bc6465b41d2911468a5fe554c508b3274a09896bacd8e01e4f0d8361c766d25bce3bafc5644db4fa6cf3b2081a64fa4a3f55acd6d0083553dc2b67da9d6841c816a2a0f43d77a11def2b2b6fc9798d739096dcd15e259459ec0044f77c9ad277de353dadcf4c427abc73bad3c3264d3070e2fce2eb39901fd636c35b7351500d8ed8037887a359955898037a04b3d2a21cc48ce68d0ee62ac7e072a9e5c78fe18029be4b12a923c9374c68867a36ba059a024e71a4cdce084ed4fe27761aa9a283f52a38996fceee9e4058e27b0123d81983b16ff151fd1d155d3e6c671860291c2258d6d5d7540e9c04d2a50591ed40b29a6d95ca0634108670fd4c41a64ee7c2db9c9cb372e98a1b10a18a818365a395b2e4bd4ee61b24b22f35a3a53b390adf361e7449480037a74a88eb6ee1dfcaaf1d781b086874074d2663b277c9e7fd13d9e1e079c00cb51d989858e85918f92c445bf5c146e2c6e295cb58894bdf16b20b92a31088305510a52c8bc85c11882fc4b8e4c2020a2274eceb8bb96e06b862fe1ea60705781b7ec0b1d544b7a68bc80da558ceda4189ef33ee7c10e684f3815eeaf41c7ec959fc06d58c6b313c4d6b3d837961e25b4898621faf80a8a94cc726018351319b8b5eb2dded543e02a018e1be6a790559bb649277128d0dd40eb468cae339763bffad24bf2939cf10dd9546d3f6956674fbfa2fd221ec50afc8e15e773a33e4771129cacd1988770b7fb4dc6c92856ea16cf235d9d853b6433cc075ad19619e017b01ea16d9b1f68ff62339e999e0959cabba479241aaf256544c0e38290d6c5662f7852bd4db11773737a226ad7a71f8a1148400fca00b82397b5d727aa93ab64dc591d3e86e0ba33d55dff1ffc60cd93116e1e84ecaef20e54b2c1530d301292f3a3e06d527ef1ab5093ca398ee8347721324ee2394b739fa1f31af8e88c76a835351e1418960884bd947a1350025e09ba063e047db1037f73e9e4153e633c61d1e808a89892b76d863a2ccf34cf868850b9a2a114035482a0b9f9e08d7fbad31650dac7ea6b028f59bc916b56014f5e2fb02f23f806203bb08714f3903a2e17212fbf9074a54415aca5020614ceb72c386596f3e78c62d71a891361dfb680e9f4b1e394ba9d536adf11eba963f15c4a1440fa6ec2c51e6b15971a103cd149ab72ceaf5751db8371c3d1f52b3ccf2ae62729a3b0fea81e9c146fff0d98dd390ede725b08a50d319f0e033b5ddc4a60a1876e1f0a51ef53b2a0fd9fa5a8c20e1431090dd44e7c091a3c4f4072657f6b9e789e0df7ac183e29c0a9159767e445a5cf7829b72dbdd3c7fb9dbd7585645e5e62cedbaab575fda88decdf2417c26644d7c30bc844ee8dcd846942b515c5d76fa340507266e0cd696904d4cc90fcc5b9e21116d48d674eccb7bb349b0930d75dbb4edaa88ffe21ab62af5504c96e1a7949ceab5e4fd2514b1f88ba9a95f0d09f4787bf1cc98da2eb09fc15b88e6af062cdb2051763fb433f85e7351463267d2b2dc35e220bd5034fb4c78b14ca8ff3634b05b0a701193c1e0ffe3ed29f833027b53392135baa726ba5b755f98b1d30b6560a9115dcf1023df450623ed09183c25a8ac675dcad6490dcda8ed7a17bb7ccb662abab202e74d067868826e246ab0cd04bd9c1557091cc988657bd6722ed406af3e3eba194518085de8f80de05e9482059d79d009d442e5c9a70f67eb292dfd54b70f246e8c38fc91f08f3b832f6d70a22f3a13c3cc9af5126c880531902e8056dd68ba6411c230516a504e8f79625a1064635ce1bcdd40ea3fabe5d9f29416eb882ba44d06cafd3d765666a495f8aacb0f3ccf9a96d30e6a2f8b9ab50af35fe133a27639ef6f5d72444a1cd9b30a7e1673798690a523de1abddd644871ba4254f3cc2063d4036ae07826dc634c31bd238900217bab3c6b4f041d020e6e5ac1912ca26f9cd24cd03cab88227efef7f9e0216b1fad98743f42aa51df6a94538fc1eb2f72706126f3920bf418526bf356c1dcf7a9fff562181ee9555216870772e6ba6c6d1e5d251ff7a64c9f249d85f02e2923c09d134c1f9f22cabd7fc6c104265225572121cf1ba1a7df6d5bf7705f46589df497fe3758bd9e016344aa01942eb14070e4c35e682e37063837e0aadf483b389644b7bbf0318ba1ab550283049427a3ca8f4406bfdb8619c146b5bb17f969d65fd06c4618f15d4ed245b87b1d3c458abd87b91bc1c00f56e96210708dc5c6839fe965b0c68a9f09f2864e1cec55bde70ce801896458a56eafccf15d1b24a37dfbe2b86dd2109dcd5d0247456aee7fe66b151a1b2638c398ca43eb1f602cae09093cd5f450eb8a1b99299d618c5e5a0d36b00734c71553f5cef5aec9779f81f7b8e5d595f4abeec9dcd7750453e6c733b5e0704b83b3875963ebf7fecbce961665e97b6b67274ac475d0112289bdf9f1655c506059a4d06b828dbf729bc1c9488cffa03c85225ac5f9d40c177e74d95be74a5119aace1a951d088a9e2bcab7ebbbd20644f8bd9b8d9c1601c2b150e9e5472675e63eb8a20114a35ba26bb876b23d1f43624b00d893e74322e77700ec854e2ff81ee826a2dea21995da49187c1cc81474ee0869e54534de8eb7264de6954e306f8b135c74835350c155bb6974586dc3bc2c1089050f51b53f8664893e7af26d51840bf99be08a3c959863e52c3c01399dae0f22cea99cc6be8ce79a7279e496e870b43560932c6c0a670d2d6f68dbf3005f658b9e448529f2ee6b48d97b448d06324f9085321283ba4d16c494d814262ac25b1e0065ffaebab581c0d51e0eba10c512540b1f7f53e172d6ffa7bf5354e36ef332b1ff88403625e68cf1eac30ea8925546bfca60152d35dcd3a28da5e5d72e13a5358f3cb67434641c6b479462512ebac13d420a027eccb0ed53a802e51f5be788faa7237bd880459ac8609f5c19f64a14291ce1c96022171f5f11af5ed2db93d963024b8a8e3b16d8a744ba46be99ce9834a1e415f98bb6fe3fa0cd37fd195213390b9850979e8f10d19ee3c2e5d4b185c005e0ca55a81abbb614c33348cbd3e231326e870b7b142071d2ddbaa880100d8618981e5e51ceab28f179f7c911ad9a1c8e23586ebcabdd967c396fe93e4f6f519c8e0e4bc2321209f80697efdae5b5d077112c63ec85c366c7460e02a69522f6bdaeffbde29f7d4a8d1ff31d6667f48a90bcf17ceeaa5d182ad2b101f35f8e4a5229a58d01963f0b23b4fff825f03160b015083dbee840876c3159e618870e79b5503ac9e8cee6e1488685725f135acf6746b39680b0c914528533000a0bfd745b127a7c17cf484394a2ad2946bbcadab5e1c4c0c6077275b23ca12981f6e72f1b7ee9aa2bd011f3906d478a0e67dfc4449d58a184ae9796f7dcba962a99f754aa2d32c94dc47dc426b525e9f8cd0e84255435d54f949bea5428cd85567dd372e2ccafd7235296c560a45a6e2563355badd8e66f5fd73502c94f100f968085014558f6afb36c7e0b172ff6821efc4ebf6098dd48360641e4f095fcf375b18f8c9912cfee811a2ac6dd2723d2f1d6e422a6ae5b16bdd334df8868d6d627b77f3de71e1452c73468994394bf647debb37c5c1c816e8b64e377b39d038286ee38219c49f3a2a633870ed9e1864030c1d32764074906811c58fdeb698cb8379a74c9e35ce9f51f1511ba5f4b6014f668d9f59a70a4005bdcf53b4ba4e044da979e0ce1660d57ff4a0f7666132ae42b248972ea539d6c1b0f801ee086dab9218566b16d33b82955065912c1853d75146fafb7027e17cb6a944de81d3d2c28a989ea2ff593cd2b7d4cba85834277fc4321a8cb01f25b99227cc247fc2710ad2e6759ff03656ea9b489c242fb8b5c77e8cf254a951a9a2cbccc91563b0b130aa29c90c40eb59de9082b2699b2ea4ebf71efb0d053f451873e2d7759e0485fdfc16eda5311c76cf49384e174de2bf950264c09e44f467376139a38b673093a4c5e3a15e137a3e50bdfd8be376d98ff68db28709ac5fb1ce01ed9610bf03e0e12887ad39bbe70a07f0cf7cd244ae3650b93d0cbba5c6dc22f1978bd3b913409490af41ad05de8bd4437c358fa0a9c5f6d07b017f2d282074401476bcf57c9f374ee7991c36756506afaea86740a84e6b73151184651222572bb21cc8c483ca7a8cf6f1490d1a2a61c7121fde215a4d2b680c3bfc05384943415dd4d38a11c711ca267ff13437306c8219c54a0d18cfa27c059db80cdb07b0600b2dfbc2d6600e4808ca3e8fc67405b4b094e77a8357bf5c3cbe2a010f71a12933bd8cdbcf6e1b12fa8b6fb7dc8cabecf2120f4189fdc465a86dafa61e3e0d2e2bde6edf0ab90284b2940dc81b2f74ed9246acfddf64935d8eea2ad384f207212e9c10833b160aeddd2d24a320e2c47b89a7e719d687ff7f559dd3c1b881e5568188f733843e72c6de6831fdf39b0961b331b563ab18a24672822855409b8f6e4fa9d94865be3c03c3ddd7542196cef370c9cd1592ffd6d293816471c5baefdb7115393213eb07334fb5038e3d3427a84a69974db5c675f9cb03d344fcda321c017b8a2aa94e01a22f483de5f8f3ccbd1c9b0cfc244636f1e65f7838d9d22861636ec8469f48af9ee32f7bb2628a59ad63dc0b7b174c2d886fcdfd06d03a3e94c2c7ce57159c7e9cab9e2681e5a92510916b5c830fc84404e2e1b53d5d82f6efcd4f65de50753cae1f0e072c973d6102213616b836b98d89c34410dd2dc393460168fd8417db5eed8c6ce4f5e314374319cab2eb15aed27fad5ab4d7a96b2e6e0c642462f8892d257730dd06503a53873526e9e310247dddf87da7219bba7ff342fe192ab3810beaaef91bd7deaf67b56a64edd278a26ad7c7ef5fac1c51ba7080ad51c39dd73af9660906e6c9b0d52f2834c1f7077d8290d1c7678707ce46a344c86d3431f590553cd313f1945addc692a61301d45b2c81e7011d1319edf6a3db0744baf94deb68aa68e26a7b520a627fac8989844e9021e88cea72a3c369bd40cd0546175fa1e9a8c1fb91f313000ced8dbaceba6f43b141d35ba2a67f44cd6e7d67bbd971a8e60bb1dd2680ee5f4b9fe9dfabbcc66641c3036f45a4faeba13e43710b992f3f0dfaf2488730d228afe2b3e51eb72d67ec2d6c7c5ea640b62c964584499c50b19f453ad4805983e8bc799bde9962ba46800fc48f5b847d7b35dcc8edf396e69feb8014f1b5b4e4cb456d29be48811579741455e710df01001e03e39740897cbb11056c0a901426b0c898f33e72f3bf8e211c9af3f1fe1e8858fff06cb99b1ca1fb61cd785d9eeca24750254923a3481bc1ecda6efb7f9a531ef70c73f99cef43209e8e701a651499ecc69ffd45c51d2f79aee1a1d53035c618b619078664a533b01aac96bb0007f1f56b5ad1e6b64e953c0eb4d3fae73e49b82dc28b963e728d667bedb92546a22360d65ade23f5c14b44805bffef7b59375464af202952563a981b2995d7e47c29d916f5f8cc3a623147ca0e388b2cbfd7ad6ff48129cff5a53078710656fde72c5b2b8d51a2f4f48f80282da2bd1c69a89abe260eba30fe1ce12bb794ede4e18bddd63f12b152ec024f5b739f0714b4b902eefe8f5808920397eebb03dfea149151df8652162af5cbe9e86e88de53014275fb9af94028d17a502b40cddc99fe67b7ad970f935376b372b92205fbe364e632ee57c29d7b29e28d0cca3f33f085f42a7b3a7aa668ae22459491049399bfda7d52f7ba54d12c8b9845fa4dc05254dfa67956f22e03d6cc31ebd0dbbe11e61570e5594168933920bcc60359eb7a4ca4e5ee739fa893d748c54ce719e5aaa4ededfc40e81a8b590b49f8d8df5ebf543ca23a9ad75e440a6d58571b5fd029f41d4485c5043735766fc47ed1dbaacbec6483a6397a0c1229bf475c662d2c25a0166f37c424d612828b9413f4e201cbd8c6f1969ed48be3d1f15d04a22fbbc86bbfb50a8fa83f9006b364b993ee01c67c0ae2ca4f645c87b0b08f535ce3867d28757ca54627ea5618e567e9d9d50e37cd48754c647889841332dddcd8c08a588bb3186ebe90d588a75a6ab8f98442abb3ef577893a46a0e25c4a7150cd872674d1644cdbd9091f7f067df7e811967e69042ca83f212a7a8465e10733011655e1eef035128c06ef60b4c5f1d4cfc1b19cf13865ef5f5addf182637b7567b35f225a4376f0b8ebacc056a928e6f214888ecd0661c04990a4e221e2dcc8b6e085170936da50cea6d9871d28e3fa0627cc088201b16986ef4f3726f5085f90cb45054eec414391aff5dfcab8bd1a88160b026b29292070aee2de12b4b549976abf0ed97d49ffece996f8be087d09ed4c10f43b82088159f06d893f14143e17211ca07a4e9c2ee1e151a678aa8919303525410daf1cbc9c459dd1d3c217d4afe0906b69239a5c5dbcb5b9701c2acde3fcc103879f44c2716a28554c7876dfb981de1c73cf6febcc4a656f43e113ef55ce01bcc4ace6f4ea832686d6f3d2ccac7cb3945a587c94ffbf7040df1d689aad1290185acda26f6b6bd81e72f72e215814dad4626dbf97dab9c33334373a4b064da8302da1b18c0777258d4a7731738fa98ad7cb21f898bb970616b58b6bcc00c310e3f02361f93ac7e0180a4545017dd3e3a37caf2a667fa45981efce20322727ef8b2961dd73b8142fcc66fe560dd0cb6a84d58c245959240d786336901f73b5218a19a1a82a1a4d1100e37c8a31d4f35cd855dfee5d28e6e517c5b049aa013ee3679fbbb1eec1ef2f35e798ffb274423697fa71ede404f0b52775815eebb7a6149aed6cd54e41fa89a0d06dc04fb9860660c00c5bc07eec65042dabf70d6b29eade2af0450f30fd6109b76894da98f93ba33f97abbfa9701035f4ddddf5b7b3d004c65616b2152b002eeee8aefedf4ea62b92ab4ff7d90f45575e6f2ee8a664c529d0c2fb0782ae9728cda8613790475c5418652e197211bdb1cbb03e4cdee2fbb984f1fb07489fa209bd16ecf6e49439f5342958fa10809f2526b516e7697c4b06187732f1a940f4d377a2e72f68c9dde8330c0571c2eda4c709c623c7c8962338495dba33c7b1be69dd09abff3612d3ff33d01c7d85bbe555e6e4961e4ce769835129ff5827acc448b3546b5dbd357cc9f6d2ed1bd16611fd5f076440c920147a7b969ca4c5431d42ca48b708a741115f65f72439ddc9b83a8dfdd2b5eb30f6b56559d320bf9d4f322c2cc07db478029da06c968b0d26abab2329c658bd58a2ca67815cae138836f1e24e8398925b934ca2803e9a050bff795a59ed87358f04daed990b650b900d04c6be0ada3a490784cb83974f821b25106d1337e4ecff6ace506bf89c688fe755ec48f13848d7d1f4b83d66cdee21f85d77fe9b3c3e625f8a590f2dd651d3a58a4a18d136b493ee89d6446e944cd7de334469682d5f8a8a5adb147d4e0d62b96b9f1c474ef7de90ffa88ff76b96b6e740bcad58d4d3c64bda789155d9f36a0dc7f931c4dddfe93c38d44af06390f535a8787d6cf00095e664f4159ec491859c9990a0dc55542ed6d9a06fa8d91b103c16b255ada6b2fbdc4000924f42fac7537444541654ac85ffff11da90e655f0870e681c38f14994e6d6254efc56d9274eef90db08ef4296fa9e18583704bb1b706c22a0d7672be3ab5f024c8b88124e26995b7270bdbf1bbe3ed22e9f5b7c1a1290720f766cdccc15cf5c9d997b95b38b5ca35ecebcbdef57f167a9a1ef4ca0b96a657e81b5c9c2c361a0ab392f78db53afd9dfddb780fec97485041ca2798eecd55c625f9deca871439d13c7ac11eafa74fdf2aa4cb7d8ec30b62a53ac6573277c4d9a4cf311a80aa955d4bbe2e3404f453c21c22eefae1bdba14616765ad6e3dd9dad458d8dac1290a9f9ddd34abf1fe43982ae13c3401c69525e8a4b3589989f6a8b835033c0e0aa54588321efbcee8f9178061f5e1bc6a37de34edaa9408ea6a9f195ffb7538bba721f42ead5a521eeb194e5016df54bb3e8eb34796cd5d83b388f5a43831369a90c8472542070a5a319e5d63bd0bcfc92ac794b94c1fb1e1fecdab73a0d428f194612737cd7a4d9ff9e3ab63e2429563337bea28bd5b73024f6604ffb9183b6727c695dec079ac6b2268928c3b3a98c0484c8d8f2fec48d6b856b9012001fadf1ced9dc83bd9b14af38b1ed60cffc050a7f663ad50efa77f1600377c998a19611b777ef07e3b34e9bf26f915c8f5de799a7044ebd81314e8a1ad457f9319efe75f03f6956f206da24751ac9a209b2d62a4845fbba8f789eb98771191bc41b8c92939663801b496d50912cb2e13fb5d0a7d570d08be5561e1c185f45c98654fda2ed8cde8cc2eda60b47ae1fb36317075bfdbc4ec3706d6f9c5c288381ad9d7ea0042ac82f96da827aa414a907c93a576850eb61f492ce769dc1131a3d96b29429d6231799155faa41759499e560a92e77f0d1d0fd20c098746466dd0bcb3786552e99e44784e55be95385b152efcbe1e65b0206d45adcd6e050e2161e40d892a6f4a73499efe193e01de770492b584492aab684b8c684a9e8b42e38f3e6b5c875b50c83041f7bd8b220a37e48d28990ff40b04eb2f193ad294502eff5cc77456d7165a3aa2e0bebcf3f61c7da5bbb355579c134499910c8c4a85800545fd4dfa8df881537ec8e4928e47a963ae5c2d5448c50cf72ed625a4eb045eaf2b242a6e1f4569478bf0df76ea8fec55c3a62c79bf832b0a9bb2a221893168efe6501e7857fcaa56b5b7dc4cb1e45fd6a76f7e0a15872dc1296e9d98d0a7cd0750e93db46fed1492f6fbc6ccf4aa0b26b62e7f259dc970709a1a8a10241cf31550eb519f1ba4aa3af5c61a90753711e33f0fee561e4d49e784e6ff4c99dec71633815f63c4804d9fdcba11b9c1daf294e6b82c3dce757a46ea9a49f2927202c9b3e058caca62f462b06a345d04332658efc748ccab1fb0b9e8188b6c38f8c32257ba6e604c6b84ac155a78f6dc09fcf641a451ef2d23a03fe1e4f277c43a382c5abbf72a3d4aa7fe7749dc7bbecf8ed0dba5eac68220a2042c8c08a6ea5dae79c59b62895d5720292c214f2d2b85704bf58c9c7469fffc25aa9bb084944918be2561c98c9b7d972fb58bceb59b6f0b3fc1fb42526645a5d7a7f8b692e17f93d99ba7613119349dfffcdfae9eec4dc2cd2478024957775d3cf89904711d750589a3cc824c2002036a274b10cc8383c64496efaabad4d4821237fe76bab27c96ea0a20c87e2ceb54e09f7be0e75080de4202be43471c4326ba29cbd1ef0e341300b0037256da2fcffb78e4def79e840aaaa5e5f28d3f6c0a897ded4ce0d2d5388fe9cbacdc4e3d26bc06e940745f2a114a8658b61c8cfbb60f31b3aae06238d2998984c86eec6bbe64ef2f158120c750fea6599a6ed3dc42be38820fa8fd170a6b7d0866fa21553b74b8b6d8658a11abbfbd95e54ea95a9dae8ab4e9471f06636e844c8a1ff083531a5d10147530ac2a429fa047d836aab623504f120cd588647aaec09848a7a1dcc9f00ca950bf0eb62d65df30754350f825662440959624b67f18ceb26d5641d9feb3407ed1fee11d4c0c23a195923b1841b2ab24fa4ebf3ffcd94f50eb1636760492f4df417ee40914231863bb4f3ba0a362d2e01fc8f580c15d75515479a391265bca371fa6ac6a79f7ad4f8b266437d00171ed91cb407844f36a5fdc64814840258637bdb9eddfaec566ea2a3978240fb9b3155dea87f469be0b391ce5661dd4694344c5d7a3a55cc57c5c7ae86ae6f3b8263b1b1047d0fa4ef4dff4a437301ff7cc254094e23a8bacdf5f6e7705e320f96960e81f2f24107690456276f9b5dfdeff23fecac3d44d1fd0a09eda35a2b60846049c47d59a98ddf6e3e97d3ad3a78b756544e4cbb0f4615dec7dfa7247c118969be62afa438f67db095f390c706f3662eb5cd7a6f95c045015882f239d7f3467637c1295f001d05830a1c72d22d24b933f8c93bcb113aeb3add40dc3f0d56bdd7af5c40bbdc58dd3acf7ef7201979a480a5f79199a7962882f30a992b11410afd5d165b82fdb0535caee4aac68ea12a282a6ab698f4aaabc6bddd56bbd18f4ee42ff05213a84dd0afad43841ff7a069a9cc6f5309fbc55c7339831bc5b4f329249f99b34a0790b7293551f31904ddf0e1a047faba449511aba84c649de8be35a920cedc10230c91b5c9f4b5508418a39e76499281de198afcc52f3bf5588bf7aec66f5bc41e6f569da1455320706e5dcb61a57c86d649b3734d33077e8f0f992c5ad1d052a56715b8e8897776bdab20f2dbd5b1a179618701ad8c613bb6e1ef39348651be5fbc3ee6284e95ed24597624393bf0ae281bf3e2f98beec982ab4980f25c9aa9810586892d1011727f6163c2ca33252a2e2318f7c52f85ef0f418647d100f9701624730bd40bb58da552c2e06a6b1e2a84b01958ed1739ae33ba787eb1d610571cc1313b145c95f200e6bf918b3d3d1edc0c9c824b59c1f0b63f2c700ba1ad3c6586228bd0628577d9b27feaa8589a35c5ac1888fef7d44a9db2ca5c7fd69e46c3ce8d7bbabb88d5f55088428de25244e2d4a881941874d38d334f51ce9f928e55c429d4e68da8499b0184e09522b822f4fb51db3b99601bf76c3d4791335ab74dde451798ac23bebb13ea8c4a9389b043ae99a404e1b07a2603b68a4af7e4b6047b550d19ea83744a497cd7c50d00c7f04d9cf3dc727b509da4590c8c28cba558b2c3ecae760dc66ce404326c93f9b5688395c326cbd7ecae8d5f0b9752a7a846cc58f56e26236429f19ddf68731f32b5e8bbf835f2f9d40c7f9210ae817a7169485da85e612737df6c31a4a8098d73f2b8a32362e71b51bd5569f314c10bf427d749c24d95c9469dd654bf70944a480ae4468fc9978e63484d3559e41e598a46c8f7d01c317c28fc1137a22192e1e6fa678ddf05d1da8a3ebad2c5c34808d8e26cbd5c962c8de05deda94e9fb41d08ce77036a74b680601d5ae51cc1ddb4c612d1b3d7ad16134496de99cba4cfe61587acabc150e29d1e283c87f1ad88870068674b9e05c0fa92dc14c293a39514b345b11feae3881facb93244f0ac9a48ed1b806d0a7e6c225ba26f7e663006f1f36907bda7f5d065a17bdfce36cb80130457779c1def6e4e4c479e29702504f09434209700d75e33135b2ae5099ccc0c20cca5bbec5718e1fd090da4bd70279e4833f5d41877433b64647a867b30f74249e56a01a88c5ba42baa213d9c732ffb4778672c4d258d084693d20a9597890159ec537835df4620262eb3f57f8731487725e6841a2a147e0304c84707b4eb293b6a949f1fbb13a6edfffffb813b5656ed142c42c1568d9e378569f793a18859a6a71ff692fb7fa68ff602eca58a3e928512d58b34c0a582483695e99a6444b9e245d23839b26ec0cdb24d9b951d84570b16a8f187538a296f408be43d1bfb9603abad14e22acd960ebb1f42434fcc3573313d94f17e69651fdacc86261a8117d8a02c8a3dc0c04ab7893a8c4bf5ef76d15755a2a90f67d320564869cc35f8a13e83038bf671835ce95d183c1a256a1b43f8064e3ef3e8f69b4b5c13c0db7cd22a71114ffad5961d63813203617ecccd824256ed78460cb09a48d61572eed68e87546681e3a19e8a91a68e87e2547a1b9285675a67f7f5292751568ff3d4981b4055954de037cd698a9e3b816bd63b56e06b41ef0ce276db14caae69b8abad42f9359e69a31335873cd7c7f93b04ccf0e2159bcc48c9be540dfab839df262342e3d7d19ad4e749cffbec4956ec289e44465fe10b1f08c185c7b73b46be6b07d2bc300b0deb2cb8a5d33e4283a93585067713ca6a3e775090e1989104c6e1fe4090c47eceef8b902872529cd1ce4ee0b0f6ead06303c9b8750abeda00427d855d41d9c04fb41864eaf5ccdf8d705f6de8f825fe22e8ce659eec6a8666ebabadec1954cef9e0379cb57b876b5cf3dc012d165ff24a2ed13ac2bb7a55b5c9aa6e8e63b47a82e43b346a4f06f286d00393dcac524435a0c2b7d0f4846e58919e8baf782dc94b654f6777a6bf32d67fced42fe91d753b80f95a25787b65e4a357faf4f314868d615f2a6362aab393f63533ac198ea922a026d534e7905614273f9324a6ab7e7088bbcb28589f57fde196115d443641db6bb8525c9d6413f66490f9b8fa8dea9304b1979cfa2fe5434378769cf2032844c7b47455ccb6b04638524f84c505b996befe18ca9c7cd08c74cd318592fcfd00e648ec320406371263a2a52ba8459075c672923bbf75f18078e14baccf39a709951a5a8d45746df81c031914ee371a06485a10587c38f353c5524d9778e37975ae80b3794ec14572b4b204a452106cbd1650fa672e93df666b2c66ea38e1878120a5255d94fb9e9b30ead94f0304d101e05a86c3df9e5945f97adc710438aa3d4840457934db4e45c04a437c66024bf43d100b8e0bfe4d44d0ee0c909e08c1852e57f39a418698e3656cd84cfe7b9f4a41107709cc9390da37dfbd3e32451807a0d08ec5217adbd63648a571af43507c114d2743f54b754d2c21318a06923775d568cc6ca5c5cadb83fa7770de75f7d598042ed2634fcbc57692deaeb473170ed48def9dc81fa59e5f1649314815770e5be83fd0c8e82f5fd8a179c0091db9b1036c0d1011054afbc3c87ee7b88f2ae4a69f7d5bb1b380fbd54d84456c9307c5bb7286404437665adad59230c4b16a924ba0b3b22033b6f40727885d687c822db9a9137422a10ebfbe025b2f35b0032395cc2ebdafd55a1e8e818d07e86ca2fe7c7bdb45b580558923b5417c90e0dd057ec2130312b8d96bc6401391639575a538d041dc7e79ccd8f9f72411960d3e801117372c99271f592d3b9907c018fb4b2e9be52ac91ef34d80795a4ee2b7f4efdd540c5b57a641e2d7891860bdf28a9692e651d16dc47d8fadfeeaf480d9e04e3e0ef2ec539c874be4459f410cec90a264910be2b22392ffad87494b368f5423865e6037e63e526b3aab15aea71a92b024e3a01f2508f21fb835b0a540934a9c00a3f3ea771866db4352b7dc2abfb5312fe613a998d2c0cfe92bfbbc306a0610509e17f1b7866602d8ee07f1f9efae66044987d0a40d113075937ce216ae0f5d2d3ad50e139d5736a6226b22e1c741699a22343bba46422efba660aabebcc28f28cb70ab489ca30f4e3f3bd9eb9ceabef8f1722650669f5929d649b178f96953c77c6ee5b4e80c8b7333be203fb2c900d697e0e1fc7f4c15951bb1b7e733a8c5a0efadec52f54e40f36282df215654053e97b5046891ebaa849d2a715964fb1cd932918e9e9b51ce29a1144eaaa967770600c0385538cf11db05896e99944844f552c0183e13d3b3bb2dd11b68493e5aa556f638c669cf1dbcf1ad7d6053aadb8f6c67ec8a00f7c2b2afd9517b2f4ff4183caba3b97b9391281395e6e426b6cf2c86630f07096ab70504d0359fabf12001e55c40c0f8b9c440d94b5436e67f6d089315b1fd271751a6fe408d86aeeae40a7c4357db4ac66e86e3690bd71f2addcf407ae53e0dde7ead4b55ecc966b6d035f1dccab1fa58c7d06c7797ebd76ffaa0dfa38313062a43aa482ad7610b03138780c549ae2b55c048b0cda1c8435530712c9d78e711eee65e0ba6a690d94b622a82dd9aa1038701544d374c2fa4d624c33d252e06d466144c3449830b49c183d0bfedc6012bcb549dd4a5ab5d48727b0af47c9430a6fa4d7508855b089fc76cb28fbddfde40a021a5ad6fc12e710bef9447a58abad03ce34164043e293818bde03c9f72b21e4ca3163c567116776803e3eb1b8aca7a20ceb363a733aef5301b72d2b5d88324df1c38beab47e4c15b10c82380788509c84546cb7db4fe065cd4e0849223c779d0e919806398a62c94730035f3752dd396baa6c4745da0004de4c8f1ff158cf183bd5839ac1b56792637a5eae5998e15738ee0e1e8c1c6bfd1e7aee2004bd5c2dc7d53af141792bab16eea1e5a75bb85f99cf09178f2b6ae95871e9eef1b9263bd82acbb932e1d907daf931425074dae674a54efb55fc49b93e7dab1ca870f7ce323c2f9dd848eee59bcfe820feb8eae15a8dbe50f411f248b8d6f99a7a5607f05e6700ad0c4657882600fb136ed0cbacbdf339564ce798d7e0b570bc337a9719d7d437beafa476695f715e36eaa57f6f5771e8a442910406a23af4a970aa9fb78b524aede22f345f15ee0982c2b507b14fc022cf3055b2ed9cf05ce2a215118f542d3cafaace084a465f016430762714aa152c8b6bea64c928f27a49df3a8ea239023aaa92bc2b83115aea2e8c8afab8beba5cec0208522d76d8c95be49860ae6727a328e890253d2d818393f414d2bbed3b2b80e052fb50b3e381f897a9ce74b25997b65f8bd519515c53a84b6fa7c9b050fc284fb801dfdee229ed60c163895e27591471d514231f0f50e0e36f5aa720a07e088353e8e5ef1d216319d3d327db576d28c6c11902d154612f719c0257b85341e0e3f1b4393417584f4580db392fdcf4eef727b5e01f885997b059a34b12c1d1035884701c6f058f8b93a33c882265d875f9fe2651caf1622e4088d69be0f3eb5a9a3cf41b6e72dc6c8a262a12f456b8f17e8bbbad32d59f80f5f69231727655df7edc1435b1d6c3a86453b34f92932c7b88975d7b1db2c61b39592ec76cb03671cd1db56db1b3e0e178b3445c1657343bccbbb07c4ac43d8191226daf6b01b87d6a44537c4fccf456b52e79809ee6fc2d43cf53b800a901a7ffcf69fe79c3be2482ac8694d1d48ed1171e032891c00f10e97ee9ca22e0a7813adc63439faa49fdc9f0a6863ec203b18dfee7130d41a2989d3328481aa6b2153d18c94c6684e33f9e029841f710ffc26cf917462070a0d8e891be4387229c8665c1186a168aec8b3b95e428b73e98436fc47f15e7e01ac133f3e067e04d43e648cbc845226e4eb0a7a197c15b5e6c6690d288e237d0a4fa0194e2a7bb42fdf7bc35d004aae8ea81070d8c3aa61b1af2b12895058407f5706a30b2da99bd1f213592dde42fea34d2f00a7b1a5f2a27da53b3f3875fa8669fdc77de24c141784a2f3a4847682d9f4568509de0fc113438ad1c33f77ff1405c4d0aea05a03ede7a794a585ef47954c5e076202411e0e352291bab2539248108ffccd6beeaa4603331204bc6ea1e8671cbf6bfd61eb33dc8a66f5488588bd840d3140a6647961759d694b3259e6557db123913cd51c58c1e35f3bb6e238adabf18dd0eda9e1f6a1f251586f80fd24defa107851df5112f81118da95ca092d34ca88b653f9e77505f9d0360576453c42b1851b915026a8ffa78372dbc86e18e83df49b09e7ffc1f257b79f13a54a4f85b49b1eb5dd2c17a9e73869811e9e5b825200","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
