<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"831ea41b017b38ffee69e97f27cf3c53897bc2a28fb008946ea2da92c6871b2782ee4e0d61acacd7beba2ef010e1f2011b4d650795e065b8d12c158bd54434006fdc99a5f05d606345ad679df4d29311ba6e9485ae4d277f6133d48fc6c338ccfbad058c5de10450e14219bfd5f1cccd9e5b200873a8368d6c4ab6de5691dc8037b0a47a21bd2ffa2fbcd6c76dd8bdf461b00d741fa56b955a44258ebd0b0eecfccd246a7ae2427e7fe865766a4bf281964f7047cad9f0235886377f35f73279dee20f4f0e362849c09faf0f03f0e2bbdfdd9b026ccaaebdf2e93f2e34ef4addd1a007e356e6fdf1ea3cc32ec181e5d920cf5f65411ff2c7c3508d3041c7933e428b9ad14afe7799fb2d520cbc029a634ad1d6b489acf4b574783bc5153ad20202b7ace6a06a0d0e236cc42dbdcbda627d08bb8364748cdde905e37e306ff543129d50bf33cda574c3c7158a9f168bdf0c968ce1cf0534795e381699d884cbeab21af565780854669e486836357426f282047979ca775cbf87042ef3611c712bf770c41c8bdf62daa1e88e36c3f1cd6dd4e753a364b2d9a1da37c26e79c36aab06b25ebf070babccf6bd9cb450fb0ec197e93bbaee53f87a03343bb40566d8426f64df279ae2732c8d839fd885c8c104dc1c7f98d9d8c26cd6a12d4ad700c16bb7ed157fcd29e247d4d0565a29e983de4a7e256bc54e265b321a737de4c1acd0806ed64b4b446644ea5b0b9f48b18762bd7e88bb3f5f651b6542597e316281419dc26a2540188d8094a79e0be366cbc1f95e9b692f784127c04e6fcb368289465ab69eb597b08515038d6bb12b318c80bccac0943304051f635ef93c6263e44d6f1019a79823ae2f42433c6981957a1c49eabeedc67b57d397029f6e9e76322a305777fa92ce6acd6ff9b9c5ce827dd602ce2d6091e7d9786bc306beb19478bd36595da3034693a4c5fe7927ad3ebbc33cda9b5da2d51456449a94325568df8389c2a01ab5d053b88f741ffb219d0c98993b5cd4c5d10255c5e4ba4cdc12b4aafeff53bcf1ce0e774bca2bbaade856a2480c4762c44df3556660bfe416d00d69aba83c1797c9db896f0f527a1c3192ad4a0755e23643d4fef4fdc502c15ba3eb461d862cec4936137b0f1217d805aaf0c2650d7c8cc986557c7d58693a2895777d7667a25165c21a6988bfb908d588324b2a64a9c956a37c122a61084afa8f8d3fb4cd6ae782349ef165060e6332d2371c92c8817525b5d8ec5c5bc061c1b52ddcd1ae7561ef79b9c7b427229181ff87b42b16ae44d50197853db2d11acec26b1638a01b1acffbbf773a3a0e157cd4d58095c87778d2063b9053f521177bea8267a7566ad0f03afafe100d460924accd6cf14022a4910ce47b4c60280481a3641539065a1eb1b4622a5f081d27dda4e03bd6f3eb728c1c448a7200f7792fbbe60686bfd2346f675b1c83dd21231f190364a814f3c942e6730d9b7d0d597a75e4c874880178e694cf87d837b7afa3bf79abc8395b42e1109fab34336513e5e145eae29d8c37aa62a516e464e2998e814114c73e3a2ef91b44fe99e5ba4ec2002a118be60a150222fbbb46886a78f29a7fc6702bb23a1c378c7e065bd7383697dfc82153cc94e7b2a7f35dceecb02458f68691399ed5428a33c79c8c22ff16d966373644119ac20fb1608cedf1ae8ba4ec3c30cfc955c3bd7864cfd287e795efcd199148d5be59e61af28202b3215f44d55b3b8f0cda837f5e4e7240d5dcadee185b23f8aad88425eddd3e703bbf0f4a64e8bceb27073255a2aecaec2116503d02a64ccf556522a4b6a7ec1d4ffe85ae8d68fcc7bd76036a378e45c3d81cea1c7b9c994f7f509b4f66a008b2f2ed8d97d7ec879893e7876fe8e3012da7c564f8a1201e212619887a12eceaf6920aeb0808962bf8034f7bbb928859709721ed406f824fc6329af76aeea6f65970699b3840de45ee96a8b8b8d990e4b2998d475772193c2017c7088669fd638d417032adc86208ed68ecb775b47207812f26437c048542fffbbd32c25e5d6b331a54746bc5b9377513d6ed6087da7f37adc21488acc5bb8463e156faade3a7c62687af60db2338d59e078735855ff1cdeeb987e9e1e48e41ba3b19a8360459cacc34db054d898e6d72c6e01f74dcb56dc471d6da4243065f9f7a45d5aeb019ef6f6c33c343e32771e95b30f1f1384f10ed008609bedaf744c1a5a4cab707c0a16014cc7e8bfe9ea7e2c522014335365227527c7da584ada2ba621e72b5f0c2e848276afeec245de24207923b77f69386137e81a0baca3382880aa93f8c3c6725d65f823f480270a639671bef91ad5ad66298a128d3456ed180bd780dfb6c21019b6a16e3f274608c6bd885702fb886d600113f2400b50e67050cd581aa276693157f76a9ffbf9cb9cbd1055b38a3e4721a6395d3bd4a0d83e07342f05c02bc46d4bff5b16b86648ed3bca96a5314df2befab82199fc9ac96aaa0145ec36d8824e6dad29f6c55320dd68c887125f6bc41a81460e39341cdc36ded560b0d0daf9aa8dd3bcce3b1bac6869113f33a49512051a5bdc028534ee992a4651921f940e2820c5e9c359d5f3c17f92da3dcacfeb6d75302f3b3bd5cb25819c1464ba26ab92828c322318255d03d7147ce677fb4fac640cf02e87d264b4c6cd167e471102594972e92896962477e90353f908f513d27214cbd93fe21e45eccd148e7a3ebc339635339de28db24e3b6ad51a040e1892fcdbbf3d92040f38b8824e46aee993ea42c430d42dd7f917705b9df7903293ff34f82806708ec260a4a1f6c703016a1d3cee864e92ec113a5ec16716bc3a53868230e4ef0fb07c4407870c46d75c18c887319d6d8d2b7a4ccf43ef929ac1b89217b979feea9c9009dc9f43c1ca050cdeef13a636c4466810c674b1e56caf25f07ff847927c02ce47e376e1dd75d865780a05627f556c9cd02a4e1c2ee16860ce418eeee2bc1956c6e1e2b9b3a828614afd6f1921901d06489612a0c21da49f810203d61a5b300aef76f2e53fd04cb8f81e2d98ddb1de5ce652b9c84228f8f1615ed21e8fb5bf6e6b7d67b6c12ff68b4111ec7481c917dc6f25bd9ab1eee3915e2c6968b3aa3ba8a35474e60148b9a79dc328c4e38107c583b86ff46510a74fabe66aced2e203411743068dd9ed4f0ae82b08ab5124ded04b25cd38098ffd6b2a5dc7866b781b45a4e0bb58898330aba7c584b912709e76627c932c0135bfce05d3956de15e8fb2ef8ff30da47170e9342b939d22adcd659c8f1dbc8fbd09982b4bf1aca448fc29b4c6c16cc97d1e5772b6dbf2718b043c4a0325e7bdb67ef2565e5ac8a2a9de6c9a928e0886af40f4ca8329e8f38795e4e757b9bb10f0861da494bf82e9bb580e398e93ec620bccc6e3630780b36cbb4c9df8337dc5d2706fc8e62e165365660ce5793a239d8ece7dfc2a32e5ea9ce8d066134f83ddd46f6198b0863842cde91a18f8179190f20d0b8a40c98cff63c1223304b9bfaf41f92c2b69c577c022f7a847021ecb1fe63efb718073ed74d0b04b7210d0bb02d91a5160f2968241c963e0522c76946276d3602093abeac153bc3f18ec476c52bf275a358c8e3b488671e79aeeea68c3c1dcd69d6564608a8d15014273995f32146567cef347d985481cdb29e9ae44c88eaaaabaa52dc1935439cd3dea60bd0efc1aead7a0d54e7a190e3aec1bf44f10b4a3901cf7e3ee0569de6a613bfed95dcf5c5967a254ae180fec54c22566dd6baf11ebb6e6eef5a963629fbd1e7a5d86800ebf847ce70f66ae48c377ed7a7f116e14b32805300e20e947aa3d4b825daa26cd001fdaf7a56893216557ca319e4a69e30b5c3a0875b4cbd405a4f7cf57e487377032f7571513e6862d7a9aae5fc2f25fc91726a10b6ea94a42c7e6d080339c41b8d2e14c818e32c294dd8956def119c018151e2d8f8a60f38c8bd072925cfddffb1993bf2f0479eb6ea926a24b40c9ba4f0d00dadeb38d45c72a1a261e7ace47125e23580e2a9b50f8877c204ba5df2dcf68579fd74584674ba0318398e6d5004c633f7c927ae7fd48806c32e24d44931d624304c48b9b12327c1afcb5eb05921f81863f3c2855d78a1bf499b87e2bf364c229aa895689d26774e43e6a80ac4a32d48aa35a799ae3ed88decc114fe4731bbcf89a88868e9b7f31603575c84eee4757dadd9b240ce08b2dd6170b99de0af1e57c4ce2534bc5c5221569234ca40d070349e5fa2c6498f34110a8f595c50ed71f0f2b1956799548d10601b3bb1460a27c9d33929c0754bb3f6efa83b191676b6243300da761a952909fbb691fe2f2cc97873eed4856f6865984d1eb767938ede72206dae26a4f0ea8bd713ed7dd3a910e6936e7ceff9083053926f783fe8e09a16eaaea794bc3f7ee9bfcba519ed7e0a6c5f90b6c6e91f6f6d694eb920dbf6a641f430da9b14816ea4d6abccf276e708ee5ee1cf0d8750f16aa7a1708c3c29fa99ef1fb43e60d598acc6e01ca1f123f6008ccb04f863703083c6cb9e6e459423ec5421e7065cfe507c4e4413edc3d98666758bf3e6a4bd7ecd2373982fd1538028583fa66f37f1b4df55862945bef937e810e7cacd53ae1d84779c59f79f285331f8c42a2bf54980fc01ad84598cea7259dd3b9ca5753b5e0d953761c8f685675c5ee3648a81ad7511fa020db61993ae73bc2dd3cf8327fb9021defa8dd03541abcab4064dae8a1f306858cabccf9952defaafb9565135edfdb246c43907e01b621f8b5da3e15fc71c410c80fd54e70e3c2f2f0c61225067683afb30d1c87b42ffcd548f7577b915ba4d9c0c716a04d9bfa37e14dae1654a6243f0814c3ce0e8c574968791a09ed1b5a7f69ff51d2aa4926b475063cfd1fdf6945bb61294da90da9d882fb623061e26002512b853cf108785c208014b57971d631063405eecc58c31f1d9da825b1fcc2be5ad08450f73d14abb2139e11727d0aecfeab338944e726d6a3d95895f6323a06826576490ceefac7c42f1e3d4276c2d1b4de701fb00488f3e52dfc0a919955239a8f726abaec53aaf10d66838e573bcb49092b19c89b979d70a4782f487cd4fbfdc7f30e45cf60c3592491b65eb64418ef49e80645105437f9e9578517f54e3ccb0b94affe45a6376d475cdf268c417cd30da9ff8273cf2e0afb1b752e0c63513d8c8a055ee231e27fcf41a460036e39fb0fb850f62e897622294e3d5d581277578121c9a4df2a610c837ce82e8e625a6ae9d3fab50622ef4dc377fe2c93332b8e1a148e068086867fd1d5e4064608135d86f1c1b75aa5ee1eee7238013600d3fb72dd4122972d28d53d27d0dc8e48cec3909cfe712ca86ccb71864897cb96a27a8e450e327d0dc0b476d3b33151363cd8bfc014f7d7ac5e77f4e6f7cdb9708d58369ca50e9af73265005ccc36f5b97aa90a40d8078d4d469167318b758d817574bc3ab56c886193b0870612fb06233180182e8e9098e32c2b3f79682c836cfdaa5cfd9ad6432513babb2924c8f0562e7798389f59fb1e15fde975eae271b31e84955282df0a0bafb4341ce83496088a16d9ce89f7f379a540c65c92134a3c314241c288cb863b3442648c354404b8298e0ea7acd077d70d9348b7b6003c7557c0494fe0916d14e413c5fb73dbd2473f707484841c13a972b76e1558236d1fadd859a51b7249064bc63a5b33fe9fd38837b418740987a1f90605ed153974904b987062e28250e9c3145af4172c7656c6897e262b41a4fc1dd0386ad2ce9ac0eb91f448487f2dc77e4f627151d9ae5276895bce6694b0b29f6f18b337ee37ee0fd9b0a39a886e759bf9a5a8670f4e52235f2d7edef6571cb6f082999c20d205a79d88e266d6467b2d098ad08dac2289dea33ad1a68c6f87f3914f64b731c163f644d1d7955f0cdf7d601e1c5abe050c0dc11032ba317d260c551e3ccd3453d953182003b1d926c0b2a716cf605caba05af9f736eb275809202923358b85129735fec388c7fb4953cc441ceb4e5aa101859e9614c05d4d047cdd3a64f46067e4658e24346dfeed2e8dd2276584411c689a6a90727c4c36eab8e1c5e26f50958ea27fa3a819985b9f01945fbfd96daeaa2cbcecaa72974d72d8a82d94e696d6e9ceda9ba590bbf2cd2499f2c2b6d2ea1e2db8530391b473cfcea550a50b03c4348de4c4c24f54f232be9d0c3a05e1d554a1054f05cb6356fab110fd2302aa7d07b53af76821832fac55fbec7212769e2d326033b0d52ac05f06472d22d1b25382a4d0795ea7ae77c0d3a31be543e44f048ede8eeaab2b4c85a81f52813042937366243a36c1dce9f3215a3d974a6d8a82160ffdd7a60643f8a17dcf6b1a6714044249f9b08319c8fe7c40f4147094d0618d46b12f129f8ef33e6a51a76f54e640b33b460bfdab3c90e012855e20a575e664db3d2078605f14ca8f6ffae1367d6fa03ec6898aae607a01ba0742b81526e31e4960b9612433b56818bd9f86b9427a39eb529c9a3b6cfda289da926f6cac007976e3d6df38dade6da8cab0d8445405fb6adb5787bde56bfe6189dcab2ee12131130ac7181df704925184f9bc29efcac86f3d1c10b62077af7feceaa9f88c788a11884e87f2cd0453c5a6159bf9494decba3081e50701861dedab63780a096976ec1c9ce0f2d8e90cf6530c42c2b60a5272750c98ae95d73a66a5dd12e94e54711bd1e27a38f6fd8b6fbd9480d986982e77912646b1712e7b58a0816b8764ffd2eff756ca77ac754b8b37785b372c21f323dc1465148bf9e19808e22cfb394e6870d5c8d09e021136e8c96f9154ba695d697320429eba78ebd9aecaf519d329e465decefa838fe43eed86bd2c5cb4a7c1854f14ba897ffb9123f37b9d59c91cf91fb001a8b2ab8231a49c4a7bd8cd08d966965a5bf6b0fbad831ac567fce55c940e9f5286b7c801c0dabbff4fc3892b92753df43a621a5546d830412578ba68f733e470d28ca6c02d0a22bdf81d328ec41943214eb9a4c2e56b1c1f9dcb8777fd80cfcfa73935b4cff46d828438d5eb2343db5cbb8a43aa56129e36defb87c1c774ecb3752cefb0202c8a99afc33d940a978aeb337683a8d37b32408eec8c11145225b80f8fc5f684af0b311e5610edf04c033caf9966a95f9df29cda49f19bd6116243b1d7be7f606218afb196337405b20c5ba9a37901d29753111e2c1141d50090195e0ef8e7382de47bf6666904513797a912d5efcc6496d94921501763c296eded7448b3f974d02b2e00b5a29dcb0c2cab79ef9ddb1ca0c86b197eb86a00662434d1e4dc0745ef292f51d3d87a35af2891dfd4be53aa6e82fee6f57bf18485ae9b9ffc430bae972f416229944d784e85e0c073b7d336acdab9249b98aba3af81892cd7ef28ab0d87c0cef4f1a255429f1e821f5d2d47af9a42c9ea298c9fcdcda282c1bc5b43266f9fc4dc95a4e3ad6f882892f6adf1b8cc105de3ed5d1b80302dbdacec77f44f7b17a9558ecc5cde8359c085c1858d2de903f06f7cbb9e77ad8db204ba3787cca530f6fbf11a869024dbfd17aa76f0ce644a51865a62c40a4547ec13b6730621edadff7a927f75f7af2eb2316c400a17e513a0893f0027c5973b000b46d4ffecb5040964aa5a9809b935d71e0b5a27c1b9ab5e3af04486139222e29142842b90c4ccb9ff2619388740bc40e6b94129e0a039933d72239d48b2398a1f76a982f8415196062395709f6ac5777d5719b4abee94e4a531ab9a528cc5ac4e18962cbc41ee7a93c93496242d457ea839546b48b751749da679697ae9f434afc6738c3ed2448b5b1e1e0743b9719e6325be7915d782ea7a1242fc9abd4fa077b61f2e33de6cff645372665ffe64483e84fac220aa3684c7fde4d008e33bab28c622ea0260936195f73f9fa97d0271cba08464ccc5a06c8c7442f8ad950c85454cb8c23e4a35879b7ea9ae1c6cd46039d7366a6a3314f8fd92b9ec0805dd06d6cc25557633e22b4251918dee1b68ac95f3892ae2292111344a0ead6009d796fab86c0a4e2a075f9a1f543a777546aa09a2ca9ffa59957651d59746b4f8360000f240bd66de9d90e17e151ffc4ffb39130e1ebca5f19b87ff0eedbf08bed8282ce9bd1cbafea73f708db6c17d4f7f09970ba7f949c4cb3fafedd11de9865ced6c16866cba2b347ffbaafdb029d7d3ffa8b07a45e61635b2477002262ab0a61e5069cedb8dff2faad06d97899e799db264ee2ab356df69af2083af5737fbe42538765bee6c413ab0dcb529f131a36bdf272219d34f2f8f34c84ad7a07ec68f2321d23772d64fb7821e5933fffccc91c5c041d0fff7f6549d11d187d5c46e4c054e63186d5a5e2a4f60249bff9d910fc03d0e0281f7f4dd3bca66e57345b0128b93ea568c455f6714523b47883ac8dc4444cc62b11cfce9dbe89bce82d1c95b349fbccc5ce7fb03363e669f142748a4c134cd48c1be9553ccb11ee99c38e0a411afe68344011cba09780bfe2a51abd0767f0d64a1e9dfd9faea2114d2627308ed39bcc33cbaa62a956179883f168326e007bf45d94bee1b7d1f83cf3be372f90828348f5c88bf0090f3b3896ae2aa5faa9cdef99f03354388f2d961ba3e4bb409ce2fa771833a292ebc9af06b228d339feda40a8d058a746610fbb06d46b61bbba457bb65d16296b88da809a3f0ca6f301ed536ddf06e2ccb30057e6e7e8691abacd3e988a37ca45e15231716e1ec461876c0df941355e0f89472fb909304a9d89efc14be31b30c2caab8121041706055d68f0f219a1486f3cfe20a88cc65bcc4a96e199ab1f4961caa04faeb2354e956c901d7b437072e31a259aa786051e98997bf8cdd66ff5fea5bfc75a7c47c92823563aa3c03995d3479341c22c1104e889bc25030932c6b1a0d0ee25f92b360779b8e42d0cfb2141dd80621a3aac9b11804fed8dbacea32034ddc3e1bc3b1b4a6cd7b0872e03d7180f3c51b269ff6fef41add30b95b1262a4639614c6fae0e2bc8f723525861c3d6d7d7419c5eb0dedabccecbe24bc428c99baaa1926bd4eb1cd4208f7ba34857cecea4b3a7eaa69b4a3d1a81a1c2b79cfd54bec1bbc4ef8acc36aa24c6ea657952e32e9059b55d0331bc76a5eabc5c41563171d2319dee61556e69186225bb3f5cd4de6f8eae63b847f75704bb1ae3d13103f5cd5f47f58b90c044251c1a6b4ad2ac066874b506b6f1a63124929c5a4a082b5bc1bbf11ae64d1c57554fb17f86fd21386b0f29244aa937edbd19840629e6f2f1d5f0b4dec196c5b99105db0d672a1524ac790b2d96e68ecd939f409a7d11621047d10e8a8fabcd8f2f2f031566cddf528ee666a846ab4fbb10d3084cd5b06a21b2cd720d9309322b114584f25a23cfd9298a42504af29b5525bbdaf241ea58ac23730370e09fe85623c690855b5eda34d9a7fa65499932c404d9c54074878a8adc0b6681b84b60e1e00b2815e40b04741446f1076c96d54611787aaffd8b85c877df6ab99299b7019b33394b3f3d2d0f525f346bb282ce3563598aba744e3d302b3eb42e43b06477044f78c6e8085603337bbeeed43417ef377b8285e27257cc2347f71cf112428e3621b7d2267648c797fc2e2d40dd2c0eb7adcf5ad0b6550182dc18addad32da1f5890c1e37d86998cae2f3f026e0f8bcb5fe1586128026e15f6c0e6009e5db62822127d02701804b83ee62b3b06bece801acd66462c8863014ad68a4cff7dc5aa827d725d3a0bc574ee66e1783b276297a41c38a955bde014f4d52f6f4d13a02df5d3f0ae636e1f32b903e2415e75423fdfe62e52bbdd8969b50d921f622246206d3fb33ae703243025e2a08990cd27d285cb50d610bd113536eaaaf6e56ff6073abb28c44522bdb9183ad1f5b02a2ed2c46b7357ef787b5d89b3ba5a40370b2be1eaf91bd3cd46cead3e41f788e3da901814d31ebe25a15b8a5e47f9b595435affa132dd912915c6d6931af60e0eccbefb1d47a551612db8d892b7ddd916dd4bc4e909e648e23127a988bee914953a493d9a5ff95df4c2d14f01109c9343a2958a3e8a591ec5b9e5f24d2e82056bc9b28e03e8cce3e4b014ff77dacaf8852ca376bdb72c40e36788c0b1ba92289065da39ab785038b69ae1342d5f9ace270d307371a9a9cc0181d9f2f4d3de3385881a7e715ec746672701968d54e676387c7365dc7af4420dd009384a570f9ef3f4c35a10b3b6f09863b872831479bf182eae911f43cad4ef6c5b8abeecf4e926a402bda080917351d40cfc2214d1a7fe1d44ecc1cb42100c72630467a5846625545640c6353407157504bb78c6baa0f9633cb1e694d4e94a12c700550a99b5f773eac07fcb4e2e579fa9d41894550029593169e6530c6d16eabe6963d64df226469d33731cf34b330ff018f220d7b3aab4a400755e140820c26625e402484f7dd39d498015f9fe6c033fb4d5c9e901295b489ba7acc4371f5a61f6f9d2c5f4355cfb22679e02c41598b0313d7dd4dd6028812c8e59b232fbdb06ebeb37998fc99bd7e10b39923d0eda2ad30be27668b5b6e01cb81f3368c0ef357046dac0ada9ce9e4f80c13bebd2b3eb5c9f6ea2a0b5ca2553def629f99a4260b2f05b6f154146854d59e3b045ddc1b8126738a831031544aeb537ef60bee861d380e985d4ff5155a18c260ce69a37e97c29e377df91b459416a61660c74af339a57c27a6875411e1168f36dd67ca42819c4bb2fb908ffce01cf5059c16fbfa9083ce0dbc57df01be2f541a57cc6175092a53fc5afb0ac442100c550edabcaddf35a03cfbc8804e6bedfc258a006dee444ee92edea27745b09e2ad491532e6b84d5e7fcd3b1de069ff016cfc7ed28e5371cd1881ff2eb646fade326d32d44059d7cdd018954d62ac6839a0d829ed79458d2edf665c9858780d96ff8d61cfcd3e305e0f9a007178333fd2f4b959deb69d0999c3bef7900e7d463e16b8f4c169baf15beaccbd88b62cb528227ce324b005560d09afe2616792d37b4c349ccd8ac42835a6ca1d4c247570e18f60df4417f3a73f15a66fc36cb029c4f17d8523e4cdc67d45ad446bb3a640835d5bff03b108ea5eaafb7d44745442b7f1452fa87d7dc762ae08ffa990ab3541be205960cd1d2f69e63e38517a1fecb10d66f958fe9483a7c413af26b82eef9d9a47d4f54edf9e2106cf73096ab219a6ceb95b93f4c5c88d5e09adc99df6a76040e478e49970f912a51b64df560507774b2b8d25372459745044b3de2b758a0c06af238c6b793ee227ca704c918afded6d4a15b2808ee24ced1575f506207af9c781e1e610fb3fcac4f9611c850afed27216d3dacb380fbc6ebcb87afe08c46f4e5b73c698e4dd90cfcb3ff24677393c410657da8c4619331d7cd1cc6fbff0227ed80f2bdb247c33673ecb800820046a12d4b31f862bb9a3b217c626aad245c3150c8d9b380b59f94e58b9504533f1cbeaf5243219310a182144e772fdd107d2f0ef630946469968ca184891f2f1e6b2335ca7fd9bd350376e794bdf9202c7d317e7790a38e917955d00fdd8524a87bfbd881ddde916dfb9cd5bb9f4320041e97f96e3b5ab9b46e4514bb506166c09ce0eaec31ce59111c7fd693fdfa86979ecdd672394bf3ab35f68a88b44252957daaa2d3f97f6d4613d7d5cada7b6e8f49d7c95db133698aa4c450d965ba05b93d3378e32db4bddb8d1566597a01e9453c9b7a00f1a1033379b0a3fcfa85d4f73f61e5fee5e188708435f957a96222e2f77189468d992b44098d9d388cd11130aa186f066fbfd9ef4f3b9d6b1fe5dea3731bbff126b1c7866f8f5ed4f616211cb1d3113c57fcdd5a96b26295e1b53e75d4c35e9e95ad2a3d1563eb57d8f6cc3526784bb1afc8c5f19ede3ee3962eb7eac64ab36769337f312bd1955ab8996515dcc05bd43b1777fcfec89d9b6b31ab6233570c27491086077e91580ca9a03f71cb96000c3adfa39fb2e5f7bb4cfc8d5e160e4d9787d501b7f3feea087339fbd9d68df670f6f1f7ad085a128d380380b8c6f48fe64343e1571ec3a4b056415798df1f507c9cff3470febc0122ecbdfe068a469e3deb80687ebc05ce99a9cef2cfa54606ae05faaa0991751977cea9b39627d586acbe6809c1a2969595b8f03fb4a8367af1878ab59438af9340b96ab28f6fd3f3d2440578f0bbedc02c77fb2224ca6fd32e3763b9a752c21dafc6e699daa972e5d44b2d98eae22b813f6430a6c77d1667a8b1b746f40bb0a5f4e03aa825040de3ece4354d751d11d5fb41211e0529fe173a94bae42177cb89f2ea070948cf343aebe3c0e8d11ad84f7b99926e430cfe7b0524c6aae7ac8f42f18d339ed58dbfa9bb9a7eb074eac61aea9efdb16edf5c1cfe4ca7feb1764f74346bdc79e62083e89870d860ed7293472984b4e9b4957647cc145d8612906ffd0c550fb974a0a3f0e07b58a7abbf81729813f4e22894ade6c32f681375539fd28225d8a6aac6e3b72333addcc58a6840f22b242dcf0648a51fde24e25ba0e4e6f90eaf5c35a4f36bdf283c1abc19f6de020957bfd9a1cd968435a921fa6de27e4d5e010d89431fb68d6cc7ed502bd443ac2b08b14adf4b1b842c9577dbea8b689ee940b8c7a902a07071adcdcd162ea9dca3c261a26a9ff4882f92d5c19409be80bc6eb1809d08c30a00125f3a33a908726624e6bedb3f64859f362f869b6a3dfb0602aea025f7e37d81b7c8158b7fe51994bd1bd061058b9cbb9583f05bc9d0b3b605e46c191d1db7aeff51af8a49cdf5ed3e0c1d8f1a9e682c6d7cc6f3e62b66b38d38f7d4dd6d14861e6f49f9ae07cb51894549d2ac5a89143576f85b96178ba938451ff5e22e0ae943ddc5c82bc47f8487986e67cfe05e92b1d4b5d92a0a739ce40668b6898856fecb55058a87be16b127b6f1235e996d8d61c4617ad009af15e1e1f1c02728b629135208f2cd95e0d09340739574ce6e1e85f3f64e6911977a243e0b1dd5c871ff8d2c108b64828200234ec8e718befc49aacb30345b984ffbe7c68d1bb8a25d095aa9de9b653a1d3f1dbf9814301d43851245da44fc31465d8103d5f20d912f8a894877aa3359d7d8a8cc740605af651e71eb03020b4aa45c68b5427bb5b3f4566c44196624b2745b9fc82958ce4f14c1ec5e43d586820d344c6e1024cda1528a6c83abcad77120bd65c2d03be35d4ccbf9a91197ba6b37861964ffd502d6e073a884cfdb1601ed28cd4b2b51340dd87006c371d53d3aebc54d2b513c42134ac8a34c174b8ec02c59a10fdfd743c95b338faf65274fdf586e6c1dffe4833e07d1bcacef6b3a1f07e413e2fa6fdb38a03d282eee2f9bb61e95bbfe001b452dac67eac0164694ac551c3af7dd3f919cad04e1c97e934f20a046d2da933bf62bea9d00b00eabe52ad6c4bbc98c0245edcc1aca65772bdced9b1fc88ebb7b0e60065ffc9986984f6f29621fa99b45fecf806c9ae0eb0f19b3392b861a4511a1a49c5542b9562c53133cff3f474265da72d060f566d967251ba04bcc3171ffd254f3d5530d7182f9a504e463fa6c376bbb684bd7cc795af5270580229faac0eaa0295a418959e4923b7ca1643747d81eeb73d0487d28f4c0ae2c586cf63791acc388369470e32b0d4efdab38a01276823e8afd81743d422df7d0d60d54b4de90dd9db2361bb484199b48b43311d5fc7160a41b615400d06dd5df4e5eef292fb5c4a40b985df248d8bedd33000a23ebb258c24037e14344fd5185778b066c9aa31a32f8dac232ea9fe5ac829e6f34b6345eed711f928f08b0b20af665e858e0ba093624fb13dc7d4a26117bd2ecafcaf173af89dc8afbaf8d44d77987fdd6c3f9f811d01790389bd511eba651c4ee2c62ab45bb716504a7115ea8028325e3b78a546222e17a44cf5ea3fe4ef4f2365595cc4ba33032e8451d5078c124b8bd6c9ec48f2a2112f0679cf5e7749d7b38566b7d9d8a41a4fc7a288fada0cd885712237fe4d5f7edd83bf60f8135ef7e3ad07a7ac506bfc20a7167e35c5c3c034036e02a1a0f11ce944cb0fc15bde31f08e56d7ad2342fa6a9878ebc991d156e5e1c9ab335e3ee0575d1f360542cf72c816865e3d689d0f2e3a895d8e576490ec268ad0d2fe19dacc51ff15380b50456abfaa743fe74e0291734860f58e71212b3c86da39a91bd6879257eb75a1d68bf3d9d3948bdf17e32b0c92851a738aced4756660f5849ccbbcda364670a71e25fc46a24719239cb0631993750d3b70fb9fde7ecb6724383aaf8d7bdbdf1326067cffcabbf6a671f0e1b894921694c8a2515ad104561266846d37547af5ebc140e994cf1ff4d11dd7be6317aa07e42d0ca6e7e19853dcc1c51aee36d15addca743f3048c1a41bf76469ed81ddffcdfb6dbfc2a67214de275b0263043c83adc0b9de49f58e2217fd6f8d18c55f117adcbd84aa38c34e28bd7e026d522c1e2d69f7cdac5e88e229f2644c7de18496cf32209268ab3d731fe27b7b964a5205f2fe2eb0cf8c1ef75e399ac1fa4cc5a262a9fb79ec5c456039745209aef8f601c23d5644d49227db6720c7abd2d876edb75cf78b313b187d3264b12233642be40531e0979bdaa0b2e0c69c4e4f81fb22b51f9792063fee24689df0b026af765d719d0787638c2fc5421f619aff84e5d1ffe15633a6daa53c07fbf6d4b8829c745c31e00a1fd1e00530584879f3ca16072abf3731860d3093fb2c6977c2ebe8e171ce94e2200023237e1b6cf13be60c216c2dd6707e4dcc17dbac0511783b4051e247e532b33eac9c545367eb09428df9927a4a3976fb4b4d1c49383573cfceff4d4b09ffc0e642db83176c27c3a09ef00b32e31c7ad3cee428e30b64dec5cebf35a964f500ff4d09b7b343427b7f7e2d028320208fce093b8248b81f880c77340450ec0316a03c819cb524642efcf15b2f41b093cf80d803ff00c4171f6c952d8fc1cba0f75abf39b6c69398c1240afe3c61bac909ee3cfd9c70e15cd6a6b01a4b70ffe6dc63c4ec526641cdfbfa8351314d580d6185d3a2d895e633e18a7964fbe6d01bdbdd3caa916725f824a0b07eaf7ed6648cbec40e5be1a360d07ec34ff20ecb3760a2b8d13b6257c7d34a4520ee0bd85698f4745e50d958b4bb7135e65fdb93956e3f0f5771178185323c7ddbbbd1a47b231e7010372f3500fa498ec73be8af84c4cb2059acde4896ae0008050996f66be05ff2463a33cd4dd9e1f0d60e7ea67b1e4300398ebc982473389ce262847bca4e8b913e83ab1a1bf6c084435c2a5d4c2738c5fb52d04912cc9cec9c0da69496cad59aafc6c92de2f181bacf6948c1368912c85a5a1317d90384f3f7fcff0c529b68c9fa8f0d1811c97bcfbf22ea8f4a506268d0596a8786aa8e93d49fb9ad3f3d72ce9f0dabdf9b202f1ad6d032ad7282090a5a8aa19eb3aaff79b24b9efd4eea759c96dfc58dc0ff149e461ca9c0122f34d40988489d8306312bb472e6cba384b279f25801f7a213873b2852d36df1244f2a584855931b4696ae3ee85efbd5ead6a2ca4a7bda488be83dac625d3bb6ce25ffb305cb7e70e98e36bc48478129f3e1aafdb44a91ca1f0e6886cc311fefd3725b7e6ae0a17fbb49072c83e08a6594e51498f9348742b16ee3678d1863ba263f327a14de1f8c0a02b06144c40b7fa4371b834cfa0ed200d4007a23a3260e12a4cdcd69ffd3590c4b00bf1d565120b0146dfc39a9866a00933320a77bbf984c05e161ad30eadc2acba25872824c411565d43ef92b502a26c264db123d4eee6e2b51b08b90f83f5e9512375b1210bc2e02f0b8009d1ca8a633414b217823606546e82a53c800ceffc7594971d371c4dc7fe9495e7887f77da274759fa2f753ed81022eca56b6e810d0270b685e538d5e7beae635faac439fc9d62a046b7e74aaabf54a22976799e43139846afd090495dbce9d66fd29f9ed44de6e8409d40129e3ea74f498e00f66fa245f02652f34d672fa4c39b4d7a6d08604cff977c662640f8f0a5060b3ede48d1b5a88149f797d7a698c8059b2ac137cc607d5b884848c2f8c38046c28765da1d9bb73e35730846732aa6158339fdf480f8e99167ba3bb406c9861bba9c27049e39b676ad0da2d550d7ae86b8f25c831c78cb2cf3e9d901e33b27a9c831b68f2bf121b63c427b6e8130bbe7d1800b1915343ad7df71f278e8bdf916bda4e9a9f19e10266eea41652f5e3dcf77b6a9acabbcdef10681ef9861b72c14a160ba891c85dcc001926ffb3c5e87858b65c3b4ba0fb847a8cd9d2d04e7894a0910ebe46060f0b2a7f8f0e6596e48a958c22ccf164adfdcf2232043b399886c61881f7693ef3e17e115c51157fd1f6de80777f30d24e2759edbf8718ddf765c5bc54fc939b03a95b74072af370867640444e3d0c71c5ee1f10c11e7510872da0b0cb97bb4490867f2aa1a3b107ab87ef72e71590625d49a5f1504a1eac7036be6d74af81fca5baf2a9368c01b77f293f65d351850f9aa060920bfcdfb2c67ea826002072ab4d1378b487fddc52c5d479ae1757572a4cc6b1419a2a80afed53c19d16eb9906e2cc9e17c159be4fff0d2548e6dbe519ddf356dcf5f653f391bcc5892b843a99ac442389245095605ba04e714d535345b5221e246004e372ca51c8e7abf79e37fc2588bfce4ffe19b882f43541c04a9c9bcd595cd24a97dd32bf0f4d04bfa69d278597565a779a1442022a8f35874a8c1c724f728731f6586485de0062c822946aba168b49413820a1b09eb850d7d147541b4bb07771d2949240671d7cfb53f143c67caad9c0cabb8aea3a2df5bf8a55f7dafc4f4300159eaddf42ad9f783f6b59dcda7e809b126f383680567b986cd0e2f4204e35508203f8a124dcb2a145446ef4f71c44f5af57e50923b34b45cf9fdb2e1a1b350a086ec6bf8e0d672bfca14e4fa3a14a73f9689b8bf9c6bdb7eb6faeb71f6b63dc23d296351001c3aed1890255cf8390fbf5ca4cf93098806e7de69434e0df57260ba97557dedb5fd31b474110665d483b6b7833f0c64924c23b3ba7f96f19df61aa801f5a93a4018df24f6a00d808612d854ca23ddf275259ac1b28c05ae58883f99cb5d1e538a724faacd78650c947dc60c4bf64d6ce66a1c626a12540607faa02671edb49f4f78436378571b712aa1e766849968d1f6ced2f2ed4bb61bf966526933557316327932b77ec1812097024658070dd28c1e9cf79ecdbd95b16d5c4f071f7ce96169ced9c9989dcdbdcdf1f33318824e93ed5bcc7fde13eeee4369b5e7acfc0924471d8b1d4e66381c7aae748c06ae92849105bb53719fa88fc8bccb30b93b5b4b65494aae6f8679e2fbe97045e25c6e96d599f87c5dcedf7d1eb32129bb028d357f505ce30a366eae4697e2efee3143dda7c29e80d084f0ce43179092019cbbe3c5a2e51ccd91f15c70f4001f4b08931ed1d46dcbb80052cd460a83c679af80d0c60b40946af68c1d362610d2758589517b3d8e4178dd5c944c81ce6f985919aafad4f04c1555b78961c542f270cf17cf34b65afa641dfef8699891dcfc73c2ccad43c925ea3ba8213a604df9e55aaefa2c4ddc6e81095733a74a2270f5504502c8b041626bb010b9f319d9e72c9b7628e1ebc593c2565f9d3b118d97bc9d0c7f9e4c39040caf8719e970c901df0828c6ed1036b5b642c6dd189c0fdab4e3c874836d2c18b331cf0ed38671f7f7713f910b94f55d834729d593e4b7927d218a588edb91821d2704bf6b61dc3a17e365268c762bb88090f678424ca1154decd3f8e4df52a5e26711ab9ee652a8b10547d01af361e234f7c845b94f6b4c0baf8bad0dfbd0b695932758350767159f93b481a42331e4c0d4bade8567f40b25cecc9d7472fa28f1a16510d5e2985f643bb3a888ffbaa8ac2263e0593064ac50827cd19732bee0df9507b45289477ebfd69142da720b96b41a31b42495beccfc4e32d76435d7fc4598bca302d466cbd10275b974709c3e3a343e91861d7781c83c74753286217e29a4e5e06fa18cac9f08cb0ec78f5db2a3165f872be642c63241","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
