<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b56c2f27b8031c7758f0a3bc3343cbb9e500f4a95630d03293653add50dbb726be31a05e92b9330ecf20f8b5583ceb60f90a9363bff276c895fe4df39abab20517a02aa012b9089f514da02893152e68ca91c920cd31ec85f5bf318c1d4aba902f95e2283de592323f0a55b8507eaf00a9e834b11aae607c1820164b1a7c43559f9cc643d07edc00248e3ea66ea77efa2ca902b2f1dd60f146f1ef0c24c1934477418dc5a6bacc8bd3818cdf5392fa627aaf852238a2108287ca799ad313b98de92b58d7bd6ea9c3af97f58783f22e974763377d90f5ab4d103c33b33e29ac32c19e3d020e629254ef02dcb009b489fdb65fd33fea145ada3af7e42cd7815a5bd06647fcb68665db2a95b439237b2c0a20b7b590554fb7c25754b0f7fbb61521e7a2b529b2e689eb3b5da585f67171d243062fa6d797176564021ccbe305ffa05bb01b7a92b855932a7318479bb6f7e1bd927bee6fb22eac56d278fae9789e3bf3eaa93464bacd6803912e09544b6584343bc530d9f77da5a64629e971bd722df3ecc7db33c4a10dbb893aff0cf6fe26f697a8a463048ef8b181efbfa0475a970adb61eeca52417a24c551bcde27ad394245c19ed7c667bdc2f71265511eb8c68c5c3a9720ee868a9948ffca860fa4be5e1d7d624d39fb6c0d135c5002a0c4d5ed61e19a416e544fa3bd2d4e4fd30eaebaed949bf60320e435d4ded9fac32238232c5437aa89a5c0334613bbcfefc43b72aa76367a19f46a840eaff21fa1b697fe24088e7e1806e52dcdf6aa6f03317d1b62ba6e6221f7d305c6060b3917046009cfbb6cffa624246427415b7ef7eb1a5cf338c04d8701729c4544bc362cd6591d9682e66b1d10f9402c130dedb5ad953ad2809002023e8a80d73daef3af58b6572e4a9eb235fe6e1e8f6f41a4a0d5f3cb4e7a160f19709d90cf9cfc5e3b3ece16e9df23969a9fcc247dbfbef5d589daf8f406141bdb5c9c11a4b66bf0b9ce8f2557bc204aec4a07f04299f3927dec8f6b4a3b711ab2be2ddc3fa76253a9a4945a297c95a5034fbd62cb1357edd2e417ab73049e98e591030470b74155b7e0037b620ec83f1557eb51699c3fb7b09a0ec5c65c9e7d548eb6e9581c3d7f3f87c50732f51f496b272c20e6da36da8cab06c7965c29d558c83fc797616f3a4cccf4c83be46aab1ea937ce7b6ca02726ca078a0937e21020dbe6a7cfdb40cc12c4d93542b902a68652fafef87b4c63c8995f6d06e2f38c1fed98f5045ccb2418597aabf16f63f272b9d43e1071335594f5455f91277f4e6da63c048df708f91d7cdbf16d169f990384c24bb0ccf84770d9c058289bbd2900a3bc6caaa31715dfa0df36b1a48982133e6aa0d78644c071a74c878c5ca509214743904a1424b9c2e428e190a2d200295b3e4e6d2a9d799ca8e5257826fab2fc30b4e2cbd7aac6d8a9969e58a0d8dcb36a6fe2c6067aae8fd64713adb630f12c52ef8a0fe532d1668424669e4b725a5480bd184cbb05f1081a25249e8fa089e63b4fb3a65e956ed7fb989701721ea098ed796bb263480399eb3cb1c1bbfbc63c4e0ac49720d0b678365237cd1e118ca80a08c15a4df9432b01878745b3944750d460a54ae51627872cc5a3fa3bd25e1833c9377918dd0f91ae52611169aade059ae2e8f74c59f942db9237b7305a90333f9ef2388fa0b9f5a41cdffb738e991f9fb0bd144c6b2aa637198cf9c2aabcd7559f00aacf4708e020eb55babea5f10d2c45604b656548f9cfcb16b83574a3714cb77b10710249150b4de9f48e58611b759fa79a055b79c271047dbbe801395c94ad5f9f90b8c2c66c449d0f8b5b20b51cb6c416bde8e3ad1ced64f091b5c3b2833012f410be42706a5f0f1fb6d10b243e0ee4a23f56e5c73e9ef7bd75bcf0486ece9b772830af004d89b402509355cfb5794364991fc20d8b9aec3885db3b7d7f2d494cd1f3c9af56c61cbed6785899f2fb817abd29aeca25c92fbcb974798ee7463a4dcc4f26a7d9a6c5f72114faebdbaa5c08be3b3ca0cfa4f023096e0335c45b8f76599350c759fba6f023a80b65ec48c8470ccb3408a97a17589460d06c8f4ebd4080dd0627de78a0cd109a068bea9ea3875d8cb3c2be5f641e5f17a2fe8f9d904433338f65fec0943918cfe446e8bba6830fc6c8da1021d1b45d250b835da0b0a189848f4db1e47fe7222f752e38b8e3d53a6dc4e9361163eddcb811915862cee3772d314e5066ee37abe613469cea557fc3e6412cbd255a9d2a077d624651c5d4278458cb03ca04aa1616d0e24fea498a03ed5b9d35ebe1e259538121ec35887f26cc33daf8daf7267fe8f7161aa98a8668bd1b12c2692a8fcae9e6eff5bfc3a3d88324ba42a05814424073bb6cd19a47a5a6f9cdc6500a6d6dd1c3834f3cf949a00b1213786ed6f79dc1495716af319bcd61fcb1a1a2aa24db73dfe2d9465b2bdc246768f22c141bec459e8a73f2c2542254a1a96f081e7b5a3b38940e2803d949ee1aa76c425f1ad11fd37d17593b4b691afbb423739a46c03fc7257ff9934843b5b3f4cf088e6c21b5d355002518ea0abbb126c3093f04e2a7d8fa563ba4a5d49e726048654e135ff3f68354398e9598c68b1c09e163d39cd0eecca4dbf3c9f52f439c5857b413463a0d323022dcbbbdf615e3f93d9b758d70a8cfdb3d8b10dd03ec0e9f447b91770f98a66cbb486128da6f1cc068e5a2767a5bd10b8284e73210a30fa92133a9e3a1587281c153c0fea92cb9bd8182cfdbdcaae6dc50bb3186bfcbef0753b25475aaccf51ac5d5c7317d30e983eef05c975c2a1e582edf61b0050998368866583742e9bbf96594c05fb38157f22d845f2718d3c7e6fa57049d522c39a06229e32ddf4e7de298e7e215f65f0e935a0b9e391a38d03c0aa139c07bbe03e267204d13bc96e82011b183e45c272dd6c962f78af363aac26483aeb77ff0128ac329da233e65fafef31956c64da8bc679aee8494aa1e736d8c6f4ad6bbd990c22150637835270984e7490378da69568b20ff08cbdea6aebea451b779ce14c2bd199cb20b904748bbf1217b841322ba71fa80867c60f2d39eb5b764f0acf64a8efb184f7a7f09f5c4e57586540c72feb80e8667fc830be22795b8cca7addabe2ec1fa4241c75ed98d3b6dc40c619ea7ab0af7b46cacc50b0ee77f2eeb0c6568fbb51fc063e9a95669f0f4b822ec4d10404224f6a146b9198c5af656dc2253f5359d025e35cae6896dc5ea32b5ec0607a026aa1c8031cc8cc06324e3bd06efb0eb56f7630e0bbb328279c8eacc02fb58d26c3b93b5cc0b1729b048a996c8d595c152976d0f9b5c3ecc1567d90b9709f4dd41699e73ae063d74c7d9754270fc73a9b03091006a7347900f1fc635961597853785753f75de2726184392f53a44c62d2e3ea3bfa098f7c2d380470a62e19378baa8c6d7f5a518f8ce911927b8974b21cbaac2772197fec741f8e2aaa8999cd83b14f2024733b8133b69c93260cd44b160a518e93f5facb6e36e29cab11098421d5c5f41067c49160c8eeb90bc893a3c0b0e4e8974e551ec4ee2272c0f54bd363d17f1abdca04a91d72f8942c108ae9fbc89d7c21c25a2e44bff9f739bc52a7765129be208744613e7e1745ea4df14ee5043c4de594b571bd3fd19a3b167c1156fc6dc8f41bf1800b5456844e83bbd6f97a6cb5d7c8af5af546200b0910f5256b87f9e1f499d253edb89bbae27fb9fcd4fa1cd9eee988c3e088b88d6f780c830a8c126298ca8b6b415436837e52989534a2e049d5b40c007c669d5a28f2e733db5a54011196b8d39ee3af72586070b9cbe80333daea4db28a2a24ef5c8fc5f0b55f7a418ed439c3b3885331c9335ebfa4ad895d06811015fc7bebc3936beaa8cb315b949804915169e8ecda2c93c5f8d9758c29f79a6456961577d830aa3cbe081fd978d9a3b5f20ba6d5b59ddf90fc666c411771d8cc7b6354e4d9dcb31249d8106097ceeb37a2fec32560eae28e49c9ddbb56405bd9a3358bf29eda8789059ed5f4fb49d14947c6af472428671279ae291c512d223b15fde89ef7b480d197fd072311aa5e252827f1a71fcf9d01c2e32050b2ffa7784c5b6aaf9f40fc377dd69e91d6351c00db97046eb4012acc387d1f29b83641de51114915dd19bc39fff505f10e1261958b6785015fc478c8238bd25a8944f13fe6067dc2175db48f1723ff301f858fd2357c5597d9979ce5b19cc18b54b4a161f0b92d7479816e0f9a1ef1b463ed6705bafe6fd49f45fb08a5297ce5ed895afebc04993f606f9daa729d31ad2aef661844c0abaf43df11407ccee38fa491ea49f1a2aa93c51bf2f7df8d7b0b7fac46a2b4cab35198859033ce7caefc4a474249d27e424e02826c73564386890a6f81a8917db24a0037ff14fbf58f51bc30b43ba0e7be6bc19623bef27ebadc9f8390da2d365da5dc2de4cdbf0b51fea93d4e304b67efe8b07841d85423449f1ec2108ecafd25a9103665d679ab415fdfaa7429e36f39dd4c1bcde8fe75460de30643a01de67d664fda1f25dea729d4606fca4a8afeef818aa2d1d52fa294ddc87bf0d0777e18dfc70cf4cb6a61db628ed2bf8987c130be2b6a663efe5d216c1d2cd414f730caa81bbaffcd75ef28140fbb8a46b4f7e1c0ac75743ea19eb095f8b798d758f176b54b47cab82034de530495a085f59f567862fafc301fc9c8b500a92ad44f15526f2e94d6f86277fbaefa7e2668436064950ac979dc0bbb902a3054b3147ba1a80360fde91935b604dd5cde76f5ad0aedd8015d0135c9818e566822ab02b7a39a49721ca579595433b340b6e8e5ea845bef850273cd6c0de049cf22d4ac2cd1139b3a1af83003aeb65a14488cbb73670295d6582aa0a6cb5f187e9db1e5e758bfceb92caf73b6fcb6f1a21b2224c314afcf95418dc1acc30dda14c200f792a85c21e4fa8c27d4cb23a42fb23c46a98e186b9d7e806099c4c3de558e6cf11f04ea2701cca992c456381ddcc566ba33b67fabeadce9d6d8aa4874240f62bf168769585129488ceac797cf8132ca393789a5ec21fc5d12423bece82c456e7f9bc298ebb4f3d1d0f68437e748af2a6d2835e7a468fb727862f2c5717520b69929bfb2b909ef83423f64ba8ec4f69dee0bd3b034f2779d77784168bcfe9182ecc30b8e3b2eebb08418b05761d27719e7c0d5d9d3beaa3dfd3de704c9de89a0e41c7fdfd40491f1beb9f2000e768ae49c1f2d587aaa24637a4d97f85b147f0db91157db9d2381787bde4288a757b90e311101d5b5ffe1513db7dd0227830d1f6a4aec0034a5d98abee9c6396e21cc1c9c66a262646960d74d28a992d3aa4ea26029674b3be9148ce8f2eea7a061f9556d1c3ae21538d12cd0e56e38e0373176e11f9687ef01cada25277a200d38e1f882b49aa609f7f2d3540cb3cb0a8fd6864ec6b14357f67cb59556b14229aedde39f8c0bd37b3f2989cdae919a80c2f023b2e5c08a90230fb071c9d85e92fa2e5de688a9218f946c49e14cb45a797fe9b0824fe34ffee4cc8efe8c5ac0dffc2023803698a12ee1be1944ea72aa5f177b83142323483b2b2cdd9e34f54cd3b86b358dafd08913ab1e11cf74446c7eb64e19be8673901bd52b337405c190d81d9a684354fa380805a0551a36e637eb08431bb60d44ab48ae84a25c954f5be6ca1ce0fd809aea7458db6836890e0504f93d1db55fb593a88e8d2650ff9120443ba3f68e84550757ad68cf59aaa55291ebb98e6a787465d4ee40dd472b97900655fa6857b2e7f6be0b1fd77f94ad6b0f2b2f67d8008fa50fd652119067e5e4437f573d79c4950d559d6d661b08bad33b357323aa74fa81d69fbc99783b08307436ff20d730421ab25b7a44f76169fd19387bcc076c27936d44dfe0522240c04f8431498d0b7c4a0bb446b2f26ebd0470477915404a76120a2e09f69567175e0163399e183d7b4071ce48760e8ef0fcf45f5364189504f96ed21db89cd6577863755417783e29b0c7b5bf127c80619e854d45327affa110aede65737d9277f9121a5e9840d116fc5650dadd04715b54a3f269187c74b120565e9571d9761529216a7d5d64380211acf4c82e4cea4eb4e5b007c29aff3809e06da17b76557e289970c3f50a388249b9ee2dc198d68977e699f89ed50dd4a8c960eaae195fc004204b37a78c41ff1db723987d6a91d0c42d4d8d23e47794b63b04a8c976e8fcfb044be63760bb4a145f16b976222128c64f5a277ebfb91f9f7fa72bc3053314ea899499fdd8d2f86c93af1297854834624dd7062c9413ddeb786490e9918185070536f3ec751f09d660acf7b3a27bfe42eee56d43f8e5aea5d0357eb8432a20faa880cffdcc7dfdd05f9cf1055a3da760772644f9209043331eedd4bc21e2ad41579f186453ca6f70315c05b96e56ac1a835601fe78794797d556996cd6b329cf388f221cccef22ea3abbffa9cf1c10b2fc7d4e93b80ea9ad3c54de822dcf5b88a4b755cb6931eb3c0d097c4a865af26c390e34712751ae76901b9e133334546b13e559ec69d04993ed66f6919fc3ddc43fcb782bae77ce4b344cb69711dae0fe0d0f4af7d344056f11d795742feaa94a548c8d555641daca0c40c21b2afeda06676204dbbc1e535794bd21332d279cc70024c04d96b14d532f0a5990b58d91a1ee4f93605b118088261c82ce6e642840e9bb6214ae83433776ec91bc6a81a5296a98c1f8cdb32747f730d288a6c6d7894e388b7ab0e64a971bc69018daa68797832c0aa4807b35d1175034891066a451ad87c1c6ca560d180e833f3fb43705e3ee9269c1cd14b3e28acf580d58584a43d0d5041e65cd8a8c8dab1de6c618f5949bd03087f864d8f415722ede602a2097bde15af68350530aad16f671c0117127e96870bc0301af0ece9352397ce23fb64f5103ddab6a4fa5fd0d9bc335a7e825ddf4eed98f788fbd77ac640460e1ef827bd84e431cef4a690181b23e533495c46e88a909c8c2fdb7604945d48d76233a25bcb9d185cd1011ea91bbdc7303f84e8f2b4209516f0282513ef169fd9db958428f84231aa68becedffd6f52bcf34078608696d1d2abee8346e1a44100af53e938e02a84968f106193c05822897e34755ea93b428ee04c0e5f8cc2771fd4772a4214fdc738ed822bc9c9638b2a50d2362759c9d70758832db337f12e203f7d96bb1f980628887a790d5a638bbeabb6c9a38e7140e8d4feb7ac0bb10047800f95d70b678a67f1923ad898b8a1d9c21319515714c820a87b9132946137be1cdd45dd392bb27fb08c4cce254bb4454791795924c201b0dc8de522aa8737c4163a6d197ef25e1b0bb0974437cfa81b8f841ba755b3daaddaa4cc5f39d00230bb62ae8498374d06333c7819ccbb5a73848a871a9a808b587100b6f2c4d111cf820f3d71589afef519b8cdaf32fcfed9f5473246402535d78d7a4cf8f24230f5a0a5e28d2f088ad91893eda19dd9254f9be39692c521f1708a3d8a157b852536f06ec9ab8409eca2fc82d1bb5dd2d34141190cc6dc0ad8de8b54f5bc405a0cc61c8a9c839978b9691d3147166e0a6acdd14fb88d4ddbd1d35e76cdb480396291fd80bc178655439a7db28b508a1c19596103fb31f765d5e03de41412cedf786fe87fac27a347f27a7ee90a455f2c3b80262169e04255ad953158630973a4990513a2a58ad3954a11b0d4354814a88fee634601cd94babdfd190a25b30d1169f9af75a3987943aa9f0c3cdeb34c8d38a1bf6b917b4660d3fe66e30e17f06ce5c6dcf6318b0a5cda5ae1f3333a97ad82f3e018995686c02d82c22dcbcbbf955a6959c899569a17576dee5de211ad09b0a84f934a03bf4b30c7906339694a3a120df52d536c406da39e6930ae61d0a23cff7fc85291d0201c9f288af0b51c0e1430d764d41868adebf0fabb15cf2749493888173614faba7b6cf10be077fbeabf7293b4e0af2493fe038f6b7289f892d5aff7b26133adca37f6be63d00dbd1a94899b0315d43e089595c58ed5a7a5eac4bd3d565cb44bf381ccf608a199eb363def35bbbea8a1c202e2af117bd7d8889fb49e9d96a88c2468c35dbb221b7d1a5b5a4042be8e634521f019f9dbe236af7b68c89fc4c68bc41d1211c69d9462089b1bf6183e50efb7bca187d48298ce75dff13b8b0068e941d937f85ee47a3d909c45a391a1671fcb9663bb68972d5aa264cfef69d40ff483bbd003707772e31cc335d8b81e48df9d39cac905ce40900d1cb3862bfde4193fc4fedea5d5dcc8863bc8b8738508d1b2e9e12474b9d4adb0270bff220a991ff8a397057786bcdba0d4bac88625a2554709ecbd1341dfb14e3174cc9035692d06e46a2f3c4b019166d2356dbe60f87bfad599e1357da72b342483faa5542f4b32d04410d436b4b861294868c895ccff1342997f9efafa84ed71f12c6823127e4754094ed19ba5156eac4e6f209aa3a1429f532a7d49b5cbb6f4d533640e19f4168bea87da5b85ffa57d12908758b88e3e33438c856d269173a7128819cb45aa2c27c1d0f88bccd42717c38dffdfb6fd55c07c0a0cd6b76639952e7bed76bae1e40d1e954001c7a29bf1edb1e3cc96e0a982bc737674185c6b626614940f458e4cfea6c49eb8da4b4a2ac2845c5df84f8c7d3d24c97946a7ca3d60a4164bcfaa535830df1c523ad80fbd4f300bf7542365c431d0f1204e6ae48327f7606e1b44c254705ca54987104235f5052af2faebe212e26e49ecc98b092d686e1fa65b87283d3d42ec0e8d90ff2fcdb0cf581936aa81617fcf006da3286ca09a6ed614c2f1d426fa41d95fc8e28d5a146a02caff673a2eda4c0c25cef99d5680fc9a29ce930ec02b3a18ba5e9486be096ecaa2876405251b50ec7b6d91a0d9149b28a9b8df6615543aa2b310fb3d936d08b262c5bf43105039ae6c6c9fb96fe33394c98775926680c4b087bc789c2e66e2ee0b4ccec465dd93736cfd216a4b799cb75d68d0a2bd17216bb2f0bbe83c4033d9c4b39c39ee21ca496de99b8970029180fe9789a57d1ecb28f3d3aaa2326842fddb4ff9ce5bf6d4dc6bad79bcf4c5c637ae6c5b4b21b384fcc4cf978a5aff1d84cc39e5f94e7957281bf4837954aa0ec8698c93ba44529f774a5c3bf5dffbed215e819cfc00e40a4fa207390b9f2dd53ec5deb5d890dff7403421ac11b71325867cafa16d0158abb22c6137f9e1627293be3bf9486e2a4086f1034198293f2ae6335f949074cbd4db48a6eda8e4b46c2791928c432596b0940bd9083f674f5380edf51d23a98f43b95e1d23f016611055ba9c9e3831cabb432df678f6c97bdfbab7ab1e323f8228d89de115e29a518d506544b2a3311f15fbf7d3a53ca85fff16015494e773c0790524e7c71f72ec778ead85879d9e1403b6632e1980d188800d5ac7b9f95192cb005c22d0591896cba5a863cf15cc009b0fc26a81ea8b33d361c3b42f70c6e0cef6f086c573f814d96fd0edb937bc15ebbdb88593fe004cd6c236d5e40b75f2c56126b1a4d12e4440e6773be499de8a6c6ead601f2580930d585086403ada4080d590ceec27ecb7f2114467b96010c4ff1b157a724871dd7ed8a9d8f3cf4045d3156ffdfcc24d09d768851ecc79758c76839626ffdc02250d9025f5c9ba2ef75888e387798d8df6c6a70d8c0f2d2b0666c9c3c04eb872393e7015577287b8f07593632905b06ddc557b0d0afd84c0f2c3d4dc1a9e08034204dc2382af0e569eb0cdf722f684e55603f52d8170d45c753adf5f7452c5ee753c2893978c790e501850baad0209df6c306840e1902ca9ebd54665b984776fe0ca401a796a5303fd537e7a5626956d181a0de028ffc878c4a272ba74ec3a4cd231f1036afcbbee174a1a51846ab61f5a3f397fe7c6357e29b904733d6fae918385d5bc0c9f3807d475226e5809c930567402d775b0ae4b9ed6a65cb128573acd776254b019095b5207efb89620b10e1126019f185a316f10a9bec0df668fd18edda200b44ea7a631811db38fc7f12292ab489de719f6f6060259bb1615bc4205459106fbeee0a314f075b2de656da46571b9c0395bbf1be7d5485a8deba0a829cb91d95b0039d73388bbe75338dafebe659b4b47aea34abe1636a958e8ba1c726207984da5a1ce8615edd00d31cedf6e434d1fc856229bd44d4cf6cc997ce04d50c722991614e679c756b568fd3afa8e17ce2635bfd3d29e0d967202125284a5e76776bc30d2ec3b79d42ebcf6a7598586c35a4238e9b82d02364ab84979e8f8cb96f612b419d9b659df95dffa8288c23bc0982048842155a89f4896e86870a7b783460b8c3980d50f7b41f8bfe031b28f7633debd980d338c4a936556cb55f37c3e2ef37c418fe8e37f34844770c9e3269bfa9e8b45d842093bda046a77bcfa3d0d1c2f8aa632374fb74dfd8d37ea1e9cb07ac154b9071f55bcf1f054da5e5e6209a1f683af9c41b4e9e97d17977a32d26cbce62e32f17b30294f2eb797132b056aeb3160f1ce5e026291df4c02d87d55c20811c24ba5ded1de548e20d1a55a7deb1d71ba5d3dbb45863729786873cf508dbfed3e0cbd6536b0479c9bf2072a732ab760d9214c3ff5bc090422e59441539dfb6ff9c3f33633484b0622ecdd8a7a1318abe81d482016ed4d3dd2e14664439c1c80ef8320e07ad30364acaad77569b18ed20b8773fb96d15d2cf954081ca6c049899a7f2783db2d11697a898810c56963528ec2b6a7d180f8cefe7ae616a721c5a0ef27f2204e0dbc4be81a4af50de3ddf7212c419b98f727a63533d0d23eac6f3736113c5c9acba206ddbfc4687a96c0ddff5a42c082803c7ad7d88c44fdb47f126d95dd9c11459d37b12e8f032461d314b2372aaec6b53d3453f58d70d054514bb9d0232abf26e097527601499d39641cd9581c0c1e68b96ecfee65ed920176e4e7d064875fd7f32ca769e87db891fcd3577e0226d785c2af7dfc53f09fbbc1107d6241692e53e9ec67a282dab2af1673a9b4cae5318e10be5d9c82db76aa9c3f4699299bca696a59d82d96862c2108b8a72cfa04f344852d63b3b2d13fc433ec9045d7828760dfa5c2edf3b3ec0fc59bda0f4c98b03b26de4b765ba7dafd35926cbe1b6807720ddb86d60f1c96ad86cd8c609bb0a04a5a8ef495b206e0f46296883f3c95c2250b00926ac19e738ce757795e7b3b40163a4efb00c9623bc5f73146762b6c7db3f58024ee25706fc72b4d0ce9f55bc157f45f0b60fb64e0de7c2ca8414779639bb9af4958fe98a125cf86f69118b8ac9ea128230189e28a1767c5df6db3b4996a2625f731ea16d8941478778e02968070babce6618a5d84ce5c40fe06950a276a15fff7d25411b3af2962f531b66e5eeaf53724fa2eff2190f7fb4442fdaf61d2627b2e46ce5196a48b8aa9e6b9ffcb06e8ac4cdd286231ac895ae60a067a9e1729eba4ac1c4e0438c9c1c195419aeeeedb7f45133c6f0014ff37b8e9f46b70c7c1e6351f6d845f670a5c94d199906c065afb7ec8f3def0320721a00516ff416b9b4aa11785e16372b2a49b00f327d8ebb2156e3c0363fc7e7ddf39ddd8fdaa2e757959ba4384cc9951160b4863cb7a3a6461ee833bc10d1a0adcd3025351d4df46092611ecc40d83d610604557a9e5c464a31e07d24b53453b46405f3ac76e0d48278596e302cbd66fe7f14a41f5fde9c37c6b11d17050dc1797860ce02d3f184747e3cfa77539f4b061bcbba7f5a412a9184f2ca0457e96df2bf7a04d2a54a0069c8893ac782c521b5e64c1c69b78347cb71619d52310ccd2c52588a25e96c9ab73c1ad5b6a063a77201af67fa16c4213ce74b3f9c355278a4a3e4d67bd40d284be089a44dd8f018b10699461229713bde5f1594742b7332e9a5b8b753db23aada43f9772703237285a73ef15e2ba65fdfa2da2ae6e708ed75336a35df52285cac33728c2e583e636b5dd5083dd1a368ef56dafb91a7be81dd7b82afabeb40d83925fdd201358caaab609acb38a317fbe9237fa19afb7234acf62e9d6c7b73cc58c6bf3f8e00809b9a933126ad63d12da09e560b2d4b18b9989a0ec426abe15d6725a64ed533f8d9a133d9ac2e66143104816aecfee5fc12d96427fbbfc1d9d82f1fd4fac66155950298799b2cfb27e06b828db6c12231294359fc3b48bdb1701855686b39882970cd77795dbae881186ada5b6f3b7ecd15eaa144b8ac9dacc9b5a77c126f6dcbad2dbbec45367cb8fe300cc2d6fdd26e39d1d3a87c1710e82ad6a679808aa56f76a0fe2a80c0537003b0d4a3318a0ca084c7ebde1c5be11afb825de5cfe235fe1d6faa1453668e113af9f86c7690c72fe907a2b49f0943660de9ffefc3ae29fa8b6c2cad36f5a83530207dcde3362ddbc89ff4ea306755929ab9eadeb6abd64ac48cec486365fe6eb0697f662d840d9cf58d2d13ee8ed60ec61f4a5ec9bc54e3a77bdcf912a370faa38624dc332e2f28d199bc1dfd9691a1430b0158a4d65f6c2e017497f8475735f5548724bfccdd6fe355d4331269814b8d810fa7f8e8cfff49f8a128631742b2cecfe0a9dcbcf60a440c19a6b6baf587d3517c9f335ac9288269ccfb962913519ee2810f6abba4dee4662ae9bcefe594bde9851e7f3d24a711130849d786d40a997d9cfdb85b7c25fed9e3ef9df5d144f90f5442cf0d5ec86e1b1d84be7a5bb9b0399894d61b520c58c564d461e69f8d49ba358a1b4aa7b1303d115a6dc49a58f56ca7166728f16201c40b81c8da7ff5ce4ccdc7444eb79c95576eb978f145481a2d3d590033faf780ea3f3e223f700af7717278c9bca252b30e454a557e7a9713e6207aa648d508e2be690dc505fdd812d7acb13ed88ec905a1cbfb81f43e392236ce06105f2ab14fa5a51579cdae0952960c4ffc487cec12d119dd27adedf3264501e0b5998663caa355033a21a8e4c7245bbfc0b76f82683eb8e83f8b0aab9bb6f0200f814e9bc7f8656afa02010ffd2d09a731eb7762e883a7529b681738d57abd7e046046ca39f15ee3902fb2839129f3535ee00eb189e30038eab173a875a35594315a81b2d43c1365198c9945605a4aa922c1d4846835f9d10b774b8e2ac8abb05b6e44f20630aa41ed1b7b1bcf7b5f8f360ad600abf6ce732f53a00310a32de925edb3f7fecc0341d5c165e7837627158e44ddb0ed79ba2a1d54cd3dee988d5c24953822ba164f2c312fc369789dcf78a4edd3f631fb506992066a66c70d5ead8f52af85a6f17649191a0dafe3f2ca58f3bb90e9ef665e1ad71b047dd9aa5311305a319997cd782571a50cd445d03707c4067abd2f9cde04d1f8889456d2f084bdb6772d9cce7db610dde24c180ec14f17e660044887e1aa316a2ffb39d6fbf4be1386edc24c59e1829c245ecc1bad00e870c541d2b92922c66e2fc5af6e5198f837301ae2ed71582f85e5732373509ac0b7836b7ed72c19417c74d0fc5bc0832b4d6507a338aa4512ccfa4ec5a030d147f6126d6c310587bfc0d9a891dda0af87ea90001315e27e6d36bd4206545988ae8b86c7c858cd64feaefb32065d4662034ea0d16670aac09ac40f004f0ac6196ac12fbb48ae4fbbb23edd0d01acbe3660a5f099565edd5bd589e5f04ec2fb430151f7bceec3e99d7b561517aa881701e2be9e61b918a348f471a27ee0d7b122e1724d5f0c6e0d1483f7227af7906e155ab58d25520bf0c5c358eaa49d494996a0056026a137c2c75389c159ba6de7a7b4b3af3ca3f21108cc8e4e9415b2c0f8ea4903ee7cffa6753152479f4f2cf4d2b99fcf857abc1e28c934388894b9c03090aeb205c66e2dc0617eff5a2324f7a66cddb9a0cbb23cc674ff8730730c126d78aebd5d50d055a123415354a3329c82b5ada03958a9965aae7ccdd7b2e6d7b3cb61d8a64c7a381a1275bdf064e926f7b871b90cbbe782b306c165867627090066d6ea3d77596af234468906adec22817eb439c6e14753640570f604663aebc6a9e1b8d52428ea16d29a559782ce5b5fbcaac59608df1221f0e20f0eb0ea48204fc564602c0df56cd35d7e5125b9d085e586237c562c347bd99346b5034114427872a08b0f52d5436553a7946473fb9b27c9989fc77d4e1b26c725998d5d92dbbe249e9136ded184f6e09584936bc06f49965e26279521b497d3e2865df7b8da89276859b73525d0fcbdc0a4f9065e3f9083d1af9cd26881843717cbab7d13eb992ea16120c2d3af2df44b99964c4bbfb37413bbc18850f03e1497c6565de103ed4ae2aa6723bdf132bcec59ab0b446eba20bb408757ce2dabbe5fbf07eb96336f3e4a2d5bcd7eb9a2bbe95ca5b054e01225621d3e48ac69d18b9c783fc3ce76696e18db1e346a966abb37604172eff6539096fd2defb04575cfdfa65f2ce2fb2895bae4ca1b6b9c8ba71ae81ef6699eba2aac9f80d50f39076b96483a51408644189d5caf733bcf751cdaa86c4d90d6d5adfd93609e638de5a84b1eaddf29e334e2978f8a27dfabf858dcc1e9c75b1a1e3dc33a7b9fba12e623242f4aa5f1568074f2d030a1fcdea3c484a3dfd77f2b2d1994e8abe4daa2cb2e17a8936426ba93d4ab4bd56f997dc80672758f28c502fc0bac901712ccf5a2d6d92a02cd1e3721eb5df7783c0d411a3b91d9864710699b2ed27332209b129456840359845110ff21b972205878fb251df12410697b6aba8bb47c1bf6dd6ada5c66e243ca2fc4991f0a834391037dd59b6e9a740be820b729f6820506ffe4ddbc9d7c33db6961d03c9358f16cbbeb41b657d44cfd9154ab73ca54fd72cf10464ee0a45518ffdc4cfbb552074d22692c2bf5dd000e4a26a9a6ffb604b3ec1062ebaee5ff096ee66377423e2f529df5bbc0c1baf912e348a959a304f5081f57f400baa2f9ee74517dde7018f8605ce69d7e3fa9a1835c3515253d04bfe852f01bfc6c85a90ff48a07807394df8799e1b8538512a49a27169257f14c31fd381a63a832c7edbb96ed5d286f040d2cd37deb85eb8450998e28d1f36a3823bdaf84c5c2fb1a0df1391f7fc34519f6b53d3f4ef2420e665210836ded591a1e5d98a0e7ddc118e07795e3d0b90a3205cb33ea423548df89391bd43e17ffc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
