<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3de5fcd4d80311a06e3786cba4672dfceaab9387292b6985913a8385c0903af32dd1da95cf6066529c3b50aa082f001bba5ffc64900729197abf9a6b349063fa3a0a24951ab2d41a0f3dabfd6aba1fe825dde9df968d91be08cdff1a66ae966c22b02e5b89b323ea13b68d68bf0af4acd95058c5a4e36fba6dbb879590395986df62c5a3597ab6c5d747fd0299c80ff4f40b0afa37aeaca9ae1ed5391518e8fa60456dd729d501bfb3b6062fae644ad615cadd1af70771fab6193b379300c2d6b1a7c0550c3be604313b256eca7525d35a54e0ed0cef21b7083724ff5335013ab2f9ffccdd679e03bb6bbe33f34bb7ba659e9bea39c062924130cf31d4ee87ec9a75c153013a8fc96dc43bf596dbdd572e26f22e7e2299ecd9f750f8c397a301c6366eea859ed28d21764e1992b0f43ca46aca5e0d34d2692ab6ac45d77833db5b70d6ba6e2343fcfe4259704e9f9b8c26c21ca9a6fd2ef419ce0ac79e8af5f8f3827c973740e27f83d4099820fd245ec1c407d910f5e7bd137dfbc550e2b018fb624a400161feea9e1554ec7c78d87afc1d496347ade11b6a0235765564552ac8100ab84bb2533cdee227cdb0542320ee60bd0d5afb1b0dfbea96b5c2d166d70feb8d853835606e2cd567e4ba01a7fd7aa56a6949d770948ec62340d9a1bc6f054cadbcd1a12c964a8def8ae8657d874c12161a716c9d38bd945775b0928edf7ecf2c5cc97425d6eea4a0f06d0bda7d4fa33b57034bd9d48a346722b2a55acc0cd3a94222d9ea2c663ba7ee4f8a989413c0477af7153c14b33109a31be8cd5a408e5324092177b1a4be3a9a2fbf0acb1e6ee2afbdab94e8d36b0305971c2fe376455b4a4f9a209b32cc53a9ce437093737b7efc208d581a299d5cf26ba787edaa027729ff176adb733cb6b10ecde96f9d998ad2b411cb73ebbe7d1be89b4b5ce9188cf71001418c84b5edbab2bb432641cc753afd0d19834fe22693fe641d1aa161a9ffa10d06dcb05ca1116640d7f1e1eeec8579b5f965353c243a92224d10f9975f47359eaeb9d725f45331731776739a339997fbdf3e37b60b451e0b183a9ed819a68467be384efb181e91ee1f4554ff1d4dd5e2ee5b546a2e5dd6ca9711b6c7bc35722331693e76a76d543366b55f4cc189f581788f95f32aa51ba4fd60bcf8fe334a2c93183e439ea954b28f25e9724204e30d6eeaa21ce031b7d76170a3729628397e2877bc821d6b9ceb47ecc137c6cc5a83cf9555f00ff9608af9b72c406835d32375ce4d58bf3e63c3c43cc1f1835b293eebfc654386ca6258531e3f85e7509ccf21fc953ec1728ee9facd23b372f00f9ff286fc3b91aaf178806f6e017fb0e0da56a4e6afcb336dea78caab284eb52fed146eb54ddf45014eaa5a0b37e124ba6fafb7086f946b39a553941aece099e9d396fb94e4c18f18be6cd558921ddc6374886d9f106f9e07c77401d5bcc6f3b02118337c88076f99ff6b2fe1f4c73ed8c0b7fdec61cd9c16863f701afbfc1c7b18551a021ecb86521e59076b32cba0c251d5930856e40002491dcf9fb7f8aa275ad178f536854ef5c1638cf9c827760686f7bfb6d564920a08bf106b5e769d3e2c49685d9024eb7636d77e3d11faf02f4e408745e41bd316ec9f61410e4691544cb1b260d6d8a89481bb37487b5098ad3b20f76d35bfcdab23496ce0ab847d70ec50743a2c684b35c7e6a26581e087232bc4be99196706eddfbb1507c2ca5aa7fdeff6c93802963a967bb4c1889bcd2713dc788daf276587fa51942adc7c2c91c49d2cab7aaf2386ecb8877dfd47848741a6dc61cd2b508435af817d72fa4145007493205fd77294584cae20ce547d2fb4a1934362bd191cfd7f4ac554df60d9c2f93e4d0b8835c083db28b8c57147b7bbe368f9f28ca6870abfa560c6f0d2181a1e9079003e4a1c69bd509b37f140b0257e51fc721ec664a534fc293c7a955de3a5aafa6412b42b1ba0f789e645b31b1d1818fadd2a707778c9e5e9fe740eec643a93a418ccc2ce0e2fdc5b83a209566c3ffafa4994784cc4781de52871c49d1e70c9d2ab36edf0c3c8dddb3781afdc5dcff2a0b8988c138a72779e3c1a0f226e6e8023c6edbfba79adcdbc1842bfbb28a583046d34da3e15e4df4c4879eaf18bfda129cffc07747d63319219bcbbd60b123ec5f42703a6a1747eb9869e8d931894223fee36ec971f7ad32474b982984b1bb2ddc22290ed76b1db335c9951992b795660237a35ebb5fee60d3aaf84c30cacd14c0e6c2eba7a34aec6d53d4bf897ca002dba2bccac638b4a912fe35f6e2f565c0014ccbd06d891f864cc9f784ef46e76d52d9d776a143e0f41e99df9b7f058dc73b251e4d923290e64973349fba9b317f20bfa277936ed7fa80e8d5fd4aadf40d6a1d5971d5a673e0e6932966db6c9933abc87eda78f58b3bc15d921da3c9621b93c0c70dbdb4650c8531b2bf05dea178fbebc77482cac8783a2f5695d3e80b24feafc3c6c067eb90733391761f25350ebdaf48e2e7e4a36173ef3c5536da8907a564012a0d3cd1ffa1bae77ceced7b16089155a625918670d00cfdbe93b35513b3806bc769b3f5419fd3969252d2c7b26523026309c4e30c2af5288efc85964402b1789a97f34ed63993a0b48292448d342aaa4e71997fe92d0316d4f7a3d8306e13b6b6af98c9f1ee9e6ff38f065a8b6a9a8994b786518ebfd63362ca8d78fb8a695fdfeec28549c83f2faf45f5ab05464796bb0735ed5b7265884a1269d3c69dc0aacbb6da25ebb983f0244b386e3394139be6a9ba01c64ca2405cf6b23e2133d6c73d3efc7f8ff02beb5854ab314bd87d9a64c8eddf8e415c9824c4133bc1be15ecc0495fc552d1ee15e9ada1a043896956d129768c9d110489097456a1876de9d2e892b293ae6a4f17b65f34557d27f38e33b6c93ea4684816bad22e78582f8d5bc77641a2008ad6e231e03f20f3550ce6fb40e2bf5ad21a988f66a0adc77e864960b1eb3c6a4ca8e7a5607751fed6d74faa7b230c14d675ee4b275ac3e028026f26f528f3fd7ed9b3262aa5bce375979268dadeee7e589ad750a646d8fa778285dfd53abce35d00be92064391f281cf12777d1fa3292620cb6eb09277affaaf603d499a4466d1369629009a1efc2c895e2210094ce5796274c6a520bda4704ebb94f27b4b1a885decdcc5cc0d90e48d7743f0ccce9082f595b55c59377ebb4de0b8123733d9ac5c2e148e4e072e974ce1e28671634d361fd48ad087b25d33f052296a964728562b14e50240d5567703571e41a696d6758dcf0948f2a37be93d0e660d4130b85c9d7f62f5436d5ca7d765107659e1b0b340bb148a26a44aefa506ec32aed19c4ad2465dca30a7ce37e7920077cf10dd2c2329f0b3d59463c008b66f1f612717ca8dcaedd3074c286635454b7b427ae66dd30ac78568b6ecc0c06495cc5091ad8258d8fdd47c51d0fe54debe0b1a0e097b9a834e05bb57e0238e861cb11b3ad3dcc90c9cc7cddb4bc4e2c368d67822df9d223a08cd10db0611290f53c3830cb733bcd5c702bf18c81b99e188346419dc0178bfcda096192882e7e442a1e77b751bdb3e390cf414e6ef004a06057816b8b52ee0b52baa7eaa1dc07d645408869c814d53f6d108069c68589c04564156a6d5fb2c73585db760561a533efb41392540406e71f3a657f1d884270bde5569598218162d9b1c18ec8255e674e3d5ab9c3f7c4b73da1ca122ac99c29eddc215eadf74c72ef86ae27602c3181c0ed3b817035f4ad8b5f4f0ecdd5828b04b7fcabd9364a3e3d1d050b7da368f389fd8fc453c2e2887ff473ee25e44fd29cd64ecaefabfbe1a0d755cb3247c520ca9b0a9158754c0e43f9d865f815aa88c01ec457a2106693de404b48a1200c5063ac2d8eb7b8dea05d714c0d21360d1649e147ba616b1fca841f799e41c47012c3f7547c1c865c80f9a1a532d1422e90c43ef83c98d8c7991abe639c901145c32a73a8fc1e4774bb04b5956c9389a7f1835911f0deb05a8f04a38347698c920a149f0939971ee7ab2a9a97cef5e88212a718b478f65c59d898a671cbb3dcc31864a630548a5dee88a47038ae1155955bbcd46df0d285ab9222f45b9267c4aacba8f3e295a955f870cf5ac908146c9bb3fda44ad11736cd3f5c09d85379e2d77bba1f128d760558f6cad5ba99f028712f6e1eba7d4ab029b314fb518d64f3c45161949465780b72743bb22289bc16f287f3ea63b02c78c5a66ef598af12d88a0e5c980ce3d875c0c45187aa6a85a1eac7e18d6d2783adcac64456aadb0cf0755485b67a9c9a289f46f328f73e8711ae26bb1811fc40c31e87df0c4c5c831c021c003a851b8cc3437333c2ba8fcd28e8bf17e17b87fa826ef25cadc6a60ea0a160abce7bb0031361478cd1fcf7b61e9a5f3b961587c5894e9f2360ffad667bc149b795e42e049011c7c1ee2d1968e52617fde3b70f37ee1a575dcdfda1bee44189b35a22759fe5cc8594cfae05b394542670e6a41118933fdc864654acf1157c1c68a97c8fc75a6f126c9aca6d62b853999f4944c2d72b93d5970a9427e0068e4ecd4f6d13a41de09d80960cf031d499d3afba767a435c757eed9da44cc2ce3c7f18e238503ae884b450e647c92b67b30c6c994eb49f34e909f52ea15a1560e26c15a7cdeb51bc4a9c2ab3e7ba7e2cd613d92191199366c5baf0727de3087543d7551d8245f57f07f0ef9c76b1e5e42513959aac97d37127742b8b3c7c52a0cac85f5e666fa57bb4333d1598d7ff2512db1d1dd40d46724e65b27f4c7300a6e8e058f208c799cebe4cbed63ee19e29dff7cccb5e2c7e84f45733e0c68ee38499685d9d7092909fe92524f048bbc2072f02c1ba6e2bab8f207dced8d17e1c1ad8f6fb6d27b553dd07b598d81b307064890af774a9bca7bc0db4873d5ad768491cddf4db4886ee09dd294dd4a16d762582bb8d293f7aadac2a27d7e744bdf17f081b0cc88777e7424248b815bde8b3c20e1e51fe269cf919f7fb205707656130c322853761f8c61520046f594d8912e6ca717cc137388b2f8d831412ce827f92acdb4bb9d7be97fbc412b7cf605a8371d8b65628524e28abbf73af1c7e534ec51f69224d575706592a8a1dadc776a980a525d508447c3ff5639029d165f6c847b1496455a0e351d8267ade7421276899d75f9126eb1457394bbfc36ef526d60ccd994c3d9bb47814cfbf77f49c60c470e5049b804d7ae02e20d52ac2e38a8afe2a9e3516e260259756a5a19123dd2e9542aa5fcd2fdcadc6fc236881d36f795d2d9a5735a8e447dab4da8907b8cd076cec2cf8ce5d3e062243da223ffafb6348da79fe120b7ca0dc02bd00afc0304f1c1ab994a70abeda04ef0cca59d5f2824a2c60a7eafcd41d0765c91cfdf3ea050fad191b3cd0adf7d48c28b59b6119b5c67702b9951ea47b4eb4c7c50ecc89e201dcfd9303e7d37e1fd0019fb1612f9008d822e20af17bdf1b64074810ed181c494cba8d2707871250a5e927535ae97b25511734e96fe2803a97d7f2dca04470b08cc742b179b22d45acbb78da35614e3a04e338e3bb308babf46271337f3ad4848f905652943b8be247c82ad2fef38cdb71d1a6104d2aa6e8fd569f5c0b62fd04452e296d0a7af520dd3ebf4f1fb98a2a6b861d998925f8883a65b7e9809d2fad08190ddf88d777e80cad51b9d37f11c27a9a21bab641b55f2d55b349b6879c91f6102068ee188859b34313ba3bbeb4f33a26a1d8149dc02e0be35fa95359a4ecc698fb19318be16e7a73988c796ed01a37107bd321a8d8bc4c31b16726b1bec81b741bb0083b95927ba14f689ef62f3f1aa5a54309273fec4096ed68cf669227155e402231b76fa644d22173341e3d29762670d8bc1eba7a1f21a953d359bbf425a3e22cd52c1cb2eccbbd07766b7af5c94a640b8805df043f31e341f0eac0b395a659e8d6e3c558d36958f93b0b1b710198a1c8f4acdcd85a03ac6405072177661d1d7a50e2315a2edbac6577ea6b76487d554f43411055bd41a71dcb5df8a4cad48245d4bd10ebc8fc0c6fc671320868afd3494bcbb880e53d370571888c8595cdffcef3bec5fb8a4b569cdecb806570864847e0a38f6ed918cb4de2c0b89280a8cf9ec26efac6aade1274854b626e45b40511579f8f57db3aba68ecac1fedb7eb8cddcbb52796aae49cc58dd21350fc72f54c28c93b02d935ee85d046ea7a4f94d36b48f189fc4a3371e81bbed1a86da3501507d0fb7bda8c9161ffca946c6a1a6a96d8d09be5caf8fbd141c62e9e5b9ca76f37b86dda2e333559b71bfefcfa9338a08115d0baba457cd376f43a3c73e0d1308b859cb4e7c39d9c2f15c9742e16ac15ba849331ad61068142c9ab052197abc636bbfdf6feb491e819aa4c20c061f22bea26ceb9cd8959842c125226203846eaaf45fe6a579a5bdeb21f99f8a5ab4e75bb8579b4373db6a1c2ed72a35a9b3920c5a0230449fe064cfd0df5f2e8fd1790c811e6d2de7aaf7448c2e4671dbec9549149e5b3df5b9d12798641ba5b4093f28e9fafc6fc7d6acbbcce127afe7b9d75c53d47d0a0b30ad70629f911bd464befb10309c77b9b714b70a7df610eaed224021e321eeac0f98f1ae3cdc7c5682a3a1b21ce0f99b5705624301c4b26d17d7b08aa3d18852da190226efe23a41664ede15c21baa7753d24b7c2b83746df062a4651a0457901a9a0ee40deb2db23bf463d20bed4f25e0232c56884c895f167453d5ddb74326b199246b8b70cb353ef00dceda858c36f1f0afde74ab6b53984b110fa8cccb12073237184e233226cb04fce53572d84ea362e6cc050634a503a314d097ca5278097084852c078214f94ce45d1b6c956ab54d0b3bdb9ae8b4f181efcdddc75bf87702109999ac43a4601417a21b5f98868b4b1dfed01c22dd65cfca869e1682aa61ee97d8534d8811360ab9d04418a2d5648241a60b02544c3b4145d8baacffb8226dd9ca07933f467458203c27d5b4d3f15596e113d5a58780778202502c62253c69131cfed62d52e6bf4f86b77ed0f769313469929a890a3bf271a3a1a11f2fcfbee6272870c24e8d17ad26c2aa02fcb97178ffe64b4c5309032f7e71b62f7a080a8f43076ea14d98f58852a190d1e8653f63890a9791e40ad82bc627e427b956db0b368ae9281a145fb6ba58975594b7195d76fde2e44a72acff19566991a7f4e01c53da62632a01145068a93b11627b6599f147af5d241ed2e4bac1b92c679ecd1aadb716b2f6cbb5c09a56cc3c283263c287dc9c47d479a01b93d39c4b87d281a504d1b29c4f0af7fe133c74030c5e37e956d90f21e36430982ea53e2b26aa3c74b982fdb2a4e42d52c2f9ea535f90c4ce3442f15b4f267a6617d3cdbc794373e2415e9d7469ac82ef65bbb6da2c50cecf74833cbeb23bb334d2e2951995c5004ab56d5e6b15f9acf90de5998d2c5db39e1fcded8044aa6da2ca7249c4a48dba9eb0f7096aaa7e9bc3eea00eb013c7e46326ea1b9ac6dd1a8c6e182aaf2a3eaf4b5ecfc1198a49ce9c6e38b333ff76893e9d72d5ac92832682c08ad8ce76f46bc4835e91b2c5d9f948741d4f65324efd885858aa395957f4df5186a0b01e953cd3d5c4fcba5b13d34ac87057b4f9f5c36bb4db867accab601dfd97d8244806ab486f3bc491aa1d744eddc93301222cb9919f99cb9aba6dc1a47e1016dd17f975882b5214f3b5b2da8fd4ce999a444cf0798f5d22032f3cc25cb162bf57f0c35d05992326ca1287a089bde2ec7e29739980128d7696305dcbf9c3ae03d7091f01a3d3cd6911f804a30b8e7fdc706cf1041fc832f9bce9ddbceb17a6e612cda056db457ef1192673155d0106fc917ae7e3a1b66e4b511f7c39523c9dc9738e7fb991b0158a808c0013336907c6739ddbf7023c78815cc34a2fef6952462fe223ab62a66586167f9bfd606a228d0597455c8f1c4e6e91b8c32a0be2bd256fbfcfed23cf100cc5b06c5591d2d4abe49d917e100e63fa45bc3f865d9a2058bde8a29d2b894007cb4cf000592cd510fb16e0fa8a00ba6f41ce8723f7a05a971fa5447f95a28e96859813bbd729caf0d05b85c11d8c379d7a36c3759ec079957730a8d186f06876a100b3b5255fccc30bfd0ddbdf86336400a754aa668c248e7e6516cbb85499ff3c82dda569548c751b3e59e684a301014433fd3f724e024517b57c01d865bbfdea62b2ca7668109606d1bc500ba27a7b51d0f57e47e0072c2f823c2b5f86d926635027546603e449fd5bf010b57dfd8f6c2b28e02bd738b3f14cfc213a4af40c7b0278e1e04716ff6b86535f012122d38079faea2840e8123d85e88a61c8d3daa4a58ac47ced0d40a759b539dd66eb1d2090a52e4d75c22e4e88132071706dc736b25a78c60662910529008a6ac703e2923f359e89a783531855dd7ba7fbfccd1073a1ecec2effb1be6318ba2fc13c2df4160dfc3e51d52ed7f1168f4a4179a62488b7d00ef4e110c24cdddfbf4eebd5927b9c7f107af87a9c3a5e394750539788828d648afea11f064fea7b5747412cd85d5bfc377a5a92a8515e30da143ce7dbbfc7488c1ab3d6fb02cee86140164f92731862e3fb6d52be8a5fe434de65243d554fe77f792948d35174b013c0e163f5560f611b2852a11d8b47e19dc191c612e1d15033dcff0ab6b4f154944067177d0a22f81aea1ae91e593de7304b7a4f2d4e20c3d0c6b5ce4bdb946e3378806bef28bf9852275fe0e4f7edb0efe9484dee29fb388d275f903b296afd7a4e4c089e6d96023789e9333c15f9f36bc3695fee4870171cae61da307dcd8b04564eff2aba3a141e4a074b14ea3f3dc0516d0702febc8d4a1f4acc030fedf186247a1597e1802327d401961bd089054e828a198a9b5d969b1c9ae7bc2cdfe2f671d88a5a4bf028af45204d5b157680900a290e1b5983c99cef624d63c92c122ee80d1af2f89ebfc2f3077bcd24daa090101bfcedc0b354841d5bf1bb757c16d248b3e0ce088d5d688e1e46ce1872a2669dd5dfdb08b8c945c4b2f107eda064abe8c28b93e27139ed2e0f1a035e28bbcce2bb018d4b81b738da4d90dac882326394295bbe09d229545146d89ccb6d0005f5af957a369850cb10eba55e0c214e681ce5c2d66b6d8ce0f9571a4d04f8f719bda52892213a71ff00cef8d5012fd030d550fca033a54f2734f8ba54235fd250681d755f400008c99c410d9cc7745a5ecab09d94b59a0884a8ee40a15d53897139dd39f12521dbe9644f570f06531977ce1b7b7982570ac285897badfaffc1dc54ee0783d7631becf9090ef29f6014a831aa8de92b564126d63c613b86dbbb0c213347f636c4732a1e0d0cf0e5bebaa5e2fd5ab140db826ef6ac8c5e97e8041a5969320561e94713b8ea3c9f48973f27a4a23f600e4c66f1d12a9f82b25dabc80a773f4d0f6ce829f38913ffc12576531e6d02d42de6506a6194d2062fc4b3386c36abbcf3247d441bae7d95ae25774677b3cb29fcd16f76991501b01fc257fb9646393de6222cdf4d218ee453fe5b2c75d2f122938c77654b884b5bc50f228b4b0d3ee483c86736d9d1e7148478e4655b41ec807c76573d4d4b1633c642af45cdf83d48397553b03a6b49c05de1c3b5c83c5d0433c156b07349ed16d775aa8a436d5fce8ec2436536149d4ddda6f54520053e59eed4f3178ba194ece8e8f7ed3ba3677e666bd20ab36c37f09cf60f7ee21087580a9877235b9733bccd9b930eee9a0e380e9780f4fd010b20361252558ed6737f6344475023db355bac73f269da8dda380901db20c843a88f9a2b6d609d1a12d5e1db9879f13faff760d3bf09063a194444f2bc1381ba17cebd8780c3d170f667c96091b31358349268fc77f014f56a98206d717ba60e5f73c25f86c73e737335bc4f71eb039db0bd9ba010a8ff1181fe073b8729f2063db2a3ea088d5fd7f54959ead25c08aca391619a61dbef00b58f7d204f29e103cf86ca9b743673e4792e8f29421186d2c3e6237061e8d39e6877cff152bd0ea90ba7ad64d17aa333a59c2eb004a5e03a3080321c2ad3682e3d52e89b594292183fdae81e0d67ab49e4b52d4e56c870ee1b35f24a2f81ee4f41bd538b34cbb26e8b85a7e6b52506d41307856396ec235a4a54515e58cfcc67d4e393eb3995e2fdd70a6cee05096e5b61f71523eb28aff18a0a291a6f197dd66559be845bd70b0c1df063c18af9daddf86cc140a526025bccab054539461cd93239857298f854671b83afc912e9b5431f1e56d7e9d83f0de5a01196d8b46a9a6f2689b767611f8b6236efa0758bb7ba1e5c3fe9eb11281e54bf7a4f36e69398788eba71800e2d5ca1e1babe29481501f4b5bd93ed24de12ee9f9aed24d7be3d5dfe4ea1e2ba97e67d420553d94633e02c61ae68cf46d596dc069f03194fee3c59585b0cfe1ebe217bf5e7c55cac45f07eef503f94278da7255966d8b917d9f9d5abef25d6d30bfc8dfa4c442fb06fa652a1695450d3c652cc600cc09b42601139a9797e85cfe4817dc184788d016d72e421b7c30c82cb6a5d7f41235e35209ab8e0235400b8303a84b3e050dc267a79c14fe5226105b200af981b8638a1666e12c3418c5f980cc71df1921c4ae0df023a83c0820701342617d4ef39c3be72537006111c632156b4a855bdab0908dfdffb3a0474e43672e373a0f7c8de3a684c524745321d63b7355744bb072afeb5deeca4d19a4317a7f8c3b809c977421096e272e3199d0952ab40201d62cb36e8a597c11e6fc36124a14253abb9e60847fde3b75996741c1b32b1cdf610f48f95a2482fd952dbb40cef2b7c90215052674a57c486ec5dbeb422d734f901b7917e3291c9909b17eb44a4ecd1db913729b286c4ae7f577f3ce0ccab92c6d4808e2b9f7adf2cb27c1ca3e40b8a159381c0909662ec5e378a101fe9cbb09641ed05e035976a7a684a61856ad9969f61a5767af3aaeae73cc470926b0f409ad7812af913a65ac6d02abc41d853c8d85ff050c1c7e35294b3605c0742624455236a9796c8b6752f4c172997ab0fa6a6bccaf137f4b12d84df4cc36c63de519f87745efb4395b093f129dc5f899f1d4b39948beeeeccd674b2eb5ce0fce2652e2c351f8ac3a3629be94873da047522b0081e9fb0869215445e785c67aefcd49739f4e2ddec25072960f58ad88b25c476ffd1ef74287221ac56f60ecfc739d8fa6cc69e007fae7b782854652750666153d5dcc5bec0ceb01e3a8a49f48d70e21c23abe8264456b500f0515c4b8cf549c21797415dbb14d2ac170cea04dd52a6e675e5a19ba4762c2f506461df36de3c747026ac5aa6c080becfc81a76f5aa77d2649d365c689a1967dd352447149f6e8d86bc9aa600b5b565e9fc97d1070218bbce3b40e7e48ce3ecbb48ddc6d10f5c5f497f91532c6e31d0924791d03d337b45bd10b834d47c437c99a90ce4e66e8c8ed5f98382ed9ffc343ef815a196e81bd57c68fcc246636cefa54e6928c4b9ed93ce6644d0a0dcb2e52d0c6ec373540ec15607901fca78edd9d90d0f6cd580aa3ff465b7419e72670961e408132b86af95484990d6a4ee03fca4332e145559dbe4c6bba826a98edf1ec2a274f9e845f9f5dd825946f14b2c441d6c2db05b7e3598803a41f109e113db6bc6535b6dec55a389db84f19ab91491cd33e398a0c72bf30c2f44627ff8c21adb81929db4461e2dc844e8de11ed82db0242a7c1a474d428db7328a5fba90c6dc9be58eaac37c8c48d41085a0bda52c172c3733f9dbf87a9ac77d5ca7b57b9ed4f74fa67a3597a071be68f9d230916949dbbc48c1adb032fe37745b26a6ae6b36081d15ee673ca6cda95883c6162fc79641821fcd46d03a5d3d4db092a0531112b9de98405fbe7e1c4f67a5f154c4dbebe7db13eee33ac9d0e65c8e2ba5363ca83675af248c17975ddc05355b0f7a487efeff086413b9e9b8ed54d8fad09ba7c560f9b2e3dc8cc66c59f8cd0d7c8cfca1416413c68979c299aa2f6ff65889fe4e2f71643646930b634f4615970224a96ea64751c3b3c12f6353c15850ef45de7db27b583e25a3516c8cf30cacf5e8fe771833553570589c9262d29eeabfc532eb365d67723498f1a341bc39d91dfbeb40de9043be312781f48240959e9b0fff4d89404a6bb7d05af0cfca66373968f60f8bb6cb43a0502233c3f8e9d2cff1b21b0d42861c477637853976b22c5d2e36ed445cea95f82a7a8cb38ed8366f25602c3a443627e9092f4c60fd78180511fe97b37fa5b4cfa7af02d63388b7639bacb0fab1f1d715f4526406688ec56aa124374e6dbf1e183cd747d148c7b039bc2eb7a44d3e0b6356530fcaae0ed2aa82204df38443dda3389a28bc6cd7a8441abf200c9e8c5c42505646f64ce6fb82fbdf27b167c3446e67a6118e8b0bdb21154c95806cf85e57efd40cfbbdf94192acf4a95ea715967b1d71b49ee4917e601fd88f40aee27ebe9850e818a1ac5c22eace5f25169a1f093165cfbccba9efade2eb8e7b58c7902fefec11e429861920102a3d8e4dfd63ec72be801b61f440d1ae5b9eca4a7ef7f73d32622e0e866e72ca76c4e449dc3736d9ff2b0e33e60c2e4f432e6c7558def780fee791818602f125d7aed84804330c9c65ae9c07a2d2a69a46fee324e2b09f4aba05c4620961d16c7fe009bf0b978013cd5ee0ec1caf7826c2f3dbf3fe6009eef2c92fb6ece033890ad103e4c21227c8cc793c3880da8383a508554c52f94dbdd939a7b41286a3adca9033a5acc34e64d58f91174168b3566c9f035b847baf1bb4f7ab9be13919fdd27ff1b92cad0fc638e6eaababfb3fa703a265db690d7cfa2539412d4bc354ddf23d76a730493d35ecb5555105cf3728dc9dc46f31ea6bd33ae90ab71a14e00dd623548666cc5d1e53629a6b133c2196aac5e04a0fd399e9ec04d57b528d47a71aca2de994b9239e239d4c58791cbaa3d2709231708e744f46b6d88ac70d275fb7ff0b2856e5cb1b84b0ccd7e9a9f5a97f8496b7bc95dbd32af0c610dc1ecc4d767f74fb3488bde160476c8109df978ec98a15055814daf80eb8dacfb8ab18d8f2f8e7fe545573ddf1f8165c3efc3d04435cc3e684511cf0e30039fdc2adb386fc585c560469643e2aa47df9dd13db25251baaec5e2e2e9a4c547734354dce3a3948ec8c4fe1a37f3f0d8f2ed890e01e889aa0fa889106866ecf936af29def2afb308749cb5e472b0ce7ee2b4cf8913939233940acfef08bc0aa755562a67037d13c2c686891ba5c6798c1972a53c8a080cd8e94a71ea62bfc8110d0dc67c9220149c39064fb1c729dfee7fe7c41aa8c02721b7ae7d9d307a3cad25678aa6bf6ec43af7a2183323bd1291eeddf49517c3ecb7cb7139f3b35387243800115abd98c219863060f3bd3802b5d0a6eb04387a897387ceb8be0adbb6830ec5814d4191bb176970d0d9055f77a4a0b0cb6a74b15f19331a549d0c74890ac7b85b4ff72ce1785685ee6a5eb6c66d5d19266e492b9c241378c304750953394b9faa6d7b790b964a58441a3388c7e712968b6eff7316f180a2d5fe9244836e6dbe8522f0c7b68d0556e3d8f080d1c52f23ec70378824b6329ca31edde29232f1f98c6dafd3918fe8a03eaf72eb839aa5ef508eb87f6b356a1b2ea66da6a0a8d316d036e66e0317eb229a9af7721840d1667a37b29ea1c83ea770d2e38812f39944784540618b89e0c6a18fbf7e4855ccb0bdd25158f10da97d39ba48978135fcca2dbe5f2be03cbf03dbe01b886d89e1c10393e11ed0e3a5c2703d128dbb1dbddb67a650a5eab56988d4c7e064652011c95f4adfeea570b5297226285294b0299515cdd110f0877c2af829707cdd4fae4def6dfff6bb219ee489968dfd40fc2f1015d9b8f042417c45040e3f9fb0a608b0ab33e31b9459fbab6855c4cdccb1d374b5d372b7e8857e7fcf0e77702c60c2eafea8a2c33ebab55c63ec48dfd2f2143dde21f2a9bd25c58d7d90fa12d9d047db3d6c46c16a212c7be69c9360ea763c2ca61979144a28dbee1f6a594faf50202f7c1e6ef553d2b8ab9b7c9b5fc6e1f2026a39fd00a932026a0a3f10ef01f43b3b4289d6ac57f65a125cbc841e3c770572dab5f0955fea44397ff6d994f87ec15f8b5620cdbf93abfbeb68e9a03753190c66f3e554c25a53f2c20a2758b0bc55aa961961275f99050d27cb0ac6ed3f2e4040db6c2de49ac868fdffa141adbbd6152c1ecd1a5c5f906874c554da04d384f986723ba7f7b45a38db133e0ac4775c7c1372a591ca6de7ab0eff53cad39c4830c165591a182af2b21c4eede83dd7f909777c952189473f8888078cb739e5d0c3b09bcd550f694ca1c9d98237e65568023ed0351b3701eb1113ff577ef6d1aa8499fa0b9d503fe783d728c1315f5aaea0b53058625e591674f89f1ac48b8ab5738fc265a9341d6ac25ad780a5e8289b871311b13fc3369dca6b1a909c6e5f27a0fc07bf9e7792f380b72e325310256dc5ee2366f9c94566d0048040cb76782cebe21c4c6fb7144a88e6fa2d3c488a2d02d4f66067746bb23b07c02de8029693d168ccb8b44c2066648180f163d4d5f2b6db91ebcb668d1aec0798a013a72448fe170b9a19797393834bd8a20f92d610cd2fd0f13d48b6db2cb7a35fbdbaabe1d185aa65600646561312464932e92ed2b5e661b36218048a826479797c41a5013862e46fbed4ec932f204220158851aae53b27d366626e0ebd10ce97eeb7618bbc592a885d922325fe9bd993e0142207c1bbfa448c09dacb6f5d90c9849d3351518064c60eb674d1fcc8b9d105a33fcfb8b85a7affbfe2901bf508f4535b9dab71ce61051f78db51ccd1b796c539864afab261c8c7138946e74f8a206ece13a3cfd6920fac47c88c70d5905d2efee595268e84404fba615cf8be180165b677312180becab0660496b101515fdd13222f9de0832606ffb792296805d2f5c25f9e44c3b9294ece03f976c8c913d479fdadbd198685567b9a7592cf03dfadfbcd7025c35ec0f65762494c93eb736377ef58c451663cbc8369986b721640d1ecfe136312350cca2ab5db64c5823a0028a110bdf9db33a0d3135b52367aa5e3c555015106f45b5c6bcf598f2c68d42a1cc3c515ac622fb8d3b7e434190460659c27e0d09de8e916e8ab8030cab5d2c79db3435d84edb0e20ba3d42789423b954a06f6611fb834304c7b79d817d379cba72bb0a7bd2f42161885c52d144028bbec10c018f4707e81d1cb123591def8b8a960b2d9ab5659865e7d292f6c33994d57a4f096f95f5ed49c3a3aa0f50f4a0938c16c10d1915af8274bae4e7358fac18597f3157b5fdbbdfac545e8f209b315ab9a8a4fc33e87ad75e2c1ea78c0728d9210ef19a0c2b6442675bcc8151748d460a7aaff4824e6aed48f72abc2d4e40d7ea627df54bd0ce8f8d050ac0922c90af0321c54cb6cdc10741683903bb9c0e2d946937c6ec5a84d029912d50feed1ce5b9cc6aeae1e06e643bea8322ecd52d8f680176e36c56c93b01f85f1d410a1f2feb780d151fe8bdcd8979ffa5ec71a48615ac2aa3e8e41f138189986a4fc8ddc804f2d0fbb023f7a4cdd190bccbebc89ff6ebba76cd094838cbabadd852fdb354473917a530f5840b134477cc2574547ae94fe5e9598fc2008d525aafa880cb7fff9e708e7bd079dbeab44f1f2bda3a69b35cb097eec81f16c9cebce04b2aec1e33c4f99bb154bc0e38e62bb7ab151ab9dbb79f90be3608cad29d8cdbf84677ed5cd8aaecfc22849153cc2501dee47e6356ca158cac9c2df4f0a1b5f970b84a2946d7abd1ba1f556e873c88dcd3753adec77767728d0699abda8735b854b782b5b5736e051bfd7aadb06e52e0f4c143c1231fa90a20f33cf7522b998617b530d18452b36194858e949a455493689e5469b2f2ef6a4ad6e2dbf2eaf4ede253d969e0d449d4ac4546d4f024b90f97b0b27d92b62d97d096141763c4e6898e84e806eb1020e893a346acf0a7011dd8a724fa3e6bbae90a42c77868bda1f000dc2c31bc8a602e44245405136837c7208a78389ac31d010faf9d1be924b204d62f1b69e57784efe433002de24ddd15deb8a4fd5df9e240ee82f691c43ef6c7c4d34e15d26ae68e4dce6a0b456edd3c237bb66ec8d16fd7b98b2f55f19f055cee1e0eb70f018936d8c3987f892f501245ef8f06066a2b05e93ee04e6c0e9482ffb87424069e03eb85274cce18421591c55c518cd9cc1b92841360e27e157ffaa9be94b76798805491f91a72340301eab1760e2f490fe06bb0439ab5b5ef4415bdd58a022f36e7ffa0bfb63b073899a9fea2fccffcf58b91ffeefbf0e8e6d1814ed4a63bc93fb0f46d42fc4fc51b4544c2395b41f65db93ee61cd608eefb13acb04dc1e10d62289502dd845e942d10add1450c9d1dea44ddaace39d4887f341acbe8a7df112bb4b6fa8bc38e3dbb5a6b12ec21857559a7f613b7342899b61ab62e34a309fb3f6291056943f32c2e4ab6a35b8ee1bca17fd96a312933e5f6fe17aaecda62b375a9cf4667c82950249a3546f91d7f795081255d0b7972a44dab9d4038ddf7feaea94830a8a5858c217f4ae7f80829e2f4ef48957cc03dd96d03b1ae6b59cfabb913308a89f73ac78600f747ba5c02c74133162844f0799ea676af4ca1ce64d5857043eea794ff491b2953a4c0f662f194ada615d438a1fd4d7e4ac27c2a5248e817b3f2dee39a418108958006c6e745b4f73bd2c006c3a2169b54a944e40253cd0838f051df539fffa07f2a960e6f430f238302ce7a00a57ac8595249faa9b87e62235cff233ee79921290035eee91fc67275fedb0078b1690ac2b56b41944d467c3ea0c8243dd0cc44e3fe793aa8440fa2c8b01f71f32ce753faf60bddbb29ddbf07d93b3f178c1a59a48e268bae8dece5d3c46d780a55b21696f34f0ebbfd17f35f44e27fba51273a6255433224b03596f5509206d35fe6b4f2040f3eb501640b89de0ddf79ff777a6847ab50175abf9907f0c06cb95515f61a549592d5f8afbda5ccb282e425b1d38d73cc3fa1b68b8e23f046ed0b611d8e62b4a7e2b30a8ebb279cd094389912e61b0c01321897e1c526b4d6c5d7e902a048b87ee135b467d6bc8ff2c09c9a1a721d2d4df05241882ef2971a0fe6c5f3952b3ebaa743513f1716ce5b2e70815915ac1eca77275f6f6689fd808be99e4df10db677948c03dddeccfe53cfbd17308f605d5bbfd86b8dd395d0c19f524abf0f8deb45ec939880c2bce519ba1b195bead6c8b9b9be7e8600c642f3531ca096d27fbbefce751a1c0164e19f35699bd9a67a3ed5d8fc806a63b7e9f40cca3691b0afe50d32e6fc66f6e2b1198e755df90c372bae4499ff0d48d900d94c4552c66bd450fef595bcad0c932619ec3c588598eac87c50b398bcd0c0d14f3298bd095ccb32349cad88ff0841488c668efebad6d4296b546d033679a6a51533de979017f28bfe32ed8b033890435fda2c588f79986bc71e9a44596eb356b5873814d090a75f1e86047a296e879de8a30678d267451870a12392f08f57f7073c124cfb16d8c6519776b9ef4c2ce514e1c0293bcc51b4dd86ffc91b2206d800589ceb2c1dc3547816568e4421fb34bded7182e9dcc96b7b22046439313e65ab432e29a6e68c53a694053d958144f5851893382ddce4157c616a950b112c2f5cd185b8906fd51941ccc3bba36d8b0a305a7ef5fe867822a336d418c56989a9da9e977c69f01a5576eb91e9ab35a344c04d2d1edd6b0dc2ec6db443d90f52700c3ec8b071c5192d2cd0d281fd0826b9d6e869d6621e267e5464707c66a4fa1d1494172f79b167fb50788d6776f6654bf282cc0e0c105d143ba9995f3182ce08c17239d64c67d2898e07bd68178c78fd402b1834b1c3f95fe61ef927da5c78fb5587df661eea0ce6381c2adbe0bbd6d114a95555fac5ad9c23f0f1d750b905877750f040425201475ea05c5d143c92e919b244b4172fa608","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
