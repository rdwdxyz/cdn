<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a87fe37ed4ac6e6871eb68080ef0b632af1241338de8b634632024d26958b7e5ed14b53735e29e01d5d23b75cb956098b63cf6d30e943ff13bf7e301c7c42e45f298237c78fe88ea73df83acf2d00d3c10f1d2a30a85e0f87aeb81cad93168618d2eca2c2a5f444cf37a00fb0fe9607d4304f250282085d9b5bd0856ac7662990488a3ac299defa432e9365618eebabbc377d5d62e15068047fb970ebb5a05b462c0f9a7abe07e87a1e63bd4c932370d7160d66f3c7dc53f89d6503ee56dfb97de1d778e65ff98e22367bf6e301606931ce0d683398bb6c3f43f2969d8d1425853144e5017f0b805551cf2e9d7182122ecd03e6ba47b585e4409a55107f63bfddd656ea01158367909e611252979e65e7bde589c5f48deb45a634fcbcbd8d4a73a3b0b69c3f4ce09d5870377dcc4f59b60409dee8764ff7ef5e1c493d677931432694cd00946b6087a6cb1025ac00863105342be31a775f223971511ce7539e97fd115a0429f091dc8d9e571ccf20323248030664c0886f1d1600a3874aa30243321309d31181b4b5ea01521f25034e47e715be35806a128c3498ec4c5e7b5379443721602d8fb03d1af3cd47e98e31c501d43b927269a5a8ed73742a719d2b8dd0122079c30e9074de120d6f95f19ace4478256439a4f7ec53b5560a704756a1691ca662369fff6df52c05233525f5375954f69a3043aff5f131e86e35a8ab6ade1b3f0175a914fc51b5fdcaf86294fa7bd5f4a1125d2b56f784e56580ff58d2da6c1abb71ec82d43271a8beabda5d40886072cd8338549d97e2491b642bc5c830ddd538ce2d408b61604c65f8e7fb94c916b236ec517f17f9f5bf3c71e1cfd0467a49956f4f282042d7ddb664023cbf64defc840380a87ca71028f1fcd2e14381c61e6dce4be6dc5fb46d20563ebf3eb8aaabd9f156f501c18da6401a63cf4b13cda239cb67423c24960ae9391e57cd9fefa3876321df575cf0d0180bce4cd5bb28770a409bf56abbe0ef36326065241ce8fba924252814d43294568d6713c8616ca751fbcb5132cec81333c3f6d0c663246ab2f021bf2d45f35699d3cbd9579e22166e33991c91cef8ea6e96d7375fdc68ca9896dd62c3e45d27894874d4f85a1fc2af4a36fe895baf92ba84e97c54811b1eb6cb5f619c5a7709cfca7d1210958a5ffb17cea383c16f3c1a2d552408e531d351d3179b4573e330315155650b1e00fbc785be63bed8215d5e6dad8a92b63d1f811b04da3cb0debc2235c2e88e56c21a7ec9a1f4d647693d147e31448397ca703bfbe72968d74d92f29216826632b983140cf9910e900fff2ef6a48918557c301f293dc6f04496b31afc4bce42947ba5bf06c79420ee06ef610b2a28c6fa7d7eb07cb1eaf252bedebbbbfd26d8af931deb88f8eab6baf014a09290da445de6f2d33040b7c6ca8356d03a06a7b1ff1a76cf144ced446de73b1b7f4416064850c71ad357f53d67bfb2840e828afbde7af109fa7d7474dc8843e2ac303e8ba6fabb096d72432747850f067a6ef7f631228fbe05b6089a96d5074770d58778a839cd48f188b7d1e4696ea2abe4cbe088565cf404a003c9eacc70abde6a32c7eba62a1439d957bca7eb47422afbaa4621d960501612cbc47f8416370fd0aedd006c86948699fe92d0e139a0697b07f1c10990cff90dbdc87797bd469a79188a029fa33a55a5ed987bdb2a94f7057323f492b3f7906730685cbe4db09004d69ece7481d0e32a50d152c02ca962a38cbc5b9f0c6f5dbc860732749a2ebbaafa8b8743d6ec2de8b34e9c8c27bc025bc5983899257dec6e752e61a33035fb9bb8e5de1e919f8200eca4223449bb792ce5d68934ee79dfeb2920d49af4d6e0c3312488ba1a93ccb835566724e4f1894d005f2192ef5130bf61f6f08971466a7a44840bc488f70f4715088cabb23b491b61556727c7fb709593a09d1276a616ed18cd87ddccf137f13d74ab1ec30e5b4389a669bc861b68fb7717508c813d0c3eeecbba35742261771eb1cb04b1cad70426bd60c33ccef67337c6de686d7f26f20e877d95decd674075e322e7352b5880a8616260448efc3db64cf37f3958e9303caa057b41ee947666b0a82f06c259b2210f8bb9bbe606d9a59d8647cfa6605dec99fbc3c4b2667a691bd211623fbd39357b84b369699d38ba7ec4f3161721c04eefff89046dad30d30d9e69548b1e0108dd785c769a9673908c905b5e4872eb2b2706cd530bc6c628538bb439fb8b158bacc927f5c5e5eb5ea3dba82bd6b64b7fbda1531c71e0870d54d61ce73297b25c67eeebb305bfa2106eaf910616866f90d94603f38b092596d18e3ddf58701638f180b1c53d59381ad0d5f8bb5dc951df5e3f1f7e2bd4fe88d9c40cc70d2ee749dd54b482368fd0eb6730a22b67d85398869934e72b6944ee9066b50364a86f72723e7ce98abc815edbf31aa3da9721b946122ffd10ed3cd8157194398230d63e444b1a96ec764a2dbd031bdc714bdaf4db0051a2aa9f79f68ddb9342d90c6f1a1cf6a7d6cc5236fc2971bf55cc6c70c5d8c5392c82349a2cad392a76ad2f705c6fff53aff05ebb8820c93459cda869cdc51c47f6da66e6866fb88375b5324e36a26fe662da25f2d680a9d74fb704b78374f91beffd750bc7df8c1d5c3ca0bc6ead3e1e5adf254a0ff9e41da62f0a2b4dc59131a30084bc408b701d342f0896ae750d9b656e1239003aeeabad1f82c28f5afe5b55fd3853a45ec49da7c0f9c5353f54c7bffc40d3381c69c2954d4fb7f1b87ef8aa749d52d20c0a8dadbe9625e5d16dfa8e2dc7156765e61d4e9ff03fbfd470af6b074554d525b72796407e17637e66a0005c96dd4e872a639664f38559f009c109e25727f84facc8fc4a9e5ca30a4051f5b104cd13d1886e34489b5b6a0fa604c88f351f5420419b8618a2c1125bf0705968f1ef232dc17be90a7afe6939f2556afc58479dfd2cb5e43524a2c3fa77746878a7b1ba36e16a5fcfd1f0a0f229488f099ecd771bef3818f6a02321e9b4a4531d1070c6c6ea5cd84d37056d4b27fe94487c057c92098925d9f62f97c15f81630c476d2214f120c3ed07424707ae4762cc3fcc43a235503b47e727f2b08d573d35eee3d26bda44cb02561577af527ccaa3fd4f204c816e3be365a51cf569fff5d950ab080a5e78efbca0403c489979a42596402d7b16a2e66debd3a506987d06124432a1eb2d38e8eda39ad2cc6af151d1e7cffd9d7517ec0a730dd7f47bffda2d9ea19dc48c6f5d2faed1ac22b989b050b78fb6f15b2e3adbdce7e49093ab5319cddeef5ce1688a32ad19b42173b996b72425213e2fa088e62ac9b23bcc1bd78bbf5cd0ef7901e978d56a1b0958c98f6f5663db112b2199f96f30a087c5e2127f66d908bb75a7d8da1754a670c7d63a91dc04f9fde80106387a62583459eca5b0e3579848ef85cb25a177d6454bb0f75570919f591ca7be9ac1ec564727851c0139f2bd1a61cbd5a33953be7cca3b1377ab0188dc8ec0c407f233b27ec497cb06ea2d430524980a0e155f8aa4cb5a4f9e9160182482c46956d373a35bc9b406e409effa0d76dfa90db2bfb1ff5dd875cc3bb207e2b7328efda83cea6d063dcdb7b195e7c8bbad73836d5d28fa506a6866227e767a8269c1588905ac7fc6224688615ada704b7967cac64b9acb712260f32a71e22adb1833e790498e5f8b812aee5c8a9e47509169961b28dfeadbbdb6e74f712f3b79e6b725255c7250b77d1bd30d137af077077b618884f592c35a0f6613d332de108f3e3d32fa1a67291b608bbe9928068eeb6205b6a0ae45defdb3243006ed5e6e44537b93bef0b7eb7679ecae0a056c9ccb0d5ed090dcfdb622f3213253c16c5512ba4eb0601696f3d582fc98163a2f4beed47c020b4fcdcd707a4867d3e14d13e12a5ddc8b7863cc35a072625b818b06e617b51d15459a8666a53b377cfffe6e13ff15992b53dea55da24a09ddab86ec6563e365bd119da9ae524be4dd361805be96cc880155dc3631c1a375993e92c2205b5a45cb551f7b6e6998264f38e0511b8d305a47322f736c8d4b2d0e383de1887b62fe3fa88b05d89ff95de8ba4fae334786ad5de072f0a205a46827e8dd50dab36bf65a168eacedca605249bd993cb2455d10035655ae3f054a1a85b40c823a297813fda947c66d895745acfe81521dc90ccf16daa5e1fd07fa07057556930af4552857f306a0646b47b941fae6f886960089a41e58359184b954efc22497c129f951f11c5e234cc3b755ac283a2012447924e30c25261468c9131d6450d01ea8a9b0fe943281b528791ddb9d93896288c9fba47be6491f2360c8f82705a9ef603adf14a5d8eaa901e8ba64f264d1361177381d83af29887c940f464a851653da753694b29315c38baf1adea03df196c6f7be0b3b4e3683c935e56d3db28049dfa39b49b5afd0b9c0b8a6edf5d79a3e6a95769d88adddc5a44dc7020b85a7f217b030168e41df79fe632a819f482fe9db01838605c3d2474bc17a8dcd6dd5c8eb1eac66a3b85c7179c20d7f3eb18b58ceefce849a7db064ca2bfb723729c6214941ff8c5130337a0ff8a8d04fd92f2e52b8a386040bfa3eaf0f8bf05428a3a9330e1ba2ace19d605f6df81c724e45b0380ad88d0870247f8c96940c4128d99fddda57ce3dc0e55df4a7a83e56f975a5ff74b9164d19cb261c6f6ba2f54c003cf1b8efb8de79aa1a69f1b7c5e106e6c0329f324985468d372af3ba3c3b153e1c6e9cc6e60e164bcc04d487828f54207736d56d9bf76554699941169261a76b80a4eadfaf53a967f33db6d14d5d208e58e520387e57504b55875e165c47e6a72d54dc136e580156ce50583e82f5184094e31d5fc792463057ac0dcb8bfd55e4949b1762faf5b2fa5ec1153ebcd32293c3324d3881e94d8003da2f732e397ba317457c9b2fc9e8557432a839b2d1601d8bb405583256901d36d7b3b2e2b01663523bd7931516e6a7faec33fc8c0c8216f801b18d2044674bf928df5ec9ae18ca877e3bfffc02f6f72f476529491695ea695cea1019c6c577453ea8588074ad644ffbfe53d173d6a674d3e779537a5393e3d73f59d71593fcc7a2a534a4ea0a3ac57549d6c69cef33d0e1e8995f52978a9ba9eda4053050843dc66d30a91d0df6cf2e46076745ef286f7d77fb853ac71050cce709e1b0172c4cfff8f230084ab8284afe73a028acc7b43a2e03d79e2318fc54ad95abeb5ffca0fffe03eff105a72b9c782e641e8a94f2383ed6a0ce087dbf5289f8129698edd817c7e139e8bc3bb98d710e868a10fbd1e869acd05742776c68ed83faaa27ac49e64faf1e0bec3b41f7a52b059c1104883ba02104f44e810d6780fca021384ec682a0678b3203b1b7770714f7374980485470abf8a95f75b9de7b8fe9dbd5128e43d9d25b6b64b6d252e23715d6365a37c8cd494db4c3959dcc6f36dd11409faa36a78cc354467e2f6d05025281836ced5723ebe8437a2e01895cd32f63206fc8986c65886c4a178448747171945ac9056d070bea134d32e61ef05e2c66aa9782c796cff82adb419656e54cf481d23679a393ef7e0e4ab7bffb0ed10271a8aed5618f6f4099a1f205770dec426bb8df5da8f638cda34f77729b45bc043a3460d623a2fe0f2475b8b7c4ce992776a14ed1d7025c31da187435333acc8ddfb9f37a5c30c8cbf01e126ae3428a8a6f88f55856a2ae99eb2f6643948d2059e9946bfa3c2e5526527155c66bb7d12803026d7200ac8ab602c77b35bfcadc1f81735285af54321f3edc2a45778ecbffb493cc45d15e942e8514a960513235389b30de6e79559be7c20376cb6e521dd1ac4dda3295b3e283b2e01fee6504f012dc5bd227fa65d4842749cd8a07451c3b82f98b2dd12fbf383ad43284df2ba8d568cdb750880e030bafbbc2327108e024d0e92a13ec3676740da15e4ea9cb06c2ea2a038ff604109d63c1608d0f54101af22b1e72ceee261abdd75afe81ebc81dc80415e0f9d282719977298e775be1fa6291ad3f85068cfe0b6099cfbe0853fa2eba4b10648248c78992f36343a0e236f15dbca5e07ca1c2ac334430cb4183335412b233fbfff5c1af606230b373727e5dea698448cab66c1995869ae7a5c3bd1ab8e1a5e3815269ba5ac327e15e5b3f4f5028095c946298c5e65cb8726bd5057ad63d24691525fecf08d2d9f17bda41335aed3e66313b272039583b3807b3fc01e57db0a0a654823a02687260ca2d299fb9419fa49c3e0050fad0c94091d7b595f971bdf052d8f3ffae3928e198adbc868879da5513d92e2b2efeef33257c57e5b4b3166d01fb1ae0798a93b4dd1a1ba8ba3e1656417bfad411fed0543b64b055e10e9054388e3aec0a1a334e4ba92d571a341903779e4122a63209e4349e3a6e44b6e965c2df774763e55267c40332f8070105af49f764902059f6f019b01b5585a8e10d24708abafe627bfe0d588a9d94989745034f007f1f0ed56b71ee46ff700bae2416305daebbf130373083ddacd071fc46168b465e16669b3305524724859d5ab608887192e1af1174621c7ad8723b61351ef724fabef42f0c911d4c88449ab7bd24500f16cc0d93433d5646e649a189f980748745679fcf6ae2fcf38dae5e2d519b5781532c2ca7a1f154cf593ed79cd3de7528a328d74df47bbcffa7d7931c5f5e1f51de2fd35fab18c728b98d48d0ccc2dacd64ef236a2f0d773deac7432528bd584d6d8d762672b25f4481b2f7f65316dd0a9fd569e47d0b93bc514fb1657c4981b2980b4febab023e5772488e4a8b15ef2bb4518c2e0a3fda8f07ef66fc9c47b38f9e2d05b333a17614da8f0a44ef5afb57cd235bf2aea4c85c602c1cd75f6072f798e57fd0957cc77e552199fe84a39b343ce4a3ec6c23e2a77f974b1e7111e87750da344d6d6833ec009543491db3c0d8162ba0199a68a00af78d0330bed281113ba4cdbc0d670053ec013960b87f636cc785a73524ed8a6ca17b33058c8ebd7d70cc590587953c0bdc0934b11833f83b755a48198bf05e2eae8f689cc9e9f57e8ce468548360b48b2610d4046968178cb06173086546bad27be98718af712d0f1906811edd5ad09d897e565dada43176f774cdfbfed963e814ba6764cac9a84ac2e7f691006b06d05333fc655256db8733104866cec76797f75c54db55dd5c7908777aeebdb22d7e6a1c4dcb3f44fee98133367da1827b493123b48794e202dc3431a7caa282654946b6717e2ff29ff291ddc96148f43cea7e89c754ad50066d6c7881cc54c813b4201be924a1b3d66a89e1792631f2a580d7237a06503799fc6047699550f6ee355a0be4f49637fd4b39c752c5a86be0dd971b7ba7de8f64b7d8f361a62ab18d7bcb368d7a90f6e70fcf9386e9c2783d9b38d2e471c692de081814fd721508f53b9fd6c25b9364941bddac37c44494a34648e4ccd400c075cb5ec65a0654f2a3a0d5f871451365fd043c98f32f3434447fdf6be6fe181725b5d53bd1fba66b651e45c60e63e968c04e4c2093990cef2c3637402b4327f0e6f7c2b5d50695e8035ebf16e545b0e9bdac41e290daaf39a85d13703eb0b6a7b35b56f738a282db1ef7826c9b586c8bb5c3dbb4ffb680347172ea7df4101799eeb3a67e5f1b78ff9cdf516c2bf9abd5184f672cc5372405f4bcfd4cd799f69103f8a0936aa24b8c3263e107c16975f37badff5f2d3e769b9730faa70bf2e53c127ecf0568362041bdb335e7385bc385a9859c79d3606476a5473d1a398391120d615fdf39e75dfdf57b9e9ca6702d8a01939dfcc82761170110b5926743c424c15fb5daef65167cc849d9c029034bfde2b058a6e731e0198e64021004f50feeb7fe4e19f872bc4bd84981e3b1090633112e66283e08cf9636e473b012370d0c96ef52f1b08ed0d7795d8e3c9d67dbbf024a101726e495ed9b4da4d7fdebaade48ea2c1f960627ce8ad56746907fed6bbfb58077390cc4189075d363fde6cf558f3c1b40b0d4a0a3e0b7ec39c5cd3c5d1eb71f10008e18491bbb922d2d55aa9573edea04669d82cf6c3d3434cfe5ad2f06546cde20c5b97c04738de45e2fd607347069aee65f5d30d4697e4ec0f23fb9e6a0b5392009f4a636036e43324ca3d4487f0993133eb42da966ed8d76f62d69a533cc2315c08e212cbc1908f17dbf62c461acdbe5e3956fb96decb611b7335f4016fced1720c2d6b9c65afe2c87f245ed981aa95a3c9b3b797153f4c77246e2481ff750afb3efb4fe3bcd441b36e8cd7ff86a01d2df0041c974f0290cbf2bf34fa436452eed34d49604b2046389d8306486591186120e9a0e757c669e28fec86f74cde3aacd1acc038de42ad6889da195cc09bbd7cc9b57fb175082f975211117e76208be6dbc312990e11e32761ad7b9863fec925a4b190cf50b381e3f1f9f1066f06955db5f41ff0ac7ba56584d3ba1855e45ad795aeff4b854b7755eb24962eb9ffb4bb3a283852dfd799270f31b5b62964bef8e3dc6e1ae16a964a5bce0eb9de96e8f55f5699808e78d38a3c4d3aca8d880a188a15fd1c946854437a9d7ac42b315a978553555878287b499db251d2bac63e36e33963473e2b50a63a480dde65a69114bd9996cf3c3765644694209b636ec61a79f7985f94933253ccb03ba1ecf7a5e9fe63aeb31e00c412730837dedafe47fc2553e7cd8ee2e8bd8685eacceeccabab620484b0f97c6ccae83c79ec9f023e7893ad1205a57f28c3ba821c27be866da0a66901f79be0c25d2c6a240d8e853a8eff1eb389d7e7f280a4b0f0b96996566b58e236bfcd8fdd2c1d020908dcfd03c6939e6f06fe95d806b12b4bd6bc53d1828f971f5c1c937f2663aa47dff82fd3b34b1923d15d0bd16b11c3191d182044aec6800e7add6a01e695bfae481161c72dfa52bffbc8caf97055acb780bf712d4353cd9cb66b42f887bd6912ce097c940c61bdd382e80ff2dfd92e85b4333db30d42ebaf1d2f570e74e745fba58529dec758823bf58b9989eca92ae89cee196e305154f5bd2806c5aed471b24140812c9275d9cb31277687b07288a1b0d6fbb649ec852f1a6af55728a1564f9a5b20f5ba88dbf5714ebcb8d77011a2942d053e1ae9d3f3a317a4aa33fc1be469347b979184f7f31c10434d54f06350d23b381af3a2542c43bcb1184435a9cc0457bc2d3a53ff804b22d1cd38cda1f8542d78e42bdca5333411ade2d2c52c26c275ef4a2ae4645397525de4319cc583f3b50e9608f79f86fd1c6cf527b838bfeff9e8327bd1acd475d85d28595a16b8f3ff342c75f31c8d71b1eab67b2ac77e34239b622a496205c05f53ea21dced40c2ee4b2b7248a090064dc756f9c85499361691fe119f5d5c1ccb96efe9ed0c93730010983181201c10663b3ec8f937ec7bb98ff1b795453864acad10026c04717493cf29afdf8282f3418ee8c3499c19f820abad37d9f34fc7721d45c40ddc3261b158d0d8de16d4ddc017c2ef9be190eb005a3ff667d7c42357ce6de5dc0c935da4fec22c20a54ea5b301be741231cbd8a3c754392a3d3722c1e4027d8f2656db78d0190220b5c4ceb311fd9d5848798d49eeddef5d6af4be87e2e03cdb1da545e9b2c1b4e5111dfc36a51cace9bf1cd9187f64415ce44861a544b160d9a3ae938f194206d0c0ffd1aaf3b03fde35e2f293f8405137f63ba18a5fec18e8efdef84a2e42a08e0b51a3bb93566951a756ac6a11cb1fd7a8101d685227554fff07f6fa7144069f68e3d452d33d65eb95070f34e272b26078897e178702ba56f9a29c05f1a121fad4be8e2d961fa835810c8ca2fc7fdfac86d23fc8f530c9e9e3c2421a2d49a78754327d82d5f568c7f5578a07d846719d38dfb9172cb38aa525556502e836183cdf129c51778b3fa2576d29843289eac3bb93ae1f39f39ceb1cd09e62ad3bf7f0c9f961317e4857609d0aece4a5c23a612e07df172f8381c31474a1ffa518a08abecd3847c0b33370136ad27c26a1b49a14e10424db9a3d0d9a0bfce9ec0cd1878ae3a12b948cfabd6b74524fa494262513fca76ef920a579ecb1871e600595ec69ca7e0833d9710e53cdef4eb3923a018dce160d56bde2d16ae737871bbd10654e4c936f163222f0e1af4ce88a90f97d939390ec965f5c72ac5f7e0fe29b0e521ac72541e1e7c654830a6f87419b9c1c02944cdb8c73a04696a059f1d2acedebc6d50c7c79494a223eb21e491b983c475f1073cfdaded34a9f8fbea8bfd444c8398325902ee5f04359bd01b9a384835c716d59a6f67819f16cde0c240a9b5208e535680c988974aee9d8f12d602c654a721d394a3418153678de08ef8e0bc6656642f064375513ae1dade307ea2a184bdbdfe2fa24758707c210a016631e36fbf28a2ddaa2d177573846fc767885e6fcf7143aaa98ce23470707dbbdb27582af85101f22fc22d7eab0adc2f4a45419d5b15415d8f1ff0c419a40953f33739e1fee45ccfd53498830cb147b6beda4f64f5b4e02746b3cace1ffd2ca566c4dd35c77134f66f50b5e932a85e04b880c30b9bb5506fb2b21b564c71a93bc87bf1d02f6ceb47499ec7d84d8adc6ffd6f9f1c5a5d510f9cc751d5277d2c0625b7eb573219755a482dbd4a91ee0b0d9605520ad969aa4c12baa1f1292d5da75d5462d6115558dbb6deab0b845a1aacf9f8c7283b2c7e5e51785f42844e72e8b541cebcbed7204af09ddcff646ce5f2b121c24966a47366f8b20bb77fe0080ed51ea363b0fd2335360fa3b1efe623a4218d65913134ece4b4a47071454b093252f69ce8bd8d77069db94e9ff9b3e63ae8f1e50fb65c77523e261907b7cde63c76539ff299b0e8708d1f260e14af1e726e3d41b8088bab1489c3916164fadbaa1ed14599fa6a43b36b6999e097f87f7df01de6705c2492d6a83a3d2976346855b9095b01ac18c259bd7d366b942d23808ed69a9a1499b78a550bcb9988c4f21e8f3cc506cea19cd28293567474eeb2f109f5894e450a88167aee859c78beb2d1a16929c2db98b7e3342f32a27c132b1f6cb2827111e763fadd6d59729c9c0c568625c88dc5f9b5b80a7e8a3a7cdba62a2a38f9f6a1df95379de42ba1011aaedbab4c94b07163973b7dab58f40527c1a6237aa263815b231f25d18b94e9f67425d26f42670cde1f1fd649bad1895b2d280727cca4fb1952be06df2e4d7e559a7e4eccf8c97a4de0ce9760388099f8fec0bab75952f3d1519833ad2e07d89f307dd88df69b031451227492198978789f286953a753503ee2b765954fac30d7195bacc1886f39653b550b65e7e91fc1b5dcb7ca277522659c457e9f858d46b6fb77046f4a4b70fba0721529de531067574115755e93a128e9f71a1b26e35177f9afae024ac32df66fcec8e88f8acaff2194ac844908606a7ac2d850b422cafa42fb14a204bea9357fc2d49b8f206154d983a94d0f88fca3d1d823b08ac5945fd82f3b57b494367bb99579bfbd2394325c9a0382fd2d3d491837add19d3098adf56eed507307bf9255709d74f5042e5970144c6dc7d8c485d7810438e2d5bad07fe8b019c2279f974d9efef250f52efd327a5881da9590ee150b2c5e6b910d3de0c6f503b9692ea282d9d904c2ec282300a692f3993dbaa52552f3e6f522613c2c620dfcceecb60062b0bf4b6f402e88ffba50fe37dc12dd40a9d20e548a03313be3e1fe45ae0eaad36de549a9a547244ae7dc4ae322e6e401423600ebc2b4e1e80f23dda06c92d446e524bea907c8f865fe7b2af289e5e9e06a4278ff098ffcad18d0a484af2774559d353fe989fe4a8d4a2e25c19e0cff43502b0a97efd8d06e1ef609dac729e7fd56ae153f9b58f649513915006a222871ba47ef4a7506cbcd127fbdf34115f92c4a987089b6af8c13d7a261adbeadd05e141084cd4ef5af9daa6cee5b7702d2bc4ca1e80bec837689d8b70af8ebc8a9efab57ef9b8117f3f35e4b046491b506ce2e69915c29289523c87e75922ade70f9444953edaf5bb3389ab62d3434a7afda0fd57c0ca55c67d4b91d4ed5bbf708a1f645ff7ad11808cd39d4508706ca1e529f9bbb15def2e7eb1d6988a218c9348b31833309d09cc4a41500ca77f22efe5b9e8ecc6828bc433ca9f3503dd294b048f4424a25214f3075cbc527072541236c5feecd88820278403544e51579422dec623ca5741a3fe51c41d03a0de579e2b90ea02716e32590aaeaa64dd4bdfed5e1a015bd77b1b760d91ebc59555614e03a5794d887fb9b00d138cd034584494de3125f9c171a5f41aca8ce6de68bb8b2563acc1bbb69f6ae2bd9fb186418fd0795d964a615b40ad74bc8aa5eb9a112b3bf87b84547bf02fd8fc0a61ba386c2b56421b673c4fea855ccfae47fc49f6e0e0ec79f0360d01da31360e1dd05c666516b2c36d2e35fd6435a2c479481be7d060772646c2390ca809c41a523bb7095ac3ce4ada304926e675728738e5b83f185d1478828a6906e70f9b26e5002f956725862fabc95bce634d6d84b9dbc2e656980c3a41c8770fdf92fb8c627cf02366033fb65771f81fc5e50a2b06c2b5a286c44d1e76efd5943d65d43ea2f654b628d102a6c61f6bab94ac566bc3ee1539a4cfab372e53ffbe0313b8c94eb5ca60306015142164da8bfa23881a2f2f22a658ba9506ba5efd516d907a63368ba87cb0f0b37c4e9a8a232c749686a4d3caa1fe244627f16f94d86e4547bceebdd2fdfa711ec063c7cfb0450339c5a6c5864001ec15cc71a821d5299294638030f62321acce73c828d36a7170957e380c5fe18e7a0feac750f6fc66c322595e1c84a69e890b68aa93d61dac9619fe110fd07bdc86b9c5759f901ba00875769cf0e688f8b5da5b1a240dcc640131a008279085f0fcf6c2f7667443fa671900e6e032ae85868bc96a153c97f2eefb7d69c937703c49e38b84a8149e68503477b7b956a603b37f72ed6bf0689f0eb5ba1efa49c14d4380b942eba8bbdb6653a5f2fde223ed0ca2befd432e720c6b23686219aac129ac896d4a4264c5c89f4fea925f30c08b88f5766a9fe06bff721ceb2a93bbcf6c02b8a251bbd38a0c2b0f5b1d1e279323e5961bac360fc640d61d9a7230dfb79c9327beb3ad2c1c5dc6b47fd5ceee31e7ee9c73127e8a62c366eebdf1e4ca2725a3a08ba33f803cf21a1212c5c40413b6e1d18dac3832d4bb86789ccb238c355af6034cb040236aad580bbc3048cded13aa6a283ae6ceea05481f06d312985ec64f499c97713f9b8f6da44b34953370105fd3bfeac7ad9f4d199c0a63bd43457d02263a7d7dfb836e2e47f0c3b74b1dc918dc36b248c68b3f78891a57b432198316ef2e5027a21d20c44263a50b96d2204dbe73b216e4c4ffc38c81116c5c691b7bca2ff7f76f99c2f523a1af30e67f467d391818217173f83e102183ce9d77db4c2ef7d4a61b78ccfb88864b4ac57a9ab20d12cc08ad5e098c4270787df8328078f4979b290adb973d62030ce2a807f7006b2f2e99b39a66008c918d3d1bf479926046803f473136dacc16c2a8a89b1709e41fa76197754d858f6ebc7749a235bd16b39899a114c710d621e0d192534c7fdf0f7529ac3fb9d2323b97f059f7d7822f690593dd356b90c0e6a06841751c8dc95abaf192ad1f62ede669bea021e7cd08b54f2bae94cc0b4dfb9469454ba994f2174c709a37640d5e934b23ace984bb9350944e7726edd0fc0e498c471d0de446964ad0aed2b869a9ce9634998ba3a156ac22635e35cc904591d18ea82bb55b51b6d9399d11d96306f31bedc8d673cc2a92c970faf902df6335062639c8682e252a05d90c60526dd92ce15738eed076453acdb03a309ed009904b669b3c4f67bbb2bc359b54d634894cdfabb8cf6e197113e2db073d0d0cc6d66dacdde966f3bef3ad4db7946c9cfc4cb5820167c3f635e95c81c712dcf5ec69d6eb91c305b2526ac9b44470cd08082d63d90e305ece9d00f939c8839fb3f827f9b4bb8ddf980636d2fae23650c3c3b28fef42816ccb0d8f5876a73cc6c95f5b3d36981c8866b2be10d978420b9ad76f1af04f216f98423ba71050d11eefc828b975ce1758f2634b7a8178688fca20f19cb8894a871f0b2b23fd282efd327a05b22b50a26fac13c89ed280289204904f52cedc38dfac4204c316631ffa9dcd279ab68c22b046b0aab117b5e6cf479b1771e0fe55179ac7b0321cd27a7b4bdfa799cd726bd997a8e5aeb6827dfd470bb5ba10f6ce41806363a63d571981c5eccf36fbcfbee3c36cf64922eb2f5ebd18d1ac734d0de67636be8750d3e4a6a2dd3d6f6b64537c0d77b0cfa4d968090e5ab4f59e177cf0fbe3826d1903882a4f461e9c704b510f6c1517483e81d2838227eb05bd0e2e45618d316a6d60d16b4e37e2c131fbea157f13dcc856730ecbd29734646676d92bd6c1536f3d38dbd44f32f76ced0ed3326978338612589af0f58d1e4f0c72f7d5730b1ffdb54f5b17eb2037f1e3b90e76e01bfd1ae8438af3250cfebd297fe351e0e372b555997f9564cbcf0a28e5ae5a0a53486fcbb1948b826fc8dbd372fffe129d5dca8dbf003669d16f225df31d0367a6f626e6bbbfa2d381302ca48ac542b26f6fc869b9cb1b6182dbbf9a750bdb6b6384b9918453197561ad58087c4284c916667be0a122541aa6304e1943e50a5e530ef326c969065259cec75ae9f7216a76ef5662864b465d82b412865131cf1317257dda38eca51a796d2d3e17b8026eb3c27232bcb4bc0609d537d0d1ed5dc7aa817150207e3a502d074205b3fa5a71c3c6110040de13e3b5e2add996944959cb729e365c7ae3de9bbec7c090833b75899c8781c8b4c4314176e431a2f3feb30ae9a9b35c976a0e86488a4d3b8bd031eb4c5361c5ea43acd87dd4f674011d9a6b28d8b239bf1afd66a47e410dbacb6ec844ab8d4d6a408fe012f2342cd6f525b3b5951558e775d3691557cc520fc8c771e3438b62ed52faf834fc2cbc043996cef83a8c9bd3ca6ae1f28f734f866bccf07488fb20c7bb3f0d4f04c614b5c16b0cf68dcd1f844af5aa2db09a2d841ee889a3c34463c00d2ad71583082ad11981090a56","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
