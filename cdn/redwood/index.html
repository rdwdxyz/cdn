<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5de2aaa388a506fa101c44e0b31de33a9d6a094d25c2add04f633589860831b0b9c0815193be8eec3db286021bbbfe4ff96eea255599ee7466214b5c608473683489f75911d30445c0e19c0589399ce66cfa22c6960633d493aeca8d29e777f3949ea1834f165beb8cb5e3dd69fd27a87724880bdba493a12b6d7317cf6d3ac7c234eadd8fc991a944028c3357e351a61afc9652a95152ea934a566356c39f592ef81a6b1e96395792720ba941a0935a3e436a501a2b7d36793ec3bbe36876cf5cb6973ff7b9b03b10ae4c5397f1cb3bfb25efb289732683ffe98416878aaadc13b4894d9e4d74bb67b0c6d9c705d85e2e6d88d59e0bc21aa2bf0cbd2c968343f1ebb75194f6fb805c4c816d34bb3536b7679e324af466aff761cf8eec0fc9f113e078282523a94d645bbb586af98c4bae7e71e002f810841bd5d6104bef24301966922cf11eb93561f31f13711b755abc00e491a404fe749982506ab9063bdcf7824d0e7484eb74f1312995e18531af5ae288c64cf9d5028175fad09c95ed24a2ed17f97dc4e5122056173a0a05accc4f55300f6aab24bf87cbe535dfe2ddbdaefb51d92040b8058b58bb729c962c17e43d6940d7fdcaa4374692f5911dca1c45b31b5a697ee8bb1dea5822e9f5cb6ef38b1cf262fc7879d4bc05ecea478ed093c405d5305a7725549fdc993414d01313856cb515770295fa274b36664e7542b87629aef468157524c1c270cebe9c361f95b00c4822199555162b8de3b2e75ca53e7b9f87561d68190998c2635aadff0565e9ef7992aa9a71780901b7f6d5f023744cf1e24dd8e4db45796abb329adc39869eafdac1aab4db0f79eaf8babce02886fd347115d6dc2a6d9b8318d5593ac7d0215b782e1bc880de099659c664c953b5f24f84b20b5046ba8203b37754c04c083d32da5bb7d4972be1b36d1f8b1c57bddcbf236a35b7ccf53db0c8452c8830d62fea4e9524b544b0ab27490fb2051d812bb336ae4095eae35ee61bf68e73432ab102ae4ac4acaf42f547318fd823806714c43b19ffcb6d1728ef915749bbb869d6a0ed03328e789d7c89049051860ae61591291de7bd85b71a9d7108a54b0183d1659c296228a1320fa85af3cce04ac015298a03ec65d327106a1e115817c28cc9c04b482824476ec0927ad7ca6647ee5bf3cca42e0b2cc242e54ab3fd05bd02d36df0d40bb4f66eb4a7291a0f89db4e5845c1e39e7191aba740f2a2a85bb489cef282effd0587a79e972c2448aa9d1a48d7d2312004a909694dadfdefaf42ca9100ca22ad8a3463d0a1836b6b7a661df814c13d6ae67acea2ceb027daed8748990db8540114d540365f6af96725326c30336cfd69c6e13230aceb2880fb19ecfc69461ab6d0cd386634f49597c0c0a4a1f42a49b37d33a7a3ae63917b2a00c6f7d810b9ce8bb00200b897fc4f8e6c0f6f2d0c627af432d073d2c184fa8448ce4d4981e6af0825337530b8c9cacf9e15f534ab2f115bd333b93dd0b0ba10a9e9e63f7e9a4ff0d39f921897588e6ac568fdfd763d4e07211b8b0709f6d08a930008e28fccfaee3d68bda9d19930a179206c799dbb4833df100980071948a5073f1c270913cb690968c61df30cee8e5257933cf0f0fe683f02dd89c1bc90744d5f9a5393514fe19533c11306dd5c347b85ef140042002a830f55ab42b021d352178aaac162f1ff5838d7ed1292ea478bfc6c7ded454de43879669fa5260eb803a58e4b190e4ed91f97c553129ea9548f131c39677a346f93656d4d1d436ea79257c69694ab0f2987dcc9e5a5ccb898857a239e2cfff94a3a8eaabe6ca06dd25011c4432536a346300c5950c9394d219ffa9bca9abcbe1e4de57012c6e3e733eee5f6a01bef0a61d764e3882b1ae11c519da634b5592a606b4a2c46e0cb22f14db60fc5560a5826d5beac8f5146014a84bf1bbc33b2b0a1b24e19c009234ba938b919c35b560f97af34109af81a632369cede3464a3580ad02b5d30c94d66fcbec9d6e6396759c07ac79eb26db7d2e1e27eef8bf30699602b4a7c6239cf00d13aa83d15f66b4500731aae317898f6e2a0e30ca302daad50cb351602d0626d7e6f2332bd2bdb8da4eedb61fd3bae055c07d94be2a951977b1b85ecf6ec6e69a217dbc915d13cf14e050af45f61a74f756760e1153da5357342c294ce5c68d70c77618e47215da33780ff43b5cf09504a8f5d4bb9c2c3a8ad0a5fe37ccf6e6eb08b7ad859196138f1d503ac1a2383bdf4b9a0ec346c8bf1f7198a0185c1cec928d6b2f29fa55ebc1437956efb187d0bb561c00364e10fab7d5b5bb114724932e3f27662d7a4c75e8b84da2b609a219be69e1e4c62f01ffd7c2d4bf26e2b30710aa81b7d349c8c29e2614049b32cb4e12c08eb2269e2263bf3c1408ce702a772459a2e3c3adbe98d8dcb221181ec252a57dcc773371fa32518bca7874842ca51ace27682bb97534556c3da03bad3d4b58eae9f9595370d5dbf782ef4c7388aabbd356cba5ccc772262834fed228800a647d3b7a9bfd3e301b06ec3b4c96c880fefecc15d5503d2274462cbecdb74422c880c44b4924b9fc544216a612e29a5e1725b0e1c3fe4d967394c98c219b65995f15a47b598b71dc0b3b86d91d359a438fba92321a49e2d406fbb6804b8877ab68637943206030dc7df0b81bc262c62f1c8f146fbfa5ad1bf11aaaa231ff8030ef900e0d5cca0beefb1f109afc056551a69dfce7d4f81e9e00d4fc94e7879b9f2430688e9f7512119088a4970500e2e888828224ccc38f2d499cd5cc01aaa64a7c0718e27df4c9e98d004393fb2a64314394d8abbc1c8183d90defb9053fba076ed3c451c3d7972fb88c74d90f1d10ac5feb8ccc9979431822ae6e3ee8e33173be7a972d94f0046fc12098795fca33dbd34a8c851067404d35ab4e658c9088c6bf1cbd23d862b928489269f7a14a74928647fa9342d40b5bf17bcdee43a3ab16a8a8e4667745157919b224533ae3364bec9a61e6b038802b5e21b61d4ccaa906132e8504d279c0ab9f47b2e6407edcaccc7b620432acaabe31c33df16261389cadd3a4e7d31f785f4e2fa3f4cdd1d98945fc37c9fe1f4949a4c5146001bae6114016e61e9b7f517359b454d4938da903238476cfe96ae36b580a8dba0d025c4dc0ffc40086b1f13fcddc5f4251cd9ecb4a1c0abd3828225eafc6067acf85a143c03d68c8b9625ce63ffc70cef5a09861c568b12496eedf0768fe97c74aa84ed97c92b6440b5b9df59b960a0129a6b3a58f340118f986961b43c06037851dd9395f62d30cd8ebf61ef23c17a96faefd40e5625ecd833632543945c19b2dcd3d697e93ad43f006cc695233f499a2b48fbf3a8228d24148dae3d34f4b86726245ca5499978b8c751190fd523541805721f92c6e059e34d74e1fb91bc69a75298807a2092e9856ad7566fb21b8bca074374ecd1fbaf2159eb2acfa04ea7f1335179c859cee36f80815ce7ef756f8aacb84444f5d7a732c4caf670690c53d863a60bf8f0da1839e9feb9ad74fba5cd97fa2abe84bd25409dd3616ede6fd1242217921b1cfc330f842a0c33ff903a66647e1e0ba1cb6921830c1c50418fd139c1a6570f02946acdcebb8a6c6df0d1d9b7ee02c03704b52e26522399d6d9f90fcc1277b77e72bcab13c04a2c2a5019799d3ae9ecb9b63a244f66873a554bf59c338320753378882e2582b3a4dde2a90e40246026d8671cf11206dc81da7bde75716a4f114b62ebcf5e0cd46c56ab4edc72a0eca638d5cca1437c70a2c718f1a2084b73a1195b45015788d1a80d0d95e55849e1b8400839b63eebf7cb8e9bb30e00d74309e15664fd91179772d9c18768490bef9374848ae300efd48706dcd542016e21a4e8c29d0e3944d533f83c929486fdb072bb7cb378bed2a3e0eb62f1714b020dbeb0bd0f86df74d2c9ae5af673e9d74089b55d4e44e4992bbb5e99d17f6ad7fed7733a7c7544aed920620e81ce125fffd6dff1ae39a94a89c82f904a6ba045449e7a82d4af7568e295518fe801a82ddac2d219c003d3eb6cdfc0802f4c0833a167a03e8d5356ae1bfa8a9e0e944663c7200d5f26411addefaa01da93926370fbb33e48292671246a8bb8c43619a9b317f2a6b03c9267ae9aa414080ea8ec6eab3e8a7b27e512c4209b23565dd2ef4d130cdab6785ebea8f1c07429af07d632bfc8a4b2d65b56c0c7b2a897464d5c1758ab5d2565166a6ea6514c0e973bf683b27da78ba853659f17f938cb6d931b595dcb7475c9aabc79fccab36235982ae93d471caa5ef895ab8683edf504fed2ad8df4430bd33dd4c55c0304a32711191f32fc062f3f758ad3557d57242c1bf56971409d7eb667d16e961d8dbbc8af4860f39054e80e1863f8abb632a499bbbb8bcfaa587a6e3a3cbbbfd204bc505c8ca66248014b714bed3dc2d490315b1297d5844a5986c7e5d70003548b4a746dbe3eccf1da9158eb24b877095e90f12acc83db5d0f3a0e66c31370818a421635fc60a7cc58d35da53ae66ee585ed21cf427520a3bbb7243b1efbafba16527cebb4508ac00a4bbd16d5f7eb1349780ffa3ff30027cd19cf459f6a5d7d74fd85d272f0e1304cf3ef407b66862d20623ffe8178bbbe85037bac31181f92d8560ec6d87c1e1644d3929ece41edee46e0b0119a5ed5a0f8da7dd7d845d237fbf6646e2662ce66bb805dc92aed460fbba75d9b4833c05da581e6c156758ad47ef10d1c8b6677b3605e4d83d916fca71cef3ae9012cdb40717b35aa5319ca94d2bb672b880f91f3fd6b7f1868573e167a806cd85f4b70b6ef24a1d7415132a786c48873ff394695fd4f165f83b1d61e2c3c685292d2dd8030676daca074a44b89935381f7207352abadeb8a1f912eb46001b98762a8ef950e11b07650f64037fee5fcd89cdb83fcafd78c4fbbbdecdfdb2a68109dd10aaf3386f6c36908298d81bd102a1238476cc7268d88c332574c33b4c00e929d04b4ecb2937090f082846343c18821d7d42a258a4d80aa02bd3d0e63404eb1d5b59cfe21023f850c3bfeb74ccd77d551a3754e64c8e4264e80b7710f18cd6f7f3b1f3899df36e4a9563257e5d6b8d2e009bd0aa4279ee214e81d791a94e7b57fb4422999a944dd39dfdb7072a34c2f5d210002e2b4d24013f1ab9a9e55394f39547de2324bf3f2b8f8fc31d19a30cef7611ed198a4ab5cda4c858bbe5b617c82aecb55961bdc7333bd1b20fb08b3c5a81b6b57eeada505bbb86e93fa4d9980fc60c7dca463e50d676de9e616cb49eb94c7f3056f2421b880bac78efd65a97bfc8d4c27a161f2acde220bfa13703cf6873dba5070874bc29e05a02e6766b8295543cd6d105c5f7071c4d0e2a2aa25ee5dfc7eac2c6dfc58ec205e89142bb0cda0b0568264d383993925f03aafbb118bfc3188de62deeb360b9265b14c8694e421b41554b7e1bb54d0088b515e55eb9abe76ab0aecfe9737908a0ac126f61980f87b0b5677d14a7fcd1b459fffc1ec07ab7e08f074dde2273dcb52b01555340423a6010b8f89c3b44d6c3059e93246aaec96c9afd7be68ea1616cba219fc3cceef5fed02246c3e5dada24d8ef84499c9f807167f0820a7b5b1ae9dbcfaddd84e19f81492c81cfd3d9e7c38cbb3305ec536cfc60f8a3faccf0fe42c309fb1caca87e9186e6f307aa6d8f30dcb0409c4903936c07eac5056f0e789dbe78806d40ea81278ba0a4ffab21e59759ae6d62e2bccab82ca4d89717f1954b39e5e6f68ba3df5851e9dd0aa943ae9a261992c05c86a879bb963232bf692886ca13eaa20c21a698da129810723d55675b003f916c4764a01cb112c6ca4baeb98e516bc252ac22c531ec0c8dd528a8455000286dc1573b6fbbbf6e1bbe6cafa359376cb5e679aaac8d5b645b22bbd1f9607fcde1eaf96547b05e59fe44262b1d5513bb67ba1d957c707169bc4c9ddc9495345a58e8b0d75cf648d8caa2a9e77b2987dd542c1b788525db8112560eb02e41a5b9f4546d3a0293ae734c79e0a320e9c7e2e0d81d604eeca7b2a9458ead1ab41660cea76078dac777cca61e481d04dab147918bfdd0926456a4e2540ee58afbbdb0c5279af617d6747f812d1a8a37d1b6b04893272f7bf7ec712a3604d6ecf5a7492be0008d94145058599af0a694ae79bbfb6605fdc7069f2f11e92499f93c943cc0262e8bd234ecbe33e3fb8348ac3a4f8ab2dcc0a3875ee955e671fa228bfc2331e73b591fb036b35af2890d99968fae67c70b3b23c426873b37ab7fc8f8b031c20b12d217f157f4af0cd3c9fa7538a86922c5c7522b4aaacb5761a868a7273b5c2dca918c614d47c3ef559df53574b075faf51930915a0d70d6561dda495e25f7db37723921c437d2c48a206da556aa0829b736579c4e984d5f2f6d3fa0be8a5933fc4e4bfc4d5b72f5d68b06917e10d80da978d302cafb009b58f9df8e5265d148f45b704e7b90b134c21342572cbc273677a2c99902873ef3c50e2bf2e26ec688c5c045b2d3dd61a58bcc8af4df2cefc24460e3e0a1be6ec7e09c08a9df75c8518b88f5f2409cd0c69045ba86483ee2f131854302349bbf9a35274b70fe3e2376502f950b8aa6df0c9ff4fdabb56b02edd08e32fb297c0403136b7148bdd404c94f632a711126585478e03b13b6e8ecc8400c8f9bcd5bc497ed6a841a20c7300403c5f4eba8ce5c4fa6246824de86d7cd5135d72dd3b84d665fa04138671170f94d521456f0427ae9d39c8e49b937dbd3b059e8e2181b03567160922f2390899e9edbb22c5d8c713b6956def7c5bde39e5fb59fc0238ce9d9baa083b92fa09ca69ef2a48f1a5c280cf2c936d409c642782c5f932c21c0ef451e2aa9d7a10e1d62cb04cedbdef2f419a0fb30e6bd08a8cb3c149c0d9deacdd40bff20eeb5cc4b602b63c17a262db7d0d3ac6e35cd249c33bcb28880e776b21c24852e68696064bdf739a8ce6209300fc1f66f654a03bd1205d17a2c116f7cffb8d484b571274ee24c0bd3c3aa5d6dd86e6b880aa43391c1e40d4037d8a9308e6a67be22fd184bdccb3ab0d219bfd42a419ef32ad5b3cadd6fb94edcb393ab91152b802d6d7ae63dbae0df48211dbb17b54e065b17152a93074da33af8b70ef1eb4e4b652107d6235699620516a9dd2bb4f7447742d54d5212af669575d5e82d37b2936469d884f0e5d6e833f7eea38b9690b79b824662dd0f8c92a2f100bcf7bf99b71b172da7ed160ffec6ae030b719603b30a1106e06013f213d04e08a3414e4b3478e32941232291da065e7015f60c1d593adfe74d0d7c07dce1b1f1c0c928a2f35f0598f7c8e56cb4f18f7989c48f1f42547e499c255440182949d902d66d4efa530f0483b27c40cfab464384f2a582834571e2c4ba2c1fe3ae7171ff838a5eb7203f02f29d22e7e39c5b0c5b209e19dd4a13d0df3adad69a92ff642e946ce19d6a01e9044781b4d29cd5515d37b14e91469e7e5af345300ea7d64ace0d09399df46f23b8741ad2a87ecfbf74f93bb0c48c979bcde9c1f750a73e86f4f80720e4c6583d63a4ae97e7f6e853231b346047a43fb3244aa47c45392e0056f6d8dd68b0b7106c8a62780a7877723ce3bf748d82d3bb890475ba0c2fcb3043ca40c3c6287f012d9c1b5149757ebefdebf29ddae69a889a2679bd11f6aa036de65d3027cd5581e7a6aca0b63e15bdde8789ae82ac1b1c2f674501bd087c646b3630cecfbdbfbf7d7ace65b2f7a76c551dfb541f27ac337809f26e3ef7788f5817d0624e8015a12e5dd7787ee816f81c931e457d89ef72d0d141d2e5153ce26f5d65fa934853f0ce97ac9850c756fe188df5c330b0896b91b10afb4e4f9a4d50803c0091a3b1d16ad2ff5dc676291afe3ea1124b9957d287fa59d185045e5c0740f81f905d27d931bdc22b509ceb522073a02167aad2374096fc00bbd0e4e177369fb33e11d23fe08376f0ae540a5ba365c9172f6138ded9788b3f0b4ac6d3941bbb3bb462bfebac3f0e9b52a47034761ba4d13229b601f4de934ec19808f99ff531d036e78744adb576b7a6ce98f0caa219eb283a7a55b5f1a54afb15d3276438d70f96a259087d7dea8bf3cbedbff1562d2b3ce61024d610c868f073c7d3a140368eadf69e126040f67e1f0ae64bfb3aca84ccabd8e8a7935cc710c308c8d9d398a77119fdf7d99e11584267fd7ff458e4382297750c91cf1049114f07ce602bc5a3770ba9435cd5a3d5fc8bfde9bdb47f1f921865bd59ce1529404fc4956668d39197af91ae4c86068d0a7fc2d1d4dff71fcd6f33b96068c71e351ada5e7cdab719ed6859246bbf4784d9c19a22471826d276019c6d60a51bfef541d6e594d4954bb3d06979efd835215706aaeb271b33426bab8da97e691870462d219dff9d38b98af4aea87c767b34b0b689d7c2fb512e03d8ab23439c0472c1ead1e36a2852fee18e2d7577c0bb7c824588797fe8dd58a3b6f803f55783c405247543f859b0a8f217c2d8c1d555ca4fe67f589c955ba5f16c4ab55f18aafa8b54099d27dd7dbcc10967f940f0af7ec3e264f1361f663b10b62147a2011aba9bd63b778a9c4073080045ab7dbb3f4c2f25a8f2cf26b141cdd2ed5a3b5dc46d24d0c32b3213f8dfe6a8ae13443dc44e51c3de4295c9869ee666af3fee467587bd6a4fc4f29f7dd03b617c7df0728966fa3f3cb6438de8b6d22f3368cb8ae129a46e66ffd9989ccf1d0641db0849ba346c7da889f5dbf37968e2dc305449065ad2f15eac416ac16b232a91085cb7622dda263260a77a4be6aee0745d31c1935179377d13c09582c4cf5f7c8de1ced8bd9b773c2149d61abdd1c3b712d58d0c1a467998206a6ae2c46ba97d3f860bd30a21b38c66ea6f9e1304edee7f6707e563b14f0c0296dff745ea8686829932a6e2679b1657b1ebd152b89489571415dda6b22bf30e64f57625f867af3959a427480f0ddc73bab8d990b496e9a4dfa37fc242bc7cbdfd29291dde4cec9a8d0014fac7b84dc1124551793970afc959ea609b691b8722ecb98a2daec237f1e9e73e512bee43eca85be6b5c20e68407a63e1d8146abd22d143d0f7aea1d112d38c5f6ee02fb833835444b11adae43d5497993da0a26e0385f56a730405d4230e189511da04f952251fd89f9f2298fa3f93a3afb609d749a9a4839614abf84c5c8ab539b56d1d90a122b13fb044c73a1be77e46fe956cb4c2dbbe246103e38aa4b39ce86b087cacebbb2df4e033464459b33f31f68f89e77f4f3705a347421570814188ed4fe1209adfd57a492220371ca638c8f4b3a7a625b8a315be85cbc33d561a0ea9904f206cc0e7c4a5552681c2088530cab119add74442198de75a488f240ac537290e247d140e416764e2048fc3de1c579c2f3729a0457dc0e989521d9e93fe0df37ddd3a24f614cf48ec29bef1c94fc8ee712e844f1237c5eb3af7f42ecaa8ec662383f89fa3097e686bca0c8778fe2116ebd54db67e892c61988e1fc67315168b8bbeebf785ee51492c7f0f23e87510f6e7cb781f539271dc888d922c1638171db54841968ec3d059533fff4e013398fb8fabec6ab281dbe27bd340d4c5682228cf22524fd58c95a672f7dad3bfcb119a033482649e7fda789cad082eb52da91dd92510dd1bd098e329d15651e7c53252a2087e239d245f45baed4b5af9137d575010590d04147b1b98d30cc0ca211389c31181ee4008d6f268e451da5681a57ecaaf7ec0351adfc2927742d3935e9a7444c8c38c2b42d948906030983856fb948fac41d97273ed21f4e9a776aa669b5db2bf6f39495f072d52246a81f0b6630126d832c3b6d8ede6a17e9d75450a34a39fb8269cbe1ced2ba484e04a41acb8c2fcc46d45539b0994a25e36fe68d739995796fe04b23585bb20b56b3a238397b3508985fe3f11b03e4a80aed1c7d51064aec2771c83887fb11d9e62753445d6081273f55f95d70103bb588103ac3d0ad0454826bd5ff7369d444c44e7e48561a4dfb6762f6c07bd0da62a3aca40660c0165b714c14401d2bd62ad1c314f9a6408153463cc34b47e6233baa7e297df064530812336beb4bd2fab52465e464d5b79dac3fbd17f3a4b8f790167841cb62b0caf0041e332065d4f58e95bbfec6f259fcd85a8b9fe2374d3ada7cc2fdcd2449b76e350b347c96c72e26e4ea9465cdefceb6e28bd2c0ebdafbe2630c9e9a41d1d9546bf7957d900d0b7bd09465b789d1629f3c4178e813f8938a00a232ea55db67d6ed289315e4d7c2801d1d8f8e93ac6372d0ab780d713c382fa57fc21f8eb4875368c83cf281df2775ecb4b18b789a2750747274393d4de1f11a2df44ebe569e9edd0b9a38a87dd11bb5ab02c79bf181d10b4ef56a58b493d11653447d66cf243c6064a51931fd4f63c76648f729c64e637d282ccecee6023d35dc1980f99a9c43d84a50784d2c8a03219892e8f8d0b7794191d6255efa8fe98a042bfc6276dcf3cbd77165759b9461c29a2e896f7a7a1580834953fb15ac33def069402ba6687e409b4a4921503c4245176386010236f4d1d5c8201a16878e74399fbeed6606fb763432144938796b36ff20444a27d43111778d8dd51c8b34df8c07f97c7748c1bc65c59f9b27170ba0f24b4e2c7df2786fbeea8d6990681e4a44124127dc62728d4ba4ec1c53f8b9b0719d25b2a10f5defcc9b94600fd0f1b9f83f7244b95396b4cddd9298bca3077e752233014d60e6f0101cda39d55449f06d9575786249c0b5839093892a788f53dfd42b9290c494feb8db5bad188041481f04ea4c48d9be239e01786783a723baa22cfa331913e340c187882ff0f052c6db1ac82fa8afffa7e9bcf10533288194a04998e103899a03933aa124cdaad2243a268ba80cef1e27af26db886b4e1b42a37b41e18cd3962db5dcf882abd526602b3b978e9fc4e1fc612ca07672b450a6ea9489fc64aeb936f473a9f8abe3db6d0b769d6429e435d2c4cbea96756779e4f254667660d9e699d74dfa3c76644a89bbb7554a29d037f86a78fbde9e3dd7f3ee821b0fe5366e9cc1397a5d0f2f94cc0c2aa7c6586176f0c83e78534f8c9fede838437aceee43bd2c6cdb607f6d0a83bfad84252c6cee7e5ead809e2e9b646ef6df9fd7bbaf7b81b0d9bfa86eef9f01197939b2aab51b6c76c376906dd03bc0d1e01917324c04c8ad514e0cfb2d182f403d0b6bffec4d59d80c5dba379660300390212d1a4889d1b444e32b18e665dd458d88f2d9abbc51718634a024619d7e2ccc953e86030572c8e0c2628871814e0ee4c407188f52344dc603146af4b002f39eb8735b2940c2c1fd84a16ac6eb9d4f6dd66ce877794240002266687256b96c397be46954726231cb1e0e94e662d5a92c3e3e5676c27587e91dc333bcddff44cfa81cec6dd5534b1d5b15f9532a543b578bdb36a9eb5ee8ecc4d91d5c85ffe9d4cb51e904daa8c932456c0dc92eb29e891545303ab61a1ae661c7f1b41b489af8165d570792b7bab56f82267950ce29bbbff4c7f4dae2ccc01caca2659d9e54b5a62fb0b5196cdb805c4d692e69fb8520fc7e77db4aadecf718b0d985da46ff044107f7b5c0defa629daab3d2fd675cc22f1bc57f8ed121cfc233c5e813bd4c5bc94d54ce56893ccb9b4cbbebd4d8ac52678888521d8dc623626a467c5b1d9e2f43d9a80a38b8da8f3995076676d00a917c7dae907a5f8a29b74be6ca3e8e4c3cf6ec31f705b421cc8116b128c956676d196a529ab2de463cfa40bf2312ab69eda171b5c4ef706c1592573bb80dfe8bdfe2f4763df634e9036999670e0664abb37823435fb421dacf9bc1a23f9bbb1e900b8ee61b91dd26c1d60744838aae42d0665d66776568cdfef5ce34865bccddadbfeba9a91da5784a006876781838a174b30e0a4b1eb9bfbb9cf680148747b0c85f40705548fa236f182abe5625c11348b7f23ac460b502af093763a5d9b913330430e71f8380880f88918ba8334e8229e2a1ad026679bf1d7ae3652a5d0f81cae749c4b8e662a24d66fab228256e11083efc8e212f660b8aacffdca54573df78055b7d7d61aa3e2447ba5b884eb2c8f6579e5b1dce20519c69fc67f27f945110ab77ba4594346a60b4ab0e5c90d242afd033bbd210d61b075e9709297c5050bfeda851613854361e9481adb0b2d6180883879735da74fc34a00673525777e889e2d85b1465eb38c3e8b7497b22d566ff933dfd8a3d35e99fb33801d86100e9095fe06ab03246e11c385f14685093291f1d75cd68366aeb966fda4f4e72e4ca587cbe1d78691a2373ad439e0b321c18fe8bb4d1f6bfcc0aec7f093157097b6ea234abd3db4eddb39d3bc99ae1e35b05bdd26622c61c011a749da0304ae1c803cc7ffd409bccab6cdef30b6c29084f359f8eef131164c25b90e850749894418d67c62b591ee36e1471d327720d78b1357997b12345ba4d6ca1b0eb91ec5e6dbc580959a656ebb2400959e1ce56f66a00a36c605fc0199ee77fb53595ae15ea9ed94f2d7a9f42b0d8748feb274e32f1b939eb98a219b91480d30f3ff2f6f6a299feaca6f2a74f902a710cc7e99be5ea2751b1719bf5b94517d92f00d9980a031c6389bb9fd953f822f057662d948a1f3dc3f8c86c0c820afbdd91312ddebd31380bd6f063a536ec694b009a65b433cc2529ebb9d3556664e529d01ced18af1aebcd3df553093d9efc3c3c51489890acd3abd39556c3473abd51238369cb2f0bfcd74d6db3c25093df79affa9a2697aab2b47a70b08dc21001bc5cfa1484051ac0c44be46bb3c48a385044214902ad1d27b245f79196a772ea416dd73512866e1fb64fb381337444ffdd8c72aca8760a3b4da9fb020b17f6be7b67ad4df9ea05102c73f66737bf908674c7dc1c30f270bc99df352a9f9c764093d6e5e04475bec91ba6a737b21550cdb9676190c9e81a157eaa16899a4358a737caba0dabcc1ac91406f1225f6c991e6589d638294b8eff3fa67a481e2147c54c0f39c881fecc19129f2ec8352a7401d4cfb149aa1f3d1c7031303c56c48c19d9476eb8b699a8687244cf8d6d03477c697993508e4b5a0a950251003dcc23223bb70c46cc8456792ad3b1fe7b9b570d396239d580f7cab5be329a1d6251f6a86b4f6f05aef6a82f974760796dee1ced0d9ef4bcd27b3def9ce99369ba5020d187b065337e7327e61585277b66a31efdc6fed7cba491cb5ea1f453048911102a4f780da0c80c589f4f1bc0e2762e1a4ab065194d509bde3d9b6cf3be5ff1c5115f0b6e21070db7af7afc3f291068bd09411b73d56189eb802957828819bd9a784daf1a1baa3a9272959c7e51cf2cdcca7f95cae71bdac92bf8d7b3e5ce12b2355bb0d80d76ca761d787db95f3741b0f16546d64791d16aaf45967e7038d52a87909354db8a326043e9b4f0a9eeac1b6baa537fc826961a82bd71bc1cb526ac57950d188914ae33021d9f143560beee8ade29b2486e31e0057e5c8c9139ed1b94d70cffcb7794ab8eba4c0fd0f5b5f25554a8a81540118145d409e6a9bc07927a2de032bdb23fddf798a5a10f8d75ccefb4f79aa6091a4fcc89c56289b174c525355f9bf6e203d60a38e9b19018d7b39d1aa948ab34bcd73adec209bdd5750f59849edc807d44557e09efbe75487af22fc31388fd712550b5bf5ca6f541c81cdaba5e4e5868544086cc77c9999bcdbd91e40be5e8466f37b7b9960dd9d4a3ad2369d99729b5aa2c3bd01f2e33dc102d5de0ea0250a2cf77662d2acada114124443764a6e53319d2bae7858fcfbb5fa552ad86e3ef93f7022f9de95da74746afe82e5e9d5002d37b1f3f0c5e97489bcff64252a5d2260018a920359c8e002de90fe510b1230fa4e13a33b28660d9a3f78fac8e217624531c78390e4905b28faa79c50b74dea0574579ba9988552cf7768bf49494607b557f335abef864bc13ae9a6794f2f85dd3c27489bd19e3a12dc08b3a06cccbb84e8a7eed8f80e3a3173104d677d411613d7c8a6703082cf03840837649bfdf3a28adb43c2a3479456ca08b7a73f484a0983649771c314a758b45dd4713f46adff25875d8910c66e6f76d180468255f361bb87f9edfe04c82a04b7f46f140a3820adc9a2e54a21b9276f0d21cd905b77f450b6b9d7831e12c9de6a5c1c2c0849ef3eaa5b4b38acdf3d121ef29f2607b51a4078ce9437a35ca4ff4729d481fce8f2400305c3e80ccb0ee4b32b094c8d0a1fd0bb0bbd35d3f8d4378f0e45a62027ce363a3b5a9089202fa2911a2095dde8ecdb12ca6ec4fd5e88c3aecdadd4d9a7ac4ab314165a6308d1029466c488dd60302db071ec9b09a88db823dc38b304d8fb1bb13f71601a92737f9261d8d545310e06da97b31cd57ffecafda252ad44db7261c2fd285dc82ec761c7506e4ae05adee5f3864673530f6b304d5b91b4e166e1c351a803219c02c9d5140242a2a5bf70b469072b5e45e27ea79efb9aefb013d948e156152eed375af821a2de6db5a6ac0812412f58ef8965bf1b5f42496b61e358103f631820d88eb8c15c0a5d396bb7735192a42c59183a42426191a4835c51cb7e414130a5cb1d2148c0d94979ec0d2985470cd74136d433d64ede051d00d870135b1c8dd4dc9891a6d8446676cd0e5f76fc9a954e5a0816debef8bb3869d26a63249f4b5c72b3e7cb5acc6ee20040d6681ea999d675d15459031f53feb32c416e6fb30eb7e739bf6f317c94e6c4e8dde337b62c3dd655aa80b0ad66cbd740a526d15992c01a917761eccb0eee8a44614c99b9fcb96cdd1954d52040f1f8968a6844bb2d2126e3a6e43a3376c8e1f766d2c1f48e595c221b507ad673d81549b91de125c908421a2ab942a3715fae0fc3ae413b48b5a255cb683bcd5edb828b7f6eb66d5c3d5dbc5e873c92ad17b67418766522fb4d1399cccfb1c258311e4f8260f8d72c7778c1e3200ed2d128207995b38a1e04ecc2774bb1239d262e44ba5744afaef90cfe426fd4e79f7d4302ff4b0266ce3e82b876f507373e0a9f17ddb9bb29ffd7656531c21224cc17c517b385532c227f34e63c2dbc41488977a880335e2b41deaefbf7d11110e5cfa20b486fd1cb3c1f90fc39f82bf99f673b0b149929a71406968bb65635e1266dc360887f5af11e5c29c3ef3eac0e9b63dea9864213daacf6bea0a8b29dc169fa5773dbcc77773335992cf276233eb55c75511b4a4f16a67c60752a1e00690dcd67e132be8aeb0b2134cb07f1839f795d2038d9be0da96c71ec32a2abdd955f2a61de228dfbbced9bf731fd1657199a6c91d4acc4b62a4bf3d6bc38e8d453672bcf4a951de3d929e1e4de9d0e53288873bcaabffa53cedf289f8232d1a33bcceb1e6d027fc4c426e539efb7963a65907ea32958cc950992df07b1da8abf1f6b16bc09c850691eb3078a2158f516d4685c0188ee46fa83c48e1df725722efcfe0fb0168aff9508a70b5815c70ddb343e71c82f4bbdf84d66175dbbcdd3ff66b959d58510e1ab21dca909dd375f9a42ee7106d1954d8fd201f64704c348d17b8627d5511c79b5cc7699ac6206192a7260cc59dc240d9b9d527368790ed0f57c211d46adcac179dfdcbd51e262ed540d492845398fdb74c368ac82a42066513910fb0c8127537553eee8b475edd3b874b452c46154e244045f83ec4415332b7d0215e69f267ee1981544e86fe54c2836e17b540ed30374294f99f0ca5963cc7435633b17704d9af7f4c3137dad609851a8580f79b656ea789a4731033734ced177177b96de04e3c40ad41e513b9ee1ee2168dfde9f758c90d61fc8366acc1e20072e4fec72b350f9e5f75b65945481d3223af06d2341070f13d4dc857b2d4a35822d902fbc6549b0a82bc9378fe0b000b96697c9a237dccbd3bbce2b7a8a1f21fd32f339a93906a2787075b3b6d099aec42ab5a764e8c29c8ba64e031f3e507a6d13dbf7dd598ad78d17fc448d1f4e48b4896aa507bbfcda06e505c8cbb7a568c3205c19b004cd0265d552d0ab62fdb693cb91b9b5cdf1a0d4818ab1d8f9d5da30bd22fe761995d0470b825ef3089c162ad200f04ef35eef7014c0e52c73566ac720767bbd531aec0ca5e4da4af6d8668857d6fe6d40bf9ca6eb5619008ed47abe6bc31834823e739b40ccd07d7243b58dfa1e07097f80f05406d6daf98a6c41068ab9ad49679a35c8c07939493056080f171f7dfe2a5e6cbd2942185fe2fa1fa8ed027bef0c54cf5b72b418e42bc05a2a3407b96e677fd9fc16a3931f1b5fd59a4bdc08c9ce2a866f62f260dcc4c03b578879946fecb6168c70f493afcf3a411493e08a4b41939cf380f88124034770384e1a715d9ba9cbe51584bdd3e76773c9753d2515bc1e8802a04d4af8616ba3e56eb061616accde9ece3793ec402f5fb72015de55ba8702bf73f6f0aa8537f6a8fc221a79b69d1cda8f23f1f0632738ff2205ae744902d2d74420e1eb3accd25187e53552954e1f66257c16a1be4e7fabcdf3ec8c9f24970647601dc7877642f5d64369e239b70fc1d7eadd91620a540787763573c183f789ff65f1c70406da4a6fbc2f5d43e04ba539b0aeb976cfbe51f554600e97e1e39348d6bd395b747ad1ddeeee318c99b2867664261f2c66ffda203893e19fb618b3e3b1a9e585aed8738e6dade8df59e811545417996f60bdebd5c14ba9b8c1d08117ac16fdbc8c9c1e998d00327043222021cd538fe80134805747c63f0b488b59ba6dd044ab2f65b2b2c4afc479a9a88387ad103180bfd4435556f5afb8d8c904f909167d63b2730205fbe454a8d5b25fd2085dba0015c27d5ae65df177cf17ea0ca7f3e3dccfaafea5ae8e2c2a919850dea08b96c5f8bf6df254a95f547a19c2cfd537452d3a86bc64de9106aa57ffba179a6db966d60c173d1cdbf32f94e1afe0e914c93401c533050f23cd77f0d495c9bfb68df9cf744d9f47051589fc9512763395b544ba89c9e032e321d4af68b6c30106d0f7b8e20e8998560d952fc0b7274a39d1945060d4b1d95d89cb23125884ff30dbae12cf5162d5309d41bea0ddfd1a551a35f8e7bc2f65147d91686a7a9f34c9245483ef7b685036ae870640d052535532a66618d6bacca29900c641376a57315b279a5ebae832bd1d36c92e7be3ee743dcb5afab070583a02abb3599198e334b54a8e790c5f4a9a5a539ea3f4ac9b165a8cb5fcac62c0f603c4605b84357dbb08627ff3a064492783767982ba3a5a78fc115df467adb086d3023775a05ad1ce779361e3af2fe4f9f4422f63f92840f6f53318ec2dabe16a6d9808ee7e5b5812b18a267dc510caeecdfadc30baa4992c722b9185fa672807809eb914d91dc18efe3700a4e1ae2f4961b0207d11f984a983fd5662e5ecd4cfd938f873a9b96907fe2b7bc38ac51512a104407ce7029cb6cb673721407c0dafc803dbfadb67500bf47a146eb77b7e5e279431389f4c527c54230e90f298ce940a6df7da785da0bf2f655c88b47ff9d12d5ab4be4d20eca849ee1e07e1a3adfef84a1b830e7d370f1612fd018705e7f1736bd342dab295e7dae21976b5b7f6d9b979ca1528f180e76f75b274cc522f9a210dc70c12fc69b6d85d5752ae624e92aacec8bf8a2da6ff88c3570bb24edef7915272b6aa01e7d38bff5f051c65ad473b533410486a7648a4d2d2cf4f8a6acb61e60c078a903ba6478f333a24c69c91f1a89d58da30d699c9d6ae77c2f17a979f426750ef503d103a84afd7d4d066e7cd25161f05b9c7047cefbccedd676c667864e55ab4e113caf3e82390af606c72b2d2cfd38583cb7dcf8030dd3d55b7a690f27f8b254d2ed5b82bc239a1d955b6c74d46bcac6dcb3924cf064984a7e112f0ac1e1ec93cd030431bd068e0d956e3a154e7665d2bbf77484cca9ba76d498432c7b697b33a71c73fc68770d58beac230fdb959b841bb20feb99cb7e13572f9c5b936c6943e3dc2a6a07a98326db8ce9adc72b2821c8dd44963f82a507d544b844e852c56bea84001e51374f0a3cfac05503571fd9fa6928","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
