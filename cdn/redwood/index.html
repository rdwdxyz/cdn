<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73b7bd68ecb0ae2fe51ac1a50aa910f51ca271e4e3c7bafa00dd6d0a37fbe8fb6ae5b46e75daafc5f7b2aacb04fedd0d15c792d0d0f1285a20a7583cb1d968a5249f1c01c1094cdcaa68b7e37009e42d864a26dd77c37c9b368449e07df807f467d674be37bc6aba2ad3919c2ab11657a7e9d01954c4c26b9b86f9fd4804b4d79f468be39ad7e415d515fcec7fa0cb82ca54b6997891be120e9b787a650af5f8285f31567e255f221dd3532c6d27981392da9e086030bc1b35690c00d18da15be9501d77c580044845dce5fd6d268986abbf075935b5a904dfa45d70d6a4c503c390bf5415796fe8c55ead784aa2f19608c50127fbf855f04d9f6ef4baac9f540c040323be423d68797176dd0e58058c962bdb53746f25e8702e7c8746ecc402502c0e512c4791ef1501d33703f3a420e033194a6af5a0a789d28ae9d9b745b9b03c2c80848eb7bf149cd5199fede69d05483018d6b41372cf25533224440570b0d781ef08001770d8639d829e6967b249961bcdc170a8bfdc6e977fa4c3e1d1e87ac3be8a1b66b3d6bf83f6b4282de6cac807e702d025739e7a81bd60180e5388350479971fc1ab871a986e69bfcf14e7ced3af24877e92f26a4c6491ce58b22616d30c1fca85173bb6c6f610be695c79473d2cbc813e65378e7a81bf8d2b9917f864287b58baf2577ef251b48e69bef6087b060eb0c35f3768bc997ad2a33cf995266130aa3df7f00d3617d93504dbfb7f3d225ae09c31efde4ea27cea204d954d86df194d588e9cae2375c8428378bea4723aa6eaf469baac348f2a11dbd6e0bdce1a7712b69e1e4894b3780260b239730af7300b393436420c28899ae167fe70148b7b56b101d0adfd9511d9311212a8824be83ac9bcb64d7936841b9f2eb3a59708572339b384a12e4a6a2a8727ea584af3ddfe0a73fd5b0c1f2ecb20a745eb41d203fcc1d5e00fdb08dc86d00fa8dc2c880ccdcda417db1c45cdaa25d2d3f479a54362ea5be7f86285934a1d72287d5a87bda09e3c99ef4db545906fc6e64ed7d42bc79515562921ddf58d85420f0cf3d0254929ba8165f1be25809ed3f04195a37929bed97077c2d0b17604cd294181dffb5d4f768ef7d000c331e62f47a3207775c342280211db235b413bf619470c104f6561e3ec125de6e77cffe344304b957234d8ef0fc7dcd13505ad83671e54fb9320336a2eeed3ef1be79579ad40a848cafccffa429931e0bafd62ed6161ffe14e00fcf17252fbb841de61c99b566464a453f1b5db5caa856625526ebfbe644be34ab3a8bfbd1d2881ea5813d1801bb12c90d3ba8d353caf3781130392880309e6615ccffa988b56e8b889686abe03be49dd6a01840431e60801640b83b7337a9f31e942e45d1a942aa003b40037ca90fa3d3dda50caaa68079ce415134ac2debf96a30e81ca5387c05adc2170d51890d196df2fd65cd5b224e54f07a090caed11e14a34da59c743869caff05a7d30daf4819e6238c2ab17b950a8e0f7527d617b056b2c637ffe9ce346cc824f1f7701d00adaa7a704fea51d37347ea57f64a3748314204ff561a88e9ab69f3c25191fe7ac6ea150a45849f9efebeffa2bd59117f3a34fd6e47aae88851d122e0d9da20029609d6d8ffe3f33e692be25a9d2108a34e543865f6ed63aafa871154ff6880d3bcbbb098439980934f9dd4267a18237e4fc3dc71019b01f07f5a245be8a6c01b2d3f645c739b14fba04afa9e1057b600ea64fe1148dfec9e702367d2844e1d9eabc959b206b6bbb3c8c9a7552eb856b3e2dafb62b9e9752c6fb00ef307fd36548c14546a48f337b2aef002627563f68c0a2a2ccbe2b3a78a71d95af70c1484dfbe608cf17109575a0e25ce08ea755e889a0c401d8efb894c4caeac9f7433687bc3e872a9b9ac36f661f49161b3b865033ffa825218b73aaba68e4c1d44ef994cfbf7e9e35f47163e3c687e939fd56238aebac11b717b0c22285053c2f7685db54d72de6d7e06f6086513cef968318ebd9b54ce33cd01a98b077fac563f599553b5605d7c76630b863b7e4ef287b016a90e91ffafab066f178cebdf22df39f05734e78f98ae8c89c72f3342eaa9c89c76aeea88c2ce36a0bd505341ec4f61adf3856be70020386c39debc8d18ff07701e0e4f52842f0e04eead28428544698d0444d186feb4b7a8f57bdec501c51db929f6dd1debf80becf5500260ac5b474ddfd991f24dd244feafb018ef44771c86e4006252f8901e63dea18897e96f25a634a1d2517b7081b92a846dea747a8e49dc6b7d434a0de687e70b7be6af5193931fd0483e6b0733d0149fa97d76f4c937797d34a7a0a3bf1c70bb3cc2316a4d2394eb954e0d0a60696ee75ddc3a009d5187a2b9c91cf264ed22c94aecb2d0be69744d114f0e9748390671a5abb7669b88c987aaf5a486f82437a9e4eebefa981244eb21a0f26666b0793ad5e1d8ca0ca22061ec90defadd712a53e60ea083732621923e24f761c85e574a745fa1922bd4b3f83ee5e5ca586f9cbb659429fa96d18e4f922d53bbe09f7dd57f19f5b9e238438468e5c63112904259f6f1308662804cbe9398c682d4ba61cba16a7006cd821c8f6a2da252e1b02975f4fe8c4c5956577f920163b27bf8153a0a4739c6e385606d47fb8363aa3dd027cd70fde89cc503d0b2b1803e7acab920d9dac571bf74fce681930c1e3faeb4bef8c802fdfecbf67f5e171ac862c95e4c81c130498f5709a980484663310bf872796844f79ae29cc16d716359f1dda5bebf1cab3da57bae158953aff56697a7ec1505cdaeb6efa09a8347331bb46152e764b95957527d00a86dfdfe877f96953b0e18a6668a01c8c1cfc8b81752823cf2f1cdf5ec285739eeb4b946a99cc0e7bea9a0e73bb7f7757966a32907c421132e1e1a65f9b79f054c6d86eedb67c583bd1c72b86717a43bc7acc14448c8b7364e9ffd97e9d586cbe41f6235e8951e2301dc78f6841ca12dbc923542b1add5ecb631712f71744f91d3f4433be4ca9e0f1894872016fd6932795a4c655eedf6fe35bef2e5a3c6397360b7acb57f98bcd7bfbf2925388e71c72e704b7d0972adc1ef1b99b52834f88a61e5522a69bd13743084644b3f3eb3125149431aff245a52f84c85b2fe3dd0e83b1087ae9aa89e8333fae9d8ee8f2ff56ef9066dfe304d70ebcce9a7031b2ef49ef9cceaae7a9e6f7f792669cd0bbee44f213b35d195b8177c3ba1b80461fe100deb3da52882c9ca6fda3ccc766976732af528cca200c38ba811f8e1d9b606e84071d4f382407971cbdc039f2bdcd825e4288c25bcad52b244e41fbb62829704c2355bce45343203943adb2644fdc1f8ee4063e8cd29ea538ca1ada7a2f7909522e2e7b36a7cbb0408f110d78ff6f5bf95264e9797aba11f4f082c9adc2843c037956d1355ee55fb13f366bbc6a769958c390688f3a1602eb2fa4880ab6187c2705bdf881831eadfda7846ff148c7958031707e5ad33c182cb37d5031365273818755f746ea6b78ba61e3c523a64c261d6df2949427dfa17397a54ccba6990ddb9cae3b63359bb721a3451e0b04ccdd869e0696568c2450a3ac5d682a73779c08d2307efd01291afe0742b434873f8963a294414725f058de4486e019abaa05fbaf5a83d79806520c200295cdd0e0749a9a8e577675cca3479f79a791fb12b02bc67747254faec1e45528b1c0218fa270d24b683c559781bda46d4ecc44ba0868c048be8ef324a533d885c4fb754681e14e706b030362f9c0474c6799ae77ee9c1bd98016344dd043fd0c16c567c3b87e47f0fd719af544b2330681fb737eedbc4039300dfa8521d76a3aee6f985d49c96898ba61ea3b46b88c9e664cea963b67005a6e44da7d446db38bad8dd278bde7818ea5d5b8c2601f6c5a7fa4314684843242ac3bd152894414503eae9a0f666a65de7cc00d555bfac7df558f1219aecad78a815466e68f30c97c6ee7729398103bdef2264b46a3d12ba799ad60a14e73270b49e37d57b8c29a0961543b37d5e45fdfb87cef7d4bf8575f97b8c19877636ec459b81b6bb7810110d23b13335a557797620bfefa2e9bf4ac32483c19a216a3d89c8e43f3dffcdf3d2d5ddebb35cc6e358b2f5f0fe39b2d7eddb3adc55a18d51d7529919f6e00d45f11f54e177d0cdea71fb8444041c73444110d28f0832fa7220d8ec5873f7fc5104931d7d3f24eb0cf1f338f861553d97f479191ceb2a1b50a7066188a1bdd13a7907ac060d58069baa17c48ee64edfd54e1aaea5c66dc965a3249bfc526576946d711cee2cd630bc6cd73b512ac743d868dcd59b23c29cbf2d33e98e64f6a1309925bf2205d7a55d033d27ed0132636a77e7fda66bd0eb57708734ea4be416b44537842cdbedd15e034a1fa3484abaa7efeb0c430b412d5f256e18a5a9d116e58f4ded6898f604fec3f01c0678e3c3850a87f4bef19549d83ed1ba3e63301a726ca8530364d32de31cff680895e5edeada19f6342003314b22ba3ae02e6411c27de045caa003e2ebd17dc5a0997ef64a6821f49ba98f044a6413689f5959e0911599f66cedb750dd3a265a1e3b93c904a3336946d3b813d057b40c707e2379baf2c627ced0ff306bccf6080d190a1087c6f89a7ccbfca465f073f2d0a9164446dd1a7b0ea29953e233d8ca74c60a1e4da03e2813941f8431fbd8a94abf2f17086c8ee2c951685c1e9578f7ac6712a12ebe2173a27aefb3f996c14129fdc8c1b745134b886b1a7175377fd9ccfeb6291c3af67b4ce6a5ea2c6a5e5b39d7c5e0c79d24832f996d0c3d3d8564e535fd7541c9955c2f0579aa514fbbb058e4234278d360e358261f5a54069d69481c1b2a4a418ed4e692f678710f8b125c251f04c58d432e188cfb249f949239260181e12351b4c4e62176abce19f21a6da1108c653c6416377f748bea61b307ae7c7e591922a63455f548ad320acbb41faa409f6f9ebd00813b3fbc2d26f606112cf88a46a4d63f23229348d23d3f4ddb5d167de5b62e8b54d9a0ee290f5a1dedd6d737f8344d0971594ad2cf4989f22663554b06c37c1a5e8d5eaeec70170bb9c442c1deebd8718d5e065eee730cc379d0401d30ef214c932421636ea19260c3fb519de9464db8d445731150163b8a1e82c41660e2a71023ee59db42e47858d2ccfcf34a6c668bab7b08ba345a54230aca117ad0a0217b5d96797da38f2824c429718930a6b3ffb02b117e32d38d26d6ca1943d96d621c416ff601ac4bef7946fbdc94ed8adbc85385b750d3ab4cc377e3d087ead886528d7d1ed954a8cd6f8baae33861eead6f81feb3e651fa8ccdc611e812e636d3d3fe9d530df91b3bc73a5e0116a5ea90ec3efaa30fc153a2fcbc55c2ad1ed28cae851f54264f1aa97ee2b1181684b6df753eaa35def5aa8140d6339f75ba582b20cc742e9789ef0ff4acea924c67b6da8204167b7739de65502ebecfce48bac6160b7f2e3ae8cf586642b15f8882ea2dc9b53fd0ef45713f3cede6dde4235822cc88c0d6bb3a4bc4940817bdcfe2a0a241b8fb18d109deabd5107fa7b4a3162843671872329f6b66d58dc2e197a2e85748c330b939f3372073aebed593703ce848b001e3559b3ac25eeafeb6c299f9cfb4c09c785a9bc6542697dc98cb6381692062f2312f5bc25689874037513bed0cf6f2a1388d433c717b728c6ff87e8d7b673b714d66a5e37440da5f7af791f12ae27cdf5e573141febb0e5edab647abfdd33e516ed5f64528d4b7902cb4617d7cba3dc66addc72cc2f6a728341cfaa91acf90c7f43ede16d6c20b032e606014bee3bc3141ce978185282810dc02a4056fcdf8dbf46a3f6a1bad87abcb18a335865db995eb1a87fbfc1d36ee095fdf062f5f45e573827b4c2b9d0483bd517ea7f9ace598515ef90a236f3fc2a1df94cd2773c026e6cb870dcc7b0454bd59512acfaf185fdb9c4fbfd49a5474b1b76904cc5fc40ccfb88f70aa5253a75fb23a56a40825d7ca6f404b05f23475cae70e89a6698bb749fad5c03bbdc7f8c84de0bc47f8a34c40b31aa76b833b4812362af3b41c482fa63f606a26c753c7b10734252c0618748dc09c6210235cb15d05b0f16085d98e54110bde69028e6d9a8afa74132b3b47e68c7566ce080c595c5dd9db46d4af8606fd59c04dbb171ff0400dd9f5f38c461348225b89755cb0ebb0c6cedec8627d2f3016a0e073cf792dd9c8bf3f736f55838d68d132bb57dc0a5330463ac8c62fe9a77147cad3df89c73a532facee26a5c621ece49833a3b574c8eb5e7ad9873bd82f20b2c9dab4ea5f93137d288dfb7bda8cef353ce44fad3d1c6fb13a548a45a59e7ea0ea5e153e181450624594eb6d02c247c5228e2c8d99979c2e6b3bae034091ca2c1de6f3c0060741bbb014f8fe7b978c00276f127ef948e39397941db340df04615903cb6532eacfa5499fc427b77267e8b94838c8646014772dd0f8c9999c10edf7dd472cd4ef672189080f915ac2cbc932ef9cc17fe61449e5b269b8fd88e9def3ee5da245dc474f6c7a5a38bbefc8f3ef02a367d971573197bb6ac2f44b0a7ea63a3b35a226ea99ef606e9cf9388e4aedf79f77737cc17f32b44ba46eebb77a1a89f738e0e4cd232550b3db549e172b57b6f762bf3699cf643b8c9b3ad37421151c8cfe450fa1b0dc0ffda0e317ba0dfc5866e810e8e8edecd78626cb23129d5e673b217475c14524e213096aa961e34833cb08ddf2c7ffd3722507db4f976a472c118de667bceba52541d37b6be81acebe12384d5e8ee548644ec87a4c44683e0ef62798df49061b5bea467e4228a099504a02cc961d8c63af1ebaf1c91ae9cab89d2d6056675b02e0ff24b9cff8a3b6d9b1bc796e094819d1f9fc53599f1c3c1fb2ce095d37a9f48d7bfbe4eba645513fca94699ff0a186f7d41a15f95163996bb161af2be558585dc155556174c6c75e57bfdb258a6c408210ed639a4da394a77ddea415dc337fc0a53fc2510655a1b95d5713c998bca28d9195b92dd547ab4c58b1bff1ad487c10fa8cb1898f89ba43a13261acd2f5a01fa05027fdd1dfff11e11934dc65bd8b741f5323668151418c13e07629746d7fd35a23d61582dc180641127f2052a83fdd7a4e46f7499c49d9c3c75b1870b52217508a5669420fb6efd61c7d34ad6bdf190104679d38d34c67e5ec9d2cb5ea879d594bb6a28244db238fed61ec2d9cd480bde11a714f89b56561389734960f3c34606333925e9aed4c4941e4bd625645e8a0a58cb6aa44fdd78adae77a26d31e5fb32d13648eed51973644dc43122c018593fd1ca84d60ff1782af356ec1e70a281dc0c2689a84c36345262bd39543a2017b9561ea32c6fb320c16185d97c3d76f1073f7f82fda19d36bb66290dacd3b416ba96f2bc938f28853165a56bf91d98c9aebe580b6a041bca9366d08ded2df6f7cccf07bda8e2df0ae52d0075aca8eaaa79dfd512cd7b4182b1d45515ee6f008d731c84fb3c4d4d5662a27c77c62d9c847482769e3ec01828a52a33447ae2c841b71e0f8a40e696e4a7d659095c4c7167bfa86dcf119c4a13e81b11afe8340f97437a27b21fd109ea82d3da85750be02a9c3dce998fac3ee37c53cc7350d151f2298d06ee019f48d79d308fdf633b051086a33646a7c5c077d250133e4e946e6c20b7047034cdb708ad0f78295d20a2a3d2a181ca9c76e993f56260a231aa2058ac761db11da428d9cdc61e566ecaf1170e89ee2c3b4d09e529937ccd3b6b3a23f31380ad2bd303e7dc8a80dfc5374c2fb2caa4ba799f3832be5304f2a26f58677084093ebc6a55f7ce09df64a671cad48fca64ebbe645db238fef16d11ac0105846083aceffc1b7b5df20c7252be3e3a38793ace4de35371f8787f8ce9e9380eac0e53c4829171beabc4611963c9f1a69fea475b1e824caf65e81e14689a03838481753500cbad267b660145014ca58288ea87bfa910f791a415d64a7fc3e532956838d7076f1b1de592779ca705931c3e891220059a9a9c7db485832fdb6de948df9fc121e2dbca1949ef654352e2bf92bdc590bf0f8fb8fe6f60736e6492f63d979e773c24a21730845d26e918687be952165518864cf752492f85a10bf72e2a93ed54a64b9aa8d2ce429126a7342bf4c4d823b02f256af5e3a659dadf1bfa6c8b4c6d89aecf02b84fd2483c7ce77228d626838d3d77d21701b990b867258e5d53408eb0af45a00766cd81a25f6983616a11aa00bf97cc7b9711e140dc66112f7b8348026d43b827fb195608e12e43aa1c33d5a61ec6c685fbf0d5b5cd363ac544050c7cdb159adf421d904d4b0cb230a4bfa6514a9bbcb2f21904be9a9c0e3ea2461c56f6255eaff0049cfe96ad8f6d10f3378cc2e0bc55df4b6375b6826971d7f55dee37c169ede67d36693b5c42f768ec136b1379d4d47556d75799253a67726ddea86cd1e7754f94cf7e4001f3977886a0543e0842a5e4b98f36bee582fc65443a7d6f9cf05e213fc71beccec7e06983a3c3c8164d44f0f9a9d2ebbbd0342f055567f8a8d98c34f435e0f657fed36c9b5e69c4dbb5e3ea29a3665378e0ec6add4509cfc34f72f56efd1b987a9dc0de588f58a786ef337ebda5b360d28c20d17dec11c350240ecff63fac6f73c7b55ff3effd5993f5cc676ccacaf84c89b26b0352182ff2c8024991fbb78e7ec59b83fba298c243e7d77b24c02fbc7ea31c8839b82584d41f10c5554db9ca61ea652df11dcc885e80b2362614c6e76cde54ccc22327ec67bacaa1cc4ad94ddbd99bbf977601474593d04e615ad3ed607c19e1a73c74d2dfdc9cb906cca48c3eed22acb9a79fce900187a7d29ee917b94c532322e521874b32b6e7a9f287458196b5d40766ac8d0116ef522dea8dc2317d645b4373f6fb2a1bd3a41082f3d59cff361b2b1387ca94013e2575101eddfb3d2b78eb47c770e3b24b7368bfe69f41f78fe2b2e9843d47f755a593d02a0d2d97d9740557faf4c0831b07e01aac57e4efbf0ae4595af0e05e60141c44cb2f049869df9ea3bcc6003abcc1649d401000360dc56336e155d1355ef70923faf8fb9b583fc914f90dd3d31a102cabece947010de1ab3fc41ddf7020b9b1f1766229322f957c764f8c0b36ea637d1cd3d2c35fa58af453d49b8450ab5df1d19151aaa957300b623d0c7e0c540201215cc556db7819f725074bcd00e68d2931635cc32d42b07a2f4c302aa08a1144b3556cca88bf7e677c07207947b48dbc1d0590ca44f8b6ed0127fb69fa7b12950f644a4edb769263aa8eda29c049a28eea7922fab1b7fa0ce3b2be64f5c5ca90f0f1344789276ae56e8d35e37af0e9bf87b68cc445a654350b7181691b93474c16c3a0c242cb90085cfd6583427ff511cbf568aa700eccf2c590ce179a517695b674914aa7b6eb685482afbee64bde5715facb1249b9556579a8bd9281f37ec29969ddd0fd8df635c6adce34cabee54168d7456ec2d34c735fcba6a85bc42fbf1b5636295a14169db2360b2e65ce6d3530d1d72568f56187bf4ca259dbc7775bac59c3171566d8f439f493ce6e1e820f9fc6b098e72a304bb35f7337afe5ab6eaa744b7c5b31ddc73da5ebbde2a4422531a45450daf42042f2e15e020c32716d63ae59bf184c7a5b5aa193e2c26f84c811486f191d64fd2a860bdcc703b09d3e0889a934d164145a371debd8aea04250882b26c6ce3afe5c7c5090251be8c4fd752d49f6d73f9c38d8fddef328d7607eced60c79f51712639a32c8e8bda09fc550a9234ce25f591dc43ffea6c26b7513de1391fdda77c8bc56b448fd50204c7b3f16e7603edebb0c619fed3dd3aa678410b5030177bce3ecdfd77a58df3daeed57ae9038599315e8b48ca5b1eef10d01b54cd8e183bebdbd9669ff9532b64678c68c53ad130596207cb6f6d90ef494105ae6c990b7b752078d5868f53086f613296922b6ddc9ca3a931989248280eab004befb986bba38341fe81d713d34c2f1bed1c361d98d679b1dfe5571dbebda590bb01f6847f37774ec5b6662bfb69d16199e87d16cf415798a931188167465b5e9050ccccad5ebbbf5f1ce5666b67b654f3b2208bbfae797376c9d84aecc7e06c365817d56d6917a52e45d793444f8bacb7e7af75fc3014d5a3d98a122834ef41cbf54f984e207089ababf84bb8a88b21e38d177e0eba73f8a8b576764c52776706f5d6fc7d200a3ee8b2b5e07db021020162eb1cb5b8b7dc84088e7b8756b98b2a511d98c93053e17c4c63255c9e13cef7e7797165689faf198670ce33c02d349b43f63cf395b62baf820c62ba031291b09bde18e646a41db948956a9de7d970f59dbfcaf6d7254d399917f11bf6169419aefc5fa123705529808215724c3c9f0e0e9bebed3d48bf4b5063ef295bd94bbb4f2b6dddb538c5ed9801e725fefdcd1ae93c4d4a7dde993404e3bd82dcb5caea79e81ee62f3c690c5394b9a0c4c38e1c554aadd642e9576f45ae056f6ce25ccaf11a7ff51cedbfe0d79bc4edc1951fca05699bd3742779fb32721073560197e3de7135fbd2e425aab7f2abf668d3cc2c2d39ec957e49f7baaba262c517bf720e72780b1d2978f2fc5d0d7756d63ee57a374f8b9f632a1ed1444cefa0c462b38ce0a8e806b807a22d0d3450ef362d7abe4129cf608328450d02c07f88a06f6c56ba99a16bbc91993777c37ef53f02d244909d3e2908e246e11bca37cacba2068ea0b1219921a9a90b863c066d53e0d54a1071a4a89eb37498395d8f09f0fc12b7df7f162344d25582785e36f01da9e3d0cf022a23d727d29b273aafd4839c87927c4d0eae714839598e8d8d75bbe5da24bcce0fc7f908ec93a7fb0fea175e75ebfee35238b4675f55c58e92f43301345b02460731da228ac5dd0ec5fbfbf3fa06067c1479000c21d87cff6fd1529a1bd5ee89e8865fdc70027a6a5cd2d2def40a796801742e63fde9ff736de080b57c34618f0e81544002275cb11af577b2654a880debd2c5a0ae0cf91c1ca4dbdab9d60603fdfdd7651f7f0fcf1e7585d3ca3db935595dfa2e83ec4517e14e388f0aa5720bd494dec7ff942274316b4fe7fc4dd96ef9d44c45b8d98bf81ccaf7569aa06a59bffc6228627da1cf3e685986592447b826c4302c19bb04edc1d7a60a10c4e16b5e28af5b10ccde64a741e2acd492cf988563b8538410e58c274f489159f92bd4d4c1c2b88fecfa38e4fd2ffb0d6ced4de768d001e7929a6dfdee2d335b85aeb36e0bde3a65564d77f15ac505202538db27aeb01f70c08fb1e3df04c7665ae08fd692d2a54e7e3200577782fc8176e250acfdca8cbc332fed35b66328c6b03bd3f2e17cef658b191eb1a8cff2c215c87ed94a7134811768e827975e549d4ef3ba0280ea99939298c1d5f3df5eea1f52835139cdf4fb4189c6f6a39cbee218dce9d131f9fad1dee632df5c149cdc3c7aea612fb0ae9204ad8b41cfa0d947805c0d057b5e0d0f36c83c3f42569070b5da66ad39d0185162862c80919069d607ffb19de47ffa6aa0e0b418a08e51b4ce0a346dc6281365d9b8bf3b421f16275ec7f56da2352ef2bad8f4c846e90eff6d14365950d3d865311a76a545c203ba0cd9d3934c62df8ab171b967f432649adb2289792f9747f5788e7f4b47f5f6539bda633cf7c80d1f04ac5683972248820ff807da94e87174a3f5dee84670574e73aba4570220de8353520d00a6f11011bd3b598b237da08952e78824e50b0cfd999233879d54ac79b06470f932bded4f668f1e721f239b7d016e5452cf85221cce6825846cad12908c4ccd9fde8db01808232194c96a5250bae6155c3fce2d707c4dddd824f57ea9b4e20ad36bf9726002827d96f6f1c567af9a8166efa32d0f953aab414e5a027323cbee07c1de9512bc7c1df4525c694932176a5acdef2148c9dd58f2c14d1b55f881f281fd7bf5b9f69384f49af7374a40326dcd99b518ba4ecc6272343889c6be3dce5e60afbd74c1f58107e8af71ed8503c97a50ccf3e2cedc772ac10567480e2814e7763bd856dcebfbdf0cb68f356e9678033bed68e063c8c5a9cf782263b7af313dc661b589652c4c1319508a74870e1fd953f743fe312b2fb0bc157ea91822c319482c77b8103fb0f2956a314c35c34df9570da9ad03614de3ba7364c4f775c7272950dba2df16982fc1968e6dbfd58401dda1da0f007719e3e0a46790ef1b85d2aff5739853c10c125071eafbacf56bc36c3608387d00c88f824628760de83032419b2fa74bceafa4cc301745c7330e7bc48df3a1f3b515b7e3d23f5c33f33d026fc36b5c8bd064234817cf7cb8e37e57ac02e109f34753fdcbefd83708c5b30f94b035870f81f360a5103d528ef724d60e57f303e4b68dbc1270c937c8f53a89db5f3b2c8a91859987be22c31c59a62152a49ce032777ca5fd5be18b03b7cce959ab058d03842253992a5bd363c2b22227f44cf82381c5ebd6516dc1fd31199b1bd671710c3d0337cd28ba1d9179c9480b7b91b826976f68719d378181dc508ad1513dfb9f488076a80fb0bc7d3681a5a0a686cc01db3437d401a5a3da4b09268883d9ed7f484cb4f242aa52188cb0f11283c69133d438303c639a45ed59c45ea56ad24a2a9c8db715798e5fa0bde56714fac6b309d9cfd404e785d6c2323b73069b5cd7b1217dea4c34f917c485184925cc965557a588f21d0582fe6dad876f36b71ddf462977ac6c918eb5aa0bf965b086f7d4bcfd1621af292342564842c349fabf497e4c2859d8a6f1b2f8fef88aaf685fd39ba7a775f0337a64921669daec120a3f15f922a8085cdb665816d6fc5aff5350228dd10a48de8a31d05e320896948daa4e3151ce5df3c8e932f1058a8cc242ff3a09aa572d4b0771c2339b71ac5b066b88fc930bbc02824b76f32495f62e42fb39df7957e87336ee2a8fad294c55a9d986f09080ac8bb00395ea510b5e87d1538651dca5bcee4bf2d25b41ab5089f1cb90d5e91e6bf25497303d2588244367a967cf84e9091f98e773b0cf3d34be93301c73b4641a5294e6f4443591cecf02ef350ca3b60239e2839fbbe4b60ea414569e41ee9d52696e5607cdf73dfb3ce54285e4018e471257b5427c50ce8e5559d564cdf495f2fab843f3f6628377ca3b72c781d0676eaf2eb7fa3336ee4d6a689b6f8f7c7d11f587dcd7954bd839379521fb3495c25bdf039fdaf3232e3f97198add5ed01699482d05e92d3c74505db494b16c303f56409060946974a4259adbaff353d8abc67dd6ac06fe233da9691836b39a298ba97efbc7daaa636f70e21bf38fa1c7e0448f7df88ac26a8712524bcc8b1be57c20543adc56a8d722f15adea8d7fe9dca06e8073fc58e2be64def1870fe1f7cb8820f79c3d2214d02e836afaf8123027c5875bea15152b8b313ef8e9000a523c389698707e340ab97686309ca9a3c147f3258e8c7cbaa50f78141a131e87c8bf511335da6847dfadaf13d0c2f67736a2f974e1258b85aa1134f8841354dc298322593d19e3c3fe31274a14f7db0380278b71a7ef27f0f98ad8d8bef41d61969e79c819886e9e643a56e02e0b4b149063525bcf6c2eee33cf3db77ce06c91441658f654a509a7e6eb7d597441ec7ba53f4c02043ed3b7382726768dbe4ca07898a97d00e4ef905f3ebd6fcd7326076b3edd72ff8db7b76f108e3b0cb0304cfb2a57714462d0cc0bf4b53bb178085e38b803d9dbb034b0565134c54e06e8bf43e8ce7f48a7b0f19ec353ec356f566290ccb9100852cd605d14b023eb291184df5643070db791ebb6dcb47d335d56268015efaafbce52c54b8503fff4a1f4e625a8ce753db75a412bd08ac126445f1bd4c32eab826b7db86f4bfeb5a2a195c15695e7c1d302d94e6ca538e73e82d30609f7010b3e6cc1e7e05c855e230b2e098cc643b6279ef30ddecd474bd84d79230cecf5d4b3f97d12d0b38be0339c728d79635f3950b585025de5e6d2c2de153246f8342cf0631b70ea77599d4d4172cd65c383bf0dcc43b10abc07733093133a318871dfa058138f9bd34dd313ec51ab3529f941ae2cea2ef9257da7be2adec07c49f8604cd73cf28f95dbfe3bc94f4e4f1530cf1ad2f69e676d45eef242e903586ffa87fc69aa9a1a9982fb6fce01a48ad289a25f8b140a9747d887b6f975f3e7a69f2c58bb9bef9ac1b9a35294b45b844f88ad395330754fd75a236a78f64fb533a3c2c2f94e7c896ad4c4e1148a9d3df849603a41aae9cb9058e7c4a5e5151d964dd17f3edb25ec38b4b1e79d09c2f9ffbc8fc5d0baf74986269aff95bec8da2e8acd48d2f173b5e6e00fd344ee6ae0f6078e123963ac927ead72bc206bc8a050d30828047d86f373313da646919ad9d90c84fc1203af5e33515723fda6a61d654d78607909a72b098ae8513a7ab94fe6e030d69b7b75a0d2ca7e918d3b98426b832e62bc31175cc7f954a297f1be0460813b0af40ec794430d7f0b906fd2713c86ae0a19283e054bf864a7c31b4253ba0d9b33e67b756818f89da4fef205e5e0380ff30500e35d2b6ed6f91c8b263703bc4c8958eb892e1c445dce178800b5c70936054ad24336408158171378a27c5a663bce47384d43b0717ccb476019c9b75fe524555aea896e586c8c6870f8d94bf2d2044d5efcf45c0db0e14a66d0e7e04cf39be8a5b2aa1d0cc05aa8e444315c2c5e74895f537581a167af686a43c3a6fa6ae5cb825ebad99e67ef1e4fabbb7e983ec26eaa221dde9d52d13934a814742732c7faedace96f4625cdb761d5cd6b16fad7a39248b4ce1b958bb08b14845def7fe045fc59c0ad3ec34fd841f9ccf4921a4808407d1f0233f30b82b125bea8da58d3d1b52307b2f66ec8be3966e14fc0d87beafe4173c4b6f0e21a08709fbeddfa4c82ed673f7a19391eac90d30d2e817f970c05be87b25a3405a2bc55616e5dce96516d4fab826c5b73add1cc09559fdf4cbb728cd7afb0d1db3d151d4e199f71e27a8874cb433a736dec1b78004e9c296a8de2e1744618789869fc45928ed515e86c82dc63f6c63f1412dd05a04f2c7c6a3c2266161a5fdde4e77b56f9f773c9011369a4a5d843dee5be3547d2cc597c9fc37d27c3f7fed9f22a522e81fe6cd16d1bdaa034a2d976058f25789ae5d84754a87e99ab18585a43f489a4b90c47d0e3ff923cc2dfb6febfd262ea1548429f9179da8c288f0f2f651168f6d119e76caef65c1be63ccdfba2f03511584ee257f5606af753e631b5b2033e361cc440b5b3d5cfdc75e6f6d7bc624ac96be8fb0603231d041cfd86239547be3595f1fb0012359ecde584e15243193105691b7d079203bc045e94788582d96ee2373cbe1ae6b9766666cdae0a468344ddebd3ab76a07f49e4a3c267da6cd98f8277a07d70d3c3d04d150342846af12d5ed12af13797fdc390ef4ea31ac7efcaac1924846cac4efbd1e912f1257319bc44041e14e14bc2db0789756960a8603ccc511ae1080083422e237d9e352baad5b38fd94c59d70582f265a780e6bdeb47451b942cb934b5c8dfd332951a235e8e81434928851d2498f76dbf237ee6661f8c5fd2655220c886517628d7d0c09041c42f01f3b27eae1bf9073b06e6241088f08d83d6993f95cf6647d28e09be06edb1b15b45f25fa450b7ab9f9d8352432dc0162ffbec5f08b929888dcf92a9740db8a5b915b3e4d9503ad1f09546d9124744d52edb1f7292464b85cc7abfdbed8c8efaf5550dd55e4bcab34d951262845279b9cf6fb51d8676699681201005a6e9860b68d22eff004be0bbf401100f87b8dc5b5a1ceeacc4406db74c90eaa3c7b02356459847284413fbe1e2279df1635daadc247f0d936d8fd6ba1269cff7ff4df9cb49995c6da42f7685b91673d826b0b1135cdae1c28fb02ba8a130653e4d736a8f9bb3365da5b57692dcb3beb186c6899173c69f427799bc2539e6ee00565308121ea45f18a30734fa2e7bac1f6250d5573fbe39539fae675a3725034d1fc87392c779ec645e452ee1d2d2520332a610f7b945aa1e38e417814f43db8c8e38ccf9193533b36776f91139fd994d4b45ae5b7ac89c9b61450289254ff88459839aaca96b79d3eb8dc72d5cdd3275553192f16d70b2b2a27460663aac7b99172911d404f4f9adaca1318ea7e1234b2008d108fdbdff4831553f436ff554bf8cab3e6041e89432dfd08c8e96af251dc3673d6897f2008996419fca51fb4054901bba834bc7e1ab8d5d198317ee7b07842292d58f6e432bd636adcc80bac73ce978a55a11b9bfc29a87dac290abb10084cddc72a78bfbf29487ad41892bc2d0d9577a34d11525609313a36f700668199f31b85c75c27390e5fcb152648efb3c67e1ee2e19fb59a379bf339aadb9d847f7515150da879934cd0c675f3e02d2fc9ebd861b52075fae5b5033bffdbe6ffa5855dcb017c629b804c5cd1480dbf27a084cbe035f4ebad8e98169f907ff7148107c958a7c12f04f0bb15bf64e6932637ebf929185d91bcd411160e9ccc5130f8759bb728f6c0de4d19d3cc59bd0a0e081d4241e6e447bd13fd53dd8957fef03401434360aa0ab8d7f0d345e99e374ebbb1e5113d58574ca85c86190225ae3c6c61aa6e8e9f2fd1cb69f8ca4c8ddbdc67b038e676600054b976eb5ef31b81c8e6ee2ba77e7c4786173b83dda024d18a81daba9ef1c1771c430449456f4af404e8ede3c328feb18d5235116537f9597bb5546ec407d25feb17bc8f043830fc6f5f98863cfa5292543fe7b63f2b305cc67a03093b2957bff8c0e7014b0760609f14a85883924e134b6c2e343b5cb09b3fabb125007b5e7ff974f9752fbc3e3c03c7a1c74c0936feeb62879149d771ed48cf21069af6b98da7e8f74dc969797e11012056052a8cae6da282fe1b635bf6b034dccc9454aba4c86555c3a7df6287058acff4403b294249f4f1be4f049866e9b3f001f84183a163feeb2e77c36b340c78cda936021ce2f7101f19a62361417c0a1765f4ff2d58a6a8f052a7089b0b4bf4d2c8bb5386ad274f03ef52735f245d4d0ee66aa69585503570d0eae9485b0a69ec407d6eb869dc8059521bc8fe2373297c99edb3ad32008e1eb60cef60691d355e26f219087bab7a7328abc17d14f2f3e46c295bc5dfe420eeeb29d341dce547e7f9ab9dfbbf56f5150fc516b902d56d6dbd1187d7fef96006117613e0d1f741bfaca98611ec215683e861ee70b749153d2aef7dae5db3b19125a956279b06d139103450397283f73c4abc2c6421051102f1617746b2d54aa94ba0029073d74cb4fa1476da3060d193f3040c0640b88ac02b363dffc67be7fa80f76def62fe9400a507d994743ab49022bd02fd361865524fe5991e24f4dabfffda12dd530e7af3fcfd7ec1a31fc90ca4b14a98a38d46f388c56a14b40bad4aa57d194bcb9703ae6d79d7ba26a65737170eed11d02957f75176e292448df330727cbb096a63122362c12b268736bc674ce9e321cb45e857631b6d5c557d11ff42a5cbfc851f09eb9b08ff22212715ed6b264db66b10191e743206a28778b90423fbfe0d3980319791aaf388c136bdb4dc814dfb1e9bfffd20d9bdace727b6780475af693f9fb28cf69538c25a3a41cfefcff31e607bca621a865a6739b1517fcfb22456a60cdd103ff7a4135463ce61bbe73f3422d287b171315f06a6dbd28776411156ddb3ca0262b0cf5e026a7e913e25f5813c5b28c65dcd108e301e64d37d711a6f635bcc337f9dd45c481a4ed399e4bf94137e229be657f567deada53f0717301f4311ed6bd2860ff7214fda0501031042cf84275d66e37bcf9104bf74fba1c70968190b9dd926225b457ad027a9dc9a3720e691dea470f477ee93e1bca65cc69cbc227c1ba0e57bccb94ea92dd8715c380894e7a267f1fcde523d92a065e792bcc58c3e2aa537faf4941de00a40fcdbac31f8b7da078221359c280c659e2dc784dc4521afd28cb342aad9856ce705690dd33fadadce7b655fcc555c9156eef3f02b907385f03","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
