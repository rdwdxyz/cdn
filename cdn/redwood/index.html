<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db48be776a728a33675d1bc360b454753cd1ba70c6540b0525fd6cca3676b34b606241da62913fe0dca7739debeb4ca45efea023cbc8d93f873f8e354ca8c25d326ea556d006d9f504e4e9f5991d1034cdb0ce3dd408ff0ab278885b8bb50d688331858537dd3b1aa73f1f0912625e522cae0d8be5fb245edf130491eed920bb90ee4b82ced13a9a6056bb119a7324e50c7206cb0ce359f0b361122c511c304c096c1832f2c00e9e33f7f9169bb714e7a24bae38b404fce5747d2a6abc0cd4feb2bc01ddebdcd0f25cfac9a12ffed2f099e398ef4f47bfab38006be439f617680d8d4e669a538bb948579ccb7363ab033792a53bc47219ce223587519ded978526dd4fc834636cf120897e9df9017f6e68849bd05577d8b0e537ea1db4b9a394cc546d34c96ec2e7440c1f62773eba059569bbd49fd02aa5560d4231ed7532c91b217961867f3c566571e3775e0af97ce1d05e828eee22404f4e3f234b7358bc755e95f2ed4b84aee737634b655eb5486a8a4bf46ed82af947e943e6e82c69089b70c00c0fa2103614a6f5416c52dac665ce2bad8950747086ba37c84f250b2e87d053010e40eb7e309e2c632ce207068e9bf035c0f145608b52ae42361df4123d50658daf1f91a1000bc7b17c3dfd8d83ffb0fa2900f0f19e7a03d65fc7918a4d9096cc3f63517f54780ec3d40b1856bbc5697e716e8c1079e8589e782e2c5789eb19dce6189e5ef5fae60f3b2c550e92fc844cb432bb5e2c8a50e59c8197526b681179b1734e2172487ea0246138530ab3614440ac936996f4664f9d2d2ae4c08d6d5a4cad77e1e5433dc48d4fd20512d1155e497fd095af22b8ce2e230783abc82b89d9f27702008cec15c0c72f997d2d338327b89a061acd54abb5373f4c15f7b8c235cc6b09ecf8218a89bb6b62db311cff4e2c311812b3cf74d771c86dfe4f224ed8508c6233ff3066eed56c573595536c345a5b1c3c9484929deb8a0f4936777acc734d819dd9acf172ac428732e8bf348aac7ba77c88ed498dccd0c450ec4cbdd0547c0bd4ea9cbe0b9194e3ff3d330bfb8cbf38d3a105493c21bcbdbd3c8f6f626d93f183d08ab6574d8a73238328716235281e6af858f7a7bd6d2e2ca1fd919ec214d75859c014460d089d247263f8a497daeb5d06ce3398b661c1d26abc81a1f35d318b027cc5514b08b630bc9cd4c3793d578f70165cc180746f2d49d307c20196ecce16696f14b633491514ed739550b0187457bc448a67e8353f6a8a62b648dc214ed705a639796b4302b26fe78095a720eb74ee87099872fb6f65ce78f8f5c703d7bfa804e01a3254579998d3da44069fd1f6da95f220ee22280adab7f2b34d2b28c8fc99871698b699d938328661b766ab911f85c6f98533227f98a7e83a2d1992808b221c4aa96132b4fe049068f7fdfb7b5263f61fe4ea83ee4c1f066493f0104ff72ac3c1ab754188db329126198cdde99712735bf315e4ea750a705426654dec9521a02271a2764b0ac94785763cccb73166d1336e2583d4cbbbfe0281d1603c687df5782fdacb385f693fa4d611b6d9e95ad2f7656f595f93c6d6e2dcd2e17a4200352be0df8fca04f792662a67c6ef4c4ecf20ee396759e9a2c1dcce380907506470420935d9f7bc15175f5c7a8b60de5b1193ded10690bb554683cbff60f2dc33bdbb2357bd538443064a0ab7a373248e2787a5298a6fbfdcdf44ef06c97ab66edd419a3e782f8c23d86fca66d899c20cbf99af1dd2a3134677eacedcadb43ea719297990f33e532fa6dbce750802abc987b25fde36e5da31e5caeb8fb50a37b42b1c6b5ad660f70d0268410e3b2ab23c84c9b45f2f821e5b5097fed3ae26f95d1c0ed06e1a28f05a6ebbce1020343b37877ae25007a83720ce4e6f060d59ef23d98577bcc94806dd9d6a2e98846ad7d118a9bff045d3ba58e82f1fc771c996170807677b07497234761599e721d5add87f4784c0aafeb5bc5bbe31498c048cae92b7085dea0276556f1afa2c0aa40f0d4a12afba5399b4d4036db139dae283312fe373d5b376612ec5195e9d66d276077844a17483fa977c8afd4950f4c773a54d7c8fe0f34249970dddf439e43f829ffc452dbe2d6b0444e078d96b6fbe5f68226fd790b6e36cdab62919ab803566bdce4fa0a1077a6222df36e24d41dae571d256ec3b3196821c29eac6c7325eaa95e35d17768ff6c9d31728a3ff2d9b1bb4dd45116de1bd9b5af3d195132ce47a6798e85c1d0566f5c69aff60ab53c0b6bb727bb0b89800286079991cee1207c52cf18814e70b8f7b6e1e19c7012a4bd7de1422457f49052277e9820224f37aa29af2b85bee7c2965935955188e33668b9ca00a8430fe2e532fd8b3d0c94bdf42b3495cf880d3e7b4428ff7e3325c2ab1484cd9f83e2ad8426e62bc6127e7403c800d99c7fdd0c5452a31020cd277c6692351e92ee99b3a9a29739d5d14c82fd1eb96e9fe63297485e9254a211b622367f747542afd89bd7653883e4adfb17873b52e6c77fd8b61c56eab0b3be791062c2ae2466247baa951d4eef78e94e656baa79bc79d9d12ac4be3376fba3bf7d72364e6d8902327d113af39570ba2dc6d17a1a67cc00b2a9fc8fb23d78b1d2f56c7b749d35ee7e2f3880791f11599747f4fcaea585b19bfcf38feb5d0c2f0ae58d05e82e2f9673636f113d75805bfa7d25358695f943f6da40837935e0f53541fe35a1bb8448d83208ad3d133be27c66c7844c749c7bd171ee8c6bca55822e9e88f4936f5d80daa8786e67b0605895b50b13ee959c3befbde576bc8b5204cc1303f7e6ce50349680a119589e54e6bd44b0983aab51e78e3c51becdc5a8a659deee0feba0318e2558caf696acd10f324d273a0a1d8d7766b03cad6845cedbd9368c973f0fb5be16567e409853466107d3f72e277a45ca60fd77d8d7c82476dad322597df7400fba8d396314c804cb1dc4fcdd0a112ef1a0161465f81f30bea3d0b3bbce41298aa492840ccdfa06c1910fa8305273fd9d301967776fc5545ac265eeb792664e3a92c1bf491a00e8a1d48a311d3614ffde853ce7d982450685a1aa0be5451a8af9a785f6300bc3adae7b38ef67a5203786d3d55056b77b630393acdffb577a39279dc28fbe392a63ea35f31d1e02df31abbb5162b1ba8c2bd3096c654f46f9e8fa5107354073f3229a5b8c0c77966b62e432fea9d27ee8ff658006906487e2f78c2eebaf3c03c2504198e410c4d79b42f8c989d5b26f86e68a07b218ee2d118c64bfef016826450f9f252a1567580e30f3fe57d7f5c368ac59fffad811801e875fdacc321adbc2bcfbe984ad9ee78d830cf623bd12e38a9d71f3cdd74ef36aec2dcb805fdc39503d8a5a5d4f0682ae31a096cacf844a69a80e0d5d9920307d7a2071601a3a5ef0a15220ea79a34b5f1ce9cf70d3f954a041d43fc2029f09486fcfba1915d4a4397ac43b35f42082781099dfee2a398880206138be285b22dfbda8a649fa3655a3bfed27d1794afda4dc863c01a833a807b4fba02f3e1637ee89983af27162b5d9befa98a8dcfb9524e554e7ed5d41c27d5829a735e54fc52f1c14d88e489917317806398651f9faf4ea958c1903d4ad3308af7fcf9d6f158354e2de9fd9fd065f8563dd28499ee6472b7d17377dd5b6ed974c3e7f296115a7f0f3b283669dfc0d7d7d70b028e87c9849f4aa70fc9caead0d6a5fc3f83384ef77d6bf626178f30d3c5ebce3989dfd6d5e88dee1853cbaeb248368868a735ce9ebe12d18b32984f01634de67e5903b4506bae46f0f5f23296316a2ce2017dae9706d41822a55e5f44288409f378b81127fdae30a47ca529d1631c8527e5c01b8663f6789154eabb2ec5d6eefdccec274a1f53f7607763a3a1a813f4b50215fb2d0be78fdb0c37ed0d4571d45c0bbabe7e02493ffc7dd6eaf07f2c79c27e8caef88d54f545d90097b296cc2dc59983cee68049dc6db8f62f3bbc8542090fdd01f485720870fd0e7e0b789629d23df2e13dbd63572a2394dc8cf48e45325fbc77ae6a3a2ddc0ba5de8832174c533a0b11bd2f061edf026e4d253d7279307784c5e362d4fd868e56b6efb573581a7461f6e48f16367b4032d69324360a838fd4f34ac7172841d9dd0537bb80f74e6f24c35aa9ded7b534973a19103c44f590efa15ee91466ee48af9add717eb80ef6daa6904ed1956a1c21eaaa7e8adb113bad6d2f4fd5c66c3c2fe6bc7c08a317bf481c6313efbf80247262c24447982d812547a0671adc1fb02215dd1df0d86eb5bf675406c582d43e3cddb5fb0ef3495a0e6465c519103049f443a7ed0c4a3efdd9d1733f0781b6af000d452bcf50e6879015b8ed7c7ad22a1d79f709ecbf5ef206ce30c739c7aede6ea8a8bb09a53d2451f863f3bebd0b3ad0edee65bf79a55674e94c68ebe3ad55e63479b2fcdd1264d0a39ede51b0ed1e8944df7b24c7ac5bceda60bc66844d3177acaa8181d0e3306cc23876e1134f92616c57877c1f0a101ade65205d361d71b9e5fec7cbd4ee1fa5bcb1f67ab1c172ef24141e8d62ce0285aefe3228f169312dc7d0459c34c745bfb2a65ab7200dc05a9b209a0a25ff3fe9199e882408622bea6aa7c3ecc131f85cf49e9137b177367a8e9b75c5f07edde3873a000c009fc97c4eb8678e377785b858073fa7db41e85644dcd3f5c6734821ceb95692acdca381c7896946909391149b1c966dc7d4149434c69946e05da0eab598584954029b094a3dc77ad33c9efb12d89a56510bdf55988318d4813dc37f261fd018655c88b85755b00deaeec4cd618f1475102ff76f59fbc6cfb236fbbc6cabed4e3b6ba2bc08abff72fcee68e34f17d05fda7ec99eb25c1d901dff5ae2c0a5d54c72ba8aa1e2b4b57b9b054cebb77786d97dcacb873003c7de3d63bffa4e41451484b387c50688af51b1a811dac0bafef40aa73eac43ddf00f380c1ace36f305989c1696a4edd6d09be03047a77ed593683cc32e0236f0655b4a91296e0fc3d8ed3f222fcb5bf0a147ddf301cc243dc51cd60778eeb334fbdf88cfbefb3f61c53cfec21f23fe1bac19fccc36d780b5457defb7cbd8f5e4d9bba263364e2e5c13894a39fe84cea73c28c34c474e28a5f83c9feef7c0372e247b5da5e684e76ebbe817eed91c5fa8f621e33c867882918529016f0697fe6ebbf312906b00d1ebde763c86d3b0927e0c429e3e60b900af5103bfa988efbbedffb1547352213bae1ef4f2e5cc06eca498aa97281f12903f38cac9ea6345001c55bb04a444a3d81b5bb084d55e630862f2bb75db1b1052ffab0d08f82f991987a27c673ebecf187f6d5a888d905854c7434dd8aee9d9e46ac7271695839d231f4b24efe65ac4a0f55790fe714db997bd14da37d3005a00f226236bc95cfbd9e9d2e0c22c99aa9fcb2722b72f28a6418f22458f027eaabee15a3dafdf1050b5e52723cd893152c916db9d17739f81c848376f0881b6b79033e600f9a744e86333cb8943e44bc94ebc9d3401c627b22b763bea126c8acd22d8e2649923780adb6c9347b6329f172abe89d367f95c5542e056821b0952f20cdd1e80fee4e9832a0c1efa900b3e628f566cff82cf0a6abce9c6197b34ab1886f8093af9710ce19bd3a0631700b71e2dc51066da2143df166446a9473616bf05936a722f2973f2c5b3ed7362c4e449da07dd414a2005f20ea0ec19f9c69145f6b8284d23052a1cdc08cbdbedc63d1f4f4eace01f52dc04047ede2c620b56168aa7c3ab6a172a603db8c6237e08e3feb23e15dfa46474a3aa709521a02318ea95cfe770444f7ebcff293bc04e721de6332795f2cb8df6a5d2de9e038b63962c41a3f8b81db795434dafa554159889722146675b9a3337d5a9ca198fc0a330bab07b74a87b2d5919c58e24e2a9e78fe133bfd5e27377443106ee924a2415f769cb42d8e09147fc12641d8fcb51e5d5fdbede6ce7735455078b3d2d07fcbcc78cc94d1897245f12b4a38248a4d23113f6f0357a2aa9053cd19260ce15859874715cec24b5ecbf0a4fb18de1a8709d9dd5fc6a32ad1d35a39a206c33e92fd73734921ec31ccf6f6d82b970457be843f937f9a10238d33fe60b89a4b34cac249134870bd2f0bc82fcd5ffbef22de9b057ea04e2f17303e277b30add9f83da99a712bd72d75ffd5a239950a01fd35843e58410ee96996b232cd1248fba8efd981a2ab230fb704773b8a3386d53b3be30c95791b5b53eaaaa9d26b4923ee1415536f39c00f322808ce68ae83d8a6862bfa157b7c173144b63ac8d35a8d21919eb5e39d9fd28e182f643029a01fd5bcfb74379761b0ecddd7ed622ae1f2ce627505eb28cf6784e456e8a36575e13af9263d255640863c36bb4bb9c117a9dc9e3647ab317d0d25dfa04ecdadc935ca8ab6e55584e2a416bde8203ee3f0a2cea7138e451b2ff4b1111197d63c3ca90f3c3a230720f89f63d9613caae8aa5bee71d585bb64517d1881e1f9aad27b68c93d5b8ef6041273e1c7d9972e6981e263051f57e00f1b6068b5d56bb0cd2ef0fb18923a2092247eb51802a70ec575b07a82d79e6578b04a4e8a3ef18b9fa425dad8a6b47b06805c9fce99ba08c24e86172cb7c0f3ec11545b0b0c1bc804ec27fcb6111904e69233b46b2757aed63daa0ecdb8b1cea4872a039997d8e212162e7d3bc74fb41a265124ae4b0669467e989d9ff0898ffdeb23a7b38d286b5bb5c5a4a04a88af0333600b7d853812071be99f879fc54d8ce6ad420e79801683b09d55f0d7f60d7c9e1bd5b1bcdd40f720804c4eee9eba474ea4100d0ca4475658dffb9fe22c07b28bd97727c621ea66f6efd5066654d8b0c4d3be558957ee3560ce845c8c49bb834c7cb1fa66ed7f54eb767c5f1db506cc90c7bd1a6a4931c7b2aa512542eb7d80249ff31215113a53c011193eee231efbdb44227680b12d74481708fdd26116aeefb188c633a0e231bb9953cc906407de7b3320a23b302cd20977674dda6c385bccd32279a3c81cc84608fde4a74bf5dafc9c1c152996518aea2d6cc7ede2a07837283ad4601400aa96a1ed6994334e355393763b2ca9ba51fe0ea066ba66c350061ac8a453837ab326c8022877ce2ab63c47ff997f19a57bdd8695698fe1a7185c78dc8970a82d81b4a47a6dc826bd676c959b09b5e886bb59f47e99ee3866385a6b8be9fd66191975b341b99325dfafca3856bec2f005d52b92576ded721e34ec7cbf7fc1e164cae57856d8b2ee6c84b147ba62e030970208b8a0e34fab9344d1b239ba520ac317cc78d20c430abb06beb810367c02d04cfb4fa77d4080e8649218fb72f83865981f8fd86548a848d1e4251721950cf1866690c2be541a50f430eee05ee0d3189a76939398d1a34340d686991de7281354e00e57646fdcade9e7627a5a3a27271aabd63ab3bf46a9d5dfd6809ac576d8bbfcce500ee6bee5e83dd88539f3396c42cd88f1270704c97ab5c8129c567c82f8a67754bd463c94ffd43c03f20e5000453cd50d5b942c926cd5445b76c831c42d84ae8d1d09b7a3e8358287ad48fc8fc3aa9726ee797236a4b4a25a8f75a26f6b698aac050cb9eb08ae9afb0362f5af0da5ac609773df209c518084d2175edb7f3f2f535ee8a784f172406f4de6d92e3b19d14fcfdee0056ddaeae167b724044a5145ba8dd9d69feb7c50316f882da2ad31592f9af07788d654f6812b3d4d07b26fc30e22eb2399e0424c7b8cc359bc6e80e3511d5470c8f058efdf89eb0bc60b5d2f39df1b00bc5682adad6349acf01ed6fb6106bc47cc489083d8295c75d5eacc071bdae1d253e42cda4e7bc9436de9381d351681041fec3806e2f7f682a05284dd7b7034cfeaadf9064870ee3ae182f8ba540e121d8e2211bb52a3004c1e3058681a5a11869fbfcc71c9714bbc387a57a8ed66e7e7916f0c6d8e98e93c9ff3f5da3401b28d10d176a2b3390e56b9dd231199035d683fdce6decc98f5e836e751170af1442957ab0711dcbdf3355aab05471967606f17deba9f10ffb58f4b353d0d3a9b7ebefbe5211256a96f1b14b3905867f38c20d92e98efa3bda6553aabc3baa69db9e756a408006925839ba7c168349a55de8a9e39de2092e3b354e47e583b3cdca5df5480014b36be59b451562e8280174fdd4b891d0ae5e9f74e0cf932a33a4ef6d68a50cc1ea4671e313a0ba16dad5e686247150ea2ca7dc9bc8b3c2c100af2117434efa60499a3408912f7aa04258492b957c0421f7a46fba5b5235ffb2a3e883cc78583000255de124c662495bdb0faeace49b8027dd68e7c01cca09546e8cdbd475af9652aa9c4c1c6413fdc26a95906f8ea1616b8b8ebd1c8d7e48d18c4b83f12c76bc3e619cd39aa1007c1b18af29d7891209bb8510840e20c3b11f2aa19211c9488ed97f7ba1d2017c360c0fb0071658dc9507bd1d093008d402c48089432fa8bace5cdbee14729eb0185c3c105d4dc290491a778d9b61fe581115b9a2af1f08a043bda076ce78a310b6586ec950b0d4d98e18c0cf77132c7e52afb4a3fbb6c1914fe43fd8eb6d8459b22ff26ca1e1053e09410c12031c479e6388aa4bc830f7db3a99cad5a8eb9e16b7305db3b51895ee0567f94210818196c31abb4713f8989e7f818977a671b4462c6b9f486802078132bb117f26edf9f8bf0d9a2cfe18455566eaca1fbb71369d5b599ff23d61243d096066868edf26f01c6afef5a231d6ba28e016d8ea32db9d205ca8f89470dc18e59d559dde32191264b352dc82ce152ddc278d94411d38bb7d196bce128bd5170a7d36c39d56d1d5b1eacd0f622abfaa88eabb50512070d4a7bbd3e05c9bcd469e3ff5a9a2760c901d033ed247ca5e56812766a7ee279b7f951568fe73ec49e37dc84f20b5af16310fd163dcae50efe81c9964f3ab703a287006e67a73df2931e3893440e7b83186d014652643467c5a2f113f1d85fc5ebe964d210007b5dd6a39db97feadb15ca487d5a9e1dd08e7cccd0514fa7a69ee5c16bcc1d42096261c5ecaf5707c88879396ff1df68b7dcd7c0279c528f829a367545f78b713174af1c39b3d210360039f0acc5254435dcf31a305d1af9d1172108e0ca382748c4f6027077218281be821d28a23ce03af7663d8761fa88f7a8504936080b4d1eef293c8990047b242e1e6061d2f4619a53377a38d259106c1240e9d13ea93666b257a656190467b8d3f7f501f3bba49ea344d2333650933583a8fb3961a803dbc70dc803b7c72a06c256edbaf05c62936eddf96616d853e92131e09413b54897b120896342f8201672f970e4da9e0d09c2105b51faeb9e81917f377ba94e39266b2a4869e72d7b1ca99db75a6bfbd53a0387c15dd9259e902a26230cee07ba170930cd64986e383e85e6bc834d14b6aec6a0eb6454d8a24558cf860dab4c6c85e8ac00bec6d08bcf50ef9e9de571e1b01fa7c12fd604086c132828cadf3786302e727d5f9251b195fe627c6c9abe9586e385a8435500ccad157d7fbbfccc92c339ddf8fe3c40b3dfc2d77eb853536813ff6726790cdb384f295a33ac2a0b2bc06f1a7e22f0541d808216e55549b342a88e66cbf37dcf777adc3baf45b05c9da3391ce10fb13cc19041dd653fafa0b7ba5096420394eb621048c74981f8fb96775bbc91bc784ba85ead23ce68adf9dce2803c5197c58ef797c17d6ee0e80b298d9cb98cee5ec0ea36921089c0fdd781bdc128f94903c1c5e3d559795433fee20c6adc3bd9420da91fd3fd20de9daa2f0f7e61f6f0b111750fe8814f1cd70b02034a3e84feb4f9d0fdd178b5fe1fdf9a5cb5865fd3930f7264737e2990ddff057e26dd78cc3a95de4186488f5a34690f7ad7a6feb7e8275048ab25611bced46a0051d77e457388046178d661113b6d186b218740267b5e3cc51e50f64dff5dc4ee9ffb1799cc943953a24d6b0639a8626bcd2f12e0c42ed79ac60ab0b4df9b452e712bc50162fe9756bf7b2e8652e2743a5890962b7feee7ff549557d9db4a2a3586bfc70f5bf96a7ba8e1c876d1b506c282d5a8eb2da8023791e3a13943b2fbbe70511e439879f532eaa63d4a749b035fc99c87cc0d118ea500d5e5b64d894520d35c53a0d99f1f7554542b797d70cfcc364fed1b83ddcbb6d46c19ec3051697afe3ad363519f64a62ca0c4bd99786ed56dfa4393c0755efc6fb15909a71bc0f3532ceb79ced9dcc46219940b290907775e9b542efe938325c137180fa61562b7b6a48ce2d67511f000df25ba2e6e51508ef13a30dbda63991181176659a1507ddff3a85f98f0d9ba2ad1a98ea313ff709b516b72044afdde0dea6b033e02debde3d89605a6a8ca2745d7df2d534a3ad959eb88d97b1b2c3b658f50d39dd413da77692f8cd5fb4cb0a8bb3721851276551d2f7063e1b22c4e4cab417735aa6c38a85d4993d1e976719b77089d0c9168a9018fe4320b09cbd466358838367ed0481b1dbe1f9545cd4e43eec47c41884d22f84185b22024ab9cdc6684362b462b0d558dc8098085de7d08fc123eb551ad206d28490723b76eee922a0fe6b68487c85edce6d00545fc031e241600a45b92b126ce04e4cffa0a85ef38925168bf4b5a677f5c35153dcfde7ef934af7d9b1e4e68ecf575946472c2e377f0cbdc8fb498391e2149759a4cf8f92fd4e883b9f9ccd3f67e50ffd06d722984594b871aa987dc7af30e988ce90126ef841200b830c1ce66f15ed79564e10baf4f7af74efc3829e6954ac03f4714ce1ff5a087765aec47e02a12c5ae1218899e6a9de953d3f91e8ad97abb83e1aa64a6caa9f948604777066093282c4324bce56a4278411ff07e0b663570df066c1dd55b97711aee81c8753cc69f585367070062a01899c8a211a65026e5df2b44610a84f955c1d5f2c33f91b72898352bb0cc0047320270a8617feb8f4342c3dc56f39972cc81b04ce41a4228a1676486a042d9a4c42b1dc81a2330d473b2f659aafc564d2cbfe58b6bd2800a59cff897888de21de7bbd7242e76c8b306a998c09d557a0b95d6de7dcdae98b30e39e3d63e5d0a1bd1c3e7c5ba0c76b6762e8aff9e93451c385c4a559939ea53afec9254ac2c73cd1946dded2c32bc0a63e38cecc6efa9fff6dd71ef50c945bebd26bd71d5519bc7493293c734c3ffba5b47adeb99973c8ff0f1668ecebf6ee2d675f5c0687ec3e2f3cecead8883216057cb822f83fe156732cf92fda695e5a544d8ff159d5cfa5915312940719a2ddaa46bb2a65bfdf8649f57f7ac664a36f1be33b99cd979eb4366b36bd1f0d030d38bbac7720439edd714a65bde8778a62e1c32d8dc3b9436aa98a7b196f78975fe120b385dd71dc686e1f9929c1fa123b712ce335d5ec3c2da5d18626545ca75959c58651fea00d9c5ff4b933615a78dcbee18cbe6c706de24ecbca90cd28d4e635549ba8f85689829a457f1d2da4b32dd2e103f5510c6231663a214a2594abaef3c66749f237eba27cf56335942b306332278387d9e008492d07ac28a9d3a613090bfdabc513f53c01e64f8cdcb55c052541efc0ae650e89539a0f6533fb9b643d239c2f39060541fc48404a14469e17f27fc80a30e39b6e5ae5b09cf0553e8603447c5cbd691f8675578caecd3869ba1865b48c581046179caeeaae930487e497181513205b67fad0e8cf720351238d3b97865df312ca17093373e1b43ad5a38740f6b7c945fbc910e8cafc6b92c0e0f2e38391e55a3fc344be34a60e08195d7ee1866d679b8bde37853f8965c1f633f4c693b626f2f7719255235215c3965dca2dd5dc73f84e96d7720a7162914db654f0e77765a15cff85dd6971a4eb3b708ed5266503db770e01876c286f119c8ce3c7238c7b4bb652d619797aaf43add5b1f6406f2c39bb7489d8ef6c70951d7c999b106d480eae65ebf271d480515b13f1c4b5cb2cd08aba179051bdb91a4cc64484b157f5f4677d93222a15d89fc3fab54097b7b214b5c36c7cb7605700d928dafd10fbc9f41962694ed62c4a45c3b68d3dbf7a1702274c61b9f1dd7394b7be66033ed2a1413ebe4a758e4fae79bee99d3ae51dc486606fbe25978ed26c080284cb62901787f43fd574a5e283b72738815c26aad1b64fa65f6622c08618db2c9c9eb6ff706ff8c5bb4fe050b39155f7ebdc0123d3e8ece14d9d794457dda02b0052bc970a3f703a9755b1f8c64be00544d15e4e875f46bb8958d39cc253e6f9fe0d162d0e174e36832d6498d8f4626da73a43b78bfe208381166ed909209f533a173993d99d58f7f5f5ec0d798ce83a1e3afc28979bc0257a225db1840cdbf6acab1e1d3e522725bb81938324fa453a94c6fcd336a8af8150d5a025f989ea43025063a605eebd226467f67d35d39c7116a1b922320eec1c169b41b11b5011669ec5f218c14cc214d3e230e5787e91527bcbc7294fdcabbe875df178df9f3f195b2c6bbb74faf4b59bca651b786835a5b449f55fe05ede1446fc7c3fc31f0d3072f87da0db1b9d50358d3bcf5177c130e751c8c653d6dcc4a6de2b0cb65cf8cbaec9eed5008d8cb21600ff05930441c1efc0a560a0d375ceb086d6741d1d80097ec22a301aa7678e1c0d16d01e8379cd7d81b3dbf9bb1d3f3bc8fded485b1bb11559f1804cc3d9e9cfb163534861bdaf8aed3fdfbc65384507c309a6d8b70b5e2cc5c887d6b4469fc0ab1fae9d1a7242df8a35d82ddc88988dbdd43ddc5877ed7e5c1a46ed02112c8837849355f6cb47a3bfe3c5ed5fa04afe8d8188eb3bf8706cfbe806b44ab0f9628a1d9caa603ac1215fc6c4c676673d067d135c140a8afdbb0b236bf98ea152556ead246fef04292fa5f1c3b756d8bbe08204d314aabc16126ef04c85229b4ec54129cdeb4f9078c51a7a4a89e1a946296d59c10e19beb9f7372f32872cc4075d5b987668eb7f15bf575fdde7388977335f78661b55c7d1e120ea345f67e230ce7ac942786b4bbe09d26c451e44b7e022cf8acd9e962dfeb13681b93559e64ffd06da3cff99ff4a38f3fff5af371bbdf30292e608c7ad124ccab3aab25b6d8fa5e3f9976c7799143fbb233b55f2dd8ad1c76286afb0f6384f4d2ece7a2b9bea6d85a684c9e8cbb9a448149556dc8ef2a0da1cd8bcf758a43f31711b5b2cfbf5e8481f04c61af10e7aa41b7189c45d517d35633658136aebe1a4954743ac79a83c3dcdb60c8d046dd8957589859628639ac9460a34df4f9e8db9f5d16d0cadc276012416739ef59324fc6ce962184903676df2cfe6ce5651e15358ee4fac63f4917a8c2bab8b80e07a2c606d5d30f59187a64bd0a122f8c563264f354f65daf75452621e59cd5800fc88e9e3f02d2b195eb227aee3f6ad08581105c4a84818530cf2d9e16ea3431640dfc09e75a119d6d0913e87c7b470b3b34497a4b55e5c2368a10b9e5224307ec030218da69d63700a96522d33d04fa17fbea9af3e31da2580e919314e742d6b160e05bc5a7ad95e7f8291a657e433a5139f7734cf3a46c353ed007dad2fe4fd7494212acdb8bb885438346ced4263c508f55ee7283762b7754106a013ee9de3594b080c375053d97e0818e0b29418d6b697194f4971e5d682f8a8858b030db6334801a846c88259a86c1700932e95531c856e517b7177e45f58280d5c5bf154bbdaf9404971b8b53aff0fc4d861452cf25b63054a69d6928273c3462e43a3363841cd3a52a68511c3df7b741b2f2ed632287a26be2106f228f2b70b3fd4711b45bbfa0831a28513e297e48c027cef4bd93dc6b6388169a6e26d499e64aec92d6bf6d9748ff4ade38b0a0b871094a69da78d30d6015d3b94f7f238adf6f9cf1d20ff8c3b5399e08b04301da0d6d22cdd112627c0df28da6da6978cdf37dbd153ed8270d5dadf740ab5cdfa3612baa1b7e2ff5ebafcf61718c6760f37f6aabc5db4cd768075b1f355d52ee1e277f912f84268a5f2d081d2ea39551f4753a14ea85499486fb1f69204f78bff8247179807a7eda0e9f4421335d55685eab775b88ec1e511ad3b89600cc7fade70950d4481b75766b4ef41b7c59aa2ca3ea229226a74f6081cab7870ac9143093a5eeb75352390e21a1890082337c3a2e81efbffa6e09b2d24a931f5fcec665cdbbc5ce61308c2c0452a7942b47fca8d5092bd4b9a08fb0af7b07c3ac5b17e286eed15cdc39f77311cc753a9a5d87e551ad9e9df5a740e72af8ad430e57d830293015da90407427692943dde866403d5f4c3f491a80898f7639c0de814ee74950230ece93c2a78c56e49b8216da33636ed3fa0eb37a258098064ba15a314000c7052fc6a3d4f5f3f7ebc470b122194dc18a6d8c8d4e10da8fa219c7788dc2f509aa0f8621a806ec9287b62104413c8b870a0a71821b48fc70a4c3be03669126f7e49a2c0c5851954e1ce3cd456e0fa125a64cda3faf492f89c012842ebee9a0812f799f2856e97a0a221adc228e32805aed8d3272cbbaad9346875be8ce7452e7e3173c5b55576c33086c32f1a061fff1beedee8e7840b6a98462ac4cbc01db1a20460f344d55ebc3f048000ddce0daa2a3badc825747a608a863c29b37001fbf254431d7dbf3d2e4f92e040604ad80706dca642d016df05c9400f7cbcd9ec1847aa939489f0f279856f52f595d5bc22e3e9b0b6a31807f98f7770c7791ecd4c5cfeb7ca708bb0729b050f045eb8525dbbcb6b13386e2dfc29bbcaf362ca15f1a84b7c15ce12728d3075342ce0949e3d88d74a2ebf91ece27d49b76aadc05feba23d54d1404dac89fbf4178bf210db806991194dc93289ab6c4492121eb43b921a1c4a7abae1c6e48dfdeb8094b6e7a7baf559d97e9b614d84e8c1c4c32f657b035086d661ae88af2a43e35f959fcca52a1e9d2691eb9b4226484b77891e7f8d5f8a635a37499eb8673ae7b2eb2f6ee6297093ec7051b2b6905211a0af6adf91894fd1b13400955063807c1ab0d9b335f698fbc845445295d0395555450285b9e9bb2af0d851d7e0b1c49efb4ec476d9ddc4f794a15d410fd9841d3b3b88e8a75c419f8be937987f0643bad9c1eb991ebe8c628e6c09dbba46d684d952aa3d05456a7d884d51ec77092675693e5ea2940bb4e6e348196857c3a97e1f08aaa7b41f4b43a4a3f30339aa17eebf021ca36e81041cc89ffe8ed4f5ff0a9d1b7bfd30e604908219face9f60d719f93992209bbdcb3a757b148a02afc86978cf15d9462ae60f70d18a8cc2ff483183fa523307b4aa4e58485c5bf175e7d87f1e7ca99ebcdb30038be27b51df4dc48ee8614b836366bcb9a09ab0536348ca685d2095a583f06af1164fe2f16b3b65db4c92751fc653e9b7180df83356dead3abb7e03e6e52c26b79e8bf829f4583064f43724b9eda6816da27a9cc76ca6ad06104d4942e12670eb4bdf0b06ae5d680c29f3c754269cbb9559f8e7a8db75b623f785277b45148cfdce9f502cd9e9363ad1efd30c653d985820113b43fba7e38a42366f7c4c7556f7d6e33cae63b9d6fcbd11d9c46c808f5dcab20614bf08115bd616b09e4b95c980d2ea56653e0eb1b638b78fcd95b8b3cd4e76610e3463cad42500699835e41180899be3b784be7351b00e3d9335800cad3173eba3883115113620186639e69f082a33a1f598295bbd6a68d18e8f5e56fa2a49d89d424e7a38c8cd029f209f52c9091aa1d34228e0e0f7faf54bc4fee878c04f96a275e3bc02329feeff86172dc578caebc101a49b469504970f21a7e3ec692ca96c19f0220e60e283656251e86598c918f66c0013b9ef8ff82646799c4edea50c4227c94cdfe294668dfbe03aeddfaf83f55626c17358d53464306eb362961297434ca7d2c23b633542ada8762f6a3123cf6112d1a1d186de197f046d3e04ba318e7e2029398b6bcc5c677647ee66ca61c1d514033512293b35caad34cf0b6777cae8e10262065c5b7a8d2c3ceaab4e51a3c2f225fd5e9f72bf6860f790f123f4ddfacd64c369f6dfe1a3e7e2c0ea31a1648a8e0b52be34cab1d53cceb05665148fe306dbdb4af5549a9fd37a6120f4ae7b4149ea79d7d3ad3ea8946d05334e0815f9bbcfdb076f9f8ac5207979eea79f8c3ee69f60e3535d7e4abdbf96e12440d3dc300940272b417b2c788fa556497a9b2f2ecf51d1e155a78026f25e7a6ea70ba4c042ac9c73bc1a2d84c7e152b056db993941186a8261d05d49c511ffa1fb170709c1dbefea27a9b6b7b26dcc0685a86fdde8f67d21cdf26553ae50066e00f07b1aa9d385572e2f847703c8589a7dbc36e9c663a72f7fd208ed4867701b8e054acf82fafa67afba7c3d3911a3edd429e4bed5f89acaa430f112e7d70785503bb7c2b1bd4efaa74b6fff1b3f43756eee01fe2d7db6f6b42da15e0e350b7f9e34e83c2264b6644f1a73ae6862439308d5a675276cdfe771f2eb2821336d9aafc96085edbee812bbd8824c47cee7c91380f38d8da793c628c921861d565ebd8397210f334aa6fe0738369cd5536299941666fbc4e3f6467481e319956b1a566b5da166a615ee4c5b4d74545ff8252e7d564828b8ce4a0f314e6f779408cbf1bfc8536c778d5bb7c63ec2d3fc78e6618f8aff3bb421cb9f3e8038f076c705d0ba96d385714132a8b156cd7c5297807d6c58f5b914fcb9cdfb46248196d60d19fbd72c75b4bed17cbdc46f033155828ece93577622d53b5ca1ce8d020b62d1d85bd52287bcd55ab346b916267d2398b48b63ceed84b12b8cafe772b08bd248fb28f339b07b95f39a1437c08242aab7aefa0befa8552e2ac31f3beef734dba6b24e3f06684e25128586c41bdcd9e0693d43782526b9293f63aaf2e5f87e0f564525a8a63b9230fb6dcf943f03db8f16cec72307363dd96412fa54b41bfd63d0de4f80d7006cb80dd07ece662774779190cca34e5a53aede0f0b0f354fb1b7084c4535834901632af850b17eef070193a0e2b731ca6238f8b79891a9a1fc74382ac2c95f726d9b35f046efc5d488379fff4a69e8824b50443cce59d7c0986c2969ebfb47b7692dbf7eaf916b031dabfd36e26ff44ca352c3be7e4c439e8875091408a06ebf554802bdc9dd5cb6416e660660d7ea3cd8ea1d4bafbaa9d469ad6f4343b377f837386dc7a5e9e9f8ef4939e25ed5d84bd3b0514152a90ff528148e93c53a6080e30de693ae3eaffd073323834b73fdbb4ec7b7c5fb7b8f9e1bbc69d3870c988695c9b60eaad1468f57655d3057fab0f5bac5f5351a69e137ef94fdddd90d8cce86a530b9ade585d25359c5685c3ee1d6ab367547796ec06032a53346becb995b15dd0322ff111aee5ab17c2e3808a0dc4a604179cafae19691cb3151c13a4de9d9ed6e5e710336e40a12a7ba6ce07fc5f3a8a4e4f86c2f8a6984544d0192f1bf9136251fc410abb510e311594ecc117c92912a33f28cf41ad8131ae0a32773f8e99a1109c08ddc88268dcc9a0530d6ea24e0e3d149f70114caf600891a643c9138712c95aa8a8a759295c0353474182dd09ab507431e6871c49aeabcb9ce635fbb75ac7b9d166dc6917be83ffea5b309ab5b6d714fa8e101d1f986b5a3febd036c9f9859295e487998ef8e7e861408418e9df8eb717545fe05c6bc3600d3c7f22affaefc760565876d48deca96d7849b0e959363f3586294563b3e32a839b08863cd2e6e2c4de6551443f1b1de844b23987c542b8b6e18a3eb565edc8c83141699163f58d58632f65d6254ccae5697a9b627995c153ae6206a350625d29400181fbe102697d0e0eef40cbb86bc8f1a6e0010512c86547834e183b2365ec71143f65e88cf370053811f207e9a5e097e3abed742f2457e852b70f31bf245de077bafaa6b00271263ea835f5c91b7d49b000cd0e3f48a06db644461e4545af0a4a45487d40316795f808d80f8d8db30a53b91f04e846c2ff0a8e7d7f9aa1b264d638b2edc1e5fc3f0ae396b0ab144382d0e3441141416f6dabc4f6d8544b827f21d39a4527a02d61c73e8da9c1bc76b06a781b7bd5f115a4040c75edee673281f3f793d2dc92105ef33ef3770b7a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
