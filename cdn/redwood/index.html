<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ebf1c7be9536d96291214c9a9ef3f3d7fc13ab979c237117b7a319f8ea28ec5571aef31b03c64099148294cc9eeca358a8f3c6de67a55ee07f86f1b63cc12bed34d819be591a7037808f22dd34e3df9ea73997e8eadcb0671e8ed7f2eaf42d0b26129c541f07656752bd33d45ea8325e949420f448f877540518dac0f49fe27f23ce74afa3700478ef7ee645059791f61c19105f91e6ba284feca43f2f7780508f718591f5a198836e9e533ae37ea986bd26a3178d76dac4c00ccba1cb0453496027b6322b9e2713dca4451c28ffb8658ef9204478f25394cff84ba75cc31d2fcae06959c30f0f6eb1b7ea10dcb8f382b0b3068341cd7a3f563b599c691e3370b8a81dd753afd849fe7d7107d718aa52ba03b5aa13b2e649cf7d94badc27d22007abc95405125f6bc091dd876ff4010ef3e6684803f7cb148465509b4479510f2e0563212f4f052287b18f785e22fdc6fd3da8930d9714ec5868eecbe8a08d017b7d1152de7d27bb2ce8f2d8c8c30296fcc91a386872eab971131e58fef9b99b99551e6a2def3c6c1921fac0a99284529fbd1b979be16e32e1cbaea3b7b0fe32192e0f3326d45a17637f5e90b9bf4c4de607735c0017e56a214a09ded3835259de4ea397e4baa233194e3953d4ddbd612a86838033586c382b3296a632825fa0c9c3fd3a71b10bdc3d3ab1a0da24c67c13ece61e0255724aea97e18f3e11a6d97d051d1cd752659a4b5a66e566335891dd76730ed222726f710696497fa5ec503d188e767fcff44343a6561f15e4f5b235436252fdd872d15559e9809641c452cfaeaf54d1df6043d55eec7d62c962d6072dc4bb3ee56a42ce5097199e1ea796150844ddc65ed93d72e9143ab2eec820c73752a7af352c9a892dc85d5bc9ffcb8f696df67e81a2d23b88f27942540890465b435e49fd2a06ac6f750afa77277c1761b1ae900f5dbc4acd28c5e82d9950c5255b8c766959f0badb35b6f4a47928d08be54b7ec40449dd214c5a376bf7c49f2d668a3fb91f9de75570ab7f3cfe740b336122d6d72521fc5c249573825bc05a4502f1619e96ed9f34a072525134bf73fb831706b118fcdd588b9d6a20cc28174c2bb08a4a09742609a05017ea9a6db2d0d9f323d8af45e4e2a59eb7ce3dc3d5a6e95028d71e77dc8c137d138bd0ed658e73a1d3ea1c32f5a290597471f69b86240493add11ce683f1cfb35069b1625b99dbc179c228afaab3d13214640ff2e4c6d32b70720860236bd051b3db32a2e182cfb905849d79afbb5c2f83215be4d672440528689d48760c9455a0b4db753df664a022936d25afcf0f746ccd46b00d89b7d2d4ad7d479a56c19ea926bc7b50d13f86323cbec5da9c7f42ef222309207e121ce238501fc14fba3292b57369134f6180f85274103ab5ec38f894b4637141e0bce3db6edd9d70632195ee5e23f1c288412bb3aa974fa09ee11cce3295cd68f3d841b89a3830e203e442364d6e8e79bc681465b27cc688172506c289daec55f229c3df8d0502388f6b4704aca0f84997deafbb6890330dfd18a0e1bd658d76bea55afd395b74d4e442d9152fa345bcc047f3b65d432944fb817d14d4b9bafd2bfbd169ab532fcc50a4cb60b4047e9464a7472b543fe1e4143ffc00ddf1e88fdd696014388f0204cfaa61888680daf4324f4324d8898df7a7e463b6d6eef188e3b983c7fbb12a9c01227bf66fa9f5796d0999dfa0545f6abd2ba224d092a456fbced854bcc83be530cf1c548c6378b21646b65bab67f65d9df4b6061c026c0c4d255cc657c26fef65f87538d9086702c05166e2b3ae6dff377a9b9357378151c4d9defb0549dea930c7f5d5f639d1997e816638590d8d68150ae8b1f195e108ec66954c460d7ebab6dc2f810456b04a524f5966d43b0381339a79270184e6d60f20f6128fcb02a42870691bbd20df0ae1cc457ffb943be6b992371a97087e7dcbbfa7547bc2c743443109f4b4a593bc0b3dbc6f6b0d478c7e8786119439d8adff9f7135635403758e05e1d698fb126bd163e228de8a4f43a496d14a5beda4c918594e2b8c4d9ede2f9abeabad516b4e9a4ce4c046a6aacd82b59c480ecabc34119bf3627a34b58e90cf44aa1ae99f6ea1f2ef8d890e3a48cf3cf2a42f34b21b59efca9dc490f754620e11d6195012d9f6fafe16c635635731478fde9d2d749455f40cb7d5b6822dc8d437e5af842865ff2bff53ec1e6ec64fdd0a63731155d807b687773e53b2585ea56a6c07793c23d6cf37977020e6a197c173024e9d7a014aaa1ed15742236de7860168abab3da26d85de9ade3ab0cc577b9ff40dc75da166684356cb20c5e909bbf79dc4f80f84f2c0009ca5352a715e241a6a845c228d8485af6d92804d5acdf9e253afb6bc6b22403c705f81c97d847f89dc6fa7daba21d660dcaddd3acd86df8e9c16c8a7b6558bf74e505e590ebba7c651b5ef3ab8661752f14996098021d791f82ce43fa6576ce5b06c8783b2cc427c9eddd821c6655f1593d2edabe64d6794fa46e9283cadd191f72d341b18fb82935a1fc56405cac314cbaf31e0888bae80aa915359639a986ef86d13bab33b26961f52375aaf10b89ce38c1c2e3c5e3ee7d8381a59ab30b714557bcd9a1419891a2edf8fd7b77022a1da2a52af2d0f92987d2c182ff848f34a109f6a9069640b2ad117ad44cee166e31c19ea06c4b1bef89d68d9e7ef060b5dbe8c32884194132847d837c5869ed02f2c1eb5149cd412fac90b9137be13abd6dcd02f41d00b8f97e813ca5fe3091945521f80a642b26f2e6bb26d387af6a1cad9629f7069b17b20f0d0931a1d7cb210a97e5651cab079c4582aacb15a2b971a3b478bd2a4104c388997d6bb1afd8408091ceb86f8a9f6f49ced02166678d8419d88440b5748a8724269eb1703c910560b69627c8b8bd13be9ba1a4f2af75187461882b10c93ad77fa05b4655958b175b488234be4977cf0e662240e4d8e0f92b3fac44bfa2f193221d619e777691de29a672d48b9af1ce74eced1424ef2fbbc5b618d2398766df58693617cc39a890f7eaa6b30f3c65f59aabba7b938d357782fd84a36d5634aa486a31b036ab3f3ea42fdc91770595e6266a060c4ec25048050b7d6061556c716d10754cf11e97b124c906eff041a47ebf785c6fdc12df194486552713023379e00ab93ae168a5845f8f1058592129d28482620f0856dd1452d023c60c568c8c56dbd91ed5e9db674018edd92e0b1e3884acc54172eced67d338ff2fc0f324975acc901c324f4710df71231b3f9e3fd2de5a7371f15cc88650cddc2aa1063d8098f195e728a6784583865ca38b52adccb7b2489ff43e3716d5aeeda1f21560c3149681cfbfd12be8e318bd1638cd94fb047476fafea3715606ea900104d9dc21e2d99c2df1898979dc96d5cfbd68d525626919a0d5f29b5a37b0f48b05c32288ac9b578c69a1b390ab947a88c29716f77a7b6242763bd2378cd87c710f392508bbe17785df4bc8e60478260dd96da8cfaa51c310bd8c901a55bf7976da362d1e2dc816be66f30f30f13ab22944c43f0ffb4af521fc912106a5e71eed921a08fb4b8d8e8a110cf263380a56147d0ab40f5477553997d3233eb1f4f55fe6f88f37f1cfab181c11df3770925ad47e0409eaa3296369d41be2374b79a366a7b549119ddb840d27c142fc837703c38bc1159dbf76e2bdeb8d49fed32935ad042e28a566d9b4ba80af45e02c14c13dd0f2f8a70d33466e100de5b379fa64bca285a4f6de550f44492184acf0cad538dfff0c9ceeef402f5b6338af310935c6c7514a9f49474369cbf669d92b747541f3ce86efdd576aaf15d929425fa589f590f10376d26b4e87329c20d95e33381a404d5cd9a4bb6ec50f80b5b979468beb9a67bb3797112ad1e17cd6c042319b2985ea0de4b267ab611105a9a033b2997fb960fd3a73025d1e269015c35131b1820fff0f1236b03894c2c457b1ec1e56412129b5e5519f24dac85d9da942bfcad0173070aea994fdcd4f73cf914819c63609196138060700c306ba96a4e99a16a1cab12d5c2172884af2593d1ee05cb0ccf004f5c7f32491cd3b1a26b0b916bd31e9ea989833302ecdf63e95c3d96b3fe943a6bab2ae3ae9430316d49da27016de92f51100f529d547f9c472848299a25b8bd8c9071799b3254d64f8fe651c8a9035b65dda64f961183fd64504a4ac16868ff8e925d12ddf75e890dba562f400e29356ae6ec79e0ca9eda0c54fe8187fcce79e74aabac41b4d8fce17ce46b9f24e4ce7941886b49ff37496fe889fea8de8a6a3f2ed0ee5b56c67e036e293ffc863de8b9f064185c75cbc48c9f886e994d533b7aca2b246f8db327fe688a0ec6c97ea05fda67fa86f110edc280bb4f8516160ba04b10d7c20b334294ca137de1e8134ba37bb6cf9ce6c241d74cfddb701283a81b7b2d43dd4939c49d8180f1415d0df7bf457635011a214c96df1d8af43ba0701943f9ec53954b0d97fc400d8c36fb9d2f2d745015da413d98d7f073ce60b3404ede35f48263a6a98c60ea94bceeb08c61d7856cb306e95398019a5f31c0d93c42e6a9426b99a80374d7f6e0f1644384eebf05594f72b9b8f0ceee862f4314a662d04eecce08de506f2f830a5659890f955f9a30379655995b3531488a386d5162c6df64a5352cf08e5b0fde151efd33fc9a8394ca27f097c10b697b6e9131093ba9bad9d24cfee5e111d1344089c34b34b012dfcbbb81c3907e6c3c3258caaa20c12bfb3cd86c1e394a3f8c89fe3b25fa6d5b19267a46ca291c0917b33f1a174ba67d08208c0d81c60d6df300769115f559b4b6b9bc69ec378cbf6357a3c96633510f5167f63e632dae7b0a6baa8bf300bf50659a85b9a2e0e5e41454d64f5074109119aa604029bb6087e5f122bf3e8b5abb516d94d3619bb239620683bc1db3d92ceeb25586ce6819dfd2e240002dec367da667d0d6a5a83e4c1c534047fd2370a0ede01e785f8bdc336c450939b16ae6b641ba1e24be8a3de859d13530976a5b559c90e2824248dadb1772f122ecc73927f9e16945536f1c11c8e4e7ff36217b3cf5f34b6cdade76e3841815e4346fa8fc6654a1b7419df69d7f1a7002c3266d721c781fa3a32b2c12b967e3c881d8c16164eb59c1d14599086d05646ac7a40424798b2c581c9d46330517b2dd26d2a3280af53373bce1ca92218359ee087f2fb8161ee8a9a32893637e2cd9f565e2eb989f3108d9f5ea9c65db229e2185ab3770b4c2c932c6f5aacf1ab57d4102242839170d842f9bd2ea98175ad3b0dc0591fa4db93e8135e3b4e8d93f2f54148410ceeb21413056c7e3c9a47337b7965b88ecd78d7fd74be331d218ad0605fa0441b0bbd7e82a2b2d98ec886a507290474396ce69ba4a52ef4086dfb2c3e2411733218ad000d59dc7189a85cdd0c07883c8cbdf93ff14815fa3aca2ada8ca02d6e82dea4551e5a5869dddca94a7ab40928b577d2bae83b0ddd4f94f05e9266da75d154be6bc2a4b260a4b15d1f6383bd089086a2cf46e7079d7b67a3515526cdac26a0b00fda7072a225acdebd2a644713e4e42a245e045dcd9dc985163c1e40c4700551f57a1ac34ad6321663f9713c6ac682646ab4f8fb91c268d5a53499bb9ebbc32eba1898e4c3f25ab7d1b686ac7752ad27eecefcdd73dfdd273afed44a7fb11aa6825e5878ef95d8e8570932996f0d442fea81d716cd81adce448fcee3a40346b97d5de7e01367fb37a50a8d60f0d529e384b7fbc067b81341f5c35e1f5ccdb5c49fd6658663fdabc54461cb788406dad51dee72fb076ce438f6b2d47f82db5d436befff18dd175e0852535dfe90cc18c0e4cf267f6cbc64a6ea57c46670b05c60a371fb89270ca255e4bfb124fdf162264c8d86e6af93aec3a0ec608d8c91d16e97686a362074cab403c93a87f8c086d868572ae7dca3388f679c67d2f7da9657fb0cbd06e99ab2b1aab7182d0b4fc45ff5dee7dc4258dd9464a15d396349de46fcc0cc3309582599e73a04f7f5298da9dea86e0c967eef989b6c34f9a37d09fa54f3fe8e7eb4c70fd3b2394501f34b9f2e375589e7dab9d9a76eee9b36397dd19a3710deecd1b37def69dbd8e68ed391d212ed940b6399d7f8078eadf0131dffb5526d77d6d2c17c1e3c1848d5a1ec8c07daea56ebd2958a963d611ebe2a4a77f29cfd4efefeee6fba858a6d2eed08167caaac31b307ab8b15c1b13851ed5a160efa1778bd1e6ccafa4d991fbc302e84546aea76395ccc06145a07cc0571829b75f3b3a83fe2db4e5805bd9165c08b41b716b043364809feda6fd5ad13475fa29d68dc3b61ee8dfd5f6fe0753e62b2aeeae5b9d5331c5ca7a14e35332e0e774ed237d6d0c52ec8535ce544f2dc32506fa38db8e35249803289fd30ef2b94e21c7761ff477a7ae4570cbd84af16f9200957ee2ccf30904ec1585659f718bc0fd071bc824c965aaf20ee630cf5ad7f6f95a533f2e1d04dec30998ccbd8dc54c12d21b0cbaf47a756ebadd1846d5fd9369797331569a6942bf262a11750cd7a1eb5ed49e2c43376427ae1cf6ae6c2d293d9a0041fdc6d12e3e93ffb7c31505d93be7ab6708f391467ecca4bd706db0fbfb872f9c14abc9b497f7a776b1bba5a55d3b429d9e70d68161c7330d433be463f0f5a5f1ba14c5e1c159c0548e9b3797e25e4daedc68d0869e5599d412bb8b3bafeec609ef4c13e4685485b6c6e19829a8ac24b7df7b3e66898ee19dee693d479302e4ff81b76cbfd0ab53ea68eb374deadf1c5403fcf4d7f40e31d6117928473640868dc5bb1a44f086eb23c98b204e1209c58c180630a7a2648a2ebc187fa089ea543d266a953146e11474a2fcf71074ef84727e150fb9666eea50190eb4bdb385fcca0d15da4e40df83bfb75d3890998de1b25df9b850c9fd102cd7d480f0905787686bd31b9d8e005f143df21a16d610694c93f9b1b87550c2f1b115d5091e6a60d97485011322fb54ca5abe880b317ba37675c7964496b1fbcef5b650600e98df4ca2303781ec5b46c3f0b27568e25c2f35b61f150dac2ec81e2d906ef14bd1b7c6d0292784c30bd9461097c937aebfe3efd1f43ac5fd800ed0affec953664b49e887487a41187e806c6502d9bcda5303aeef27f24d11beb20356653e29fe54cc7512fdaf22c8b151830227d7b25dcd1ba98c63146502fc365df433fd3bded8c21c966f50d9fea46f44b61c8eaac8a3243c241c043e7e07971de2057c958f89783a29a72ec3262b8e3ba21bc1d0fb480bba82d74742e63a03f3af697455fc45d645d65db8decc7415758367cea808a94fb52367a5464a462e9368724d6d88183501f8d76ea35137703cd67d556fcee7c550f1ba01ff676437ef10a634004d3c3ec9b6811fd9168812aac035570cbd2b7f9c5cd9f4843826c7e74efd42d396addea35c91cee974bc8d255c4ae4a9607027f481beafa3e9da3428f3965f74081af892c065256c0cd7585145969ea0bf029be7f8d5e040fc940833795447739a759539358c6025d08ab54dd61d598c985f41cae9edf94df9ea1a914bf3b3789d760ceaa98b4c7480b387960edbb97379e4a1382f8b6ee464242402c33f1542c754ebe183afbcf44f58d798edd2752a1bf0159710fb79c68063aa6cac48b09df6f2a1c8c787fae49175bcc3a12f532787accc8d2ff16fe607e1ba10ba96fbdb05fc2c9e579c8db1a48e21b3fd33e2e994d55883dffb6ede611ed1cc5ceb96346227915be57ff790cb83bba210ff5efe5400d187eb8793cb679a3bea9ebd56533e93ba4012752cc5777b12d096a09a28e6801a83033ddf4662c9e32ed34b504818ce4558849e04aecb0ef528a13ba848ed4da7f7f46fd179d6f080cb1a7218eac13eeea476174a840f85cd5d4d745a023d2caaed0959b0e58801641a85a35b28ed0ad0fc9f61c9252b7d04695e466610e4e4a8c9076999f561cf6cd0d9c484d255cf196717bcab8d4c451b7eda8ec9f15249291aac1adf2d9787c3ecd94be5028803252cce0810288d74c30113fa89c51f21a6c93d4fd6f882174c9a96076f1fefdd31f5995f5ebd077cc3ac7c81c04537db3abf63022feb71b85be87af12961d074b498c4b6dbf53a8955688da0231a97870ff30409c65a1180b55f0779f9e96795c8ecd985d3c0b690abc8015e42621213e53dcbfddb4bc21513d508bc6b8ceadfa59c4fb491477ed7a36bdff8b166493f24f9d7de3ab6acdfc157fbfe22432c083d3037a35697bdd92bb892a923b8191e4e3089d6f079727b4b2b5730fbb36a754ee937bf68e9bfb559c422e24c77fffea91e64da41ccda26a34e578c6410512d0df1acc03e7053b5a6f49b53a92e298a7e57a9c8d94da2583a46891ff4643482d8eb8bb2fcc34a4b4d868f3a55e41e6dfd662c1cf7aaf711757f6fe31f725351ff6b0cae327d3cd252b19b4d114b8701f50f39208685c48f3d79cd9ffb36a5b94bdf9c1ed27d85abbdb0ed1e3701bae113632736b8b682fa9bcbcdbe62ed1551d265ea70fd5e3fbb711b19921560af1d119c4a746b0e40acc48afa2aa4d1ad45d33febad372939655eabfe4b50cfe67ba4ae43a557ff95ee843d2e47706c58280df337fd9feead73e2238dd90661adf08136b1f81013eb72549d6f9c2d4dd2b8f9fdb5c3f7d93645e9f54a22bd174392cde1577f53b4176b7e93ebc562e4b8e4f717ee04fa1b4b2daebdbaaaddd4bbc89a0e9e1bb79506b5d3d92c565a42ecf5eef3bd90233d0baf2253281559d38103f2f8835a35c411b9157e992babb7c035e869c05126914e8516af68ed5a67562b7364c7ddb0330c0eadabe39b1076abf8dda7015ffb0a2fed590777470323a466fa1232f782b5c645bdfb1cf8e68a148f929efcbbf44ad46a9655da66f2d9a37901add38729e27e2bbde78b805fe0409acc91f4e3cfa73b6d7e9627cea312be78930163e02157531c9d9df9af85aad45e072397c2bd91d721821d26daef60f95bb21a3067cdcb6d32f42e98c65efc12e2536e2c9af66d589a2f3ab8fcfdf5abce767cbd50811d703e42e570eec3446b5f1a1c7334ca9ece99d171093275e96a2c76d627523d27edca8070e6756aa96f81159aba98bb68651e4360bf682f9c2336b6f6435cb9e4507d75131e873a4baaea81696f77c9bac349596ee658316c58b6de1215cc9561d81dfd0d39c1a1fb375e3b37998dc9c1c8821fce69f9b647e3b1a86c1da516573091169b65b23271dbbf9cc7b989c62c2a96f05fbde6285a78829b51b29f660df13fd6b60b83feeb90a45bab156f7fc20beee8499ea670a872a9b99185288013fbdb767f5241c6be60e73337a5b9099439168dd0ae69a132bda138aad8e8c7de24cfda02a35af42029e7cfad2091827090a38de7eb9308cd0fd8b59c8d5f69ed59a13fc280c949b878e512fdfd1c27a765a0317c151a5a2f209c407ff1813ea85af3b7e849a009956faef203300383832943397a592d3120d8845cb33e3136d7d476b222c735bd0a35cf782211d3c9d56ab0d71f055cfab9e6076bb02d2468d2829986312b6efb3bd1ca0622ef0bd0c170e0c9d0a9493ef0b08a0213e6de64761b9af6fbcb81d52810941d82fdd5ce05867e11b1224df7b503444a7f50b52dfbbca3923a96a014fd015426bc7049ae0132036d2ffcb6f1e3d67ca5b03bed0c6e625ef3e1d4911857cf1dc88675a750bc13f6d30e1f0806932c48222c1e1b839fa791b3805a66bed3e8939e47693f25b0ff68039e22d349b986ce504e6845a74980388e98fe3b8c52a8d91a7eee25755e7e856ab2b8baf7e11b2ea0c23f89d874ff6f34d3c5cba464807d1f45174ec6591f826f0d5e262b6b52251119a4857e262b2d7be4e217a69b1fc3abf0551a7f7e010eebe419e8cd96b06fc4a0395c4c6090addf19b7143b4cb0af10276a1025d1072fc5ed6e08faa63eae938e0c1c9345dacfd50b1351dba7169013183b07b59d791996cdd403e490629c790cc2c31608e2550bcd709b9b9d849abe574b5e9487f04135c0105c45203ef697f371be04d54680c5fe6454dc398c2eb9965fa0cd6dfc6bc038dc79d8e850675d3ce08c79e1b52cab835b60c5d907df80923c6ac89cd60a27df44ebb36f05dbd6b0ec6f88cc6f1c6765d7f823908a12fb7dcf860837e27866e647bbf8979f4b47abbb34bc7b531dcd894b722df3174d14341dc1189316139119f3f25e19bb3e2ab5505523692fcb70d5c90b40a0ea5c746040d7ebe73c0e9fe6ffb03c48575423f1d0c76eadcc59ca2ccf551fb81460866d81ee1e0b12ea1d2ded3f21baf5d1ee2f508220f3d653e0440fd5dbac9e1a5c80d7704ddd2241ba7aa30837a479524c0da940994be2c9b1de447a0b3a6637e88a098c55634b9773103e8ef8203ee4d754552e06c26d126488517890dfeeba4bba96507774ed5b47ec3df38bfe45e53e191151174ecc1c6c4ea461c7996b6fe093bf369fec11aaf7cb46238077ad208d2b073d033cf2aa761b2c799f91e0eee23040902ee974e3f62e551d42b63a825e4784b77d5f9b10f6175b937ac4332e57cb1f3f010d20c225717fa566b3b8a05af47c7604a779a2d44ed79c9a79b31583aff448b765f65f80f7f8fa4bbdc5e4514049d08b8e1104499aad43f2342154a1d19da9772fe8946566a61c7fddabd61b2237714dfcb30e36463d15c3722b932c2d35e3cc4d0aa3ea883deac669aa39236cc194fc6aa6dfc63bf306b96cec0b15c7d33da4550903101de3b310942faa5c5c1608297b3112a748b69ac8970ad20a433bd0b217a265daeb65e6b62286de6454117fa4d9f4f4ea25a5c2a71dd7a6152846e7d0e25baadf29e8474c0aa7290ad7f2d0e074de16b5744feb549437edc2fe87151278b6a90c5da851692605b98f53704b438bdc752e192602b301575f0e924fb5b94bceb8d92caa84418bc4bf8c2c776bd4cf64b130a3a874f4f9aa2471b3cee23c98bd16da83aa37c47afe34d29ad3a1abaab6b512769eec5dedfd9f9203ff105a5b45438627b72a3e22f5cd159e33cd1aeb71d12477bf4d5ea764d45c1285b381336c8d1ece6a0ebd4f2d1578b5a22b8300fb30abd5ddc906754435fe533356092129482777550a2b444baa11781e055bfefd48d4adf8aa9383a25e65054f2cdf9994307bd21105e12c27ac76c17bd880a4687e18a09b6446c78548fb43b25ce646491125eb9944a104d34e9b6db99f22482309fdf7166f6731eb9b2620c14697edf2fbb9f364dd3f1c9bb8940ec049c1e0fe3c19d4dffab92d3287773f75e2d4b5de98db39eda6d99acf7740f47a7320c5847eb2b4146e24f6dc09c1589b7a951ae306116c38815366b1a5d10873ec8025fc90fb88f2e145e2e5b4c3c1586cdc43f68aded509b349dc6e696b4cca40a1262d969c52a24e57f7b820e586929b091d481408a0e53c2273c7d95c86a6c5a14a83e40c566c82d47a05278f6b5d9b7fcadb5fea99c3ba702b695c4c97993f8e1da9ef8e97f18a3c009ee9c9cba62e71403a12a144db720a5b0213d4096d8f0e71775ce1084077fe261295e4064b4f91e997eb2fd5ed81c45282427f53b035260f42b33f35d622d16c29ca51eddce74ff6f222070b77b1f93bf88f12d734af85a240b9068dc6a7315b02437b58a089f6f9d61240379e535bb1776565a0e00562463d11e9399110a073645d69e0b570786a033fad682d63b9c32f257f7ccd9333585d9210b42f5b490dc8f8c1e708f18d29223565edbbc0a43db7e7f53539434fd269fcdf323c25bc0a8439d90e0546576ca3f2bf1bf84cf1bc147d00dc9c72e96be25c0620c3cd3a38a4f91ef48d1c2ba21fe0cb4c15a933abbd14bb4de80b1d97b9332cafeca95690a65a69efba442121fd70263aa78ab0c81cf1de3068ede30c3c06bb4f07b534c03d01b0a59be56ee3a510dfdaa891ceac9682db05bb8fd7df54022f68ac3431efebc982a8dc1b1e66913af2e4dffdff7b79bd83e18d96191b35d3f24289a47d8a90dfb803ed02fe8b0f544c4e218722beaeb820e4ef293ee4cf24df71a276bf1d0688c3c327e0ea5ffe4e59827a44c78dba5116b365aaf06c50f8ffb929139c7dba26a66826ef69cb6d559f2fb16478a315738128adef4c1ef36fe9c258445ffcd7b04916372a8c7a252d27c6ce18e9c195550e6b44bc00fbe79396ae948c9d25bb2c63bac71ed2af9dc8a060fcef1db59f82a3e8684d1edaea04963b5b2e4b03b4d8b9d9b203415d25c5c1338aebe3f3a7ba7a8099e21a66a93fd32f33239117d078f3e1e21221745f407879d0ad329cb30ee21dcea10ef2fa3e76926b11da4489bd9d4cf4f173eff0b7b5f0d29962e6f21122b79530fbf2e1f1d6f80b047e3efdaac139e844b2fa0c185d9146f9ce2d8aecf48d55ba731ceb1409dac1c0df33a1e7eed9d94082aa1394e52fdbb07f85f627eafda00bc3e8b575a305bf11b94be8e776b7ca8efdb495db1ef803e46474921651273f7e7d6513c9d893085988760b6130931f042eb13e84e421cfa024126071d08fe70483c35c27c45fdec9db8ac064930c14343e266dba13f1179de8f6525317f011287dbdeded5e51e4fce1426e1710d0db6c874531d9d06c8e4863f6f15d52567e6962abae61947b264535f04d5b8571d32c848da145e70281cd2f9a0d793afe7f0b895622e7fe5828bcfaf8c2f6f2faa868be46feaace4639ef4b63731e50b83225d11b330546e1d8f139e6134d5d2bfa5d8951e39cca795ea9f411621120507ea6fdfc24c6ed0525c78d47fa4ed70e8351efbe6db1dab74e7129785c98ef019b3515a043f5f887ea351e095f9f4bafd13c9d9b94e9aaded638587966d573b418817fe815eed5e098fdffb764c634d5c6fb8cdde54274b7b760644fa055b04ee9b35f0e2081aea17fdc28d45d624153ae403758fe651d224dc724cb2d9813a1013699ebb7150a45859e3083624a85a9033cc71d4640626b7a385a001e272c68afe6fa5209deb3f747880d6cce09f9ff0eaf77b34ff7b2fa988a03e3dea97f4102e07d057cb0bbaa3d1411e462023510582a608d1e663180badddf52f3d1c5a4cc7e68e8599b8a38c42089ebbc227eda5021e2f84bbc165e6b9bb2383d7befd719653598f5be9dffe4cfad2b708c091e4006bebffd1d0a1ad9ae9f09ad1fb9309c27007f865a4ef0ebdf17c952b79bed0bd2747ed95524b0211c14d009c5c665b154e360cc11950c85ea3495f1bcebfb6f9b54c7a8910769ee64af7cff60384d5301f3995d0b61375fff4c1ef8495f686d9ce6210e13958b2c9144bf26689152f6f1f46ccb7ed295e8a5b2950cab0649f53478f83b2f6a62df6875ec6b4a437cc0b9b9597dd0846b8249316a01756f3484b8975d8944fd6b2259374823d3af76a2aa3d2f8df1b91ea25c00cfde8fd675a1be64f4cdfe476559208ccc14b7a2bbadad19a2d41c54987f5e6bdba6b4de8dc2d92be42c3ae72e3ed8c9dc3fd9e2d857aef672ee069546bfcf13022a1b3ced9461c36a0f6f25fc06621f4d6de2fd7c5bf803def49f0e8c2688210942ec9db51b639069771def7c8ba103ac8fc84e21c9bf93a3cbcecfcdd849ff657afc4c5d9ed067e9bb350dae79670ebe0f64c69c32a0fd38057d264908c0aee54c2a0fa872b752aa91632fdd6de247edc2770df530554e6994c4e368163640b884f7762ca80a1883558708fef9c26c1a8ba8cace9a1c23707cf6363cbd5fc8f2943acccc12d9ec9901d40ecb4597cc00b05357be1fc8269a796eda1ee14a97ea90c9e4d7fa39514d71d98a40ad039faaf569b662e973de8880c1ad1b6dad305d887661c2f4522cac4ed21cc85bcc6812ead28244dc009c64f48750bac4ce9dd2744ea612e44eca50f8e4eb89a02cf93b4493a1b424e8c32ce07b54d6ee0a4d109bc209179ab3ebac55145b9dc79d70dcdeb3013cd43c4bea6446cf18f50322a6be7f96e387babf808e9e1e03ae5f58e0358d319b5912049bdc5f7e89943490d569eae093e5a73d829049bc6d4e190ce4cd0c946087d0038522b0bdb236f5646d5d2943a114bffda840393b3891e07260ec0611fd019a35994276f1af83624753e335bb1fc89df134343acfdc72b49d9d332a2e98721f288aa1e515af99a0455269996150d93ff31b081f4bdf332c55a0751313c01fcec17429ddc9c41925f994780715a279377b9700abe4303b3cfc9251719a3151ec4e200f525b4d5092ab47f5be1bf4e0b915833f9f570f1bcc29e4e9ab5e197f6cfa3b2765f4058c9a8e847602f1c8804bd10a094c8fa5a6fd39aa3122f6651f8072ccbff94880db4b5f9bea4b94c1f7942524c8d3509be2ef537c548d75aa83e12dc5fb89e97e487793e7b9204c56ee405185b23fd74c4b7aeaf52bddf22bb719a52e793d79a2c7f9cbf7277da08847fdf15f4f66ccc20111e97f201adbfd3b837ccdc278111019452816b747af99a5e06b067808f59ec1bd5babd911d9cfa17550c86f1eace8ae16dca58fd284603ceef4ca6216ab839fb5d521b7b7f0c12893f7f26bc8538b2dab97ad5c2dcf2025b9b3aabaf2eccd187b06476a32b992c17946f91006118e81915046014e594620a4587ef74ef52418e367e155757e752b6a1e11d8b26832cefbafd59b4b1e745ce808ca8875af8ff6f7918d6ff073a8c156ab480a58a4fb9103261e0199e787075031c66617f1f53404e5b519c7e86c47466744f8994e1ac25164bb1087e7466f7314154a5776fbd9856e1541b72f563dfc548f8c86d261fe403090ae252fb238306a940d7ac10c30fd6112cc1fb12168926e49cea716c24e313c122e443ea450df3dee6bd4062274811cb660e0ed6ff7859ab494b68126f0e9938e4cd13c9d15e072b18511b4f633709e51dffc2dc35258277064f5961e5787f2823fac37fe876a79f7a73207ca6528a391c2d7d187ec38ac719e9f7c181b22b9c875214c951dcfb6d648b25a6fa4ed24fe260959c626d638d834eeac4b1a4b7432b7d1762ce7dfe12da13de5b61d40455bc542a2600cbf18ba06c6e8a534b99a6263dc7ec4ab8154dc82f84335111f9ec4b4fc4bf877bdf034e238a1c860efebcd8c8b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
