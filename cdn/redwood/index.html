<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1128699a04b91bd48a11562209a901a2ee959fa0390f9ef2509de35402f05aeb7c194ac315deae54a77b48f50e6f519e2ec43d537dd89a3020bbd3358bd7f88c5e29ca388d4c11eec1621e55f3f4362ff4522e1aba91a5dad077477192a12f0c0bab6c279792bde7deb287d9a160959b37dd4fa2ee2552e22820ddf73fa6d0d4cc96dbcc85d11a0cd9c51b9f2de54e648b1caf1be5da70fcf0d7f9562254dfce7d4a3e3436122923540e401cf0e38eea11279b34e8f42ba7c563efd1f53c8d3a4d7e26774e22a1a4b4bf89601229c077a58b72b3f29e36aaf82cf2a9925dc0d6726789bc12e8673812841c9e3df3fc052bff655583947313a9f7e27951da5719948f41005c232d6b95e4c29af6558f9e9fd65baeb0a5c4e3e6167054334f69769f18fcd54c74572d5df1c8f6f689eb31c046fbb78c0e195d4757e27d05c677f98b251cb68062546e0c61a5d19d9594ee421e5d370607a818c6db6c0caebfb30ad2e24e74eaa2155e8c078e4886ca4d59548fb5f57cf0e6f753a6cef69217177fd919ff90b8db8b746a0a314a26d1ed067e3f23da5a6027331dd50dd2432673bb2b84399ab3e652470e60fd3d1e5a4642bbf2c42eb5bb178ab100a12e6cf8c5e6b67b54a5e8befc85b0f8a9590d8654e6ec42bef39e451c9066685b68a8531cc8d3bdfe439f55b38e6bf84f42a6693b6200cafb0d3edd1987e682abe8a5f5dc6fd81642f4dfa90bb2e4e55e676037679a3f1acc603b541e5dc0deeadf6e050ad4342a06f9d025e980dd25f31e6a892de5dddd610eb721e217f99efef016821d002020d8d13a5732cd5d7e864d225d471c90f8357bedf39494994f0635801e68f3fab17a0cbbd53c632e7a0cb9658decb1959070c793c5a6b7092931e416a249624342d8f03e423344e0f10e84b6d38eea49dc6dd4592bc4cd08368caf22edc3acd5d00687401be9af1a68c26380a8741fccde015c075e157a9c180b04cc10535f252b41f65490e2c436fe95b862de79eda36c7c2bffedf4fcb302dc234e7c3728ac769bf4f6564ec9d2453825e0ba975216326aa425d9c456a213338b28b935a2f686dd6167e7b0679938254efa895ea37a6417b39822d8923f64ebf342b3bbd81bf9aa00331281a32150875ea06423c1d3fb163a6d9543c7153555ae1a924d9fc722645840603bd2df7e612901de3dd62a2b3912ec5a88735f0f5c4edc060e990de463a2e665b5703de9ae3c717afa8e5d145c5ae00ab91ba8c190232df1756732aded8b97af8da17ee3da909998b362e2c142908e67bb13f729b7787e9b433031f294cf9383e1347957b3e555b55c1fea156e6e11741784e0a322bb32dc38ce0c713dfcf973fe5c74baee433f186a44e3446e7c4fa4d151bd741162b24634e45f5fc96f0fbd1105d0e1db8c355ffafa3020deae0da7d1a04802e0795fe804a52919985d90b8f79c640a5cd7daa25a834e6801d7bc06fadc9b16070e3d7687146533e1a377dfbab04b26e8c7ec1c0a68b0f34c5845c5e8b88978598fd8aff9adb0b8c55dcd4dc5957c3cec1409835b2e8750b48ef7b72ed28c222a9d955d239f55e49e9223cce063383555696357383329075b6399b6b33e53ff32ef6c05c60eb6f6f293ca99ce2b06927e9fd4ebe02db90d6fd35a31a6e9a797b87d6c5d9e0d9b2de66bc310e5a018d617cb3f13bb380fb9a7edc906cfc15ac4605f469827926d2eb4a685f1fef9f14f30aeaa18676ea51576873afed3e43f56a317863ba0a53208b10c488cc15d126954cb7b4b1230f5c0f0e90092023480ebc5c844cf1821cddc34b3cac04e7a001ff1f3c5f23457e7523f96da5fcbd6610570be807f0730c497fc13070f34ed1f69cb859d6a2b6fe49bb39b823e17d227d7829a985b19c69761769b45512edf308c3fe8766a14b86da7faf6b713030f38c884acfe3ab640b4dc91aa3d3d68fe1ebff83e439cd716f8bf86b3cda4817920c460fb41718cc29bef6c58cc5b4c347f4146535c9643cb22efb0be1f0792fb33af7b37c23f793206c45b2ba53cc0c3342f5f321233391deb9af3a32030da68499829b5a9d1f052bbfa8de85cc9036ea6523d2d0037ffe36403b5df405d59facd99f2032a2fbcb3b0f82b17904ca07616e4d70a010b33edccdbdb0be4d8a3cf55189a87ebfda773506b2f6a58b31dd62cce2e3946a554dfb1711c02b446ac212a3b4e881ccc8da7e00a84885cab7a53cbf89735d4320b866748333f586bb35e432a298dd69220a3cb13731e384c54c114a20fd0288449dda54799908e94ad3fb548b15eaa4e4383baf86d5aaefcb41e9279190ea36aeda2be9c442e3121884a8a536178269231264840a10d4562385fc643c2c3fb173c5a538ceef2fc4891c3150b406bbb2db03af6afd7cfad4f394009f31cd8799ac4ddf1fca8fbf889d2a76e0e9e56a2acc4933c4298131c472a01f63f1bda976080f22b3175ebefb925f6e0f1f815529c5fc27b2b476e892e7fc32e7a18bd7267ce319a8af96814a592862e094b16a42ad59ca49965b7cb3f75527425f06922f11c30e66c148a473b0db88ca4aae13955f63cd81ab0bbe8c2343bf60e95b85e975ef349ea7c5ed689db17099ccb32ec8e8b3ae18825c51f95605b99bb423b7a15d0f0ce892ea78565695eb4bc1c5d3f14d54d835455c9c9272c01a3af6bd993717a116599b1ab892df19f198eb20380b7fa6ae84d809a7e2cc9c95a1726700fcb92fd8d6857e28a0cf23afaa00999b95db12ceed2c3c8cb9466a846cc367c1626c609ea6e9228f8ae21101ebc8795ec3648d284b12251f5f2e1268fefca9cf9ca1c80ee654639ab9d1693ed0094c500018111411395c36371b1401b02277633e7dd61c4b55ee18587281158cb917c8d3f6962cc6170c8614887f53cfe8bd3ba0182e33d4f45678e423c54bf0e429cee44e1a5b2d19fdb3fbdc681cff92d2e24e3a198e8404301503264c5fd9e176a9c7add58db338d0d3e578855bd785a6e00d120a67650f3c54692d0eb8c18856ab7a27699bea2a2a722b9e1f5c7affb66fcca749ff561d89ad92ab826706b538742f09361ebd990bc42f16dd39ded5168c227f4fb73a3508ec03a14fa540b9ca195ffddfdf953c83f5b87724039c22927f06a0994c176373c832662e6ecf42bb7142427ac415e0c076ed0630386aab8e8d176de6b7b6907dbf73fc6de11f6ab57d53d92fe2802208585ac887d62018b7c13e02444ffd46621bc3c17eb7aa8626501c33bdb4bba08880344064ef7d8138afad722db55934cc653d9242210f1de3aaaebdea2e13a94e348b228c1de084301b8c7530a48117688965de81df0b40cc7782cf5945babbf10bef7d3491f1a2df4e811aa3cce6a443680a12330a500f806437db279b982adcc81d7dd496719cf563f75df1756c64d625d41060565ab48c10b3d6f037af9d50e828b1112afad60bfa8e38fde12e4d85dc6ad4549e61ee308364c64176074dfc51993042397664aedac7cf7fc884501bf9af37cb470bb97b27afbe66d74767323fb318f2b659a341eaf7378e8f2cfc703918ee77c29341ae6ed246b40c71d00e8e255d4ae24562ae231a58bcbc82eb32956d64ec796c33d0140da829ec830e8fa98b1ed22060a3b86f23e89f27eceb93712b7854041eddd8280f904a12c3d5c8e6949c3ef2111def02065bc4fe50c136da1393036338712efdd1b32f130876f18cdc9aeeaa1afd1951f6ab0cad35322147c51e04863fbd5eadda44cf583cb347f1bab91f85f8bb4bf73c1db1c59758ec42baafa80cd7b5e2d81b3b57fe1ea7983105f2037cd66d9b98733721c586cf7bb1f0b6422bb4d46f44e63f6d1e5f3dbc404aa774c40e54928d9a8822b1f99d33c8a1d94c5f2259c140c2e909f1ba01bc2f72d6d04155156d086336f98dc36dd80da2fd97c5913e477bc83abe4ec9a3eae6dbfdb131097cb2c0c5da17a8d02cee7882457f7e11cb9d71b1424b6af9190eed5d2c1ff938cacd082654e09e8d362cba77b23b866f83d117477484b2b0f96fe7800624cb65cd9c418c815d3d76d337da86ee805cc7c9a14650df630b976633e43bac11c61a1a8170f9a2fb34c2a3dc8c2889c4a414f0f7415a350bb8466d07eef9ce2e20e7c9004a1f3811147b2df8c6020311505f2bbca1bc1aa27c7950ccddc1e367438bcfed97cb988d7bda0c72958ee309c8d31611a23d4882a9cff6f7f0e32fd67af9474424149ea31f0cabe621f311bb7c274464af31db282a2bd945dd19b24fd8143325bde5eb6aff0ac3e03f2ef1234c2ccb7577108474ffbd85fcff6be8df21f96afe81311334c6d4cf3e73d48d941d2c75d0370e96cb7d365ef62d566e79a715ba87c6bfa1a33a5b633416d91ba62269a995caf5415aa07dcb3a0326296bbb37d2f4f9fadcf3758cb81e3c6c9435d2717d15e06df0e96e2da5805dfc00b556fe1410d51cb6d70b9bd1ad69915ff48806c4d7334c86153f16bf924a4bbd75a9b567299556deaf4ad31b47d6c0bc6c1f727ed8e801d65b67ac063a98bb2c8a40879dbdcf63f3f4c4df7f18583777676404da34110f94aea99d8413900fad5a48a9202ae6bee59d668fe3829e0ec30ba1437fcb5a434395cd2a3b18f455e516f2501dde7375143f35fe7e385c3311565fe323f2feec37249aced54666fc8c1bc802d0a1d0bffc2a365456d4e05626e218beb726767d842f584e9ec35d807227a1ae52336e36cf0795f24bfec984296824ba87803e3265e42afc1dac7b0f0b4d0caaab9bac463abd8550a81cf17541fd422cb7e399796fe1d0c42e2483de3e59e89357970c79cb03650c04e766fd0819c63cbfe34d4834f5e517295fcf169b739ede211952a96840e4256d2874b1eecea9d8d13608a3ad400332ef265d4c1665b31f01649a758566e1593ba69b0de8f46dd388f0b2a34b233aa484e6832d2aecf0c07bdf5e55d552b443f028cbe7eef0a98ab1c7a0a2c453cfb2fc6c72370a20f07bc7f8a6529891ee5a729f96db05629ccd77849d7940e6e0e4302149c2ec06482d092c29996581fa9ac7225506d7bf808b1c1b1d3d02ce882f1e26b8ec82b36e71074aaaec38419cd2b3cd6ffcd5f898831c7d774822e125e53ec2ccf76fea4e1fd30dcdb9868f47b999f39a9831d4b8fd813f71335fcd906bfb02ab60fe583ffdc989185ae3318c633cc397794d4f6fa530286f9254cbad2ea860756ad402b3bdfc77f09d2c1bfe577fe4be9e6411beb30e732a0be99899837cb1cbd065bbbeacdc59069949376f1a9f1fc36842945dd64a0f1ec4cc2a02f72751f7ef04b850251aacb23708ec6c5f0101e5ad0915253e9f8f0d412b97fcbcbbc06e20e2fc7fe7d587fe3c2268c59efbd4a040ce5c657b5362b1cc30c4b7025eb8e27b7297281e09feb3e9c856892693a8365bcd3d178a0c65fcf33794a502f93c97af601b86ec566c540dcaa9a99091cf95aaefe613ca69492a0811ed652270b751f97e9bc628185c70f12037c1d2b0262fb86da6b31f6c2e13b1b5ce784061fcc4f523df8896c89f827a88dcfae0c4e473f3049598d5fceb0803e6328ecd35c6896133ab598c3ca083a649a6c214f930a55d351538a74bac2722b35606ff2380f5e249e3d23c6f79fa1a23265b2bb3ce4cb350a14dd0ba972e6e2286119dc1cd9f5839aa8ac41ac9685bb9163e87d1a2b4449da55011a1906442916db99a4ea369ba01510e5daf9513c473287b1f8a52c1f5be3fb2f3a6bd0659707ed3032d3278e70ac3baac22457f55374aa5bceaca2a9991aeec12a3bcae60fce377a5cf24b34d6322fbbcf5b21107e1cdbfc38fef4637539ef388f5454355e5a43ef2a73619f5c077a3926aecde047ceb343f9ce88d07ffd3973bcd9d1dbcf092df3b608616bd3570a598e2cd7672f6fc365481af254f0a677199192028560f645a54f0037f8b0e226209c88cff5762b7b0ac341f9a8912493564acfc92489eeea91d060f82f1aa10060a8c1d5ab4abf7da6f246e86a03370a9723600efa807b7559e615ebe5d909cc76f33edc1592294af277d03e35d7595e3f7ea8837511a7590c20ddf65f7938c15e628c94401a84a2e3c7f2c91f0c54a02acf6f14f5827cfda6899455c2ee8b1ec9d790f5e676c5afaf3c28af516ca638967522df62db27fce229a64f24923908bab3c9d3d2fce75111ec50033b5e1040430c9634b63e510f842638cc43a78c9a46c49b17c8d5d55c5ef8711dd15d96c3f97118c4f8a266fd2e094b71b8271e151a155321ca4f4eff828d3c5156d8ef674ad9494a271c781ad5040dcbe212513db5ceb7821a2eb7803e16a34a6e199a887fc6c6599005f46cc484ad4cdb193b9bff19c2f4c09c4850d42f32f589976a542d75789cdde0e542a4b461e07f2709924ca94a4611ee5f5193f831c88ec7fe99770efb66a60781ebfca4f6cf2e3da0022e466a660e4c4c68c21ff3bc999c0d035e43a3275a32ba2dd961e8d42c73365a06b03667efe2cf4cc242029b96903165b8255aab9d8c46a4533db7bf76f090b77a19a8fb04a777ad0233a677e35f1136b4805479db041a83a5c6724c2e3e39b6c9d0fe6a631598dd96936462376da9c403ee237b537e18d595c43c37038050f5e148b8ec0d7f1076e9c6a44f2ed23e5531b5aab5ecfacf5259a977a917b70f8349bb4f56fe3f4282c4986d768bb8364b27daf0dfbb94f6dcd841454895ea1c8002413fde52b35bd754a1b8b662a4e964f11bc23f8d88ad48f252f50078579ff8a7ef9e87c1d438b58d3579440bc615dc6df979f12f310cb2660eda0dacc52950afb56eb2e2ab2f543e01df067f6f269462a3c808b76829dc9d4ac2dde70263e0537fd15453b3b80264d1f4dafe9cd060a932e09a51293692b54d1fd11d3e18adc19737163a0eb81f8bfb51c4698b91d67e7eaca1e450c96da41ccb67eb15affba263c69c7df3e31d939b967ed071a564ae93fb74338ba8fba3f21a29e748e90c50e3ee94c057c7ff68a88e44cf4d5042cb9b594f4ac79a50fe34ae66264504138cb6670838ef0be24b961a90ccb00d531f3165d0ae3c56bda9d1402e0daa56816fa6e35125a27716d74d47a1d16cb89fd05a82651cf1490f097cbe1e1eb6fc72556d2979b3e958ea346e7e07461e8d796b3f8a937cd1a04ecfab176c87cb1ebd0b04628a6c1400aaf1af8c86e9c2b4703c9156861b45976203ad286b40bf9f39856138b356e3f9b9c5ca838ff310e77d778f700303e5c52255a797de7ebdaa6246582d0d11a494c6b4f0ff6dbc97144139b3ca98d847bffaf43116206f0e5a01bf70cbe5b4ffccba4e2832c2a32de86f067a90ab5ed4aca2c4966f5c6b8c8d36dde512a308f4dd72f4cd2cfe4da960a8a66bda77188fa4f539572c57c40064df0467310883b770d1d774fa0a61e42f87e12ed15d0eaab68a2486e4dc9cac443cbee41dc841c9a5991d3e712b21e9ffcfb9259aa95abf2e0eeecf47409ce4a12a79ecf683c75cc4edd24421de6aeccfec63d4de799ea7c273451c9cd863bd866d08dc2405341067b441cae4515e2046538280c9563293daeba891a15461161d12582ce346a20cf6e9626d103e2a83510342246377b8ffeaffe423e1864572451502f744a603e323bf55b8539bbef3be168e94f2a07afd5a504a5988b6ecc5f5c033ae971680eaf54d25c26e8aa8e5627c5258dfc6622039db66df00b5f58f47676ddd7ece4b99655493cb3b74976bc20ff2133cb7a47d18e5e472017543b363a35ba63c7f60f5ff3db16c14f8ca6074f50fe569322ec7cffb52f8c67569ba53d9d774ecb8dbfa66cc689dd4f59564dc65ca3dd974b77ccd78a6be6c6591c8973b9da906e903d236aa566406e4dc2950d9a0c1aa08385eb1c0e91f9c9f4e67251eaa05ae707e620c9eba9fa4fb719c3a531e8c6778d614569692e4f1e3ff9490edc48f0b9c82b5e0ce054095ec2271a3d8ae3bff34fbd9b05366f7697a1a3adbd66fb22b5e7f803c17f7fbc0b8f5892fa843095ee6906036791d2f4d784d666583d5790a9425e3062b013d227de97cffe7ac4d417eb17af3047ab8a83ffedbc6b52d8663ff076a3dde800f580290399e2197dc6bc7026ce1a9f771c83f85a72f782811ef1db6c0f426f45ed30aec4103116b93a79a553890e4091fd95bed259d172e5ef9b4843995304e3a8b92b01721358792c685c2dc6f1094355817e6c85cf8139d002802f3f12ea5060034c82f258e02f4c9661fcfc5b8f51f66dadc4619448e07fee1bc9a0a95b991f910b40cf8a0a4eff1d4fa4173fd0af92c7160b402650f5111e088def933931b41f97f7836a10667c79739e768b0ce401ec0366cb6fe2717645d7bb71429cfa68a74148ddc09050d756bea2a0cc944635aaeeec44e43f23ab67ed101163bafe9772d535ca5327cfba7f921b49039b0edab71f654f9a2b4197bf6aad90a50417f46c94e6a2bdfe001ebed0cfdaf8bcc6cab7e209f5f4df0563cc4c156fb47c7e1a50b9c96883f6ff049473af24e7dc52c2932b91dd36e19b22cec1d760195c5b8a0127c698db57e99a6f31992cff93626eff4ef7b8974eb47e2998f838523ebc5d627575f8d7dbab0c8d0bcb13082893c921673e4b535efc7e05631ee8be63a452332daf5efce9b994a0ea3131f2fb3434742954017c0c4123db6a94844fdb3e0bf05e965088431e7c782c4699b924ad5c3dbd3e41f4b25d2264ba71f470af73ac8be878f5f627cebe83bd52841147ab2100039e0e6b836606a09d934479adfd40f4df7a6c08535a448e34860365449b38048ffdc40f24a16f1058d0a20427129775ce0706ec53514fe1698e713e164ab71bdd282a43a23f1e7709ce7b7954351ca86497f83ffc31d01b78cfe6de343b89a1967269f043405dcaf85236d4e40c14913dfeaf7eec658aba13ec81dee1f1f1740f6ce055b6f350c7daaa2020799c103e2da11a9fd3782a188f35d7f294db5513be04685230e829f07342b78a50ba24e1b358fad34a99a37d47a8f5c3a52cc5d80f9e957fd54456c03f666c92dbc4438abe9672589b7f36e60b5e1fe9eeb2deb37c7924e1ffb6146f2a71fa98a41f377f913cec255b66ebccf510ec4361af157956a7dda35084e549e18af6cc0e597858b0b7742318baed16e3ff3c0b3fffe790331fde3628cb90bf551fe22d1bf9f210ed356c2e4443e04db8a8eff7676d3dc9dd14788ba3a5a62a7acd37f858c5949b88544e6384e063c5c2a781e1fcfc5f53f79dbe2c2d78b61723f622e0d001034e27d1be199f1aab8291b216d466b2cd285debb7a65cc12b4342771fe4acacb5ac0a4f5431f1ed2f43208482c600d559d6f7fd9f37426c81c94bc23473faaba2423cdaba98bf2b0df0db0fbb9a9b539d7b283189d3e7029f1cfea4d4b30ed4b3818327bfb03582762c26b8073e3326c06fb0e3db10d1e5d84ae93b67d27ce2925c8e5b26224ac72a7509bb7486342c81ab2d0e47f6be69fc7f5214e0581eb37f3be1e7dd71ca07f2144e83a01b8ee2fcc55e5580c6571c7fb6113322a13591eb91ee60641dc866d5dcc9e443bf2931c46b4d1fabb190fdd96638ee01f58f887d02dfc6c3bae58aa85220606f1eaf551106c2263dbad314620ed1b0e3ff7e7e9765bdda66cb517a220e2d64f61064a15480ff47b568485e1fd32ae83eea6398eb7c20403cff31afdd8d868ac98b449fa21017a047099f6ec78cda677bfd06d9f6478f051086b8ed6b81ec891631331acf30d2e137e41eba88f97832356a255f1d383686235bd0de91e7620c5ec018ade0208bae8dbef2d0f9837c92b6ce77d64eec72f08070c7f5a69585c53113d5cf34473b1026170a51d4194175d0b1d282e7b1919072cc967d797390df9fe8e262b6fee6e2f63770748da6048d38add83c456bfeada7212380fa1fcc5a32faca00ac73979fe65edbcf42cab30f91951c52c95a631c2af5d8dbe4fc8f4fdca6ca80b839d60c7b847794ec9a1672e85ea6bd027b3ced308e14afdb9e973a50499a335e0e8bc4847c47884c18dc4e65c824d20a55183a1659f35d2e391593799d4adf7059893e327deeb498ac96e71af2b5a973151aabe5e95b120a1cb53e038e9ad88fc9904ba6909979523f933c538171632089196f9adfa2cc5698b3059ae77bcbf644928b6b069734c41e04cec8896d1bd13eeaca777e2a1eef77bfa2d25668623dbc988d3b3e44597d6aa718ccfc2f48b7018218c8dae31b5cc75953ffd6310784bf8a72d6643065f5bd877bc6865189fbb78a98fae55b4a5f7d0062e9dfd798f72b52a67e615d3bc355219c5dd211acd094807249a2832f820213c52ccba820d02acb31e4778c415aa15c8076108bc5bbfaf0b3d0038d99990718a2c7fb89ccf4fff8179edb540462cf088c320940745b3b84c878f90901203171ea40f7561e0871b90fe7ad23f2e9b0ccd2a7a40ca773d27d9ae2a717a9d8fee3e2c3ae1d321e9d870d36fa40a056637841724c0f2edf38941e8682f9e638483d5b17a0f08f43173c2ed7ad7da19a052796241fdefd16f4e734ee8c53861f92b6b1f68ee7c88e9957a36f02fa29f36700bf07574d8dd987bb890d82ba57fb69375b5bd4695c7957690f2acef2d7164472bfc9bdda88f0caf17518df20d031d3f0b6a149a55e2009de8ff2c899f6be3b94cb44629f4e73d92012eacea5125546f1f40d31c8a78543439029eb59f9d1e81a725f7575489bbf06b7694d404c0e42710799cc26f2c47e45ff2ff5f61f891724a54c014326b30930d733f5eb71302d182a7c056e861972a64c6756aaceb13116c0b23e289791eb9933bebacca0bb7d3cf43be8858deaafee8341e56618e6cddfe0278ab52b3b4bb6c920ccf5f423e069590717af78c2283ee07185c0ca6e5117a0440d6e392ea7418b4d15b34d21da2b65fa479bb37296cc6fa813bf2daa670a64cd0946dfc85f27c7fa96a801682bf9458adbc523e25a25e245199098bd13df20de11dfaee5c3ff826c24f6dcb30dc49a19d1664154e233bb80f340e270b44fd7155db6d2e4ad4331ca3c8ff6edfabf8c4d198544e2a9f1836bd8234265810b157fd96dd3712e2d85bb9328968f990522943d524da145838ab60dc19d05acb354333e258295f6d200e968f5ca019d015b514a2e5ea17c7f9675de813f72bf00bbd88b0aadb7b5d4742bed7c2def9643849f38284fb592f4c947fe40e0c8e4cc816c94c6d459f5cfe40718985630391f0d27072549e14e23775c67b593b6d6753c282a71f4686f02042b851a89af9bd9f8f0f1434156b8e79dd8352b419f33a283c0584b1a6dd4edef200c2f32365c878eecb35500884535d3414ddff0fe5f50abdd2ef4634c7c987a72e61861ba8d09008414483b3e8d30132e4e8bb1e64423a71f76dd098663a425da8adbe5f6d52d98533bafa614fabffd715081831218d194595c8dce55a2f593c2442f60571c4f57e38b33c623dc61182afae49c87b30992a84633b477df348de2ceee0582b914315781d4d7abd7fb44bf9ee69de2ad92793f52b072be020a4d9a4f15ba3cb58cb5e2669e5de226c3ea3262b661974f9b242d4c0b05b54e88389b39292c6df68cb8d692426ae68b1f7a08318f8dfad3967bc33ae74fe40d376e39a3f62e060bf44a3639580421c18335af971bd2951c4a58f7979837f38282e0ded13ac40af02d2e0849d133ca59bdfbe366e69134b672910b93286f9186538d87db0754965f4c42db15c649e28caef9d20e7d770b9d2975f26c42a30cc9c47ebd66d7e366e14bd1640d0b858ab1f04d52dfe240cdeddecfd57b7d52f2d5abb92b19b55718a8a24aa70bd4d0dbb793e2773af64095af868a6633b39694274d8a8fd23093247f929878897423233753ca48f5ee8594e22fa36946440d50ea41f89e5f744dfa456e6a318fb69c33d547ee4f206fad16428bbb2cf2033597fbd5eaeb51415f7f4f5cd23b4cb9892b765ee1b9788d04266815bcce15c6e1fe8dae0e8882381b17695ee273d98aee9f2daf4aa24baedf579fde8d842ad87c7b0025fe075ff8e4db443d337add7c641c357d577f7ca7ab156b60ffffda13694e126d094522d386c4b3888edbc6ac6a170f747e759a608eee588e04c1ea231de82f0154b9ecf4e601f4d9ed6d5aa7f72f5e1b6272847749f850e9b27c8d858b0657ff5da4dc18853544919772332e6bd57239126a59d28e7fabd02c9440d40141de5d9e93624988b009a6d74ce24e28814fd0fa4d6b6369c431b37139803acf214e77a84992d2f162be7f648d4924c23233c66c301c1bc693447f04b1f70e88cd1da46f5020d30ecb0ac0f8c22889b3a0e9efa8aeec339507708ac7a68094a796e954c89b03cec4373ae015409bd4173b1891a332be5b49f99444c66410e455163f79f9f9e6db2a707c737dfddd80640427787e97a6dc6827046ef435bdf995e27a4e32fd25b4222639e127c8583c5220c63b202c09a9dd845873778f179affe5c231f4ced239ad3760fdd5269787243e29f839969c66105874949334c8daa6371a10eb7c70e37358e7067ddd19c5e1778e116edaae656d51a4f9aa2c31ab7c1330e7da5d81b975d2640b6795571fd2d3aa53230ece10d39d4d7fb27054488725dd1d509f760683e2fc750ba5604ab69fefa250cb225ba2c54c0dfc56e41421c733549582b780167b28dffcf656faa5da4ce94b6cbdc65a36c71ac4ffdf0935d17cd8f7ec00969cb951251fc040afdae04d46b9d048c3d3fb90aff0ba16755db250360be24d744a21b27abdbd03d0d8c058e618774b1afa00e1f66a18549574658055a25de7167e7f96ff6111657abbcd2eab04d4ce03aa1c0dd35fd80050446bb76f81c9e6960e4901f78253f4a4aa8bde8a4529106d32b5ccb32c03b7aa13c77e93fcf6739642fcd853565580122bd1c3cb2da07ba561d22ca845a3853ad454cd8e3c5e9eaa48c4f51886dd73e93fb877f99489490921b0af1349e77973510da8ffb123c7424d6ed7c00d789d0f605c954b684bbafbd257ec07a62ab467a82e9f667c09230dc645a375b60e6872caaecdce7527b927b95e4b85380d9956b0a3fbe11d2b1930670bb116dcfbbf1785dc0af13000a0e4ee9132150f92c7506786f6987adf15330e0a9044c40535cd9e4af42012a66efcdb588c0ecbb3c0ca697685771ffbbc46ad040c644be24c3276214fcc4add97cf0d2eb901e9c27a30bb4c2795feb6b0ef3fe01cc748c890609b93ad69f8ef7e5ea09a34a5832ff30b63623348ae9d5f75b1b1d6e521f0f7d8ce9f0043c3101284c52744c6c113564a2d529ebdfa41a75f7365f3c4d9b879c53f29684d4928a0cd3e8ad5d920b7fc2438f552322c7076977a89a0fef3dce2fb1cf402732eac2b51975299c338b69a93e195a165e4363396cc90e1d6d78506c9ee1d133c198a055c138f5057c7e1d2332f4448d75c8dabe7072431d1ff964882118cfdc9eeab484a6b34045411f43a2df43c2086b200dae007091996c34f497f1d5b1f26f7068a5caa1514719fa53f5298b22e47113fc61918609f19a7c8c6f9ce6770b57f19f01650fc084ff0ae3f496e3061509cb587e1a35e048b60997948c376d1d1fd4b20b4ba16bcfac73998898499e7a73a594cd5ba2aac6848c6e3e56469aa990e00828ba2c58ff6d818a0ab1aee9da711acd439fce4c679e2a45462075a1c354959a979477729a43baea33a197f5d611c5884b4ed0251d5a9482e4ed2635604b2b270c1067414416b11ad4e5ed03446d0a5b65c9d2a3814d6d70a70f5a05ffd111d0cbbba59b5c78d11bf919618341b32df642b839f8a5b9dd4d7edb0bd999db2322527490392af6771325dbcae1b6810a4261f0f594ea887879076edb288b5a1ee6ed14e50d81608904983c5ff986098384cba5fc32e5e3ee2a24ccd3f737b7ce54f7cdf0f9f0d6fc0a2796de71b2b9c9609f8afeb086024efbec617b925dec529c08ec13d8d7a3b2c65c0cb4b5cec21a6820d937aefd426b75e9a8bff7d9dbfd5b3c5fd053c5f8491dcdd51415bccf887186e70b654171bc0e5e72bbf69ce38dfcbf53a3c68ba9ffa6be4eeeb3dfcaf9b511cd68445e8e542c4580dfeec9ee3f81ea55fc0b48d1391d6718fea46eb0a97452cfce7c9c6cae3090a1b5fe37bf03b12007685656bda6b5680e97cf403214e55f7997a29c7844f0fef6105ee365b0e8c7f372a319833bdcc73848414be3343d7dd27b8dc53f4f1946d1cb45172a1c235b703b1b1abd1db52c3083e192ae738e187c322bcb2202b7c6f1abea83a4bfaeff717d7fd1f17f7a95ca0e44c121a74ef1a703a7b122c41bb746833b5cb1dc4fbb3714915509c34389edef59f69df1a5b13e9e809e970443662d9f69db5f2fe20f2571d9266e0a195b37985553e6b99304cc3a81f5335f21ea371d1829502a0940e784fb6832bf88e07a206001a58de69d730f9e5ff6ec352ecadff290281378af1d35cd770fc404ee12f4b061c7c7fdb96cf239452c34e59595541743e1a827d5996070eed82bff5391cd037430af3f5f695b208f56028e3d78dbd5b356fd35efe56dc528269bcd855ad41320cf131076d8c2f855634aba153e855478c3cd74e50fae989139ab66511bdf5f4cda1776c36deb38692032c4edc1c84fc42712832955c8711184d550ff5460556b113b0f16ce3e7b09b2e4e29241684b8713ed46fdec30c5b6b1a1b9729522256882380da33359ca400bff482c421eddab0b19d3f23d8b598df0e2958fa39e1137a41d709796287c01f95cfd9f64503dd871185e1377ab6c42b4e200f26d42d68c991ee1d5dd691cfeb2f7ff47b5d474d515cdc0379e8a722633da8cfb46f0a89d2a4b2121f043d389a061467949630d7a3e2630d19fcfc287450948300ccd0cd84463cb2d1e182a05e8c342ccd7b656c7769fca55e9b36d87731cfd763d9f8e67bee770eceb847feca5eac3090028323ad3d6d8ee53e741c02771cbe77fa4231def07aa0c4fe830735c93e71f8aceaca377c0d277ee1655f182c53880300cdaf4d8421187dbc660d21bb2b5141dc5d9432af43d1e3ca7c16eee1f6f64c901149ec9c300345a751726bf8b5d0e3b81dda5eb0c840b0c893f06f96a6d1fb8314e08efb467c59d89ff5623b421c9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
