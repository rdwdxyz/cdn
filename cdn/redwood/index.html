<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc1725c9646b71ac83c8c64d7b6456265998bc0f5238f4dff43ababf58862a159d76f3d702f5889cb1fd11f778c8b0aa61da9723b430e0ed21c19c72dcebd86f9e5c3ee7acff00780ca13c82fd5f56705377a3a1bb6db6ecf76cf47a7fd2c18a29bfe487683cc91b0d608ec3e860fc8a596bbe8ead7e51c211fdfede089a4a3ef1b8d50ddb2c38b1075960c800155d4065e7ef5e94e6f16b523d287df4d11934143f5d852968513bacd43ef687be905dfad31582dc6e07c7484584f8f98d32b9b62912ed6fa29c08b5845bcd77b66e88af8425ae88cb765be12e8aeb9f62930ebd2825c95399a068cdf25defbc155bf776bca64d6696238f0bb48ec31302a782f5665f52d234697f55f68c3e671c56f2bc48202a5ce5dad59e3913ebf9702e8f9e29a4d7af2f6a1ed56900960bf1036f04fb976a821ef9f24093c38155413d94942a7fa9423e109abae616209c5e8ac93e5180c743b8cb2cc2b2a4fd969bae9cbee7bd33b99545c6d66e646e8eb78852423aa7620e9756fd4643d1b8854868f64571d3736c280fcb733c8f415bea4f096c484a8308c3fb9afee55f39002037207418a4925b896fd0678bffb85d91fb89cba5fed6536c06092a7b7af2724ec7a33aaa34f6e065707d920d30774b7808d59b6daf5b667dbc067becdf7a27065a6b4f40b9ba977e23e25daec7db489bf797efe307768e8a07cfd00c79eff71ad858b5964ecdc829312f7a63ecdb6659b0afef2fa73d6084473e3f75a51ba0ef465ebbbd56e49c98c99138e98d5629d543f3dbd5621ea6a60e52bb93e6c17a26e5a7b1077c5204a0e94c45348b34b8740b457f1293c166439614d2e1bab016dce2dea494026a6d50b95c4bb0e6a78808c3b9b3d1fc1dcada02029fb9de3d6fbaba507ec01f018e26b43f9ab533ec132fc578b48e36b9166f4639490f963bac943c1fb395f16401efc805b010bba191b332909715866e333fc8c8e8f786fbec4addadd5f56105eea910623526b0e3eb11c33809323247eec1d1599c676cd7b3e7c7613cc2c25f690446395147ce8c08919c3a4ed4ece1e9b3c264f09fa1ce5b9691714634a7cef4db5a0164844206e73c98048e6095eca9711de9467ff6ee9d05985be90eb288369298cf15dd3e3eb3e97a033d2c1e1c1ff05fa25c03e5c3964670f7ab9250b6dba6d14846c118b51cec80d4f9042629f599d3f249e728da3544a338a57fb45b1586b2c81a6585236ecac7d6256ad6214c4f2aa6757bf48961848a860195c2551b317a885e8b4ff487c817a771d24b442566260c3e5a24c02c4e80429b230de19cac3557ec1b69a6a59b6048a57651de946df3287d6a6a5a8882fbb23bf9233438ec36c4d26c7cd8c1469df729dd7511f5b6c60bbb23735d23c953467510997a8694c8d4275855dfcb2ea4b4dbaa642bdd4063353a325f2589bba35028e5837474a567c48bb7d1d73888ba5d94353d9c42fa66c69a066ec5272192c60bdcbfeb5d0613b72ceae453de3f33b7b857f6dcc90b0bf29c389c5a7c72e42ca8a5c2fee42b2add744c3845a18306b2183e38e66ba297d7831c0f9335d8bd363b21803ac1e371b24adfc74763ee3841a1f6f82b708e7207af96434eb5854fe0332c001e36d4ea21c32ec510a831338bcff40120e74a0a108ec2fe4529abb07d2b596eafe445acf5d162c9776c42ae43b1d6e0016c2b498521a019516b5948aa3601f8d400b8ffe9e2e5b3c40de150e4d7abee8a54cf89517b97376307d8a97fe05a6b93b825e152a359697b60d36b0bc0d88d6ef21a4fb7c5e0e365bb5543eebb356e510773ac6cbf4cbbc2b9b781c5dc800282a5e2e239218fa2b35acc09dd1e0e146e938e7702141bedaa5f10b991ac1d4393431fac16d2b20ecc1c84b45df6aed0bc2c119a35ff9ddcd2ccca8c95d55e69debb288d6bc53b258e46de40f9f60d50583f86be2432dadbd2995df0c01b058e2e65f6b6ae5b5a12626d3ac1ba09b742635b3e7ce6af659713b2b4f3bb352081803c67226e108f5f623db55cabfea0d7b015d3e104872b05e2191ca46e84a4f9cfe10dbf58c8774446e71d0e9145f353076c326dbe8001c08a27c6776624eb9edbf2754764a7a77f071ccbbad70122c33f439f87347f394f1fe5ae1c6a7024323c78ba48939011249d0c82b87edb86892a2117e330bb4db041bb76fc7f4841c3e572e180f6d47b7b1d6041c1c7385451a5268e1b8c571a3bceeeca15e2f0449df4c195f7fc147b170b825f96850ac59ac78367c8328fb97795e4633ed4a86275cd655b0f88cdd5a93f6309aa60edc0160117e3f88050615daea4529558b88fb41c9f10a8fdb3cd4d46766c0adc4cce2011584e6cdeb8eafc13a15db2c06f715cf12ed0fc6ea51586c28d3465277c496f49bda81976cde8272b2d71170316637ee17b19b9e164a9b56a7fb9dc31849d57e6fe583cb761e927af34bb3fcf347310642b12fb04ac1a7ac002bd2dbb4f1d134c4309eea515230d324976ecfcf8c160fbd9b04252593b8eb9f66e8a3150903c6e0c888949635f854c4745a7939730b27dc69e5388bbd110995640c57e62232aaf1c12e2561e23069cf3ac6be193065a4670f5ceff8016368d3478b0c3917217088ab762ce3462e2b9e9e01a6e5c7de6c1220ed0599cdfb8432b576043ecb86ee2ac13a48a085457eab77b3e865aed73606d0e7892bd34f666c29768085d673cb569c9e5879a976c9ca800a7e1b0624ad8e0ba70665086930670944c67d5aa35f8cf6e93f222ac49760e02225dfe880b78d6849f73af245328ed847a8e687b48b156ef1ebebca44a9965569fdd0162538d3e35d6e1c1048cb970f58d7f6a87b52d065574d3ef17c1918399f4884924e69c1fdb4792b840545682c7681969f7e9ef96176f20c0e4085f0320f44eb2a56b1c4a5d1c102d67102256a282b42cf22b17649b8f1be4f8546fe2d15a9bde21f706e248982a1ecd620c3b39f55b2110537eb00f8b054b3252f20a6ccad83d7de2702e3a86bcd30ceb4cf0617f37bc422b7bd4001ac0f93de392f61c1aaf807f53d5ac9a949ba00088fe729951a92f4065ec7fc796cde722a57945c4d42533591d5f059bb4fc42b2fbab26b56cca56139e11f8ec9a8ebb759a9a44af2ff04d49aed184564760bef2c7f8581badccb5eaa397703d06c53a08a989db1fe201bfbacab50a6a6643d8c91e4ae8ba828fc9836bd80c16378a142226375c1a381a446bb3e7833b233ca278ea656722f46744993407aa5604d134ea4e7f6fb304af1bbbe1c632b2ff6bacd1e67f0cef489c199a42814e6444484d46643dc759f4fa0ca6bd42dcad0482b6795380ebe293aaa09071b7a99688934b88504349c39c0a7481d6abf055ca7428ef98da3bca0fdf3410501339bc48f78b7d1bc7d18a552b5c8740e7331cbf1c8f940728a1218f456a9dd1009cbef32b56d680d957ae85ecf180e41126974c07e930dc6476c8e0f16323c6bdd0382c18487210b3a43eb383b3a23d8ff4d6c27348ec99dee418f680af36d72c7617de74449830a963702c44a712cb3562509cac0e8cc449fd54c1c75ef714e018d17667611d5949ff14046feb1e68a7dbd8c073f35198870ceb5bba2e07635e1fc79711f4acdfc80616c9d71b10ad27cb710502a7c213a11195a12d08052d0f9093e732d83d97979750ea5c7d11538f7353ee2fccdbe3be9e14cbbd477f5dfb354531922d070c1505559ba899a8f2a6f584560e463067d48e2f3998d605cf188ca43f553f29d673f80b184156f89a923bda5d375b84d558a0eb964f7df97b9b2bf8950eec7b09d00bdd95ac2fb3eb990d25530ae1d35bda7828876dfcd3084647aabb85f098da8c362fd985a73771694d3147a9f80df7c260f72eb896551874ce1004a2590ef28855318ff78ca0c6db5384583fff87e8688a631d44b702c599827de246f3adcad44a2fab3a3fa0bac6fba30b5431a8685cbc7052ed945b2183352434b42e99a7e74fc8c39413ca9015432b68f23d584ce88b066f09a0eb6742076cee2accc1a1514702468d1ba1a8f6301c78b8d5fdedefa07da68784e48afe3823c16e06a9fd7cf54ff1a5ac267d98ce45f713f02dd30cfc71fd3be0e99c09f1d386452c0d6b79f5992ea70a52e1b2f3f46d981b633b1567589230bf04f62d5e5f7bcca12bb153bc82dc86d821018b927f5b31fa2f21508f21a3bb90607592a569e38ad787773a2fc65e05a2059f1c27cd6c8d7e2f545b1a3ae416fea9b1948e7ea9880b7fa09ced96487ff52cad79bf175979bfafbead7d5c4e621306be8eb65a04cc41ea7b92509b28abeb0244f7d1e2a32f38c48a7332272dc487681b0cbc769faf3a6b713694cd036fefbc972a8cfe326d7d8b29f554d71b6b7624fd48f6e3fa4f5eade493b74ba77de2acf1da71372eacbe67341cbdeb357120baf0a95e3b3e7f90eb2b62b5c4e44f53a086ea87b5469e638755ad710b8beaef06ba221b0b1f7f74a9f06cdc4209061df992b6da2028e723f13495e050c8679d386acf5282cc0614a8b1f8c85ab26aebcdf70417e341e72b03a014e343cf1d1d20dff0eb3bff2c8cd5624aa6144cb365975da6ceb877493d635fc5b3ead50eae01a957fdf19b975602af7e9189343abe5405b245010f3bf8bee0bffb7149fe12c04e780f7318ac74dd1cee4dcfe45c54bd90203de0b960965d1b75df4599308cf971633b88c02573e7f11c2135f6a3501c52f6fceb3a61e0fdf94444273ffc90b4a48429011f43f1185b3fd38a2a92a83049d6118386d24b4571423746e2cb960b407f3fd0993eace2ea8eddd2cf1a72133c3cf30ed201c7e895f5ab90f56808e77915f0c6e75ffedb4863258e8af850b39f16f6054fb01d010b018e8afd72da4d57914ba1e48decf911baa8314239ceba7854bb2e8db0572750e55fd6c260ae0e9b6845f51c0a3cea900371810cb9305fd70f505b0b7854901314b7db85daf5f8b928e85df5d98a09e1081b91514d4b9097af4f0393b736ed62a6f916d38da4985d239338244b165e44de3d6dd10e81861678af89f9c83180d8f70a45eed51fa44565e1cd59c8b05521567300856848e271a47433a475dc9a9c97424c1193dfba9e295b9d27cf9220d4883dafb02aa7e3911642c607fc99031ed3bea1d41f8fce52988ebbb0f5bc27c696bf74131a4bfceb8f57402b261c3ba5704f869dfcfe15d53b3cb1f6f86caeaf62bc3e7639d9a3d0efd4fab8368a0ddd240aa1b17dfb650324bd6fadedac91fedce44a2e3dead8fd5ea3c7bade5e5e493208827b81d5b85a04b48b91c6de41c6038b764f684a53f4020f8079add0588fe5bae8f5441d442064d227b8009ccce66faf61a55ad76130f88a75ce3ef33fa19e15974809f2124c3d7311e2a30247fdfb338daafe4e5fe8fda681b9ab01f757404cc6b64ccdaff2084156305a8562be093978ca990610208cb8a557baf901e7d1a0e7053eed94eaee4305de3781929d471d6e30dc3d6d02fd8b175de772316b4f7b5e3b0a7ac5bad7cf1e65da12f2fc76097f33d5b323156ddca232f226a9ce1c919402dade7e719baa958bcdd64e5188ee467e15611fec72c3849c799881a0dfa8b61dac01e34c91ab51d74715839d1fc02d84c691fe0a2bae3af1dc2aa21789ea9dd40545370df4f28447dbbb119e04e286172d71fc10de91827c4992be4fac389e5883864cce5501d3f0a5832d27f1c8c7a7c8318f3d5d8b7a3213ddebd1f2392135a29b91075a80885df45ee095bb389d4170fdfd7f4585fe08f3d5469325c22b5d8ef539818ee740e01fafbb483de50557d88c291357af78ca1a445b025526e3e6fe9cb8987b53cb17d02963c59f5c9e6afb26e22a2f152483d7398e76c0037f8aa669d4079f685063b37178ebc0c41933de26c2c161ef7b1d14a42e71c4f3d5461b5a09392b8df78f980fc3d8780efc56ed3b7eed4ebdfb2cafe081fb01537e4a3e80062951de273e5623f9c915980a27d2e6b936f90e5cb325584996128a0b8f81ed2af754b88b5641c89981d070261e285f5c64a6bb42dc1675d219e56172418d47ab27888a402d528bf5036989f1c3dcb1fa568fddfbe653c2db1c857a28704e7399c84113addca9e46984b91c3faaa9d09b6dc44a98a5e10981d5a9c2391c3cbad5af807c3a9ede086272df250102d462487847a8714d9bdbb7640f41d07c6feb1ae030c5aceab341fd94d330abbc3558c48c614e278cd26d766e9b1405b80e06471f642e4f67cfd49ecfa3cfb2bd429aaee5a91e09ca2170de264df3c8cd0a30bd1f6a5a185a25480c41a67116a6d408f496861260b1e9fcd4ef406dfc2a89f239f3566fe07954a751f9b09ed490803af0c6080f201fa2d4610746fdb95454ed7bf2de5c2e5019f008771317b0f6fa1fb889f8b964ba92c7945641d668cb740d16c2d2b3fc98957d5b980221c313aaa4acd21fed6c987c057a177ea2924dc36034701f238ed5dca044504e55762d23aa5b4b41f03300d7002c99f6d3675a6f9e94defa5be8012b6f6e7304f0fedf33b1493677e20af8c3f3bc40f22feddea600d5bec37556f47714e868ac8f232d96ead7f9167f508a964e075059cce66fa4cf9cc157178d9b4a34a4b4240007dd53e0e374623e7dc60a570e65cf26fe21158f8803034a5a7631b845d4e333347b63f27023037aab0864a2f3e7d479c6793bdc01ac645d7cfdd2f812c3d1096243594698475ef073e4bd7a7ebe251aa918ca6dfca5d07d1149d318d939bea817e1454ca8265016fd95104e5fd3c0879106e0a32c72ab32b6481c73b8ea63842f783d37d7077143455201ec6f1e00a0445fa9829f65a0e7b955ce88b0930ed4d07ac9a960f46aa51db55aefee0d7937cc948ee51b6068c12470e22188bc68f5564500d2b07c7079e5bcb000836ef9511b2b8850c54ff5fafb50ed025f385ed54d75280b18c1c9cfe0e888b5e4f069506de7ce29536a8ed9ce9728d2ae5c301537fecc3d8027d09b4cff78ad5211ce4a08b3eca77c801bf0871b1c485c8e5d05869e763576b062229c27979f9a7b180b91f8e23e82906bac773619f56dd8d794c2ec6ec37157da1332809bdd5252e4b2516e3376579bc46948b12752a248c287240078a80481f907ef19840ae1362a0a6c5056bafbfd46b776aa2110d3d6fe377c70fa36d1362d4e03b8c1df05b9fea3496f23f0c7ea806948987e55a6ed5e45217d2253d226fce8b9b04e04142354d1605ddf73da55158b6ade260c737982ebc344bcb81cf9a41c9999315152a702d8cf177e9cbf454f8fdbfb82bd60858185b0594d0f04316b3fd9c29b0495e629119500f9086e40e8d5dbcca04122441a81cf530ec627f0b6dbdb7ed727196acaea514c9d363fed413446a15892911c08a55b4673868fc037c1c4afe70dd043ec4f30068e41672e919b77254423758fe413cf578fc62408dec123feac9e6e2ea604f78bfac178bac5fa26250ebd0ddf49c8d5a9e0b571aebb68fc5385ad57752bff5fb4b57418f92712b7a3108aa24c92504042f8b24e9bb97d2be0d302ae29d50f2a379c0018c70c2a5055cf14aa53d5b265ae483778e53d3ab01bcbbd27bcd5bcbaa39cfe62d74a01d131190f98bb494703c550ce9b2b3cf8182a32eb85d02900ba1b5181ef3e532292be17f8cb8755430671e30d1d53cd86fa9aeb6deef2e838fe07b018534790a2d9974623a852b080894a92f0b528a262186b6222978eac320f7ad9eb57efde3e5dd7e0e24be6541a2aa58964fee2ea4239f226966b6daaf369d55c1d5773ea2b78b2c2b33b98146635e46c94a2e3e2e946793f1bf80b8bf9610417c42af68ad0618bf6dd7b7468a6de7d14b271500384d986842406acc9789e4db0e2148d7145a2b339662e9f938663589a73d753c26156fe96f73a6ed2118e53e2f4f30988bbd15903c92b69592cd59b383885f3e79ae0d1ff30ff7c7f558566780413f04304d6a37cf6ddcc3d815ca17c2185ca642eb508bd3bb3a3a60f11633641e58c2fef768a72f04c5847b021224591d78233d7540fc6884a37f5ca01ff1dcaab87f5861a8519162bc6fbe06704acd5ad58636ab146547fbd94ac054c3c0c38c605e29e3201109ae5a90b0b09f53c8f8691de961c771adca9872ec844c4721093e12b7a929f8e64bab8f3eca14ab56a259181a7e644bf4fa6d8356ca28fc13b13f9226ecc349e35fcb081d52798eafb9df7cb034252e15083915882e13bd3b452f293b47537c9b7c482860f3944025533a125f2a09b2121a1b12b023eb52d5e26dfa6e600bfc020c9a4022e4b0178f1a6630f6792ed2fb2d3a140d9727eb21a9b22ca5f7fa9cec25c0c37535d21c34e7a3de912b359a407727a2ea29bdb1d9ae2c7202c6de7bc675abce9915368612b16e4928e4b0cec331200622dcc803f97ada19c3cb87447f0f5b7425eff3e7fbc32943297d335aeebf8dd0a3ab88b79a8b640654d7c5cc017c7630d17eb6b0be9db5d6b6bc173de9cdaf01e8045b2ffa077186ce2fadc1605bdeb93d601c0b948a8970435078841e239ee5f26a938dfd7ea0d34c5fcea9825219f8d9de6bc0d6c026a482c7d6ce30a469a517a7c6221be39b77d2c29a9e608a2201f0a6964fcc35f2d91ea850da9e92e8a77606b92f5b366e4f2070fa2abe24322ee1e09a36ad6a3e9aac6d02143bb2d85937a914f7a292732ddad4426b8a2fd03c6b8b32c4339cb59cd2fe4c62ccb6446903e1c7edeea5b8cda9f07f80723e791be8f6588ae34133ccf1ab9bc883e210749a9adbf879c1f461e36abbfdbbeb67108b6c0a120e4a6e61b5f7bde3e6032ce5203170f33ac731fd6e03b449ee8b97bbe13994613e57c874c9c5a699cd26721d60619e8c741bbc2fdbcee06cf129e9a999bf64c1d5281e6bc70daaf44e5b81af426f5d402a00539ea5c622b644bebe59c39d3fa10cc52783bea8a3e3ca805c03f328c72c1f766930ec4fb5d40e56bff9446a909ce60c967bb2f1837024c7d5930d246ed83514fbdd225f043304a14d890630dd3f22e0bb4b5d3c0bdcfc09e85ba5473bf7f125c5fd95c2fc805050832f39f9e4ca3eef3d46be295758a4d78990f3597cbd3751740d239b0cf3acfb6c063253f2052a91d1fa2b4bc265c86dfd2a251f8009baec25f4f2e6f5447b14c4f116e98320d3a558f25d4335ee1e70909b85e1270f1b69c7e96a69880ea4f472bef8a1239371e66ffaef2d6a97c94a7bca17203428ba1bccb3fd954ed2eba42f9cbfc1138b8326f35cf3bd66f96e2d317eeecd865453742a4866f833809796356c79d766ec8329bfc2a65ec2c3d6fde9bce5664d225aa436887e0db581d35eea40f118d0b69e90d7403ed4ed0f9ab6f3e255c3264829c563276762dbe1c5e7a7150f8778da44a8fcc950fabf00237de889f62eb89c7349416f551dfb9852cfca3d5e3592a9df1a916be77c387597e1c221cdfc308f7a930dd1a77beaeeb5d728a7c58580f44595f0f5102824beb2fe58c6b4030c9604f9a082cada54378adf7ac255aa2bf623251c9e7f3b0d6fcb5778f1e281c7d91d56603a09ff87bb3fb514457b1d5105d15a2bf22fbd8da501bc4eecd4d680759c4359c83cf61602dfa4d3fe6834829b2c9fe021f46398bc722f65be93d33bda8c56dbfed3351a52c667320b66897068dd3c17523e39fbdbe88d17926eb7e7c716051b0679a3e93bab844209abf6ac92f1f64ba43b3fe77f0bec5f7d271f836d6d38c8248217a35756d0a179087ecd2aec69cc8a5aa3fe61e1fae108716d28ffc600402176f6769171156df4c0a00677242bf152ce7874e536535b8af524afd05991e3ec3e575743fab8b3f2b27fd556ee2ae56585c34777d4bcb50c4e1db25f71770ad1265404d3eb3f2a50f171fdb379a162762521a051e7eadc96edb60138ec6c2aa678a5f271803993a1394cc460eb34bad99d01cd464d93c74a0cbb9fd17e45a3e23fbd3f8fbe69ec005c295ce0f50882805fafb1b1b35a9729ba9e07f2b764f4d6f324ba8fcca684eb949b5d692e0ac85e7386fce025c0fb1a5f002f97c5c152c1b29adfb29fa729924a60403958fdbd42e149b71e73bd651b0d04f9a72bbbd86b7987bf90f37319e17729ef7028c3fe63bf85b155e9efc71eacd75bf5ba3f6306aee3ebaf107a21c8d34cecc2926f9c286e371cbd2f97760973712aeaff52575b3b60f7ac244a077a397fa7855db596f5745c8ac48c5477fbd0ef5b674e230e57a689b126ce4aa3a04daaec61bf8c27f73db2a92d29ab4e34a3833e88655e5e52a36193a7442b5d4192579367534c313f976c214489c7ffba1e1d82cc535720001e59720b063e56ea5a7d92cb3fe5ec34c247cf1b0dd2c4c2ee9c0ac3b2bdae2a62e4c64e20b630fe029e4818f6d93c3352307d25689399c7c4d1b3ee1b4a7d4c1a2b2ee6ee5263d01cf0554a2d77355815557507fa41355d6572ae2c8bbc78a30c03958ed427228f33755f5f08c16f06738236d6aed1f7325f054b484c171b23206c0243957493021e67359bc647ad7b5bc07858c282f9249ccc36ed8692efc3933b48604f668316ed6eb42df8cc3ee4b805c7c710e943ca0a875bcdfdba2f1b209d0e90ef34247e8ac9b12eb0e493d66c45ed917dc5092280c76b33b58a388e1dc9f69c6a73ae17a2c5a3a90e922c97a81de854dd10f1be3589c90c913b25cf9282f5599fa5c02403feb3fa4c8d00f7f00d84c148ba099c1daec55264366147f0bf43238731a05b5dbe262f2335c227c8526699523df5553cbfb69d240c1bc49c3e18a8ada28b29124051117b8ed0f6294749832197e02386b4a24f09dd3ba16ef6e61681be92fc1338b773b7139aa3aad2132332484b20a99ade40dfb69f03b36bc7df4ad84779c2eea2574e28245989a859c321c085911379213b6374cb1e897605cbbbb74fa64b0278272dc2e902b9cee38cceec9a777872d0d5566caf11a3a4757f55a03021f21c703223560e5c34c951550a197b9520c25711394b2d162e0e65ce2568ae87efce6430b123b60b3c9a8dab79a34d84a4685479958f0d0203917e5ca27a21fe103e812773ab663a76faaab86f045a5aa48d7f6701a50f8393a2c20ec16563f384154032097bcdf4ed298535c24e49f1e9b362f3fc96b864a3348ab9a4855efc429e869477c4222841aa176761007e8b24a80c56ecb3bb2fa3cd53301b88399c468dc3a9243508279c2b2bd393b03244b4ecd066c111221c9979ea899af7ca5ee1b893bb15b5122b6982916f2964bab9227a81b08a132b6a09f393cefcdc0e50dc53afeef1e557bad8525f8ec41362ed22e32529813424fcc2af15114b93273c415f9b763e9a066d0ddc5bbec75686bc8aa4d1d0e8d9557d67db3c1f559da97962797807a86c45c2b69e645860e8503afd35548c489fa9c01db7034037a402dea0a201a2c30c25ed9addfa05140524163c47cb5943a5634610d3047e1fdc5ddb3b250f346ede559674c0eb9497b77c447af583034b677f3c826897f2d4c7f1f1cb85c23fbc648116df638e1b80b7e4c74f8666c24eee6257b2681ce3edbf520957eb7af01248c469af0381ef2209e89e37230dfe51a68c754f966e84524c67816eee0c4e26f028a7363dca52e2616a9c5557756c92d9b1670ac1b48e8ff9378bea1373a6a0b0646e619d3598c471fcf69dd06c43a6bfafb14b9d453078b57b3799201e9c35b2e3048632de339c01d04d58dd754c1a8d917461c134614984e6e9b90ee49b8cb4b1f266faee86f7eeef176e058734aaaaf8508be5d7a37d6f24f454af89ce9fe5d1f649785f3a3346c9568d2edd2b467b04b481c225e912c83fc804c8e34a8f374af9f7a65313184d042095f08f571ce76fe86b838bf7cf557e084008660d891584711e32a3828c8d7d24b6e61a1b53e0410c415d679c4a1c0d9864793fc1f0551823256e590b4f5b80058d947227e679b2647f406b4d2f95f370550eaef25ddc4318309ec812a95ed7b226f053f4e1db69399cfd393e95ba39e2e494c7c96624c0a06b4544afd53c21017df6f45df0c9af7b96719422ccf6ea0f6064e6aabe9f5f2ec84d88d26bc3b6dadbc269d2c6d84ef6301a7254a17277547774ed71b1f106fb71e54fd143cce41819433e6e580bdb5ba2bba15288c4ff734fc45d70c81f47a8681e8ddc07826b32959d5b440438d65a265e5624b34bd00f2c789e236af29d3dd64d19856b59b2aa8aaf4e51166b301b81283513c13deebeffe8fcbe89006a0c938d1ae5e48fbd5078962a03980cf55a028de985c972bb47907812dfd2cb4f67b7a2a9179059c9854c76de08825bade0ed5a2286367f36ca1113557da1a985f61a2e185b4d3d4bad79eb25f53f2878595620cea7f70445a9df8aa9aa3054052009cc2e86093189adf5003863dab4a44efc3eaf15f6ab9f34009e184de9c1a2679bc4d893c4f84f3e2f2b10b74dde7f1b85d277bee9fa36c6c22268698b8d28cad33f727bd9487abe6c49d576f71b6b40e23e99cf301ffaeeab89bfbae9e7c70537eb8252fb193e34cc08e040ef7b1fcf1a423dfa725ea0e1edd6b70d99a7ece5192a16bb7d3922646bc441aef5f80706932a0feb8860ac2b3efe640a8c5b5b6fb260c2187eb44af638d884b50d1a95d3fb57f89c6847e895b5e27f29afc8b81bac0d20dbb289bbebb211a75204575ce31c2960e35660fef9955b2dab4dfe3e54674c50985642c2d1a65a1cc26945dd22c840aeb7064309cd83b0f5b9dcad52ecaa54c8aa81a92a7bc1a378ade0b38984cdef6b2aef5c9627137bdbc2c02dc8af63f37348d604e28695c183eb6088cc0db673d33862f46b0d01a97a62e4866a1416672e9ebda3e6c9ba3878911e760fa3fee723c21809f21ffb06d5f0389bf42150ac75076588217a38a7300c4781a63be2841a5b487f7f5a08ae3ef423c880c6ef60bc88314a40ee12e7b5040a324a36cac15568576fca1403b02fe114b48f88f5961630d213c91d9d6adc1c5c47751cc9a239edf887db739040bc0c3a8a2b0317287ebff2adcd437c07cbc15058fd57095f397a391659696238aad97477777e6b413891d154caa2aa5f0e0fae95d7652d2d8a9159f03b32b23423915658a34c99e32fe809be06968922c60fad7a68a8d8a1a19a53dbc70ef11b0ea5cd8e261c935bb4c6fb7edc58fb25bd1529dc5002988582bca2ea115c8b77e63fbb9db1cfc84598858e3dbe848f49f93128037593b976da6f7bd6f210028fc06255def07b0c551a91ac289012c490d7296ec0ec3e7a6459f5421ccbb06f7e15d74ed3dbe84150392698c0c81d81a6bd79ae22e2035ea329a31c583fa9608998569b053e5571f90d9a6449068964c9d4acf44d181db4507678fc72722edeedee45da4f48ed4af9872b6a9f37893859332e1816ca920b78e3a32d110ce59716831f84f4667a510db3bd92531e41eba90d8511a5fc8df039b964e9e067654ab6b98d0295b6ea0fae32168addb25e5ff9fe8b6b667f7a9eb76153e8cc4709fd1e1bf61ef92b0c43901a8fbe9f12879ebb243e78c60d62706a29779eadbf515ffb5b3a264d8fc08fdd9e6318d947fdf9cccfadd2878a914d03249b0c1743a500bf24f37cb0b6498f300ef929d85312ca681f2e578bb875bf48624e9041d298d7315466a70f029502e708780668f44cc062101d642899436e7d616812511ece392166e9ef4c4a0d02c38fda1d198a9d9a7bee7005e4ac534231035ca4e761d9027eb4fe96e86cbc872f7858c93ce6e1c14f83f691e5cfc016a4eab2d49ced0df8823749297abde399e1ed1be40103ee5bff30e825a2a8d67db64fae817e67efe20316a1a5bb857b09d5612807e0ebf43c2c839bc14164454e51ef91d522f6ff3a9b618620e7c41a2fa064e83b49a9fc9476c74fc7f714648b777772c0c7ddc519ccc7d74fb6474f2daab725406bf5956eec17e6210facab4b2da77cd0d9c116974c6f8b6f8dcf019fbfb65aa366552f517b9462aa496e8f151aa183895e087c2b5e1f520392c7d689759975f8a2955f885f8efdc1dcbd91dd5e10938e8eaa41af2eeea4fb84c159f98cfea75d0a787c4d0302bac06275c4143e7605bf903a4d9a678f7659af42b7bea911c6475f77feca3978b41afaf48e4c7ae91d5ce6cb41b074ca45bda584663e2c4aea94f61353dc7519a808088f08c9132a48af8aff3666ae55c61f805ab72bcaf970981c3fbf4bac7d8d15f40061d3bc6cead251dde02b1ab756a7c0da1867f0f51664d391409bc4bb0a3db24c30eaffef32533f22ae34fcb429d8718ca457f86f4bb049c7aa3d6b95a59f7d420ace94a8589963cdaa0e1d9c3ee072ad44750edaec47008332adc2fd635ada6df627c6f1007836cff3a62dc4e39d275206088e4ae1a586b44770ab0c030ed71db038d2a10d56c13d418eb48adf1b3ea18834ee55a9dbbc7fd65d65cc39fe8061333dbcb21b4f8757b69357496246fbbe9ee23504ec1bc9ee21eaaf844691ff8fbd577b3f536893e9749db40cc02bbff787af6d430584dffba62933dd9945c6ce4a0426cefbd29d4362ef4df541c15594ca98e568e838032cbca3876e512777631e86ddc97de56ba77378f0183213c9e24c85f2b461a0ca75576033b57289461727e7eb0ceae0e046f440dfd008953426b2dcb53b89bb241a8fe0bd48476b0305309e3464f97d62bff96cef93599bd9bddd2b7a132969be4fcb57dc7069a89191a82ca7e3b52a3ec01735ada2fa24e4cfcfde61c73b7be2b6db53e1b3ed1a2722942544959fde2ac5f3b496bed125f581ac7ac07bb588ccf9750891f2bedcb1200ea49d331fd06bfcbbc31816b63878d00391944e0ef4570d7395cfb562cebff5234f39a9a44e12ae06c4b29f0ccc0be8824be22c1421c59509d6f1942d88ed987e4fb00bd50944c8f3f17c2e19dc6ed9020820d577e7c46c58dfcfa3096f920e08aca5e2cd695d5d50a7de29b1027c85abda5920591eae0c8a4e9a211b9a628834a7099e8c7b5a8950a0d5e26f914a8fe062bbf053ba2fec44209dab74b98cf4c954b3f2571c20bf8753767408af1921e794f03ec4b237444508b96352312ab7e8db823fcd7dc3ee928e04a13c16e1cb0c4446d9508b8505ce6804976dbe428a1680ff215fd3d0fd19ce67ab7d517a726e4bef0de29d722de7ad4be59d250a43657c3ae6af711a0d0d628008b073abe68fdd2fc63290743cbb1c172b04c464e984fe26e94f06060a546e613c36f3c0a14107d3533d7c37b9cf5e6e174a3e51b84b71592c85885ceccc79aa994a0ff104b339690a4cf287df91820eb1b6372214c909da6f229e3a743f52acb34c0a46865e5cb7846e35ba1e58f9031f6277ac9f72644c8c7d090d05999717113302fd774e8ad20ef4f358d67f08fc4eb1b5f8607a9d3120d80c3b372b9c7f3805c88dd8c45358ce529ccc60f2ade062dd58085fc60b285a66d7a05949a263c5b6ce24ba050f5a8b651c8e3ab4bff3479b8cbdc717c347b515e42f9ae6124490dbaabea3e353dcc856e1ee9d1d0851913e8e35f7ca122315cd00a70aceb36447d22fc1f538d07efd1dd39cd5a8917f32c1fadb057dc8ed8ae9b1e80d247b504362da58e5dedbe0efe72475581f5ebcc7e75c73324d2eb72c1efac6b351e09ed36a4bf7e5b7808fa3bd38b2a555eec034f247019eaf578dc60bf334bf42cf838842be4f523e16997d161a387cb9fda8eb3e46b6f8592b5f28a0ac78f6d9d555404d4c8222d66ea344030889a14da2f42feeef82319880af960d39abf5ea39aeeed920867ff4bad81ffff3252219bf6c42e01f1a302f2f871a97bf746e899b9df1f5964badb3afeae492df8678b34503ebe23197ebe4f183b4fe6796f62393a02394f7cf151006689fa8002a71176fdff2d2e03f83139167d8a556ae6652328d4204a6d78be9a7e9ce72e48b7259b79d5f931d95bfe7aeebfe98c9b0e0a85deba0ba657914e9cbbcdb000c24ca30f18c94b4c1c5c749065de744f1da4cb19c843951034082fc98e69f02d62987b564df148e53db9737ae7c67d4b6863cb6d21dcf86197b4ea86eea44b9762f87f711f6f72e82962a8a4177e73ad222364ce12876981aee2efbeb6f4ff881656c3430a26184cb726fed38802b960d5af91713c5935785d8402972ba5b54c9806d1f7ce9a2b4ba129bad98b3efcf00a7a9274108d3bfb76db5723017fca9fb16686735ce48e7ffde1ed31cffdcebe68b84b47b5eefd0dbdc65e8a4e8f2389142e1487dc4ce3e3ef24960fb0e06c1cb53e83f177cfd653363a714ec3dc034aafeeb49aa785f244808b30b456410b1b3bf9a70523a663ef8b3426ae85f3c836a8492da2679abb3ff73bca6bf0226dc98e63ddd8c5cb2cd8c24648bd287f48f01fcd8d447b2487a64714f6b30c44c0e4a64fa8f9843486f71db713f677c07733d3d4dd47ad84f4c137a3866aba448cc27b285b35e7f4a66027ebc9dd41a451cd2e7ba61c523d05e9c0c9e084dea5a230525f24a926f6a985f26b2c8147511344554bef9fff70f1143ca8546b08557a17945fc41d75905a59b78f7589be91e2747f37493769b9d91e1e54aba30b142fb280c844e87a9aa9558e9789a9ad6f462ee222cc57f9021461e0fed8f8398e03a364af19d4e5a86ebe808a86c1ce1f524a8eae98a3c9c0a9f2bff70040e72d82ea34738410a46f7e8cfb543155c46b4036a25dd7a5c63df6edb00d685c460b22978d58a33dc6bd803e82f1ee48a33149e4a484f5f9e97cd779184b63b1223cc492c4e04a4e81a4b00fd7adcc88a7edfc80c397bc20b2c469717eafcc44380020b503beca9be1715636f39de667e6978d4a35cbacfdd4546671f09c57358796f7402679b8b0ab0679df1c3f7c3be0c58f918a0cda42ee0d16e57c31e368f4a9444bd732b69a145b0966f81462e789fb90b9853380fe876da32952e2abc16b76e6bceb195eef048db303b197514309d0f009bfdbb83c77c3f902c1001f9be6cc0b8c91e034f091b73582fc9d37b0d736642902a83108849b668a57553e664257e970bd5cc2973c62cee97bb76f98d96750010be12aa1e7cf4d2185548bf882f0f4d1232eba6456cfbf9c9341d06bc50d04a1680de0ea31f2ba98c17a4baf9cebf8b6720efb8d64deb21c0ad5a78248951cd90b128a8ea6a190d40317706d8f13533eafd37da52eb3ff87a1e0c2d73430b334899aec97529b408ab9af0fa21b13e35c449636b71eb60fdadae581c79f15e1eae327031fe84f3d5578f8b0d7978ab3a69539c8e907840f11cc83426236a97e358977a737f4df78c4a9922de8d58fe097d2687a43d5c9628ec657f742a7eb96ea690d5227504f53e194eb6ba376b4a6f1c6b84ab5e6e85c923ddf0a541bc287d6022b7f3d3a607a72eeab7a9e5e047c19426986270a72583d55385d198d4fe2b30be2876dfb5d45035446439630b4654dc6a0bcc3dc9bcc714560081458599c0f638cf56bb34651f8220b80386eb9c6bc05cf698fc4904cfde87307c61bae8f6bab9f99ea290236bd6c50fb9bbe7b2d4be407c8a987074ec0c99b7abde37c125e23ff2ff5efb8dc4970ebbc5e8ce70f3d457dd16a3af964671fc0758e1e85d0a717776f9a6b057c33eff270519f15e38cc76f739847a692c2aea88f82327555bfba646dd0478d35e182bbc938639c6ab24968ee5ea4870e09404c5e792ea5970fb934b591de7f8c49d71afbfbac9a7bec7f7a3c758200d9a5dcf2531de1a80c112bd453bcec0a32bc2226ce7830ac0413270c6fcbc95f80a640c712e2d49099839b5c8489373cb8d7fd4a0032bb9e0762bb6d32de8d24ee114bbe99f84c5595e5722a832417a7ab23479d5fdc5ee704f631a5ea2942549feb9cac1d4e522d6bbb04af4e12df0b5b15caa59b0fb3342b22101a6aa0898a75589fe01d756d75abd260d4112cdca773fbc5c15e38ab035980c740fcb5891d3c7713a107f15451a00c7056b22ad2c5250dff27607d2470cf31acb1ff7e67531adcd5984a7d5befe9c705bd185b20d25aa1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
