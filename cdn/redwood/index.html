<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5e550099b5d4d2be93d13c688b8a25ce79d52d91d40b3a6b3b5c5c8502cdb07590df7fd4eddafae7105d794a73de2eb93dc993c8a7c48d90a20d80ca6ac9c7712e2980926a2c26e08003db9a589f57ff6b35613bc93f61daef86ffaf1587452e241fde0813ede1cff7b5f002873a860f756f7be1f55eb857ba586e02604cce48a5b81fc96cdea62d4a7f338f4e673d2de7824d8f9a5369339d31489980eaa9245a49766984d85af3ef265b0b4b234be69fbe5f7a29deb76d333a66d6045a5cbff3aaf5756f05d934e738501e604af67a60a851409bbf802e18b5ac09530ba29b48062e5356516316947d4259be07e49ca8ce2d96a8ed8a70eba02366eb2922a3519fbd061db878f9112af7901e84a8ae463f3d773dc4a884e3f5d6a738698fbebf493419e8df79a5998966220b89aaea247f08041effb89321786be87eea3850b9c5e69600a476b4354af4e1c1b5cf6ff9413fb1dd3da4ec7b8ab5fbc72616b4cb108a17247d70167aecf5a8117d8ad27128380cc84433d4d517691c216e33406faba8442c574c0b29696651e24fa88022f81424d1a7952273a11e5ec4e0b2c569a5bdfdb759cca95ee9edc2dace2d99336fda4121fdcfc5705bf18f0ddc84d5cf8344a8739e3329bd5823826fd197a3cf74343b35226ecaa5b6c55cc07d72a883e70c9876706b7d187a0a289e4b62c954702cacea345cfb4a0abc28075445689b34e01592b614b968fff93267278942100dc3bea66701dc150c79831ac853a95bc18cc1c7bd7f304a56f48315c69c3b27c9ca691e8c8e7b638c74ee35403df9016fe605f95ef678fcb4a582d1c11952dfe85a8a219b9748261f9f9cdcb56c0ca1009ac07b4f6e419e4d5aca489e7f48a95b93db28e5cda892bb78c5585a4c2e80dbd40ba7bcc68ec994a3544edb0c04182dc419b37fe0d7c76eff2217088439b7fd1e14becf1e3abf5ad1603f1f1b83c3c8c7195de2499cc324e623b1d377274c68bf237043025e49c7e9170d024c6a90584a7de8aea3d4467452747a22140a8860d7490be761bfd7cdb07a4c86f27db6166d7171095605f8a79d70b23cd4853cb12a22a6e3e4dc5783b692135f0590f8ca60c1df0dd59b373ec465d4370fae31a78c7af6f60a7e3f03d220aa997989f217819c05aa2da4e98c092b1644ee73f77b63943852484267b87da6ae3dca2d433679fcb0155ce6128a7f10644e4fed899fd702559b76f6a786a2d01ac2c3c51ccfcac417f2fed305da8774a45c919759de39163356005ba1222e6a697e14f45a47765dd8796824c9cb7638c1101909956f3b21f9bba16ed9e42131f26fed503a7c956407546ad04e498f9c297083f534e935d6ad5af798c52a27beaa665cde9921ebd259d70a6e6c2d580fcfa96042c97c4504f299ddb7d1a7d79dd8578f4858d9e6977e6604c6fe45ac650663b56acb9392426bc5957e82d0a127971886383c41b59f10c57d6098fe0893f5e020e2ae98bcb9e11010d83eeab36b32b101ba32c978e45739b025a4251ef54efc64a67afb2cbfc0284c8b7d85db89d870b00d0405d4e17bea26cfbe14113d6d0b0effcbc97bb9ec1495f8930ba5d2d014eccd065d8999cab61b4955f910ca6e12e1ac570eaac28b30e1ab37ccc1822795f8b4cdebbefbb3b315f54f19a98eb9060ff1cefeda7d7372d7a1212ba0599a0c98c7ea0f207b5db38cb02df0506f124a085b2ef04d28927cc2257dee6d5b851d78c2a894e06ed61e2cc04a87daeb58ed6efe68aa4e41a1af999bb63b08b921697fbda9c55d8e14d123052dbe20340f13e561e176dc36f7062016bf2bad863b0592da3d9cb07e0c8e3ddc59553e3ffb68dc582a2dccff741304ccb0b270fb0c8501aaba46729473f032ca5a12436d3a43591f18a9a7beab0529911175680132a0ee77a4c1096044bede30c99f968f79fec0106f2132ff7a7c98210e5af871fcc6bfedb61d95668dff093c365ea4e105c8671138829f3141e74567d110146c006ec794f58ba6b9c7f8d89c58062bef66d3e00572304735fe1e187287e246bae353f1588e85d14a8ba995f273a4e7942f0b3e73acf54538991a52f4545aba95be2584dba20c7c7480f3441205dea614fe214d7a5edab9b58360677fe143c264dc3f78add41b31456b6ded86c56b091aa729ab2db6798d261338fa52ff5e12ba8d294a36bb2da851577da48e102f9552e58723618bc76629464083f0ac6ce21e4c06f69c3f4c9181230c36c1ed9402b1b3da115aec9a8a1fb9c6e668e83141a718e7ac57cd6cce4506f76ca463db092415d94fe21659d1419d2aca466d2915c45b35899256abf0bc57e9fb25e5b486451dc63895d6f0c737c6a86cbe22120567ca077cea9890bb42d6bdef6afe09f1e263e28623ecd81f4269298fe3d58b97d28c26f19a2e4e824a1bbed59895ff686fd49dd4a3b8ac1c132456adfed6bd82fcaa4331e4ab19d3623a4409e1a47d34b53eea316784f35048939015cd47b1f5df4fd035c6f7b0e9cf00a4ca4cc5ddb44b99b6d026bf77b6398539a112fcff9978d62d5d4edee9a815a0ca5c1e9f484f942dd8921bd3ff541f8ea6686a56258306313e49a62adecc9c644f900b4319b7a52d7335edf995d7c43c70cc21b4b1678f6e15e3050b5b4d929e5be234498159e2e3e6209e6c2857abdaff246535bac964edc40d0042ae24c597566d19b065fde5b674bf803fe15555a2f43ffc6e7e40f435104d3531dbd25ae5b644d2b46966e47cbc705bb25f8616bd144b015801c662f5cff847aa748d4699ba43b1d60349003885680cc1b664ee62e6551cc82706469f61c07fe608d3ddd2cc0935011e2aa96daeb762bab8f6ab05dbda9a2881eacb80c49436dc82d2c0e6c95237ba44e263f8ddd187a423f9062c36a0e4e4e1c92909ae03d33ba473d695448d9b0d12f39acfa96e679103356f8806cbd939baa184b4bd6c04bfa514271a0d26fce8f7e341402e6fb8bb6ff68d2863c6da2ce4b40f84b8ce71adaeb748328a3a199cd887708b6d76db4a76bc01bb8a6c5c5353430299fd16dac989cd40bffd0041fbf794b3e1921397dca01a9b59a33806e18ad9063d0f0ee532b074f4b5e7e0ea9094c1cf36d4410cbba91c1148bdd9e4794f8812f02774c8d785c10aa565d84d470f7a7663dc85a75f3640b8c698606ce2fb6b143f2aa76cc562b77711e4a622b827d5989f029272b05a3a803a1e81aab834b92f9664e3b0209e2a181eee318633dfcb2d534b253231e93261b9e340cbb31c640e8d9f27a56de194a06d780defd87c0d16285a7b9dac8e7593226b95f7944348d3feee755f221e0ccd791cde48407c4eb050730cfab4b85c9a761e3165f0c6371da2519e7e5505f4a26f7adb31cd771c59c77b522942843cb1813adc48d716ebbbaa518fa123d9e4a290cf29ac66d853fc2a985f690f5db414c81145ea89b5606928ac71376dd273793b80a90d94961f8cc463b2a9e167575c011d1998c3134e190bad4ce89dab5df65136531309628b40b63d8237850b0b9debeb57842ebb18302b3118f959b053f68f1c2cacfe9477ab35207271926d494717edface717c393bc0fc1ecbdb8f6eb669a5bc5c5b807d1f2db01fff3e3013a7c1390b806d50b7da2d08c51c25250356526310ddba274e4694a63ce52e8180352a78ea6b51be197121436dfdbc810687c143d9a0e3aa0072e7bfd3709dcce51d04d070aa761674f2d94670c9d311c5d1d0e951be43ca9eb955426f5dfa6efc6f1d58992e70f31da137ad093a47d7661b68d3ef83dc06ad93c83a388e454732913005c537eda1659517c4cf9c9ca0f2f4af17821314ee79c6af5c3462ca56c44678f605cb7061c16e20394b8d8f1d0c42c64882ff87c9f4a2f425bae90e8f9f4ab6972673cff8c6bbb7f0489800d634c50d9b3f20baa6ce3e11c98655b29a49b38026a2c044ce67a636f02eac5e3ce46a691f0ecf53981cacb6d722e4103ce185ac49c033d14008af0743764f9debfaf54f30db1e265a3ffbdcf41f7a4a903e498a048580ad82d40a51388b59a8637d749f1762ecbc4687378a751153586d7b8b97862268baa06e4fc5310033e75cd62a7e5bede6a21ab20c5e634dcc163b749de10fc4b46b831714770c7639b00fbae36fe4b2d00b9f849aa27b153274241d1acefdedc0294d120e2324ee52ba4b0e3b23accacfe596102ef65c90eec5c6203905b00d0cdc590e17bca975667f3b9c1d9f71bac16b23aa679668045430a74607567379b47f670225d64be1ed6008e5541ab2317d8ccc0a99d2ed5234cc12246c2694d85142125daeef12c8bba3ec17a4b8f170af9537984d9a8d34c5e6aed16d7c7aebb57cde7399ab21693c5213b6645b2daabc0970ecbe61e560489c2487f80c898285ab4d81f84e5701f13c023a7df3adb520b50b3c28be6de96c1b9c6d10434e539485e9624fd909fedcd53f4af8908137020c463d6983cf26f8ade4f090d9e5e0caeff93237086dceba9bf8ec0be0ab06d9b12153a25807de023db177d25e6b7492a0b33ec081097f797ba4ab3edd8f7703e536d77fd0ed71466bfe9c5db4afada3b3b5bdfefeafce34feb1dadded28e4ae54f832c4bba3b92caf38ae7e6f4710536ed5751fe28cf7c652eb8c455bd218adf3f25dafaa995b02fdc8160142a08a9881961f7cecc8fd9ca32d173f88633c46d300c84e1c9f2694fbc3286c9911b526daa642ef4e0b1dbffd8baeb5c0688f5c8d70e90447023e456b89636c2df540cbcbaccb2437518e8db857048b1792a6c04649918708973c014cb4753c4342d62af0250b5033e5cdab56008c0a1bf23ab292ff7a43e6af6e5e20215d7ce53603830662334490a95f0fd5eb46b51db010b529896c7e7755271e43ce9650fdc0e0dbb3e3dd03f28c5305b65faf15f1d92c8ce23b9104c723193629ef802488d66cd04ce1f46579a3439714b3b04ccc3b60cb1982e2f72d3a6cdc8a1fac6b4c2f1bd2113b9013c51a77efdb24d8bcf29787076e95dd539c276e9648852b07ba98e51d03cd22b10c146346569e97b1bde25590978c204f444a1bf92c70e0b2cb44bdea4f0413872eed25063ce9932d61d05fcd18ec757356c23c2e2ce49bc58cebc83e398cc98da914df3fb62787c11d54e17dd43a5fe0cdf70dc5fdd90dfca60bb5c4370983eb9cd4dc86445dd224379e1d53030199c701dd1b58cd22e038f9130df69a791c840e87198da802e00edd10e249f2d97e112170517f734928f80f64bb0bc282ce809181108db139f5420009df58d2177061bce8fa58bc945d8050043e6a50fb7849f031313347a7e88b842b11a7c2c3b1dcbc1f35de0f18c11dc4006364d09c841d01648f85be6e724590e86df0a52575dcb9daa70aee66bdf98e1001491d01a0d4c692cf07b78adc4265f9826988eda90ae02fba38d9edca8bdbb4c7ab0c79abef02522a5e3f1a78722d4bb2155c6d954b84a6896d620a9676e7d43195a39cf123c5050cfb424fad73ac2409f315ea2c39c9127c59a235bd4383beb733222e8b176978717cef1de2e79b3bb27af571b5ccd7b475de7f8239ceffa8b5513b391d6f722341d2105a5a13c08fafe6d3552e8d3e3ab546489ad8d558633274a4d869f43532d1dfe2b2242efea26ca2d45edc2c4e77ef88423ee5a22f0675a8746749e8d75d1af2da33b7a11203f9142c211c6621caab8280951a2cf3bd4db9e8a3fbe8728ee3be9570d7e698a3e64432fb7ebcaf630c8abbf2972ba4f7fa8c8231fb91671ec6da63eb83ef096be4f0acd75a51200a951bdcbde3a2bed41ee005e2e230693ac38b9032c28d3feefbbeb9f7d56b1642ebd3c98800706b92550be4e29db065a0ece00215d087dc0b7982e99fb9e2114fb8bb2aaaddef1c4f11ee05d435374d33414188ea3e1dd16b07584a7f48257b244c721a9d8dabf344fe019edfa2cb37f3745d221b3cc49cb322c8b1cd46839acda98e774754d075e9bb822b7bfdaa3e3565c64f5de947003b56cf7af6714011ef212ab381096055b752b631a1c31c39d209dc39b6f4feb55288cc43b21e7f151027bbc4268ebe87c48278422df02162ddbaa2225f98e583aa2a1be9f26ee4bffcfa255628a3daec58eef2625c363adf2658e6c25dd19e4d75b8bd2af30de3b5ded0c52308d5b6c81f492a5a7fd038abefcaab5fe53fcc92c789455c2c47346f98b1e4937f0fdfa67c317dda7a65e10e66deac24ee42db4bb7a6f31c91fec75396c6a0bc0896e48a301df2b1cf5d6f1764b142398142cf41daa96d70102ae60f2d3120018469f23857a51bf8740f01b8352c85dbcdd65d849a41f6cfd5179dc41fa20f225d0d4e7b5ee34939cadf7ac1fb99d4736f77362ad45221592d49cc34afa26e5ffe98efdb4480f7c7ea5fa537d183ea46884d9dc700ab0ca6d83d110fcbb586edd7e0937c5686e217f9a7d3aae3a6c756c163fb610463d272923fc382d1c96aad39916bcea26ab746994f655c09e8121054beb63e9aa24c5e520ffa3517261c7860ebcaa19046b69109d5ebc9dfcae672afabe36435fae447d79a574a5cf0537c01ee1919b8c3e6d3452d2ace15ce1e5d958546edfb4c2c2a26b8e17fae3f52afd177cf529b6fd7676b399d1a0842919f185b821813db4ab1c599b85518bfb46442f09ac8ffd4b78cbac75c2991d41fc7a4be26e2865e2aca2c15288bff5c8c30cf2152420f750a364d7c2f9603699500536385dfc2373d72152a75f2841046bc016f6ddc1b1b6e22fe4927ad2f864a753411ba96046163995f8a4a36e8d27ad134986eedc8327fba62b3874e2e04372aa004fe363c6bdaced7bf4b5595024724476a086fbb16a2503b2aef46cb8268fd25288a8226367ccd478b15787f14082b6f32cd6bdec0039769ad7883f33b1a99f09000f2e85b01ae1b58186106150cc7d40897550abe5243063561c375632601cfb17dfb9f646ae8e1f9d584b5881d9e530adfa73c5f73ae08d4499ae2ace8694ddeba0fed1e5499160a2e0570072ad68a36478acaebe6feb8cd83e23376dd7bff73f2390580ad1dce5a107d1ba86adb89478e3c78b31f8350461b98cb2c530cd91866406e4f8da77d8686906c1db12dbbed81e52aa3527626920fd4d840c9e06ebb58e876b40ce390d450b45de82add2f06c218318c276a5cae7e4a4ef61a762caed1a87e76c376af1152d3b03cc064553a6c18c101db1e4f21ffdf00968030d8e14defcea9b95f0615473727073d16b87a4ab0282c913c48676788a9d6b38c6b3e44a3b2b2e378049ac669d35d0e99d43e0ed9c020efc20540e9872a2fb606bb1076c9e5f75cff1d5d31efa5063500d0097c444d99b4f0b0232d35ff6814749bdd34f3668488feb671bb9a470470c2c23ca9b63cd173d7ea480d5f411ea57dd18840d3521fdd6f4fb721ee69e036cfbcd3f26ae4978b14c4d008bde37584ca26749427b1a5609f44461c337fa8415ae9ba976a872c9a356579c8bcf164386be93b49504b3177e9a50e9f69fd2a1c10919772e5948437589f8cc59ceb26e2499605bd2a99c686bb14301fa852612ba9836b9759c04f398c9e48bbabb3867a13b3afe9a19f845b1c7952cec167878c92c7094ba3dcc40dccbddbd5a9ce11870e656a229f1ca8e73a9b4f3adb32168c14e5ae75ad9a8a12c7e37f4a309e6c2fb553f547f3e137eb21f3cef9f8b36ad9104fe2b0858e658f5622412af25b5a99ced073283a7abb5cac888f0126f2136a1b5fc82e3ca696a040ef490eeac43fff1635e62084747fd7aaef9cd55e3b94e4fa93f67c87213de4f6a133e72a358007de19549319b5c5ff300b24f9adbceb10306453584fffc47730b114439203161d1a549e87c3ff728a16a6b470251e71826c68e5cdc65185e193ecb4f86e397f6050c8ea5f5bee8bc710b389dcc06de5cf09b9deec57b0a2fd27211f95b627d3156aed460e593338d03dd61d592472ec68f019015895c97c5d40f23e5680a2406a139e3b7af6f77bd3845ba9966b5f2a206e299c539302f367d8f8f93f3efeb724be59c44719ba056fe2ff800746fbd294084f3cc8bba4d195ece1bd825d9aa9d3e46e9bf7db72f8ccc960ff09d3c5599787298f67ed65186a3d6853056b14fc361670581934e85074f193e3ff5f52a60dacffa18fbbbcbed40b507fba83236c5666460c886d2b77e6724aee91f37cf8388ce891afddb7f1910f611831195453fcab6d7bf6e0503bc0fd5f90736c5b94e67cb8fafe5003a5eb0e4ff28b0b917e473649dc569b86abb1fe9783609394d4b32cc5816337224f76f3ef1f6ac1fadb0f427b9e6c009946f40c244fce1a26e60d45f849dd15c93d9e547a1a8304438ed38912ffe49f04878d095253251dde69703cad56c094b2c26bee40b56b0801b7284f28db0e0cf2b94e13de180f2de0f5d51c645ffbbb29456f299a819f68e201476c2f93b80d36ab5b971cb154b9cc9b78ae3378861ec92056767a823b100a234cdcb2ed28102d37fc415c523cc5233688cba9001258d033822898a1372dc7426fbd71aabde097090c9b5d295f592e44f012259b8b65907b5897a9e4379fb4c6fa075ee6c1bf7befc3cf68da19c45952964d1ccb536d3dbc86fb48a2c468e844c0b77e6fd9c9e889a659d43f644dc42d6b416c6469b10a8890df4b975725a4d8755ec0deff28f58acea54ce442fbdba41d91d45d72177541db4cb9d1f8a81240cf0c28a3e0ad97476db0cee2962b95faa915486da97d134322b98a220e1d74476c8c17f438a2041d14395b87f82f6cc35cc36be9bb8bcc5a1b72339262b48a65e650477fb53435ebd41d2e92ece5b42c5452f014cc07420e6bffa38fe06fd55a364ac326dfd98cf5c9896daa4f1a334e07a9feb08f4ca13da4a951fe3536b27b429e756ea33c224e162163405da3091f918c917d5f5aeab1b1c8d77284c60c49fb0de8a0b23c2d06389e691399a5e75ab286e2d23e7dcceaef442b26a4719e7ac11050d6f09514b70a0411c08361e6ecc61905bcde9416c16f6fcc43f6cd4ab0c2056968f2803c5170cc9f4a941a7b549622ab0e3d0e76fd03ada546ec2799e4082d6685b9473854ad946b4519dfc2662183273c477d599da792f15bc1e661637c33b2f2127fb34d5c023d12e010d4788605d6b68e9bae682298d8709864bf1028762f469dbbd4bca7ce52da86c50b2c4af17db641996ffbaf402d3b52154110b01338e876f7d99f26aaa56a50106849022b09861f4abe3b7e8c382242581fbb73e153f5aa534ff0e684afec653a16c28c873510233e3ee47e503731e513875f01596140472a319171be09b1f19d93ba0a6b983da6bd0e7876d948def974718ee3d912f3eb3df4ef8aad2e2ecf19f4cad1d97783559746d21507f8e53c9454b68cf1ad6910a2d77ec50378e78940290a13abf1e293396794c283c28b297138974053da23c99f7fbe169da0897b345e4210634603cd37ccffea46a67db316fc1e82167de8555021ed105dedc1f8839bf8e3df9f4c0493bc5238c984c138a89b1a1d483fc7f588de4d465bfbb6ed3ece8c3f552e27771e45ef46fc201002f45c041932d4e36297be4b130d5da66675f3f120fc451caf95c3f08db15cf9cefc872023253a013ed19b5d670f17b7a14a77f4301941b819c3894eb33a40601f2d0ef64f09eb86057326769f67fef5040268539a43e015df464eeea067a32c8c240c63da5b5188b09510f7d958829c4386ab75440d67fccba02cb0fc89f79e4c1330a28a44975f9108e9ec5e1431b9c5214689ea18bb467cceecb818a31cd866949aeaecc2e61b3c57a96cf119ea6345cdef24acab12027865b091bdc58af2e4f6c7bab50bfa04a0c17b327a0d23e6b66a977827f53bdaa42da8046793010788f15bc8e09fbb1111b7dc7e9e1b8e86278ce372e6b7cc05948433bd24d71b9acb2b1211fa4304c015d939cb9d72b9094c629e254556cb2ec2b87cb213be1acbead0c9a4135febdf430d0c89647e753a1a1e411b25cc550c8d52d6e968e7b211ec83d046e3adc0391e37ad7df643fe599103ae0cb3a0201a582186b089856aa932455fc614d2d7bf9bdb306c370e062d46f8819b7ec702fa5b59d3fa530f545499ea5fddad7c3c84929d640c7c130c3bfe04e86ca802d6938a53052b480ed59c39e45ace14bf56bc9b9452624d0000b0b621437df5a1403c00f34e6c45bcf0e68fbd91396a2a10e4adb52df9ca8214c08f0bd776d755360aa7d22d5f57d9966536507a6fe682c99a851a23f1a914779ae37869d1bbe54ec243aa4129048d421f68a84278c5449fea0e93a36825115ebca3b071395c3ec47e379dc5a17fc2e325935d6c35a65e87c085bd7b53a50d475bd6fa06eba439297533bfc0c31d8d44d25cb276f98519df9d184d9e5c34460c35b80a1bce2d469a37c4e98233171e4857c078def01e5849ad4e2c05909eb81ed8ef49ebc6f2ca3679c11cb79e548a6dafdd2b7cf41655aacdaa7f7fd927807960c04183cde3440c9b9baeef6a1939855655a06920ef7fd05c1f71d345f988ff9ea231dc4f233c679a3c3657254862f19ca9d039ed489745d9528451fe097ded434813e839bba98223bbffbaca88c859c09ed40ed5dfaae2571d17c669b81521c734ce60e94d57c94df56b1e978a0e1beb643f17520b4f5212700573a6303f7a5d8f83baa2fca9d74f574ccd083dec678135776d99f34b678b54a01789fa3836d8528693a9f4ac0d01cb55ebb87df1ba79cc4d94d6977dc09f8a79273a3c62ba8ad8c8ab80680bec611bda664b7a1be4eed2abc28350b77e132f5a20c5dfb16ca0316902f25401cfdf8802161a1c34eb1a54a9e343323dfc58f5e878e647f1fac7378b42e77f86192bcafcd5287bf604e965913ea84484b092d7a5ea1be17f95ee400996493df1db6bd8c0cc30d68a25f21de2e61349ee08f5666c5e3d38b8a8512527475df2f0f8fb12790f9bd94e09d5ee0529273bfc0f90efb3168bfefee9adc541cef020952f22ee0799aaeb03fb342f95a5c2d231474fb782f4eb6e3191bccb62c19c3cf9db2c18ac15b118d24b1b7751586626e3213929e76306900acfd8ce35008a19bee7c779bc64741ec4528bb37bcae7b475dc66cd318e5c6a060d9f573cfb978e370d53e4309b76a42d2bbb68ec435d657b9aafc7bd6fe7c7028afed9c32cab8f59c0c9d1adb8c7552b20d4f408ef64538d12196b992ef8add4fd8389e85d94b4d53568f7ba5ddec617f1d2a7c180750c2798f7ef265ab01084bdac9f96ceba8d521fac167d7210d6b496137b074bfd55c07b39f662459c50b84777b7b812ee1470e2298606f702d590f0cdbaf93a74718b22d6fb7f6a50f1cb1d961f86de7aa42d2f6fb693661bbc82f92844baded30e2eb515281a4d6e583d1bd9b6ef90c4067b3e0d19f3e3952250ea2ed088eb0e6da6d92d9eb31d3963b555898453a4a093aac1c5ae98b9c24bdf55ab0b6f0ec69d812d9eff77657585e4ce59b053d22e8beec78705ece16d331ef794cf1553999525588b111f771cc1bfa4b41bd35abbc65147008a361de3c151befc60ec0f1de4fbe616d6320ed4012cc3a0e8f31bb2828f87caed8377eaad2b50708863cba775cf6346953f24c0cf2720ef5ef953245cf94cd71d8c00804255d161dd2484c21b6db5ec40e5a4a857ac5eca429656683defaf3a643ddec96be4690d4279bbed39ae4c0743e8d54d0866b62c608c8ea2e8603cbec651d61c1249b437be5ec30307474515afc8512de518bc150c4cebc0b0a52dcc05db467593407c776168092be2c3bed1d0f854613bd44fd8cd88d0b7907e34dea7bba6db7bd24a28c986b38cec73690f34fed6afe2cc32b87b81b03a331d135bbc86ca1dae3252eddc5c8b57cb7ccc343a0ec59f8da66a2b2d91736e2e11af2ed45afdf505472c5d80635bdefdf14135a9530fcab18f1b13e08959cfb7c783b298d086b8d1ae186c34fb6207a7599fa278210cd97444ef1297fa6ff16d87a1b6e0564a46716e145f840b75cdcdc6d8dc457cbc7725470df2b146a60341f2f2807e726cdc851ef3caf9f923f182455a19422ded2848375ccc993f43d3718a28e28184b4253b36549f233af17b7ffa34613da851d610a95967bb109924a7e0d2e93d0dc2e8e90f82006c73b6bfb18cf49812025745cf685f28f1834ca05ba85937af119093e9840e9c644d8a6cc92f706bd3c426f9324baeecdd9bb85982728045aaa571fe310c28e01c228ba62a6130d791492b5e14944f2b697218b446bb67144e44b62e9bcb1c3a3d91694796d592740dc39418d7c823ccd35c1ef92511077ea4e2f9e58df1ddb9bb3780f871c0deb486dd996961d24ca68dce36653aa1d287d2b9d7e63603d7a28a4c2b1841ccf6993f6aa83e0301c473bc7e54dcbf3ff13d47557eed2cdc483fbd28294bacb37a005981af27edb075288f3f4329be5d56b127268d2e58b8e68a00c757f84164217a873cdb757ba6604f9d94916acf99feafc50924ad4e7f9e94ca5243e73587e4af64e8ec584f9637100bc0aa4446074f42f62830936d096f82bfd10d092c094b2b945d2dc3d7f0ca8d97f85e6194d9f3cdf3bae3d66dd99b2a9635d74f78678170a4d45fff508aa2b28da41fdfcc5026525de9de756f6111792c8086faf5e2513b6392ceebe576e54f558d243ce5d075f7c59b1e15175d4a30cdbbd1a7ccf834d54b13ba0a86b0c433f1c3196196bb827a3982e340556faef4b5c13736e1494504d54f3f4b71091305dc747f9f2c76b38a51244158021bc3432241a698a5bca4a04e735b4e74de9488d8a02f1c55e491f8eec4325aa5121551d664099cc741e3ab3be785f338fc058e59440938c4310ea44d8f707332bb8cd70788115bff1a47287d030d30bbfa20499825dd3c68ba4d1b77345dba6e48adf249ee6e73eaa744bf4d3ce5bd393d6112977c64b49433847fc7c3eec8b2a89d14fd2794cdc172d2a0f4d5f1788d5c0bfad034d4df795cf92db10ed46c901b255c9ac6a8fa7ce0d469e3ff6c435776ce2248074e394aff5f94b7c1c27dc20475ac80e2240f3fd01f20441f9d40b1b53066dd396ce661eefa32a245a08ec0684cc6ebd2a242a1f7df48b04db5f48f7430c190eb964d0657aae1c3803bb91516a67051daab8865ebc1725d13a57b32cd45c226edeb45b104a34b80fd4f553609afa6bb523e0936269fd292e5a9d9d512202b856925e62cdba8f2f6e9e234ae37ba36fd6f589354f327c94e42327c6940ae9fb8a4c350723505d939bd757855017f7bd2fbf96c43f835eb3319efba79a664a00a6c904411c31763d2d8f08a75976098ca404ccc6566c13e4cd77a81dd7a7984860e879beaed2be912c27eefa43bc10fe5f78fb1c5449e32804e5701ed053a12fb1b2a6927e6349664aa478d80e8259c85864c57fd2edac33e380779a223243a91d0975c614023391713c2c54f583f951ab6c2adc29e5b1e9fa7ebc83f8ac88671df2ec894c53242f3f36fdbed43db1f0c85412dd7f489d35983b55d7fa939f73263ccb0a70306a8434252a5ba0bc45693bca7be0793ff2660ad9597b7064cff6094cfb64b37c9fa4e19757bb4c49cb9ac7b5cf7cc02df7e01f3bf16090bfe72b67d188719d00c3cd7552d7d02b617def5b6226bc84008eded020c8c3a1d62f414abbefe26d534f1b7ef1e0661804baf2a29b9de31a4ca15cbac5f7254067f5f08632b9e6b2451355c616580a0a68d7f0b892cf03bc283cbea357a2e752b5ac219541fa11b556a62b818101af87f5af2a8caac064fd124f76900e148c9b6f616445611a11a172dbede44327046e5013b60484b9473bb23c915b5fcd7a5421808c7b1c017b95a7425e1b85e68427d262482a6a280dee33b484803bb14d2dc84ec8a37dc71aecf5f67f29e6625883d00946c9bd5a1f466a5c7993e1d1d373f6e90b6ee71e3447eb6a60a12f27646d81577bdb4c778b04a329a3a9bf92ff9a1f309f0a827a9ac0d39acf5ec9a061a343e33836542f7e3189c8a0197c34fc0a058999e39e276cac34c9da402cef84b062ec2fd12313ca0b9fa81010e039bdab43f6d480307a5c805e6ae5eadfa00bda2a69d861986e837f3669aaa1877a7ea41f2678f66fc1942571f4384156d58fcbc9915c11b6dce73ae3e9963df0c272efd76b5024d4a4f1ad669dc5cc36e04d08d3741250b8ccae1a9418e042337f3879f26f98a96b425296e7ec9eb1e6e302c36b6f042ace2c227cf8d09279345101a4e6d1271c94cdb1234206dac428defa03ddc9ad7b94f09d540ef5776b27dcf8e6478a7262671c67369286a9500556b1ac3847c16ecf9f0127b66f2e8625aa6abc333e37849019aaf6bc3d24936357836498216fc6812f20241414314acb81f377012dbfae991ea70d91bdc371bc0577c7905ca5595c10028f3a8a6afda778dfbfa10a6f6ffcdc8e2ac687225b6c51021ad8cb1d24a9b0f6569ace933ca5d5929024ad64172c4a45e70198160473a797b18d47f40951503b8aa888bdf7a7a0b09f8310aa8b85eb0e200bea555329867c7ad1716cfa91066a5ae16a96d01de781420e9ae6de1148df7fc49bea37ea636997248dc29ccb421e9661276155a98fec25ea8e480ff12144c46767426ce7411fb5ec73708f73e9b3f67406bee5335d042693e9aef8cb76e2e28827d1c9d81382fdba7bdc8280d96457e614974874494e987a8e9e4fc4b770a0e5ca190f3ff3e925fd8ff9bc135abef7c7f54567ee626d6d6a33b4b0495307282554070e655a30e37e2c38c3439fd9204842182d1f6c581dafaf106cc8e37681a3c511901ca8312f066427f5ecc68f97bfc7b5bac1c7c1cbf37ed9972cd4ed9fb42b15b83a8515d9c86ff310976928acbbc290a8086b25f50fba44839964e62bb426f49eecc3891638435ebaabd62a0f874cbaf561ce218d6316795cb080734837d63c5fbe6dd1786a0b5bbeb0709c0d10339d28a5c9d148de855ae08963aacbc112c5b90d77cd20453f4472e51a150b032078d1843d01a077642681179e2c19b05ce3fb3a9311e93094fa7e4cacd1329f6a77c789b10df40042dff827c52b6dae872d38f190ce0d1bc4837a55dda5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
