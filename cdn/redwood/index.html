<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0607ed16caf370c433449e14b84cc19d9c659cce1cf653a76c47931a7a1021f69f1154ecde0119fb8203344d8ce6ec57d718d7940c852f5aaf3beb1c4c8832652f4d683bf1e5a35be8e644d76ac6e1dce21b8e7d54617f899e713cafbd70d1c2c688f94121b20da2ec3148c93df14d161718a63a9ccec3ca24ee6772b9727ef515a733d1472a4666c395ac320195e69fa22e9912d3b7f3cb429034213fe39844e411feb6dc80601521e4bedc7c452f4cc43a8e236f702e4a0db51a9ba7f68cb9b81e40fdb099c5515745ef4f79dd56d6b6b258035b69506243be5c4d681c9a1c3bac072d09dcfb3c8be1f3b0c4e3580d26de87c0f2d00532814e4f0a4e5b8fd076614e7db4afff2e99c0428c3fa57b66fef33a2bb7da2adf285ce9d200c0b5ff527a56a7fad1cc5ff40b515d387d84e5e1139cde14a7033045b1c3e52e0641ed5718253416b6a32ebaa68bce10bb714fdf9d032dfcc71033d3b881c5d456a9c7d26e5a9c6c80d1f95d000cf5673b19d5886fa93d27c86a06693094967f17fb8b8953dd4181dc1ee8e07ea8ad7891e90a19060ad388946de744865cf461c977ebaed344cce602646c5ddba878d42cd80e49e94dca74cbd8594139d3612ca2a059deac0960344b7e1330ecb62391c0e7c6b2a5c10c99c157c92a6e0ae4ef0b39af233c4506c72353b6f0b4f7ef751a93997514d4e6df85f9d6657abc6ddb45a4c63682473bffed3181d99f857b1e91be88b1aca803b22c7b3bbd2d35945bc2234b986bfaee41d2a96ed899db8b43eecaf0112693f26507d27fa10360d753edae1b5570b05415f7d4ce05f568edef8f1f388523d3a61c3215dd5250bee5d0633ec2ff1006a4628de62c6ee20c0e81fb675d2f96920dd03a80439a8652d3261c2b9c5a1e063c740c8acdeafda611b311a650c88f7faa76411a69a9120815359020f4d082a60e641b03b53a56038002f87eaa865f5f6e40522db1a9eda8c0554d6e66326c0aa3df7c6f3ed01befe644be2a3e50099a2fc6ab3580406675a567d0cf69971b535b83a3753d2e30a4c5cc2b83d6a8676e740ad0bfb0bc0e095d72aa715d0d8571fd5e9753da909e8b2bdafd6548a66b1960670be69acd28b875d581323ab89b38a3c53bb4990d4a5908130b2543e08db2666f7267c072d16fb20fed76a6114abd5dc5ef35b7da8074a672a6a090ce741a74a4628ae4fee4280b38346c6f626679072ef09f8a0fc0813e4c230db798342cc456845cad1dd51f17b1a0d1133325c5562bda05d3b473d9d958851327e30f65ec5e023063aa8cfd8ef8d5e225349f35677d606857fc2f7192bdea348647191f4642b5944502a2c89d03337323dca4935936eda0253db2127d5304a0572bb9a25c5d26c8ca4a8a7d6a8a1577bebb486ce54b3a8a67c121eb89a1949552483a99b5ca25efb374d95a6055d87741baf6a168924d0c0541c9c797d684096a56f1835b1c3f66e500126ce485d29a66ec922d2da120f8a494367f9f81f6fa8c474e54e531e25f46a0a6d3b67ef80435fcbf232d8c4e2065a1ceb71f26b05c9b06dd01f6c9e6ad01bbe5bd1539e20d304b39374672a37678bda0d0c488e176da95bb78f7c8b1cbc51ef6e5ec5dcf3951248a8a33d8eda284e44ea65b729375cebcf4712a772d3664529e940915d7c633ed95890e123a6be242fadf963e30267aef5913a64721259f156ffb9e35f571e62593027cda00a744cc5f008ac88be66bc6c38edcff904eaa8aab29f8aaa6903f0a884b8eb7c8f3919e949a08576d5cdc8d067d0feac568115cee21cfd47c1bc50a9b8158e81ceb0969eaae6fe0d2ec6788e6404dd7b46bcc86f00dc0f73d8e405a0cc50dac7636df649a175200b714a52502d891249d3ee95ad9be0c3479e76eec3670ffca19025c35d92dfd5a2da1e8239d3b9e7a71cbcce0f6e340f3a91a11c48b688e2399b412f9ff4ffde0409277fbc85927f5bd1f193e72f0f915f604f5644385f7c31c3b75b37687abd6b4b92f9c16d49148850282a1fc51f94308b7391df021e17b0873fe79ea68f7ac4191fe0dfb71fca7943ea75aa2c1e187860ccd66b095cbc6f45f05939e0903b01dde4729c7fb953776387bbde2530746fd175b2a05f1cd3743cfdb4f79f9ba6dd9e973d5d8d2b30eee1d25ce6c2d261c76b0620339674acc66029e9d6951198643423475a0e7bfca46131989baf7e670f94c8d346945e34529b68a6bf4d70dd67616b88590661334b170f65b604e244b5cb86fb235192d9a0417e092d15b4bd6f3a9e78d67687a1b42bd274e4b4ed106f9a909859ec6fff8efe2d3bb19478cf736c48ddce73d7c344e5a00881845643c0cb1b2340afe9e3824325bdbb99606feb14f62d7687d1b52389661797d1688301278b39cb729232d68a4a0ee76dd47dd697710765f088729d7469d1bf079a80afd39be0257bc4e3d64b8408233363491c21ecb2a18cf88fbd2fe32b95456c13dfa8a4f7b31b69b727e9495c996902317224f63931d5f718b35086844464b8fadeb2a5eec397de7efea70f77d68a4d6177dfa6541d8dac284170f31134ab204a5980c3ba2964dd03829c125f9e3147f11a1dab0687936d8df9eb312a197771a9d458eb22e992375c5dbdab8f2e112cf4a7a3888120d5aed2d5162197c09503ae44baeac346f03f751aaca623e6c239cef296f2afb561c422d0e887e98527005f2e8f67e7fc0d63e96f70a9282f816df520003b66b0a8f669848f9fee302019770586dbbe2b61997b76f2b66f5b74553782cb7c10216b37f995b1bd4622b021f07ac1ff28ce2df8e0db5360e7e8a4079e8fcf5f7b4d495d2d42bf2ea3cb8fc00fe54f66492255a2873b78cc9fa9b262d428ba6e9e18e1d1c0e06301f5211681f50db4ea5f8fcb89508dcde75c987d60576f8dade807c1413d256e7beec7b789cfca6a0a44074b6ae90685365cb7c5927b7fe35f5cf865f26b104ab0eef51283574a38a3f899225d4d6e125391654a1767945f48eeca3592435b8a805ecf4dcd094d837325bcf5ba227cf3fa91afc22ba5f18ac1e6583600a71102a7bd3fd7390634f580d8a547dc69ac3252c91ed58df6705ed40a170d5918b1ddf2aea00bd437cbe5b83b640c99d84f6ccb7c8e08ddc89603bae4bd5042ebb082488dd7e21f104ab5712df551c16ec9fda98e20b56f155d406a7a7453dc051528a9fd044cfb20464a12d4a8859d3a0a2e5eeeb9bb51f5eee1962d438196b29afc92d4a93313bd85ee91e2517c5ab96bcce44285f310b95a5e62fbd02070fd3149a1bd972b13b41d96e7186aef92034ccca771958da6cade1a002fa7d39c0228a7a6bbf6bea173c7434de85bb01ead1fef9c392969fe61308bcd0ecc3eb7c85d796f0c08d5ead81172ed06e0ceeca50b13c3053c2f79993f1229938385b7e9dc3a01e53374cf28a8dde2b7b98a0e78db8fa8ac6cace014feaec07692a4bb5b271d0a9e58dcd901793b2630bb100fb994ea54435102a5e446f8223133d536f9bcbfbaa07f21ae09b4ca88dc0fc869c19371b5af6d47725cb8ba80a1551577653e71782b13416fd62ddb9995d58f9fc1ce5daa50e453ad9184b7e8a2b4e493c0e1577aa3be4e8306067bba11f7982d4f45113b8023dcf90a3a68428feaf30d85e6a36803a0c4cbf1117c8eddc7a00e5db3c1f2275963a050aa6561754537cc53b34a5ec21cc081166e193975868765f210dfa97a17a29e77f878b04a4b5284c8507e428f96250a50831bed66db682145f293b955a431569e6fb4c42d8249e009486d844a649fafd9edd0acc430f8801f417b91bc38e725da9220d87e94940cc9a2bbc409b54b361d1ea118779efdb4199b0e1f720353c61fe384b56d64e876f72a5423b734ad1a6a5bdb6a875775842f3b61a32c8510cb21b0ec54d585fa281dba82ea6856ecd89ebd7499f01850dfc2681beb21efadddcadb2709d28dc7bd3fb8804d84bd95cf6b0263e6cf04ef6b7f100482ca6cc5a5a5ddcd4c940e670930bfc3f775ecd60c3d09335e1c311d28fe10e152e312e58a5ea0940d11e804f8521bc18a61066eb940072de543e1d266f77a907de3b89a14441a96bffbdd5bc380e001aabca0fb9694257fc833e9ed459ccafc960ee8b0d789f828243ac3c43605a2b9c26a9343427c624e54f5edcb4956b026ca8901bace0526d42d7eb8743342a52468ceaca0121a7f7a562bab37f2867c572da2819fbb2acf50959ce7372e264cd1f382909f8793c0d6d433e46256b68a330ba618a08121a6e93b4944031f7267e0355308fabc2097458a6689277d5562e75c2c31dbbbf0ef78cdf8779aa550d4d4a348c4b28e2c07adf45f38a06ed2ca857b29732fc53d024f890b1ae54c3df5bc7cc5c48b8144ded56c0ac01d47f69edae93a7ee3e2955d585e077c4eb333abfd13439cbcc3f0058a70dd77d334ca78ffb40124507952d796352a98968a2fc9a2b6c4da59dfb3de093d5c4ab87be05c51ea0e4fd306369016d3e3ad68e210fedb2ffe6a6686aa4d4714295c63ebce78dde8f27fcfaa23fc86b5cab14ec81f2a857d9ed1d27d7a322cb5cbc7a31f8bd51a3ce23e70b4a1b521e4c626a2e5cc192593e17a1520a38ef6a82e175dddb41bf1e44b7c4165798329de7b1db124c785f0bcaef19649d00e57ad83c523f3a0ef69b59e9f6b81f9462d1208fb0dd9f9c708ab379b4748c8da6d797249285ade893fd52f8ae654f10492609d27347f5a980f59ab992e43d03e01611b9f70d7bffdb6868f59afbae9f562d286fc3f108716c1e9e8802e2c81651051f9c3aa4839bc62a81bb06cc9adc746df6e789ea0169d2b85c011935281b6d0ded4a95d7460685ffda3b18e01e5c884efb068755b4284338a370860315bb6e29924cfac04ac5124404c204119dca8d05777074cfc4202c76214a7545d4fab1b38f42f1a8e1f14d1dcee058718db4929de0de7644f5c30b17b95e4b27fe067bff4a2313d3542ea7e6062ffd54ccc3d3ff3897e58c7b54beaacb6e76244ff8f3e721262f50d12bdfcf411ec5f43b7ea224f3f01850b6e33adea3960314476433bc3df88bfbdc68a35f05e71422114f697b5d941119915ce48fe2e85690be4d7ca2d87956e801c1417dc79ed8dac5d2c982819819eb9e7499c4edf92bc860d72d2cfd893ef8cbad0ca26e3b759cab3d5f15d54444e8e809b3c5eeb79bf4a9bcb1f30058de1ed1820d443d82210dd492096a0e17006bcd437c485f508cf7b8f639028f564b42c94bf3b14fae87691ed0f93d8c1d1c91d69fb39a29f6e3de07734410a11f966fde6f3a5e20ef942cb90515e51c49d50bd14d2f2cf3423c6d52680f7a473d31765a1c0b669f36da046e52c5fd2f9d7b7486883acc4f997aac8162aa4720f7156acc065ad5f6c454de893c2348ed2b66ac0c7535d348108ae82802c0648d40c9e4fcfafdfac416a015ea9201a0e0bb060ddbef21598b08a45cb912ba26ac7218c1d3cded35bf9a381ad54dc0c889a6d8e53f309a1dd307601fd2e2a42cb0b86402bbe8cb7ded2ad4e08048709a9c478f1288ddf12056244f474d1c9ca834da2414367c33fce8260394394e686491d98db6dcb650cf5798acb81cc1db15d565e5c3f652dc1fa36f0517052eed0a619d4429245ec0ccc28f98bc731785ae725773c9c1ff92c610f32fdafcc535540d0e8ad1adc6acab3ea508e5642083e479f33b625a7fec13a946ad82c8366914905cfbc1b5b607fe03c455136cf2b2f038ae2eee7452162d8819efced3c24d11ddf65d42f5b3be1723cb9d3acb680163d40e1bd0851a934c8fb50a8a14a2d5fc762feb926468a3339f3e21608df3370a8b50e40fc97d143a79c82a2cb57af6db0a66e78e1b3f22f0179dd5f4d499324af80608fff4207998364119e2a8bdf4383c50c2b95b1175755cb075b173f9e97a148a306064ef0ca078bd514b9ea68914289adb1b72321fc3c1d2889dec4990f00ee237f2db1aec7c24259d5c2a02dc39da6e9746bf1445f2f6ce6bbb213072c8f4ecebe7bcaf54916ca7bd88efe51f621e08f84fafc718e90c88ef7244582b043c13d2e9d6fcfc47ab1ea4e71b4be07b7576a3f525a096f6956a9661e3cde668180e103fbff529c3b542abca3afeca4e8762f354dd207356f4aea1a19fda0d41a67a85db7db193b8505534372c34fd6bc989eaf5b4ccfdeabd5851c843fbeb7be5597b5c48f6f95fa314126d3b2fc6d4071b4ff07cc8451296114c56e1f89a5aceb40b7fbeee153dc86f104c21ae658a73cceeae5f1d55dd92239b71ef17815b50785cc0ec7a1ab06f8846ad4222bce6b47f2a5628dcbdff0f6b40d8cada8f8160e6eb880aa483c74da243830fc73096d0a7ae2a91ea953bef45c3800db71731214a7b3c12c24da6d75d5a8256914b08e7a1dd56b1a9d3c3f93a9dbd757b9ce701f3d8af75a535a3fb7edbcfdc0f4ef037134c0d81ae30100cee088a5ade6a0e720d2b945e610f9def43ee10e368b2a45bc1955db63f9ed6a10c53653289c46786e31055c58aa44b75a93b8cbb7f72d42f26f9c28a4b03dd2a23a4fc3f1a86418909f520a689ee4bb07d4987e401fc1613beb5fe610de8f43d4bcedd5622974e2af84c189fa3e6dcad2779ffb66d89d0b9535e26064609f07fc6a6c0b86a6c9ec5db68bdc2b505c9ea1d9b1747d3fd2bc2a81ced583e18a9973fdc59c47733e8a229cd9d4dd76e7dcad690afb4126692816278a288858b9c9bc8ede6003d565eb9996386f5ed65a74cdfa9d7cc68f3c9f26a80282c7fa4f0b90d5037e31b953eaf7a155637a6cceeab9878767956876eea3c7c026eb9956bf35b9c36328792c9614800e63e77e8e3a08d58e242b3d8b32408f73e791934ede719604cd64847c5e6a04519a199ae7a1c53b76c9ca9a303d86e8d95f8540c26f9acc127a2232c40bef07b87f59f8e1e2494cf3fd6707f823f4335b7cee65401fa2c5df78afb81bab5042cff4bc9737786c9545035c729399a671d5dd4736aa810b6a44e033bf65808a2671021a1a2e6ede6b44b1c5c224513d0b4096b8296db96e4770f1156f16ce05bfde52c7cd5e8543df2928f95f376439eadbb74a9ea08153ee210bc03c1ce1759e13c90a6ff82af0a5398fe9cee14078be8673645a11db66550a786ebb4a045702615f18bdf9752a5a5bb4f4a6c6b2877625cd203b21d58cb712fcb9221f5a6d0fbf84a2e5afa4a4cbe8ac30a12334f70cde867486a2b4b37eee78dd3fb44312491ffbd355c66ed97203b467d9c18bb5803e5dba75c6fdbf0087c76ddcf0e72fb06a1257f7d30dc6716dc4f3604502aa9177d061ce0f00fabf97d75f9132c214eb9a4f8b1db4dd3f0d55da435ed920e1848f2816ea69d1d1d74e80395d7ef098b3bb88029995c24a64098bd15a67a0366f73647e198ab37a4abb8faaacf28b0aa0e0293f06783860caed0898f563f71c2f29a664d644120d06f695c4cb8250aeb286b6631a411dcae9320c6605ce0f2efed8f4ee946e4a207ae9c58b86d72debf701a65463c1db6498be4c7b0cf5ccb6fbbbedc56b512e5abd6bf01c06f03d814c03ce35b03a8cc3a7ccd68af4a5f162d2473f75fdf4df3c948067874e9fae23f069f2eec8326f14a2abcdeeecf3fbe4d8eccb05b089b364957e0e100a7e434d8a8a7e269129a94860a2476844a8187a541cbaaf9687870ac9c8a4e8c985570f20c7f0a3f7bf5140a23f755cae3cacda08f3582c93d88f916bcd459e1e2d7f6f239854fb0b5a2ecaca8071b0b1e7aae181fda6effcc16ef5b559f7106d087f235e250a79f144117da34fd4b2ea81a3ae2e78c3bc9289cb7257134061e50c342b58f0241dca9f9f2b54e563e6005cc92f769e1b85b9ec402f0e354e3d4daffd6b5390aeb046c420e67609b6cbceea124c0695c5213af8fd854753aee634161edf0f8bbfc86595515845e162a19dfa95fd9aaad61acd8114173cb050e56001f6a058224cd9505618ad1c6928b0ba22ebb90b72e8648a696f12713e09e9bc72d2c53afd4e234aafdfca2a8c1389429edca1047975bd0043b20410a39ed9dcbfd438a1a8f491cbf8f1c047cf0a5ec7b6e15c24dca73b4a7ad042d09ad946a4d05d31d8762b657af23cd061c77bc588b186e37253efbebfbcd4fefbacd4ceb5f8b9d2f9cb88a78b78bae993901d65a58c2b80b557ea3a04779491da7ab5df4035c9f77f628f91220f6b68ade64368b6a5f8918a9ee9809cb7f0254c604afe9f0704022a0894a725520485a17a0432a1d0f611e489e0d6375a1ac6b9d3e6a95aacd023f7332b7db291016a4d94bd0ad623d1bb1d2f8e7b0579d45e9712403197eacd9751d2a89fde778f722fbf2d5b5526f680bbca5b97aa411553876f1e6755d3e081122b1dc99d14ec3d2d4abe37f796567b46d95831d9c159e4862cc45bc250673aecd8dda7bb5486183e0471f4e4027538c4c6f6423647728d49af2eb9457ac64a400a6fd689f6a03ad6ba49a45d9d12b8208fbbe188de5f2863fe709c59b86ee5d72ba678e14daa9731e062d4ee59228cc5646ab311147bb221ed19c971bdbafeb8739ade970f4dce74e80bf07a5af5a55cd3512fc32b1197977626c24bd37d449751f86d16cffacb787f262f881be5e6a9b619310092eef301dc87c4b2cdfca20b97d169ee89152c388b5b2b299b1539d92082c62586f992d86ca7d445158dca70b8e2b4d06f3fc575597caae0fed3fe40c6f22006c0d3c0c2b7de745498488c91a868b66567a055c3977f2ad4a6022a4e7f45b1a68e0344b355a64a6f518cc998b8b28021aba404d82b2b23da1c8b7291568dd9213ef358c2eac06221621598cb65b1c5898742b97b44338624d63d2eca620a7d7b1b0159c2807248f5acce97370b43acf35f0893086a5c1e07126af3632fbb8c908ceaff31fe3b9faab3afcb28329a0bcb41868bb045c0a91a8b9e057e3fc9d4b497538ed6187d1198be9a2ad0f1d18140e39636ff4ac81fe3ec7f3ee4fd5076732f2330fdeb6e971528591fa8543211eccdfcb2f6143612ed3e321507727be539f50330da7385b19a3b9a99f29ceffed930fd4aeb55f319fc3ebc79032b68226c9d2168dc3053dc6471d249439599608c71480a72693264596dc7cb577490f0264151c6a9dcd401124a1b5bc22d3ba3f48407b6438b1c0c149b9e0cde41c70ee07719cb1d07080760c7a678a2edea7966c3144d3acebe038e43b566b0fc853880e836ee407e6e01e7edace6141f69acc9636dcf1a00aa443daf53aeb6e5a9983214ef64d8e8d47e17a2a4e28226a7f66093ea49ce43511cc97f2309e527e9f18a7b89636aa8ffea9b36ede9de8ab607b8d5a097158526a76a67009cc3544e42b003f944bbd7b497a2d60796c7e9e4753ebb9750b3319ef22ee94a0e8ad483e40de1bd39c7153b196d00de6c9c62d64da27fa3583f0261ba12726bc33448595aead4c6e3d4a84a4f04852bd9d47b0ae0a85f9ed069e5ecf884c3035b54d0c6dc9771deff1f2348c3e0a4b2b64b648a6da6388010ff6af6e73277e3e00c5b85217bfcf2ef1543227069f68fb02bc70318777b7519b66b3e863a33629d56a2e8a7cf4be1ddab6dd32f3037b6907fff3833f3054b08a3d274cb29618cdb1400b0067d50b608b3c3d4e0d6bcb6a4aaca739c2f2ef35abe5760f7b3b92e27261c14467426a9def535af43098b312a5563d6151946b16fc84b51194f70d39b85e9bc81865240fb0794a0e745ddb24fe4adba7ae53893454215c91d84d903a0ab52d5feeb073d7998ce97ad084989849de8dbee2cbc8222cf5cca668cd7f47a6b09b26f292b356e937bf8caa57e6b537b212a0eba4751ddffe54e079dd85db2cd393536cc2ecf7d2be046e7e35e16a39755aa1f2f81da98933bbb67476aa4f98f3787d6cd7c3c80ea498888e5cab5057ac268369926f630a70f1559c6e10f406123bd034552ed74668bfd60d8eeb8c1f02ae1cd6fdf57bda15ce4d3673811f33a317ebe55fedf5260f5abf138b0f3ff5b7bc6c8ff92642fcb18db490822ea0167a9f569bfbbb1460c301b0bce5f1e4d88d3cc03cb7a91ab7f474760d8f8eaa0850fd00aa7569341799fa7fc2b40dcee39a7a07d4413926e6eac618509b3a0f95ac1b5d1ede2add6de1be3c85a478d0a341e7aa88aee7a3cc3dfef081a2f780a31f0acf9f4b0c0bdc48c741228fc88f86b5931665cdba649bc15ef436a94f1c9db6c3614384ea0b78d2ea53d2a3c4dc4935e8da1518e564b368ef73618ce7dae6a0475f9777096231b622207d0a25c223d721f2b1dcffeddefad17a7574e3e49b6e8312c6897f0af3c3dab1e71455a0db5500c2b0b3987355b37723c37f9d98dfdf89f47c28767ab57b1934e41182aebb573c140e50831fb1c4ef3ae0bd3f6cc493908acd8ecff93e6c8a2c9081867988af5dbb045420d7f489d101fadad25ee055a1f240bf6a1c720453f9c8157f826580fb2bf6600503482e512601b026c784ec57203b17b763fce6083667d03dafc7640855acf7b95e6312233bf752fbd9ab6d0980c84a7df08fb0811c7fa818feb84d5c4591abec732c7cab1e53b69aae6ecb2e4a6592adb4e696df7b8014deb4445d335ae9d2cc9d91b70b46453e305f153ffa85615b84feddca086f73569d06b8b01d7f6bab55e549cc86819a46d3563a9153032e269076b95c888b135dcfbd123487f4795aee367c091bd537144060c337fff29131153452548f13e3bfd77820c89049179c7e86af372aea2b479f1b358e1915cc3bec10eed50b5bc9152d9896902f0420a42209fc14775bc9c4124ce36e6867c55c4486fdbdcf5991f81272631139bb0d487d01de0dad1d558947cf93bd5669c4321b293de4bd13e0d48105b22c5d75f26bf34c10f9c5cefd07fd1986a8e658a1f71950beb43b0a3e6ee220b434e6aa1fd9092b8b00bdf0a5d7a5dbd8708323cdf60a9b984c0493264eb855cbe41d0c2fd5ca3ba7ef4376295ae1733f0b83f1a196f36b363e217e061e0e3f29f3e26ba5da5568bc3be410f221b53b7d00c2436ce103d89f3e4c27ade786a115db6ee473169f010b4c85e8d9520b44d1d573e324e397d03952039566e41f0700211eda86ad110fed28d024658e7f83ebea2803db590323c9b160b0fd935e8484e35fdeabb1c949d0b2216d48875ed867e85876f60b25aa8bc59e69f07ee4e2f459ab7297c45bbd5498809518edf065b803e4b216f3cea37c6aac6969f3b9c23f139ebe2275a83273d3da3978802a3d935d906d36fdb6dab565a0e193a23db85338004e580e46a733b500baee25fd1bb3af46b120e669e3314732c126bdde13e226af65b55d2c5d4553e87d99fe22075ff923515a62cf550a197a3387059f090c732ec1138bd8374eb8eb87747f7b935d3f39b78c19201a2ea7a9fa5f5ad6a207182a1cc96d54840b9a5b963b61388bd06033805fca0e5dd0590481174881d79c01bbc703ed20b2276364ac055151082acc035c16943e51d856d589e25f8ef39dec0f7d9eb9e5e8652030c689977160fb5682d19fd515a727eb3b88f7067bacb4078e05ce4f71daf9ee6bb3188aa758e0ba6442fc61794dbcf862ec9fa8772c4e7b9696b9dc41435ab68923ee8e6984a75bfeaf352bd95b12f759d2b822ad3712432aa7dfc2ba96ddc5a2fc82aac3cd9608f22d1bfd2c89d424683ea1592d1556a55aa7e26df03a657436b830bd5d5b1e5a52d7319f73cc80c7c192bcd51b7258bd7a6079825557e25661194eed25b736cc0d51a9552efa216ce2948171ec7317b4715aee7970d0eb7e967d9cc30f332f697d95faaf7196ffbc87ce6be0878b0d6b86fa03b4e2ceedeef28c433f8e8e9f73a43e26ee70a7fe7659b0e891ece6c4d8c58def9a33927b2573675c08b7894e043dcbc54deb0bc5834eda83d75c9adc55eddaa684a2036204792257305d0c81aab46dfc60ea519b6968951ec4298cdf979a91b94009ffa48cdfffbb041bd1fa39c83ef406293d8d36d11d9311d6bd6faa6f219e6bdd6a44a5ffcf44847d7eaa82507e693905be4ddf120accb507b15314b632c2a26788f701186bf258f2a7e966b8798f30b4ad06e3fa686cafe97ec6c42af3487f1bcd68be7c906f8b888f6a695a1eb4a62edf2b2c9efd5097c76e86ff8bbc9efeac57d0d2199f61d959f24539cb60f5ef2ecf6c10b65ff2128b589ea579e2dd4b60db3b95e931520737a5c4df3427a2c29718fa6b212fcde726f14bf647e4423f82b7f8ddf0a8351b382eb4cdcfb2cf6587b37608afbe0392994cdaed010a64ddac231f48a156cc79275267d32beae60b9ea9c22c787ed42ead6b7411afbc318da20a643a953ce814ccdfe0d586c79f0a194cb717078e714b3b2089479fc994b99cd619edfbef9c289e3aa2d30e1c003247dcc6a1aa75a323b9970a255e5213865695836b1c1920dffa2aa8c1090d04e43b8de8d27d9437f4a042b12b626d51296e06a9550ca3cd23676d37e58c68bbdaee13320499791f3883b1e60d08ddc331aa64c9adbf0de30c0d2a6aeaebee5361bfc05bd8068f4f9f93279c8f931b834ea0801b166e56bd10b4904bc23f5001511f8577def87e48c82fb14660d09a9f7f716ad3fd691be4a937b398e766c4a8bd15d19f725b798b6c19d1dea68e4ed0bd1e722ceca18fcd7b239f8076a53e0c247f6611732d134e4a14d6101c2b7830d62364269964ba3b18ab7426c256531d24c68a2783ae491e8ad9eb77384da34408437b7965a0b608ff7ba92c974d03e6def90b9d7fdd6a71643432e0e1a1888c66797244f8929ac305c4c6a52902ba5b8ed3d3197588e997457158d485586d42c36669cfdd743f0b9aea7c66584daf365f0b4e6288d3c45a4bb22cb31d23d2926d34f8bc557505943d610f29edc006c492c0c1c273f861e2a9aea5ed9f79ba21ef0ceac62335987c02715a88edc1c276a5a7c8acf33570fc7642fd6575c84433d1675990350e6bed404ed7c43a1a8a528528f01bf84f0e1e2605ba3874202ded33992e8793e7a96aa258733cc22fe34ce9cb841eac792ddea81ae5c4a13f271f54786f8eb20bc4d76705ff73d8bc929bc39cdfebc6f9c77d3b5e17fd6c564e5f186772b918cef4790b2e3d43ebebd8784971baeb9792d77bbec3a151835bac30f641221615812d61a7693aa13f7769d4521c84329d6ae15c1cee36f2f3884059bfc712d63648378dc8b536cb21274c167b9069a3b44a232fc231c4bca579866cf26a3cc1d44376554c9765c2cb4e2b5680b41ecb30545acfcde5ca30306cbb984612a476816156a8fbccf2dd52c770d4b506498c5f29123ea2240361130c80fea33da9f9c0012ad88627723c16abc88791cfc5090bef834a3d10a79bd08cf6ce2f9ecd8233631a02851742714ec77ec2f1cbd0da29564954a9c3465d979fe83c45b7aff156c1626ed40c5f659217c995a2593c62efdd6ee0ba6c1cd7890373201dc026a7b6809af8f95f1ae15bee81bd3cf9cecbe52f9414980167acf8053c1be516217797c1de7f213ce1923ce8a80001108f279fd59ce89c7ae8c2b8402c99bd9c34925f9c61c0655065c8ee3b2b27da0409472398d327f716f2263b46b315e5fe98346452f1ab8eab01338e2f13d524ebafe6214c0347ccf8bd5599392918463d488014661d08f01bb6b64f57b1209ddf18058b4b7de13e50f39b56160e35003fd543c63403e8a3db6ead16ae76c2165b5ca155190a55904058aaebb5a823c82d1d42715863aa358b439a64c76f4efae88717c1de1ba5b9db7419d349d2046b850a5fe49b5285f8d19753f962242e22355552eea11fe5835709d4c70d785038c9f19c74f98d67256c1212609e3499d7f361b87c31f6c9d7736b6975080647f65e11f3543e5b3e0ca7dfc1b336767503de780e97acfbe28d4812a25bf4b2290cfd17e7f1a0232ea9484a5b3d2341cc1978167f47364323c2f86d0959fbe353528f82fe007bcaf7f3d2bbe17bdc9a9208482e4d9cc2b572a360c9520f0a92f734e8cbdba2a66f64bcfc510d841586b4099f77c9a6754e658b1ee697c52d972bc74dcb1f47cee2babee72b08a2441545958ca5c4f6720cdb3ff3bd386721dd3a49a87f8c85773cdd662db509e778f4976cf2b4aae8a01a3b864ce2cef1b0672e6056e1f55fa04cae3aa725dd3df2d38b59d667bec8e9729e86a1ea398db306f52ef711d7ccfd6b0fd8f7e2aaf4ec0ce17f749be2b823d689f6352343fcdf47b8e74d9704eec7b5efede70e84664b7d221a20c6b6a2bebff6536ddbb5c6d1fba5fec718ca2d6fd79f50fa2d3b1bbcee5c89a7ad510d6da044311a2aeb2a565ef849185df602cb62543e6537c3d5844cd2aa9342d455ad83bbb47de82636a6bcaa8940b5cc2eebebbd6bbe6f1bc4ab49f400d1985c342919fd43e4de8674e8361bc9768ba99e4be967ed5fb2e5b3b009d46aa584186088964255e49f6037155386089103c5b8f10557c941559027fcf0942f22be7874ceba20e6485ec25ecc7623d61c34c43bffcd595e3b4bc75ab9086b62b20eed4dfc5ef1e8178e69ad24a49e3cacea667e25d17607baeac09cc75e3d6441246338c972c086e303c759e98362f11b494a7ef79f43e859756e590bc0b2837cee335109339e135f4f545e011efe0328f96c9b82beaffb82c3dbb5c2b97ca5889061660ac3b45f852a43570d0a67a0df69edba354789b197794777781b9ba030b64cac1e9bf342fff60da35615e62912bf7bf6a057aeef40ee22b62ae7da98b3bcc2805f51c9f73b812bb794265ff8bbe5394a5e5c8a5aba513d5c98d33611a701354d6fc9b8f4ce6403d2f753249ca75ce0a3e068b3a13070e848ef5ed38c76f09005c79a9758c346900f7e380c67204af8489dc7dc1a0464fc6e0a258256e425fe6c94c1b8668f2568dbab7286383ad505578a8816782bc6bc1a933eeee092046ee060afc8d7131d364bf5bb67a96900af5ff0133c62e77a962fb1022a8f5c691d812a7084b87e01a327e4ed74722c76d0abf17e9556b9f50ff854f894ae74a235ca6c70316b323b93d1f181b0d5720fb17735955a394bba68246744a65159d44386d2945cee6bfd55ee0cc7fcf7105b46e643b346e61e9e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
