<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"53f79ddab3a8373df7911e34d159117c31ed8a9bd5278aa9a8a507187af74c3bd4de8753a609a688ada0f179b7acf147bfae5fa18bb077f349375f43d35e78dcc1cb8ebb3a93d32e3cc03e43d664353c5d6b987ce38ba0bcae7fe870ebcaab0e7731f3db33cac91560696b3dd79d2f028b379feb069e9130f59e97a469a5a4127372b5ff5b50f219d1c3795e047eb555b346819d1e7ee1511b544af7af0d64d598b823e6f025a271f85a447b80a787a6a2f21263ed970d86f7bd612e7a5f054ae6e482ff0582e58ee0142e905a0b529887a6f1507769c3c5385e9d458411d88846c65fdd76a7296318e1053ca1a40e8c7e09d3b9facc5b607e53b6cf003961a23e532530048d5a1a28f3516cc589336f981c113124c82d21ba5d881b480a6fe19c8f3b9aa2467c7e05ff26b765e7ac1f2dd6c1a901993ab72694ba7c1945d235e4458a166ab8c1d4b85519066e8e37297a8d2b5823be8d26f48e34ed527485bac78d1312a38d123207921c8f7230da81550a69b14e9f9fd2b036b654eadc9bcfe3935415166446c88aa312d997e080f0ffac23feb72c9083c3468255303e30fc6cddedd70b65a8a53d8b59a14874d46eb7a0128b0ec83910f208ec501990dd1138cc041be6d81f3eb84e4968683862eac48dd7777c8b785ff03d83bc2f882110d24dc49e001cf24e340ff3f42200e6c606808c435029c455b34fc0520b9988fa66a9fd8f204affcb1aa2b39b6a618c48ddbbdc465646dde3b3fecc3bb4958058882a22188e030747594febb5bb20504070aede1dfc1716d779a45f27f5d4fdf0b5310036c92f212f620ef3615b00e5ec9e5ed62a4e81875d9849656f3025b5a93a38ae2b188fba762fa6b33ba9fdc26b3c7f00335d588ed2737276307ec078b4d9579617e60b112e52e5d42cbea4547f4959970f8f4e814b521a220ba0130c7fe4dfc5034be12a097ca78ad823937fa41c84c5e6249a7e5399b993a63c982e08023fa64db87590c8d5fe1c9185ff1b8e8c675bffce8d4956c42f02eb17a5b4b86c5945982e9b2c2cf5e4c1cf99f6bdfbae9f8ee74dbf46b85ec914fec98dbf3d8de9e31961aa81021d52f421f82112ae8d3de30ed7d1a830a66572b74a2b79b661605fc19752f06386d346c7c445d158d2600ef5d254abdb7d476105c7c4a7357b06a740e1bb2ead50f2d3344c5e9616fa5c08d42748192be821d82a31e544658d81b72c959826a5eea7a166234f235efaeb50825195ea1f938ca4daf6cf5c57d8564b190ec034a842b831ed129b1c6676bed9c66de83990aec57e59a1a673bdcaca54583ca0d6dbd16cf3b4efea0d287bd5dc38ae536a4d2fde00ad8c24bd86bc4e019a6e3c0db0146da0267bafe883455a96bf27022dd3975d65f5247193b32826f57305c7454a8dfeaaabc7ab4eff7842e5b7d90d5436d5dd8ba05dd5ffe558ddd6107fca1297ac4a2d6a75b19cf3dab60245220fc7da76f6f990fa33777acaf583cf17ccdd50378b211a2845af2139028847328963a20d81f08bf39904d496e1f8d2e075927aa190b053986415cd6f9b9d0d5d11a95c9e92e0f56c6866a1df9b34867a20793bc3d0bdc4103030ae5a14390a654fffbb71f8ce1701ddb18f751b7120af72a19863aef1c6ef70e3d6ed5d51b5f9bb5c09cbb71a425fe86ff223332b740dedd9c97f632f2eb367ced67aecaf4d2e8969d9a8f62557fc1ec25ac14d1017f81e350de6960974a2c3824e5aea6cab64183708808d29abfe98f7e02dfa66b6b7892e07a50d7098091addc5795b952673bddb0c141069c50df7aea0d6d87801d8102e74de5a80ae9b86e8adc4e6379aa75a28a57339fdb3459c98b8aa07837d3de5589a901d1ce7c42270a4fda1f97faf57cddfacc9de845dc1d2b395e109618e40beea38307b5b37a69853bffac5b9069a81aa404287184cef54931e810cb65485f6c42c10c31fafe36bca20370d8c7cdd9733828874893f1cb33b87d13aeef3bec886b5d9144371763e60a2ddc653fc73646fa8ced440f47effec3af4fce8074134b45cc405b3ba780eb68105e62f3f5f6018818befb80b91bb7ef5a10a1a4e530e8ed6b6d573edc90fedeb57410ca8aa30daa3d55a10b88d51d09a751651a11f5f11bdba392c1bd588d89b6619154316bf86dce35926f453c952b681d6a0aaa313d20c7efe86afd5df2edbe81af9db4492c7bbbe59240ef092500098adf9fef4f515e660ae65deed176b07daa5ce83e642eade655548f1a8f23b232667ecab6c51033df42032e3b19c07e0be3a388738f57de3b540c2b15b2b228422428147265758840327c8a7fc514777be63454ca47e6914193a00aece0883ca9e56d44dc258c94be75235527f6ab0ec1989028cf490cece3e5a48ed67686c075a14ed7b93f63c257fd58cc90c30144cb7ba77dce35802660e7c08c7ce82d6e7277005c825d85a870bc9c839642f3500fdc7226736d3caa8fe3450ce4a8fc294f689109fda4174db9443aa9cfdeb71a95836b8ff517c9f40c98cd05c6993e4525721fdb85aea9e3f135fb828d9dc3049068f0c4e2a9422863c77cc258e6bf53a3c1b37cc5c9ae2ae7209b8f1e93d9e46d3e9127f92101f4b0808dae75844c8efd570eb646982745bbc0f300075a6115cfc0558ce10b036202914b4b543a81ce43459a4733faf9d3713e1d04175684098d144ef83bef48166f912cf0fe17ce44fef65f36c65d59a8a468b4b1b3825f5567fbd4e7b28b760ba214dbc91fd07b611496fce9da4b355b5d87036897cb146b55e1465fbdabbf21fcbd40729a3e2d1f71c83297e67cc9e50317c90e17a6faf77d5cd13ef921692554eff723e7a6878eba625a69aa1a44f875bde51519ef4cc84a97b2cce1ff71ff82249e3b8fca40d0cc90d248203506b275c9feb26a68b2a85d8afe440575196dfc7712f4c9f4c4428cbb701f8575cec69af958c93ea6be29844c09ee8a856ce08674031e89795d054938cf7d7268a4d1ae87e714477ec5751f52bfc34abb5591e611da104997205b78a83475fd00f6208610621d73874c040e5b813ad2b1c850143a1355b1836504294286c29cead23d6c9bfa0c97927c41e00c1a01b123e8da1b7adb09f17df1b4d5dd5c185b129ef8e9cb6dc2d49670d8927edec89beac0e8ccd34ddf58f361a32ab9b7479c5134fd97a81bf6991791b3b5fa0c6309b366786110a2f839c5bde75f217bdaf187f792462893ee8dea230e6518deec93e8b35df21b9382c428aa2f36a1ce19ab4951fa457788c7c71ab9c218f11968a09270f82e3900638ae5cbea86562c8108d01c6527a78ebb46349d96fd037382a7a34b1f8cff2cba49666ba4336430b66df9be0de457a2788151d597a2f0ffc3e103410e1ec274579bbcc775073f1c090f676032eab24cfcffad1cca63a20560ba2707bd6fcf89bc5ffacaf4c41edf187bcd2353a1dccf595bd714f59ac2ce552d3d0f2fd3266696b3d982ad588930c0357ec4233b911a535a6f35e565c1e9799808ed43bfab49785f6c218b71f6204d50805bbacf522a7fe5e9b3126dae93aafae8185c617ce53deba7cce247b321637b4e27ac4f6f935460478f954365e70178a2b380fe84479a0f16fe82ec7b69ac92f1ff94f7e3152b51ebea3b056230eaaac32908719147c21cb7e6359d5367d00ddc51d83de9a49255126092c8c29802f9b48bd39c6f2151fa1c443db373e015c43e077ab4a2141c4a76cfb148e66078c0668c9963775307bb64693bb20c743e79d030dc8ed74a490e039c16bd40b26c846aa0e6639c60d71e9a4ad831ea8e964fdfdf6bba10de9766c6a8976cbebd0423d72e8694b1a18c9e29da91f6047750d3ed8199974e4505208f2a4e096882cf486b9f9a5e3ef25a8792f8eaa9e17abbaa18172a4b0847b54fcae35741b89e541cbf945f3b23afbce6261b2c9ff1384bccfb9e6da277652db201e0307bebd5b153e40dbf26065ca3bdf4b600493507c80263ca4754071be97418ffff1fb63a11c54f86d9deb3868b2828960a77137b1419eb9b2145a83d89bcf6e5b7f9d7d13867e6f08b30ad5905c84c3ced805df021595e61109f89274ca54b953931ef678ad10b9aabd1f722593f248d13b7be55d77d02b3012e11cfe69dad687b246d986de18804fc8677bfd93fca167d825d5ad098eba92f03caa081b6a320465d53ad9504291fd0c254fd6a858dc02c7a7ea1bcb752e75922a0f826b6c30175adc4e27eb623f68f4b85385bc61a660c909b76f26a16ddd379557d116259285fd54f0e4991a09d158e601ef5f297a5194af8f4169415b6031e07f84fcf67b16a9f5219327a83691941def438dd80e58e4be05c5fdbf52f05d754de0551906ca43041de69a72588f655743f89ef1d96a2c5daf9e7f7f744811d4106da2f35639bed3a7b41030c4d0cb9547479e0301e4463281f7e075311f670aa340cc3f05176b3055bc7dcc2aac4d93829cf6294c7e8c66e18d000f3bbe0d7459e5cd154e753d7087a908ca90315a4be0ad682ce975f971dbf0dacaa21585570a35f5330c5636a24e7bc6c4265c260c750e9f0deb22c884f56071feaf994600dec0c18dd31822cf5c02820e54caaaa47a6c35aed61d96f6575e48393fb912bc355fc628da46039e534ee5a244eb9d1470a2926c14ed7854671744b90220668a44962a7715d9eb89fd3e30542b95806346ce6e1d93de6e8a5e6ce1b22dc4fc31f74192f744d925643d86605bbcd08d147b58b586efb948713b9eded330bf0391a13a802c765430e2a7e42f8ff8414131a81c26e91571082ce1a63cdc1a297949e3fa688b0b0739338a068750017695f29c4e1630f253c845b3a8ef922a9b2dea0385e577fa1a22058063f1c20f83834b5e135db09bbc9024b73cfaa9a42bffb752e46ae8f6e0f9df6fb58e15fc5337c23148405489936a4cbe2d4e1d6635029244068003cbbd6c8bee37a19cdd2e53d40addaeae242b00c29cd1e313ce671703d1beb682aa7b4e1953b33acc595c612c7b85859c83444e0fc688fa29e5780137b4e06cbe3300de6b526e25a03ea958f874d096caa32475328d3cb89c9389ede553fc5486447bf15b4eb4ee0acc608b70342bd0fa9ce7a240c2e53dd15c3becf121f5b3463a70650b004de3bf53f3595de4e0194508f8a7771d929bf937bea57ddb9bd9ee4f781a682f20343711d1a1bf6dfcc9e5b42fb1b6ad75e22f8f384bea7496cd2575417b7f90c9cbdd38edd22c4c956b5ac85db658f5d9440296fe04ec01ad46c77f1f00c1bda88c372bf6548587af1670e43e4546ffe2295b489bd590e18ad801c7ae63167e9421ecdd668db59cbe4e085350c8c2be01b331ef568205c5e3263af32209998019df69c089e7d91e03ad3a0d2f0f54f7b1c5f2e3aff9eb89a675e14ac9cb5cfbb533e6b03913fda61dde2b64b97f2be1721166ed98a3d5f9fc4147a19275bd390c6cb19762aa88b5b80b9003a9c13b56bc16b8613dbc88ab68851c61914742dc987a4b069e01b5a22ecf0271ecac14f07af88389c5d3f37e67e4e0a919e66fa0b534bc07de29e3a9e5464b1d00da566a74bb1251fdea2b9ff78c75dc4e6ec036d32d3c6c66772361096542be3c9c02e83ebc647770e8a80a834463338aee141c7c1c37cef29c38f052de2f19ab3b67b9027ce8413954b228518c28c4a1d3eb2f09b8af23af7baa8017985efe26324653235ece1028b61710cc99f831a129ff574792cb89dd871e7d800145d3e465766443fd04d184f24f13ec3ae0c3d31452c22f309d22ea6e8f2572090c36ea7c9198d3b74888989f9ca8afb71b31ab0837a26c31819e5b2e53c14874e13969d6bd6e7b27ec601a827b6aeb29ea59954261b4917fa9e191aeff604aba6b16307a70f4bc59a84e69fda63d973c1312a604052f8dee7c90f50175d038f0cd18b26a27cef8c7434ac93bb8c7a3d95e980e405e7b7dd8553598fa420d38c5617a4cf6479944d82138d740caa98358b42bd4c38a9e32b46837fae331c795bccff7e2d40a02860b076ca20d151ff6a79f1ec32741006dfa03572400b5ccadaadd6a1d891badb8529cfb95add1ec50768fd8cccaf939796154a3269f1f71272a9f012daa1d8a614ca51337dd92a647d528824f91b231d0dfffe4a8bd7db5d4e3070f951389e83484581d214fa43eb0c18344efa7747b30ad58c4cfa8231e4051a98a4bd5570713ae7817f4b8ec46bc9f29a590292e2e226d666568f2aa2b79d454ddd574993f2db8d5e508a06b241808a3fcd1e1833466f215e469308d218a874213050ac27ce5f8eaac2db0fd60a9bdbdf0f33393740130245fc52f777811ecd51b0b2a0a75ba8c8e96128b02cc8845b75c0d96277517b5d544a9a18f375d54a75aa45ec39a5fc56538bc964d14db36148a26bef3f6c794eea182873e98d1c4a3d8796b3c7a0df3e4279a67b1eea566e305394d473ecc2f064edae46da7bbc84a3fe8668ba1574ee204a6d2751bae656e5fbbb96840205fa721f1da70987c18be4d5d046c88f11f31ca2b6f5336246d7f4b606ded36d78da4a10c3feefef1bb2390a0d4513ac8c9394a8ce08f59d03afef158d5ab6f8458835ec33e74594096089d29e4709b66cd3a7f0bea3fbe8dc9c8025b61a1188e3fdb1c19e8688a022867ee1ded93c87a89349d86819f46b1fac759be46a6d4de74865899d28cd8a002ade70ab985a7d2b7762e3d1fd6e8e6b1ebc43228e5f74c80749871c64b9f6b89d5d34d80837eae4c4a646731eec6213e11b8a912a29dde0c7c60c18f6e78b84e35392fad53f8d37b4b3704ada2b0afcefc626f52327703eb376b200387a76ab6f16e0571d5bf0ecf3cc188be85bdb4ad7f8095c1fff56da6b3b420d90c6443b3e58f2904a437dd5a570d3988eb8fedfde0bfb88f42a2d0f48ded1d6e5b417dd7eb767a04ddf9b0b2f8a5adcd722f47b21a2e605adac42a3c85766d8815faace52b14274fd5d0d7b46187736642d477e2186ce9e8cd13dbefc22d9193b5a1e7df0dcd9f8cb4bb996362a9efbc099ba1ee9634cc5f6fa8a2facb2c817ae52ecad95ac82469f9cc37ff8428d062df5ab345c3aa6c156306c946987d183fd414d79357ee1150ae21d1c16eb70059a31ca86f2e17f8f4816ccfcf1af0ad1cbd07c632dc646a2130928e806b9e3a66133d5b1ef09d7e219a4f81d0fc31f6dcc3714a3da25567f90362772e5db52a494e56204879b880379cec50e21c8f4dee37b399e6921f9fe64a523b1e9eecec5b845e86cd66a57dcd71b15d8622bff796d2855a705254f95c942474662a31e5ccb7b1a75de4157ee766eca36867692b47f2921f70d8039a9073d02d3083f13e0b0a840da308bc803ef1a2fa0c3279ce498214226893e143a16ddf00dfe3f36e9e3c4a563d0e5cbe9b161fcf8ee7b60e5cf7f7c12e0c36b09b1f6ac96e9ce49a05d3c10d7946f2bd92500d661170adc3bf71f01fca830a8da2dae365c787689adb4efc160e999eeef54dffdbd45152bf19313e11886b8043b904e91bfb89c85b72f609f3ff5a9cfd024cccc4954a4a1215b46129de616ab056e5e81ede78baadda20b66a5e80e3a9a88c7bdf03fec3bfab2f41cb36693eaf28a71559c9de2f44597aeced7aa70f05b695f857ea6ae84fbc89f4cd6672f3af0c259275c8e1815e6e0d7579dbc0976e1825316ec78ff16908fb55bd48c9b0f4967d8302736415913c03761ce884cc8939e29b07ce3ee9bba19afd9f132fd5f3dc8f004579264615e2d2dd36f92de497b661eaea8a49541ee1b7b9d149c8bef44566b70dc67b79fa4754ccf9f800cdfeb35eeab08d109edcc877f05f0f3aa4c78509b02b895b01dbc3a3cdb54a8fafc7d31852121bf39d0092d0b5202ac79076d3cda47d4cd45d02c1d3cf266eea34fb66037a337f1ba13b33a82f19610794b9f5671dbe098610be533f63715758979d5f0a3ec87531ac5c64f507d94b60c8cf3401d8b069cbaaa37528d638a33ee3a25e3e3b28e62e391451318710a7d3163d33f611e8094f24e92e0fff421981e373bf663394040be7d3ea294fad461246d319c7a37981494a7b68a9103ae93be6139307ccfe5cacfdfac4fdf9e237abe377bfb4b68e179a2336bd79d8f82e93f82cd901353992e941404624faaf14a45214a0e4cc97e6093c4a21ab72ae956139212a01321705a6e13d9f1a373ba30e0946f31832e4b1dbf6aa17553018796359d2e9e0cbc064c829cd89e79a750957bfe826c5cc1a3381cdca60fc535bca41c627ea8730871348cd28c1460f118c0f4a6cf3b9c3d44067f4c31c2a7a038b9b927924e872710cb4bf9447387768f772d840fba5fe9aed16467ee90731ebbc2588c46b16859ee816b84e7f39e9903dde922fd765e99841be6ec26316397cfc3af4698c281fb1fed608fcafe8de99916fc84a991d012f76370ef82ebfce78a5e3fb12f081662979d477bfdb94e5b572a79f2f36195fecf0fae58bed02e03da1ea4472e0c095786b00cd7503c5c23b998f4a38c0e51f36a6434b8ce5c46dd09a836859ae96d350210330d88d547dcf4eb5b093a80653397a1f9ea5e7bd2d417efae11d4b7baf8550d1ef8b5c1995e51bd215bad1a0b38be69f05433d292461b541dbf234e435ca8554843bfa93550e4cabedb815a11dcbfc0765858ec66ec3e7b517170ad694bc7feb8a27eada3e82590ea13272539ce66087f26fe2ddae8fb9141f8a5fb93da1a2b64d92a9f047df29ffc36037176bc3794b27f2522bee183ec0944f5ff10fee061f6364afc013abebbf372ac8277eedddd97952b875681cdb5f0bdbba224a14e841006fd5ab3872c7794b0e28f4e23894053caec2d3ef41d6e50343fb86c6c37e0de1cd0c2a03bc0e31f81c2b0f429c86789d9848023e0df82c34ca5454852e10451b5e26eaad8ae0d4b7ec0e8634e0ad7dc947552d7eca50ffe1b54a08f73c1214a002b50e42f57604c2c361e5bb7da95d6e32f4848996841ce541d671ddd8f7bf4259db334875cb2b4c0c384d9f4a18215d00426ed8fc8b01f2bbd210871b6b1d3d1b1363df725f796766bb4d564c7b2b8a0473c1297d830260747edfe253a0eb24841a819ed1dcca46f1ec4da6b6222c4e83825f84e3b6f58a7e0ac0ca56374b21518456f36f8d8898a6f80cd6e88dee7c39f19b5bfcce691b6723bd06ed5ca6ae33b0a73bc770d4283c471bc394ab25ba1c9503fb30b792268e6adcf38d4e696bdb6c0f35370f0717abf17ec08bb4b0b3d169da7981424b6c86ee824da85283c964ecab9e87e201f53ac64b1655ecc2774c9c778104c982c8d9c2d4569abbcbd90e22cacbf6f5109289fb2a0b01f0d54147e635ce068a53bfc35828e654142fb0cd4d9c62a7a1b9ef28b0ebfa087762ab66e1c6075342279aec9b4e1d9da7cd9225fa701268d6b16ee83e0ddee7674aa26733cb1912b2d54329968fb2b81b2441d187090f81a6a3ee4ced443a9b204fff06f6f3bdb7976a7d5e42c5744440849fb770cb38e1ccca4365257eee0b110340c7c014d652ae49bef19fa24321ce45c49cc493518742869d533b93599f17895fcd1e811af3c970b7f6b0d5d8a71a8ea3749c2a60e9e935d00b738e8a3a868908e6e1895561df354048596cabd778ef8e8edce26a17a94eefe876cbc9e7d81ff48de1b1964f2c46a0ab86d179a5a8daf94b8e2c4a5adeceea3aa5a083c5728e1797b11308edc864c967a5d1f16110bafecf68c459ed98806feda3b014590690486f026e51260958e8d33a80e3c40fb319cec55a4c5914971bc86e9b7e0181818431b42c6b2ef809cb833d2de09af09318ba384537e7aa5cb7c80030d4ff45c6a05b87310c85895eb5dce8b4ec90c16ca2ac262cf61294cc78caa95d4073cfababc525eb5e3653053a8af6d748eac1002b579173676871684a794199078d2fd96667c5c831de936e374b225d7aa3397d2779663a1157bd6e2ba25acdfe770cb131f1ce4e41e4f169f45d9fc0131d556fdc605661f8220e75a370bdec60f053bd178d0e1a328b6ae7497468de0b236e6f08d872d7365807a5eb84aa17f9639a0b0f57f7da26a59fdc961492818accf971405596d6489d2bcac8f587fe6ef28d15ea1c2edea1f890986ed2696d8a0a04c198cbbf089c3b5e84f4ccbe608aade61d54d7a460ea0151600a1347f3fb381efd41b8679314349761421824fa6ae18245469ee0beec65b2eaf777fe92e0a4a815540b8c7adb4ffbcc0fd6906bdd9c0af08945e903eed2ae2aa9c3154c3e090203324aa96a90dcf3aa1598f1a9026ae6104d86a7ed3060e64126ed978b59cbc43c1e0e75b19be843a8f0d1bf2d1552f7a9ab1ffaa35fe4c2eacbf16f92b6f5fb96a8b3f1f00979c627f3e189aeaf8909138fcd51d66832a72df20b3e9ebd56bfd29bec9116e7aef2e367da42bb44ba72cd9bb1a64307429904456fe11423540c5b6494caa76b9fc4715da4477559fd2915f5e617b988283e93f8846b8877c59c848b423cac99408bd32a25c9d84c2dc65b9f1086a3c0aef4d3f6a79864737cdc05dad279bb2647b69051767f8f8c92c870a268620ecaf441671048a5b2f34e031fbdc4cc04626747f823009756c7fb828a16814746df3d5642b940ea082225e0ca539e96abe0d1d2fa4f0387e3e9f1bce36c32e821abf37d839f8ab07bd30ab75745e3e7eb5e61be18c137168dbe08b3e5ac5c959796a45e0f3228573ac7c7cf1906d800f69978f350e9b0c5b51988dd1dd5ac7998892167da0468f0e9ae6e843e83a25332b17da893ad27ca99240e8f1ac67213e6310e32d63f1b3d8b3c35f0df6981f0066c92d5e9bf490c6b21a25357548bcd9637b049783c5e7280be3b3f246021e6bcc710a98bc035127684dd5f83d1c3267e0bf787b6a559ea05edbee5010f5c71bf686a9ec6318fd051af01979de321fd992ae2685e93623be4b09b4f4ca01d4360725e26ccf45c9d4c95e8c2b363af4386894dfa447b2b97396e17ff8c47d54b356a846fed80ed7249a34719c08d3280fa31a3f5c2551d2bfe5010693fea38253f96687a7bfba7df6cc29ecd87a0ed6b05a19fa39fadcf442f9e092601fd874e2f68e3e4312fd7694a9d93848416e7b6f17cf78bedd266b9336dead7bf243dea38c715ee5f4e5bd3b8e347c5d766d4fbc8c7be1532703504df7319fd149811861f29f54251605487c4b8f597cd0b97ff2f3f0e0d4f7fd8c669d645362f014e8351f5d790126e3b3583a6ea971b13924e43fa62184d432cd85aeac77b6058360559fa589b8bf5d907cfd814af818d5cafffcfcca65ae00395c0555be13281d1b977ac04ff750563dc34c009d0299043343ec71343108a2f0205b97800d19842ddcde1f704ef965514a6b73f445d8b81bf2ce260065cb4abee98909f87114271075cad09d9bb636890891b5e77009f1a0e1444b06b471ab63554057e8cd526eddb6de7ed16cbc9a6d74632cee0f1126015b6e64b08d22694bf786ff059b7ae6c72f1831c8ddbd5d015927a935729f16daa4e9ca9795363a1b65ead421c494127f91e49015915578301607c4de5a91e3b96ea3e2cba3623e9e3462d02bd7338262094e7158a357e72c68ad07594220e4445972f525de28d667561278a1a2d3ee5723d67c2bf4f27fbd206d0c470e9384c8b95f18a6e64bbd75f73db0e9c7fd11b2d8f8b2552fd0475ee0a741d3ba1ca66c8850b5bb5331f42f340115d66b8fa9e94aeef2851c18d000437a12fea22584129ee2b239b3413f9b8ac38de75fdbc51966969f517a6813e1a86844217bab4b0790ea42ef0b327966b62a54caeff74bfdbc2084f08b376f7584479b69d56de9e29d8c02750b4958e4fef030121c064762dc7d191d6fc7eb54c504d1115889c11250045d4f56db75b6bdd89ee38b62cdc978ffe2765e5562f3bd5102b03b1575d8bf7b90fcc0c1112cd93ea3d295289baa417be34de9428b3ef859afe8af6e99d7f4e4cc42ef1671a8f80ada083c77c8b9f96f23f7bcbb75c46a0ba46d27774e369a0041df03ff962593f78419759f3ec0c892f050f49043af7e1a3903465330c4ed361d9f64264839e812fcad9a46a3b8413d87de90371f0a86540f3354ff2e1fff142647f6e17713a079f54bb7f46c168182b914c8f3b69151c242daa1a48eeab7c57590af31bb09eb261a4eb6164df28c1df80ba35e0eaab7738e92ff1cff020cf020f21f354c0425b0665f6b6e8a6c4f70766ed3ecd13ba6c76328ff3e8ae16864d9fb7d33af69823711003aa6fbb02724fe035f61edc503f16df3f4e05dc54908549a6587f6a2f71816662a7dd93529253909d11d52894a0ee06590dbe53d2e0f7754c3c5f4fad342fe226e3501cbad16f440229018fe7d16b1030e0c3ede228410e3fd89d153e6e9c13cd95032113ac21e17df24f4daa3e3bca4c624ab363f613359d767e672871305ad5447f7550ebe84c6d6009ecd7847211826c68136e623650a3f4cb57e9ad94a2b43e38d7e30e39c213fececdf26157e814e8fb71eeb79a71bce29d249716b094e2c3de0dbc3e727a93374c7c4cef8b18b37c67195773bafb3b59eaa6be130378b4cac68e704410e2c9e18a17c0e17f16c106d2a2c56a6510772078562968ace4e2318f2122d2ec5e9329ea0843724a6d65a2c60ce4c78b3b48b1a5af42fff72706a53d4b23caa92671ac1547a935a7d9e1918815c73d958069f23d6bed2cd73bed23ecc51a101baa310104bb03857b21f13b954098445ddf56a71791a756794404bd7e8d72a7dce0f77b525b8f371d766bd9b377d48de62888e0474e0344a669c6f26a3296df29b19b622c822031a5ddb8c3b3bc73f2f094ca59f3f365da07283ccf2a3b782c1321cdb2665479367af72d16558007c5e3b0b0a60d9bf90a91938338ae77cd83624aeefddfeabd8d805c0780a3ff40bd4be3484bfd99f9066781b421c922926e233391a947c2c3cd028e3f30509087ea972812fcd6b323c801368833d6a17f5b438ac47d4244213214b040ea098144595c5121bcb8ebff16443d810eb930a533ef8ead6e35a9f5ebb6cfa450ac20af6a4d2737fc0954f5ab2fd9c616ea42318683809082a42f08ca6d4fa8a7312c32f25f732f58877b5ac3d17af612a03ae513e3856ad8ed8d152776fe7db78a34a285030d7d3857399f26cbed626cf691ae0e1f4d80335a538055da634479b1bf4f9872f9db4de6171c48ed6844c0f038734ed5472c14506c7a5cc2a00a3fd95ff4570b42e80e331a587aa316d311c6490259ec774f12631f5f9207ba31681ae40cefcfc290bddfd0ea0d89f3f142b0458605ea512cd8b3d9f4cadf57b301896ade68297a90a97b9bed9b224d19e6aec432500b3b02121e62fb0bf21373b0f53a7cac5f95f490e8e2e10f435c7444e0c3a9ead9bcac7f4a2df5e52f5c4f52d3f22b940f2cb5a2e58dad43a1337ab8e586358060207744a05a2b43e4e5ac7e5dfa23f5ae364b34aeec157c7bce5ae992f8929d0381c1c1bcc5c0d101cbfd9ae934eac99ff513b4a2691be1541ef3e1d4d070da5de2c8bdcaef3219a86938bbdb325a5f114578651617732f4af4ab4c8d19a7601e21a4017259ca73443d2f5ac5c8368595a9225e489cc8210f64319fb43f45bf39567f05d8693c97aa95e0ebb29802239d54cd9c087bdbc326f2f0d18f30534995b78beb64a77f86d43953b2f2686ec1964954ff004ed9fd0e9776cfaad0e9ec02acca286680c678185b4630f31cf2c5b9776cf191b97bd5b86bcb3c6ff7d16d7f27f3975878300977747ad339e2fc67c155bc3ca044a32c57877b38526976965b5ddf11a941dc70ee017058ea9d91e17736ae2a7729433602f3e958569aa9c641ad7837a302308cd26a485bc49a91cc807dc8175f79d4294767fe4da4d47dc1251df907f7ba151297fe4f77988b13eb1700b98e830668dfd36729a67cbc0d01d33a17cb48c8592c04a8fc3acebc101e9a58f2ba729426beed2ed82027b10d4a7609f4197d0ece807057fb9a21a4191479e6de5746d012e922df555833197f3866657abcaf8d21f700934d0550096eac0aa00e6b9cb1663f952c76a96297f3a5596487b7b874b531e82ab4af1b7487ac5c3f6d21479fa416f0a089c7ebc99ade495244b6604fb748971a35877286b0726ea89d0cec816fd952a366953dd640deac11e88dba871aa64935993c351295a1abb96426af0a4b91c5adb01aab500744d7b7ac5d5bbbd5e3211b5cebf99be624a14d99c8f14f4906a08d201694666ec357a90b5392a34ab972884363b547ff603de14870a82b6228c73e10c27918f5851c749e2f8a1f28fc3ee8b499a18a7aa4b77b38dc7c64dfb9e7ad9779b9d1759cefa4c2414f893d1334995ddc5cafa8e9edfba55178ed6867a561ee1ebd0588b31477ccd6ec1e6363841052cc2ae1ccf0bb3f32698ec4800eacf33e20d31062e40286dec64f4d1e6cfa036d94139a9e17fb57763c0379cd8eb690ccaa3b1da524fc9ccd025b4b0e6bcff0303130ed9011cec9b94c7b14ddb4d29e47182a8f7e3b5ae530e1bd1df18defdfa2253229121e0b2e9d685feaba977667cd2f29a551a5262b3616c45f971e5e5ea5ce06252c996bbfe1109e3e59c367503257d9ea75fbca84709506a89e77498a00fdfb79ad4bb99f03612908de6ad915b8a4d3867c80142e87e0d752dcde3d621c3777d7d47fb35a5154bd8e3785e10168d692a319b384d48b97b382d3dc1cba4c9c0651322d43cd086e93103ef52e5fea8e2e21a05ab9ab75244b9666204101ef76af666cf8c497ca3ff4265a4dcf967e7650ff103c97841d0f0af027ea7ddcb2da66149c00afcb5ca8d9fc559d0d45b221044d47707eb13b4bc7f84f9abb529314eb8729491330403b8ebf5915f245b2561b3c25b73ac004f14abcedc74c697140cb61df9f72b73849e807c7d0b3a749d46b9c562a91df9b2a46e6fe85b3ae59fd97a27b0b42f4d5faaf6ae665ba2cc81894b8f2eb6c13af32d6954d48733ed72faf51cfdd4fa01dc73b8fc1bd196f8175a524de04d973c8f724371c5f4aaed82747f6b730486a56313db1b20460a27c30aa26302e19fa36b6145e7d51d01313935e14eec782e4bc3e654ded16f660ffc7872abf67f40a201172ad77c6a07717c60198f63ae4b0b3d49755bd216c4b59946dde7823ebaae9eed72b2924bcfe1f66e0dbee1799600309646ef69aa5450823a84608f5de24dc036c682ee3dc25e1b5834922e0ff33a9b026fa225f09fb85a61e637129fe6374786b76559ce53481e1d0b42d5fcb6ef8262823246dae5d4517e8a7c9ad93b0462b5fc1268c98c141d18afccf89aff202074eb399244bc2d904229c914e55bc891894e7f7c4348564dc254692c304df611813b8cdedc84bcdbf7ab2e0688266c5fd6dc7db5f0c713b248abc0dd3c0aeb20bccf39c7b623332f1161a1d137e508bb01618e735163214408c4bec423cf24ba8b6e6ab705b01de29df1e2b87e42894fe898c06a2679c515fb2fb5c192e4e741b426ea1017d857da668cf0863fe230a4743a85d972668526a4598a8ab88a8599889cf842fa9d257a4f35aa8e3728fad9f31ab075d1abf685addb01068c697af666c55324f93e252a0ad01f6799100873fdbe1ec5a200855c9d835de404f94f744c5b0d4d843b31afe39872447fe4b355cd5081e8940b7b444c09c7ba4130b21b45a7b30962de08357cf3d3c41e58499e0e7e4f435db670dd0033cfd1ac4681fd2f1c11462a6406bdbb1a0c12c2540661357dc72e886fd287543ee486e39857353aef05f9615513981a1332a2f1433bce1b9b3e9cdc7631ae5824a07a1bc5b4b490389dadc25dd4ffe4307a46d198801aa4755e4ab3380db7aedf5d889b5f33ff3621863882a5006056dd8bd1322f049414565fbe0940c1dadfc360ac3634de1a99308cc147b15e099e2e64ddb3396c9c276c75cd0de753610be29c3c92ed19535f4f19b950e37ee9d064974ea392fbed314b0ffcfc0f0e688a9bffaa95016a533fbb2a4df66d579daf97657a63c8294b2693126882493de226c6cdc19bc992316f70ff684c8822e4554a3568aaa01051767894cdd661975a0f03c53c11adc027f07cec6c86275c37e5d49d03507349646fc1695625623c50a16e067b32e9fa1fe95a76899439a9d927a2d4a9aceb29531ddbe41ff86c5d4b29ef60c9bcaadffc1075bb34582b2a730cd88c710e0a98e9668b8e1157b6ccee4ca9926d460d3978490538587022df91ddec7006c079e637c54659008b8b7308ad50c4e16fd8f4b8f67a5eaf8d0b48d6ed19740fa0d1cb054092de2f1cd20492183eb1352e67672f9cd64d3bc8c255addddd84c3b022ff8e2ccffcffc9d336774e8e5a3a4d802c84ccc60e2d05369956b586d016f25b442b851c0fd5bb590ac08c20b02f12917d9820f44a23456e7bdb05ae7197985fa39089894199b50c8d884b8acbe67a60d886808583092b2cfd30a8195348165a44cfc5d12201718ef7fd418b62f0806018a6a72e28352225b610c9641a38e3e6ed52e108c9b22c6810c0d2a5c8540ceb4ee9b897f954338d6983e589b636c980bb57cf2ce02d44fb898cd6ddf5b397654049af267c144db4aee66aaf74fd92d399ea972570512de673a2de00b19757a6c28ded55842b35bfeb426e8e7698cdccf51383ad6b669daf119d6c0289092e452b81826463de5990b9fcb051afba6adabab218959c5c0cc0896f1c51449286b305004c76d30a41a068c9cd38017eff194496d27d7acd189b3e18455db3e3a2f4c40615753d635112b4afcdc77466f8df91d6b7146909cb0c967979d537e9c17a245869543db3d5a372398dcf22684b53e940b7fb6fa6d59548c60d8e5478b360330f650f66a09ea4678b7e7a0ce3c6354dafac8c21b1828f8d7b495bd9d65f919f1b2ca59ebb17da40f34eb9212449a6aa88de7819045dc0acbea6369e5b9cd68958807fc053898000c7f03f8791eacc847f8728b31b8b687946880decbf51c01527b9d2cb8ade225a5d89fea8ab976f673e36fdfcad8661d17b5f1fffa134e02d996d70b098f5585b429d39a48487ea7e70dda77c65cfb89c2ea2b1a58a7f4c7406daab6f490fa6a24b7eeddb43bbfdf86676e6e525a9b6d52dc62bb8438be93c1f845655b288762162782429bb6d7b5c6b1a249e79ae59198e73ec98ce2bffe0b034faa12708fbcfeea86f83717daf55fdc59ea1535450b5c391316b245b6213a036fce39ff3088f65437a6a3a0794f194636e4d502f55d6a0687db6437192d58711710c2aa2b372891459e1b6900e8b8694fb16d7cff727319647b6bc1e2f1a8056e6535499bb929e152c5956dff03b67698e16677082e680c3f85527d8a477ebe10b1214d40ab11d847c22320aa4d054a43eeb1a5cd00a9892f45b26e970aefe0e637f5f321ded716723f6923547d129eb967309f155921cbb1ed84494d735de7ecfeb716a26365a5fe214917ede7efe27c22c0e4e20d647f8c03e76727f3dd0513891529c846a069561c232ee479dd6d6582dbd68ad2175a306976baa81a1f2b0d1dbf5f91a1dbd1ec26bacceefb47fc4fd270bf59b63ab60c11a7048573fadc666f79deba3f85dc444dfae8cf0993e016caf2398252451340e1b1bb61256fb0fe850fbe30f00ed4f96740eeb51215d4ac8a52f5c6ac9f29c9deee63f75ce960a904a04c2346d079c499265b9b258211d0f1503f2e78795c730e64284120ff70914b239d2cd8e1dff44118d367e61e3ecf3229211f744c9cc2422933424d535c9525739398c7760f2539a3134af1c3121ff65cec64d46a5a0944794236659a22ce92b811c0f0360c5e74eab94a6877067d35138da12e5422d321d1d630ba5415adab2deb4b2ba811b231e9b6bbaa7e797185518f09787c7ceb88699cad9b8a8031896a7416deb2aa58bc7a9e3172616a2923911aa3dcb012c1c571ca2c937264c4c2c133b152f709a333a0c1911d004e2bfeebdbcd021e733de910a4f435c9c0d5c96e10b00ef8230d6eb3aca1b35100d97f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
