<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2763f469e07ffdb1c1a085341c0d125df5bec15194b16a453045ed9f271893c2794baabbe22e094b0af69b684336ac726238ab71e0d93933f39a12717929c387b6a74b919e26674c4f2303e7abdfe5aba182beed983b9833032134378ecab675d3112924111457cc2e5c1210a83c7862bfa2833146894fe668c3bfb4870ed7d67fe299df17f8ece03ab53aa400b5c9d53334708c1df68960b37cd24c5e505ddb962acb4a0aa24b48b019a952883253dab39eef36a2554bbbebf32d1371887e835d01d52a13c60b7677bcd9d2f55872bb37cde1df7526126b8281a55ae7d3db84513194b28bf46b9c9a68a4c618e8e59467ff9399f1a728030a4988362adb6dffb3a790e38f506fec0bf640b91ef730859dabb587e26a67f6dbdc0c2f90d7d1eb3fcc1d3a47a0934a45ccbc289b68ca1145da8bc48a1a850dc4e6b8d26f58d570b34b4d835c6781972f92f513f874ae31c7819236dafff6e58b553aed37ee90febfba4d0b311766b61220c71db62e7e42a96d650aa7d4633d47813308e1e3f2786ae22deb32d483652c8a3eb28bc8a30d6c8966f3675a224c6acd87c8f088b274deb1846991f4d6a18f4faa3b3aed9e969fa77527ee3cc819ac20d4f03dab48583665c315dd8c1f2779429e2677612dc2a83b77c06ca06f295419b3d3db06aad313d146cb5112cc5438e9bc8a383c2152a4379a2d16c8e1200525ffef1c861e5673dd9d0391d07f1ab6835fda59f87b6ed51dda03a4989a65b7994f202867c4098ed259a59dc255ccb463b08df52777fd6b871dc53ee4bc1469dadd588ca44b4fafccf8b4668935975dd21fcb89c34a839baff7cda61bef34848bc0e3e25df8e3e4650c24bfc1fb494edfe030f5a076a9ab8a38d30189aa569c6e65f476c532cfd4e68b6241e37006dedf2b43d73aaef4dc8967516466224dceebce76324cb48f682f849c2f05d37ad4bd29a650cd156d50dd887304918d0a07b05f83eee01c40defc13cd102d01fa636641735b33e981d30c8bad2a2bde0692bd8f6efca0863bf3edb2277d43ef28d199b86d55839d435ed1c3bb0f132b4ee19c173dd3820e84e1c33c9fd15a8146e748d393f081434ba9bbb9bb1b4a259bfc34125ba0a86169aa753dea2d6c1cc7d1899f41fe9f9e1dac6dcb06ca4b55b5157956c3a25bc040fb7228dd1f8b61640a4dddf4617693758d20e2acb4b95dc2fa259439e4f12919622ccb53837c141aeeca12459a438f34d50517d1d98990a40ba7a5cca6ecc65fa13d768d7c12db6f3536ddd86a80ffbe59ba69f704cb884c6fe74888147d1d463e03554b2458ac8cbd6343de84d75e90903af4e12ddaade7b1b9f178c05ebc1ddce2fdc6be298e04e684f2a0f49d749379d0714611a3bc0f634f18ef0425f412b6cd4b09bb63262ad553c5ca46fdbd18977efb4b6aae18520a1b53c9f17c43dae5aa1ca21875004aa232d0368bb3cbe3f942d6635466a712ece25f7797cfe1914fd06c625fe3c89793cfca86c556422c07cf6bfc0ff2bcf0e5f4744897f58593092e953b4482b2801a0577d604f016fda71945db235760143dba311d5650947876e9fcbbce3178179992110e7ee34ce1d677e5b3c07d2174ef9092b06d73058150710684214dcafb9bfd3c5d9fa4aafbccd155c3aee6767a0ebb7ec989980d18e54a6be7e846241d2d3bf04efcc200508fc66a6c9123d9e0db391ed91e98c6c3fa75a27f21a0748f0689f898fff7802e20fe29fc27d3ca8d180dbfdaf1d807d57ea3db8e12dcfaee999c82d9e8273029addd7b2fa494a7784671e167726f8d2eccda0c814d909100811d3a58a97a85a16e21bea30df925ce0077baa09e6ecad4adbe42f8e93d63e8a96512898f7be6edee89008b343230ef30313514880f0ccac0aa15b65ea7157f327013356a2561509e9a7ee9cd25a5ba03a2cb7a042e80915794770bcb36337e780d8734165fa1e05a6504893c0868cc1791bef4b665a3b3448d7598ab3e83cf341c6b28f52b99cc48f69235894f145ddec8874d9866db899182f5a12b973dd8ab5933bbcc5009ac4495c59e2c83b8a7c52ebdecd8080b8e0a326672cff28da088b34756c039758d288a91f8b4af8bc12b2560a17fb24ad9afe91b07ba07f9a8fb3fa5af6e5cefcb786507d8d43439328bb09bc387a61b3f27df3e340501060ef2bb700f5562a3688f2252da6c6ec514ac7c477b2eaceb24754b940eb5592287547bab6761d175e541c60e41a2ffaf13bbe163184106e518ebae388a5e80593f14a4a6dad84b6427fa1c41fa5d09efa34d33c0f3734522cb5aa15bf4e7e70c6a48312b94ac75a2d5de0f7f5025e5ae817199034c2955080174a00591db70bb86f82e72882b820d33c9e19f09a163da02c01f466b01316c67a48640afcc67217d92bd5cfc6740c89f2f9c2c57df317c0bd3af8662e53ca4da38f6763676d00d44663c5d15ed501d155405a945ee68456fc16d9971a4030f0b13157376ecbd626a897ff31308ec108cb70e9e05aaf40dbf136b724621c180096de97acd0d45dc591c6addcc2cc9a3a0fa1d7c42ecc014a571cea008268731e3c4866dc7d9061c5a0295fc20667b4fadab8b969021ac2d66aa89d56aacdd9316da5561ae4cd7734cf0d44317e9e011f5db4d01bc37f0c8b116dc7dc128151588228e17fdef1b1bd9d1c8915662a2d1eea236943f97834b1eb43acc17f0c0c26280c896a16e131b7da76c5114021641ac32716be6aac723bae4751691f28628e9b2c8f38180ee3c7b9f4e0dcbe998c1d9ef1a8bb76c62517bc2ebfc254845842625ecc3243b7123e57aeb0f614a9dd3232dba5d95fa5561389832085609dbcb341d3ad9f77eb0be805f823d3b1d00fb6b3c4d7ad2242074e27038a3dd54c5dd4878a0b1e958a83a35d5d77c2aac3fa3ae85861fedacfe45e382523409eb1be2a973536fa30dc4cd985106faf1c47dfdda7f1b3063549fec84489d0c25343fd42a6216d250564456b87c9010bb67ee8683a037628369421b140bbd3872594402863de50de00ac33b96d23af0b094fd29e8e8927c3900fc0b2cb42a9bc667a9c92b646b3775a014fdce99a8c9938015473005d02277f10407c8eba7553ea1df0da9982007e5ff6559a89adb9e1c932024ed993456294cf84ea56f2465e698e73c0d555ded4329024072d497d223281232c2a782e437cd0d9be557a8d6f13c9851e541d733c1a7abc522c718408c5c118b0c8b4f7d94ab772265ecbced4eb7d17f4b5e9fd01ad3b2753ca40f58fa6d7297f6d6b32d0e2b9b927b0b0e128850e5173d8d52666a11bd21183d498ad140efd44ab777929f834842d0bf1d596508e50ea0b53f88de36922a8421a609e52ad5b69b2a00f4ba5240f34ba41e4a207dd17d28d51a91f9ec090742f42472a71cbc5850904ddbf8403de9c2e8f3e981a0a83ce55b89ef22a4a6b0558f2fe36c3442b2d12ed02d81b934bda2e6880269d44ec321ab5c83725b2b344ad8ed443d7fb3ca2748c67dacfb5087e67dc44f2c850053cf37ca0bc2da6b3a0fc7506309450d2df633a2aa404d9fe268d97966b0208feca337d7134c65f1b2c766ddfc9f65ae2aa929ef83ea23ec483a5649d605be150c50c15bcdbda663bb5d6f5f4831da655bb4168ad180e9697324fae539fdeffc4c2ffe6549f64874af7ae380e9d9d75d9bedde2de3e2a7fc40d8fed32da4c2e65f34c3dfe4b2094ee361fcd271a380cd420f59c1f95b7dbe07671111090b34c26b1189f880d380f52f2f7ec381f683a9f9d69b2b8bea7c7d8a571be77ad63fbd145521c2e320a12ab49d1da20fb47ee7474c1aae01401e82869f062c25abb0a2aa4cbcfe4c939c4083d25c067f322f7bd52e252c899450a19a5a326a16859596c5ab6d4609810569c901b506332fcffabba7c9ed78df6dc3b45d945999528ded5dff7bba96e09810f48e35d5a8ce52da3e9de084dca7408eedc9271bd1cc3438fc7061633384387c7631884963317b68e94f8f65e60c88c51cb9101157e3a8898029dbfc9421f65c1317d964ab3836277ca7c9b5918990b3f614acab0b3390b2dc3d608258f80880028ec0f9e3f499328f5e33de857818f5bb71931f03988ef524382ad9309f3521c8a878725c5dc3279e247298437534b5d4562c8dde263b500ed69a695e9689dd26ff3e366153d3aa88ae4d53cea718f4327f7c98b00f458c7aa4574f98c28b3a02e59fa615dd6209e18c62c4850a38511c0142ba5b981096c1eba0ad32005f7480f72cbc4317133f180ea34f6cd539fb414d265ced655756a88f851d7962fee01ffca2fe42de6b96ed17cedba1bdd295ee38ee54b395fab57a421827b4e018b749f6c3b90a32f68d5171cf84c7453307b35680eeca990c0fb82912f1affad9f1f6701e54c7354c3fb8aa61f9d82aca9c95403eda598f1d021877cea23fe792911ea390ff0b3d499d0e8f76a809e205672bba6799795315ce9ea0e0002b31570d5f3fe6707331385ca81fb804ec633beba044812ddd9d15ab5d871283abfd066b8bf1d39e3dbaeb01e8609c6d081b0b32ad81a1293dcdec30839e0c924f3502731c726c7adb7a2facf61082afafb5b7647fcd9bb4a2fcff7ec2d58cb1a4615dddca2c5f69bd59b640c75d39328b4fa66c31646d4ad25e2b1165c7cbe7f4cd888b0fd24f3c6978478fe3e4b95bb7fe312726f1e1d8119d0a2fd99fa504626cdaa012170e59db6f0b66d663c42bcdc66ff725febd6900a2bd9d63b157b46b73f20f69c7a9ac1b2b367d0ed36d5b22ec0e0eae5389e246764950c8847abf5a921ae8a8ffa7d3af7829f48f0db01fbf833edcdc237ee761578d739dbc79327cf68ec86c2f3a98152b0e988a222600328cc8dc49c769ce8215abab483802eecad981aa296252a37cabc1f79e811f34025e0b62be9d7e4ef5df83e0f8c6cf0c7e4efd9e3e4d00b681dc7d84915aa86bf215b84c74eed567491fa93d6a83f825d6e7c397012382ac24fb8c64fec12c095b0632632ec7a9fe5ffb7321267acbd1472ce79dc3c889cd54c33c69615b7141035f017a9b60317794f03d70e0f2bafc8c116ac19f7102f1c16e8868e0fe37e83ec059785f0bad7b106e33eff28960ee79b19a822f9df67d690d6cbb4cfc6b3004969d702553d23411ed6e1d4124d15f464595f701f6bc363b518b00661ad3e7e08a05a35918f6cec1292c639ddacdc843992a41237cdcb9c50991f6e26e71245ebd88a6bc262f07e5151bf5435bfc89bf781aef726ab0a573395a8a8f1de98ef96c3e180eb45d56ba6d2bccecf2302d5343355b47c7302e1f50538ca05aea7ccd4dfe0681ae2f95373df5b270489a581fb961994fc3cdb7e587985c676af213771e776328f9993ac9abab5069993817b2a627abd000ed8978d1dbf59fabf4ed6b2d1abbb062812be64c0fce481e9302f5c9f785af8b0cbaa181225f44e59e6958be080ecdee84c9b3151023a9705ba89e90d17691adf03278cea2c0f1bb3e0fce475d4ca9212d9de7a6fc3dca8a968fdcaa2a14f5acb74cc2ef4b5ae0eddab67e20680f6f919772b93fbcd06353d18b0c7f0c4d3a4cc08c5ff7547ab6a8d27c9d31d5edca3c06d2ddd59e2412b6aee9d577444767d19ab38790d69d573a03ae9db3481aeca6b0e812a381f36f1b9a054592bd31cb8c76cebe7b88b40e7aad14b99878fbca52267fac8ce702b077beb30520fc267eec724a98fc989f8f4821e1e4f694fc430841f664da40890b661bfb68910fcd1ed57d9aad13f31542cde15b84733a460550dcff02e4a3d514b1fdfc8c6afad6cb29c4fc7abb3a84f27340acb54b4aae2a749bb7615e010a66908326fddc540a1fb001568dd9014a1a9a1c95e069f8ef395973ff2f36050f9a23a4d39d07815c2716f7eaaeb9c5e1b8de6edb991baf9f0b8e484ae72481dc5c4255f47e22bd93202bf2d56a642c869a6e55c304c4f605fc53450f7d204a39fc89f61a1552a42a65b601732e4d85fbff06d62cfcb91c7a579384aae1218685e4805d37d178369d62e3470c9962ce74a53c823ebc04c2288bb0286996a0e721e58a1b8b7e2ba255a6a3a6979aebc296bd9dcf3e9a068bedc785e2188bd3da59dfbd17a40f53c3536da61980a78776e75ce29fac09f023a35a8f0c0fad9dcbc21a0e893ba1b362ea59be62037670d7a97b36a4948ad07e77ad2b9ad369d3ec225baca3ab6be37920e0f1c148657f27f846739ab794e3f38d0371b917f33cd3a6a2e71829fd3df1ef5d835947f06abb07e70062e93d03b23482023751fb1ed631be2d8dfc9281b8c70c35a14109ef2ee833adeab4b903e4ac577c0a39e29e85aa234f610dba038305379d384f9c7f18af9179210f3745a119771a5162296eb4aa9b41f4e45c7cda8353da589b0f19aa4c5a5c114b746f332805351cf1b5c6408d9495e0da80d9b9257ce09dd7dcb6fccc90116042e9cef4d8e2d57c10092994af6c603efcdfcea8decacc94cb89c8c7b6107691ed00fb10d819e00459eb05c9d91bd890f214027f502a99923d4d7f0a42f9adcb73e4fdc5dc6dd0e5ee09400b5d6bd70a5f18c46efbb15ff727d34c91332e4084e487a4928c96d1c783815e51cf9d5a5cb936e3a78322da501fc56216007042bd59ecd85366fbbb46f23fbdc0c156a912f1f756845f3c99f195a2630ce32101eb8c54c3c6f7a43a1bebe8fd7947d97b58993713da382040acd76fc8b8dbc6dabf74a2d924be650caf88ada6ce63b15cddc089be3d0430d8c69fa59e5732e0e607ee66c5610c1812833a68eb2b58d719ab7fd1b51f35f123ff29a3458d03b1ea25890d456c03997c68ee7f74082a4b5f90138f8e0959ea0abd4fe1536a157ee5c04112c2180d6aa6630d91b3e69313d48a37b96bb861bdcb47dfa087672cbd82955851f450d611b345358af6adf278a3fcd6a4c5c49a613c59ab10bc71acc1f582fe319d97ea79c6c63bff59b03364894387b8ebb71adbfc4f1661d49f380269b864da14ee311f064791a5bd457412a5c74852e55c8b672b9845d6bc11190b86aa5ce87f2f8135b2fc7ccc07e9ee68c42d9718a1063a6d64590ed8128c459f1a640107142b90bd2535cfc208d9c88e1665e0356f6bd93ddd0fa51db575c950744b632246ee9e1edfc8d57a7a54601975a55e805bcd6a8854184e9f896aa33b9a15c639a0c4bff0b7e3cc766990d05b6d368179843cde4fca72cd48f5a0f746968176172193d023a95800a9f4baa1658ae249168077fd3e44e5645eed142151a8e8f04b228cf2b4e33eda4ab254a49df0401ca7b8d6d3d9625b3f8d4d0ad6385760e99b8e0830c2741f6620b172b0bd369420e8bba2e78fc2b4008bf3debf546da0f74303bfd4bb22158f55bbcd373fde077129b6cf992c7be6793f930e166b5e0e4db24dfe40169fe3e6c33e0956458c94cfe830ef8b95969a1f79f31c48c1e03f033d2f9ab7687342c06d5579a1e803712a575a65cb1e7a8641835a4887da0b1d649141348fc91bc3287d9290f481a830dfb147fcf079981e927a20af998288b23494742cedaf139b69ca50e1b26d8dabb7ea025cac35e4296641354569bf5a13f3b05f9359ecf72a61103cbccde482fcb8be8141b5d6d4b947801bfc03b45fdad84454ebdeddc0644f1c459b9c74c75ee374cfa3d75135ee9613144607fd29bcf1ae9275926abf6450138325fa48b97ec1f953933499840c870b380a2ccaf02f1d42348ae22f1e3e878cd40309c48eadc19b9bf152c519e250ff45958cfaa16396026587a03bceca9597d86e29ed5a0a31dcc3ac191cb34d4781a937bc42acac9d13ca9d912382fa05ab50f8740ac4b952a849ee015f567202598e6c16b0afd20da37bacb85c8f2884de2a5b8124aef18b595830b8d24654e9679dbc854cb7658f0b30e74d64ed933f50cbdf65315daee5d2c6e9ba009f62add6f0d83ee90a6c1bbc384329db4e37bac6a0ddd69a7b6ae3d828e8d3852659af41d1a55936cffa50b56767f2a53ea70da61d1053dd3d6d5c8809adcc0057428ca13180039879e0bbd5e86b6d2f5352796a165b78ba6ae10b5fb0ef0bd3fc16e76bcae5d93ce44b4caa381c0857a785e1cdfe12e6dd14546968cf61be187fa7289a8171bb34b01c81abc9d51789a2650952843dc136088f249e925e21bcb94cec639100a8015fb21b48cb8ab65a5dffc352605c52eee58ed3f881126cf16f5e5b769fb81e050ad2bf100198106a42a576dd13a71e631ced34d2b9c4b11919ff1e9ffd98436638e9c897429c280f9660d0aa004b5b73ba27e0d941d948ded4712383d67f1e0406f479e32ee8b92d187c855cc6773b619523edf5c3a7f94c5684d6db97a6c3cc0a88a0b83c3332ddc9bc3559df761480c29af53b8e142c5faf378f6c9b371d28db6ad4d9af88b9904c1b2ea097f8efaee362cef38687364e1e1b12b1096587384428ee446a86f0915e20f7fbc36dae1b0adf2152e21034b093afcd7638682054c15921b8f4998b1234b307f285edcf06f983f3767b318513a260e450819f3e35c37cd0f463be996bdd917daf907542d96781eaa0a3c2b03b2d399ee62ad10cf3853cb7d527968caba41df3926b6b51c6dc7e94069f1a2be51a7251ef679bc1c573f9d48daba79f9c9c81f00aeb9a63b1784fd7749f5bd072f717717842c00a2d27df5cc386039500b843a8196fdcc10a93bf49d70598fae439564cf75b90495cd35b5cd4eeb1be1e643ab2eb02786d67fc0c9ec8c7b1c6a185929977c82b2e5e6cf8199cd61fbc26aacb9532cc03ec74e6c4654f80ca81e106ad77e348b19477b2ed33988efbb9d0c806c92912595ccd1c3ddda8bf5bb9f2d1be2ccd26942fae1ac0cfefaf9338462ccc1b2c9d3a6d89ed4d233f289f3e510417cdcf77e6b739197b9c2743e7231b23ff77862da1787eaba1c73fec7e85e69b463d1dd5daf0df718be9be8b5816af70ee59b9113e939a33a5039de4147afef11fd8af718ff29ef8e3babf56ab716b09fa212bbddfffd5383162503d5ab4695bd1710839b0248af91d29c104c91ffd789bf0bbe19ace132bfd93d9e2f281be444e787db7c381e9eaf665cf89fd02c7714c93dc979117762f70b579ba02d4f9cd14089e68d993aa5bf412a9f78f1722be3ac9a53d506f14b94544a1b154f7c10c31ec72902e0992d8dd674b099db146fb21918f194f8d4e18f7acd6d1be4f5404fbf5929bb7f69bee9cc360ef838e84f61fe0824121b0b598c66fe1c27e654c83f91cc938cd24484fa6fa565164920fc3df34b6281733955e6250b98fe9047e942eb3dfb03586823b6d70c90ab8d5db4dd7342aa37f7de9938e6fd091c7e1fd4d0dabdcd9eb75348c4505ac746abf4110bf691f60af066f366ac4d676650c65adbdd85730afbdc1789cba426a4dd1ca3aa80ad8fd445656d450afdef8c8cd8dc70f2ea03d4cdd41355962885512d9feb017477e5e87235123384f5c6045e0514d8634a695f0d0d34c8973f62d3fc9907347e12b8fcf075204cce67d18d2833fd98457dbbc1708ba5bb86fa4dff738913c518040e8154d7e00abc762addb73d415e7da7882f87f990fb46be85de89f6dbe884cbd1b98f44e57e6644a4c7d6886816b1f4b305a321f9e373c7b68a445867a084e6005a48d1aeb609731d4c018b67c0ebfff74acb7fdc72a7520dae261bff231050de113e36bbe7d97a5b392ba9cf0b40847827ec9bfffec77a651675c1a605e09def643dac19d35b5406df748154ef3ab5ee34651c9b58f2374221d190d2fd4be9ea6f4f0613b80dc06d963662ca9a98687022f35102eacfb98d7a6ea4613713a741830de924e42e2aff66550288abe53dc4d1c298f9f63a8b7df500fcd4a77bb3a8cf348ccd0f9a8c3abf5709174434a630409115ca49e645bbc71327527f80370047dc6ffcae0125cac87bbd20c21901f57f4ccbafd50dcbcbf1bf099a22548665ed1b8cba8b25b157fc0001327b03871e5f5cdd06358bd40fdec363de36caf79f56a6427f623412f99e3708f60de5d423cfb65aa28659d7e6fa770ce8a02277c23c03d26f81982edb48d650f6d3d21b9d98d4f2d23330a15ccfab40634669b72c9188f7ccae03b9e6d2254418c0b0147adb2813ffb340eb41ead985e5fe9ce27d5a3bf1daab2bd8ed66c4615b8dfc8a3d02b380899fa350d5643dc1749f09455e8e8fcd1e1b38df33cfb13ed2231f2aa5927bd35cfe64acb27436fd264a69a9cca2371f975cbc855165ffeec71e2536a439a70c094c41ad3f49aa84a0b3835f48a16b8ca04af9fcd8b86db869fc6d0778ec16cf7721c7e140cc0a5a4c10b14ffa39a24d08d7e142b2d9d866f019ce800c1f498e2d1eec5193dca70b17bc036856a4e352c2d9e442f1e255702cc4d8534c5f69e16bcf1ceea6d28b48daae6035d9145b5004222e3fe9a95f2a10bbefbc766f0640a7d15e761ddaa7c587db5e7ded3032fa1c452ea69473d1012571e14125a178fb2d38793bbc875a5f009ee053eea82ea843b86840d4dd2d06dcfc4194bfb2228023d0108df377f0d9925dae2d66b2e2b60b8c7ff41c07f9a08b5dd230d7fc534e1c550f6c06bad34f840cb50b1ecb9e2e40875a6e11899eb1d6ba860bef6ca38d80719f8bfc05ea317bd9e5cf6796d8e928711cc9b481646407e62d2a714f342496bfb5ab8a84f8a53267840d5d7f59599dee7b42254f6cae34c05917d4041a90727f627ad76f67d1bdce6a2cb86bb9f45a18f53dd131654a02df582396db76fccda3bd82691263f6991652b1b5c6504e48565bf24d599b692142dffe7a23ef28f32a6eeca1b8eb2a7366bd83e48c1b9069b3cfe25ac8baa1020680396a8c2c3dfb3102252722ceab6234176c31f66404ca0644677a003fb389923288ff4b0995567a440271e6bbba5cc3755d6b7237e43d74f2b288bcab37850c13e0691e722a5e7ad671d4bad54f67f5ba9bf458ad2c0064aaa308c7a2a2460b6c13fe3b815f30a938c14db1ce14c6879cb0cb3f8619025a2e64e2ffd35f57a9aa41e2cf367c0b426d4c064206a49948779c591d7222787c4f77d933b6de86bb2416b682333251eed9bfb9e28894acb5adc4cdfdfa21666c3ba6cc918de115c5d9cf9dfa58f75078efb9af424f4f6d11bc1ab904e53612a6d8faa747d13ac242c8d1eed729e0e555e8a371d7c82490adccda224ea97cb0eb729fdb99400487eac5e44a4b3f523d27213834aad90c5911624ac8779d8e3714ac5de77eda6d32bae8b0a15e3babba4fe0413a497f78b8e2ad30f8783a8cc629214c5518e5263fc1e78e8060024219a0f61a6f63c76506d06d2e7e03776fb08de1308400e2df87f84583af6dc49aa1f2fa7bda8406f619fca465bb2ea3a05fbf923347e3a89b3c75560174ef1b3283458ef632759e3bfef606095b4a10a1ee8b957894468454847dabe0f46e4f127dfd2789a41e76d53171307e082abd61cce16e5e5fab3428d6f2f18489c13d4f39a83595d215cd4b95d5bd19509a2ad57956f5f0eb5cb789d7e5db8adcf1f647f76b5764490cef10367b04e89b0cf12ee8273b993e189809fcf6b0b09ef9f77a08bc8819ddb66048540683dcc17f4b21d303b6d1f4737d65349dfe8635bef550cf53153c88b46200797c2ce82fc09f9d9b618278e02030bbc80b20a18ac8750d43dcbf509a58e3dfca54eb3dc953ef8088ada3e54da5b434261778b42f62a1df1dd042b2f2fb93800c874b47dcfecaebfb5b75b3a1b5c7cb6f8fcbca7a643acb7759ae9cfa2a275534ebb20856782c213c20534f60afd63bee6c66954e6a4fb1cb713b82d4607fe2f670e2a5e3eddd72e799b9190290dc37c2c91cc4f790e89dfb478d836ee327bc94938fe2b77646d19f28b9cfef0c10e70df0e8428b2d86a01b34d913168afe51ae3dbca3ece06cfafe1c2676b06802f94ffefbdefb72f84717f9376dd3af595af9ed62ecc51ea316ce33bdbf4308024d4dd14bb0f304d4fb0c1ae001bfd918e7c886864f0184a99a74396b2c843acad43b1fa7523440d7d3c3c8632f390820a2acc247bcbcaa985d89b6cd07cdba8c2f12e29ff14778059e6acf2ee56410c7cf8cb325473b4cdbf245c78ba63f7021cfec921bdc333720560cd24cc9c2198033ae24b6768a70f147d07b1480ba3d71764c3be6db0386b28d4c4cefb46e21eacf39564e96ab6911002917e24b2d8eaf9192fb3d75393c5943cbd677acbd95ad617673fb4b4fb90b0b676146749aa24b4c326c347c1ce7306a425bbf435c162a16d2eaf62ddf965b42e7c83c6402e478387dff08805abb81dc02214fa875528172665f619841738cb443b067c48f7de220537b59fec0142f926fb2634b7be53308fa5eb3e7141ba7f8980c0b3e711aaa7c715da7c3a9d969ff50646af4ef44f18bce97d274db6fe2ddb6b7a33059da1cf8bc954829f28f0b38c43058c17314a5eb249cff7a4f492edd7b2a7582232aac3568c70e1a93ce6ed3992af4782e7f5d43a5e2a7ad6a694e2fe428f30cf05a7c5c70511e2e295964611b7945bb27a99a5e5cf4150ebb3e3e18a0a9eb0eb79337ca04a4826e35a0dde06438eb12dd86a3e102cfe4fd90152aa39d35a074ebae090578e3b70234734b83774434d295e2a366782b87900233d1f0b7a72a4df259ef74665937472249ab6ee9e8816fd09471704215cab868fdaa67874a08417da986771d5d73ee9a26f9e25b24c93b943ac3c93a43074fe7d155e9f3efb81e8b393eef2383bfd4e28329d927edae7789aa5c0cc337479d03ad5edb14246bb84a37350633ed96a6ebaf1fbae9385698758ccb39507fef36547977226f17e534ef418d456c6829cf7ef1380dcf807d1b7d7509ac12827bbd2a4f800b1510483f88959953895ada365497d6a2606d16b8f14837d2dcb902a705e8c9bb7e3fb15aa93dca975a1039de38f844bd66e1dd93a2aa6934194345b2dd0671da0db59e13a6078fde586f16fd3563c23db4e7002654dd3eccef59e007c015c7361fa5be612db4bb0edf42574062535fe94bcfb682dbdf7b694f7661f1468803a6778edd5f501ccd4863ebe6fcf3c062cd609389fcad86728d19e54c929167284c6bfe943628cc298ced58974ff2ff5a7aba596cfdd6b10f956e06063fe8fe5e73b0019b30fac6b31af25ffa385c13eba6d5a46e376c597a7c1dafc5b401058fb3ba0c2fadad69a5d42235fd8b15dcddb8c1a63e8088b5d2c96925e678ff61a5ca7054f43ef55b67dde68514410a478f4e7ef1b1bfc0ffc4af6d4685b8f319de26f01bf4003ac432b925c696e1407bfcb54ab1e401042834516e423e40bdcacbb262e4146c81a1f471ef99f9322b00d474b7a77438956aff43000eb91d0dcdbbb9a085dbbc9bc32cb172ba4c287b9730e432d8b60d497e170c70b79ecc71fde2b67e562da6e8c7a4fab13a47a3f9b2f6915e6832ba4b0e88a64c27ece22f9bf7396ab73cb98fbf6fbf987f921ef78646c1c2e0c9ea4e4c6a6776ea92dfda56bd88e91d25e4ab5980df09da9e75b90d1341d9ac605857c1715a21788b1ba09ada251cb753c8c4a2942c8bc1638c29b1f84b736b5180c1ab8f2d0d36f0bcadbb4e1a2cd30d57e7d3296ef8881d6e7a0d7e632f3880f9be68ae1596b910cd28f7f1dc4ee7d49c597655048925b984b8f65f05c39117f7625727f2ee7a39d11e6e94d61baa1df5a8103b5d5e9a934c43564475bb393cfcc418c1490c0e40de059c1003000b7ef50fed3e43f7c64a249b251c6dad6e38752bce5d616b18f4fc4464d80005fc8e51722a79c0d1648c22ae5b4c2f9e4685c9fc0167339b5a4c5aeacc8ae116f8d245a413ba599873b063520928e868b439b58fb7ebba35e71ad030fdac23720ceb92c1526965f659199ab19f02be87e35e2e0d4c21dd6fedb44e08a7a16c287c3e1662a7d4d90bdf631164e9e02eaa95fa7ca7bd4b0da94c80511f0ee8ece7ee074eb93653296b8148940c2bb2bc5ed811624508df5800477814d55265e6f21765f9f941db05ac8e082e4dbffbcb49f5112fb49659cf8abc6bda59782547a5e307a67f1e3f4a75a5dd5cd5f30298a11ec42441ef38eb353383b0a2852544b2e7d294a744faba158e85aef5cca3e72d0bce838acdf0689e46a2de1686b2dfa747f54939a541c8bd21f90aeaceebe1d00788ec63c358652dd750960e606c2462b39f1742ad82a261e0069b4e2970f8fb918e8514b1452430dc5de59576ea80668fe23a03e3e714ca284208cd8f8f1c8e03a07dd3a32dfe70787ea68defd273207c4fb839266cc551cac9bf0bd101181a3aab6d1c7bba2252e08adbfa1d033304e5f3e0a41ecd162546a0da1c17d45bdc142a2f2ebc5a3d517ecb8e2c2c0884b4c0f67e8ecb866bc78bf37e228be0b5f75387b56d1966b17d43c46432ef63e4c62ed2e3f0fcbdc5c46a10575bb14fafe7f61df757d14faf3f496729300ac9ccd03eacc210c0c88ff3a7359b6dc1771930599635fa815506f7e8bea00bec452038259b793708037d8305a6652cc48b98dd70ce27b5cf54249567593fe53c105fe48333a60be9842220a2c5e5853b774d4d6feccbc764abce66a87a10d6067ec51de20bce9ec7928fd3aa646d496964eeb07411b9805deaef59790419b3bea9f222d8de120ced514e607b86b29b5bf4af1a8547f7d2b03a2dd4836547e4a2838b391c575905f2d8e28877ee736f5b417b76700cbfeeb76fcf7b414fd25120c61fd610766fcfc071859bedd7c740f3f5ac10ee2a01d0d369f6442a1a6a5b3475d396413757d22c69a0f2fc5a80f5787678b7c0af98b8dbf68ad1993537a6904d9efff25a340207030a2f09661bebf695c5f1559080ffe324cbd68356dac15f5898117e87c76446aead71a3ec3c3a4f60a9b7bf7a58dbef39abbc0492c29a63da18346b74c6366a6b83cffd63785531c8b447acb77595bff25ce800d217aa53ff81f485c02a90a78dc893c12b38b69b8244c5bc8518c18b3d9be2628425d22d8796e5dcaf44b67f078882098a080902485d4e71af9fb4baa980d01903f3536412ab33534f41af1523008cabb01c0d6569381d55e69c93d7c814511b32cadd23230be1a012e07fafca65c97c8c7206a3682086b9a076eed2edb078e80c34c03039aac9eedb2527fcc2e4c9d3edc31630948ee4d3c68addce85d758bb3a54f43901370393504e834f30f5cb87c4e7432dc125df229cb25052356fcecff6f40bb0cf2190816ee77692a04c3c5723e382fb1cbf3cbd0f098683605641cd4c7bc55062339a4148efae48e835ce2ef3384cb830946929d0fe49db19483be983b9f0cd1d345b8dd5231de6271f6056d9fd7a115b59a268f32c7a0c7218cb4f6d0c0e81048295b778622c4025205b9bafe21e4e8be2d8792b07d4c75421cddba1fe7f75ea1f021a5cb7917558a2213d20252bfed6c7268e805cc7c53b64ac5f248e4b41a9cda510c418872e66d9e71b2f330195ecfae664306e8bd6a119da79319373210699f74458179b62ba38c10a974be8849ce0f09a43487650ffada056f2698b5a4d7cd3224665e06db7efa26e9a0b03f7a0c3db677950a1f82b787491a81b470efd28fa574c48431dc4d43caa7360185104422f49d1aa2a4db02ebea06941e843556324af9cd2f4e7a08b18d86e8c8169bff4bb3e8828e0219de85d50b046ed2507b06a92cc152c79353cbe5e21613e459c8635b13a6e40e12b48dab048607523ddd60df8f2232576e1a6119e24ca3a424f812bbe2e21175f0245f27e1d99ecf411ea74f1aa9f455abbec2b19c4a21826a69a113b1613cb0e10de74bdc8f8445c84ea533f6fc204daabf578ee9e22da6025732f8cd75a3f47e029fa42c29f10e6fd3cadf9ee966665ff0b00512404b9d1ea8c0580958a58740c7247ef3cd627e6867a2ba57c2379e8f8903fc7128b4838b46f99a64e3db62e63306da6cc7527d1e2a4dac90b190dca7db5ec4aa0080e538dea15fce832fe5e9b51e8f0ace5ae6aedd829427bb5b135e9b0508db25f1578c4f433a3a6ed7370ac8a23d63f8ec5f04dd105374b599054fb8dda292a431504e1f36600fe6bbc3e2eba31ae21b6ddadf0f53f4c3d1ce21ef463db2614c44050cdae7dc099de04581a8047f6ee41fa8141baec138fec207b698ab77bae87d3ce950d5541c8953512c76313f890e0c7bd84c12e2c5836bf18a9289dfdc33865a7ccedc6d3f7949a9e7fa5e589580e8395d04ab1edf7e323191f1830e9fd13fae8738efbf02eea09b46dfdf2bf47f3d9b346cf8fec3e35d7204f72bcfbd1605b62e82db46eeea6c315b594db0e7ed3fc646bb86360cd8ad002e2a7da2ca8d7506f400d1f0951cfd6b9a6ceb83ea63e9fee48a549721a3a307392f4120e8b399f995051b5e74a99f3f5574604c7a328aaae50e1247650e025486c5599606e79658bb08407a465509a12b0de4f98c688c2ed939ccefcca7decd027bf9dbf350f0fbe82002c474a213c699f94a3aa0deddfe206693fed5314801105c84e0e5824ef252df49b80e82512ec6bc8925356f9ac56b640e88ff42c2536346a2ccaa231b7710ed10ad791b17c108f8ce6a52d7d3dc0d96f147b0d9a33a77193a3e5f0dfd040bef540e551b113b102a90ea7495c633e15d6df27c1cf06305076e98ca1a79603b415454e5e905c8c1796e08cbb2b2274d8dbff7d8bc5ca3553f9794d3e354696b4cfde599916fc2a2705f5818a9dad312311bdf96f596e7fd192bdfab63be19ecc60ce6b7a657566b6702334943bf2a63f8ccd54527289f60c6d0ee71b47a28d40df8569968eecb2f55bb89d92c9bb8f99aa883f59e71ecc6eb030b874d8dc5223e86ad6568b8572f4c30078fa9cb50dedc87866e09df01766c3ebf414f3ed7a8822561344ee9994eb5e3fabf823505821227d7d365a6549c09a21d1cd8012666d9fad1adc04ac0ee4e1e7570610b3b18426ab4ac785438b3502648378606a2775ee432400b9c934c9d021a333ac0f85ae5f6ed59654325b6821826753e9fae7edf16bf098c39600d38de1d16c3ae58ea3fe34732a1233d57f90ed623c6278952c93fd5596820b40b4347268533b8e22dc5acacbe15a203e7cf94a0c1de35c2a99cf4edd2b6f8f61cf995296609b0c2f132627afc399dae28b0b79a0e4c774948e8e5790e225e2fb91a58a829e9d7361a5775f5c01b30a411b539e944ce3976432c15e7fd9307574a334cd73ec5bfe14afd4f93dd7dc6006719adc81f4184da44d3a0525639997be14a14f9f0040a504eed6ee584550f508883728dfda8c9dc7c07df0596c111426ab649ed001a935afc8c8654e4d93a8dcd43074268410c84507e246532fa4bdc1f4a83ead4147886a4947f90830279a3d54da132dcaf7496f0a0148fa74b1ad6f77e3af772f013146d07d4d752d933db0ea0d2b0f7a850619c60cfe9f3a435685b52691f56f38a66d8c10a4cd13d8aa776625e18d09daae41678923a5cb383f9e3e110ece1120d5d764e192506ce5d6ba55def4204524a475fc74929463ee15a9708d69662aabaca4d80523e989862313a5dd155563f4a29a1ce83c95e7bb91742403ea105849cee6768b6b94be5b26f5aabf06bfda27acd5b88b5a104962e78c504fa9878c298ac373fb16a544bf105a589f88f725edadafb9c9c9289c69f67a79ab3936491c0220bb2777177401ba9410438b943fe7a505f7c8452d9eaeff9d289f8295da4a28b6d5113d052af32590e3f4d40f451514fd929dfcf8c70435d5c4cd3cd4a2ca6f132aae9f3c9798353420de26ca384d24950fc46d7df56c48d83dcb3958a71b6f6d2d8f7cc33e5ea54bacd42afb29d8bdcf7e25aef13ae3f46987a3f8b12944818bbd781eee536be16e4d68359405d26a7d6bdd814afc691b755cc50a418bbc3051478c0460f504f6daf21f1d4ef209818bcf4c0ec487a84b7b3e153d28a03ce184d29b1e2aeb62f437ca2539a21b4e015ad5c51c17576f141fb489c54a2abce29abfdf1f69600ce0729f8fa715288eaed75de30f14bae2112160ca212ef8c1290077dde38","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
