<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41c6489a2c02c412e34bb91c8451f6984b6d6b15e63388f7e669d8b7c19eeb3fe45cc32f21bab1e06373d3eef166693fbfb716839fe440c5251c2e882b0f2ec851912926b85921e4c5d41823cc409cd92c55bc742aff6828d8851df0fa4a139ca1e659ea47c1c281ad976fcae8eb2c1e3e1c55b6219731740bd937a16f9e1ecf6d6ceef0bc05dab0a5fade5fd8a8abec7f6ae607c50f7b4dac1dff3079570ebffaf53708b492c6fe7dafe4d7ffd211dec9d2e140baee63f40085436b001da6e9c4aab5799e41ea32f564dcbc38c037a3fd678050fa7f026a84d75e739175efd6736ef6ff3e0aa0bd0d9455754f11461f92f0bbd458948d7489e18d238f587f2e3f10810849065006ea9c037f7fefb73a262940f47f1e6f94c7aec760e2375a702571716a113e5afeb454578424fac8b25e2b3633f2f7655504e0881cc396488e446efdfaeeeeebcae600bb3cea8e6e54fa124bffc5ee197d353c9c63663905f23a7356fba7fbaafeebcf934d1433df7d5efbe304fa9b58f40d86b8c54fceecf74ee306758832e8b4b033fb0d8f45a8599c48f4a432ae8fd18920514effd26260d6f2c8fd46b24e30cd2e32915a94a2199a370f613397e8728980030219d4548f43d0e21d8b17cdab00a6d9c51b9cd0a1790f1742f26d92941fd8ed08d734ea927acea7f518a875f190b9b171c0eb75c5afdc89c2322938d067bcdda901d8d8c389ded9d28118cd8287d7d131f7780eb3d78deeba49ef0d31aa8443cdfd703d7a4c45faa8a6676d89764e65583fa898b0d7399ade4d265b2e2435e2362ecad8bf67851384b4f44762761886f07e2abdc81fd7cfcb201421dc7f08de6905bb3611ce9ba84c7038348844d9dd4adfd6bc7b0bd670dfcf46e1b1216041b58f3a551decebe5019bb8a7bcccfca9e1b23765c8fa9a2bb9ef6e9ddedb3422c78022dbf5dfc108440217ff4641683f05ed1101a5e5d0ee027f4879bae3ebf7abd763d553a273fea508cecd439b19bf05d4040c29015ea0188b720adfbb72785b5113aa6be5b9b951ed1c1362369cc611cbe6b4ff17e9773a152975f93c3932c8f725c9233b375449d7f548410d903faa83da6737967d1829fe3f7fdf2fb17b220b1ea1726a25ef2c37f60289f6fdfcc79a1caa5ca17dc6e92bacc329b6b3d1bda0d221889ddbed3079a2c96d37d61b692560e6d6ade2957b24507984a30dc3b63dd4cbf7caf77cae4079984f35e14261e5cd24cd081b253c906faf334c00e8b13b935b8ddcee3900e41b6340bbdd8c5ab41113e08a5db783596c455662a5ed3d52e55cb5ef36adccf40d858f0915a9ced142cbd24e82ad1309452bc867454158a399681c13db921e056278d2341b24f1cee9f62126e68cf73c762e875b5bc42c37e8c2601896880dc8b224c9373e6b48de661b67a0bd96a7b652ba78d67469c6bbc0844ae6edf494c63797684399e8013b3474a6d0a40106283616342a3be99db74c1894115fa3a35a8d4a9affdfb0fa6a4aaaf0e116c4fc1d37b36ece4232f67884660a8b478047c029b7a48900c425e3f4f6ef68811910b420478a2aa9404e45a8686fb302e7870054f082af284af5837d9cd0adcfb20f9095f0164af15e2b85925a3b6fbade2117fe1f6ba52c66f89d1da46bb204c6cb5da8a90a8a3a73637ea6a071062bea17e232ddf825fef7ed3ab870d1c6a0231e3e823c852265c9914a62c38aa479000446fad74dfed560e573708c092528c4e8ec95bdc459d54a3452de98c453a677bad55ee1e13b95f9b30e2e523e100e5d4f3eec281fb42e39e3fa3fa87b08c5489b9bf46347d8fc6c7f5389b88c6b6a5d5d580fffd7b843ab441f8707bbd13ab414395a2b8758656a6ce36151f927a7ebb3f4ec87882121e02bc869fa7cf124ba49a9c1719132b204b90e3ea306c8449432fbbcf666af23f0a55ea50503cc480a46f58584517bc897e8303a92fa66e5981aeb68adbc4dd09cdf67f6fb3f6fa484751160d0fa684823640fb377414a6d35f4056176f8493c7b3c11aecadf43bd78072093b1c005a32e6add86510c76e11425e16f50fc6eb65573122dd298b94b9f0fc41e1a1f6972abfcdaa74f83b6f3e7ccff7ad459cfc306cfe7c31081ecdfe51dfec4fefa5dbb380d5e5eee5677eea1b81e09ff6436f9df631f60033ecfef7bfc5426dac19413a0faad4131ee4d6cf4f93a9c84ebf1f2eca1c8c4842c21ff0f2ab84f76c7f9ae65e9672bbd586df9a253e2cab4b7f92a6069dbd483fbc50f04f67d1eae5f9cd86e97e2bf0655872375013d04c0eab946fee4a1f3ec7c20b6fd15d92f576722c7bc63620ef4983d0962081b9322dbcff09215171081bab2e38468984f0c2c8ba389139acc5df8e3b0603f9d23ca1709d8abe6f623a744d5660fcfcd8af10a00098d36e432196767f35c27c82ce04f913a0ae5c865c541beaf92c7f6c6a5b0be8df07fceb9ff8f095c880ac3d42ec3b0703b99162e678be5633f9caa5a4375b138480d6efb1308b34015463ccbf21872e215358ba0b171e79d66669eafafeed6b54e55b809372479fa476f1498f05e12a9a53df29af6cfe6107b9455c40e3fbfdd302a6181349fbe2046a056432deb4ecbf744deb7316774e51a17c0cca91bf969a1eb5237abbc2e5b0d37d72a21f207477cce72a97c7efecb52b9c5bed975b8f2434c328783f58642855d31d61faecf9ef15e03d91415a496e058e900bf72739fa76e9619a0aeec560448fe8dbf6c80f778a38619eea0b6d71e7880818fa2b9bfeb7a73f0bfe8b6e9aeda010ed5f3362a6b322c4f2125f1f7312f0aa6b4ce21b0f1363fca9ca08f36bb4c125269eeed0a2f8bcfbb98ea403f10204205c9651908f0d88c76cb5ddfed836b279a344d97a1cd4e00d90b740069c97bb5870ad6d8646d578072c10221fa02052523db619895bf5a0a51b742ac36788426c965997933cbd3a5c0411aafba8537e551b09ffb64afcc17f8a31f64770f44fa0a8dd5fa36b41d9471dec1e749f1342bb1d9752ca36e9ad2be26ec2a490d6bfaff689e92b06e1ef4b6a8c6f1847cc17a94eb5fbbcd0c373c2d46e36d01f94d14fabb43f87016d1104d1720ef7fc55af4d0bc5e724b74cfa5b5657861238d6b4bcf6acd8e8d78141ed4a6c84d28ec74c2d8d70a8c9040366eee9fd263da6a99e2ba478fb4d2cd0b05e4dc32a3ea28ae6adf13bf666ebb8c6b7e9805386412e32b5620069f7972e55ca1803f6ec3cc402b58774dde72e4ec857cd5f33d22bb9bdd0e8a7b055080032788c8b6a419e6b314a6ee2c65f2c618b56ffa47d610c3b6110bbaf3ec6f09f9b6a1c9eec7b5b2d70dbfa56042c694ca1dc75506f614fcf9e9947a1cf9d072c6f8f5bb44821647ecf341c078f62864aa0fbedb6b673d9a81903cd2aa4e03c720b9141efb9ec59da37aeac82efa3bfc55202bbb40f2aa6d3b939499265f12eeb13e80e4a10a5285998e4910b071242283c90419d0b808db99af24a935567a92f4290d4288dfb3251747084080a99f100f0f233f5370fa8fdb3f6d9e2493a360cbd45db7c049915f69b40b6793d7eaac7eb330e33336cfe4d8e70c6d0aa23cdc925120ede78be4369870379855808a4bb7156470c17f73ad5312ea403338437b2751424bb2db5c48358953431e69856d866bff76e9786da2f118c9716157116a40d85cb97864d1ff2875110ed737d772e5d8db011d9413ff9ae0c6409b33da12773d2d9d0bcb85b56625862ebd9ad85f2cba392c037dc79c2c0b12bf1746239dff1f634a64a63e3600a218f8e19f3311889ab966a028d208709f193a26e025ce3c7205be2d91119425fdae8d9c49fda464b144cd016dec18772d1fb10d0b27c13298215a069e0b9c15bcb8969c17fe90ccdaa6b2b9c9fc0f5af974c487a571b5bcbddf6db88bef361b06be59c9dd6dfff8c72c138a3d905b3dc35c071fbcd26f41f71a304e10f745b6934a17d6a06c143ef735d89d25ae8dcd8299d4665e64f906d70b0f9b9654cd851f207cf0439d34a3b14e9394a26b89a0bf6755cb0375a60265ee088b1620590bd2cef93f5152c82065be5233ce1a12b4aa6646f6258d2ad2b357582506ad5cee8b37398af857d32d0eb186ce4b62ceb7ca00ad1530f0fb4b311b92b38ea260cb4481a877797242368376bfbd2b6ea0fd13d93d2009239d8add3fcecc0af5d26e53376760ae13ca344cdc2c259ea7becc841e20ec29e68ade1d69308b23f8514d164c87f479015247dace00ba4497cc2fad22b6710c8392a58e6aa7e1a4d4422d827e4086d957c6235620a960164c2c6642953b45155a2f708dd325dfa44c33c4b01b3b3d5ac447df20100f0215a4ada41a43fc970800a10bae5f0ab097a3309724dac77dca31411229463aeb085ebdf3f6a0fb30bbacfdf415a91377c1326abdfd342560fc10585654f3c99296a85c9b69a2bc34dd7628d6c6cf6422f521fc6b3e23d587e6e246f2fa7a78c35c9f26124b9d6f0272055c3146a3b7fc8ea79596a0c4d778277e289c3bc19ebb5fbda0b17f4fd7a3731be91f9ed920118c6227fde8934766ff9fe0b4e538d217652d39aa77cfb604eeb5f42f4a8c4158fdb7cce3b7a42e1e77e3eb83931e1cf557a6f3359c15cfb28ffd22f44080a3fcf7e69550e15f7bac2aabece2a6b1df38e8f425e1ad7113cccd7964a6b96c31178bc737b2b4eb84e8b644abb0a5b1585cd4ed33ca02846ec83529fdd034b02a26473e1eec77bc41c32dcc83c6e13d31ede60a8eadf74eb20a37b1932d3290d31254d35b9e46956bb1412096c168ac20e59174742d67a2c42e9702fb043c0a9194dbc3d32299c25b00b5e40a594234ddb6669a6f1f936cb9aac94e7ae4b2969169bf251abdfc073fd801c6287dbf8fd66b8328865f062659c097ec3ed14ee3c9dd9d9246e6f60f6675d7b07ec30d3869c1e7c667ccd38a0630221bd62dc18bdb84a94603251934f9948b1c60b891dde15692404f2ae3bb55f69ced554ebf6fa287fd356e9d7f780c58aec55d500036cb247adb1473344c472d9c37899acf7246ecb9a40ca0990bb3510f6b3dddc9c460ac372d616a4f572ce796fdb4eb45d67f9fba17dd2d60399d2d977741f0205c478d8618d79424af02b317e43cbd982ba375ef9f5648cd139211613c34cbf5442d87324bdf0207d8a0a14f30d57359021593b91d5176f62d28cc47cbdeeac1e6cb9cf88c707d056ab8454acabbb4f63809b58db5c6fbd297cf2b27b9431fe130d65c748ebc7ac5d608124b6bc74fbbd1870105147198bb094dd3176f8427c3637d349ff2a65b9caa703a739109874389a0c0878af592f449833ac9583085d63c785cfce4c85e6c67028cdc8fd90058c089cb265a6715835a6c703c70f54352f9df319d0a53f25068339729b544b461a2be73bbd3e44dcbc83fdcbbd559ca906b71e03b56c2ddcf43822420091d567aecaa1873928fdbfa738387cd5d8a0dcc9b807a31e6be5c810107b89c95781fa704469f3f47731563b31123666227e8acc81414c5a11f83c0c3ee015dbda158c289798a6484a38d25a3c48f3154a8038b702409029337b521c626a0346078396e4456be8f33bf26cba15e6289d6f92c5fbe1e30f888dbbfeb3aa4f828be6beaa1dd06854d652d47241429064a463825108c777995a1c9dba1011eedc4eb1354700a45e4e7f92136aee7bbfa485f5aee80d6ea9d67a86ade6cb729d1c26762a8ce42a7ab4f0d3a9b279e9e87af80d38ecbfb16c9c81fe4901d737f13c44d739a1b92f51cad70e655ed4a48af4c0b828f10c6edd523323050d454686f4417f4cd76800827147282ac7bcc0c23385eca8c19315a6ae34e236e90d9897d14f1471b98a2edc00f999c95356ce678942329ccf8445f1bf8a7733ed2b69e8d968063346445ec002ea379dae077f68c575090a4874558cd2aecaef6b97c43cdfabbcbbcf01799b5f72665cabd6a8f0c7f907414576f953d5c6604fbfc9e0ea8c46a8237d152ef98821471a3d9bbbc3f02e8ab12dab451aa6cd5095b13df073e05827ceee41512d0a9862f135f239169c99563d8bb00dc4ff4b78cce8fa0a1fb5ecda036ccdd69cf016865fc31354746258970d00d66b3ceebaa4deb5a6334999350e60840f3652987fb914ffef6178bef85ddf161917800151e87c5d27cb32e1751849eefd6ff3b246a961339069dffa90f820cf5a2ef2e34ed2337e2fae65908fa63b1a2e7c0b78f17fb8b996d802dc087546662f2c24e8204013bdb4cf1cf91c3097afcdfd5effc2cd6ff4ab073698925843b3211c6a52b222133ed535f8fe3a3fe784892bda572a6e2301fd72a74a12a5b0e3ed0a4e3713de52d07a794d88d9d66bfbe678b1cec13114289f6f88956dec8815e45e6d2b015c39581c90aea777bf5447742891d415b00c8e3316cd479d1b6447387fdc53ea1fce9ae08701716eeef27faeb4cde7ffd59310d51c17a6c7b845466da6a4d92f394580f521901fa85abdea7ae3a6d1a27fe84e26a9d13e6e441077c3d55d656bf0abdb932aaf8dfe22e5d517dbf0db91288b31258df211c72c4ae7c275a0275ec88bbb9ee3f61ca939178d0be3fbc5aee45fcf80ad0250736cb0c7b0340b1ea7d9ca925589b21056dc12f3ced763aa1f105580f2881c26e16ba407554b4055875e5797baf0fbf81f55770d095ec3dc1f0c4c86c57d3425429d4aca9e7ace2255ffbe379e65b3a4e994b37f41f996c9fe5958ed36f2cef6a596cfa49938f69b4d5dd24664ebc0658b6f1186c1893a9ae15cf3976240a60017a5696f7f663c575a717bd259cd61b94d716bea5bf432066c2d1011d38ba1bc6efd5af0d85b4bf90b37903a92c9107731eaa9d8d0499724ef4646c968b267478da9566822c8ed7fcbf7cc74917bae3d0c8009e25703d09a394093d8af50e27b49c8c655363ee6aa8bb9e4112ca33690d46d7304b3413f67c82bd4b6b82a1cbf830aff127fa0310d7396f43bb43125a1bb44d0b07cf5a2a18e1f45089a05f59ac5e8aeb22d05080c7f613c83f57c2e61f61f30526d12df1b556343eef915c76c4eae98c2b8d3575f022b799c7866f90ff77a57af601be784caf20600fc45edbe2db65fb2748888708514de14bebf842393fa0e0ea53adee9a6175a11f1728a1a0dda41b78ee5af96f5ac2577c4feb6b2042b01da534037b4434b035d122df7d4717a4d6ff818c9aef1510523a21941c3111da79cd3095453ed045d4c0af619e45bd290d4df6862a84d438aa09ffdc18cf9661e995a409c4684c7011a7402846b219e1ab176061f8d877b3c8fd8c33025f5ca0bacd1e5a325d46a53b712b58223aebe615e69a20cbf925765ede78f7ee0747e5825e9cbce94dc2870a77c91cc53e94c30e10b6f77fdac3723d3b730c2b4d8cb7d5f253c1ec82864d4c9de4bace73556f77595f192be04c3ccc8613feac3f659cee5f8849989b6121128f1070d934bd11191009569c84f18fa8b1fb8a0f3d3d9fe4f4f0ea23bd1ecc33b394cedf7140f72d68b24b6a3f5a65757d2e6ebdcd688a6a1f2e75e52f119a92a90741a508a42e7e86b7ff5e85a60533b6b66aaf325372f2140a5188db5bd85c1673c3a9425c93c79d8215f63ae57de344b4b638ae768a811cd92aa4455a2f80c98e108698d3c4468cc8467386494354bcd027f1524be19df9d5f362c12ff2d9dd30823ece514260499978608b6a14ee3c75cb039948633be61142e2f1db0653d048e2fb5c0f3dece1d8ee879dc40487834d144740d4c39cdb1589aae5adb9b821548421467dc13dde9159877af4c480bbf76f9e3c128d467b3119d7f3f7c622219b1f939f09d81688430ab90f37f1cdf65ff98bebb081f2fe5c947d2fac15ff1bbc008a35186ba53e8717ded006a6e526fbbaa149ce9b5c156fb1d03b5f08f330b747ee64e69dd96e45d88aed336fda146626673f4f0a3d188bfd428dbb4442c86cbc4eb363ccb897068b63829aae3e6d46c75708bae6f75b187330e254b8342fdff8eff090700dd1911623ca0ec9f775099f7cf2206b29ac6ee66973463c38b13e8e81f08782bda45dbc3de57d17675ac6473c1f6361e0ed9188d7069495ca5dda3b8b9a56638d43cb6f21acaa13d0eb7acf73872d95512ea03f9da417af53c9f8f93ae50ac5a681b14ec44150c5208bf0745dc0d22b6ec65fef3d2d80b3e07305534577daa116a6d67e8006e7722a1d0f43090fbd5118095cd19ecfe8e60a98d42074d82f73bf730310888593f68f1e2588b957f42402fe0cf34709b5f2df874f33836f6b2472f772dd98a0f5fe5c7f26dfb8baa18de34d5e6b9d4878e89b28d2e8969567ceb69436e2a0fe3188e90dc00e20b1c61c5b25043416c48a181b08ec27b9d90e42e3547897779e40b3563327dd1ebbd432868cf2a9128f9afa1663772bf3699fe4d9a6fde29c6a9d0c01196d809b5a14a21d00d207e321b9da0b2a99b1e438f8829ffb3c54216744e273aa5ed57a365371584e9b56fc02bdbf6c1a9d54d587eefdd875389fb77b6e50985478feeb50efc66bc1093a8dfbec683f05b16ba4c6ba12a9fedba447044a167e9fa547ec5674009eef966e13ef84e18a5d2cc56af34e523d9cdf1d8e691d816abdeaf219e33a411bb85da47918886856785235b49adc30fbea23a0a3d205af8d82c5b67e8c2e3bfe1c55a458e35271922387e03e45cc370e319b1cb99905c149d0430c38b114d05123871a762d73aa5c98341ca220ad5c01e570bd35fc53803fe7f6db6924e92e7b0aebec503f78e0a4196f56623fa0d4376b4dad74c551742a6808fa330b1e923c98c921ad7d71616f518a9f006e5ad7389c4dfb33c906a7c8866efe49c927e5fa6ef0b0809f3595ac33a47b00b627833baff009b6f406a0b58e71d329013981623e7bed36dff81d53dae38c1cd71035b03ae7f0e5235d82a1d4abc270d1769f68f2239d85b5314699b84654d1a1bda696bc56afd9a39a012ba9c39bdf39955b477554210aa3a4fc01ad861809f67902c4714c448bb05bbfb60dc74336d2919f9130196c586288fec48479c814cfc2deb4cec9bb72c86559a139b79e6b610c5071ac6cf7f29d742795909973a1a8b0210bb18fc2538433721e3428b2e88fb56d004beb23b5cdd708b8d13bb031cee8e19eb19c7c48add8905a06cea3668d6aed041ce1660078c457b24686a9b5c67f78a5a3727d6daac28670d280ed566aa0de5f72c6ab6ccc2d7afb87436a47b7620a9c160ae09176c5ac20205eb2f44d78f1cefe0976e332cbca9c44833f182a677a9d800ddc4302edf2f5ddb2ee54391dbf25abf349c624b1f3d48168438314377e8bf1d79b52bac97df4745cf6a2b5fc8ad6dfd358675de1c901f4a088eb8bec427b8d544475ba4005acb7ac16466d991a2a1edbb6cfb3a640881cda71fe0259337ede4a4430c3662eaf8ea9dfc6028dbfc15ead7518ced3ec9487c690362e33a924c2286341a0fe5f1520b9516f1f6eeb047ceb5e5a70ef7e45b87737d972d1d97b7c062c9b1bc79221c94a72470a25d1b1d839170e4bc919be01108c1e81bfbb4ba4776bdf9c65640971ef67db054c72f8477c7f0d97649c01aa9440e3e4160a865e6406de0a736b397080f85d6e71de67086e1ce56e46643ae671682f575ec13715fe396738780f1ae87e0a8b0e19280756828eae72eaefc43712f96ff0aa159dde075a45b0011210b5114df0147a4b4e1a71c7b3d9820a0bd89d7ab8702ea3859fef17cc21a297e8f61c72da862dec02d8e05f74e664ac975fa94d6102e0082d845dc89065dfe66e5a2ae88755b7f7300f145a4ab34117b4ce25f3d3d9d815ecc480307ab2d7486fc32f035ed52a5e30311ee235d92e928c92672d2e9641141fe38306ee9898126dd8ba73566d86edb4678730f0bcb56d1699e7c5923d2a79a9106f1cba4a654c3e8ab4e29ad130aa256883bb6cf5ee1684dc46db23b413239e66fb1f1d3844de6878d88f9810202d2137cffb31955c25fbe35eba88d1120e29c49622510f44248fa3473a88a8f12538db0f1970827d9f7f18ab4803601c3be48fe5c434d0afa64732368388754fc892a4e415422cd636368ab53e394191a04591a4b1705da7d1ea0ffc1bbb21615600cdd0ff17fecb7d52dc0b9ef3a247b93b3d7b5d3769468fa3a204bce3ce82309243f4ce06b0d1bae3844e2655e1152dc2ca304428ac1e1aae2103626b9c078e4fd0f199257e00e459d2cf2361b9c4a365ca3e3cf2368f3c60ce44ebdff214952828033c273e07f156882836a3fc45e09049636f97232d570568c9535a49157fb5aa3ad374198c4e1e88b99f9db234434cc74f9bb0339d7587aeb1d62eaf718e835fafa89e942dbf764c4cd2bac6837b1b1ac2f75975422e44b9b88a90af2fd5b98db105345ffd515419334a84d3f7169968674de692eb60f6ea090fe6fd98406b1eb40decc58dedf5539195c3462725ff8498dd1be942f762326842f2aaad0f3ab3ce53ec87d74e5cb1ef0d68994beacd922c0c9792bad2854be53ace3b3b5d381491d0809250b67b3d6e6898efc7e261bb47f82e781ca3305ee6cdda0e1d19b3ad72a073d090943a498a94055a31dc80ae953427e476a023a6bc9bffe2fa5ac78149815368c4d5144be7572137f019c6dcf5eec463be61408132332d4f8170487064f712f515f525b2beb4621a5e94168e04ceed504efa306690e646fc8c9c0d5fc59237fc844926da45b5b4c6f9366046d810e43bd3e2fdcc96f942d293a914280a37d2cbf91c3ba9b1eedec2bf0e4aa1a57e72f24f47837a196eb26ba3a84c003394da94d7d8334edc10d27c36a3ddfd1cc4f1e2d225eb7dac958841e8c8208b66f4d5e073a71775b16bea8074c3006e489cbb388139d982069847279953085a5abe4c68ae60ca1a52480ee3dcbced03e9dfa6516a91ad508dd9415fa4016a48571726199ff39c4901a9258210493214af8d6bdf2f6acc529c328ec3ff493a2d04bfbd55d313210e04366a88cd5a03d6c5513c648063a66a5bd75e12a2a9b3826b1c4ebb14d2724e8d320aab01892310bab124a38f8cc16a35a54640b2e440c3370a6a6f569b4828efba5d381b449b8d82f30c7df803af27d37f3dee527eca05a69d202a5488f033fec2782db09a4fa648819c112ebf5459308f6717f0d4fb870c0d4abe5841d438dfe8b83f88bd2198e51323a818898d7a9f9169fc5d4fa3e0ce0af384905b2b46edeeac912bb9acab0f1f90abaa5a80ef2c8cbb3afed22cebe39d80ad5793de052007e6f3866d0f0535df50c9762d0bc7f171b7d30d7716d607dcb34c81566c5bc36b06861c504df4a775f77e229854da639232907a5a196dffa9ddb17330c7f37b9d07337b3e7bcee15a5f7e4dcfd675babd5e274eed10e186092a5d2f1eef781db084c00954533bda8c5c02826d357f2159301f1e47c71412b54ff7530422337f53724b6bae5ac84a735d5c079ede561d39e85b2380364f52e5d18303e2ee4778cd21831a910d0d0e832e6f247f9ff569377127370883d380b3327a12c06a92201153ea465016361de0f8834297720221a6e5ed9f27e73b6e24001a756a6f6e4ba4cf8c54b72cdb9ad13d8f3cccad7b9b6a843165dfbf029a0d1b55f8b9c982005ea52b373c5de23986f1ea9d4a9505336203d568cb9036b37d674764e67f00c9c7c985d30f7242af1b3ba190bfbee3288b484a948670082b3ab9c90d731e5f75c46a2145e3fa3336fbb35fa94d018fdfece3f75b3508c8c8318ed782d3c9eba3ae41f9c9b4aa214d110779cb6d79839b5bb04e249cd077ac89696f2b623cf66c9369d10fa242419c14849e9f87f1ec5fadd527dbc9fc834914718b20a6a25b6022681852e8ac65c85495759314ad957bb026a418c193883176f5d300ce23df6c7b0dabe5f53da6247bc24b7fd072397db545ef8ee389d471e354c0ef8feace406047b8d88858cafb215de023ac1d4baa374065704a47870257c505b50c9a6fcb9b1f0bb79bd4a2e9134204b08d409783fc1cf8a6fcfc2e6a6d78d474a45531ae1ca4f0831d7580bed465be4cdda34cd85840d7ad7b7792b1bfacefe8924011a281aab662113b9a1ca5d60c4f160f34a45c50509ecb13a7ab1b23f69b8191c1469c3900b21b8220226d3a099371897a482f4c77fccbb008ff004cc4e8f94c7c714e1fc20278011356f277cb9ddf9bf873ee2e5af430573696af57cce2ade81c47d7878a6c0d1c7d68a3533a9d6f3bc9519ff734a2532a4e3d75360e429bf28c415482517cac539b098bb89d7f814922d6f675d69c9ed0ed84f81d7218704d2615ae4ed3071f640d8f259dc6551673efdee4f83f41ea1cc4f07bd4d20342959946034d6f8ddac80f22cd61e12ab46b031a8c28de29c4cefe56fb9e1d24d87993aa436baf37e9871d7c3b225b71466ca433e47bc280d53ab4da369968c251410491f074a97640da8bfed94023b1c5eb07ee7dfc824eb34844582f70ca7602fc1b2f26daf2e13b44f429a76b5999ff848660262bf6b39cec4f753bf90fb196e57e0fa4928375db2956c827f288f6b612e20b05be4da61f863f46435db53af3bdc0b47e11856e913bdd3b64b82f71d288bf282bf13dc3cfa3883ebea9a2d037ffcefae9da1187cc057fcc7d782a0e7e8c6b4031e1105e4317bf806bfb0ab80e2a51a4581b3e4b7cb2d52138541d288ea05b7efd782f34f89f3dc4435b91f2cf89c9f86f0d2ce8d96e20f0addfa64cb234ed5c0864c422d09bd0c496a1125e8856ef99f28e2456f06a25e4355a688292c20e22b68ab84050077a245cc27b7e32ac3e79d7b59b6bc199a70e26e60ab1e7e4512e39dc5ad0b9ba5dd146866cb3636a6ba8cab933aaf2a7ebef251c3feedc22794d48aee8fce9dafc7253beee44829714a02e21d356bb0db09c62cfc3477dc4bdbe0a84a9b2f5b896c96d6391cd9ac16542b137963b30148dfe99ba5626e3ab7e8752fe25aa837879504be83bfa37df88661b4160ab55fc9268bc9cee99babf93541f8c1e03f3643d759aee84f68658860874a08ccf47cbad2d1e3f7ee41f99a3433aaccca0cb0dac57c5b5a4e6bb467b79f666c402570afb1eb576a7b7ca7b13ab5c0d60b2a995365b99555ce92b64e95826d0387a5db9ad8b7d607d2756efbee4a8a56993ae9a0914ab1de49f128a3a10cbb6ecd9b7746612a6ce9f92dcd27e3def949314231f6a381b3294956e9aee0eb744b5d5490d70a032028aa0506da05012793316738d6a98ddf5b5fcbed75e4bc3928838af01bcd7f08e19401041532a4c8b1cbb9c5953399cfd62bb55b3365d5e8cc32034a20afa3da05c20731510a63f9094038e2715bf187dcd5bf873291e8fd82ea7453198e3247f3b1a042bcd530e97582cd438c1f3648f76fe46f57e61898a6683022d249a5cfaa817ae19731ba60a60aee271dc4edd8979f0a795706885bea5dd90b598231a21ea3fde2011aa87d364db91b239e5ea4d8306b488724ffe43d3163e57cbaacda37df3a3e7fcb40379f45897e78ed5fe116f7260baab6b64bf237c6554fc478184eb8b7e947c4608b93e8d6dd79e3e7b245b267a2c6e8cfa37a411ac80a9798359cb3f86a5e13eafdf59b12dd25cd4747da42b4428b278232543464d3c6b5098b96c40428243b6c5f3c0f54ddc1d0c0139b4da52c9d7a20ff125be819eda275987c586246735965aa4c2520f16bb6230520a74759ea159ccfee5678186a4c8384c739b1d4facc6b68c30e3218f12166a656d5b49e1427eb3cd16f97d3a5da73ff5d5e7df821eb59ea64fccfb46a41a8aaf4667272c6c2e9790ef755335b0555b4b7590970e4a2712d0012f52a294700647885f48eecf8321b848146b245cc019ca07fb77c051529d61bae2d2584538d26652180dcee1813a2b08f084d90d66c19d6d99028bdb225bc990669c2f7b9e3b6b66889ef7064c65ca9f107ffecbc5bcb8b90d4c2da85c28c31c80c394e953c506ee77332f288aa0e6864291d82fdd9fa345c231c0466b17ca13fbdc36c9fc5a7cdabd0b7c0a34d8fac4351fc2058534ac10f2ce6c2234aa6d48598b2daabc671a04ebd4f8aaa30e1193f727358eb1ff9fd4e68217182195a552877eef1a23b38017c4b2e95a8127dea9d84b2ef2f2d41434d322825e963a663a6c81f52954111f89e7ff71d530140b071585eaf3a7bdb9273f811d46a8631f0d090b04104babfce1a9d761fec7a4473712d13cd4257e13d7acce3e1b4164d3dabf64ce905047e0dbcd64bdcbd01da7bdc8f0160ddb0c673d244f4290b6d1ea9007f2564518df7cd30615f2492b11f927176427cd04bdce381227e7bacf3f9cfc7a250d04a2f78750c676a637ca2177f80d34e2cbcd079e876e402f6eff2e187d3ee2a465aa3d3d42ec869ad7372db0cacb7e9f177e92d44717a6d133f315b74f8ac1350a0b6418ee2c455f0618e1d426cb8d02803817981280a8293734c00406f15e184729670608704f4932e93e78d9035ca54d2c4756ea660712d070c19f569c7f2dc52c9a6d7b8ebe0339a38a1dd94dbf2c79fd951e3bd73abdc8def50f7542cdd47e625b2e0830d80d047b8fdceb9126fa6cf12585ce84cd330f3e47ebece0412e2be7871d398ab4ab1f9588e6ae61544f595a5d30cfd525d6977420da0f32ac087956241bb9c6186f2591282859e170207fca3041c54a9ba21a0a5cf441de2dca144de73e5b070c7df14d36ade7f0703792b79a7deb7335edafc91818152e2dbf1f354152db4ef767a964c70f590117c20fabfd276ba7e41b58633a6c93e5b2a35ecde7cb3597061450ed8c8c31e1e72c4173ac18e95983537d6506d041ef39da695b6187634c6683e0da0b30e677f064f0fa7b170ae91de7c9e014ed6ae69da697a282bb738ff3f6045b007925a44e2dee1952034eb4a7ecc1d5fd3e02dcf8852f98e256cf172b512b6b75c4caf354510ad323d346dafab718dce30c49b37bee20069c2c2290d2dae5774325c63761b9f20501d71b756e6cf674eab1466cfc528d9bfb47cbbd62434fb01e33a9e785909301ce3af533853057657745029706b6f04891b4c34438d0fbb9cb8f2cfaacf75a0e87aae5c6098b4bd2cad74fe669203adcbbbb08925189b62dc1702eb32f09a1d27e097cf71e57d365bdd29a2e8a371fe41929ff8ac984c24158e72df9fc108a60096be1aaa4d8c7471e699bccde76df0c7ad96f4cff6df67352c426d1eec8c5f1468b8f2e7bd2f3d593a23982598e2e4bea1d47fd5f24f4c6a1285dab93d229072caff1d61102ae155f21caf557913943a1b0934ef528c9cd2caecbe86d6037bc5a808fabf6770792f2154c73fd65b25c0266a7b60e299bdc14b035c9f147ce5d15a61d6aef16c19a2bc838dba391e13cadfca1b99cc01e1bb6dedd3e2a3d9db5a70b747e59fc7ff3866e939c04f33f8aaf9ba583f288ca3e8d77f2673f528d2fe33efd40cf93f21ea6f8a2439bc02c174a0d6e583bc28ce34886f5ed7c57aa5b113b1bd06ca2320270715422150a9d8b148d617ca6504ac344f62f77461e747fea69cb8ffa1cf66c6eec2878ee9c3df43b4d1a981b8ce29b1313755b71e7e51f49aff7fb0757212cd2f7a94d379afc2af59afbba736b453074c7f8526b64f15ffe0b1872703fbf8a6d77b0c7d9357a35168120b36df36a30c4306b1cb5057ce51cb4a5ac981da7eb66ca441abd0650f31ab096ddf4785b9258cf6672bb66338564db9282ac965c968bbce1997cb3184019cb49eddd439754d24ab0c01b1552edb9e65172c52b25689751210cc2a03b85d8af57faa3fe5588b8d0c5e77d54e5c9972151689ae03f4ea74df81d1f35093332dbad7e4f882f3bff3356c6c8cd212569389b68640a081af8e4542b1cb353c3a8f5695f3106969fee8c3667b23d5d8da7438001c4256d3d1430dd2de88b41f800cdd13cdb578bd7e01a6f6fb3933eea2e16b64a1382e55bbb27c0eea39578f1f67492f0465c8dabee0179bcc87bb8b381426a896889097fb9604c99aa4e08d3661840973e1152a7f758d36b7a3f4c2261fa2cef1a1c4acefbec866808fc1e15de2dd9f08d239b677938b1ccf403653bad0e1bdd4c19f616ebe389d5cbeccbe8eedbf8ad0f33b68d345349f7497dd7fe34da257c49ebd04ad9307ff47d71f0b83b9cba6f09c7924a7c2978f043427352e82f49a474de43d7bccfe4ba26cc5c20b865e51e23a93022269ddc6ec04813ca835c3f795122677173e865c421f53edbcfb22a7bb0f824b76a4430a565c258b3c1ca405071eeffb5f66553d5a5bbe978688a0d9440976f8bfce9ad644cf578bb1af1afe9d4684213acd4312b00a87b8a61245dfa85002238c03fa6d730e26957058f58aade002d9fedf82a1607988c8d8f50125692caa81e09b6643f88cb98098a4d6a53a841e0fe7480e1a8ed311fe812e84810c02ff83841bca35af2b77b2e6483c38be0ccd9ac7f1a2b1524b562358b589872919b9b9e203ac8cf0f4a3535b6361796bb6223b678ea9183923d9d7a822afc2fbf0f92174e59f22633e958a02db03c1997aca16c1aea08e1a8df985900672d9c5e3cb30c7f0f69adf73d4dc4c396e38a1cb7b5d947ed4e365c5049efebbb5bef125c0b0e74ebdc9e42116258028b80b47beb19fd5c4aa36e38b9e6fee943797dbf1353e3e3d3705954a76efaaff08b22e767b3449ff2760309171922444e02e868994263ad72ea534b0038742be72f9ccf84380f0880939af9026e64efbf2118b5fdd92982b3c06ae2e7de26188ac7604c49ff4f673ee1d2200d10d16df95a202ebe3c7e15216d84a52eacf1800b6e629e741e05bbb347a91e2bc8c0226448a42e98958b4d9882e77a431b0ad84dab690938b8eb3fcec778dfea0764c6f37446d4b4dc6572aa8169f18890b82fcff07fa738e758b8dcd2a425f492155e597cd94e9ad5323032e2f4f6cef4bb6210957627aaab0724b9145bf2733d32512952bc78e858d7ba60fac07b17008d4bd1fbc6556d9419623cd0a1f626137f7e92eab259f4cd72e77b639c855c5e136a9b5872325470151efa67d110c1794ba5bd91f7329283c6d71679c8f890014e62d5862b18669ec9f1593e35e4e9f64a6d799c2e935a5fb55bdb6b44a635e463d241b93355e86a89cfb0ea8430781aeaecc3ef37b7c3a2e9332d28495c5e013d0e8cd0ee72fdcd03034e4c010a1f8cd9965a9fdd77a80d77e2f3936923c89d389dd71c32044dc90fe6097e40e3a0c34ab7c85d0070aad56b22f3d51433193527f486f2e6e449f328dd01b410073e94523e59bf8d5b7f185459b7ea6fb3bc5c338ac536ab1f2a5c9fd6d244e57e1e377909fbb2dd90649ef1254879637be149ee8008491346f967d5e29af2560e540acb6ed752c54666b8dc756e1dcf175680b07d1de5196d8fbf11461fd6af7dc59428e9732e0185f40ceccabe7504989c619e3a25d10a045bcd63f447304459c5c9d49b9fb46ba28409510e88a683058bee11f330f2d23851e6cafb3a90f3f0a2b8621173560ae47d3050e932f129f47f4879f75ab114f5f4da14967b3138ed35e1e8878d59edcaf1fe560839f5f3efe7803ea3da86b1564626be058c03fb66e9bd662031945499b68c297ccaf44e01dbdf411bed667a9039c491ad1f39ea3e1b2408dad98703219311c5107a106bb98373a1309439a80da149caf747e7db105b8436f70b2206862b27361c488a58f4b1c2cd02ed6bba0749444e6126b8a8fdac2582998f409cf71ae97ada9a70b2cac7a427823816d09efa2f73c191dffcac5c3fc0de86162109cca223f19e0c36e6c20456497a7ade01bc00b5208b9becf04dd2b0362b89812070ddc92d2dd50c89f466bed4c54e0e29c7b8e689c0053c1dbbaba2cee474bd9398d704164524ed26a537f567999b847d835a22afbf9eb867d584eacf93c0b7f4261f0abca94ad0ecf3666e8d7013e9d02d4239b622418b54c725a9eb017ddd80d81dd1eae5dccb6cad97a5a222a8f9ba01ec01704528248800c260d32cd61b2eb6eefc544a3c1283ad141e4110","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
