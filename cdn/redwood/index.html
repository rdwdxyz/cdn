<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d23167cb6c1656cdb4c236373835906fb219fa0185ea3c266dd54fd0788d2ad97d9e731316ff38a64b1d0e922fb792816c6ecd1f22b7a3d17c1fb384f8a3cf54191fec98b8ad54574776c9fe14e08042b3a9cfd60bf052f84b8cd3b30045533914e9a701d0c7a462cb604456bf3b1f06c801bc9f8185cb0fa49cf7cb5c3ea95f64cbc9753d617838704f22af1e9ee9150fb4475f02c5bac465e170133b05da6f1305044d8a637755911847129371291b761df3347b72459ef3ff2c208ef31f4907e85261d9814581bf43843e73953c11bc2a208ec131935c814ffbd98d084e4727bbb6df03ebf7cd0d6a3e0350331f7200701528a82d7591f0695d7c0ea2f62e669ffbf671db768fa927ea9d6981512c3fba189b848191ca63f36526d1934635f7440a883a5703bef74511a2b23ac1db872084429a959bfde1be8d07d6a7eb52cbdbd6aff650f9583deebd7e1e80d69579e9335e63c1205b079f28b6448bfa4c181166f830a1568a8134322e259657d8d3432282d33f782c50a8f19cbc2ca764abc5b515fd3b7381885d5a005d2d7b3fa71ff18a1c8f3c8c5884aa2e2b540ddfed36e5212bd7ede55a5430042016b432440217b168aab6d00be131b36ce244f1c87d1c29ffc1a2540cc11f9ca535a344e3540f261b92c4f5c9840c6c19449cef2989effd2d910836f0dff5f8edec2e776aca072924eca8249dfcdc1ad4ca097b0113d8952f211731a7b7cd9501f10b7bd5fcf886b9f3e013c4669082e2e91b771a074de310ae26042343ca32d99e6b2ca5d95c86e00841753f0b3d820ae9429defbe35b9df50dbe17c55a052db5b91dbd54d3e3c97ef61581cb82a62f89b34222d20cee70ff0b8d98c841b25c61f5049b84849757e5bf5e1748604cfd7de857c474c396257107d804fd558d521e04a4e7c608c3a9c65e07077dcc9c8843cc66c7f7ccea9fc30b49287869cf834e46bd42b8a4c1f755071729e170a46b150978bb223722ae9ef50cb95d9dbab228189be229fbf41e2f470ee96363cd21120f8758cbbebebc90863a2dfb60bbeac0d1b62b4d4f8e3a81513700b64f317dc42ae1cfe4bc09a314003589aab36a21cb49a84a5623fd8cf36ee812af8d638202dbeb2d28000844923ba09d51b982fc8fbfcdb35ec124c2dd31670c7b40db83c32fed2a742685f9f5c4af0bb36de96c804d15dfcd9b6fa7ef314fa97298ee288e2f1af75b29b7d748549fe4efca6c8cbea7a2fba1defb5a7b4e1bdd34d3306fee7be2a1c8da0c7aec93690f0736c39a950ca3367b4c161d4a7502285bd821f533e9bf780d98b4652c1caab289a72332a46bb6eb3d94b2c7079cd24e9d0db8e560e6e08574e1263833b37acf4ade807654f7d512ca02b410751c2748e17ee23d5a5994dfcef884df8c5299cb0c21097350af24cfcc9cc5f702cae0453b1e5fa893d7440c37b7cbbd74dff4ca95f3fd23dea8ad539fabe15fe494befd87f3023bc7e3e76324e4e4e461f631f600174ac18e599063cbdbfebd70e044730fb867c1f354056f0e770c89dfa7575624070c95c786a299749a50bfd8f58278d68ccae39b1ba20480eb30ef57efe725cf0618ad896bed4fb2950d38a49cd8322bf34eb549b188a099fc73fa5f8b332a43831867bbec0369748c7df1b6c5194c88d7e329d1ea9bc219ef621a19735ed1a237250086ee7d9006dfbf286721deb2a5bf7ed5f34d4320b56168ed619bdc71c1d85f2f1fd07898bbea2d279190e284f1747e55cac68d8dfefda5b51c95c91f38cbb6354af909cef7a34f664411f0133e0855b2040aeed17e84a94f60872da2bff78516d33cff92f4dd677690065fe1cb159a288952d542b2df704ef4af3700f91e8dba3c1c0022f43e3097dcd7227623766d5dae2eaa7c9367797c943d718c2a3dea6a228c04e871af9ffa0c4c5dac19f1fe52edf8e14291c6b55b11ccaf341b2f8bd877064776d46ef409f22a2e479c943d9920ea6af112bfee8d2432b1fd15341cdc50957ffab47cc742cf0e43708678c9142a48679a420fccd52d7a2c4c2e97f889f50ae0969b7a6489f7a0a99814f9694a40ed7d9ae45df0a42c11b79a49de2011f925a752755e65321c59eda9943345eeb7728f492421bcad6a04fff22446ef078da8081c0cd48ed02df79afe5816579bc25c3e9352e463a6dc76464578f1e5f12cbd44b8568bd0d8137a0981900479729087d4e7055a1e91f712630c8980ed9b9cd7380898e88071f890ee528ea568b938c5f071486e053021087c9a7b0bdbfce86b2f9d6f352c878ce3f3f30f6b19ce677c1ec7417b4a3937c76f70bddc2978b3c2476f97d9b1171bf89b5d8264b44bac5a782da6904ed99a0eee29eb78a3a2bf4bc25c67cfa9ac002bf569a5aae36584cbcc18abd4d224adef4cee727fca40b1d084e51cdaa41530e6b9ee009dc3fe7dd0baeae5caa460f3d1adb904386dd3e87f6a7f1df1779988162e1e6dfe4d11b65b5eff19f2227c258b3afbd873712cc8ba6595f8e6d70bde5cbe41f2e291bfcc5e787e4e9206a35d7179b5ba2e02d9723098ce45c20d5d60fa554401ed9a931899fa517a7dbdece9d95d6e1c995ea8d38faef192d22a7cf6ee5e79cec5c4dbe4cdb1b091a03fc0e988b3442e59090b7811b766c702f49a42a61bd3c0a844c53a8b7a16fa3431ac8ddb1d7409a7b9f4c4d758ae469cd06e1a15f0cef60527b12b7907caaed96183062f6f4f1b9a285d79fe49d66984250c20f32077975ecd39497ae684f6867d9ce9d194dfcc9b7161db5e1394a8b4c86b30a0737e50fc3b8b13753b54dbcb2ff89db936e83cb78d8783d36f85ed9f2423a872474ba6f2131155678e957badc3cac405e250cf6c8c31c1c137e276b1385904d9995cb91217d6edba883f3d4088ce97450742d4600aa0b3d1887f1cfc78802b588c029b57a6fccf2cbdacc988fb82c4f27ff618cff90144a986fc014d745a0933699baf15fa8081c982bf529486f058d80e78df7d32eae8aee1e2e3cbeae8c880e9205e531eb715ed1a0f30d3581f520be08338dc62def1ea82dad3f37c4ac74a10af9fad7b58be69b9c9ba8a36b8e05ac3223cad31d6e26f1edd12cbcf1d84c811090db5b3df051a7aa1d643b3218c1a8897dc7c26e645e1bbd482137694d858cbe6bb491e3caeca76efbb2418e34a462ed64ebfc51868527eac55dc8f8312115dc42f20a7c3bd2c0acee7e5e3826d3df004cbcecc830a2299b613e4d26c8f7c987e6be025ffc7561d096251db14950798c5c321f44ba1d4b4c3978d6508cb76f62738e931aa7207b11722ca68f114ee3038d9b42bfee874c4626a4fa1a02bb477d1d577c0bfbb69f89867b3fd811e24188a7b2e85ced9a0ad5782b65f8a8bf231c2f4111db68be47bf5f2c45035c5feffa8918e6ad186c7d765cd73433b5374e4ae4cd2d389febade6f75fc0cc6102032d7c77164103e3c88bf8c5f04f7e81752e323b3ee363874df89a696fdecd3c59a72f8cbc21b68ef72bead0021c611ef5f17a394c9623776d87b533170860ba872c35a945af8e299e7ef616ac80f611f7f83ff00c2a9651f03c93dadb0d51fdde9a94d832070eed8e90748428700850e783013dc00b3caee0755ac7002eae80c6c8d4b3939a183f34ed195e3c639324cc7ccef048532437a9c0583f7017caff8ee3529c65facc4422baf0fdfe4bd23d9963af110a58a722fcd52da26581784f924c1bdada509a15ded0bece300a706a9112ed0a8410803bb5d1a2dd1711b1d848d0024f508ecd9836f77771baf3c176555299b86288db8969060339545238c716285668f8058c242efb34bef97849d6d80ce797523251b59052106827a86a89e8098ca10a66e4de6db5d916db37679406405687cf521e4fe3596b0e98c310f7a5bd838efc07ebacbdfdf7e11e86e9634cacfb7e35b4d92df15824f6d362da1b3662f46c2b6fc319d1c275f6fcb0fb7a952bb48b73eb7002841071c062dc04926fa8deb45eecdd9e75f1b49a306b0b6a718a1ce89b227acdaa3b78adbe8ba015e0d3b447660969b11af64fecbaa27d4894e0f4438233dc17fa1b6a15e921ce13994ce588ec1bd1d9f466c27cd5315ebf3fc9d4a88cc87935b226115ad00727737d0847dcfca0b2ca35b5e24f9b26334de972360439853de94cb2270dd00b1ccb0501c6c13004af51e10ca9bc9d94242bd67c4b4078495cb6f6f54358ed1523dec453f30479e6f8fb74357089690186f6c00c35140618d574967009ef7cb9835341230ce16907f4e2d09c19bce6230ca8aa28256aa163eeea91855d1a75d737b019855766033b0a49e3b5870a00bd149860961a663599118bed3ca7c94d23d6b0a0e5b6481571eab059c4295aae9fe864af29d5c28acba9861cbef94ef1f8e80a35ad3321eab1f7ca6dc8a15f850ab77b5d07632631f560c9942c42dca8fb2198e0e216318e1c69b4be22ec405c93225272a63d33b22a3e13ead7d24170dce5136edadec37da3f801f5a0a7208d50745fa019291e108351206ca6c8a2369508c96c966147609a58bd4862179a188b4b0cc547ed03e5a99a301c2b5b5b9663a3273b5d6698854fe16e8268c18820eea8d8805fb8565baf7964a867b08f97fe9e8095bb69c9c9615fc1bc5fcbdabb280e13587480d97ece7aec59662a4767cdfe5fcf1862f95933dd7db0cb13096e39e17c550241b28295277f5efa9baf4868d65259bbe75e23502cdd38b3a5b370becd136d1009bb1353c026f07d9433f00eaedd69a4f7367180ccd2df95e47e1ce58bbc5ba6623593ae8218f8e3e820a40b79b179000c79368d9daa00b51b3ed955e6f027e8b4f991192d3bf5c7142d8542c2b84ed8fa2d59c856580045465c8014e6e576ff81eedeb3a80846e37e368f5a93942727ce48b746921f87a78f83c91bd06de9a25bb965bf69d534dac389a7dfaed3b2dc214a6d45fc0c955a9afd35ef77a68557716b2eed18e157f505d6b7a26c71cbafba8b64e61ebfd9ab48186e648f32cdc2115c9ace2e4cdf5d11fb309fe76d30264c96db88c9d7544515433c67da2da8b091b6448bc612145c9bf1f083ad123235e6e936aff1a8062fc80c293c88d27ac6c2da825f011a9b7dc33ac8f4c057eff7ad82f9e3f3fa8730484c4e81e9ddb431b94a2735b582d0a5e667118619a681db71fb21bfb2a04f4c3b97e7c21113ae6ebe9df27e49cf66d55d71bdb2f91199cdcde3a13de7977c2ffd6d076012de1062a07a6fb5428346f3b9144260c815240c2c9b02f333575132f66deb412957200b5f6b63beb0a28ba86170e26aee6e2136aff22968149f39a8c3eea34c641f6abb1b3c0a815dcea8b3e57ddf40929195f37c26d02b897554017bb7c9eac0d1f4134e4e4638b757702066265397147a4bb671c5cb87405a1af6e54c0d38ea356877985e19a9abb7d9eadbfd951ed2786a80ca0d3eb13ef010cdac44e3e8418f74c3fae5991bf53f601bd2dd8ec4c5db927092f27534bca781864e1620143b5bba860c0eb93446f6b763273258376cef2899960809cbcb6e572a5b404b2e1b940e067e6e96e8d29cf89d57a575c3901f14d4dbeffb2c07317c7613299719ac6f65d92dd06b2325727ad8257a6c883afed9d6b2fa51990c88fcc6a14b6936177f53d052b3f45bcf463645b1bdf8c7bdcb36cf0ebefb317f1bb8883a9b40eacca5b71cb22dd2434c8966abd5f436e70eb6a94f71b689dc8b83b820cb1ca7f73a54acb760f4c29c501ff92d5d547192e7b8f2995ea4fb6460286925c6f1e3b5f9a8b8771c5ab6b5c3d80e1a46a45ae3658f2eb5598c2d795f3860395723af9b5ba1f38a6f4c77e68180d278691229f93c627776eb6abd6ee28d6fb8a5ed28ff0c9989dc78a69a6c2c4fac88d5c13e88a492a08d3c02a7a095fae9976ad301b76e275059290a96a53e0faa39d21bb7d5584cdd7ae98a0b4de9aa5595e41d07eba207a43c1d94a31d49aa15b3aadbfbf7fdcdc27e6998529d019b356f22e87dbee15590fb66662ca9751dde94a884271fad811569c94a40de105f9d7bb176fba820fb2cd01b625dee0a62e0f0317bfca297fb49dc45ba4c47ea5be2cd936e4dd3e8f722ab5a53ec8813a3d51d8b816967fdd750d50e1583f85c57743f5c7a41b547e467734e4d8b76259ba4bcf8f9723e3a156b4a4d0f6b7eefb0a13fb406bef2dc2c19ebb692924e03efae0127552677e2fb20748aa009b3e2923af1097f0859476c7ca0c15d9abcf3760ec136e71a5f1ef3be2aeeb78ac6949c4ab57cbdc0d3d25a9fe76360cd60a530af0c128c3cafd1f2f94c9ba2842e326f91415f1b76a3fb3f2dacde60d5bc93a12a3a8f6b583a5e138d48cc866c71f51cdef5669069197aa30f8ae0f841394ce3374a332091fa7672d81037c94d190991f943b52d8598e94b9fe400da624c78a6bdced9cd003b1995d0221321a1ac0b427424c7816565f94166d9573ee2b3e3638c8938a494e63be26fcb7fe8ce5b1f67c6fc8bca646bf6562af92f4169547c9d1d7deee34fcda9f03cef4e8133e0aacdc3d92d87c97f3f1ab2a1200850aafff20f8431fca198d9155f62433c72f96f734ebcd6ca661de92190429f2e32ed5611ff0147a4bf2f8bb8dfb2bfce76a4beafcadfb65302d4d54869441875b5c32b270a78c60a1db2075d117b9f54cefaf1a991e704720c2752950dcc1deba5b6a54d6d76d05f1d78d62350770b1318e401c4a69f336b2073dee4dd49b9fea0d3b239918edf96b16ecdb7e2239308d0c507475d2e9ebbbfb43a3c366bc32fe2e03e1e38294a8e37254ca9af4a769015642383aa7bd90b4a53c280ba0ba14fc364a45d5ac65574f9ad14e6672b696f53e9ab94cf0d3879510f6c2227bee2d6253f16620570421ad9c5ebd5dfbc47e01ca1e3c1178dcf9acd7d7d0e259754a49d7d5b837d0c19431126b7dbc34fac1e0994f379ea091b3196c98dff314293bb6a4dbab336da44d612541b596168746029ff9d15f7fa19bd46fe71809a97df29899d6467c9633396377fd4fed86b6c44f89e1ae418e0155ad1fc02da02ab022a373d2ca4b23dbc17b182cdaf52680aad3404650dfa8f57db88af7a9b636d4e042baf81c44dd17e6a68808f18531ec1532c2201a9a8685e2046b2597527a7d4ddf90da65dcef77b9fc757f02ffd8029dd4ff7117840fbe9ce82ee10a4925b24956cf2ca69264b2a6b8e9194db10491d959307bbb1b2d9a3741e1dbeaf2d158c8b3b887ef9e6fa50a484ad90095fac37ba1e80992c56f949c5617a02e0ba560a9811bfd42e5ef4a959e91600b086efb05a1bf741f0accb98b2244dfcafe44c1c5552cb2c80c79507100afd4c7f7da91dbdeb5641dcd777d594900c599d3c4e62009f7220e285eaaedc76f5a707c1e5e9402f0a6f08842b04e3b9b646cbcfb94c4187b38cd8a876571645728416fe59056e83faecbbd10e8e76bb3bc1b6addae8560708f70c17ed678725331c1c448873860f641e510bd63ae811f59d5bf3397dbc10caa112195fb9dafe788c124b7b5f81f0da4887b4c38dc3ded47deb3c6fb3427e54a55a32123696df6a4cd565b8b0f4e37650a711ee36c700d84ec320210f025bb8a5aa5614fd658f827cdd6984c92b0e64e04d3284dd4acf2bd98b0484de01d342f4ccbe5f2d23d8187334183d0b50dd9adea2cb234e0cb028aa8129dd74ddc8696dceaa7383ce4404a5bcf9d39932cd588cde1c4fe9352daedf072c82e81b716e973bc1dc29cf65b3b6804fcabd770656c8a57f97c711fe02cb91cad12262c94b733cb6e9c6526050aa908e3a41dbbf1cd1b5a9402ab7da469fb6ba94a35f67168b8c28209b08010715015ee2bec1df81ffa685d04be742c0cbc0e7e513a353a53b7f9b9d4b2334a3d9152faa20e208008afd853cf7f6d0cda1f7c48a4c0a6d5f38a044869683ca4684ae17635739eaa8b5a1cc8876d2a20a98f72366751b598248d00fff244ca4ab95ef6a1a760d7025235e725ccd7da317e2f32a2d95cfbd4c26472f8ce969305ea929d2cacb40053fbc945db3182a25d5c92a3a39e296a8af2e303c6f5a209c2a065e1679a8b10494b2104e7aa517360eb7736f77688a4dec0618ef1d3e0288d420a8176d0732cd1dfd267131ba0768979e71a3de35c23ef7d94ad17ca713ef78f92c966146b4b7ba8bd997cf90414cefbd94ac81c3471414d41a2e7817b76a3a0ad0e435ba23d21561d71af9ed85a7d4a6eefe15ce506de341d83312cf9942f60a2a0df1267e20bc84d781e633f1d5beeeb99f4733a0c88c04fb4b4fd352ca7de8e2463eafde41033d2ca893192de088b448f443037db5724bc3229a8bb2f2ce92b5d32c000ccdd868ec29aefaf530b57a027d2d07252e37afeff0ffa1cca99bd1350704c5ae6f31bd2ae7f51f15bf056039c3c1376e6d0a264588eb6d7baa6a8f070a4019a5fb1125f862c409e01f955feaa7aadf4e4dae197fb8c41dcaddded344f7aedae61d62517b753d7d84060b3ee8261b315260cac7b1af02beedd65458c71cd12aec96a7bca1b0b0c42280009443dcf7fac78d35c44b4769c2be1880a1bc73d2dc3412f9f38cff4d25e6e7f0c2635dbe0ff02803c9a120324cb3d08c4db1e873883c32a1ef8a4bbe505830c0b395bface251172151155fd840e3237fb8a8cf30194e91df2ea2c7d91763f7f23e56f73645ec34ca37e90e7d131836f4fcb53da71194145c581096d3014f6807b2f4168da3f2c5055ad3a3e536c2c7367db7bce3824523f9b05af988010018a60b291e3cdc1c7cc9d6fea039bddbbc47c70fd2954824178e8f2bb161bd8c73289a60b04a869e9ca9f39a9f0d5dd4a7e2bca631ab9de15ec1b1b6c82db5213f5dba854ab5d5c6ddf71703606bc79172585ab913eb9d37421ce39c23b019f33228b06fdf8ead036338d4874d94c49be82a0d06a86bfb8d2ca776e12d010847735a0b21ea27a977125d26f42377dbc813d6740814933915ef32bcd4789f92b25f78cc9723f9f7dd0ed81a486300d3dcfa2d76fa8c39a800dd600f5613fe642147b5a40377307419d1e8e04869699055b483ff0e93e5a41cb5514a89e1591848a5b03a949841d769ad2754d6d5fe91406ae374db93f83acf624cd06aed3246544acc75ec7118ca4e61f839a22fd0a719a0d22c5a3b01c0b6b63a9b3bce42742b1cbecd5e242b498a52805640d7613df46106ecc1e2fa00a7a8a20b97be9afb6d1d7efcd0cba2cda1664da9eaf9425faca9888fd21d070a4ab777fb97aa590e26864ce5a7e91dfcec4933880aece371d6d32eb14db45f3e2d3f8c69e0769c55f2707c163a51b3bf7d7a0b8e01c8dce9c2c0dbc5ed3488c441e0381678847b69ca966a3f57e67d64a8c40f83b5ea779593afe06c8309491cb262c29550bf4a84f520e8641410f403cfc46f3b2b956054552e740bdb97f43b908db30f15b5ab381b82fb4c3f5ed527b6223a99fffb36b47183c4c97a297884e050299b4457d493214ac4a6dd932f486f3f42ec82e7b159f397c60859e88e1d2d9e704c6f70d85b21acc5dc9149d2f935c1b46e1cf63068e3c36bfcc678deabd4781abcd6ede55049ce6717c6874b34173358e293848047f644f011fc33a8477938abe244cc191acc7ba26e24da1c225119ae460f353cae73dfd29dcfd674b040ca2870f9dbb2481f3d8cc42406912c48984fb48acfe2f79317b9ec6086b762eaca2308107438d6d2032c2e1065adb4673aadb6b8b611ed66fbc4349a1e2ce7b8994258dbd2765cb26eb04e03ab652d1ae264ac1e57aaca27bb3701a2654fe862fc5a3e722e6cb1744a992a63e16b0dcbd8a39d92bdf20a15157354a281b5b3a5ce20c34275b808b49ab52eee9f0d5f75ab21eea28b826906eb5f1e2129bdfcb7477fa21e0b96b14581b1cb870363d269a336d35b54e10ecc58b2a63b5283d56068627f6c283c4f614fa9373407cec20796d253f1904a42a166ba3aa882f54da9a212328a87095ecbe2825a895b9847900455dd7702a60160a2603dddfcafb6e68fd4689f68921774eca81dd16cedf3f7f68ba9c4b71eca1de0aa4611b499f16870b012b366e46e79c038debe86aed49fb9dcda3bfd5a96844533a5f0685a0dd7ad2839faccfa46392189589035c8439d79330cb83fc32b4731fef6e998034490054a2e6d8d640a37303c7dcba5c20d300cffef656882f4cadf928e2c645ed60c0fd09ed9eaad1a0978af76c705b3e52006941675423941872ea8de68a78445e6fbfc24478a4a0c8d917be487c2bd713074468d31921ee50c57bbb63e926adc8398a4ab40191a681089d72d990d9880f76257c2428f7f67d6fff1e87ecb0679bf954b6d3d034b7469abbe921fd679745c2372c2aca7932881b7a55023209225d1907cfa2e3a4e2b112689a6a2cb094ad2f050b9c73cdd52a9852f6c32a8c468d619fb8c8ab0ab5b8d799e0435f622abb7c63425ed98ab9f0c031f8465544d33d3208074c8a9f776be7014cbe8eeef5ad9786b22ceff9663a05763c7f3ca6c5ef276e52b52ad567c6a07875f5244a386016ac1b20ae6f350906cc132d3c77966617a32a22852953235792327b4665c497337773edc58875dc8e16aab021e7c41561f925ca9bf1ef2a090ebefbf7783a27bcba1da4255c42de091405ba3d8155bb409130b88afb8239a02135d9c2ec2c57019c3cc2d905786c40c15912383e3e54d4f2a553cc44d155dbe39c09549c44c0fcdddea03a97f6bc8615cddb76b659bc06fe23daf06968a029e48a3c399d45d58b103387a74d697919f44337062777f80919ccc6e49a5321be8193c67eb841042f3517401a411887720ed6efedf249fa9d29d85ac68aa4e6902d019aa00bf5fe7ca15fcde25367b40262da1c3e41949bec5652039352cfc8f66cc80f265e4e18e819daf3db16733447509614a96526333e8a1bc0875b5612d88236383234203ea669a7f9dd82732af8bd71a1538e24e1757a3fccc337a4464117c7a372980cb3598dfa810df6fc81c1f2bc2127375c8558ee1b728829a0a7fd8e494e74255910ce3570e0998d18ee021e9a4d06d9576cd21600ff54e110ba6c146344bbdcbcfbaa9c6e9c2469abd64fdf431582f0201377168b69f124eb942ce9c1cebc009582982a134f54e1692ddc38ef68b5ebe4a48e8535c1d49052638738ed6f293f68608f3650454316e165e7114f6743c6209affcf1a8a5efba7474656e6b92daee7e0d18a6f5abb186d20f69cdc1a933a70e8285d61c19f8d8648ba3380d3f24e3c024016f42a51b0e5ad9415efa8c985b88941d3d6b7ae33230307e5f1f9046a5d97b2f624749a86e76d760b0b4d6d1653614b02743dafae5390c35dc9bf1d9f404e4ee07bec30101fe70beeac6f28b79b895d5b503a585fca184eb7feaba4f57a030857a7e35cb0b65809e25d17c6ebf18d3f06d99ec3044a3de8a5b3a1215383faacf23c5cf82abe59c4e7afb5d3804eaa86e9bb1a35c5491540b3e9b8e70dc0fefbeebddc3515b815df2fba685249ae29a361ef818255a4affa7e1461ef32cf7ba3b62e7f8e52083d3ee56b953a8271c5f9867ffad43bef0ede67c57e62539cf89db646c867aa7141adcddb6d2b76dcd2c2d5b29378833eb3c0827f2c36e90e692020817f89750ce96884ec937086f282e580f801286dc4fe5063f10e688441fc760c9946486275c9bc345979ce8ce5b576babffbc3e042e5880b39f88ba1385894cb8268e541ec850c76777eff72bf10294fa48fda7b843141cf15db93a7c35caa492b50d124d216bbac66685346424bfb043ac3e73d9bc3cdbc4ed979354c0ba794c21ad67cb5dfb6f7a33cfdfbb2329797a6da6dee403012ae765c9b290752177e516b9d8efd59f3db3666ac162e290206e076172b36403294b6921d48524505e59d434b867568781e99d469d4bfe8bacfda13748511dbc3d64e1d5e872bef1f092fe71c6ae73e079b9c1fd11cd54759aa7d4f9851000878237cf59ceda5e484b088ff53b839bd73fee6fa02b131e6be70b2c7905eb102aec18cb65e517e0af5f0f91246ae50ad9721f69451c4a1ecf97c75a8197b3a857e9a38d0ba88f3af88b9697dfef6f88bbde6e235ea44f6a70db88829d5be32151479c296e6f86b006670306c76dd3cf2b038fbb8f14e6972776c354fdfc4dc16b1b5ba5df2811f2876d60399aedc2899b510fa019c4069e3714abc4458e74eb8a16ac9a87fd815c66d0c6a36c4c0f350f4cd07952d99533316034043a750fec8e0a74f45ad20a4a16c968fcfd5459617cb06c8dcdfa9e929b6660d08ec1f9db6eb49fb9aceaa155293dff41bff88602641199f1fd50b726ac222c7dbc7f544ed41337aaaff45eb0eb1bb85fcef5938c74637b64b84da352af1640872ae2286f558f08864fbc45d691ea89b8638ca42f685aaecdd5de779f56f6eb461f3ea997fd475fd1acc8cfdb6ca982616d009c3295cdba7533bce2bb01aad83e2520a5e74b9a3c275666fa3ae0b5576ce668185b057e0511312237d382773f218c314979bc7c7d4ade8777dff8dcbd5c99aac1930bba2031afefadd86de59ca5504c596af9555442daa16782278e9ca664db78a6b0962e420ce549d6a125af616727d9c02d28cd3df6948dde0946777a42f6d6a7ce7f76a56d12f1602fbedd04a788cf32cf45405d4c029ae0417a9eb1604d9a77f87a71ed5e2efcd31c24d914e8a2b09dfc6a5403e230ed0a6ba68cd0b6eafe72fc8c31650cb395100b186128d65e17af677d55fda76a0ebe06f9226fa3fc142dc0bcf91ce9c61738c17891f22749afd745f88ca87113df789a06b6c42e77675a6b3238fc26d4be1566016efcf7df73030ea26c6db8a570b4306be3dd968786edc66495d1338c4e393b9148c71bb76655b5780788c8fb88caaf872ed39401f229dfc593ed40961d7b33d6759227746f183f337219c28d7cba520918d7abc9fcc40e5e9bb7847b9ed10d8d9f020ef2dd10c51fb43d2071964709f8d0c0638a86598b8f9489dd89c1d770975a582113d4eb6908f7bca1498cc16e49290e59282877e7e58ef646782928eb8757160e6ee406eed4f3b06e9a480ba4d817ab31583053ad9701cc3d1b87da9602d392ca6157d695756cee4dd208e388ec4a291f3944f799167bf3bd4294dfa089512194f80a888c380efdc1ae22b8b4bde722c4060ba27f8b3a79bd0baa5e1e854c8edb9cbaf7e85b3086b70f8422ed6db28440876d5620b736d72dff2f0b3b376ed6e90b7df5ea0fb80084cc55d3da1dc41edab792a729ea6ef5c41c84df9132170d9f5b848032feb51c6a8d831a9662b1d391ae5f15c35852d6ba8455569598875d2893326a7067fede021818055bcc5cd4278488bf6f1e37711e69449aec91611c9373441f4d23f894121a187f6599ac917e037ce6a36c03bd0cd0c283a64a76bc7b8381738157849d098967780c002def3d608829325dddec37ba647660cb629bb1d75d2f006e9b50ff34b134ff86d7d7427c3968af5e52ba1e282aa396f11772e4740acaf903d99231c8c25ec3ac8fb1d25a027d59249dfca62ba58e002258615a646e00ad88b7aec6abc4398edbc7b79accc7832827498910dd26ebe7d72f1525d3b9dbc13902a15617a3f5ac7ad73a2541c32639f447abcda69f311d89869973d49f94edbb2389c0f35d197b411f4344d2b1995729a519172a2927ee13b54b6e399a22d4e7ff8c3dd1f52473731bcb351e651cc57f4b305f345b25419e2673dca7d7b1b26ef59c5c817c9ddda624f22b3d94c482ee5824f2d9b1ee00f244c1284f3162432ad0bff3074a1afe0b9dae751d06e6a403d27dc8fd074ab726eda9bdf2679824ab0808d221d5fc7a7b3b41c307df151cc8667f837f786071541713d978ca7e632d3e7271bad204b222f654a26395cb34f604630ed84465326d8ac2c06aa87f32c5daa7cbfbdb3f1882502b5b4be86bbbd804e94135207e8a2053dcae56ae3720c23d850e41b2a2ef5915bffec5c98a6a87a1f462b268ca746306fe2cba398617d5c73d0e097ee3e9021bf628fefdf82405031af55af767f49536d7978cfde6687fc96b6d5dae522b1dae4311eb64b1a7ede98532c11c8ccb71b0234b53484eb7fc6bc2e6e89934092d2457a80ed8aee2f92183da325f02b4be675c51b1e22234f51423b3a290c6c6934241ed9ef8daacff1eac298aee6d20d773671799629f80c47e164bdc537730ec2a0288bfb629d1338ed2b31ba6cd973e4d513d5778ea74a4b4104ecd4446f05bf784fbf109e2ea8765bbe7486687f3171fa794af16b54d3b3cce7117391b6d3a2a064c22d87f51499c5f3e1871f6dba9bf514af6c71125276bdb973c9b210aaa965d58a94b6bb9cc562a26da365d729c0b349dd030581384237d5fd34c6b2238ff2191b96093f83af0835a7d660867dd111b410377f0a877030f8b1c13afb4f384ef9718dd56804b1ac39d8038e98756c4f0f4ce48e7d8d9bb96beef161ac2bf1fbfb32ace55331ac025f99563db5fe3753a65bd171caed93405fa3df52fcc19cb8391f7d492ae8b350a5afe527d199297899572a11fd9a892ebfb279b57cb97f3b29491b3e122011620e882232e2f3dce1158085ce20dab447b5ceb77d12ce358141c02ad5a7df8b76613126a717e4ccb380130697ce4a3b93889fcf3fc9d0de85b078504d3a37e220aa01c53a378b1e88a49914b5cc6a226d1f1913936685d2a440ae52403d4e062e63fb5e4c00b16c8d8295ccfcd73ba2baa4fcdb051213975610e51e31ebf61ce1701da490a7c2865e30e0545fd01e7cfd7e31e8bb24253c1f35a12a0b6a8d28f31adb0df48035fa81372c94e03be062955f4e45e53dff437b0979e6c7619bc49690e3bcb1762d6cdb59692e87029be49f21922e6093234ca4701d3054cb9e44e6fa931e4accd5bee0bff0a37243e4d0c07bc2dbaf7951e7b7e53f313adf7d065ef8ac8c4209f091e2eeadcf86e1cb513a93ce60b5a2b6e24a72fd3e1899371831cfa11741b78301ba5dc05de4222f885f9b4f7f43511d946d5d155b3fad48d0b370d9bc66fbbad9e5b4c06dd2625c46fd7882ad6aea425049e01aa8d8250b17c591831d84a8f10d328b378d7b86ac90cdd62d48ae87980d21e4506f3b4836fc98ba3b222b2ef57519f25374f3f776075f7aa84d841b38ccf490d68dcfc2376d23c94451fc27c6d5c5538d3a4e68128b45f1220cd540bcaa2d2439025d85067ed3d096c9cd5edb51b561b753438ce19453c542fad4873d66fe60b7a6063d87ded7ad706ac39613e5c240a3824f1bcdd836bddaca2c43ad11426301fff02c14dc965336d37549d5e38174615b826b7ef7ce0d64d315ca5ca19060ea0ec7cc69063897a1778aad1181d217f0dc13422727ac9f152dc9f710b600650fd6b27f8de5efab447f6abcd4d34c5e451c88aa6c66a247786016ab212887c9ac2b3baa96c81dd20ceb41ebc318c3487fcc36dc2fdd9c58d77794229f7cfcefde870699fc26c660ee96870fa13853b2e79f9d4d27321631ef31b11e30dd4279cf1aa6cdb8d2b089f68e1630aeec6e4dad5e19e34f9cbb26977989826a58b0f6c95fbc716a82aff89a3c454887a1c810caa9156b670b9f259b419c677e8012c2248f69b8da3cd7f35d861b81a6e1fd2e6df0b472be6e9428481efff99250e46fea7894ad2f0d6fea6eac2206ebf72579a643eaac5c243d44c8f90e1a363a45ad9ae67b76450f9711f644586b18220d01e617e7c185964edfd5bbeec20fba4089e9df6ed6205ec54d9e260026a5058de45524853af6663cc0602b95c812a4875aa68af9324fe095004cbb89e480a818bbea82078f3ad4371d8d75ee1f84d32ce73697bb4af71845873f689439f7d3acb79e09a0193f5252fa4ee8c4c79ed8200be8b6edb29b52b00af041b32ce212426379b2748e36b83e9eb5ade5c83d267fa3a3631e47e52e1b4c6474b45fdf170390dcc2f6f77651480e07c356bae7226ba355ae2f719e854a79a97a9efd7616e3b8ccbfd0b8cbc0d832aae40c125709eb126611479e151a602d55d51736e2ab067d8ad561d6b07e47a06ded1035a42c6056e8e681eec2bfbda1c893c5521585f6d97ffab3d9c99bba72beef3124fe0a28a47ed5724457b5c5835a0383f35f0beb7ceee28774bb1fe20c8a92cd38487c7eb9ec35e5f06cb9d81a3145772e4e8ac73bd23bf2e61bc50e240c7e5e2b702b3a0128c463f70aba27012a5656c1e20cc4ccacca63ca3121bee0ec0b1200a6e2814f06c58778ba8f0b58342825ddf4e31145ef14a8bff85999f16be7bf5bd22d2cdb38dab007734e5e65c6c564a772935b9d5abe5c7876712973550dcc2c5baa74a3400f6956cb9dcfd51050f306bba4be6f954f400d8786248aad6688f07cb396633304e670780b270eb7027e52aa1e0cb3afd4ab63f7d8e3f3a1352607b0c1a692f5638e166c42c420e6e0b3a7de0291a20666d8fd69062b682e2f79718db6362249f4874a8030c137758680350972c6854be4d88b41c476bba2a9129baff95c068f28380a37ed66cb767c467f93072a9f3f0bc99261fb1d9e3c8237529843fe658479f34c435c60d70deefc930d0a7ad1651e02479c11eabb0f870c4d66d7a56b60000601a582e0e7620f637e99691eff67146850467dd67ea942d7e8af6e1c2ee82c85fb5b5d4673af8a004d8694692f502e2e282e92997a9c988d0d01c3c3b10359c6a70a88d585d5546ef96affec012583347525dac6f987a991c320b16806d89006877b0295c2cdea3a17513e7db3c903a3e25874947b1277cfa01923b98f6cac9d0290c75bbfc32b1d8a60a2a794f9a55431e4aa4ebf7a33a0d3547ab5fe16569adfebafa05737f5a6d16fc780d00d360397dcbfcedcae6515ff9a853d41d85ea4e7712d37d5609a217527c69eb18ac1fdbb9b88238327682fd3dab88ed649679d00e20de20863d5fe4a451c170cc2250c249968937fcd566b0c45051c53d0b9157ea9b4cca521f5c9c36e8ad17d32318ce39285d5decdd7704e32743c08c8c4ad978d231fd2f01e9c005e95c004a5304fe8d9386525384cbdecb8957d18fcf9236139875892553cd0a9f27e72f2e550022e39eed5861a5bab445e8c6c9f3c0e5c03819d2532a8abd1902885a5d69d7d7b53fbac098f3dcf526b8ef331981a9bf1c1cb8abd683ed78869bc0f1e50da38f1cc4e7609c79c9fb56ade41f8f523910b095f30a46f2f4afcfd766562221e06285635f53d77519553ea0243690c60357bdcbfeefc65a234f7d0cf9f71bb34f2402537b55a3c7c6b87565bb5d460533a111e13b6590b9529ff6dcd8174f7114616be1940862cd9bea4bc0e8d176d631b6216bebae11695e5a83a7af4bd3f8241c40709c0bb772df37dd284ce0e04e76c8822e1d14743d1070245ba749981a24be45015acb4adc38cb3558b62336a6198fca16c62d8ecac47938b05aad2c3de77b855d19c927d9be676ca2709445171dd09f5df0c9416340175799cdbf2ce3bfa33312b84ec10608d583eb6e155756e11df0dc0d31532d7d0b079f8a2b1c64e1916e6e0defb1c714c887cbf8779d24ea3cc50973de8f8db2f73581de4e8812bb3ffab1e1acf94ebc7594e377b59b58a0f3ed7b212ee99b9645b67dde503c4b3b52b6a5613f544ba57b2d6e1c0cfcbbad197310ec70523b62e661c0a1243a1e13352d2c51237825e5f4e0613c32d8206ac98052a51270b8534739ccb903d6289185ccc2b206b06e613153d7db3541b9f786ad70581f55330e20e9a24a5dbb94963a09707fae1a2693a670ce2f8276628d3b458a30a5644324ab73efeaff5152becdfc26d06e986870a620042f68d5afb345742f4a03083f68a2143f70b7d9612b7b367c9df0006077f43190d80e82f57178b46e1f4a02e90b4b3667bba13b86fa920437e2e772a297a3caced8fd63c4fce2c597c445f4fd6b1471699937e5faee3c4a5eff8cf167a1539fa056bee3d53e65e9caf873ae992f66faf52a82cc121cee47aea08526f1bfcde53344975512a49","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
