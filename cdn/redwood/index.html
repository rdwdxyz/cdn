<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"706d437a2cbf293d9e428c73c34ca97803a76145362371819b28618da7ba910a44014bf8e2a1c7b2b8f72cb013f03a59a0050b3ca033f87307c0d15ab0f2e5de6b7b9ea4108eb9f03827c99476de2ecdf31c1bb7a85d4472f63bb4aef7300c5d60ebc750cbf3f7b5b82b2085f9f5b6db8cb32be4cb6673ad2650a92aaf877cdd8355cbefa78fc16760df59c53a50ef94af68018c4ecfef36f07f3bdf2ca6d8fe6eca46176727a2f2c11b99c2b6c6d21ebc161645fc26f49a6498e0d3f5df71fb026cd7756cdbe4adbd79e9e1d1f41873d90babbdab192ce2f4bb4598294c32f813e8f6058be9da9fb8a704375e60c8a1632505fa2859340ebdaad88eb9f22fd8f1aae6307b4bed10caf99886464b2f8eab6aa692f48e55f4f58abeace44ccb63dda78ac5cd46931a4262ab7c86c37cae00f3cd284f9cee71bf0e1b77280853aadc89dbb2770bb27df6be20ac11c53957ef42f47e5c54529bcdac8d6570121b4fb509c86ba5b6c907b77c01f74fed3637f1e3c6f8213eb22153c0e785992b3ceb84692dc0aac6e3b9c1a233c719652956a1aa64a9d599a119cfd0561a3767b1a57442e07be059d47f0e381323e6f54fd7b55f551f6b5c6ac6c1bc8100faf43b304fdf29b0bf56df0e8aa9d934e26b01edfa66cc63eb8b0d34dd85c9262d491451a5fd5b02039a9392b9c10b35f78b30721703d18f74f3ba6246573d1d9be44bddbf2292461efe8cc54193ca3878709c189130bcc6a75626bca175ae7ba1f924ef934aaa42d96ad877a8990aa6885a03f03c10b36d0b66d961ee2e7ceb7be196b26686e48e7eec76a36c35f60da06840719e7e2454c8da37f2d12b03f302130c4722efd57c706a7828ce75b1b9187ab530551679c1d7f1b2d6d8d8452405e66d93781a969a9dfb381f18e5c5b89a5f16a567e322ea92cf7faa9bed1cf7fddf9f50b75a44c768af75ce2b0d83c424e045f1bfea28046183b9d48a0641bf0dbd1df9ef59105331c1684dc6bfd962bf0f436a47c67338ad5c3c16c0705739aa268a80842e6ac2c32103facbe8f9d573f9817e38673929d6a02ed12dad583b67707300bcf7d3a425cd1bdfb1c49ce704822992845d97cde6b11a43b75899d2d707ed4b1b24701c2b6266e01d8d951ab7eba1ef2bd54851aa3e73537bd65cd66537ed4ab5c41bc582001f049ef16dd978f590d9aa5db7eccb293d95cef6237b7b0550582c896ae61e5242cbe10fc999ee3d533eb6a8a060d4cb53a3db29c57ee19f24b4a52a24dea1cc9cf7570c6644955193588c664a364b9bb1357648f6763ee196056bf85064a420d29abca3f9113a1a78d2301242a4c5ed0041c079246518129994d55fea93cd719b058cb4dab9e91d7adb902d6cf94fc6c30091a3f6216fc7c02aca8b8eb5b4a6069862afcbf03ec67ee0082a9ba733a5ea50e7462c51a9e643a60a834f8e3cf908487332b1422d4a4e39254488a681d9709d59a3fe0a37a5b6667269bac57cfc64ee681ea52513de3aaca3bfb2d3b2ef1cdd04a63aa66218f65f09034c993b2e49c514ee41f27e00c0c829238cda6bae83fb7a2febd9c186a4ec9a23b2800e77028220261929cd0be2f704208acfa18d4fc08bfa1878a7e6da4229ee3b336be0177e999fa40c5b2fd52c7df94464296143e9ff78070f48ae87a69820d7082fa85a45fd99ba7adcd113963e248c7a903e3a8db0febcc6974c18b84178ae531c14d213b8ba6be25dc1ad6ed9c82670058e2b984bd0a34482e27e6adfb0b30f7b013613c690283823e6df25a13655ab51c7df162b92701300181dc6fa3a2b043e20da9f6809e7182f14be5aa4ab98e5599bb12adec6627179039c2b69990072ad91c12a3596ee616063fc4969797a779bbdd099f97511c5514cfdd55934b33a7e4e5f1ca736b182babc6c8cb1565e49e0e252ab187405f40f5b55e067c396e2df2aa2c680b37df10c90ff429c190343f6e2145e0d353abc4b4780842f36c13de16467789a25cc9de3d89f61b3f3a769d6716e77e6aa2f6b93e7071fff92d728899b85f4d1802e5f49cfbe56c2436649259a45f38fda7c675b48992672705b2622a2caa72a91fb7fdc1363d5846f5dc0cffd878b2c5d329bf24de9d8cd056179cd3d7222b106bf40d250bf6b8c537cbb22dce4dde74dfbed02867b232c8c1042fdbcef443c418eb73df6bfca3b98166290ab1cb266af3ee4c328e0bcc7152bb90021094239acfd14d2a8b3a0c11f5d24871e65193bd2e40a5e7e6a251968c8874e8056dd943b676fc7f139cf134f38805053947a4f2bdafa6991967290071319e916c63cd3e31cc3e9bf48b52436d1054f1d46a2ce6311308e49d024f05ffd8b2ae6cea630166ac05046617d79afded277d6dde2a9de57ed55a8584e5cc6f68fffb49e7ecae0b931c40f7b763b3f574b411b0a33e60d620c6c0cbdfac2dbb7cc3a715e34a549c4c3b6797a6ee63ebc32859548f8f0eb87caaa574d5014373c407dfcbe67dbf50efedd2bd8bb80346fc8d30054f553446afaaaeabffd2bee447c78b54efcc3939b4243af233f058bac81db479d04ff223c2387fbfb704df762a3dc8eba0ff4919eb33471c0f03fbd83264d51c51094478d1296e0818555e53ef624a83caaaf6cd5c6c43f453e17ec30b0a26f0d24175a893385a0a882bf8d3ab8dab1bc2d178935a04725e712ef80d7672a4b3fc1b0175c1874b1a31f0767c43e5d3d52f4e0a012497c2f40eaf55525e10ee4be58bef79f70d196e19bc4e39200bda60fb0da056f7465bfceac223cd6b8d69136d7040e311d109cfdd8d0a82fc77e1e7384a4187f3b7a774d0331befc4b0c2535beef5016b37e9c7ba4500dc26999656344d1a82e21a7ce25d6de511372ff2c5fce2a94b39dd1cb9027f076556983fc4ce54aae72aa48577feeae3d96894a4f07ec4b19955404f556ab8cc9a211d410fcfe49982c49c89fa0477bd44bb45a5be6911d5a7d8b34de4b1dca82e4677ee03ed80594a8e54a1dbc239de2bc691a39a62739f86cbc833d7dfc62f397e165a6640f51a4a44fbaec70ae50a73b4a21cf5b6448ff7a4f36c5f02804320a5bc09e6a46b5b63890059cab81f700778f007320ba276f2ecc33fa4bb67836e7b4aa095d29bbccc23eaf7e7b3ef2e4c38d3b0e698e6a354f57c465922d22775862b83ccbad422b8f351b3a71fd9856538ddc1cdba5c58d060b15c23d0871c35ab1af9025007e59be827fc1690343fd1a0d26b2796a823f35cc71d7be7dad14435317f16ba52454e286227ba00b528385d8f2303ee4529f5739c3b4fc33c3c9926b98f5c401bb3b0fae956509355de1382e5fbec82bac724aa97a8b0db4b6576e79f5f417125a8021c866fefbec02b639942a2a05c2b5dd26b3c9225c7832406f4614a1f4ae577fa7b93b2a47e2b0a6b0cec0e03808ec0e2120dc31d5fcf2fee68c5d7e431f1c7d8126f6d10e1a795fa0a9b00e11a7828669042bc43d4d8967069cb68e793810ab0f131438346b2ed6177e06a245deffce4644b944a3129847c6479a6563f0cc932bf83b0cfd2a582b6e3f94197c0c4a10d3c27dd7d2e73492e569782fdf733f581931623bb1cb203859ee349ce6eda0b170e082a8cb905ee7862bb8e2dcd3ceac80a859d17b1caea41109a7a250dcc26e7d55ab05750baa85a9bdb8de77b68f4538fdbfbbf6478fe0b1800827021743a28034fe162e7758d2d8084aeb4e29f91d1c433a89ca357352b4c5de298f012a4d3623b2dda9424a41de81c8016e9ae96108ff40e10ab065c163bd2691204fef36d197411d8e600a362929a9099e6dd15130defc055f90a2c9934fc18bd36ceb2ce9f7502a93c00436494f94399282ca9e77e9971f00f0cc1c00bb4344cbe3e09d64cff1069a7ae95a68009b14805dc7494c9afb7408b7658d89703207bcf5823a98b5226ed3bf4c30cf8accdf9eb35f046548d14836829c7bdfd8901362a978c79442c5b46b16ff4bc215449601ae0d52f21260969e95e3e5c44180c9a0e382872f233160049edaaffdc9c3bcf0d1f8fb6e1d31a3228da2c7c6515b8b09aa4ab4d0da8a9b3e2147ead3099123168b680fc8648e2d2427c5ff5aa81c2d9ebca11fefaa9d3b1846d5f4c0b714d4ee0ab6ae1476fad111cd7667c3a0ef129a36d8d1d9854ffaad268a64537356135e2a188d29dbec684ab1092800ebac8eb5add3793e3166e3c7dcb64910bf89c840c027f6e3e420403c75c632cecf738de5761a5fb7a7d9a2cecf521d61f97fb1fa101e3f56cabc32cd89cd8388d55cf8603fd842a56fed9ead6a6064c8abb4cbbc98e672530c3018f86fc54016b8725b51634c7d895980ffee45080ceefefc4670b9b0b1ad73eb3ee98937733e31501a556e3b38a4d96a897f4e8095e448d3046885a4a02844a98e11c851eda271b0741d375eaf5dd7eb5aeab26aca920e8a00c37f1407c5f0a234592461a004218109bc6697811e37d77f5406d4eea251840b7aad66b8b9c24fbed7179abcd4357d36b69361922f7a3e1bd9935fd66eeec3a787350598c304787474b96464c14ecf83a5598ad160f0960e280d869f431ae51b949eeca0ee9ba6589a5fb975f0268886a5fe8163123d97603b01b6993a97db401e1e000d98ceb07cd6dce503ccf1d996854af341dd45ed75cb339b60c4b857e84077ffbc4d6c65e935ef6cb3b4ce2cfd407ae3ffe34e901164bc3fa85006e793554028d4bd363c58aa11ee353f86ebeace55a1cba7f6d3618e3c0eb41f74e30d980bae7d103051f0c52ae2e6a70bb56bcf357e58c0e18a3134d1246c35c947b58aa071db8d318b1dc80a63e4efdd2721d548311c46be5631336822a62e727fc131ec387613dce5a04f909e0ab3e265fd94a5e3b4628def7a8de86fed295742933b9b8fec23c08c6d806deaa3a5f1fb6cde7a7942104e099a111e7999f1b4f4981126fb47c40ca2c178fddadb9a356852f11a2c25b7bb61a549572e0db195237c99daca6d9217bae2f290db4a621c7b4323790473f6417c183f347e4497814032ad30f51de3ca381589deaa0707dce9a737e09b66069afc1f98355efedaac273f17370264913ceeb96c1aed11bdaaee30acb9c1a1ee5768d08e2f1764f1bf6837e9a9360d475ede6a310cd428a1f166c31f9af555d300af26a7f7431fbf1f83d82b5572629494da07b361efb87d4b01c485a026e52245107260fad9a86ac3e6ae623ae71996675491b81e9208d171e92ca669f1bf9304be03a851347da8074f4da42af0a4fe2e126278dbbfefd9324483470edfd393674162e877b584e64446c37a9167bbbd54f78c957a02b23002f7ed31f27eab14df4303c805cdadbb3b5a513a27bee04d507bca4ac64eddc0a6a3af4db55dffebb50a3fcf58f52da3ad37bcffeb45a400346af14947b8d8df98f1c7a278599395b55f22016f0fe7687bde6b29c38f968438787e5a88019ad5cf63844dadaf889f1f6988b6e557be614adc0152c986a5808fa092eff772151e081b67c1367f890057c187e44d2a6e29ba5dff1b5bc55e29be0711df8902a3481a2d6b696f8404e68881e6d9d0f61a3a6ff1199fcd0c2c190e9515cfde57593bade113c22904cc4da3725a36ff67e24340d828271bd5c3a55c6c324d83d76f73bc5033f56505b92136da29e44a3067215b08808863567d17b8d625a47eddf3ae8f0ff3775a088bd7cf6ecb57502ee3928e8d48082e0421385a68e0ccd667535b0373a686311bd3db1f6bddaf24b98f119d0cb822ba2dda6b3c4c23f71b4f5d9dcfb4cfa2d96e591b60874c4fd9fb70329f0529561f82a875d1b99de90038a32eb46c32b14f83ec64a06f947cb20be25c6fa7ff9bd7314558d7cf9dabf76128fc3ead96cf4dd09073aecc43c9a2dc929deecc8922a8cad7652b7bf22d25a7c4b9e4afa54dc8337aec20b9cdd5485deeaad688975873c8e8ada757a4b501e3e67b21cdcc447455db4197681915021d001c6a9e0af3459acda108c9976c19e8bb5a5f4ebe5748647b2d8b191ee3bc97ed2196f82ede1abf7bfde0755648846f4bf65f6a94afc61ef7ff0cceb7c7d3e6a27eb8c42d7da76d5d4c609354668cba87c4e371bfe1247f55e4ce887dabfae477e86b0bd2cfa9cc29b6f142d39aea1c28f375c02ed1a879928334f7033591a3a270272716f06981abf98d3fc436169464f47c3d21a3eef25936c15b4de45d523e35f14d6967205a0903f1b7a189f60a73b5a8d766bcc7b98546a133f694991cc4e8c08992d2f9e0bcd5eeb50e9059144ee9e3cea612608fe7e03214b35896bc8619b5aa0befacabd902e181568398c6bf48a4c35b8cc96865195651ed7d83caad92762e02929ef14e0cc8891ad5f7152fe1373de964cc41e09fa69dbeb24d78400519ebe1ec22cd867b516cd6913f020b1065277be7a1eaa418e8da6dc80940c9f150c840eb88e7e5b6e87253dd2b528a5c2c4ef92e85dee763f804be9fcd0e53c4cd644bbac541fbdf866f8c40e60e8e99bf311dccdaeb72d511c5debbad07c31d66c58e3153cc69d86f0157eea707d52c48cb6e054ecfc44620c7341216413526ef6f12a0d7deb7eae1966eb65a796dc4504bfa562ddb97bf5138b2305e42c76e832745e6a3d49fd05548a9eb5f5e982934aee39c8d2aedbf3d29ab0a9941e5db460d3fbda6351a71338356d87f5a399310037cea9970421c6ec9bc3f0ec092e21b7baa2668f91f126304c89d68ff6875ca8b9fbb1361b9a41e9d1bf89667aa49b8726fd650b0e323548288644c949ea23eb5d9dff11ca70c661d80892d7af9d84f8804b53262bdd0dc76af0206b1d796a286a02b18db244383ebc2d5f792720475e3e88bb0ee3abf569660d3f52be1bf3d465b609f56595e2bf69a137282fcc855c8770e6e882f601f04d7bfe91f1f3273bc50b3d8327eeedf74b178ba6a2e58dc09e38a95e268642a881731f7b309015f90dc8931aaf7ca27948c156ec773a758b6493ec2573fa7b47dfd25b13f2e70f4370ac559f480a53d103fae7f7d5bfe5ba88ff32a2db73629b96a6f2e082df976b2e72ffb2d6e0f5830fcef1bc8ea48cdcb35998203c7ba4f60694af149a7b35e4276cdc83378435189303f9083028f80ae86531c96bb0e00543b95764e846c19964deaa10f3f6749b8d190103502ce9d4548a2cbe5a17467cdc05f184ab116bb5f0f32f55e433f48f109732ed074f20fbc8c92e92afbda41f7d5744cb7485fb13379e99393a06507790b5c69665a09dfd54759dfa52ca689db80213e1bc35c2d0ed6aff40dc909dfee8091dd7344912e677c6997f31d07301172ff5abc9c96f855438198d3b6a9d2761db39c31c88499f733da51e98b04780e05a0ed6b4a44a5056c15069eb807556644df55452abf367054dbb00512e260f20133f7e4d4523fffe995cd36f1a97708ce14388f675db89fd560e0a5782ac359cbfcd67aeb47415b3d9bdd40267926adead5a7201db83d671569047da14443e515b7bbe77f8054ed9afac696d187532fee0133aa8c13c10b77d8adb94b8587079bc08a095f2f6116fef336cae18fec57bfd285ba74d92472ecdbe672488e4b3dff878b735971f6c8ec261b2018642c35cde6470fc8ee6b3637b604d137dc3aa670d4596b1f101ab524cb3be670b7501840eedc0b59d5a721a81ac25e5903cbf60d75cec2714a3a51cfe4d8cef9fd40f65fa62cc372873df0f909c9ffdb80b9bc5b1590b4b13cbebb86125ecd4bbd6d2d608355874dac68b3e6d8f8ffadb74dce279499fea6c4737aca8452b21324f49a3550f7de0bc95a596a2683184d39cf45f23e9d23cc4634e01778b73b16ca77136abbcb8ef6dcf026f7bf69e78ed4e3481127caa9114f02e0281dfa10483b86d5527db894fdcd02d5b8da8b7f6bd7fbb0e918734aad8dd2dff4f64df6316ad46443868955cc8ccd76321b52f008bb6c7d092b865370bee615a4a7fef625201484e362da845e1831dd8ff6d51a2c713d57abf92514a2bc4b83fe23a2a2c944065f52021ab2979296c0a8f685ee36ef2d738f1946a6bcf08b14100626f37a3673bd465c847edfbecf2dbbfd064e0f5f5b5759151b506f1698706c81404af5586ae462d4438f68430765c572c726cf5a23054bb924c2e659db75b389ef3f604cddeece4d2f4abfcc1a7f4ba0936f4f13715803b25585df4c4b1234cc046611bd206f8db18a6a1a25f23c8b3e0cd78c81a90bf592f111e5fce790bc40a3071061f487638a1df5c259e5c3dfdfa490c27adb002c5b0ba74e52c57152fa05029e19063ca26c09bda518b04f27e7b85fc4ba38325e3f0b7faf8f1a1b223046cd957c8e604adeef3fcfa940866f0e2268bef2c8e54d068ca05e67666f7a192c443f145f4692e55beceb5ac5780c1c8859f2c17f6224e2f83236cde4ca5f075f00fe285fd999215f430f60c1849a01292754048ef845248b30bbe06f43e55802296834bbdc6299c7178d747452c6557db7406b91a0c803017615f57560528e870408f232bded8252c60d239841e23a9e71ebeb099d6b5c4848e099299d6591ddf729d4c3ded619ce0b0d79317c35c58189230934b92bffa405c0d39c735f3acdd0ce6aacdbbdf035c57a7945a499c1f6e02c83782229111c844f26863ab92a4090fa5ad6e3da09c11be173be51af07993653952289e260def02b3e80870d2531f9f8a0183769aad0799fc346fac716b05b2073eb425bebed975bb0bdd26622fa8bac0c385f250e0f83ba574292853e2c7ea43c83e9367e256d988a624b521a7e93350d6fb83b77622885be08596ac7f226a643b2a5b1434c4be104b91a207eb11b80a152da0c3cc3a43a1f5e1b373c59ffa576bfd3cda584956bc5b6c5c4133a211815694899426a1d22d609cfeb716297b9e70584a181116e26efd5ff2034da935b119491adbdf5e9023b1f9d95f8803d051456cec0f47fd93d1e514c3b9a2184a8104c07256ba1310f0cca0297b3b2745b801c1946c29bc2f9883b29f446644468be0a164137f74cc2f952cdb3250e2eac9ab38a327b2b99afbef4d44ed95c587a297064619d7a2647a58a3c4ec01a6ce6016111e0678f6f3ca4ea077f8dc4c597ca92e37a248ec2d7c7d15264a9021090ebb82cce866ed2c5c361f2f88870fd9cb613959e65f518b5c0d00902cb63cd5a1bc96ca00053bf96247f126a843161589b9667c90471645055cc4f276faff1d9092e810df7d9688c3c13053e37c95eb188e364baf671b96e0483f8381080bf3e6dffd0cdc237e835be873f670a13f6fff7b8847743c60ead549888a90f6f07d158752e55eb1b24a226f0b90489a4346f8eaed4802ca5de822fa171f106a57b0cd2d5749b67c6c8891133012e2cf764fb4f8a88ae9a81b225e3b69220b61eb8ac5c43b9e370ae2338b0ff5ffbcb2d31efa70345cbfe9e78c44e457c29b4df3cbd85f737da46a336240cf9ea2f53327b5016c7bb28170b393c14e6de9b63d495e6c8771d32b5f3e250a3a974450aef396db96ae93d0b453ac8e91ba3efee88e54426cdfb99dd87269ed9f95797b93d6991893c3d39d977d72aa0c0dd2b5be1848296593b10fd5137eebf6efb54971b907f416f51ac1123feff1e6f3623d0ef77cb1b7d10f1afccc9baa5b7f378b389a09f4750a0c1579df6c68d5dc097bc0df8d5e0e4e42bffc1cfcf822185ac51ad2db5ec7f9f966e1b51724bba2443cfd57092f48c31b324a4a601896fad72c2274c459d527984eabdf33a5ef8b289683854c3c28accdb9928e9e986f476fae8fd507ba42e3b49bfb8193b24b122f01b5a44a8dec27d2fd8810d5509ba51a86bff9fe74e229000c62e88f2201b6728b56284995d4acb647ed142292c282fef4ed75199c5a3ce0d37982d672eb3af4204623418229d4e1a5b94aecdfd4d99faca2f1a255f7e20da67b1fb93e21be2a765e17f2f6726a4ef45b9bac234312687a735608a08ee3d13bbc76e4e35cc54aa70af7bf20169341488c0f1e05d9e04205868d299cce16c7b0dc431a3a36147faa9682260afe77dd33f261df170d2a4dd1690983142582d636f5eff0f29b7009689671a6fd3b1a88fab68c5af351bd7bc8a28c34e35795ad45acec6fa13db1d0b50bfac9b09bc38d8cce005b19724bed4af81c9a1c8ca1a13b8d3dbb786361c453343a70c842a8150a41c54cdffc95210876eda4bbdcf9d66c4f03f03e897bd72b14ef637cb83d99c0e689c5ca8c809d605c3bfa528b2f7f516298b6454c0ed0411215f0975b75e26bd3ec3af255b8bc6fc9dd40e98b89f84232e79624138c8b5e613e34f27abfb223a407172c480f9d0038376be1537f28066ea04b912ae1d3d60bfff5e75cac691f0d95d364676af1daa4b87d7898c26dd89244854c0df4f3f858234c64c14f0703fbae14e8d6fdf5c95b635a5bcda4c8c40ef954c783082c3405743025f7eb6e565a7b98675bb0a782acfd268474f8c10828cad03e2e1a107f2cc57e23ce7573443b93684cae716bdf378a593755aac8d39b8a5d50e11c2bbbd1b8062513484714ed94798390e3458c87b1e3504f85c5290fd9a0380cc355557fbf6c8242eb76d096ba2343e589c197a14375cb33ac9470a6946c92e3b104b93e589b15b5afe129348fcaeb6800e582982b981f1ff2e5924f93f1df4a11af75be7451fcc962a2f5bc53eb8315107115d1a87e8a7292f99711c76111c4f0760bb4a6104dc6b052032cbd7ecc83efa4e95abf190ee8db200de4b9c8f89eba80a23e143a0ff606118a319ed3241c075b1151218457239366fd14c468358fabe76447f49390f9ef0fdfee4bcf2ebf8ed54b468d1ca532157ec391f94270c50c282915eca06d548e4154aa79b81dacd2f60dba4ec990a524f15e5a102138d5c55d7059928e1e233762cf2c1aa00b75e3fa072198334dd916c86e459a99d248748e703c67050c26b5fa19b9d2548dfbfda140122f71f0a0f09dc64dfa7d4b4b7d5ebc55ff6c49dfd01f9438d9fd37daf610768f4e7704c2b35da6e7065bf2bef7505317dc8cbee589fd1270ed5f1b636afb179cb4038e7cdcf9d754869de93d1a93f45606a76017bacf0ab5809981c0855370565a294fa2d590fd36f2e6b2d6bbb6a444ebdc21d63ad11a806f4123af7c67fd5c7549cf886230c58edf00d3857aad59f9edcbaec9d373e22c92fefad733e648faae37c62ed41ef1b0367c29a3654d9a307fb77b7b5f04cd61572cdbc4606c6ccc5af43dbe679933a75c24f5da80f5846893fdb512ea30960e085672153c3997f4ae25eeedbf891fa8ddd7c2e0e6064564d0643600c7e44ef9f7830b20d215d1e6657c6069028dcec3b3e344438c5338bb95c3a3ca3931c3dc23f0832442cc2303c78b0b7645b6e9186a683c4b39460562b3c0b2d7524ac1d1328ba7c41797278185e671a491c07b4def3c9de1719c8850a45fa6f1a1fa5a3370bcdba19c40b34f79563c2fb74229d8a9be08c0fa7b22174d2271b5cd13585bb60c0dc755ef46f98cff3d3efbe44d1a0fac323860dda5b60c9e179275a3760575996cfc353a936748b3438d16cd23d7f200ef7d4a3533fc7f8fe64e6d1cfdf4a82b0a5394030d936b091288e61308d361ccefe720c7da248a519338971579fa4419d33169eb05bad8c913b519f508e3646277d335f03bc188c733eb785b2df32d588476022d3438ab82e6efe7498fdfff968af7f59b9a84ca790462165da7765c36bed2c8c5069d80ac01aeebc2f6ca8a1b2660df7e89c1b307050ac11aa184c13cd3bd22a96a412cf212f1a8d9b91faf24a1408ea93aa2c5bf770647358863252e62e868d5ea3d4a49bccde813d30ddbeb37907ce857c0df7fbc3d74e212884a4cf2331c6e9385db118279586af28636d8a2428dd0650d80e5a8fbaf4ccce42946a2d03236aef89aeecd64a988e48652807063bc00babc0ce3b13de1b85b47dba76539ce538fa4399a00289c54d606d3c9c77ff0e62ce413e0e252b7584fc6ea29e45a62cae9635ed4ed488e6eb0981f2536034467a8c0d3f2dd92dbabc8f31d1d3cc1b5b689aecba53d10e827b9d23ca0793e471ec2b4c6f792cdd4ba811460ef72c19769cd9af2e45f0a05d5d9884ef888b1a37ca01343b0481cdb16a8ba9e6ed915e30bf77589094b10c09ffda55dbdcd7b72a0d214ba479679bf91c543927c39ef79b9ff2d04a5cf69285d15148f8117ff6bfd3915593be71cdd0e09c6927daeabef315d1de4a61d019615a1f82025ed5d06945075247f6ad2d1f435df677e31d7741049f2bce0a5df932025e8be8bd10f88b6a7f6ccb708725eb4c8203a23d0bafb5a5fb3b383a5b9dd3dbcf3f2f4dee12915c0604f0e771f867c0e614f36c5795a6e5a5f7deaf504df15f442dc591726938a9380d97fe6bd70a9a67b47c45be06d797283793c0cf6a19960c9eeb73e38071b306fbcca0313849cfea3672969e1ac0ff1e0f5cf3c7ca872a425c0adc8a1c306e2781e08bcbc24bc0194749bf7f77feddc8281232c4fc07f5912da16bfd13bf72eeb2170b8f2dc529271e9082341f27ab9c80569bb19bb5c0e6d7b1124be3909a4028a5e13a07f0aa0588d073ec6b57bbe7e629526c6813bf6887a9c0d8f8d66023032c0426208ae9a0eaa2ed47bf7fbe8d3e13219f00529fb19b0de092308d0190afc5cc40e96b89ae684f0cc4dc40c1a0041b68b22862fe54079186a859a530034335561e926035ff482d7fc0a14d717791046df71e807c400ae978bac0b96904158edee61e59389dd296fc66fda6904c25bc86afc0c28bd0ca904ef11d4508424114260a7159a871fb99f7e8795db34e1418f2b0ba1e7569c3a73880e4c7836491f9928fd5d76b73f61f638cf9c0b54e021f38ea679bb7aabea84e213afb1c8b96056b624c3d4a9283846202dd1f39eb3a1e59fcbe748cae6341ab6a9c8032c3191afdcc9284610f00d72a0b7eaf61173ef41938bc9ec907e7413776938fb192ba0ab761f328928c1d3635371d5e4150633a06cbb95322519e7d70f82392762ddeeb117ee71e75308f56e0d526e8f27ec7c6878ee2daf6643695b0427304ce8e5f29a29f4984552721c0ac31505014e0d396689fb73153ae3b8091f872553722dce7b920b52737c3311aa797646ed7167a0c702e9a03de28be57862fdc28c0d6125be3115beace610e3b708db0b81944b797bace409ae5488dfd206caf1a9dc9fff6e6c2c0e00ad64c1bf96366f23a173e98484a24b078480587b1313c96cdb911e07da5f21ccfd98414e32a69e619bb44ed156a44bac0fa209b8326a4fcc6c6c01af54d000a744548b8a8c2a6c34b5e3c0fe8ee5b1be266c94901a32c88f5f05ad180816f90cd2d1e642865389c076043f09df2350f4671f7bc4b712c32d2b9cdc1581c4ab04977dfc7f723d168fe0480a2631ebb7cfbff0848bd13e4afb6c76c060fd9693e98e7d68896b0d6ce9980da1a0de12f3aa424be6b842aae838205e83b4b5a50f744c424f8f679c1e84904621883edd94ebe9d41986bfc4b6f879a24568fcf92402523eb37af2475b16351489d0f7cca64b892f3ab645cb3414b3c9bf098151f612be137962d8aead8e8fa4e9cd7615082eaa4c4f10a298379d0aa7fdda22af224d6a967b089cdfe4fea334dbb511920758e9beb32fb9f74f100115a389940f0edbf5adada0c46aa30c0fe14124ff74ae750ecc8258dfbf1e2144142f881fea951dd2241194e4d9b2aea0893ab7238b287265099e03dc63900f7c7471761ca6c2f28a57e403b5bffb301d7776fb27175824e6c2f679c5153304d1e4812ee9b94b38c1325f925f19d69da7f5ed25a1c845fcfbd70d1825ae895272389e7ed4f24fe532819f4446f9ad11886276c0d1243b78d496e1d636fee943e26eacbc14fcfb6a20d07f7a2e6803e90994a046f492cff24639f76dfd56bb8ea04e4c762e7b6d7d57559155d08030ad0ec8c46f7cc4d18c7a2290cea60bb8b374a091e8181859a20aad99480d5b776e10e191803e7e80c01cec8cc8d6f092009b9e35ac6729faff5c079c8f02596ec294eec9a9bca84647191fbf22785eecbd2e2d2319a6e7bdf25f28ed748730e139585adb1b174d4a6d05ed2e0b9ccb7e28f390b20f484be32dccfba6d15b4977c06a18d667267673550f180d19b42953a0d3b4c4ba5bfaa62e79644e4a24db5a5e2aeafdd39e84c2c2fed51d8bcc081d0469bdda82779ebd52ab2f76bd36a3e3be4cb9396495c308df01f6de2977c1db2db5035fdaffc27f3955e6e2b4e5a20914afcab746b9806865fd8ed3a053d4cd0eefeaf324fa3c81bba7a0cf3f5e502b10196ee0bfc814f4b3c3b0017d2af062c606ac7ddbb48e29437253b52832e844927c04a59e2f3db9e9fccdae49b9183ed4be440e80025cb0be1f5402c47cebd544fdef7b0d1208743796afbdfebf7d0182a79632a5be2a3787c877d34c6dc3142a5a81ac174af7ab2c2742b710c0eeee64acb80abdb3d487f98fa394efbda6b7e62c775de0cc8dab210f288ecf4c3214561c609200b5faebd210c0a5a873e528866425265939624fb47877a2851c43bc055ad6f49ac98c736ae13eaab75e653214acb50921401fbd6214870403bfb9b4b58df54222a02f332a4aa2635ebdbe1620188789bcbdd8486e789c33f6409f47e10e203de849a30ecd34acc330761f65c7a506699dcf7eb47de59da8b6cab8c323409b3c44b045f7b52dc1752e2eae909f222544d3f9dd63e825cd146443c935fb74fb5aad38651005b50c083f8f32098da5e008569b20dbeb623dd6e2db850d57a8c3bf4d51c20ab461b7d0139f0105334297678cf79b0842852b8c7c6d7195009fd66e968b4031bc6ed0312f79e0095f02b35e62086c19e531045e2c0a24aae3149d935b0bda7c2162b4c471a63a7db4b721e3dec5363c86f99984ce7c4f17836ac10b75598d655590fe42d4403a5d7fce43f09d0ffbaf3c3eaf3a5db6bb052c311702d8536d000a1daa81e43234a1f9717698e75a3bfa581cc2c9a8438675ea6002e2594a20bfcf132d5a2fce2d57ea9af225fcb3fb594c8e056989267614d374f3ce40ec4c3779155fdb39fd007fb985d58a2d54225776d4ce68da2149e2ceea72a8f7e90a940e1007e30c6d34c064549fb1873e1be1e8303ed50ccee2dafa4c6f5f422bd4e5fe26410e35ad7ff6616607ad92b1441c0ac51f3629f868a5b34da36b41c751a33e4a5c08421fdd3759d627e6c9ae99770e895a84abd2e52c1a3c639a3bb8391dfce91935e582f56070d688b3b242169b93fe0062d27a5af8b04500c08ade4b144b209865633dc897325e342bb03b3a89b65991e2aa216fdad9daf4264d2ae7241b7a9ca20137af8a1749698f9512ed44393a9fc62a9ccb02a4041ebf8905fa0c5650ff484a5b7015eb5125519048561ea7e3e8ca749bc6069816a623487cd352c9155ca384909c27c6915746fff1e379b61f527f891ff080f1ed9981ccddee0383403733760ab7bf08fc1900f4cd9d88e758097519cceda8127309c374a9ddbe7a43a2544e59d9cfea70d0382268b899321f76eb8ef8c4ba33ed5948254376bcfa0d8065e5b23ec9e3cf5a0e2d16989a888d5a06b672a5757858d85419999b1b2b086ce04262be0f4d82718f74ccfcbf7e76cca7b0305bdee473540f193f5d6a7c6758785bd01f0006c6e0baf94d808f157aa120b46e31f292fd066cec51e816b1899e452160a7f6f870ddc208b2b336141a75d1658fb5fedab9f46a5e806f392344ead1568be36081cda0ce140aa5e70fc73adf2382f3ca41a03e39d7c43a6e6a3a294baf639d09d860b4a8142a0e6971f4cdc3fcbeb27ea05522d56e1404e3d2df6482fe5538e25ee6918160af7dee43686664dfa10dbb58268468557c12374a948817d3a81eceedd60740e2044553a59c2275179352c454fd15c0b00bac98a9bd1eeb86d1c251d57cc1ff8f7fa670b489b9b435afdca1abf95c26e6d33aceecaae683dcb6361e91a070d93faf036c98da813edd05795251653ab9c8e9c0eea1e682c031adc33aaab9debbc85fd9913c416a61ca6b55f6ac421a84bb1fe7b8aa2ac8842868490e461d25294227c5381d861439c270a02e19823aec7e7e360e984b9c3b2336f35ddea3edd2eaeaa6c639b7b4c09653e3efc917eba40f6e0ba59c465b7e77d791f963b3a254d93e8e48bbae45d3c1db8a7ace8d470037d28b325a6eb7f3a16b022c03814f6e48c99b68aa18bcef2c6864cc53ebbb9aa95742d6f151172fb3ec701b8885f896e2679ac729216ac2cd7f0b5a6de0e885f65b9675a8fe972454e528c8b2e07d6f6463b42a5dd22d514f13dae21dfad6aca33adf81bf5135b86b26ee36e46d67a82c226cf93fb9e2a16d612ed987609c158e97c545b92f8233b5b319af4743ffe2aa5f3bc36994f70fafa0def2e34992fd3cd7db1ce587496bc92f6e839ee7f9655a007420c054ebb4e0f898bac631dbc823543e46dd1aea8cb2276992bbb018d3ff6d416655e5c73c813ff405ddf216ef05ae5073f3310398324a920ce37cb2f234d161322de2909c2cf030968c8a8cc6d5bdde9fa2c0f446b91d29c58824e9e4e04a01eedb6cc1dbc277526eff3311f41b2541446df83c39e1372f97fe60cbe97fc1701945d94f35a6e788c636e1e17235030e3dbe64fc07a72c79c3bec63d8a669f9b85922901d84a2399bda161d6d3d1b40a5de85980dc4a822836e5b1df562fac1666cd0ab2eb1348c026798f7d28db20d513b88a679a700bfedfc427a1a2c1da070cb02ba419c463035fd49c1eb607718c9c7fa33168ce390a758d8f8e41a54011e02075c072025cabed4202a862019babc9d89ed7c6a05157f29707313faa862e163cf310a8b6dc60cecd5648d8262f6f32b95934a6fc3fd51dd069dac21774f40b607d9c51c96512a9b5b14075e9b8f99f0ba5f61f1086e7a4d9f084e39c60c526fc78367030f616a691c78fa548f79876b9469d41c314175cb5ac434f8f313dd93dde683bc07863101c9b5c4252d7af722c181979c2326833371c0a44181f080d977107a2c88d645338cd53a0dc22f12332826f0e7412a4718169b853dc9e430a7d13ee6eefaad14cadad2944aff980c207c86e218dce5ec508575ae92f3d6aab1bba0b8f7008151ca8821d6a0e04608209b1e0550b90a12b38fc00464d6fb3e9e3f59664280fd76e4d81aa40519d3611160741c3a76bd6021cd1e3312480040f7303c20e195013515dae98ac9fd0a9c4340f43416b7b9bd861c3da46f587ff78ed5bf64a360e1701f2f86c241f791143367c9895b52b9183f67ffcc9745a676547e1db6e7e43faacf5eb84eca8c6b31da6cac527d1014fbff8422a415f90dc9fed6a28dc9052fb1768a8b3c014afc088ef2c771f0a85d4f1ae667864f49b3308a5a954b3da1371dbb8ac2f08fa0cd20510fea014b442752f33e38399e30dd5bcc7bb09addd2ebf833764661756e877a68775e4fdf01ec81b73624c29a92f2756c46391e3aef9616ef63e2d53ede957c777721f1fa1e28a1a58a63427d0e9517c629d346e1a177af6eeb1a8f2146242d364a1591b0687366b034a0c4cb15c047f7533fda7d4b69c9645f3f374a338f15116395388e0a5433c79d6d33636313357e3e76cef8decd3f1643b0e8c4715b2a908e4d9d5ce9676422435a9f5e4cff112ee92404655ae3c25132b10d56e710a5a3929a16553d33665faa4be646c9812097d83da088098c915cff041a17850d52054fa5e3d458fd6dd6976ff2b7e4d159d223cfb88a1b72e24ccb06e57a5ae354cb74812f658a637c6f5a57ea0b6cd4af8b452e5b6de7e2cff63d8c11d421ec4257b2488451923b19970547e8d5a76f8c75f1e20cfb277538ea22d5165e938bcc97912fb001470b44adcb06337adff1e31f0ff7172fe06b86230ed9bf58fa0ac06a5e80b9d238d33df9d5d56c79f16a38bd0c591bff9abfbd6daf3be4669c18477e52b877a7442dcb14e0bed039f380c2854f31042fc6bf280bbec9593f87982b35ccf057f4446fcac016494d6ecc69f6c37858f8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
