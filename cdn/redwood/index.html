<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff56b5129eb52714fe2193f3015caca4b2f82a2c7ea47c001e8638b1c404f958111be87b107745bb8435cbcd51b31efca16909254b75ac13165dd80610f9a1f2460d02e7dc0bfa07120ec50eb8fbce7f22ebf508c8c5ffdcbebc1314d036bbcc6edc1a1a051a4dcf1a84141a8f79431bb1ab5842ecd6825d374dd74a83be5de3bcc88da69ece65f34db7e4bef1c331775ddd3b6e0f040c988b94565219f1656668103d375ece3a4cbb8f495e5b8ce1c2d12d2e68b2a29540efad72c09e26b71c04ae3f008067f18950056c53eb32063fe85dcfc7bedfbad8ed2fb51aedd24698d94ee195e6df25fe6bf9ba195e830a6317ca379549ca91d053e7ff697babbce2b2e392dfcb178df3300b82117e8a40a3b8d19046204237bb9515ee4de38cd55276ad7ea018107e36cf72c8d0a035634154ef7977743985508b2480daa9ea4473127a490bca38ffc70d75a0ac47bf063b1a91922ae1071174e61e56efe9663b8103a612ca7e5a591eed74273883e9a383004d1694a6d1512ccb378122d9a567eb39b4d7273b0bbe7661784434c78a9bafbd560036aec04656d75ed5a6c05c767e83650fde9e4e4cb6d268a7570f6f2b459318229fb2aa33fca89eb88b2492d0445673299c610686a4a7c498435564880dd0c9a909ff85b6ea60e65f2632e9270431d81e4e7f1c2f0f4732f0126ddfc7f93613b5126b3a7e0baa25ffa3b24bec4dc6798b34923dfd0b4327191c3a61ae0c7b9fff7bcb77f9ea220c1886b70d36a54c9bbf1edbd0dee07415bee5f16955c6b5fb71d16d98b822180e0bf7026a36b58c7d9a1e6a7fe3c6b117632c09bba7df32ef4e6c4f7d0c6c6e8b3413bf17fde37f7b0d6565438d41c52e389aa1c11a500e6a5a26bfc1fcef66a6085a89791f9a7e9b3832f7dfece66cdab759f3093f86d80f0f8c5dc94a6c9f748968023852249b35266a28badf9b74bab24569fd212f2b2bace6b0a9931d32aa2680c8af367e28f31ad3c3c0b2399808e11b039aefed077116991858d8b37fb1b75b38934231b893633cfc187cab21c52aab5c3d53d57d6f42056de5ad7aa5062bcee30b0a6251b6f95da48c2dbf7a0997fde4f4fbab4bf60dab33a56199ead1b2dcd2c86f752efd045a895c2dc439cbd1b30093bfeab3f196c744166746305f3f38f55b9e60a990c1b98d6a4b67769e0868beb73949a4a2e174352a2976627a9f470e1454173ac4a1029b3f74898762d24e046c56f2c9c8ae7e0f2bc51df8dc14d27b6bb49df8d6dcf8fc001b6a882d89c6b86374e63084cfada1cd28e7025c24553936317b0ab6f3e6099587b8b32bff8081f314a2a689f4a50a6e0f6ec0730d50859d11164f3b9099721d1a8f40d351a4b3eaf4272fb9df849e54dc57d931dabf6b6c2cb07a960bfb2a636096481de1cc8eb6b9cc3b00139ff7f53392a45e4e1267c0c9e2b0a8cf9ed36d90ae0b49f3cf74b3f4896adefbf3448d1a2d91fddff958e8d1d2ef2a4846e4d8265bc2f92004350da0063615bb7078eaac7b78c4e39e21c16744a13ccf649ef6c0a435b9c01a8a0159b378d0513cae8751571ac87e6029898de5f37f31354de0a4c60325d587cbd0997b8462d037b79dad0c0c3af1d772dcd4a83f00146880c282b34e2e9e023b612a5c89eb5ba1c21f2567c8107e9c62e881292d69ef759f067e2755ed7d8b1914a50ec7107d9218658898cb99d176b36008c638452901d7b61c3cbc3d54222e26982398b6551acc50e3dac05b78d941eb9d40fdb8e550f6b0bd12c51882c4d3d21030c8fe1be64627094714c4a186625dc3ee2313182ebe14f73e21431670108ee5bf2b1470246a67dd4f31ae9a0d4f5e7d0eff7c62920dfb0f00b82d47499dc6a0643e46c565faedd650d4c8afe138b57134f0ee1fa9a8ababaf6f943123d9c20463313204716991099f1fe234226578aa0637be0c742e0ebdc53701b497b84b35f36612b7e302c1e6847fe220ef1d0726b50f9f2820bec5537f8b0c71fc7efb8cc8b8e3065e3a7bbaff54c080a6ed202121bc128d8ab53eaed79d7b20691de5f41622b3eb328cb1c9f104c823ec0e003b8c67dee53c588c7532f1fe328dad7ea9a691972672577b7ec05fb83a3a0885827dc0a7d33b317f6941eb215ac7e4feeb71a736b98b8817d28af69552c715f2e92c35ef6481be1110c2c777c50d7f9ae2f0c574f627d19adf57353b9bfe9a94f4d2fa40f20a59dc789e92bbd11a8f7e21f9c724ecd6f6edb05a8e551fbaa5bdc82a1d8e508e1d8a785035dd097d36a1b47782131b3e40cdebe8175d7d2bc6e7678336da95b9d682d6c548294fcb97406dfffa8b589e6331c40f9928d4eab1c2c117b9afc7f3d3d523b87ee723693580394705db5deea5b0bb499eaa5122b24f621aef9b7b574c2127eed03d4b8d6567737f9827620d003e984b8ffd7b7df79333f2133bb41c4e5420987a12be565977965fec389039b48e9444fed51e7dd8532fa6be796d3840f660bf827f683174a1c9205f62e3f8b23e056aaa8fe2ae104633ccc7508dc245e7e28e1527fbfb4afb700aaf94f5f7efdda52d33e107e3943fc8afe02fbe4fc97f8ea58921658fd14e2f5417624cd9828a65741c5655093a3b8fcde2431bb9fe3eef25f9f7fab06aa73b16c7e262f9d09b562911f4549e3b644fccf78805895b3f77e7f5b9f0f01349a3c25df4da86a6069fe8054e02033a6608bc7a76ae220e78c96a8177a9ad677f5ff9b2825d888bdc87d65f2c5bfe1dd3ccdea95dbf37b0bac6c561b51899431c60817ced8470dd93d16c74cef044e58db58011baa2fbefd1affb38bb084ad0c86711cd466acca02a211d1ec99cf500faf1250be1d00cda59da1f92f2965b68ee590d5c0a950667503b22e3c30b737110a19a8008a25348746ab97411112b539b0ca3da3c4efd90926a1935e00d0c9fe67dd553e908a60e14796517185a01b81eec5594dd55a130d2c9b3dee81a13246a20d911715738f0e38d4f0fdd9deef6efcecba8a9cd15f5749d90c6de1779bf6b856118d8d4ef97328c6f7d02044f936bd821ed8079aa6692ddeb2e1a185d3e2579462d979c3f7c3009f731885739b63430f2f4facc7dad6ec0ff50ec2496f7c2f711af7f91f26d6dbd27d004812104649f25f6e49f4ba0c2d3d1121836297450446e22d70fbc604696011a15eff8bd7b85cd0a02cfee8d478e696bf276416add819652cd99fe998291115e3445eacd71caca2ea973cec96299efa6843a9eaafbf630f41e54c8c3359fc89a5a0160d8a2d43505c6cd43941294f2330a215bc11db3ffde0e56598f7440074ce72316f5d6c37f9d1f99f96f523d9703c032aeabf7f678763f8010aa22ce201adf3a97935ca492f7ad5e3f8dc5487c19255fa95196992e8681e493af64619aeb8ea72bc96ac0fc5b0a9ab29e4030c47f6d057c4e7b08df3a07d710f9274402ba7f727044b526bfbf27afcb4a2fb3ce1376f94f6bad4054d2606c268d1e2d8d94f5efff4ad1bdcd59c45b1e2d9c5ac78123dc04910351ea3f5eb645b0879f4a27072a4dfa2416e530b899ae6422ddd4b1a29ea09a6a598df66957c9ac4e1ca5d3f4cacf4e3aff77642a6f31296d9a606e818b3ecdcfbccad3dd5fb2b0a84144c8981c83ba154f98843807412b65a7151dc7a048379263fc11d88a25a00014ac2a0432e7fe796d2147b73dbe4a921e657a25a500536aac893b1fcf91a780cf740266604d1c16e1eae33584010c17e17fb18d59fad816ae9316c23f71f37a85e2e4e10482d6ef1f5b3ff3289dcec0f85309408037ccfa5065fae2d21b21de7b7cd5760909a93d28025d7b342b935c1a5bbd5ce8ab3bf4693843f88f5ec444ae1e764a485246d2fa3ccb4dadaeca4d49a37f9f0779390f65cb560235c95133fb13f62a4c1a08bf87425747d27ae18d042f8a2194b22fd14ebfd38ffdc0122d49f115c82c57c4098d9d317d91babbe900bec3c2dc5ea6b830c24195f224e8ef5fb61a776afdc9bfcc86a5c95248356465631191b14f6b6667735c2fe53b0c0da57a9bcc2e9a687affcc05d7940e96cd2cf0df45d2ae1d6908ebfa8b5cde301357e35a4b4da9fa9f72004713c3035e665315d109d75b17779b91d4476105026bce43149294693da9fb63424be6d6ebaea10d7469ed144d0937ad5c48fbf85ba99803b53256c1a847a99f36cf7d084f11654a48e4344e49847b8a57678c9f12f6a498c0a7060072c2ee7ba2bc077c132cc37067eec8ec4512df454f98d760b5b1b1b47005480bdf074223ccfb1f56e344e5775ee77727ed3f05a15c9b4c201d33b44037c8dd28bed63752ac90c3a8958ef61278d7f4a0747b57e97666f0945c2a6117e66da1ccda7b513f0f6bbb75aa18a6a6d40f516b092a84fbd7f00d128bcee2174990f14d6698ad96bb7baa05bf944d6311efd6efd85fe3e411c389fb740b8f9f84b366d42300f046c2440719f2863638aaa63e6c2c47a06148e28249f7c13446c53b924f55fe9dba29ad4885d22e786a1af2d0bd16a515fc901f89354b944434d49a4876213b0aa525d43617c1c5682a500b300ee0d3259f5d492df1af3dc77640de363d5ee1e99acad5d3e8c60ae0df0741c9f505d6de1ae70cd1600478c89ecd76197165a829d591df361c6503daa633abd747d1daf1cd7e2295ad29e06f7870fd10ad8eb98e4dc627f3b5b7ccfd4a6e9d542de5057f5964cb47940c0bfd8e32378f72f5bf3840e9de96f696e75417d821c36da1da51f2a111620038174fcc7dd21109119735e3eb31068c422cbbcbdd8a437285fb58af774c6f0c1c3d8e2efa971a6110e0fc8f58a6a26de383298aab3bd537cf915d3600a8b3bca4fee108e484f689e1835d46e9bbbcea3592eaac8e69ae4350f356937639a2cd86bfe31e012ffe6da7f9cb0995c80ae7ee9f7ce67f8d0217da157672af8ef53681363f9563c41575f5bd26ae6ac3d387a277837f6845138512cb6f20883597ebe1d407b81f18def6d61454d0c3782850ab6dd817b50828f7539410323010b4d3e54df8b691984789497377e96893b404427920ae8d4206adbc70785d8117f146685b72f7288f505f26c0da9356e5ef42bfd667d20e8971ba24db5ad51bc281c71af6d608aa6fdf577a0c72e34a5383c48fe29fe7d2a3295f9f6a7113b81f27c760dbb6ee71848e37db48ca9cd2579a4b07d236e477c863d60b51f641981d61d680df22205f75749166cfc4c30e07b93a757da5b0f0942b77b016b914f15928c5bffdaaa9f1c714a995e6716b1f21727da187f6890d3084da77e2ff794b9ce0126cd53a84297009ba2b7316c9d9611085707d1597e53310de1335abd23f36715b516f4a2c9f72dd77169e3836e1519f26805e5a96cd71e1bd1c5d8c74d32e094d62b05eb988ed61008f81b86a33481a167a360c01480d520ea3a6535f7b9406b351b657d5c33b1e49360e9496c4d36c4582c0aefbbc0906fd5ad34853cfde84b9e2afa3c43f05efbe95afacbabde142a499cc916335c6cab8fd3582402a167565efc28c58b48b17d739d821fa991151f21c8689a070f16efc49e66e4fedf37440ee27ccc28a94b5018e38e1c9b34422f696b238b4231bc1a4153d03e007703d6d8be06b33ed6cfd874cb4d4f3ab0d83f149d4c9ee4a2f112837ef3230877c295ec51a5a08e7f652d8246fbd7d2fbaeb5ea459c76a71bbfc461069ecc36e227d127203c81facad0625d5b3d2d305a16eed57d35cd078312db16ac0712a590f98aee7075e667afb11c70a2137d9227e86ec281b0912534729e511c8b549463baf92ab7dbd0f52b3b4fb40f5814838853afc29f23e2a9c9c444529e62f97b3471daa1debd57d5960415bb9b70e2c12db59c6b5319a983c6fd010bc663a22570aa62bcb99c611baf782de6a0dd86a9ea5a94b5066cea999d5b20223cb399d113c8e2c42ab68943b4f69cfa3be81a2b58dcad41b0fed84df6c7525d576e9e2a0a21941e700801e375692a486173d2a6dd11dabb6b36d56a714749f1a6f449262320cd017da21ee443926af24d72c651820ab62f3633feb0524c181a0d79e58329feb9cb76011435e4e61b61a1af12c7e59c8935a323fe54b962b4bbf73d0e65e079ae69e6e623e99848c755d7a6074086bbfa9bc77534050247c92a52cc9e8a3ec92ade04aee77935d41f191bdcc91d82596ac57021f8328f56cc1f62ebea6607f5b9a7ecb306fd0ee60572efb8df38a2b96a79134695ed4c5a4f471037ce6fb59993183cd17e9dedcdf580a0b5550e80c834ee3d40b84eda1da222f6028b994eb0b56660e54f18a8d364cfffc5ef83d5114a77586f0d57ca443fe0806ff8847c2d596da7b79af110fd7f83a715c14fd9c6450af37352de4b1fd05341911b20d72888773e5ecd1d91a4168e4b0db9e058bdb0d31ceca626ae4bb234c0235f8797b9ff0621169c04042b55374ca4373ca0db425e9f97162eda29f090df641433807d219952eed3d07759d322b436a025d59f7a649f9eb49d5c63dcc7dad2b3a6bbe407a9d69a3431fb2c42820edde3809ae302ecfe9cbe28be4d2ec0c3bce1d8bae1c28d688abc3db15e859a32ad23a5c36f70d2c596dabf552d88ecb172e2e47d83d9345f7a6ced15d2b8c469c3f72377385e0c3c6d1a2623f09e03478314c27b9eb31afa8b33198de629622a440c557a95e5a07a7f36ac77cce3494a96bcdeded7d3bca52f9926a5ca772ae730d1d46a8d5d50fdb4d699d688a57127c8d5ba143030780d3e5214a3bcbcd68e1d81df9216881b95fa7a5315175d2937b7c99c1c10dedee93b71d050706a77533dc33ebd63cdb503778c1c4776e711083c5d8b007d4df26cf7a5bdc5e5e8c37c9e648bb7ab9bab0b5a49bbaa974504916a1e8cf8864446db911fa35efeaa727528b89af070d50f1e4c56ecc8ade4784b707ed8590010e01f4905084d886cff6e37fa1f609b019b802545730d0af28a82e54fb1fac8f515b5c7cb531ff95a2cd22461e073a70c666db4c29691bc201c86b0b8f046af559a818f236fde331089bdf7f0e27997b8fd90d93b042a07d2aea66a2529f508c9a2ff43bbf6a31fcdef9ecbc4cc1d28bc26f365d6e486352d67b01d50f37a0cf60b8e39c1014ee0b84e59c40d65f29c2e268f267b36f3387f3ce9e603342680570ca36256fcf7dd8dd0309aaf63852b67caf00f1d5733bfec345adfe7639416ff7c39b8e90d365ea3d14a7ceb41cab4677d08ada86a17b09caafae18c172cec5f464453b6828bd71bbc97cdea93de1bd885387863230e8bddaac81d49fe0e542f4fcb12091c5679962a7b775f40171d73efb82d13897d4cd2b4eb2a3119982881362dc679c669bfecfdcc19d37818a5cb785b4e25eab22a5544ae8227f7315f76f4a3b3510f60ee4273417a3612ce6573875a0800369144c34148f4caa1cbfa358b1b01001d0fe8917198b21f24148757ecd7e5bf4ef45d4abd79b734f569954ec91f066a75a93a71d2f00923c4482b6a4bf8eda58e9b2f8a7caed027eeffc281c7b3db5c43b351d127193cb98d228e0c003f8637dd393f336cbd1928b98696da303bc9117f7a15310094659c0d55ddf2aa49362615b3f544d40d6828392b906796c1306aa1535b0065051cbb9279f80b16159868d805b277d05c43839673e1b51c52a6e471b3500d76867569183d1cacd1022ec8ee0781ece17bd4236316e8440d50cbb465caf0505e40b2e9d8924000b9262fe6b26ca04ac9bce86561cf760a1b65c49be4c0b076dc5852219aaa83b102e0cf66cd91de5277f474bc24b200e56a2510932495a415a9c5b8dd5ab63ba6276265330867178852214ebc0cf1970e664b949ff66ecfd793abdb2c6045862c311b7513748981ff85e9080b1ea395a01ce61cdb48c1784071676b728bf710b7beafa3297ead2e83476f15bc9b926cc2eb20f9dca17429a9cd5bb8d9c04ca1c0d64ba47e5cc5ec529d40fcda2ed50798747e7a5e02734d9421b2d80b80a7e7a52377bf10cc7505be79f5fb46a7104d44b730908c05ae13e3f6bf66e804447ac5b0d39ad778d57aa77852c8f84f427df1a65da66a5099f21819696862038600d23c9a8944cabdeb057eb999888d2322a47c0dd3f70e3619e247bf09dd756e975271351c19193192e62e83ae19d55d3ec5dbc2110068dad519d75d56a919b014885c448e674b3909148ee819f9f9cc6727fcb0e0e7441f41170146dc5b2213a1f5125d9aedb88996ed14e17cafac8a57d50668b0793c6689b017ec12c3441f626904e3bd7ecebd661e699e59543bfd60ad77a2f7719a5801e029d24afecb5ab9502d36592b726eece68a29b05e08f2143c1a5c06c4d2fa0c013411443a6b496d9dfb5ad8979dfa829cd86e679e08fe9663394393e888e33bf206e21f64009e1d8d0990f821bfd23680256612681d5db5bd2103bbdc6d658c45ac89c75bdb00b20d5b9af3eb328699aa79120295e9b113cd5db39afda6ec16909ac17b43b9903ecaf6bc1a92384bb04fa9c1bdcad4cc1ada894d3cf3facecb6c2b741f3d747cb333230b87bceca582369225908bd9a785b37dadf42e2af1eb2f2af750bf40a5fdc4056fec6ea817685eb89f9b5fd3299cd7337c2ed352b7cc8c53745d6730db3a025c5a5639f2a9958638b409f7053bbc3168fe46beb682c8d96d165af244ece71df7dae7e8ac436ddaa13609d1d59ad31e58fe9a531ff68f7b03de685338a1e5c73db524f983098044ecf6d211668883a62c08e8c98e6a702360d67c41ab3afdcead0a4910a0be09442179045d7e0ffc7acb45a3bea2ecbdb5e81ea5b826ad0b09d66ff55ea1ab529d1e30b62bc4e3035993ec98d403ba9d8dec6f3c18cf709b02285c5ed98877c0d52447328a1c26fef285a959eafa26ae05e0cda3ac345ab14b3b2c8390c430f2ebd1db9c58e40137d08b2166543ffae72169c365cc69194e9c29084fd4ebd17c2012f7511d2f67b7f738f96132d45e865a851d05bd0dc9c2d10feb845378951177df3b79a58c5691ac1774f46c177ec79bf761e1d8584d107afbe861704b3999369e60a63f9a590783a61f9515a9057c555fcf3cf19511e29c08aee480b92b81306c3af46a1d2c05f602cf42984b6347069e86d216a255eb3d0e8e0809c1d80b28dda860d015e53f65d851b48ddd611785dbd491b275f73d25ab17e34a45fca63a08bb540d8aa2b3bb26510292f9e4dfbc97e43652b74e3d57b9b1f0d5fa5ccabdf1ce27e723f0162cc01b985de230c44abd787c24577e88b90d909b5a4ea684cb82c9a75c7d077c947f522d8c8b475507a3ab3465173975aa63b30ff3cd016d74190fa1b64f463592304aebc69e8c2713febfce2fee25af0076ce6d4debac4cfcf405c2d271fff9d997a8150310a3b1f9d080a835a1718ea8f133b585970a7a3b18058b0dcb9e264d10d990d7cd78a8a00ad55fe64749ea0dc4b08ff7939c097e7c489127caa8fce2252dd0834e15270143cd693622299ed195d4a8062a425d218a43ee911e8d3e6f83a1d82410b76c47ac351d8dab1ed9c85b519ee3b471dc215b61fa48416d76ea623089885c4fa4faaa201165bb6cac908547ee237c48a222925d98563fc05e1fc83d2eca853b71838351b5589f68db2b2042023702647e4022f00cef0eabb09c56bb2d6bab28541925cf0fdf98f1bd0e3f6390a8819868c2dda6955e2d1a70ec5511361a4a9ed3133736571a6665897c82a77a0f46befc9e3357429c2d2af1826a652a954f56ba4d22238899f4f9fce7e9cb9e25243fd414543a60ccac9d1ccb21f612af61e4c9fb37fc32e50be268134a682e3f87a672a0014bb2443bba9dd49b6127b0f6152e7e5001848b84dfc4ae4c7d4d7c99d04ee2840e8109d29665cd78bdf00e10cbf5cffc5f21dd826114e86a606b7d9b31a79d9a4aff10c144e4fd4eabc384f7f53b05d10d6aee83f066099c9008c2e718d8dacd581d0f34f66e7d97630f9e2c04148972e4169c8eda0fda226b6267ddb50b50ae2d8bffaeb4a1e5c8f6c1a81db0aea9ca03e3b2329c19381c104f7397c5a0657297c3726a28a6ee948af530a41c337e4f9421a1290a9f131c324bf2f717b4355aec5d3305a661ecd249c9a7ca2808257a07c28667ca9c6af736b521f545ebf6f93bc7c4c9379aa8e057bf3c2d9210425a7b4e0be27a9f5711995e6cabff466a8bc5a4bc71435aef98210ea80ab5a2a6809dd3b5d7ac273291fb21ba770765308d3a39af6b1fa09acf0e0274fe9472eb10088f181b263ee5c5b03369e5c5e56c813289b2dafc241e73bfc9d0335fffff47b6279f83507063babba34f25ceee2d9c5874352b3b926850d94d6fde9bdd20aaa3ef8ca80c2258fddc8eae8cabdd91d28d084438bf36b07480499a956d618637fbddcdef465d6137bc7af868db11ed14a60657895852df855fd294978acaa2426ee75804d35e5e90b9a898d82f31b35af51ab1aafd3294534d820de5fc0abea2a20927fda9919caab9a7abbc3606fc31ffa5acc709a7fe1132b684e250d8e23e59786050dd17b1c6af095f4101f52e1af2dc05e069308ac1a2525579a010d10056addbcea9199c55b9f9e8102f423274fb25a52522cfacda9f00cbe4db2944cd4e08aa97bba64452dae4be71caf7c7ccfda622b1e41386896246dacfcb4e7b380bc04000a24df803a3b5f297076bd86fc746437055c05d44125b94cf94c1f05fe6796b9bc2ea11eb486af2d342c380888c12b7767348d613fd04348aaa4aaa5578adbcee6660e4ff7a4d553b467920a4bd57e9fe35352adfe56e5a1a3f9cb7f6448de50999ea21bc490d67a8a5a6a501b4f34245aa9abb3c19761ad288b856e4e0efb0b8d3f4c6242f7cff90fdff9ffbf673eaac2c15192853d3fb6dce0ff943c51cc29df90526783cefad57b92a87ed99084978fc44033e240b2621a8578f9b93f9b2bddecc71b84d00cb590fefde221db847c940c9f9262034a063a68a1afe9a7fca7d38b2b108b6eb6e1248d8e862ad45ff632a54d24e93b01e654b4fdb121ad23cb08153d1c8e1a22554e025dbd5ad0e270ff1de00931c85481d9a4b41c751c34e288261f76fffb17c6830d309a1bc56304b3aadcf40bbf7d27797c065d2818e507ea6675f36f47a8635310fc018b01d8ab7f57fb964087ced810a86ef530d34d945d5a0685e8cb8bccab4e60e8dfc8ca6e73e8c598ed83d937415946edfbf1bd470bed73b19dc334c1ab4a3930143ceb59c6a63dc420f7358bbc47ddd45dfe9bd57b7c13f77b87f50cfa668c4ae14cf970891914f50cf855f7b969e599e89f9db9c696c72039fd9e4153e7448afc1bcb4d5f5b0c1f01cf115c0b80faa15ff8ecdfbca8768b4ce32952a945dd590a2da60a9d911013bbccf50e0e81fe0a7906b053a48cd7b7d680ca5c14cdba93a43628977344f616145ac1d4b3803a084f70571c9ff02161294ed0ad36e112b12d932cbcd94d2a0412ff2029080cac65d7df450a55caab8a58be1185f9c122cca33333df0d5333f7290789022ba0968f1237a91c0d88b44a9de09361fe97f51f9c67bc130789d0c2a3df39df5b2f1069066fe2c3546f9c7f5ad3d4078cc78d449cba3f0b6a33311b5fc54cd6861486733f745ca9f040b5bc749dc105a2902beb7602e8c444efd279edaf81ccf6fca4e4afb97416824087d6f8a8e34e2fa3a5cb887f8cfddeb1c1c9c6ee98c8d0fea5540eb1a1b0f86bb60b281ffca70f0952733f8c6bf1c6e4ba82cac4eaba3782949cdafd86f03677414221c3c81f6518007b0940d9c50aafce08d8c954d276559e211089f1f96c6b0ddb4da9344d79d5186d7dc5113cbbb4d2d3e97e496719e40b9562a55a3e41010381e604802371c94de5d6fc7b704753c915a5c2daa9afc2c28bb9708ecc1b207b9cc2da93d35ce65e7f03beeeb9e5cc95930f019b99b15531306380659b9124a65f15ef03799a978a5c400932a1b1fae3189845952a4edeeb88e79b00f356e50595b6555618cc73562db43646a6e5c69e2ac69effb1a9af70caaa97bd3a15342f230ba13397a0d920e9c9733ef717c36762f24ebbff0da32d3a44265e00afa15b88c3bdb06e10013fc01e8a550e655add1853838d6bb5f865703f18a1399aea1e5c4ee8c5fa70c87c5465d576f8a4b8543fedca5155e030cba72acd7232d5ad93595c9559a870e8296a982ca149c1a9c3953a46b1a0813b902b6c76b4b5c60f1265dfe1f479d62383a57fe452ec0956f8a8145f12dd00ad71039ca547bd835a2896589f33d34cae534d94e2bc908eee64b838c8513c879df66dae72c2f6db5832621eccccd719153960eeae389647bcf01a620e79f39be7fe50eb74912715b5b01ec2f3d8815e8a31d1f41eedba8912328fd588b007e4a18fe4af242bbd91bb807db6b2b6fd423c6a71503d0d0aaf5cd7a32beb0b6069d0a4ad3a92a88aca06d1a5a933fd3dc8c4b95ec49c6d79aad4864ad13b3577d206027df04260009bcda14f07da11094c5d8e263f071baffd5062f7d823cc7911f8ccfa2fe515cca766bb60367beecfbea4a9f48214820629c474e73255daa8647542655083a6e96cd537080a163fbc55f9de922a2fb241b8645561d8d1022bef2013e372df0f8ffcd271a5978781e10b4088fcdc1996c7c94afb0ce0cad12a6c198ad0a509f7142b96715c3e0cd3b2be41c8e1dfece8155e9ffabdc6735d4997a9b64cbe1350c4430e0c135595eff68d8eed1d36ad7a025f83b5f9486a4ad306d777e2db7adfe1ea08f519cd63bb561d8d8e5221f8a11a5300754c2a04db72a88e735cb6630d660d7079428bc0d43525481787d97fd15faf62a7115293dc7275412a6ea7af4862a2a1fb7e1fc1f35d8317e500f5c2312c6f4f8d36942f75184e3eb5c5c978950952859279636e70b5bc96b64cb5483525911e33dbccb56664f98262c0610080e3422fb13c5d2565ea58ae49f837abeb72aee319899add94811bb78023f4c11b9a4fede8c4c859695494ab48d6dc142e83fcb1dcb5beb2e4399875f5a6e8627cb66a751fe6ad3cf9756abac8e353c87aea2036eeb7d56d7ccfc0b3bf069c4d91755540169bc8b6fe628d53689358a7ce82fbfb7c1e62180ad81279fec2b2d5c7e51ad278f986dff0e3d1f89e96d933c2c1f950c4c46e069e5e66f0c79ff7f1e4224b7d12e4264274cbe8513996705d033116cd4a51dac477805aaccb73f9405f281b31476676f4fe637e649a83364432a3cbbff9eb3f1d745f23e9a0e7055b0afbd1b5391f2ef05dc8aded36757aee57e19734cbe4e5e1853757360f26e6325b13e4fc23b6edaa9f95a0f73b51bfabe5958f5a9bb7da44723516f710532cc16c92f3a708aaf7d1a923ccab22d87a4490ebd7f4f6fbfeed0a5086ca7c05b8833f28c4226be6244c9572c1cefa06b0c0a85934e2c28666e6405a78aac0fcf00f32ae4ca75e2ae284b1c51aeecee836ff0b52397e9fe9859cb609ec2b4ab9a1613e973307caa99bba00ad3f105bf2b535b44cc9d45cd96703b9ce320ffd280a292a674e7f1a262bd7c08b4c2754f06ff46d588f2e43ca91998a89c3580a05cdbad617c3f62f9d8892efaf6dcb201a620bf31557218cb8fbe56fe2e1c206f28d283d9c5590d9ed03beba81a2af72c92a27fc9aa9d305d39e71127779df74b935413e0e9398c6836e7b05e9ef29d2858591d08184f67dd456c02fd350799695316b388506f8d6204c2097a8b49a0901629259bd168705a3b52d76458521a0e62a47d3378d32ca142b6dce5bc9f9522c0850702fcecd9e21d024210923d197550354c30e7a63a91965e6a21e7bd7705c75adf317f5cecf4c13ffc9a606f39aa2095b4f976e93caadb8b5e0c534d5d4a7b52aa27a7dc1f0b542e989ae5390bc846f881cd703257c52e51d888b1e327037cb1f4b94408cc6348809778d403be61ede40a464ac4aa5211752c40c9aa7aac70add05e2c99a42625a8d62bab3319b98e2437688135310ed6e19dbe9a9f85110cbcce34fe4522043219f69e153e3a1b51f7f491915db14174d039b3e085c9ab8f4942fca03fb64739391a2f5d18821a40e256b99345d8b61ce0b35276e84d1c50c809b73f8ae866a200b94faec6b730eebfbf1e78a63542c6f0e47c57ba0cec82b18ffd22dac8088df828a0e68e8249ae3c7bbdf14c8bc201dc1f811fe91eaa5b9bfb886ea3a3567181888a1009d73a18334d1ff06d2452616aea48359432e9d25e73bf9a4778d6fee3ba63ddd5cd0771885fa0638ecb1396abfdb36fa3104f07e95d92397da6ae7455e76b662f16e3b43dc0c487b4f0ad4831445513bfc1665afc77dad4df2c4c62e7ec49279f4fd878129da432dad639bbbefe0402e21d4c541f9970dc7b894ba2ce48efbb6b8455f95983ca76b33fc4cb4890a34f68a4c4ff88161d665fa7aeada5245c74b178b072f82419f9889a126f4807c04bdf7ff656de7a5e804f723038b8f5d7a9bac9a43d780cfc91481f7547177d61fb9962b7a54727a914f4ec0b34654fccd2b8bf7a6e5a2d64e261674e30595584dac26e22f66fddb529fbeb0593b2913b241886fe160adb943b79cbc48ac05724967673d1bf0bb757438909e6f324ff8678605eda046734799ab4e1fe92673304c7beff854d7578a92ab575eb77c3b2f050e7b49df92e937d96ba2fb11315bbde74ae22457531823ff63883b5ee40a60a7a5f0acd167613e13c31ae574701eef75cd60415804eb9fefb02e820fb8a7741db91c40854d8eae1d5b0dd39c6dab8af2006994a78ae7a92a70ae9eb02d327cbca6e49e46eb0c700ba932a8ff308bd0449c915a0e6f2c075c933b0211b5054fa2cb9222ef13da69f59836629d762a8a00e37749827b071a3a3943e4f069a1507084d6b879b506080f0c75257319e0b97f9a6648ea344da761fe5befb67593c937e5e0b8dbb2b55adaa26321b49f6d5f191e8611f1519071ecb98bb6cf249a5331d0a28aee7b7129cd71ee9d910a9fb5ee9fef6a03d2b21c483c3d96a24669f76d2a7905b7cd700754691a9614d2725628df877e2ba0bddf3534e5bfc41ef269d2c74359ecb9f418ad0bde2878ce9d5f290ba8cebea73340b1de4b70d63930fbac2a158c53515f917cc43cf8a7b1bbcda1131de05b00cd8fb35ad7b4041f9f07202706389b1b59f785bf30f3f959a85c431e35fd8952952cad6839d3051d9608cac58fd7bc4c8755afc92f314dd01c89d1c45c8b18996d0e7255fbe0d1c054a433b57f9b152bb8f2e0539304bcaa5c202684b52121807a2898c4f01a5be5cd9dcf95001dc63e79a50e4ba7aad72894d180c2404d21b3fe35d9437bfcc3af4d587821352e09eb36dc78ad60eb487e13440e751ac31d4b262bc3060e8cf93f44de1ba1c70b05416c2663e40c0f38e1c6daf93ff93a88ba57129b3d8e4ce68cc635585dc5b6491f3f8d544f6d30331c428916c954f10413ad95b2ff7961cc1b0bfbd1930ddcc601b42e1cbe0d30bde6b5eb624ad52924435a46e2abf4d64da812711b5d20b517dc2c6fd949bbb095ac05c19ad01478de2592c70e0ae42cc84e9fd32d4f977f58d99a5548dc69c99e26c682ad68fef17587855cd0aaa36e6eb73b67600b0d53030fe901637356c4f1f496dcee8b3f7cdb63b6c8ab8923ea6be2286fc135289fd885607d2399fa655430e2316550e74fa12f2cfc54b002f96e912b87ff979f97333337ea45fec00f90223cec8ae93a7d60dda74aa5f36f823e92d836e9597481f034c5f34f4bdc4fc08f60ec1a7fe0abd9b0ea0c1f620de33e45584d0d1034535734858b5feb5229feced70fb40d6e4a0ebbe6ee58e504500ef93b3217b278c0466dc6df45d84bc0ea607d61cd623fa02d200bb844499967839c74e3668ec5d0500f0f4678d01aff6ffd82a5deea7257c01e98ac90726bb36ddd09b64eace8c866bfd72e071cf1f1d04f3b633f100c89ac37663e849bb6b0d5c3e2fb6f5a40b727be31b5fb2d4d42e85244b294f18c002d18169b73c0219091921080ffcdff055789e8a90449f33a58e95ed049f35e0ffe6a074132c2240cbe2ee4e2fc104f5027305680673e9f14160dfbbb6c4a5c9c5b01ff96ba6e83205ec7fc6fa11bfb21b7479af1365530cc632011710be746be5bbd4a1a8857adcc0c37fcc57ae384c838b8462a734e872814d809b925f996eed1716a707fc6d9aaf15dc7176e52303cb1b14fd03d6c8f6cd4517de2ab5aab6b8f8ee54d746c7e2276db45ce05b58fe1d9f4e31459721038458cc5b62cbcaa61e48d598e4f4e0dbc972a8b44b10d074cdee99942c89f2a86e21df6a104aefb5a923b73f4f67586b526404ef8ec7ba892c224305e87d1d97e694e2d02c093c9389c85e5d7a7e877174951a279919a8dd89056b5e4aaea20b6cf7df41a81592aa470d3956e490938e91da79dec05426c37ea5fc8170db68fa50fb734352b09d22841ee52105333c255841bf8e57d829dd808e88d904f646faf373d2fd4af59215c12e384b08d8bd89ab7a1e9d314d8f1c63736e95886322ff5099be5f714e65f2ecb2f82081f94ae0048b99de3d0c53e574794625122e7c5d992d3421210e03d3b1d6eb237c7b830bdfb06b5394e79c05ce58fdffa9dd953b15f0c76e7fdf8d18c1d258acbc3b96e70232111076356498edfab0f4a84cb0b4c806848d9dee5892f9edb8800d12842ac7a26ca2d4784d13387fa6a89d58a63439db5aae887e10fade10c8e21d76461c66b698870b19f1d4001531ebe98eaad6b1dfeede8f08f93d350a6cfca34d699e6a38af230b1ccdea0dff688a7dc5728af0c1fc3379aacac2c8ea1c877870ce0e47c4caaf8bd0e1ca99e07e20b93e515921b3db5aa19821f5fb3affa26ab381ddb336d7c8c6ca029bea9916a66b302706eab83b78c61df1b3134f2a98a9821cd479c30cd083554197e2dae166c825516b1fe67c716a84dedbd416b409f073d680688135805e042edb91bc22618520604370f221e271b0493f2193277244933ea4102655db7b773f2a55750281df4dadbcd358fd41f30eb7169fcefffa3d7605a5cacc5003a0fc84055626fb59213d0fe12629a671622e05f529541d71838f452b36835ff57070af1dfe1311110172056684214196dcbdda2b50f89cae84bddb7cd430d321d625ee2f14129061ce73b9fda7502e49f5693e85006306777dd11506addfd6ed43bc0d3067aa3a446d52e955b35717ca28a75874659e1adc9d5b16489f018b26bd5ac1bfc127e13d47cf278f8db60b6e0168ca077687de79c30ab32be423f6782756d2ccf476239d432bdf9e79002b4504759c293560e91ee02c0e2d5bfa3a9357751fd1e310c340d1a2a7e0a01ffc0d02c696a5bc1713ffe21d3062fec4fe94d0909a9aaafaf03cb93bc53ff1381125a622c6d8ec9232e83c469bd40e1fd8300a4eadd86d385afed83530480ab9a0bf6e96917147b36fab84f75ba14c4dd7a0cb570433b5f6531449ba8e3efcd59d7625b3e3cce5765726c1023f71e3d534f3f1fd366cae2f08365f43186b79072638e1365e17785171d02a7a8cae5752764cfbdff5bedd19147b3cb9a6499005778ce6a453746ef344bfbbeac557a75163370de1140f524dd576ce106f43383065c2a9bce4a9cc7ba9e6de4d90ae4fff5942cf05f47f068a5e713bec15057864f93f4896bf3425ff72af7f4df6d6c40dd7c2390c83017d13fc009efc547e32afe88c8c65cff467e854f8abdfef86a7dc50bd749ee0f9131de5115af9d83087c9f8646d23bac08186a067b417bc2d9b783efaabf153a2ea9dd670c099c6e4b10e6d98acd1e77c15df170b2a0714570ac2d4239e7c50d3cbc28d03fdf25c06268f7312b3818815e0f91ecec95c8a389a105cb1b335192fadcb94157f4b60c9400185e51cecde65ebcf53330c33b78a04e32bb114c4aee4c1e2b9eec957b394b5b6b94bfe84e7da376cc95cea3b640a5e5cbff63328bd4b65b8312329869970f864722214e319e9b9d7e3fc05429d8796b3f177b581c6d32d856e0dcb12f1d2ba2fa49528ce51a455b52bac379","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
