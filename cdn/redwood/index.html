<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"876856d2daeaaa542af8b8f024c2ba6e5483d7935e0c1a8266ca57ca55c300f35f1e9614c4cd40314b9f8146739f6e865480f7be530e2c77f906bc85b82f95071224403d630359c1da56c2413197785c253d7585d282e1b22eebdc699638019421d305c9786ef7743b40f0f0dc2dfb7d25f44ec3ef5a1f69125af77bbc1e36e5b54c0dff4fa60cf48293a22d9e34fb54c5f50cc197f5f6e02388d244838b6aa7185bbc741154744b05f34610b2ac944226eaae28a1898dc81822cf972ead07b64f347d6e00feb43d773247f7f461e16841d4918cb2399cb2c96162921f454db966c72006db16a0b81396f66fd75708c1d30f6a32219b17740d422a9e76648447d194a7c936a3e6bf46fbd38cda80eb3a38ed40487cb78d6324355c50b23e719858005f3a8984675b60048e4529f6e0a867852ddfe623129dcd544335a52c9fc9c97b34c15d0fb6b6c8d660fba67915e6912a42d8430f207d4111803c267511a1237eaec38f68d7d00d99ea4050fdad07a139f1447313d622b61b90435ee1b6ac57d900765a7b9dd3aa9f6708c8ec8b0d4053fd6b61c86dbc9482c3bf4272f0688f1d7fd3e1567117cdc208fba8fe1d711379f66c34984b996288c1d40a2d498f91a69dbc2425e3882d22d05589def59a7eda497208b1ce16fe53cbf8f15cf87a781529b05b27b56177f925e4b70e944454919aa9fa669c4e9737b3e740a7fa1ac7bb9b94b8cdf8a38b665d06e4df9124bc5eacbbc03cb8f5ee4136c28d5ca3b834a52c95acb20626e1774f3e18de9893bccec94ee7a9252cee779460d7cae4de917c50006f6fd951c2843d3438e66dc5ff1187a59b5254475d349ee3e950148cb7a7a800ff211358f593afd1016f4836e142ddd52ad5ae1b5108491967d4e651d284362e74ed66efe093bd5598dd7d302a15de151012d2d388e0716fcea30255bc9ca13bdba01f1ddc5fbbe1a3296333caa183de4f93756ecfbe7e961a00894fa6f8c7187ddbe2d4a35ac27bf34629dcde20bd36e0f703786834031fb5239b8726c0f2d911189d0abd63eeb8fe777e8356bb03193b7b9dbced174a6b7c7ca0e9911a5156b2fdc96089239663c83daa5376f006103f07ad7f6a84bab5dd54a4a5968f00e2a548494de21d0c0381b331558e370b28a72a4dba7f166fe858f42401308940c2be9b10a4e4b9d9a749342e0587e914fd5f893721f7ec8c97393ae46cd9f0270dcf3f31d585d48454565c178991ce31c01e5a7fbbe1c3a70534aa12845b1cc40f5561ebbdad729e92827c7447f4ffb117547f9be6aaf511081ce434857864b1902f14d7c43a7e867d15260664372b2b230445ff9693cae06577fbd69e576d7e47f0877f1fad8e40732934c95aa2f0c8c047327be0253d027749cc8c8a72560c8bdd1abb67fd07641a217a12cf578a1b91153f3f4d3115812cca25aee47af4c048617ef73ad777db593fb057737c2897fd9927666cb2323be9c009e78e43b359bd5c1df71bc5b6a0e9489af0bbdb92e9dd227cd68bbcbbc7aefcfe490f6acb48a3ed42f3f5bbe7d93995c6a84ca7cdb46112b12b987cb39e42dec324f72144ce21264f3e1886fd5cc88afa4d64b7641c7157983e8e8afa1ae632da8ce5f05d274fdca630a1c7a2aa656d9dd87831e98b25729e21bf563cfc65fce8d0c7ae7547c1d5d414bc0c1ab3361e75c44f65dcb0a3e3381677425cbf5f10a91148613a420a92f00b122558c8047d52a0d2e300ff3e2312a9be51da53d676b655415efab79e231b642bf61a4a34f72328bd4136e7c92357612c7fb35140b687f8deb3a68f376b2d23e6f64ecb6b00d95697e122ee561441189c2f1a5cab7fdf9ee2e15d127fc58e696a050c1e41112540516203c0ab9f684daca5f804ffa714274d1de0be973523cc6daabee49dfe950a774540439aecc84600071dae5afc0410db18504a6449a977b1265d1c3c634a23fb7bac7b55191cb32b5cc0cdaab379ef67dd6affab5852bf80d64914ff9c14374895a4e322ee8c951cfafc806eaba8c1b7df43a7118fe122caed7d03339741af7349e036ac0ec8db0bba9bc0586ed4ec67b025f9e4a05e59092777493f9535306bd801b53c1fd5c861cd8cd65191f893694776290908684ffe4a8822c341195872573a9abf6d5dbb21f3652fc6b9c27459e5e37e1e078116d975d70d3e7f992eef68be5ab61eb56737474d60d1eeae3968a52ff4d1ed1fc649121f59692e1773bcd7f4b98971a07823d7602de08354cc3594f9b21f72cc1f3dcba1522df2509575cba5f8fecb039343f762cc045983d11446104b4547b418a092a449b09cb1299991f207565f92bce7c63b8f40cb67a047c517ce37ad13a8948220564125b0814bc52de7080e3490533df1fb2eae1fe4a98f6beeedbb77b31006ec0d701f27453def86b8476cfeb4a68f05ee56bc4c5a39a58d2848a38d2e31e1a04e021a96131fa1c0764d6c43aa4034119fe35d72fe72817087ee3b3fd74fcb99b413ac8c3ac651c3fee5dde803855c63ccac3ba8e2bfe71c9c1d68cf03ba5b325c07504f0066cb15e66d760e4827a83e9a3519f589802fdf519b709244f9ff24407b2f8a4234471d90770a2d8203942d1b405840454f7217bca0ee87754c15177d7813a1fb5f4811abf92990012c7fe117c351fe476257dd4051fef289716f078f3c198fc41b77c1af8a86b97fda47690116f487bb3f84cef03b4c4f20dbd9d59c35df3dc066cb5d1c2ce05b9a68b7263b02fd6116196c14fcd68ff92b8a3bb126c0e3ebaa655c3aee03156eaab13b6abc8611aaf899fc6db98bdaadd16d0fbcffd0a04d39b17e89cae2988c62832f7faba523e8e6ee19a3f571f85539f2ffc9f0fcf556d218455e29fb4cbb277219b54106f790de254a987f6bd6a02c29d1f428ae9af942b247c5381cebd0043a2b685bfc7215a32f4e63218ad305f42b59cbc39fccac967221d702a2179403149bd5a9ab30925ca11cd8b4213a3ae25f4376ea5848da27f92e7db526e7409380f286dc341fe1a15d63765acd5e765ce336fd24248a8b83c26406c08785ee3b0810591e4092285c54becde96a5faab598e944dea489657a3e9780f95826986c03f15967dd6795ca1c8c9d56dead178b63e2c279fb7d83e09f607b2aab68633c52a9207af7a8e7370946f9b40a3441a37d46d0b4c26dd4bdc5fffa2f0c483e177f1975b9938ffff34a4537a21f059d4b356f9d8ad31a4e32c53bd0ae68f80066335e234bdce2c5c7af4f8a5786ec765b50bcd0660d3bbf8fe0db62f29832eb88460d8ba61ba56bd898431fe542be2f9e0f1813612d77a60ee9d2b8093bd821ed1fc9392b4df4e62a39b8713636287ffae319a8df569da999bc057e807a48899f8b8061f6609e6e56d50f3256c7af0eba2555ae2047443003c9b9c3f8ce81f53149160511849b02a755656b361aaaf5237f2ce590fa8ee0208a24282176e2db2f984524d1b77f9a43502f65c63b4938dee4ac31a760da411590610fdf874649e05e6c51c336b0ba3c7a5d5a9a8fe675a3f49818a4f63e220bffe8a6cb85bedcfad6d398134fe940b3dde203469fdef76e9bb4dff19eb2a7dce824955a11c37aef4237ba029b673b1f4984d1e96e35350a166adb72ba70d48cf591b97d8710c26693c984fab24d4394c5d5f99c5b1b973e7571d590fda89a009d058df440d0e057546d323b08207155e743bfabada1a907d27bd9f9dd60c1f74ae40feb231670553ae1dd25cd5644b8d0108c1bbdcc14111b4197eed864b4ab6e177f909b8cf5dd9a8210d42cc46957f5770b3289daa428e78db796205f1d80327a8b4c2986d5f2b37d7e53476f2f344df40fe839ffe3cfe62fa7fc18900068476f119fe2be4c7ecfe7a9d74134898fc4feaa078b7debb12fdfa23a29b5ebed6518f0eade6002ffef6cd2f42fa97ba6fda77e2520b910c7b9a76e6b316c63a3e3d73486e5eb93843188f17461d2263a9799ba14af97ab5a8d1d6d62277e418ec2ecef9d60d23af39837fe1d713e038c9559b66cb55eac7b36f67aa142a6c43d63dbb52cd87c5ce2e6d36aed89e31e570cb747e9a9281a7f524e227d6e6c481a0b621e60869f9785b7abf9e54b2c74be7402126d09c784a883a4bad3cd989d5bfad4299529eaf25e4e553c44524c07ab62a20e6c11004295bb8b6ef5f5c369c7c8d82079486988160c633aa51539145bc66327cb8c2c6b84d3be0489cd7efb1bce7d425199aa7f92f219d48c78c6f5bb82984b3d44fb1b6bf92f18a0523c07152f5acad40ce1266fd28226eb7a73cbb2b30d3bcc8f8bc9fd0dd9180a4a21d879be8ab80f5d60caa3b9f1fb128d759395fe47b2074b16eaecb8d8e102a9f0bdf049e13a72fa997e9ba93482ec848bc6a7e40c1df7f3ec89d427ea3f7a1f94146a6acb2cef4fcff50b88a83bb5645f69409154b8cca4b813d134b6c7f96a1d308230ec715bbe3ce275d30ada62090119f754d3012f1b73a75884b4ed40e744d99a53f9beabdd796e707789575968ae9095e622f80f6afc24db6dfd56418b0f1f2526009eedf35670aaf6c54f7e396c447b082588ef5577682725b80952119b2171bf5ace05f515f5ec45d0be3b32c881482b74c1871d744b017fc9ee2d24fc04d8ed3ea83dab40cb70bb460bd28b8ed17ddd3797294be33cc23f1f8c30a4f9ae18631a2d4d117f70b3665e251d37e1970e768bb0ac525c15711b1c3711de575db172cb4d94e4cc7970d105833906cc9631f787c7cadcbde038d39afc6ff3b3fa7fe070d4dc2fd3bbefc2ab217bdcf6e267ccd131556c4e03bca9f8a8c16e5c0a2af9bf5c20d54ebe1af5008becff3301e0e74e36791122521e554324327f8055e8466a4189268a009f997b3342b7a113b6a3ca339e0fc720fc77265f74e5ecc74188a23162428a98b9145e99b6a6afa9e5662f95ceba5a2bf0af6b2cba01ccdafb2879ed0b52c3abd1914152aa40f75edbe83a867c2900c7fb6fddb577479d0e456b42ec574053e17797b19a519a147b73c3cbd2b7dfa8d617bdec5a31825f807701f41af6d0ab93a1e78c17795e7322a6f44bde5c7549555a8a74f3343e655cd88b99152aa8bd16816b35b9ff23bc71ae6ff7c1ce480fdc6e0991a98653964fdf1aa0ee9cf8fbf50e5576165ff442523477574e6679d6f48b2477395a8f9534f19ad4294235cf3f1dbaac883dbb4af47c2deac3a88ec6f7554bf37ef6d36c95761abaa55f860580c27815c145370dc61902a02ac621ef053f5fe659f2ab555b06c3aaf9f6244b4d3250adc06b24b16ac8c84591d31657f0916b7ffbd04e6e59f38210954fb7751887aed4af9820199fd8b017f4733c5137d930914aac77d49e108b76fe37ff9c6485416c7c5520512a029b553d923491247f44693bc0ef1438afec6d0d8fb4b8a3fa404788479a37ecc053f2d5f653627ebd367541d14e928a35fe139c55993211dc68f2cc1bdd7d2f19cf43a17ad9257ac69d575feb1022f3153f7b160ac6a671cdb50d7e1ca81473ce712f5a1d4e6b0a882099d8d02f936f9fe9cd32625cd374e36b85483db15bfb8ff1a1c3149b117be2c1b8653e2ba091abcd6bde76c22305340039685b77266bbdc6771f613396277321277850a06aca02e3e6d31606dbe6577ddfe361128e0390e18fc740fffbe5f0d7533485f7af5352a575265cab71d5e14762c91a55fde05b27890d8ac50e7bf78e6c1776f537a7e6e827a8264d9b300c2e0a181fd492c13652bbb75943ecb8c71de8a72e884ec2af8e3c623183be785c94818745807dbfbb157d4795a996ccdf56468f0aaf31d00b94d81d107fb7277e696be41c03c45e39670527c1c947ea279979f42b75fab4a2fe954ee4f21e482c662812bc6867b8afe02a3a32beaf6eb8459977a72ce86d94938f9c236be479c571fb040130ae510e8f22e210ace746b0c1633501f66ff6797831fcae9619d81caec9abdf7ba73e9c041be3628b4bf5fe07293f942b5323a7338781a82f7b2811fab9d3d8024c8c833d2fb401f7b9e54839a6c1493aad68b676092fa30000d1c0b53f65f22218e1d940d31bea5681555d66d443cf8ed5c65f5276d827c54040bf9d284c713a392c8b240c2f03ae06cbce7621086e2f6adbad66539359072cf662d8e3247bc048e4a9a37181ca231cc240ffc71bdbbeaf2a4904dcbf85a9eb8bcae15d5462e3ffddedd8ad2cf1ea742b8d464a2c95d4da6576455a208989c108155e631a65d03d4af573607cb8012ce93a4f5a8a99e9736f52bb1ca30f608db34ad61d6e2704e327ef37cf2ef81eacce36ee43304a1618388f590d60b9388df40004276365b808f32d2970107cd2ce64a346ef7614bc2d49e629735923b34345f9cb915d1f6c2a371a211570b7179bf80286e428e7324b6dd63ec026bb617a5e20db372bb768326104a94bc5071ac5f1d96d3da9622508b599dc3c4593eec3fc0991a6b87b9539a45e556448d53fedfba09fbfab85f43915ebb72189acb0245084ad137d16dca250b9830dc5ecf44cff41d328db1ea47a2d464c23041d7129b47d23c761252d5c850c41e5f390f05c2ffed9d386b19815a72a75a9de28e053fe4c0c26c2a31e36a8239a6fab74cacad9985087e183dad5fcc5d3b65fb0854a28f15b0f02b5973e63a4c73e27b264fe926053f46c4c61d6cb78edb648db2af9ce4328dffee4cdb15690a8f1fb426c5eee83d4a6c22298558a6ab12614127d2c515cae548f679f4bd64a388163bd9d166b172b55171dd33584a016702c4ae780ddf6a320d7217b2083ead48285af1d33accb777a3e38b1579789e543d8cef11acf571470b95e5d4c09b93f4375dd0bfc935be1ebccf563282e37a06bd8c850ce226fb9eda6a25c8688d785a43ed5e1756a1df7b9f1ce8a15a840bab07a67ea0749c44e41ea5a6f891256a9f7f5e31cde758cd2cd3bccbe03d8b0116be7580a96b34de4529702e387b20bef39e1aa34115e32a7dfed6a360dd7d3991121bd840b0ef618f205e53389f96353186a914dbcf111cf88f7bdd3c169af3719102bca108de8bcefda8c8fcff79171f7593329fe37f55ffcddec58145310f5fce7b362e3ac0c40939dcabb593bbf5def344598a87362de4d1bcd3b3b992f48a558c143c8aa453e945f7de93c630a7eee9a484880d773ec4e30e22a0ebe3151962909974ecc657add1a2b6d3eaea39ee22720c66a587518d938e075e9f62634f4554f3dd76cceb8b98b458f21dcaf6a86207731d8f6707025252f92c8454698bb77fea1e5b461992c4589fb58c010208bbe8c24cc7c46afa4f596c9de46ff0635b8f1c2d8c812a2daf1ed034bedb7f3d798f88449d787f7ba3ee8e90ebe1efa7e1241588f5a1eb34db780f925b6de4e653dec3e3b1a77f485cdbb1da976a9bdd12d95f6980650e9054973ec6f5d9a2017a58897432e6e5010b898dd397a52e888242de5ec1fa310728d8af2f333d03735b1f14433b3cc07ba0abff6eb9fe7c6b66ee96700663641fd0594ba60095da281ea6fca2a2c7c6917c738d7a5c08836aa633f0efcb109b04a1b6659edbc56c3c8ca575121b497e26f5fabd2821cd1f11b0041aff4f585e3334b67f695eb5ae21367137ac5df5f5c325b5c117fd04d46339114c2b8c7bd4935eb586d116e3a0f31f09d5fcaeea89b096747078bc9ca4fcc9a3c730249fa3b6c3b79f5f71e3a1a40d256393f483829cc70982a4478ad14552fdd25ea03f2380164cc880787579f0ba34310b1876e6c5035c2f0e00f18ed5a1bf2a88dede87341d9fe2206b7750111d9b1e078b463ad9b35c29a456e146bf78d0812a1de0da903c3fea6302250d359e246a80f479f8a61a3d5ed355dfac945f65a12b7ef23de1216e3376a4d0fc3fd7f8fa958172848a07a69b17eb516cad7f239564b95722f0bc7cb002e08656fa8d807622466f2ae57021077e546eb240770131c9862acc087eaa221e7553a2f1f6f7dd10f3fac3757202731c04afbcd92234c55bf0f798396cb7b3db7734f1c681d7945a47482e570a17a93fe0d0d128c6b83b36976b675c5072d3a8b0383176624deef3043f06a02360f8032a4c1265ffb0654c2b081376cd4891dca11e9c6d1360bd7cf2d2eb1d7d44ac9a0bf129ded77fa5c78f9c7bc722d3b7f1f4d2a680b6cbab2aa2179badd67cc726883a9a02ec62f2a65fa214a8e3e50f86112fb58f975299ffa92c645a22d2a6432114a7ce6bcf0bc40921d57f8c094bd7f171b79ba93fc0f2b39e56ac729babe6124e82917e6db2261f232289f87c54944a6d42bd01824817ab7a06fbe174fad8b1ad3600d0758e7577d2cca107d034fafe310d21e2bb991a311c780e6b05a1700f260236677ec746ea658c3fb24b653517891a081662fddd9fbaac518ff07fa6066ccd3df9830e918d496f9d7065a62f8aa0223f6457643d13259d3569b29c89308c5cd74b7558510dc535643ba51034189c9781b5301f73591d480458015fbd57980ea5cdd4b2ccb52e555d03aaef5c83ebb27e4af5cb2c332f2763fe43bb0521a3f59883885e7ab3e7bbf04e7c48fbc76f5ccccfa576474ebaa2dc95539c9b9945773060b7c722613d7bf786c3ae101b9f0df807a41733bb70c08e21603e142ff4655923a86fb2397eacb22263479c4f0a2a847fcf81bfd7719effc5cce64f30971a97e373cda74a0098b4cd122bcea8e6b1a06397bc00447686f4ba6817b3168d08856c7d59ff248063352b1c9e2d5aa4ce48e919d291774f48f4b8f1fdfa2d6e14ae0d31a2f743344a4ab48c00f63be7739f4de72a355d1cef6bd5015aa4f8df17448458943c589ff377a98e6a89c69eeaa9f6aa205dbfa912dcb1cff433a91ee68e4abc5ab8b99d171b4b613cbfa1aaa9514281992053ce5d75bec3ff8237073934c6ca7192ecacedf1f618001758065cd77ec6d10c60015e10b7002af8e0d7427cb7f2759eb2dd017d81bace87d48e84c1374ad7429a7704778e1a0d4223be058406c8841df2e0c25fe5f3cdb36229c20e422e725f48d1cd5f48284b515b64345f234316032f52c950ee47e7d78240ee8d01971441592c6e21a1475b69fe97f6a7d15ff52f95b0925b48c70e38665cf4255df153b9a979f2286009d8cc8a2b694ae6fbbee0a3d9e5317f4b53b7460db2e58b156651a596799c1437a3008d4e36346bd829fa7df8e4f947bf7ee4b553655a4a77b3b3dd654c4681aa2c53f7c7c0eef6a46651a156799fe729a0ae9073efeca8498e19bc04b3d103801613d180b6667135f2f1c307cf0fd3367528bb4ba89ec7006a5327088ef8e4bc2bedb4e48b22610910f308de16fb1057993a3d28e6bce2448607ae22d56e576f4035addef047c0e5837f1798ed26040bc5b1d8ee56dc382aa801bd0bf9413907695a07268c93b025a1a10a408fd6a15d12a6a6850f26ffd21089c50ae38ae98888b9a99bf64c3e83f3157273705ae721f0aa2d7a5b7c4a0221dd7d08e85d38bf60a74337a9f0baeff4b4e85034be84b6c1f94b056a3c76f3c102eed7dc6d02ed7a7a6d8468238096c8838c6f36eae996d293f5ea2b64034b547e0df2f50d34fc7040027abea7e2c3954c7dce2da253502e948719a7384565ddca1a5c0c88e3ba93dc4bb52623eb5632401e2b69bf0b0db4c451f7b3c7abd80b7f1e57e6e908324814c80eec475033228420d7e44d22bc758297aa134c3c56338dce5af07ac56db1c0d9adbca044e03714d239d29787ced82c6dd0d294828690697de67d9315ccfc9df9023f143b2af03b2fe9406737f87eb5d3dd434c0a5f7a68dfff49efbb546403b8e86d5dce99f7c8ba480d7e741dbaec63199435c636feb5574823de86e6296afa829171adbf2f9a1de2c88c520959516b1cb457b2acfc6a0ab16d95c6a242f63d3924ab4c302a53b50b9750b83aac2bf0447da4b1d2f3c6d562da7ced718d1809a5d5d907729f6b11fc2b68af96364a0178bf81c624abb3404421d067d89e2d6d227131497e215a1f341e01bfd376eede4ec68064a65363a34bb362fc023c8ce699c2acbb611ca8f86ed7607c63bf9d074349fb3c046a30ae20f23a8b6d6bfb4488e536a1ea7bd1f956e3d46f7386fd712c2e54c7b61f35a6c430a3fbaae804c823c6800c7ad52b5e4bcbe5380ae4919073d4e73fcf5db816e9408de1a6c99a1989a57acf5c35f10db0fb3fe8beb0a087c7a8dcaff50cb6c7c9160d4a0829072f42aee1ba0e3e42af6c3413fc8d5720254656a5a9a05309328dc17d18ef2eb1b10d7694a56ad85c4d38f8a39055f26a285a9aa376df216219c4255eccd35be85dbad2c5e103a53357e44d33ffa597d5c05b16e55629a9cc970c69401322179eeec1023d62cb93d4bf205470be00463bdc3f136f94ce0801b1919fa3d958e4d12e98d453973b0017690871110554273f922615bab20c326860b13e24d3e195d0994f596946d0855b2515ebac0772f4588be4b0b3871d1e33540e77d941e7703acc485e6abdfc38cfb13f15e4e98eca819f626e43cfbef48d0b14e5e38ea93f89ca0f54bb69a86b54bea3689d66f08ac95184c435b19f0bb77f6f0eea642a588f3794b963b895d580841e0f6271cc1493a60daf766c2067cf15f15a983431f0c61b44b28d01865147ce3b9d42c678700f592c7d145892a9d7f24f85244f59caa4e6f692bfcb0c632c61cc27156b5799ae880e6ad6516057aaf8150e49d36b1022c7d62bb807a7406fdab3dc5aa0e0810e3dc81b7b0a416ea9b6b18c1754dc141fdb75151486588ebe20ddee2061c8bd29ccb314ca929dd301c20191d6436c0adf5c05c915a940856ef19310abcca3cfa2b2747fba63451084a9391a72b2b1d5c1096175c16921654dff257ce39f403163f5b358345796a040ad210b4b7913d31da5ac4c895fffb973a833ab05ea38c06561495555f244132a4365880b072077f684d2caa656458acd77d880aa8067857210fd01b9092b5c910e767716dcaa05413b42e8eab61f079773eb7e75cadc31c6ee6bc273897bce4c9cb1271f6b3132eb916268b6b7e832050e7eb0ebd67a0742959c7004d4c4a2538a5b7ee079647dd795bad352510c14fdd6d7f4fdf6f85912f3266720be3d28a178992a12624f41f8663bcb9cf2d2905895f89833d2703b27b9945ff6b7bf3ee5fcc04e0140f74008ddc3b01c388804138365924500a82f7726903c70e03c84424703dfba3f3225aeb3d62d0fb4ac78fcd77ff7d3ec17ecd44cbe66c9c9ad790ca5e150120ab6168023e2f8af0aa80cadafb351fe4c9b25e4994ab790b8beffa7bed033f941b6797c98d89dd917888392bef73b34af390886218373fdcf9b419f63e77b6f4a566c2f369073813f264df68347144248d6d4dc0e5aeb050419c8282ec0a832e1de1e09fc6fa55570f09161d132290673c954208be5b1ce9f0d01ce2b234ff62633e74ebab075fdc904b5a9ef4ee6968e95dccf7c9b63b42a0122f24efa53c344a1b6b0ddaf546e917fd724a5c6891b36bfc8f0e97d61e12d136d1b2e5bfdd060b40d95a43eb3b30d26e4e8755ada6236b7f98eb4a0da0a662167721523fdc9dd9e52bdef3ca233a68a56d8587429815d59c63596d1b5f025c96bcfccc10865b028cd8d13663d8eafdf7831e04e729edd3383b21ff823d26eb93ae4d2795f8d7ab97bb12322d000b09f5aa4f5926746262784b92df7318a193ac5d7221b0dd52a259bb5e60c2a2ed7c94531a3908d1821ea8d8990d33fe5fb634c8f0f24a2daab7a8f30d3e6aa288f48c138a3b1b2fc459400acaeeb175ea4865c99e211f1ab27fc42fbb6ff55c1cb6a3f1f432e089282dc1f76048177bd06f0181fbd1537db43f7e9b2d14269b0191b13ee8879e2fcb1d7f27a5b78502c2696c2cdd5ccf76b0c681b3bcee1879de44a4901247e31e7d70354b5485d1b3c8f1c6a556bd6cba9633d6c926dff693d70bc8485166d3b590381b637757c2ab426c6c0b6f1497ffb0ceeb86a2c9302e2fc4226a7d27515bb2a92cc33490bdf8a8812f712105d20925985338311b4a80d3c010ccbcdefe5c65628c1fb14120a20f162d4dd18c8973451a531e674a6a75ef875df8bbd46386fd0b904ef33d4c0630fefe3d0679e7c5e91df84c0bfe25dbb1f13944d98afbb6206260979dd77aec962ced223164a3914fad242066adda26a24f7ef594b2aa891302bc7ac263bc19f04238a51348f8b9982c0b569884632201029adbe334577010c597ffefc7c78ad6dd2bd26614476e027b41f913976e5740652914bf0eebb786bcd05d03fc1ae60e58ebc125075fabba2abb65ae6e395d2a1f349255c5f73a11b853f67fa97c92136c569556aae1a62a06a5db6d2074f8f16d0aa9ea5cfe4000354a6ffcb66a014ec1410adc63afd620e2b22923bd02ceb0f9341dbfc0d35f59ff37f5bc3c7e549aea81c0bcc75b27fa575f7b783402d76399dff829d15fe1af56ae375dcbd8da714e2e034eae4394e1467b4b83d025126873a74e2bc7e72ea4a97677c20ea236556f7ff066b9ebb767063ee700faafb56756469de42565e6bb2446bea4ad979ff16de08e8e2105b2ea2e8a714ca085c30e81844ce0afb48a3a6087d816fccbec3b8b13901597c10c38bce1ecfefc6467239fe3f8ab3aed18a14cf1dd403aa8d9cb224da1d9962d5083499b96a866322bb4b8b343c68695023332d8d10cd4b07b08de33d449b927e00257d736808d31ac973761f42eff946e04c0318138ef8cf2fd4c15108638aef8bfc180c82220c521c82092ab796f2370753317f2bd75ef2334d52a296b2d65e51810d5a0a6652919b8620ecde5cf87ad04b331dde5b0e7cafc5b9915b6d330c44b587ebb1fceff1eeb1a16b8eb7c25b96ed8b697d07172b4d72aeb0239160dfbb8c4a7864b34df64a61ff34c4137ef0f4f074d7167c37fbe687a5de135e0ad089d9bd8afd48a9a1fc542067a171e02bd5c4572b534b70668f04c8f3b05a0725e9b8e1bd0020982235a6fac741b063271aa166784a186b4e45d96a2354090ae64a792165962efe9531bbf99d2ba66998a3909b805be94b4f3e6474d0a50b50bfb3f9b9ba47cba94cd82dfb718b8f75b9c64dd2929222935b3007aa57cc33e90b21d2d71b027208ccdc1811ef27b3f330fe5f7e266abbb1625c63954a9346d93c6d655d019d9ede0d61e8f91fa75c71ca3383e46a612ab4eeb9966a156bfe0e3bd441d19575ab58c0eab6c1e018c4d7941a4cf9af7e58b7d49af65d6d3e16e40cce2e3030dafdadb3a8bbcd7411abd96893faa7521a028df5d80cc35161f1a8026a765096541f110f62c2a7a84facef3cff9641587d6c41de367709ec6bfb6afae7dcc7c754fd5b9f387c4257dbc15ffb6e825dd5be920331843e13fb40de6213e4dc7e6a08345f916074ad12cef5d5dc6983e4c74318840ce89b3615816e64ae55c326ee3b40eadffe59a13c02b3062d0959faa724981113807bf5bce95dec4c3a4e027b9c88f85dece4c10f80a4944324d5e995996e5974b40c8581beea581913368c6d961a688ad4e4f38611bdd226e0111fce45d9a94d74b8cc43ce18cbf6a856d58a67a839573223e5aa504c6840296aa9d52c642467a93e10236f53412eedc0740898d84b42fc6a114b3ddfad48c25eb0e0ef26068ad6bbe70a3cce4cb1b4760f577cc6913b32806804c4bfacfd078d0100f201e0974f1bc099f2f7a2aa0a718b7f2c342ca930e11f395f91460bb110e7dec832dc4185bbf06f927f88b1b0eec77531b41b401d3b3f88964311c5f7cd5dbad699dcbc848327305c57ec76f7f9c4b051da907a9127bc6a3fd7a2cbf616e48e5351bb13e799d59bdb014b83f1088b3b264c82a8ff54ca1f1c3bbe89ca12ef8622da1fd5c4eed57e41e3e5bd0442ec2a7b03dfce97ca7835cb64c4dc48b7951e496ab40ad400aba7dbbddad1f9c33d0eb451f4332e1f9809d42127a11e2d5ec63ec3ef5947b24e9493843cae33e501dbc0fa092c0d18238c8a1c2a74e3f0c14b0de632815c907d84be30348a56a0e2dffd1292e63a3d4db292aaa4afdcfc00a442c15b9156c2bf3acc3cad5bc3eb310a9028a99da609968502a0eab9ef47daee8ceafea95940bca8892396d15ccbd937539e4934a12a130fe68008e7203324ea929ae9e7f7b22c56b09f63ebb7dbf1743ad07f30e93fbd6476514419236bb1c61b3f72fe87a363e40d1d6307492eca89a06ea2c2c9475451e8dfc20a7bb75613f32bc905ca68221339c26208b267ee8c8f788b557c20ea96cbde55b5dd6953199f29365049a78dde76c7b0f421d22fa6ca542400c0d844bb73c981bd9813d4566a6129676dc93e7dcd4ba645e0f81f4f31e37f8c8f9d511547899b4b5b5d07ec90e08a410ee769d0cceb14d622b1f3bbd9fe28c3f52dbde009e0a234adb7bcfb5ad47f22de2066de593502fe262e7ca0c0a5cf9d562d6b7a92217b2095a1bca6ea4bd63109bdc3233c5dfbf5d8dc2a114a505e5945384cb5252d06c3b30afd7fb0f23f3ddaa43810264f0c7eef3d07aa54096a96f7469533522bf567c9b4c541d1463cf79efa7331c655ad58abf15743ad4293eba6df60308c1356091fe28c7a50217da440089f29899c70cc0e177882e33aaafc2f10516db78a019b85acfa415bc6e50c1c6f8686dba5aee66babdaec7920e6c1e39708e473d571943535f47ce07082dc66a1a27c01c3a214f37cf6983a83641e15603b2ce96ca1f0a2593e2838d9621428cf2d88089d38139d056ff29c0f9cf1ff00aac3a23cee631304a0500fc94eda23a71c37d3f7d0c8d392b87b0f4e69db168c4ae241a9a75be16eea196f5aa01c00c047e5b5afb1387b9509c322c9405b69211fa3b4f4a5aefa46df0f1da352f4f6603c74dadfd1e4c4af49e87adee9e1e4b128c612c54fe85734af945a96306fe4d51e273462126dc48867b15bc867f6ef35a1ac8ad81119409ffe2edb61b18b44c069759ceeabff4c3250c741742cfc9691bdd00721a1fda682c03ed2da11414590e194f791680d907ea47cc279a01f20c572e5aee63caeff403240f69be6dd5ecbc395bcb0d802eb4eab706ec736b63dd6f79057f8f0582bf5ab3a588a17d7d5bfd1fdb65bab491204eedc93130fb67d3261ee7eb5f6a0752acf132d2f6906089c869b6f3c8fb4aeb1b728939828d6e37815f452a09cb80ccc5b0677821d20446fc04f0152791c985403447b432f3548d249afef5ea3c128c351f61ee295650a7eada4fdb640881f13f61ea13069864ed2ac9c9a6c8bb37f781029d75183a8fe7847566ac453eb4db6718760f7737ddc8037b7779855474308b6855c471c20dc2b8ef462d1a2c88fd3cf770e15f9c12a2ad9569ed2ebf86d3808618cb802b74c084f20caa80a1116c973cde17a7e55222b06762e3b7c3c94d53d8ba6202ea93921a6e35ac93287b3f54128beef84e05e3ab37e9ac909c7b771fe3126010d47078e12608a2c815bdff71c4c8d7d5b759d81d97ed7832dfa30b39252fead4203b49bd89e1d6b4ba46346b4e6dd70c58c56a2dd46b34f0016ac08beee60c7f01cc1362f68755a0bc36d0ea24dd3d4e5d7019267b220ee381181c231a908ce644c68a518cf9ec3d905c42c80ae3b1bdb69197ef56e42b1f985a1aeaa51257f97e50dd120bcdf376aff0b38f0f5ca18ebf50e582b8e6af2daf6f9fde913879501852631bd889697a0cb61d584d837254cc38a30edb5fdcd3095eb813a1e060803362e94cdb8982411168aced40af8cfcfe0e886921d9fd30205e8495f1a715c0b0f8a50740b145da8ed4cb25170326c3697b944b0335ce81c6be517b9b0f129d4a9ce9d27d6962b4629af4f81dcb8774dda8534dc27625394c18c1266577ca1f2dcdcef13c2fb98581fd34e82e512cfd6e2b02b1b67e716d175236adaef44af128d1afd58d743558ae67b55ddb667c9f80ef03a5ed2432af9b3456c3f4af53ce6eede5afabe425ac030fce512d3802bdc60ed7a1154f52d56d1cec5ad943a8c7c0ffbdf360bdf655c4b79dcd0dd04f415a43e5d71b28061341e0f612e7b19653b8d2c9512701de334c600d877b7a0b389172c49720c21572cd2ff407d7966f897b6b5611fd12bfb331b212afcc53371ee66778179c36a2bbb49f9c499b670758f8fb4d4169b1d24c2786127b2e0114115bb5742bdc0fcd3cec6938cf10156274b0536335f12d349f9336b6e53811c6f8b7a72c756cd41d13467feec45786ad2bdad206d480a7d7ca33967d2f8bb72452006993e0adf5357b6e896e9f5e5d48480aa9c3d63211d0929fa677cb8377e6c533291b3744a4b95daf23aeb2c475c7bbcdd1006a3b53f6b38c50dbc0d090a7ce653ef7e25e1621625b6a403376b859a3dd6308c9673e26b538eb8c5965fde56ade460891c32cd212ce1b6819f81ddf3852599d84265b24cd2cb3909259cfce32d92aa7ddb58e028356d662601c8d462f861e3bc8468682856dfdeced4569c491d405683df0c6aa5f7a737d8f59b8d94a215f4c087346a6fabaf174d46d124fcd7186121206a0525f50c81b8db45811396c274ca9eef28df81ac71bb8ad6c45a54422bb021f010bc652d5305c60a35cf43cb6a7e7392daad38416ed89cae566922d299c6e9e755e4c2222e1b7bd80579eedccdab3f62ff0b829ee4ee1fb2524b4f0c18109a5d18812b9311845e08ead2cf4a4a252e8cb0e735fe3805e458b44c703e976b0b913103d5f7ebb0de73dd037e06472ca0bea083e19def1032ca5a21cb5741f2a18fca25424643cc145356066b9d9efed2a5dcb48f172595c3d91955fe0ecbe3aa9d9ce6eede98b52a308800a8bf9a9d47b737374832a0fd9d51a371ca1c34407b0853d5146929d325d8888e742cb704ace1e76013126b870d1f0e98a5030f4f208730abf2074f3a23864b17288f7b74c61dc7c2cc6b6afb0a89af69aaa7a241b58ca8802aea9118d7627bd137df7d3172cc0b6b7f67fa0a25537d1b32545da82b8df10936cf2133d8939e017f68e54d48a643e482f86f9ab2e56c17bee58a098e577c49ce639053fac4ee996a759f76cfb9bd10899eef00fb4496a14e334021d19758cdb35166f54b7223671631ef50626728ce4ce840790f2e70438bcdb57ff223b61c5dee8bc84e3db698c18db932ae8df82e17d43bd46dfb6dd8c31e95cbb3ab70628aab4dbe4fd9303b5eaf2ae6a213e970ee99bfe70c983b3425d05a2d819094ec156ce0e54505fa7e4da4b2cfbba9ab5135bf5481d55f3c754b4581344f34e28ea0c94dbe4d9ab99d5a288fd892b76c60e1e8a1938923b1b5260a91330be7ce006aed8149cbcfd5bc884c621e8e5768ffe935f4218ec03d8459771756a3680035872f93c888c5e95d4c8c8e3024c45d7ee705b48879635c7aaeaa678c4af69e8b50afb0ebee8100ca3f09d1bddd7cc2b971857148dcd87480d18161e4bdb9645c21ed8a394c2c308f936708fc088ab2a5328ea9abbc5855983de3063054345579aff827fb530a8b5963cf9cc33625bb95a1444661480cac4332f5eea01e72ef5b3cf5b68672cd01039ffe7fcda0f9b55769afdc63fb084dd20c5c53286df50cbb59d598b19ebb0f2c2622bf2e90894719bdc2994139629fb2115224dc2738cfc47d66b037907297f361b1eb7e5b1081dfaa5892874f193ead9adba30bb61959f20a7c673c9c596ccc8ca152bff418463cb4bbcbc099219ff75e1c62ea610b0f499aa86d98146a7986e71463e71b0ecb352d5df0677ce1e51445f1a571503ddc43905bc2d0861ad32e1796c06afb925d323d31e350b29eb530dd1892de21deff09361b618911bbf7f5f685e6aee4897898a450751bf67334e6803711ac153ef2ac3a0c8c7fd88b98f0721a854b7b56c5ef63a6590881774da83741b9e8892d3b37f502a4c44e0a6fc79c077beb217263d315ea0888cf00eb0dcaa76ab59c3a734c203618f45cb48ce1162d872a5e4b402465bd758374fb27d59ff802333a176afa4b02e4a87260bb75b8573261dceb7c4873449c92ba77723b5a698e700c3bf9b0311926ad90a1dfe1e4ca1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
