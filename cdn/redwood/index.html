<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a53e6545f6c4a2d945945c769d9b737258a764ede77eadc41cf43cecbe8860527f8564087dba1dbdbaa939ff837aa7405914d3d48fb0c7a7ce4900d2fedb86e2bac34a8a4b80cb2d15132f1df5d8661959c184dd5094b46e8b171872530024fd8e9889e2453ebdafbf1391d667d53820b9c9b95b93df86edbcc282fb8463e323f9cedfdd885a8ba0ccfad3243f7ef829636d797ee7b232a62b785185f4c871d8fa8b536924c14f7826605f2b5c93fcbb8b325c3148d95f10d950f1074ebb5c5f9f2caf813d0833233ea53fb2ba77f9adad9a35478a7ca0d1cae54207c09626d5937691b83befdd21ce3bd26718482ba0d0b957098c5a2c26622d2255ab06fabf39bb0ea9f411bfc6f2b9d151c7647830b2fc54cf09f15fcd1d08431e56229cd644d4e3be9fc67f7f93ca1162fdd395987032a4482e3bfd703c812f49965c5dfa1872e6983d932460712f0bb0a97e32109ebd66be3ab1e4ced9ed08dfaab23206fd08bd8194ed12c3b9e7d7238d7cb19cce80596df7dcb8d7d081c0ad3e0fc2ee62169559ac51887b8f34ff5e374403a016387ee50c813923135e5188f12f06b79fbbc4d099c82059e1f35c4608857ce14596c1c0ed16980b51c69fa5fd92346338936040f8376001c238bc8c490fb940f47c892001298697240ce3a6e57c17b463db1504ecc69e4080ab04eebd9b7140411f84096cef4c389b20c8944037af1384b0495cb3cfb904a9073cf35eddc6668f8297cbfb0c25bada5c4bf8004d68b88f8efcaef9920df902645a25b56cc03aecf38a3c0c7f7eb91e37d1c4cecc15341ac7e1080b73712e4786c318cd31df5336de59b78294ef3499cccc1b5d2616e883f6874272f2e04615bc5aa648fd58a1b6154e77cdadc03c697526f61eb4b38c8288a79d8d98f88d328e63060b897203745431f55a7f892e388546a68dd45d997746c6fcb1966dab29423fb0515630aa8927d69023836df7bfbaca2dbe95fbc6b3662d403985bfb76c8515ddd50c7fbe051841ad3341ec3661775890523993d07d5dae8b03606da2d57fd60f307d3491e4247140b670c1e3ed7b2bbeb49c810e539f16e169320b6ad45904e2d6a736f8b9c3beef1e77d33dd904fca9fde44a2f44e05c0a327becec5f8e6aebdf814d5cf52a6e2cc3df89aa83644524ade8a79d1d4b2e4110c536167578f58c543174a30f9f26ccc781dbe76d535fe5013a37b2b65b2574fcd8d9ec42c827519b06a38e200f6fb7bb5c0520254cb4b36fe68c5131b621c3e7c16011aec5fc4d358a7d3cf8d3881c8659ca60ce24148edcd7927daa085658d58f70b2dcc448645d2e612a2e0cc3e48c0216ec6277ed76c47ca625cfebbcd0eb75170d64f0a09ca4d72455c6923254458a5d706f654a861c4b5bd7e13ed726a3464763dbf187b8c2b3d3b3789673220a707856bbff9f239b10ef35dbe84e7d19fa09e24e6188d1b783eb3ee10f797d3883f9f32fd18dfe3546c37f73d54b83ce1fe93f1c7f3ee606514e5db51c0c18b2349df555665507130bf1ddff7327ecaacc20f1ed6d2cf26d4a2141cdf45242cfb58b4fb6ccf771579ddb593c2f020241cb867959f872b7c3c4365aacb2458961ea816410c6e221cebc8af8b38f863266517a7b94a50674315c7e461ab738c6bde629126a03202c10deca613dd7ccdc611be23df8de41cf9b077c86abee4d44647f074e8983c402c3d302400dac5319d24e495354c9b47f4f1f65b4b128c591270431600f92a9fc6283004a7088464a12706cfd74c64c88da4f173bf51553428b8b2dbaeb38d6d219b4947f91affa68e07498094d1593dc694b7f852c92429c4e4a2251aa26b9ff9e364f2cbb0bfc30a87501cc7ef5295699a86e0df78715a9ac0208c0b2951822105f84409d43f0996468d6b38ea80191325a34b74325e62e41c64b1165e4713e64fae47f160b4c60ce6541aef6057e598f8a0d0827ba9bf4db7ba7f03cfc5148952bbc1cd7a14c105882c92f298b6adb1a47ad80a9baf0a7cdaa18245963b748f7df3ae2e5cbb8373bb5805ef49531bff39d9eca5ff0e14e1bb7c8bac0629a9577f0c08810acae1e8aad535a264adb707b0b2f1555af703ff4b7a26d244d734670a95b35124d0a0fbc2cf43747b436ba613fb17a28b770136aab9c672847b288bac25cb45da529e1db7ce07ff1bf23e0cc1c1e5aeebb0c681018bd92e08a7f362cbb80abce9cecc502ef7400a793c43a0afa066fa9be12df6e8eb425e8a2acd61ae707f802d8db805055d4d3223b9d1319bbf369d8f8a51cbaf1b61b9f716889487a366e52d3df85fdb7de0cdf5cf14b2708e6ea0e6cdb19f014d9dfcd8ac8c0f35b102230a9099b795d310ab6ae0c4e62277a7d6b17ac4660baf074cd4b9cec2ba0a1368e5003811ebc2c6879ed533dfdf419629e023acbdbf0bcb5b040f54fea3c4f4bf19a8efd7e98c1a2595f2fe40667a5ae646fc7d6d49d314dcd90c6bef6378aa8e6a87952aac1c7d16b3866a08c9da075ff3c40a4e6c6da2b5ffdbf396e3e17e415a976ed5748e5db071dfccf7ffa46b329fd389456a282cc304da3bc34617b79ec0279c50f4b6bf521401ccc9f9cab7040693547d22c4f5dcb19af91b884a28536fa7ec3c299ae6e77497ab8becd37804385737bbe3a411a865e7d04886f57f5afa461ed8068b7478199bc5085ab40458cff7a8b4f961cc92763614fb8090f4b6877b39e3367a9ade1346d49ad66383c18293b800e30395d31b06e60be0395f882119766ac205d905932f198fe3e545fc5a892ebad80b35e37024103e996352525be888c4951e4889d56ca11c527a618b59a558701f8eba8edb81f463bcba877ff86c07bc433781610d4a05ff60a8ea0862191332a2a26c6d6bce8c601386941d46d93af506916a21cd8bcf191737e17c3aa81e8e7eb88702c6f5c23866d8fbb89d3834b0bc1371e8602fdd9506c92020d7901d2e22e90a999a80770d696dffe35c6a5f6667c1e160e6fafdfc76491dbb114300896e62e4179f76219f0628176948ad8971cb9b11ed3a2bf75d40ceb599a323612eddce9cbb84ced283c41314c6e9783237cf88aa06fd5a88e02e7f0b83ce4077c4228e05eee4a9a623a70e127f59814ab10fbc16b5f424055959d96dc63e2a0c2c7f9f416dd305a718e8fd68b3f981199aded6a81d33c7cab2b2f4b8d4c1a5acd5f9ac192710bf708be9b436807d5d5e6a6a1236da011202f3811c0bfb7315b6069dc2c16f37cc961e6a82fd8d8b3e55d65bf3292c05e4e0c0da434cfeabae0fb0e77f8a58f1d000584e084d07f1ae91ff318597b0d35e777f3cdd581d7b3bd79fc3c81d4131041f868967913f7f4074ebfd7b743f9257403025e774eb6448055b13bb3204fdd9b2864251b88337bbdc40d8215d0c8d831f8e95007abb86c9dbc5b919b146ce69374d3c40ffab49c4a7f9b18cef3e8838fcef18713a10d928a958b023a7131ad60aa8a6eb7836e8bfea1ded09f36d859c80423445d92dccb0cc53db1b41f3d0cc30f64a7913135cf128e4d5b442eb15c7605b8b59bd0dd995bb6075f349647a2c8a2b1119ca2abff2b3ea24cd2442c8a1528f11851ee126d7f0cb0090dddd02a5ec0366adab7968133f8164c60bf2e4957579f7f98272f6032975b2c447b81cf4e4e2ef040c00c0904ba16b6f091bd008af400362d9b72aa7bae850955a938591264044d977438c67c43c448d1bfd7d0c9d54f63a58cd7b68ff799e769553bc9e555b40d43d95661cb59d7ef948cf374e370f5b4bbad301f033f04b2eeeaee2c89f6cb12b7e8c29c7e638d06d3ec9ba8576ee766dc26c4fd072647d9b30ad40d8aa48658cd81614710269a1bae9bd36ec80e5de1847cfff576c92ca589c0f3d22ed5246f3226cbea453ee4e5d5dbc29522ffb7b7fb5823b238e78a7334c888fa5b491f03e7f8b4b240fbe49954ec62f73ba0c74fc5f71866c48d66c63f3c608565ec53d4963a23c3b9c398b0fb8f4766a8ee9ea0e4d36a6c0b6ba88d441633397d1059d47a6a7127e329772cb1a1f563a10c143cac667dc293b61e7910905731594e707de952057bf8dcd3a2c5ae38aa2e0a6e1b4312f9abdb0fe611ffd17832d1238675e1288b14bf8ef2a0806396b9c659884d2e00bf603cf81ef9f1322d9a66464bb6676211b26209cbc2d07b6b6766569f492d6e907d3981125dfc6403344bf49c30a4684c68756abad51ad5a87887d7f2d594639d475f6fe3ff580b58c414da1ba8c8b80c43b23e0d8c42c63a32a6974214239a2fd6785225dce82eb8439202647ec2b5a958b3ea4232cdd2eb2a5ccaa16123e6cdd55037ff80f25aeeaf176d25172a2d400cabb535013693ab1f695ad3896f3076f8aeaf0a157a52305da7121ace71330350795e7a329bb31812285575330bce1db696f236764699517c9f31a8c4065cd2211d1f52ef9652c20f18c616d371b869835fd83e7baa0fa96e426210ccdb1d5004f2a03900b72f3120c59324e7a385e9dade6dfc09485b8c5f8a8da5d50ca8e4351477282df622b0dec4cee1f06db677c8877073b4fc898be10a64610deb6f32ed13b9b3dc8b04b586537263ca2274008c91acec19643823a55eec3fec84f50323ec041d6ad8ad7d9dee4f0969ea42586e051f764ad45a0de5a1ff3723dd911f60fe78e258c4b0b4d71183ac4222d591955a3a0ffb17991968ab557397d85bbedf2a7f81e00ecbdfd72a17ba9f2b8710cf237963cf01029be08549e86966c2a56dbaa9dae46fef0a9cfd67aca68cb9ee333e87cf9d513e84f7e0af430cc77238b0669c7254e99f0ec8e7e9695e544abb11c56c67a704f22a48cf1f8efa0af15330a56d634518d41e46c7b40a703b9ed835190213d0abb4b2be3945df233f26547105e12aed72352f086c6e808a07e16d47fd75d9943082ec44bf5480bd2f28d48e27d39d2d818f270fcc93bfaf1311fad47abef9d2f7ff02108af64b5bfa9d0ba1c7c51f50895b08225682d0660b20bce5b410c32c17c0bab2d9fea7019f378a1033b0ba224bc399ed7d0afb1dd3eebfa422ac76ea4201f47bca55b1becd202edeff4178085af16baedb5af3a23f5bd02c2e457c8b51e928cdabd161849e10fb2f9fc7642d797f9422e4cf590ca24a445e99c9897a6f444de58228d787b7cfcecd85c556e1e14d2523bcc70c80dfca771fe9a24e0f045a3a14bc76c9b189ada97ecedaaafa9ee41c59c64d75b2868a51f6610ce25c7b0b9d3fb50a3c2b857401b55888ff0637c6d6c0eddada9b282e921be7e868ae4170630266687ac3f94d5c762bc2d1168bb2f189237984376fa1e0089d9194572ed651dbbb6ac24c853a20f8424725de5c26f7fe884c901c2a044311aaef2a1bf3ea46459fd08e5aaeecad75513e500de64f9ffad5f75c2fc2431bbd3bda2871395ea6dc6985c3678ae1782a0ff9febc5c59c050f38ae0e6047da94293cc0b6d168cf8eb9669fcddff57fcf97e16da18cd263d85d2c5cabad4a7c92d864873e43b2d6f3d5c2210cd3b54ecadab5fc5a4d5be4b1a989f02fe27b6d19188dc5acd3010b9af5c22a4678529b63534ac63b57ceedaad96bb953aff2fd5ac946d8046d0993148ade20bd93d06565091c3839e7817ab26a6fb33c2bddf3a587289cb60123325ebfa2ddb1b9ada2a630444e77e1fe528ddef0bf2cc07202961f041cee8679fb8a7a242b3592da883a7ad50cef2f5350b5ec08603a615d30ddb19f2c46d38b7e41d33f529a2f4b34362a3fc29d525caf6d4c703a6b2e4da157d1374e105cee761503d21a9ba5641544fbbcabb582f27f859e76de4aafba104f8dcd0eaf675c08032936e13f6c1c53cd54750b3f45811860f17352d726ab3843268718f204a5d61de90a8d3b99c9a6dab40f5d39d9f3d8c98ad6ed34ed24cc770024555138771589366dfed4473b82cfae7160e5be6700ffb46e1ce59b966cd32522995514379f46da9fa6a7de75d36511ab5f97518da8e3d74875db64786eb6ecd6d6c669deb421f9aebcf15f29c0152d89633c26000a7fcc3676effafe1f57fbdf0945785e8189f55078a6ed932407694482b0fc89b6989867d86800c3a72900216da7d573fa95470b73ce78a4d239451db65099dedb38510fa176332bb682b513b480c766cfef3c26ae65b1f5da5d30ded652b1af754065a0e66f3045b2ba7af54d3db0fa82141c88625a6602d63f78c22de7d8b231b834b88543ded9ba5970e0632bbf519d7cd8dc5853dc5dde77caf2a89a1a9c65338e4eea3591153669543fd42fbf3f1546cbd1e97ade972d5726ae53270c98ffa9c4a546284018f480a823b3e6891dd08d5af5ec78238ef028d06a5f4337c4732a4d3de16fe129565793d790869ebdfab06dd9980d1c7c06ef7f07d989218e11da947378124e5ef66cdff032d36569e45cc8f852f28d4c69c814a18a0e58022e63b6153a4b0c99357ade8be105b623141e4bc3c91d676d897acd2e35fc3fdf6e475d2552b4518b275d8e9ca4186027abb2f6573890151c3f554c3c9537cb6de30d366502422ce25e24705e79455f5afd8a6e74dd9fbb04d84eefd6adea900eabfe4f8fa8cfe08316c129a72b6b534dbd5905d68c7be3359d01e4efef1c03d4b0557c783d7683798606aadda4eb3da1a32dd5752c99da606a8fffa21dd97f69fcb629eb5bbe93aa1b6f445f8512e187c4e31431dec074bc9f55f5f5abc098fb33eef83bcb533c74eabee87c71a6b87cea12655a12ee956173b8900fa5608c6d42cf2b62f92d34735287b4781bcbee99af47d32593958f43727f12b72fb34825a57f47edb5ad665a348cf4ae65baf33cfbf78ad8b9380af377153256b8f3bc76cb9a17f40be2252ee797c77cc7e044c92c5d2b6e64ceaca05bfae4673f6368490cb13e8b9755719a6758bdbae08ed8096da56b1f94a355757b60a9618fccdb7065bacd6fb2daa53e9809ef541ba0e2a19f7f0911beb0ccde38f3b04c8c6b49cf064418da1b1f90101a58d4459333b83b174a540a640f0b125a2d96555212df3df21a6a716821927ff79d8ed1ddddf67c956d968459067b6105f90ee2780e9fe668dfefff6cb697765d95ea0b87038f13aef4bca9fe7469f81f468d802a6fa9263d9c3fbc2ce10467ab7d7fbbf99584853661c10aee178eb699efca64bb7b41715383bf3b261f6afa64014a5b9b0b7148cf84640cd506497621ed63efc982299fac3b3a35aa31f7d8e3876635059d1097f1d5aa8a93d8346afdcdf512f2722c47732cd674219c2e09d21f086fd954e919bae739942299ba60799d2b163adb503546bf85a744063d3f0f65e93dfc43f6f80b321c88ed7f2b1c4f135b1a352fc25c93dd201f01747efa90d605d76c9889e0ff468af07a181f26c2ca9588aee8aa863af3af112e4d9b4f97b67fe6c153ddb8c916442cd3bf6732a0c45a0259b664d0d19e3636967955e66461416734f02f6fb2daeece007104d45ea10298624b4020a6c59f8b738341a8b0ad663d1b480a59ba7a6a2652dbc7d6b41012254528a3760eecbf010d4783782ff2a61e62b804d1bc66a31bef5c6ff9f9b71f7a51a6dfbcaa851f59bc313474c4cc560e6c327f9268dc774c2ef3c3ba16d686d2bce3f1bca140540b3e43adb195a55b7c56c4c9d075cbc97f5a29b7dc7585bb1ab9f3a4621cb01f5ed77aa0eb1c92f20aca24ded9076898d00a1c56f831e4d9d6257d05e388363bf7ee04da4380eaf6bbf09537bb23b40dd4980335e322bede749dae8ce15b4ea6a7238926a6dc743e3cefcbb9f7462c754466fe38dbafc65ac7c649ea01717dd714eb468de271d9688785efbe7ff1377959264122d723fc301ae76fe321785a6f0f52781939ebc77fa7a56d18a42cb661b64c615de4b97de59fcff841b818fe21ccd8ef4a9e46d48bc12f086eb1c169b2c99d1821d1da1f177315fe9b2b8a0a62c6717c82ed973ac436c84a524e4ecabc5f8de6eeab523705cd24c258601d6a1ecc6d47843411663f6fa10b0965fa1aff5853c05bd51072de3ed743b189c3512103d0cd70756adf41d45264a54c76cd2b6e87f297c9a9c63bee181ac20656faec39ecf83f83e084a49dae4634d0ee28ce7ddbac18611ebc920941235730cb14e95de2e96c07bbf609ab0549a5c46ab876c01b91294f48521a334bebf724995aa6aee08b6883c08458847768e0b3f0fdeff4e68f5cc5c0712b881fbdc40153194b4639edaf185e69abf506dd4fca212e63c0a2693fedde073a03439f5d66ca2cfde9cd199e1ad4b2437978f0decb384172adc25c08fcb74568cd8956e3edc97cc61766644e895ff787fd90f973b519b51aada2554cc59ac4d383cd9e1a4a8f95b092ac261c44d5224e5493ea9321fa946feac740287c33634bb6bad2de1cccd45f9070578e13966c4d2659847d5ffc123e673e1c19a75b62fc30456fdf3fbfefead7143af08135ff98ad1ba5cf564ab177eedaacc885d0cd8c130bc278f8251551ad6b280b54582dc88b7e211e4db5e2c3af46225ce16f12b64a06aa696c6ad4ced6cd35f2f3034137c8fcb63d4755fdc86ee3f545a42ff1253b4c1f78aa505fc920b2b4dae46350dccbc3dfe453e2c1d42904340e75c1f59ec4b6574900b41545c03c3a02b4dca2bfe0abb5b417157634b1dbfa5489342d5808b4cf0a1c2e0e56ce2ff9506bdb3e3c80531daa22027fca1b926d5932bcea6b1ae0bd357196e42aec747aa84d90602e48a54d2211668b2454c49c4fd355cac32a2eeb26f82a9abbb3b40b29d5b6ec8c2b7bb575422972995093f815ce53930f97674602d953f5ca5222712f10d26a95c7eeaa106fb7670184b958594016bf294e45cc2382a05c82928aa88dc80a31f3499dec7213cda3ef5f403414694816a5d95ac0e94a6dce25622cfc76945674c8f5fd5067bbfa67f53987f217821c091a89463f147c6a4013e70ba63007dc9e074060f8554f171f4a5b53a69bbaa039b5180e8a51acb835516c425998293476db1d64fce5c0eca1d4e7a846bf44e2b7399974866f8b8b15bb6c2dfa0289aba674248df8be4e1dc9aed27a758900db24d7b1a0ed0db7d662345c03906059aece3341a8d722c1bf262b2b4e78b38cba53c4521783391927e1f1544d90d9c06c7f28cac6ff2375c72054d12421d96e72e66106c4ee072b50bfc8269795b684cc664192727ab2bd194b0652c8f8423be429f34654785f520ed4a1159f2491f59191267077d773032153756d133c7145cda060c4ec3f54a12895ff7091ae059cfb8d3c74aa82eac2d5db1bfb15169b7d4d2dc097879317bab9f3971d16882cbfb667f11ebb0da95e165de1f7715a94ee60f2d02b4968ac34f3e5eab2d0f8767f13923adb8dd77fa9620abd7d70346da9e0af503e157dbb223b22e6b49158e6d85a08c9bb6fb876d6783a621292dd7820a05d8952dd9bf3c2abf4438d206b133f2d0a3f13b5b2bf818268601ca38ab7aa65465ce71fb990d2e1de7b8b37d038e90e6eef4382e3926106476f6ee1fe40c21ee4597acb3df95c3012e0196790548ed9fec6c6b04245e72632bd897d1ee9fc5b5130fd658506d6f47c05166d51c21d9ce369d70e622826d546aa311d49083006221e4e02ea8dd649639f896a9664ba7539dde81c7e7513d1f33949776a972380061d6445955ab2de9392f31d588b102d10cb3da0242a4853d36da967be91078e4a86ff5fecad19e80cf91d647ba8da9fba4bbc3f346560329664dca10ff97bcd81dfd7ee6ac072febc3c0d6fa4bc3afd7e0b706e4e647f0b6e3137d851372624e6b2f13f0391114a88785c39d006412879ac4c70be84db40e7fc18fc9199afeb336ca9bc5b07a312e19ba735ad796fe093d215521ff45be9c43308417bc592900ef38a90686849173b46b6f6848d705f02a7e96acf41be1e022d3c45e4e993d67ffed1f120c744b4d041a635ec68bd460e67742e23e520191307ec234e8b8bf28350ed246deab19a3ffc65b71ff4815741c186105ff0e70b10a0f462f34660b5064a5ba1cb2c6e2dce43c59441064bcff7b9e596a905df67a7e8f120fd333024b1c1dcffe19421707fd7eb0a656528a4413175b5d5824f380cfe43cfc9d0b636492df46e7a8c8014e59654e165106a6bb99a025daffe88b2dcdbfb1f64a1eaebc638236eeeec69e07975a69b8d528e34aa763fe54cfe9a542c905638de94e78f52836869112095986900bfcf67f7a1587e383c8d99f3e75a92f2d7a5bf3ca51130780c63718af2a039be472ae2a81e8473a9dee977d60ec83139759cc4ea932fe086129566b51dcbcdeea4cb4f79ecb5d7fca2b4c0b802a5a678633dcbf4e9adacf01a83d9c7cb11df48ee0bc12e40057006871232c9c76f2c59a3ecec5fc24bddef1822f2380ff0e8b7969b14924755be2fc95f7d3ff0a814e1e91db846679d566d43dbf31f6fe880f66d5fdcad0511790f0eb994f78eeb5c2671b50df1b6d3c548cf45af8b7a03ecb6fd3e9a8b1987e926146545ae022366a4aaea9a3b12a8426b292a29c1f070e078c0bc08058676c618c99c018f3609e4cfde382d975304fb5c3ca369f24fe3524b0e184aa3a58044d47959c4d8066fa04865304a30661b94a5c0413da056febe3591fe1998eec2867ec901fa7d2c64e64036def17dba537656f7f5cee4b836f1390071ba90a12b4e296b92ef8b92b299dd987ffe677debbdafb6fd16b606985eea37a36c27ce99dd0ea27707fd8cb2733d3950b553998ffdec3d2694303e90c025bff1cb75b0e045a07795631f3d32b5549d4679e7096e38425c0261c097d5e93b1695dc6fcde7e5f1f5d548550353992f5216f2c9461d66348c25601efb268a2564c297372e7efa16a96de74845821103d0831d57fa3d0395d5158fb24bc145bacc5cc76504b246d1dbed9e106684cc1dad477efff6e24d635273f2895755f61ca4de590443a195c6aa6a49f1f7bd8ed8f0cd2a38b9573efaef522a0ad12698a55a4aaa5bea5c47dc7a9aafc3d3929014199f8743220b9f6967696bf5416905fd977ed178e2b93b1e0bcb086b0fd3c197436d7bf401675b255ec519322eaa61c47e11506be5bf3c2cbd76fd525bc1dd6299afe5a0590e36c38857cd75e574452cc4c494d11fcb32e88f771d8c5cce4000fb7aecceb157b3906a25a94f437779075d7f0310b2bdd967df323e1cdd864cbe8a9bd2181f383787f5ea76e7b4eafd2c4b216a8d2546979419ca520305c567bcb34150cb5e0b594c320c401ea23a38054edaf4b506e5b203f7a2636efa203e95d0f34e62adea8f6e5742c2a079b38807a18fd28743b440858d33f698e91fd2bcf1b2a04ff20c77b3c8ad39dec6f2becd3f62970daa20743d55b44af243de5cc443ae735770e2a7ce4bd5740d80f30dba61c98a8de4dba30dc2a81782689eb240bf9ddcc91b9f6e0e3146e6443071f86bdd517dd1bab204ec562f9207e32c0baaf82ee548347e5e4605c7da9c83368dfde67f86dcfe5fb4d4f00f9f06547915e35c28c3b389e50e02896dc5bb7b5929c3d9dc0b0d3fa3fd2c8b8ed36a819682c85e5ea9ccd1a182c6251f5fff9c3bf9dd07e161618cb6cf015d8b93139ada6dc8e0b0cf167cb97b24183484207f01e8971ceee0f7cfe0f48c732ff9e54cbe601e59f3fb46317015eced570440518d991ab5320f381070e339faf59048cae10c1554a0c5cbb041b2422874a06044885ec728e0b5faf8c0d5e8a32a2a5d93a0e670391b34fcb61d4151009e98bb5027f8c5e66ffbdc56221503bf5202d5ba719082d10d3621f04d160cb57d89deeef3bb42d915a4caffe300fa0d4a66a71d10b6002ce37a8d2c35efb38af63f9081ba9c372d32a73a5e9db18407e857528b53af08967781ccc8e27fca82ff02dbeaefde5232f61dc1aacf71bc2ac3f9c731fcf18f245e4fdccc5ac98621d3bf8ee7fae52e9a8849ab16aad57d957d5da299ac0626bfd09ed177902f951d90ad891accc044fc1812b22464cb51192861195eafb1d44fa8f944d9724423a6bf85f03846e00f0ec67a2832f557e83ff9762f392e65165fbee37f9e63270f58574b1d7eea66112c313b2535660f1230e0f190dba4b4130faab885cfa30d1783f499122f6fed5983799012499e1b6f1d746d3d3b360ea988b9950c5d52506400bcdcf7b31cd5c2a021f54057c3f6b4f804997e5364d8ff715e03c139965cf3db95e681a71d54dcb673fc6066c7f1075318d8478e7d0d3a3649037965735e1b4d91ae2565fe8de9379c863f0d29df90dab5c1bf7328953ba71f2b741cdf0e2b975d406cb158479da12c5e9fb8f11269d8796936abd18fa613f3619db8bb9d7ad5f72d23644049a221586f6f57aebe57824df12c1ffcd1d947fd0b92afa1fd5885644f30df5ed1ba661dc239bcbc208475cac36f3a1cb1f5ba9c5e58cf2af94429ba20ba9e439e3b89fd6ab7e385edd22cec6ccd81218dfcef81b579ab077802923be7c1d44a41c1c2c0797c5e97c2d33a4208e53c989a5944fbbf5142faf1923d1d7681404d11845854358a6091c9cda4afd6f67d28dcac6cd7a93b7ecdb167c13e1a1df458172446fd1a535fb56da021cada7a86ba04b245d3f8892a15ce0c318bfffe600eb30477adc5c89096badc820199e8b38c6be9b352560e85de5dcb854917598b4182d4fb529859ed0585e2b4924f30dea00c3b4b4f583228049182e84a0bf0361d0462d808b400b8029dbb9456894cee794781a518dd3e503882bf6f6ba9c41f30f6e6e11b075947d6c78c40ba8bef0910d57b0c4f686f015b13bf28fa42c569123e8aca19206a51fb5b47d40c309f4086395739af4d7f9009e4f4a503095c64fd06e77c637a663dbfb606485702b90a067b4d0ec545a6d78e27fc9d5a63d684ea4f0b947d784419c67973d6e0129021a6df613cb4755dd243dbd83dbac49a186b44ba6a2858d6b79d51131a41aa953c47facd4e003ab56fe51702c0db1070a92ad459c3c44de7c3865256d5606238d0e6a2026396306493cdf4200e30e3cad837b1e7b58285f428ec238dac46c4ffd6bf970fe265ccd4986d58a902dc8b036ee565428a98a1ada2afe1f6ad34d254de177119f7b5ab8514834b9a9613e97e11e1d2b4b557876b62355dfb0c5c17e318cb8537c5a9ce59dd8cfd0758513793635bd2b59df1efb314782c3294e858e04600c09d0dbe1b8af84c5f1613e47c9fa019881e326338ac384c2f6d822185dac0e7703c4348daf25a8cb8cf2711c384e275410e0589be1ca133caf5f8bf727af1c048236c9a8e799944c630f7010e855f405776b2d138a68869d6b5f1db64f557a5dd904c3708b45fc78ea339cb71861d9a19c234c93baab19ff233e71b9a7e55e937bf761e8daabd3b88a262d778774c4ce744e2d7d8a1554bca1793e932bd72e684dd6bba77f9f605f29fbbb872fab1effd843b7c21250b74d650344422d3c4b5a6bd6aed090a260a468d7372797c9abaaa38d6a35718b2313aaebe9e3197a9c6db5527a11769dca6fc4a6c57459e63567d4730c3731955ed3cf4bfd9562add6fdc308461249f7bab0886e0710145cb6db47deca5975207ffa5a13a3ab9c8a69256e0c93dc89d84a1a0265bbee47b2c6505ad93bfa9eb176bcfa54ea0c4aaacc9ad51dd2d4ed2001146048454bb3320df33ea406709ad0dffa9f659f51b41ac920008562e36691c725c9e60df4d7c5ddb6869ab796548e1ea6d1ad2dfbbad1de9f3bd2912743368777824889aa5394ef75e4febde44b765a45965f8ec221566ee301c08befe452992f236e9d8f41677e3c9f1eb7f395e7b49a6afc8c8ead24430661c6ab709e8ee729bd8c9efeee5f1157482e0cd3f2b2d7b598f02a84fa8c8226c3e600ee3bc907a31b7a8e410fdd93b389bfd562e6934460ded91ee8e82dffae2ae2f05ef41dfd530585e4a54acc5abae5c6a46cbad9d2eebcb01251bfd63b2086652c76ae73b0097191f87d3ea0e7eeeee90876f203d0c76dfed3e6e95c5fe97f0290af2f9344f817e332b7f08193fbb0b4fbe7b85cd101935d930a91af45558edaf560ef62bcd64909c646c1ed24e7254175afa776d0e8169a9a00b8803ae49bc6fde8d29d41ed26fa0ec5e7a2ccfd9b2e808c926f6f03fc00fbe49afa0beec11a82bfe48ff32b66633e96297f83583ebc7f9f58ee45ba2989f4a2c86787a8a8faa5a0569539dba4031f956edb3e8fc22bfef8508571400b24e2a962dfbb66cfe9b836ed8448453fe62eb41a5505c2472af4dc4f61f5c1ddc193c8042b5ddc8923dd12f8082814c3e2d8339e05b66746d4efc350f40f333de8c085731c5e77ddb03c1a1e0151eb61902b4634d1cb5acb03ce2e6fdd1bafd0177ed714b2e8c7012957ba6e6fb21921158ea478044e60a4513b05e3d078a2647140268487dd12e87623833d24bbe3cb5c955add64fcd8fd1b668557990a6452ccca708fe8c17dfbbe9a775109c93a9e7d975f0bcd48bb740ce7fc38a7e58da1ef9d5338c3357326bdaa41412fa9eabed7268220d39082d44f58a4c4cdd3b2b8a81eaa70b7b204602c3f9928f5f227f7b8ba26cab3d074bad697b53d5e4d3f654e5c182090a02bb1a973420f8289f7f56644ad26cbe0eea239820b7234b757c35627e9a3b36aaed4f2b1dc5934004f0d58cf553f04183c6033ac1900056bd5c70add81c730067183144262bb1357e1d5dd1db487820017d162bbe23f70c87b9e51eade4a629ade43f68647116d59d158d2f96de53add5a65dc5066631f53f1cb654ace9b073106dfec4c86c1db41aed5e6a3bda0f0996237cfca76c4120afe93434baaa0a18de51c82f83d413b0486e0f09e231e0bf058bc28ed6798fdebc7f45f8b83d366d1d90c10ccde66206442f891d293ac29e1d6b885c8f34f590a51f1a670a84df234f8b7692048641e7e08e6e40625ca209743448a1f125e10d651b60fdb9d2bbd41c55de83c32fd43e0504470c533460954fd51d6a4ca2d1f7817c0f49847b080a03ce002fed7c541beda7de328cd79e40a36db65c8aa12ec8baa66074b1267e5a70d0aa0f8b1076292a402b9b687ecbb6f8a537e4c5df3f10c0f2c31e401de67a21826e4066c5d98db3ed94dda2eaf1a5106325d9682157ccf469e13db3ad6c2ea870860c12f90db9c5542f0bc2c7de39a0ad978179f0287858705b084906d39e6fa3595895f24d3012da36edcb777eb4f5c318162f6c72dc0aa7a5c8195ad28d72b55cc7fea053392e46f54686740fa927611f74bd69628682aaa72c5ed856e3d81ec918dcddf5a0b2751eca778550e7fc87f23ae5b87869b49e844ad4e045db25929532a598ab7e0eba01ba9096197339e1ef36b32e71864b5b39b7d671a6ffc3277bceb3a37b80c1d3e46d6ec02e10b8ee1c538f015519517d55c7644c7ffc9981b8b15ae4ed4a553002b5bdf1c66adb6b58924959269139651b73b73a6a1f0698134cd0ff2009ec2051cd9330af0b451f75b4aa834cb21820fd6cde1d9c5bb24adbae5dccdd2040bdeb6174496767c49f34e1621367e369d67ef8c3142ada2cec224a27715952c19c97ca6f3f1b47393b3e7fd91e2b32f895accf16257f2739cfd04813e6d93beb3c4ffa499c84d470dd796f97921f98ece859e2603891823eb525e523d6b938116341955a2abbcff32b7f5c52716d70f2b22a16fa94a3a6b5959aa501d3fab488ae41ef2a1cf40309f70802a9aa5597c7de890c75ee53641a5bc7d4e6a19e50752d12250a2f46ce03a56ed66094657a74e88fa9cf32bae4c2c72a55048e17e0c32345e52f264989644ee96bcabc6552f5fdd1445e737e511d448a1339a8de79d4c4494fcd623bce385e3df6a01fe6bbc1129b2e8fe8faba96c2c7171c714e547be0714572ceb11c70a06c43d3ff849fe67a8aeee89d952588a4bda5663055c16145c471cd9cea9aed6f20b0b484a41aeb23a5ce197446d6918d0952bc0e203baa0eab8587f72f6916c94f6069d3db1e6f4aa571c8d4f14e190bb7ff96c67ae636f9c6644a4a2cfec1cf2d0b22e2ecb3765af1921c9d47fb12af3774c99698f85f6123ec348e12c011c9c0dff51b0f49b2b296f2a52fbe0a775785f3dfa97e7f41e6d3406e1b96bcb96be2822233c9af0a881236fbda71e2f02fc6cf19463205148817a1c2654032f97f570407fbcd984b243b2e87dedf7c7ed0f1cd4e27ec7d99e95532f0397564c69a211dcd8e9696b2c1b0fe665cd3e6dd82cd9f224edb81aec92598c6892361957cb14f636500c43ce0feaa3e6a99adb23cd08a0d075c236217c7d3a2db20c164a25c9795415ceda19a642389b34d8009906e02bbea7d40b99b96f47ea8b6ecefbc4a0005154cba96ad94bcc74a5a5b8de0f7c00c519444186b34e6a3e4ee16f4e20ad27ecd5d2f0dd01d29427e0c1b22b13de55ab80a76ac86996568fefad631a306c935e6e5e874bcd85490a6ff40941c6bb965453aae8c0a5b646e1ceabd21619111a0c3a418288da6db6b22001d4401292fc36bf90081b1bdf34c7b1174cd09a10563abe868d73ffb403c25db29344b3f65dc897dddcce97023f5446ad70971e2f24df64222cf986a5de206f4e908275eb75669874a5b2b13925b4a9b6d6c7c3639868f0b753af8dff0014a93a17b5147195762bb491f3de993cabe9840a15a543b45a59877052fc0b93dff803b646771ea8afee8c181518197a2b329507ab74d33ca2392830b7f93b54094efe66e5f7e894f14cc4a35260713ae7b9f80555598f63c39d8b122b6386ef227d44ac981d0e2401974d5d79470a9a8a4989b45825f068d36348d9f62590ad469b94847957384655bcf5aaae824e4e6740e7cff3c6575b037ed74793460a5eb0cdeef230d999e4c16b88c4e8c6d34fdfac556898a2a356a4cc46bb2b2139a3c103b6b4bf5603fb22060b4b4ed2ae659a17fe49eaf4b662c98a399e1b53f1cf458a0face8fea10a20a35ee9233f13ade9f6f4c196984d275d7f94640be4e056fee05c744831182b90dd48501fe398f529bdbcdbf5c619cfb4837ed3cd48750f78784b1bc94927d0c7d6bceec061e4f14ae3c61d61a369b58618c044d499f77c8436c72d45ccf7c4fa45caec4342b7b41db1849f59cf67cdb52abcd424045975d84f4df0b785632ec07f5f661eb6e1f6c0e6b1c6e492907bc6aace80f0b980e9d44e278d451021fa8fe75b59ddabbf14e2d649c942438b30b1bde29706dd9307a4bcb969b6e3bea115d19b2c68f3092659ef85bf2157369e6868c961b1731e2ecec44979a4bc0d9488b56fd2a968e5c3a489c69d8dac81b76284daf45bcb42b3448000f4e1dbac4b93d5f4f53be54fc5231f846753add3776c41d9359057fc804042829da3e14671809cd636673053932cbb100d5e218401628752b8f353a3f3cb0f515507ee1e1427c68add6a03308fb2e665478f519bd3e835a135971a3d36eb9e9a8f9eed4dc6ffa63186c0475866dc94c3da16529b317589704734a732fdff56bad0c8a75fd263c0ade9a15835bf80ee2d728c2e72c56923a88ca3f326b951b80b63efbf3f0aa6d7a1ea9dac5af1a1206acb57fe052ff782922c0faa7ea2bb05b3f78551e25cd3c00032ceb47d73d65576190ebebf9b5ed2da548d32822541fe7d6d7fa4d317982ddd8c851e81b0e90fd052051af9b97725910ce6762ac1f24107ffcfc3bb82ab8689d9f9b3e27358d1fd129cf76be6f968febafe322277338590d6f0e490682b2f28c8ad59068134549f622a0e63e10b54a2b66061e46d6abf1e8754f938587e830dcaca27fdf7756e2e56b06eb1817bd9c168b5f26d65119f468f2a0657cc7beca8202d66b672e2ff8c0d6e9134934459403c1d2e694b974665c3f066c94ec80ecbab3bc0d2dd214183146a22d4c409d7ef097ab9d28a4eb9dc6540f45cb1be1aa41e445e47c84981977b7eebb11cc0adf5f6ec74f6be010d5fd8f222790f6153c0fcc7f577e9da5d6693f1ca234c9720ea7f1e764b3169c7fd68b950997de36d2064d835afc19476239c5ccd4e6e560979d2e2c110fbdcddb292f346468f5d91c96e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
