<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f6a744a523daf6f529cf6d6b264d3e3397cb137f450d2772f1ae40ab6aefbf545339b094e8ffe70d42dd91b2d202707b4b923e101b9db62bf3c82a263e4d7f092f97ea92b252450a3ef77c74bdff451c0f1719145fb0f9b18a38fe0a7042deca22b2c402c9943ab4bf468c3d4ec4a3c640008941d23072581cef9f4862bad6ae8447f28e4fcd2b9fc2cefa8b162aaf9e0e7c15fdadd3523e526cfdf77d0970e182911f3c1364b60b39fd0131aa9df41acfe79ac7e2af433fa835f59b6ef1abf5bb1e5e21b74802299e4260b35062039ef02011ee35432e1a553db5aea2985c0afedacb6879f0d7f556c4c5ec360c9048e553bee73706536a6f93f035cb72cc0a9bd74f447748ac56b4efe446cf07907098829dfee7485f61fe6a98b91b5531a55b570ce71ce5546625b35a29f9bf26958ae46608e73507dfdead627bcaed598719be97cb4f75b6e977e04b0c01397794ae0a03b3a8f8356007e186161a0eec7afb5864a82d80ce98d726f560cfdeb16ee0144736b7af21d1699d164df0fa573118b09b61097ddae4ab77d87a04d4fa48fc20fbed2acd6a4afa0ede44f6c44397bc592df17a913eb3a5ff4416b0a0bf4f0c29476c3ad5a789a665063d93ad35d8dfbe6e6f1bbd6689f3fbc49791851b333820d7842e65de7ae9bbaaa1f2868aa662e42eb174f946cf72920dd35d1c3eaffdd045b04365100ea13b9a593d729dc11d0846384d2dc998e238c4e3632b4b2ca308a9fb042d58af3a5cdc4e7169b7e34e14671869d8eeb769b3c4c2845ecbc421e490d843e13092089f65b015089755c967d91beda7fd2c59f0a87dc7763c21f2174848a1e2707e7dd675045ebeeb4f5ae25932c1e2f1492babfaac0b4504fe1acaf70ebdb8cbf7659ce435a94a3042d06f5f57aa83c7b5493e18f9ac5f47c097fb5d70d56bbd4db965dfbe84f7f1e52964a50622293931f08a798f3c2fd513f8a23738e825add6975abbb8fa875e5c492c9b2a8fc8981a639c44ee873a8abfa87bde51c0c3127b8a5e64ebfd291479800dcf2bb8f23c52b96f3aada36711fce3a24545d33891a318823aee1528282837bc50b53a087b11cad00630bff093560aed7dbc5b7bfaa89afe09a1172fdcf005b0e233851dd8095bb91a8b6eeffd674d99f5332df2e774f8af0be9441b38a2ec735507859ea7c1b15c9595ab0bb1aaa6723f1070b06d8cf74af2eba04315b7019f844e61d5cf11363a4c5bf043bccdf70b8a1671e480e3f24ba95fa94e92775fd62f0ed337ab754e8f9f51f9ba0ac51cd60d0b027b1792c675148d8171145dfbb2b1f7fc4db604d1165855497f80fb06b6621479254cdb9d939d3f0601354755509a0fc860c0ea3db397bff8821ac1d002cd68afb6596f3c7cffa1ac0a07c77f1383f94ad0ba1b3014dfba6e8b1ca14992c5b2acee3cc21176d3e4c27bb76b19da2ae56f76bfd46de2f0457606aa7c88f79b5013385baa9f978e5522a5adaa52ef5024e41b700da5de81546da3a7b1f92a0e7a3751cf41325f47a76db4f153366b2c4078d2c2a8e2a09e45bc17423d8ff46801d5446f5f9c378723b6492d0e04202255b94caaf40e4a51ff3acbd251addfb48724349c7cd08c1f3377aeccfb948b5165889fbd1420a98f97c6fc37c72976f37a67345fd2683333fea7e2726a7adff6e62bc03e4a2892dc13d836e289bdfd674d6fd6b5df9596932808dfb01d944851a71ba256f668470887914aafd0c22b914a207d163d7569898721779a09a91723031e03deefd3b8fd7bc87d98d173b3d75036cce7161b291e13c2910787728e705ab80d04eb6cee2315a6f6a9cd4a7152f9ed9086af35cbbe985e7f600d65dc78fc6bb66a191844773a36b196e4f8a5295a512b3f1d2ebe8dd053ed45412c0185323db6c533e931dd5d7767ead51fbe7bc3689f79fc521aa84510fedc2cbacca5aed4ae2d68f3d33c6755a44e0a195982c5123954781af03952b6ea8a0d0039b69b6252fa12eb32a330981993c550edbab7f37e4485e1d04c633b969ade1ca865db34a2d06df16e4da54e2e6c592d0348a67dd2cd9bfffc43be9fe6a99d3fa40289f016bdf9ef7656748c662d1bcd5e107563afca7e5846264b6c05076f53f6463f4cb1792635874babfa4618505e4c8308505d9c55a1eb5d06c05a559c01666838b4b0c3f405494873bcdc7a93f957654260a4df54f48001d12c84b38c903711207856a6720ee4143624e05875666165e6f3da36079452e957e3d566abf53fdc8813b556cfd955ea43f7eb781227e319c43fc2a280167703c47c4374ba566fe213f5755f2208ef21eaf5308afc230ff3bc43368588b3586835da0b6cb18d486724bfd050d0fee10d915694ea2180b8060e1a74052ed95c7f331af0409e024732c2a6ffbb069a21a6b17d82216764a69f6e0eaf6a53784a7dec7f0444da5bb744949e1efd22725f875cb0ff2f881a52bc204fa7d0d7fcc5baa57e6ffe592285ad16c00163b0af018974432dfc46b2c8e9e1f16751934ddcf5e3ab0f6caa95d7f1e6dfe5f138df15c9e45f8666ddc28c3184dd8c01f7f171f59d6ba01bdb1e97b78bbf2049639710c36a8a9d7aef36f75c4250d20b8e7c320a239557121c45a0a1aa3803818d4d2bafe4edf6712a370969248ad365a75d949e844db3951835c9b09029a3a0446a1d4e27156d81ac6e01802d5be7dd95e2534174753140a2e5817b873d76e9d77b06e1746a9773e6ecbed3c8b6f70cd5042eb108d3b0ead223d2490ab296fac49c5febce8b575b430a75ad133fbea4cfb20094bf32245434c56d52b2ddd9621dc6d9acf4c682b555c31ed1d9d0b2e8576a74a607af9c3c4cf943655ba50700183ac3628ee9f521aeb1a297872eac45710f676750b7ec986f6b5c8609cd4809bdfc353f8c4a9f80b3a6e637d3836fa33dca01a542338c9de81f93c7f8ce439ef6996ec0ecde294f631f47c1669109c4831094d21683886af57d451f3e16185f73ba85d8ef7fc971512e782d17c9410e716bb0a2211c8a2a5882ca127949a1ba1e4ba6ca51819dadd60e7a30811d467158e92f6614e2147db24ae51c7faf94d867ce9360008eff0c1f993734b0e33d523b51075b76ac0322846a56cbacee3ff218d8911b86c88931d368d6019b9cb707f790b6188c83fbb278e15a967db0c79709aabfb9dda6ac32b3a92f30d4421dba68c3f3d735390ca4698d407bdd77964b3c73d2b227754126db0d77f03922597ac4349cd8347b738fde8142ae323c6e25bb456f6396b435d27413ccb296627ceeb1a2207b5cb31741da69fa986ebfaad68389b4fba8e69d9dde708d232fb656cca1ca7cc6d935304eab3ea8d205d48ba0ef34a01d991f5a04414378f3fc10039606ea47bfa5bb3b07ea625d5a94878670279a108c4b421be77975e613c897301c930e137e512b45324a0c8961be0b7abb2516f9aff46333b70035869c880cfb12c21bbec60881184664db3f37e7c7234de3e8a4d0b18163db548b93f4e2261a9d800f78d7ef548d204a38cc1a9fd6b92a0597e9bb2fd9014e0d4a02fc093337ef5ca53982b0a5873046419ea2cc9c21d3d2179914beeae4a01deb740f3934238ffdd61c5f063653196cb56356879dc9eba101a2a84efdcac705fbf5826c71b081cbbb4dc99e9d51a8e18038d39bbf249751b96bd3cd3926e438650bedd7cfb049ab99cbeb4852347ae5358f7502a1e78e71ec3aa6c077ec4a6d84f9852b2d5d25321fe6b26152386b3c55fc19aa452715ddf10b9db2982939ead5b60e52d47af9a7b5884d80e3f1147f332ca6161afb4cbe370eecb5c1a6d0279549fddbcbe800575ffac7f86745fde58b7d745ce901f739a6a75881298b99ec312a1898a654640577227e3ddfcfbe2d80f4974a4c48e0bdb08c66a2ecfe1f6ecf6960076ec75d38e9044637e9fa0f846a7c4ead621172d6a5d2a0b6263ed8c5c353535b5568a4f221c5c76e75980155ec5733fb0044f30be66a064eae3999e62daaa077c61fe18712b64ad59fa7a750b9b87f2216617f92ea41b54ece19c3838b396883f08cdbd1cd989625c6771d3d992984d14a80c8d58b0b41bb5789a5eaa50a537fd4c9c0acec98b0889d2fa9a97d842b6f313fb697be4e84ba73e7b05885a7bb206abae400c8c6b684c0f451594205cdc65b9712231efb86e81b120492fdbed71559f33bcb9531f20ec5a3236893ab18904ff10a8849f68583dd366671273bed0648c2f961bce522ed7b9aa8f40b41ce142fc10518a9ebac8bb9c4025dfbb0ff5fb48f9a0fde2f64287e2b68bbed2f6073f6e44d4fd7f7fe854f1ead32cbfd1247f7c494466be592e944f5826967ece0fa95d16f9647e68a6e7ee0be0b79d7ad1888e77926d37fabed98539eb6eb470d95bab4444dd2d244a331c8e06ef19484361b9a01e8ab7aff56340711931878af326ab7caf30c8dc1ef08671e60b609dc24e9d785259c0bbbeb809a3726cf0ad17b0538a52ab477ce34fc5fa32c221eb5c18b75f54d6c4278217b153cb2a4ea189df16390e4a6b60bdeb8a7bbcb39ad6cb5575fb3230914f5d5f5e78140d5a38e5454ff1d3beac0c5cf7d4d992ad2f64df093d3c8561f1136682b799ee9a98cb46ef6b60dd9d1902813c26d299bfb0f47c67038be4509d5fb8d822318add2b3294a2c9b1f14f4ad627ef77d15794db124a0d17e8d205e6ef166d37ded7b9b9a59aa7c1a8304c329e727400b37f939684eb3101156a15646430ea3e889ee48d7cf7b88eebee0122769e0d662a6844e7f059e8be115c8a438ce917d0462e133cdc80332c49a04974e48de16f2322b7466416253d03a0699f3d3b69d73e7d1cf92d5cad0b3bcd9182036114fa47720c465312665aa250fe03aa1f305d9702bf9cbd8089ddd51986a36217aefc3a8d72b46ca4cc6d4d34bdcfc1595dc87b486876fa8ded12ef5071e0975b48d7300c231b964e64cb965b14249914e3fe2d4a9e49e9d720e84c1b0a83cd5e2ce6a7611a09564e531b202fc92a7ce5500a2851660bfc5c7f3be4c7f5328669573a2819828a2fbbde33c013f8d7a46eb502a7479313484041e733479deaba14f46d086a4adc36a2ddeeeace8880a7c8210d94419c0c9817c995465619a17d338db745c6d35ddd1dace9a8d32035002c4e1e91d4376c20cdb388f7569b0fa508b8ca38b52475591db04ccea2e1f5b65f20ff4b7367e679e7e350d11602ae75c1bb87a16e3442deeed40e1ae0572161d69b7dd014cec0480e9c13562b8c665a33663e24aa209396506e3e870c1290e1f397898cb379cfb3dab2ad261337e88ca84bece8bce7b2953f8cebc6799776bc6de7cdf47f3f6792ce58aec8944bb96cfa46fd987c115cc4448a3a01706eee60b54317f61bc97e4b1f244992a64617751df2cd13dbde6c8551960fab2fd2bb8fd2593f9ea3f52a0fcbf57708476cd822b7ad6a794b1035fa2c07726fea64f22f176a0a0a4cdfd5f5045d73ab7cf951c059666d0c88785c050ca8467d29584fbf284e462d8f4d397ed508639c6236a98a0814d3f3db12584722e5d84ce939b3436d454acbbbb6cf36bdcfd208d6dcff0c8466010a8f52e130989e94932b8ef7f0f719aeea1b1276c794615f2ad43b46a270ab1005bcb2e902feb96bbfc728e253d31d5db3cc24cc8805a231109c1a974029b084ed5cace22df7a46f0705b39ad2949745bad6f375aae8a553bc603e1e558659739ed97012ce39273ecbe854a6bb38c5daac2a14291cb5d82030a162254eb817d625db3ad10f31aa0528328310f7585649e244323a3682fa55e8bbbe8a12013036bec451dd11f998636825ee49c154bfaebdd9b90d545f7f7bc93058cc4b3ebe74b3755dd0abcef91d2be837bb58b0e2cece9505d3785b23d0e68783519ef2cb1674e5e8b93ee98aa5f4c50d33376175708db60007e7a199687c8dd97d9e3ccdd3b049622e281df46fed73213987e5b4b7d957706469c49a622a8750abd26b1c73ba6a7c4660d7ee09a2a636f0795399d589b81224fcd0c10724bed50dac58d01340199164d84469fbb5ed9a21751fec190b34df169d06a95f141a06fc1752358ddf85149de246cf127f19020ef603a8fdfda3b9d04c308e822a8e17064ce9db86bfcf85048c2279a8b9aafa5346a47ac581529b257368b1f97bc78908b6c7ace76f39341c71b2b239e834c9b54bbc488f74b0fa29255cc5526ceb48a2a62a7a1923741d680ea7639b753283930cd30d03a24b5d01e588d0c262294c76364314e2ad6602af43bd35e17b5864883fa36fa6681d2826caa2e08da36e9a678e438c6b46f71c412bc00cfab5e314a7906cd57e789ca1165bd49d9021b868c6fddbf64042cfa84c597bd184450954eaf704209fd2bd3b8c45baeee878120501037bd2348a35f7a32cf6f4ef10fd20d0fb9d70fd39b8d17db27ba07c3ae90680ba63fdb1d4d8b2155708865c7d47d09273a04b565571d295aea2ff03cb69aa30fd382dbdf90c085e06ddcf2b03bece93570c49b032b28f95ac393baa20bd6148946ce218214eda5ce997e66db8ce31023d1cc59c3eef382803232f835f8ea3c8bfc176f4655e638d8553afc6d6617484807ef68b93188b103ab4d3f6e6e7d3c529306596b07dc0aced19cf460db0c6e6d0031adff78268e864b1d24cf52ae13061f524b5a8a991d4636fdbe2a4f3d1f39b4a9404e3f0c1e53faf9d9dcfebb7be3cc42ca53e547e55ed364ba9aa2008319626c8cb9455155ad156c51087eb632793986fa8211a3cc918546187df5066aa5ae1d8f0d42a3035dc46ef818b5e04318c0f93c4f0753d60443f46b15dbe3c0a9b68b1f41396fc5bc6d58c3f3bd34410d43d354fb46ab8b464e231b87dd2f6a1ae7946606ae158ef6e297e801ef5d75ab28ff977713a3b162b22580230f62b282f2336bd01508e82f7c618e216dfafc21dcfd1e6560800e418133222f5a129ede3ba3da3595121f361e58ae1f0e5626e0d890daacf78d094f6c21ebe2ed0b1ab72e8a3d782769ec43e95b05c879bd9b29508823ec95ff9b48af9ed38e1d2a2d1d9cb0ae8e5d41dd4549cd6089db4aa4ed5ade2e8d2d3fc32c6a3949924a383ed49cb82a5bb2b721c62a71d6fdcaf388a10ba3c9a050d2101028de2f73106077599712d755dec8403117ef8295f43244da90a5b4eddac503d9f5d8125403e916b658d6cf6ff896eaeaafc051487f27df64ddd2de2476b401db452389b212326bee786694ae90baeb79582e34933be22f6fdb080dd2e783a44b374624c593dcefcb1fa38288726a3ba46a72a0343d88545fba6fefd377fc041b1f35a32262f29dd76fe307b47ae3809f5a8b20adaa1f881a137db701f9341511c9e7eabd6b6151972d2d18cb94ded9bfea1f0d13097505ff2f97019e6511caaf35b2e5240c568a59bfef029f28c2379ab69f64f1494c8634006a9061b0a7ac3b37897ec651070d59bbc84162247e878abefdbab7499f6d40b0f380e234255ee2860b789c8c8542322b73994e367ed3a8287b7c4efae765ef47cd53f4c4420adaba72168e5d82be55beb21654c83ad08c519325a4383b81892081868eef0c45c47957877a9637dc9068deb2eedd8e4c550935638671309a82af2fd490fc1537fedda6418dbe1b2e00368bf85c4a018911f569449be592ee6bb1c19acf2d70f4791c765c4c25a98bfd6afdecaaea6c80297ba0ff87fc1ebb5f0794ed977c7febaf7257d66285923323d3cd4678bc0bd7a48ee515eb9440cca81ae1e38b1ac718abe08631ad60ea67110dd54382784d710dfebd134ad00770928a31f8d38c84707278de6525b920f23d83006ac3b6d5418bfd770163b008015bef05d91d8c2a0927d5832307f116cdce256eedc25eccc19246cfb591f0f112f95002424097f3ff049086d53bc709fe9529105088e946e23827e967d31e21571a439d14ddf9be2da466aea595a414a46b582be9e9438d56c91cd42a3a2319274569f1a844554557f8a2f5bc967eac75b059e9c83d54bd7e569bf1696e74afbd05f4ecd9924ace8eb38d94835d7d990d70c16981d769b253b4d467af068e26eb1a5c5f3e6f4d62402901c82ceeb78e34f16d47d414b22ea19b338f205ffc2857647e2a310119d67c169de1bcf98a6e82a96b207b4daf96345c9416a326601dad661ef03a2e24389af796e71aaa276eebcd611b3c406bcbdfb9a486adb9045fcbb6868992cc5bc11cc1c0facdda4c7f12f5712f0e3e4639433f24e89d5393c55c5e16be8e8e725936d7af205d22a5e9443bbf3da694de899ac38c602f9dd835a309b39974c8256e046a6960194a61f97c2354ebdf5467e0b17e5b68cd48e75b3faea68fdf1b70b2dd00e4ab06b1386932a2769398fe98ce5fc202b3ceae36e88c500b817e879dca48d402dd619aaed003389d94539ddc0200e1edadcc3b53f9cf51e46b262e821f66d4e5ee9377097370f1e6cee77aefd681a89b7858ff7a35f40c7e54ca0879078ff991c3e56fb3ee594c13444e98fcc126323e0c07e0d6117645cd41139126aaaf6c1b49f80c8818a649e08bf8369094e37861a5d6808fe152c120e6c9fb99919f45a10423ead98675a8ed2b15fa60217ec3c8cb6d778cb06a35cc30ccf4a4153543d794898ad1e60cbb24eb5b325f711fdfa34c74f4ca931e66c34fdd7a67ffa04f3c7ba81a39d627e09fbcffd999002f2d95037bb6498252f0a4a87a776ed926fb6663d92f809e184af27fcf62c253348d4e6b395b1d15634f5ef3197f8f56b28f8d4102510e4bdafe49b5dcc663b5dc4aa456146488a47c5f68023bde6eae00db5fc21126aeb348ad4c514ee8d49c6d750fa5503894acaf2a48f693fe7a4b2593e7f019749d0d4471000abb54aab3dd59807d6e4b1168b6a83144c15c63733464e2212f6ce7f69c20eebd22f94dc80de779ee4eac08f7e614538ad2b59483fce9eb06b9c1965430d8eb172daec167515c708317fbde3b4c710a1643b541dad8d9e4c9fd22e2293a795fbf949cae699cb928db93237c5a2e9316479642e1458548586a7dc44a149e0c93cd7fe34efbe44c3432b446c046b7b7584c5321c99e118899196172129290f712ff4d428210f844061e203678d0763d9f5ac6794969ea3de71e3874c59b19b787f106d553459f1af5ad13b48cf918fdd6325935248ec8f2f060fab9fcf3fd401449b1b283b3b1e3cd647ab7636be47a648a7f855fc10ed296f28b0e1ac266257239b1cf9466b41bedca93e3fd43527d641afbb78064f84a39140c8cea7de0663e1261309b3678a80aeac8a7a674c20bb51ddc121035916f998274e3e1898a7c8473e5f701aeae44f8071007737e08e5c8ba635e7b271417b3a552269653ddb5d79337d1068b057e64bef6f2adc9d8d97e987486a9468fa60650b9048dd052743cbe7332a3dae10af900069b4f403dd851074ded2e17fb312c24704089a0dc6899fa4120b2460fff2a6ff67d4aa66125af82a1826d6404b17d19dab800b0f8933f3d108df324f7ade2df4b9c27d44254dd8a548ac9a061e2c8f7a8b3abae75a41a111e0f751c2e976591bd7e29db69bdeeabfc613b069d57a849956cb7c9fa1203e6626a90a834ac94d24d2a885ee5ae74f19fc546fcb80f47e192759951e5d13b4729ce9945ed6b6171d182321c2b0ea20b1a5de30f5f3e272a5700b000e6bbe98c6c60ac0f702791661aac50a175195c5d660022fd4ebc2eb0f0588409c998f4a23d72b4f5da73c12f77482888ba9eb6c9988e9ee48f8d1953d8b0d59a5e5a75867365ca044d02b2e901b05fa42e7db01b1b06f72b5a1c6d94faa5c369f5f9843abd9f141b6718b8da71f400f84a867bb3405198fcc3b4959144d2ec2a9926717f99fc8f7cecdd4ecf7a0f9e36bd9d63c958f9fb669a00d10603f5c89958d740d5e84a4884a3ed2c656d5a8f538b32b8dbca946926087b3a006e297a808439a2d57996fb9a1696c0d9d1f272e9b004363cf0247834e08ad16d18d275329d6ed21aa9a903516f1950c14ad2c539ff26e2ab09f60936436e43ab0cd35216da240ddabe1ab479609bb305a19e5a763032e2604cbaaf38c7787727d5b1dd0673c77895bf3eb4d1cdc6fb301f8b119b86960d888e934c9a3fb5539ed89cddc73d6075acbc14782062b3163d4d9f2bbd29071da6b9da7bc7475a24d8c3323d032ec75915b2503f4a6597195abd6017b54de1bdb0c732a3e2cb109dec0e90acf14898fa133d613de5130218a2f79957ca7b323796611a58f5021e8aafe886856fd2f413d0eedf7dea94c8d26a1e14fe36ab88e2587384645c7786cdbeb9c17158996c19c173dcced21315af0c9e721705e98b3d4a97f7cb090fb4f4a382f2c5ab02765ef60a6c0b38cd6656452c94fc5f54de30d843289f19f5ba95823906bfe66cecfc1d2a0e1962626b6fdc48c45cb0b26d5baf61e941c4662e861bd41763a11ea33c380eaa3abc70f4a1ca442a3a0a52c1e1bb1c4e9a74862d4fe69af94f81cd2baf6cd56bd4b8ce57a400ba0006d20d4571624cb3c37f34a22934eaf455fe95b90aaf7caaead81edd7cef4a8c7c82adfdd42e784cce82dbc67cd18897a987ca0cd25532af317a869a06a699a8174927aee4a6208753b7a77de07ee09e0cb1f26745c6ab8c864535434d0746cb96141e4070b6d13e7a49527446ea36c62d43d932b3ba36221288f3f843ac2996436237953d214789ac5f959c1655392a58e14a49144e003965b0dba0fa5d8bccc6d93e90bb6464c37ddff67afea5ebd2c39ae392af1ccbd9b5c8b93e1149bf4f77a984fdbe277c79dbb9735909124fc96f0d5506dfc9284154b078a0769f0cebc8d08d28075980c8da7319029619f86745baee4c9d954103fa5de868f1872f6053344ec516fcc56ee17ec3cc21789125a0a44a61aaf208170a02681a30e5a9831ff41aa30ca0cd5c4eebdfbf6d1711ae509aa0f9f4d648ae420c8b0eb696147133d42467e06b6bd7aa90772925a933c158f914ea68976749f5e2d17fcb441df7d4d2391e369e9c795557c3ec1b5e925108ed84462e0bb42b73c43b00c153966323d2f5d7277b4663bf4e69a6404f943b02ec60e94496a8cb0aef86958ca5e60e902242049f6a0cd11e4c7ed1e8c382c0402341a249cf75b740d207da3c0abb9373ea4296c083b88b89441cf99c263703334686ab34277fc4a4ea812fe93a2561610dcc9f6cf41e9fc39efcc149cb443f3c6c50e586b3df62a587ab673ed1ebc090bd71cfd8fe98f0854cbe70435a1a839e9e1ad1a581046e826ebbee3110cd49c30ce91bdbfb5ef1f46da818d255ea9021ccab8bf4d383998e42135a5f7a604a4acb43966c2e62fb64290d85faafbddaebc97424a0defe4c72e085fc46bad12f257b22b679c889d4b696c528bb470d20c6a15b8a0d7e74e1ed7bb7170f6e246e25d9b4ce6ff867b8207d9f2b4c99003129a085f7dbe5a1229189f6ba1151d3a1d211f82909a4e44b465ac7e236c71e627d3201ee4de6d7e39f4a02df1d683ac0cf993c1683be01ab075f33fa43dbb4ec67d5af4ad2a919b829e0552066203af79fa29b8da1b6ed3953fbec3682ae0a959fb5502f1e47f004a1f9f46b77aa270ca5e0274a3077346fa0fcdd215b41ba2162012d45a34e5ccf107b81844361b637ff05e1c290b541eb02b61f0f9e55a69b5d92be837eec8f551575e1e441f158705867911a880f973d75f618c73cfdb0ef1782f65cabc70c31586214a653078bb7348557099ca4f9312773a8a1c209adfff39c533f4c1cf039828f72f315286c805d606b0e5bf14993554dde293c32451095f6b372ea4f191c2826dd3cb441d06ab95306070c2fb9dfb8098a96de1f72270b463f28a3a2c69045e6ed08772265a36d5323a01cc2514ae80ab08ccdb0de7a3be6e2b7f8be0b2b55d2d5793ff5bb276c1ebdc1a7414fdecfacfe71e3b04bbe6d5d112a6f3bb8ca22ffd669f6dbb765ad2e17a62b2136e69440aa6d66e7ad51876af40f76ae4514a2f87ea28716bae68fa852f36df0ca269c6594ef5f0591911370cc054bd9615c074a1cb37cc01c6b3d7919931ef582dceb78c562b766929d778a9191c268f8e00c97c878448bd4312276011f13e7708b8f701865eec2f37c0f83debf002fb2f999c62934771d741545a3b1069d50a5a50e11e314086b7188088be9d364afdf0fa4f046484e5a1df2e8aa62c30c25cdbb606489ed105937ab6321f4ef38e859ef454152266c5238b8f40b565c83eaedc01071b1d31d4acdaad476eb6b6233c912746511abee5ba728ec29ddef4e293f5b9b4f66d50bd8ff55082f68a49b9db43833a9b0894ac1f91cf8a5fbe21a87df9133489804077c6fab2d81bb133d54272c54567d23b581aeda9e6905469675dd4aed05e359d7dd01c485586494fe1db6110f3216de60b162a4098a8a12cc4a5d60c204d101636c67e9f63aa27adbdba325407fa14f7efaa8acb85d1ad9f2f5ab1dcfca071fd350cf5885bd489ac547e830b1a2a5275c3ca996b53c86bd7fd01ed96b1aac591cc425411ddd58c848ab6b70c9a520696d8c7fd726eb492d1622e5b37764fc74259e932ed342f948486f1000472009a7ce4db7ac4bf6be5f6ba683d1dc4ee7f27967ea1fccfe813a26d60a13c554dc8a604c2a76a9698d4427ea509ed8d4a56b82daf35e2633894086408d357654751c95e4d1d94e6359b08db5e115d7efbf136c3bafbb88522a0e44258f93c8fae85300c1ef33d2cba8ebed5795e3a0ffae8f19885d0c77ce48e9892370f0f797357e4030c90669b785b0764535f78a024924f55951012490d99cb619dfeba20d1add253a55bfc70fc8b48fdda43087ae0b4c138e607a93d3ead3e540c0876437785cbf2c227e41c475faec20477e408f93d578cc5298c9660c3b9287c650cca6e7e063473296b3ea8be8283c8faa777732de10e791462a164b203944654a4f469b7a93c33c1a70fcbfe558acd90c7f361f4cfbeb49c1b61bac8b9fd950e72c8e13d2cd99cf5251bc84fe42139ef37e3dc198b5fecc82511792145b43c6edbdf1517e58d6089549f0680ffd9b0905d4ddc7e9eeaeb360bbd73bf5dbfeadcbf76b50676d1c2ecb13586993cb234d17ef9222eeb810b17ca65e9bb9a13f4eb2447053d1bd3f0804c1396bddc921d1e02f237d967fff650d87c5ed778780997b140969322103aaa304febe3fd0d771547a7dc0e7d2ce0d5efd544bb52a4c2b27f9353f2604f6e6e716834d252677fd85a11b63ad1c93c845ce6cc04a1f7de4946219b01b4a099b2f31a2efe12817e3e144dd4f62da2bba26ed5295b17e70e80f038ae8aa526e7e7a63d5b51e5393da49e6f294cdad1bd135189a445c5e4574e03f4b3a17a4b614d6a12f6f4187bca6a70d4418dea9acaf60eddcc9d7607ff144bb604e2acab1c3088038ad4922b83c80252e29dfcf2ff843b177542da930e106e83853058a65e524d4c394c24ed701560856ceafd27654fa96cfe58ccef023792d6183a69a1401d45135dbd458d4bf7500a306e5de0a4020ceeabb82a9bfc136b346b5b2ec6bbadd7509b2eb7481e7a008802c9b0ec0a99653b53552102d944bd58ef5ee63a5f0a01c039c673b9534178a41dd2fe7fcf04d4af1a6fa8ae262f23c1792899b5e6d013dfc1249512dd85fa046c598370c2b1affafc29fde7f43e0c9f3f56bc2c0fe01ec5e879d38f8bc5031f1f2aa2c0ab9bb2eeb5bd46acfc94e262e6fd7d86e24d416ac3434882aedb953318a31cb04ebe936c44f4f4a3fed58ce8364f131f191a7adc4d58b5a2b48f7b8c6c16c2b7cb87124c8e32c120a8b930249f18a316a4913e059462e36bb6a18d0630300dac43cc418469f2329e39dbdb7dd5bcc621ed5a9ad3d64991d046350f4d7d0d83a84f29f7b56ed22e2251585ed37a1247775efb957cf85562c37939410e2cfc194dba4602000c0a781db5052cb90a60444e5ac3e78d0762dbab7383e415ed0f56ec2bc251b8b090859a8eebe8e63bb4739681843d5d556f5f063962e144ae70b7aba6804e1d1335c0fd124518ba2f0d1b1be1e9ae3d0636a7465823a125c1d8ae90a9b4cbafb7e5e27f3b5a654dca1aa83fd69898acadbb2d5ca02dd57a62afe57284562d1c2e39752764c6c091a41534e4e5bf35911bd97402c12799a5a84d74f6c257ee51d0b063376b96ae272dabea516912bbea6132a2d971fc04a680a0243da2cc6db0fd034c920244f7e7f3a2c5e3beba825eb4c3f56e34af482225a9a6127367bf14d1157139a04765d1361795f421cf2e4019df22d9874e7c44efc8bb7cbbdc32f654c91cd635fbcd6c04ff0f25658c04148b9e79e3f1d7478722a7958ccf7fca88254bdcfb8b3212be3a390bb215522de196d8dd603469ac01ec34278f53efe6c79fdb27de39d4aedc17a8ce2dd13600a6332c243910c610963c8f93394fb52395672d75b5dc7871d69db33aa2eb1ea5c91c8cd33cad4604640e56babb32db2e37b62e9240069329ed2111cbb19fc87a48ab68db97ad0fe1048838e8346ff018f5c8015e97ef065dbf244be4570d0b3ac063e40d2e7e103fe738fb037683ebb918799694cb978d56e7504e1c4469d42c01b39b1e2eb2b3eb458dd728d140a5b0f8ffd73ed873c671677fc5965a7ff5115ca55bafd8c7b7068483bc01e21ed61b7d2da3f1f00672e920dd9cf34a3544cbceea7027fd13095ca93eecbbd676bf292e9fcdc3bdcf8f559b2f479bee5f2f71094e25c00c056e17d843ede93b9c2cefc15ec9ef3033976b8b663a942ef9f6550ec94d5c934b30a86d528aba86c36efcbe1ab00063420b061c8f75b3c105034fe7b1740420a21678948c6b4e95df978de7c4899e269049c20100c4db0904812ab4da61be1f6c29251668bd4c9882e3cd144b32be644b8be5b665147623678db9f80cfd4581cf370f8a1f66fb658415cb81018268032ebff574199f6031abe94acd2f193892c725155da5a284cdfecd15cde6c0faf33287f1422031fe97322b1347fb4e135d28c9a388279793d86e9b58d89f38666ccf8fae1465a8545c0ac506e59264ea96731d102ba3a61f82228dc0d61bdea55b6a8249397b2699516be6b7e6574d0166579a571b960f3848b66bfedc7aaf83157a8f30fd0ad43a90bbc4e1a36ae21ee93367fcb1342b30d43b23f7e026ef8aa35a943a223e8e4232eda233107b2ffc971683c58fc53f7065a6ccac4bce9d3d30198c3050dc92671afd7382e42d19ca10d27c75596b3de2122986f4cc52485c0123c19037b5ee52f43cb11625e72da557e9445229234ee8cc11eb96eb5f44cb599ffa31d295f5b9ec50dc91f282878ecb563acc979f5c7e614a9d72888aff19f1ddc81570b0f4d5c30b1285091f1499f74339e72c5857738c437f067baf59b2a50890d60f59ab4b3bde7600a27020bb6db032289e8cd634e9d84ef832d89edb26ff093673c732ca2423435fe20bbbd75ec66600b8803812c71200b71f376cfda55be0cfdb0ebc514e04c7c7ea6f8ce7e46105df6c044c728418a4a804ecc1a4b9d0921befa5324c7a538f3b5c4230861b624fe32736e46ce047e1059734d769836f9fc81c6648b31f343437bc75d8e62b59fa8a8b4073ad690b32bf3bd493087008b97f37da1bd464a78c9ee4ee580ebf655f2949b3d5d5fa3b462fce5576154be4bb89d8dc104fac4f3eb4cfa738c298ec296369569759d76caf53c94e850bd828e613bd715c45db78d3cacbcd33dda63828d8dff68515f7d0a9413814fe21af8e9835d6c7748c479b073e6e6c97dba65b65c245141a4268e77cda6b4ac7a6f52c6333596732c423449dee7c1d46fe58a00f78dd8867a132618112c611011767afae06cbe8a7896fbfe7953842391babdfa7140e4c6ce18800082404e3c92c6c2e1d96ebaeb6e2babae0428d7ee443890c565b052a35104821b066b562130ca4ec126af823ee03429b39814cdbea6ed23583a02d6b1292b955ecfcc37da838b61d2eb5c26f667c260ba8ee914ca2a20e707fb2930acab9801fede2a229de8a28fa7894cd40c8609d96283c27b0b9043ee6cc789922f54cbd33d4889f69a74fbda17c06f0d67e3ce183c62d12c113851b6ccb88ff1dc0714e1c7d0d9c9438fd7c39c3e4822d74306c1e3c29f51bd2385acaa5420213582827764254194f74f19f235e28e657f0e3ac4839cdd6b1986a5b04464e099380f2cf607d1a8d1220326854492cf7f98cd85b560c8ec89996a6519a1f34a15314069a089648893872e131922c6d86670a43c547b23938130a88245908eb80b0a7b1dad43e01db931ef0092bbb5b537551ef5504504243d36947c1d6964d09a30de1c43dce52330d7e5966a703035b45a9a026bb14b48c0af319dc9da0ea28a64fa3d112a3186552e5d5b85c79b48cf23b000310c901682c4c5597102b4a64d6ec1f057b49b116cc339febb9aac6f0ab470f7fc0155809187c5883ca74cde4e52455eb0e0737756ed30d6f114318f5637035e6f8092d4535c2f475ea63e49c9768569dec25644968df90b47b66cec6e5643d3ab5264eb41ac73c0972f997f799306bff2e708cce18cdbdc1efc13ef9562a5ebeaa97cf7d3dcdb95839efd7e8770407f9e8be8c7e9d3aae6a214900a8e5f38813ee93ba00a82c2fae9cc43225bfac312982ace64fc64a6003e2010421b97b691258f7e39e6250d0e371933ee5ea09a204d4321e0aa16ad5bac76d7d92818c337c605a52abd1df7c6171065dda2acfe2981acedf7f0609b7c29ef4c78921537618eab42816a9a66e75bb3929ce2340719c7801db3d205ba431ee56fc2ddb4b9e242a3643e3c9b0fd6c46027af403111581d69aa732e9fc494f183fc33df1496477e906e0b5343bcebefeded5ff225b8b39864c6f81e81c189dc957fa2661af72fd7b4009cb48201cad6ab0013f7b3d7142ea6530d4c286a51e3ed2013497e806b0d2136047b16b3f08870a959f9bb7006d462753279f32bf948353a339c56c66c845cc74bb99e658e6a549b9176889201df47702c5a827076a5c663da53b56bc981469602f362eedd9d48ec4b7ad67ce0e7afdf6266cfc24df9523b84992866de115b6f0eb18b101f523d780d2c56119dd38adc1e1e7d9320cd42ca91800ec4d8b1e0f79f36b859147a63608e13f572971bf5c8a80ea5bc46e1531e58a2873d08a4dce69b15610780c65f46bfeff5cb776f7330778741a270135f9d26c453d0069b2d6e5c6550120364bdf2b0841b2ea785fd6e96e8eb3731f6fcea0afd4f96af2ac6ee0298f9f18d23a687ec08e990ba7dd80b6268c54a120ebfed878802d65cdc499c095fafecc014ba7ffbf74f07dd2fc965070ba421440042fb89eeb423e3ef08ea47448db06c1db1cf9f22b336060d011906ecfcd098abc3b6563c199977682028a177075f1cf3b59375df28ac89910223de246c737d0790f843f49dc0c746b0e016ad0f6c737e535b0fdc442dd7ccab27f9bcffd121a09de62aabcb9401227489c34e72eee4215ce430ee79704f767c2ea001fd4b4b750ef0c9e03a4b707275be1c4e0f343963bc5862951742dc2674fc804e238c58f48a852ae95993a970f1c9ed3c6e8b47a38daee27a52179f6f5038b7409b76cba4175dda1d77a9fe0eeb23a8c7f1ac48e27870de1cc48a8de4b99ed51a3e9e39b86d5d4dcc64c61b5b74d9e47fd89565b2c709d321a2540f52c40355c1bd3f3ad4b89f25faa77c3d78a4b7774bee67b48ffcb187606b3879815b6f969cfde614dcf4787857a4c3b181a293ae5298887a9bf27040ef81c06814a511c577f000d99dcd4339083fae2b1024d9c3caa8456009d25cc19b4d9ff67dfb9d4c46ad2f2b59e8ca146ee9f45440a4d41e2fb6b010265c7663d940a3b6d912db3d54dbd3081be73f41161adf6211a1d14bd33fafcfc373c7ae6e502d743f8f2758cc45ee665efaa8d2ff61ea70d554bdcb8fbff57c7a3c16070000a95c585f265f5b541e9e107efa05e0bd2be0074e6b331af0b2c9e9b013394c4d5a2c170765c9420b4a1777accbf654","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
