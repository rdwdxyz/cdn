<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db3cb30050bff9c60820d305d19d6ed7d88e7bc8829f81de37621f2f2889fab7cda102a2a0c5a4948c4a37d9f0a4e9e917fe0668056568b08b13ad1a35ccee14e7b72719510677522343fc63186986f8aefb278147a95833860a5bd8772c05dc914f790102e9e81bee617ec9a782f407563f3956bc58a482785218ac807ba5c977b95b31e20d89610baa895f90c931d346245f910c24b84aafab9461baff559b452860b93952ba11767ea6a00231e76d91cffa9fec17ae60b6b7a8f71b2b1e9630e6900845ae77e830010e911e2c4598b1c3af9a2576f2606ce37bcf7306d0b3d015722074005a70c5fd67a812b6ba1a7bde3857609704094ecaaa3ecc760d7c923e351a8ea448a53271dbeccbbd7b1a644f3c4eec0c0c4e5e39abb052744fff789a5e8d5b4335cd29b48ee4dc0397f9719ee45c866bef57ef161496c7dac08c6a7b662f9196b71fd2800af2973ed595f8fc81cd0b348dc486b775f7a5ae7c3e05a2f4f9cc8322978692fd61062abcb57692f315a8c1243170197b07c0541eb4e169c14d7b08e2d6c9d1fc867c3277963411cc4fc87fb42b2abaa3fcd122ac9823499fef11235798f70848b87af1e27609bcf5b020e3f20581c86705654ce5830b8596cc73a16f4e8121cb1fe3187821a75f5f098ad85202dc5bf93d13c767d46b44a06c2c436b94cf99085970c1a36f871cf39acd251724d6da75e0e2e037c22570a6743569703a7a9cc915010e2c3b17c2f88a1abbf14c1bd1e690dcdc12c9fe54ccf0bb1174c1e8603961237dcbdcd8d355aa6a92e71b564f6230ee4fc242df4f0b842bde1a21cf7a7b20e292156ea22a242db84520479a1dd9af8d7d12e96d72f1d4731c07bb557fafbaaa53ce1aec4ecff60a8b4ab57bda3992878bcb2284d873e2b2b91e2a9131b0949f4ff46676ae8c771c3b9852aacfb7fd3efdb6d7f5cd905a9e3640fd01e5c18b69046f7dd2446b9084fb07014b20c1c5a47275ae038ee66141287b1cbbd760c8861478925e61f1b310608476b4df407b1c877e1b829a7bafc75433686f43eb637ce9cf82a410921080ad7e4261697f3f43ced284f877f9c543f94fe447e17b16a57263425c723bac2f5fdaa441b3dc228e9dd2543b39f2e1cebc0fb40361f5ff9abe21d040dfb151b24c9ab127938c8fa1c04ee9a339c6da6723cfa64221ec18e16d239efa26223582b342a622e25db8b8110bf7a943cb8247924a0e469c8a7483d548bcdf70f2ce7bb4b93a5a338e8f5c7840590cea699cee79dc77f3b17437acd92b9c7f186173077e51bd3856aa78bcc8344d6adda202915bc1059bf538589306f3192454bf2d86c80734935ba3560c50bc32aadc0c709668f6fe39e691888f5b2514b3fb7f335a0edc4cae4b7659141c31a9cd56ee5738e5b123de4b55e0bdb7f68c4eac534088b8095ddbe225992cb60451e103e13cacfd54c237eb524dc9d621d3474d97528446830ff6e6998ebb94115619e420917319f88668d2bc02a7fbda3a15a3f056641cb8be39ed67c664f9661626036aaa2155b1cce9cdb39c1606866f8ab279b941f88cd899d34cd31b01847d52c5204f2d7b7a3f2f57970c0e5bba52432036a6538a9e5ebdbe1acd3c99329411ccbd9138301afedb56d2673721275510d30b2dc34e98266898952956ac932e1bfad272d6971b13ffb729961dabe5a588b4b3511d30eb993596547c807532cb081c9e8b6a3bec2bbf416a0c2534b1db4a575b7fc0c7d289c9d3132b6c117dffef85fad53d6fc4bb1481e3f09688f6f4d911d4e1081b6d2194af3cfc6f6e00062aecc4b227bcaeffa96fde1dc22dc0630d87e5fb9e42bdf1bae8605680e5da1282c22cefd5d727fc5c7679a5c21227a315a25d714d372533856f6a3a0b3e65acc0e12499e7803a1a75a23ddd52aeb093511e62b90134e6bef1d662a142973b52a2854bd44c650761531ad60495ebae8bf62459473753376efaf09844b3bf86ded6ab26ac5adce8b42199da691f4c0fe1b485ab0b38c76efa1eedb9e7c0b16fa4e0fccb1d39fefa3be1842d5da81669ea15c2948613485424b1e820f31fe20ad715f2c4f0058e10c18bc7bde719dae7493aab69581588ec5774b0da10579cb657b107fcc8e07d803fe4a2555a7dabb7687ec77ab3767f1b89e18c209bc471e44e130355630a3e3f76c89082a124e88118558d3ad9bbd32d4c961eba7e7e33bd2da9bf10437e63009d51cec9d68773b94344aef2a3ef6bdd9d54f1901c7ff2177565369cddeb7070a41e70c28ec214f8e2d451c903ba7f0c196364f891fbf6d24abdee00ec4973f4915563e780b6eda3393f4b34e21ebea399f3a5df7d26de4fa26a29a451eaad3a2c69e4a0f953be96a0ee424d49e64e673f4e7d2406db64f2a3cedfa8c1b41efb44cb1a4ffe9188d28954433af440e6eb04d5fb0feca7d2e38e8c8d0df5a10c582ce9387fe2dfa4a2ce362ebe1102b38f55e0d5583ada8e13c0811be863712afca0dc3d2015d42dbd969271cd28609c4a754378e038acfa974fcb7377261b6e0d7f6a6982af4ba1ba0ef383fe7613be276a96ba1b5956bb3a00d408e9691a286175b8a34ee6b10eaf4946193a12ac21945b98f4c1dd2e585800d85f76905ce65baa8f6d64b786cd1d3bd6b653fa8c8346fe43d4fb8226f90fb8450b41b421f45df974116c8f0d985d9cd08d0d7671f9fef7ccb03e5094b12724aac7acdf5a003f4d2c9fb0b74a443c2aeeef6a7a6acd1c9df85c3b3247398b92be5038a330cffbdf878fa8d8b9ea20d265ba47f96598992d61aeed07090cf9155053bc6cc7dc45c48f3d37cd95653cfdfa36886133ae71f2a9d334c923450a1caf36d5400cb3759c384be304ab863b8f5a3785938ef0e897e836ac20c3f9243185682ba46243723cb98d514afceb2d52d2f1e23dc72a4ce45ad8aea69b0bf433fc21700c6d9d624b9720b8ac6114918f82a7b87e87c9cfd15022e3cb1d6a585fc0633e4c77ae3c933baf2bfc5b95630daba7c26eeefa0e501ab66fdd3fcf62e7a67ca137f3326bfa5d94702afb2fc2a094a16342892b38dc4fdc5bf26b080ab028b76094a8e002edd7fb8eb0ccfa2615b2c660b6791d09a5c1f5283b6abd11cee11ac55df2e1330211768f25276bb09dfc33da56a37a1c7df083a6bdd43a5662487fb4d10812bf90ee8b9bba0d7c794b9160d9b86ec7df2aeca6201182a74247e1c9b3443b382c46556f8a21dff9bb69d42db46d093d08a5d73a7c06e68a605c864cd490b72a87fdf109aa931d73e1083a010eace4dca90efa7354919c8cb581d8a9b36589314fc975c9f7bde5f34701d75fbaf31dd6805d3f246c3e9301c4551d8669f664cbbe2fbed1192f9e6660f34272526fdbc6b16f9860054047cd9945cc426cd0bb9ef76b3a10fd97648fc29d60adc7895702a2f00d03b8acf9b5a51008c84c833bf38b076909ec1630480fee3bd019233b0e4f168925098fda3e471e01c36b33015f9bbb714b15dadcb866274e149f32e36e3012e91b0a009d0c39073e14fb28b1ebe8029c6f543f194279cb6b33729f839edae6b379117a4888fd407fa41dc759d06d232d092d7761c9a8a2c65c82e0e5d8ae56fadf3ba00ae063383d60afcfef905d46e86195fd44ad90193566365b8eb44209ead9250d2a0807a7c7ef54b12102becae5a9b747872a925b7e69cebc15aa016411863a9cc3d0a0ccc933f1b97036c029db89962f8c2d864433232ae5a92a2d8b5d4e85b2b9f787c5d7e90d8f6545fb8f1109a17822aa4b9d104089a5d9b39705da391cbe5f44303a0ec64c70abef1c7a4ede2ff53e21bd71338b1ec9095a2b39aa58415731a1a90e36fcc11eaca0a1e05318be57ef80296bf66ef01a44fcb91c98e4e1b8f26433ebd4ddfc8dcd317c66c2a21a35921ae9cd26cce10620c5ee932d86959ea731cad1deca596bc0974aa7f8f2c6cb39f3b5b99f01ea863fa6f894be99d98adddd168ab296b4e4c55c5f0c1ec69c181ca5ce45fce886ab5834c03415f548205c78fb005cb93c957a6efdfe26f314745fd5f5ba88038293f3fe454818c78ca72cc8abe4d7e0ae1079006f36683e30b866bc23d7383217e5418d5ee7edb09b26f4846c1a9a4a0aca3395012afa319a6beff59018c9222bf10449662d4760fdef89ea7287240f7f1576562ea1e5f1151b4b489a0168e3cbd8e0892a5f635fa11dc2e902bb6c0cd05792988db42b45b56e1c4c18f91d5664ee485c250b8f1722721f4e0084778ec803ff0fd8bd810b67f922381aa8a8e7b8bb8d8289ada33cb1ad45c6ac6ac94eee7295dd4b39f8f539ac7c4f35f2759aa40df22bb96f58a2b4f0a5618f80a2fafa43ce6289f1ce1901fc4ec25216ee395f2bb53aa6a39a3043db31b5b4a19fd3fa9d1f7197f714b684ea65f6e991fd997f753f790768c33596bcd8568d921995ef42ee94d771edf6b2ace51eed46b93408bf195a61a2d70d0db174a4e1ebbc585aab15ba5e8012a587ccb12e6e77588b93d2f821fa182ee0e3a9c7d7c49abaf339c977a355ddd55434769f71785175e07b6fec8f764b20b48fbb8765033555b3963cf999314842ec6341d82ebc8ec5d78e4a21e6be3b9fae5d8cb148c476a116e05409616cc472fb3cd1ea70fc6229810531c51de7eedda6287bf3c6e53096757d73c2c7cc697608c2d63120b6a287eacf12e6ee922b5fe49cb78535ef65e55652e526949def25a484eeb24083c819d558c701e5c9f9843ea7ae9eef802c5af2fa4c96721d47f5fd6a391e3075f51eac9d1a6cf299462805c0b1f3a7438ebd004415aefaa02cde469e4a4a9ceb91dd7ff47e1496119e98e907acc719e0000bcba8e253a26299105a3a0b45309885fced411e543c4435770896c057f2fc8226e5df3824e5cb6ca9be7754d1d40286a70c4947aa676e396698c7cdf4671b91915941f1a0995cdd0c20120cbe80a37e607aef537426a658cb7f87722497003772c2560b15e73a8d8392501b4858953f7f79365dd324e567fde1949edcade865dbf1fd38deb3842ef4ee7b4c82c1f7f99eb04c8831e4b02724791c34026b854d595add124451c1c56a06f072d0c75266f4f9ea1c9e50353ec1a5346e80ed50fdffa7c4924ad7526eaef0d102b6230e9797fcfdaecf4b2707902e4bfa808bf0fb6fb6279574a0b27678a4691c952d16fae3cea879b33f30e8d4d7d053df46f46ee54dfa9e037ec6d6c9c2461a2c5105680bc7905d163255dd945d98fb3bf0a339cdf3019dc71d87c89625aa37db8537fdac752f1b0981b256d6925958a97737220bd6e953fa27e1c563837f2c5ed96ae74d0dffc3f06a2cbcbfc11f04d92fa0e341fe0af650582223fad27abde28e2ded160c8a0cb08d899b92ec7fe036a45c91942d213149e4f0326081b3cc9eac34efe15835be1b202cd1dec5e87264eff5f1cfb7c31bd1c647c6098625fa8d28ea62a6e88d52d8438c66a84a72e148473ef93f6664bdc6719f5a3685a42269c71e2817aa4c9317ad84df131a02c9db85ae02c5076d3e96d78740fb5b45e35cd509b817035a856fdb716f4d3d2400ebeb63fecc20f551a588e01d9baa4ea231e7da4eeb31d32c0de5ee9d161927aff5a213e447685534ef97181f570762c9a2feeacd84be91588e2463bb1782cb237c8259ed9860ccd117fa0551017e41889ce93a9bd2648e3891d88111ffebd4f1fc48fa88ab85691d458363d246b4fa58e10058fdcbcf31fd89497780b8bb4adc32d5a75e66531287400747760266e9eba1bb95beeb0079a4d16be375d6c394f821a605e082ec01a760705bfea54109cf2077b4ad1aa47a470ee19c6234deb11cafa7d95ab8395ff6c4d587026f921daef35fc1cc91a328a27b4d04e9730e4292484b8daa7c0c359287c426021b2a92258c580b251ce09433fceedad2917f1a073575317ffd51df6cd92702a3279a44247a94b4cc158453d107cdcf459bdc1879b1fc09fc91684354ef64222a39eef32544b1d5f4dcc9d5f22cac1b4602ad7d31482b449b904d5860912a39f033654b355ae451c0f1f992ec40db624c7bd0ae04d379e5713b65b6ae09f601c0c8501a74ea8df3faa288be9f465f623eae3d00ed2d633b7c871e39638fca818aeb7055b85c16f83736f2fac3b93f6d49811f01d13b791765292d52a6835a60faae4a7c56809ac81ea73c0abbcd622e33bc5f2dbef311d37c2b2b671f76b15574f2bd8ddb92eb789ce125b6abb83d4ed3ee9dd1fd638c2e4c91bad299a1a2850ac301d8b224449a700731eaf4e81ebfbc915a6aa6c921dc15b0ebe82b619b0ae059578625448cfb93ba93a9f92fe7e40cd110bbed1082a5ed2364074309f9abb51be069e083870178c2accd27d4ceb183440b2f03d59acb613eee3c319089769ca4c941e6c6b1ff9e50e1802c295f008ab3657f50bc76e6e45305433331cdf1515f99d8b1550c7080401e3f6a7f2c5c92d3699b266c98fc3a1ff0679dab96b3a6f803de07a96c6fe68923588431d9864e294ef786b803b33136ffdcde54f9b2e3afa2376a00ade6e8997d542ab764c976bbddc0b86e63f3fe67f8f065f001f3bd43018e0ff212b0154cdac24a13d0890fb512a357ca78122dbb315b8db664a396b9f9e932665e6cf11369e1943f9de860592542dbc77243fd74e189638db7c664fc38f30611ce1e089f35a6786722ae7aa6fd9b5f05300556e03f5276f114dd12d509424914e16a85cfa9450aa477db9f7492e8501087f17bf28f24fa1b391861986b9788da8e624b4a762d6c155f74d15d665a2bec277a7e0fafd7d6fa347bf2fe596d3873a4a7a77df7d7bd2bd4955a7ce9f722b404e4929b6bb353910d41d135699e73e84e9d7d5e1000aee35a97f29f448c2fd8a38daa8c7f398c1ec542d955870c7820037f2f430c121b2dd0d9b6c97626bce2390be3827d2e9f90c4b1926bb0a9db3963458a774b90dc7ef5f8eb2b9df063023ba3aaccde062bfd706a4dc7075399c6fd01655c56f68acef693bdfc503b15a5ce04d17edfc4574f9a73f66ad69d6bbdd2b8ffb1c70803b06c502163f0f57d1e82fd0a88c28e688d1b4839031a357a2b50ae6a5833fc13032672d5767bc7cd6e9646cdcc60f88957bf82cf182c29b3e0106a26b3d7814cc7137224e1513c540a1a2d58322de07e7b0439072ff61b1c8e7bdd8a2ca85322adc24001e69555c9b866bc201d991219823445565b8b2e800c075e1aacad690a79bee7f72facda5bc872cdc4bfb2b7620a6c070fe05ac26ce8d2db7e78c3344fddc30cbb646a4c4ee110b9c3e0938fa4d0242e94938ff7f217aea3d3a2bf20c1663a233519a21c8681d2ec76603af9e598eb52e4a662ff4ec794d019b38292abf54df5e444fbca6811c67cdfac90097ccde0b84666160281400dd7d00cb2dd11cab904df30e42b74b1baf1c22d1b5857c7b8d731a13ab0f15cfb6ab478831ee5e23a649fa6c196f95d8e6845ddf182cc27f70447c4c0179fe8ecd0affb4e5a533ad2ebe542aed9c7169ee90127dfbd0ef41e7e80a7a3a5284b8f8605b1c5159f8c1c51919ab9e8584e4ecb772e1f637182d042ff761b624b0adfb2cac087d7fdaa198637c5dc5837eef6592f0738286c0ce14f9be028db9477a559a68d8b091206188134180a867b46b58e6c11ad2e62b09a479d8dc284aa031155e2adf57b4efb9a4a77dd69c9ba6501309282b4f273e97a97edc01417ab85dad8ead7e21e062d28edea61f55ba29e845865f01048bf30a6fe8259b651b34fdce0cac7ed83a5ef1089e067dad778f80d32aea5e6c1670333009d5f5397ac5d8fb371c75528ab747b33fa00cb42854ae225b1e1eb76bea5a4ed80b4757ad77af1892848427abde8f724e50cc6ed59fb1c5d45d3ce1a24664acff126ecf8a229d5307c9e03aa1d68feb0d065ec6a91c7eba50570296a591a862d685f10a93ab87fd1c2bfed4482b34f765980ecc7e78043a0e95f738da41ce389f8252fa2cfbc193c39ba89dce81313be75bf54c419151955ee8b24bfca2a4e195a00d4c045ebcfccd56c3aabc1c6ce841640cc28f705c544d1161ec86562f9e232e998034baae16efe33656e1106ed0b06fb54cb42eb38adaf25bf95dc2ed711ef96d2325d6f49faa9091d0d04b7909fcf816e9220fb14cc1dc919330ef1a2ad7879b983528e1dd2c9146db70111ffc94c3f775df18c5d38760c321fc05587c8cc3ad8493e73f7d1baafb9de877f7c4fd8394a052fbb11470cc9e566c91cb15bf13402e04eeb3db817dc9712215cbb176fd827d3a1c95c03e069bce123bb6dd3afd4429da227c02211b8ecb6ec7a32e8e84dbeb21f4a4c539d0404508309da0c4bc2e81e954e22a0dcb843b864e9d155f8f02d4d8ebf6fa49faf4f64c2cb0d5ce250f5f0e7f56e32e86510dc80e16faad2246c16e59fd283f42555941fc2c9db8d30e47e28371e2dd323b2e1aa0c6032577ead3116be17586a55678259eeea138762c33fc7708fdbe6679d97f220666b868991e25a71211a7686ac562e9b4d00d9fa64bb50e3e7565782e7ec4015a5f59ca0692e81070079e600e0364328a06457f0420555558bc48499543b4b4fe80c04a9eec8e56c8443af36b70a8ad0467e43afdf456b414e012fb6c2792a7faf8beb6ad0aef2b3fef774aee9ebbac3fa478c1130c23f4d5c755cba3ffcfa1304195db2f86e30d673fbe1f9e683eb7af1e6e9f3909c6c8233f3e69f028055fd5120d2c1ed340ddcc8e7337f50307980cd3470d214949af5f8cf43d5e67b1825140a6d8e3811e37a097aa564871b68386a6dbbcd17e4a5f5f738b30a4e0d8350b57b0f1e395ba0c3366742093b54d23e09f116e274a3059945f3dc3149f6c43ad3fd82575046abe7ce150e78df64d34e060d4a990ba0d7758aa43ffa3cd7c28612dab8d1a4e999b6af8a18484d4268874f4dd06ba51cacdc729f560bbe420654aa7bf7a838c3075f92cea84717dd6255c458e201b2db769fe43d908057b418d2ae123273dac8f005db4a843ef0d25480af9ade8ade7e74f8b2afbe87b0af53523159003ffeddfa8ea731ffb3428f1287230f9cb2f76bae8cc9240c23edf4982031ded4e5637a6526287ca7f3cf03b103b40c6f8e9112077fd9871cfc051bc5810f305eeea3f7d03fbfdb5c01e101017e4dbfcca8a3ce36f372210cec45a7683baccd0f70b0efb81782aa4f5096b8504c9704a0d6ab5041d6c238a6c7ba489926d2f4f19ffb0f9aa19dceac3c4e5df05018652b3427a88dabff51b48050f71c8405e68a9760cdf7069ee993bf9bc13e27e12ca8ba3a06e3ad1e3a4add1263e2b1e2029cf08c1f6115dcdeb8c3cb98ec247d8f58aa61965c73eb94ea9abe017cdb2da756adcbf01d5b83f81bc33c3f13e80c111c55b7e61893241dc664b07912c717cb4c8071f202c3793826df13b2845b8e559aceb877656389780c761b3d967b68a8632915892892176c59c8090099acaddb4362fb01ee5c8a053189e0ffe97349b07e3b9d8e10eaeb26ea8c6f2eba4295c299410bb6bc131cb5d15a319839613846b8229db2c21f886252a590a2fc05587f0a51e36492b92c8978e0e5832f0fbb6cf28a6f0d96dc2eeafa9479302c17b159af3b68f4d56b4af7ce82c11229e9e96cbc0261834db7dd6a68a6f194478925b627f1d6a4b9b56da6200701143ceb0c4df098bde18fa4bb07929df488f356520747fc73531b371675336815b610fad869e6130af668199e6f2857586e5d10317c76356baaea8c305c1807a34db9e7203402a492270bfa27a8343ab65eabd90f1be5f3c963b0e08b74c0107f13e2787da80ef849a4b07a7c0c6bc905cdc4607c790771aec5b4455ffd1ab015b5d6d0d49cdb2e4f445db599d955970ec71b4c4416047fbfc6da43be2375f4d730dbc3ddef6192b45f2b1976b4d2ea003182ae4b96975007078824985182d23f7f4a95a5645ced6023fedacf04d7ebe49aff374a50fe95d3995fe84afe3f73530955fbddfbefdd4f14586e64ae9be83eb1b5f5b867f855538ef01fb130df295212fa9084bff3ec9a49fe34946ac04bb3c9c93bc9bb80faf481fbce188c527d37b346be2b029c28e0fc1d1d54509a4547673e34671a68450486e5e8925af2f59bd1d592027467263f10885294f560a5289bf1eb22f0c14ac2ae63feeea11ef15717ed5f19f6429a3bccb485c51333934b82ffaa91fbea228d86d74e839062f7e3b1f617d373dfc37e71fbb3f8970687ebf1f2685e48f20b42dfd83812036e4a0ce81691fd6525e34cbb7cea3bb3128346049441d052d7f76eab513008ed3f00ea574826d0d6b216543e9f7c6773949bcce1203286ecffdab4a1bd8f50140c32b6137f035486926ba8e357b406561812f1a1226f28e9711295c595a68d6bd90f684d84b5ab8681d064095db1a55e891deab3f0e9ec9cab5f171f0d77f39a7ba891e83cdca7cc6ab16e5e33b5ff9b54c13c10eaf51d43123921bd4575c021771e4436cbec20c80d8667af70b8f5e7b1e1a3ed90f763ac5df2994d2f0768e6e8c3c886a26f98bf6a1344c626814c4e3f0f0f3d44dadc6ff93cdcfc82f117581edc765e547cd307b7fa3486d788e0d413263f7ab9a5d6f3c3059541f52335d984b2852dc4cde31b2499914941d9130ccc6d85d8ed3b4369e0c335a213b82f8a4b0181c64db81da1d7dd0a0be6545e196d3801b0feb489486227e3895e2e37cfcc2e931fc833c8915eb12bd33c01639405f0e8a08bd6f3f4b5521a05f54cd55b331922349a5fd99adfbf29b939c990b436289c922081157f827db73f749157ac2c6c874478166425ad9be3b62e763af78d12b78f764c5e01b33586ae6e4e978d9c4c6dc643fd85a48ce74e3ad31dfe33fffff25045a77602529dc1085293494e90e05d63186faba0c2576db9e13bdf3feda850b211db6dc7ca0f10830c074f0d2c1a8a177f7bcaacd395950ef144fe034744125fbf682d0a6d970e2db3f7835a0df79e99f9f09ea2c6fe38b12fc8c66c6115729549f7cea18d8c4bf0e34e81c5abc8a4da3c8a4a8e1c6d1a89e1972d9ce0b190a88575cbb1231cf4a1a4122d7a79c961d4e0a79f4150611281c6131aa7047ce9f662d1f78b4a25f3b5399fde684655a6e7359d0c7a276ccca163d9612387651f30771fb442eca44c35c0a6ded1101a359e297396c23d300050eaa93e7c0bf584d6d88656b426f56700b3f7a692547288bab2b4148d56481fce6594e3856a82eab71befa1f1085f3f1463ec2e8e15957d8e409915aac56eb779aecebd9a65d5f9e13429ff26f4941caff42f25e3182bbb9a026a65d420c69b68c18b2a1b600dbacff1d909835f7873a54eb4b150dd7b2451eac07cac6fa7a77a63ead998840413dc7273f3e2025ae98634f4ed6891789ad354e238f37fbfdd07ca4e2a19d3da475cec1a62c718f6848d5adc6b8dc5a819cc8addb24234092f7555e8dc925a01ab794cb15b6d2a7b1fb56e8b3c75d2eea92d779c71bf9c1d15fa489c7d76c1367f4e8ee5fb8cd43d1f49e660e70ce29122ad3c373dc905fbb46267055f0fbfd916736f8f7f68033838e1aa4c0d153f1c1a3027f8d03c2461b6a6a583e0877fc5303c3cd8ce7b5f698701bd5d0b4475623d2c1023aaa8ad4c8574873ca9f11e7f1639bcb56b7e1822e467fa1c23f3aa231edba4371fa77e64143c1ad7e62c78a464b60fb6d830b34fafc895a4f4abdbf5488dea7d91cd9c9fde3afc21ebdd4fe7111f3beebdfcbdfff4ee4293b99a836dae497cdb4926383ae75707ab8746fe25891e5d904589ca0fcae99b903d8e59a0ede98aa114fe8b18b7b374640aeaba7ae640587cfa34f01d6777c7a9739a887f5dd95cacd792994e4af893a1c88b1e4fa1f7ce760ba098dc363e8e468a3a3cf48fe12fd5a3b4503b8990de5a4e6211582f8bd9289e18d32bda32d8b9465b93d13f4d37ec1fcf750b7807caa41f6960ab6c0ed63aefddbe6de83917e90daf749b52aef90b13f75f6b221b08cf91a6c65a955d77e8e18e20396cf3712e6cca3fb8918c6b7897d5a2d9c3403fdc460fb2b194821a5b4dc659e3c4b7eac8f74dd9345c6ef7a911e1a7cdd1ad16b6b2c5bf8526dadb07d9d1801a7f5b398740128cc3c556de8c7d2a257cc2211a0eb52f32e97321c24ead6ba9637289cd9a1244fb03e554b4505ceee9795dba97b7d3a46cf9df784a5a716fdfbc0d51432148bbdbc52d0ba0699ec8a1a42552c726f9b7ffbcb55b05f130cf4ab9b6904b184787398be424058708c61cc6cda8fbcb1f78596c5b169719a3c3606844150c529a11bab0d859783f85b57459058d507bb1b4cf65fc36b2788d001eccaf6390e85a624d83350b65183c449074399d9fd6e892218e05c321aacd352f166a8bbc4f407803a98251dfc209ec6d58dd65b4bd94f3336652f557ab666444435db9a38303b6026ac039e59433d25dd4412cd354390a42d600fb392ca344b63a59e9776ea076626b7e7150f3860e5e72ca40028d17c6b583552bffdad458fba3093833b64b0026318714a98df732688bd1b88ff89b88041f6d72054d1a772170de24959c1f662ce68145cfcdd5f67aa05a74817c3b99822d34a4bfa3d5894d3acbb2d4b851dbf6bb62c279dbfa502c5bc107d4fcb99df4e92a5c5f227472d83663999fab41e0b2fb4761d21ec1a93790b58416bcdc23f00d6bc34a2a59525101048ce662a95249de795b2afd06b435ff0edadc6717b762de98214a9414151adfb743cfb6f188970e0632c521e05c5eadad8e924f09ac21e077872fb21a010d66dcd897076fb8680227f4c5f57490a872bcba7ebb0dd6c3ce540bc274541668a242957587a2326d6ebd74737ff1a548c543b0980c492c55a84ff6357d472660b5b0e03369adf7ef40f554330d3210f4782d3b5e5935962e340bb1474a3cda1ffa69c30c14d09daf5f7305d08859b55d3e5f6f17bbfec9dd80f9117b86001b17c4ae1d8061a5b95e64cb33a91753a5dc8e8c87f125447675fecbea3b7a1e1bccb81d7f4b1b8fa9eacbf4c10072c92b52342f7cd3b8e3ca65eae7b550d12eb8fc4523ceb41d3a4737aad63bf4dab7baac77bd6fa5141ac49e6aff0ad524680e9971351a0c9c88734e991e1e30ce2f46fc7071301803dc57a03d28c8319eddbda9ef19d8d28d244c5b755cf93b9b9d74cd2dee74f8bf42c46951b1469be5a183ee8112776f5a561c64180602f3cab6857f0a7d0fe095e60289f5f506d2619cf476461bc7eeda504e332d34c8609c483b9a60a6844721158a0b9097236dc9f852a65a92c87805825616a785e5f21380c31bab5d43cce96db8265041d855bdfa9c468578041a88f5fc41f895005dd31c00eeedb79bbf437c99303a32dc00a319cd1cdd5efb42666324bb9beea802ee47d478da282e19db20b0567faca25bee13dbca98cdf1051b05bdf2ae45d82f9e8d868c707ff5b123001a37e71040846aa8f3fddcbd0c52405fa4e8e4d96ee3940befde69919c532f93a615b0a86d3fe42a7b6caaa8641a90909f9043ef15947cc43bb3330898ace5317b9c13d83df1ab467683c063baba28bfc8ae56dc7fd4e07f1da3a13673d7319649481c2f7ff10f2919c30b67c3301d135c7f4a4ec704c5233a84c7c521b5c54697434401c987b8143798d98379bbbdf708469cb97ac5314d7d347725a3f37e9e0313dd22e2dfd438f84ad97988e47bd8f3119f214b49a3cf72a4ed2a103b65aa8ceab47cbb9f5f3dea7a94206f52b1b118b156f3490e6f31fa844fb0f334448e272fe157f33f5070af1f38933c3544498c89e56432a9b55070f8f60b1afcf57c7c26cad1fcece21b9ca5e42b3e19bfdfe5d0facce7ca3fb519750e162119fe59b48b31c464faa42c618cf3382349fd7425dc6f00aa0e7b64aa8832f832239a8c6e35fe287e490d1c61a18bb8a54e0131094d72be2d9e9a6a75885489b4299eda8150b36d18189a269097f1d242f73ef9a2297ef715205b2687161fe8ee1265074dda49db817269d8e56b0fe18116f0dd7f492582143cd417d80073f6359b2ba5dae22a943576d8eff8abbb595bf597112bba19819e26eb4409488924bd1523abb16ba617f1bed54769ef338af8c3a28107858d1f7a98724615d190b5750aeb29c2c1f42429f4a591b1eaf8466220983bd18432c00d382ec9914addddf1f6c48e25e36f614e6b651ae2aa509982d667236ef4ca58d6e42004c506dd6430959eddf6c88ac82e8c6a047ccca85503e73d236fa5ee81703d60eaf965a61167936ca0eec05bc9b2fb614537798fac1b5d945c9824503008968c310fea45cbdcdb48c6398dd6fd3b5f3a258d7dc329494358159170190c6978e7a3a90fa3f51ae3fff8b2b59e85713bbcc705b7cb2036c84fe324f671c0193d03b808fe54c0ec4332b2b0eb139e0d41e1e3ffb0ea4b06b581649a7281e9e0fcacabef6de920ca288abbebc990862cc74d58faa77ddb48c0e57375c3138dae3cfabd2d04375e0e1070f4c11886dfec88f65202522f865747bbbde1fb119ed4733741ccb1b06bf61e89e9d989bdab6e0b29a86044463f2e2f7ba799f71ce5a16b9782a19a59184a48c6da7b4915cec529184fdcfe3295bc93d085e52722d4c88e3d1b683a57dbaa3884a3867a1b2c2d641b68b4c6698ca5f15b3ea292c5f0729988c9b31aba902714c5311070dd49a07ecc888f5ef9146af45e077971eb0b2ffa70f0eec80fb8c98f39f51fd8bfc73c2c87d1c7b948581a719f9b74151fff512d3b8a843b1165e29e7d3132d8d766461fa7a952a84962475b2ad6f68140a54c3956ec304e16e2afd7df3ffd3fbb7ffdac7eef728f85f066d483793eeeef49669c4a22ca0cef0459061cd17a13c7d18e84e59d9b22101156536a5ab93ee4bec9f676e546dda50098ae89d5d2aef54a8c0973880e276f3dca6158a15614ed15cb735fd4823a6de5e8be396643b0c6c956806a8d19bd1312efb5a00d67b7f02e9c48e6cac4abb312fe35a4829134e0d0d100552e664344940b28f07c013e772fe8e32e01304300b2132ec063e52e1af94f3dc7b37d2e7e84d6534e9add3550dd3978bd0553bb1c2adfba3e0b9bbf1b8344eb199182a165a82d5f7825667e3944117ba1eef434c4df7123829e708c1985d9e93849e111ebfb38c4f33432e25044198ac75ef93d98239dfcd37232a7865394cab05116bd6e643af407f8e9a7c39a9b0937acfa5c78d5fab8a1da3bac0e2c99047362bbebd8703a060f5d54a2ad2c4fe967b1e1b7ac9019151cc12979847543264879416e48b90a6feea85b47938575d037e5e1919749ad4791c56a2a6469a71f09bdf700c5581c620660997e12bef0a00275ba580cb3629f1e28425106f79befab689372fa288edc60d220e38d4308660134243aae9c67a8ac155dce3477f32be97be5f3999d624e6adad43a3f2d86dd5a44e4d1b2df3eaabf3d396decb3d5fad06bcea053c17f8c6288fef3ae975b726be1e11ee2eb1c2121d8aa38ce74c885ad5dd575624dce603b3809b5e60d3abdccf2a48f50d3f1573426ee10e29526ea41b0bf50c7e0af92f9504e5192cec432136197997f8d28a4a7def6ed086c17b908ae8fd845c43bd7e365a9ff44d41f6d435ca4bb12b9d4a9ad42c3f9ef9e498a56b1a60920ac721f04fc74fcd30037e2d6a63c6411441d92fb37d497b5aa081bd2b6ed794cdbe9ed74ed6128c6cba71e71a116ceacad73686fdddd03531d4bddee5da25c86093cccd84d6679f96a9693459295c985c4a9a5c2beb79e19d8d6debe90c8d046b933a5ae93c1effcc5d036d18ba9c6b3272b88dc8b25f32079cd36e2fc411a9a9c848dbaf99ef78b559bdd43f82bd662a2421379f3be1f7919594e927eabb8dc0b40ee99fa138d121c5021daf85e9cfe6eaac9b3cbb2bb92ad4affd39acaeb3cdc5681af7100958e19e67efd1160b0f64601dd3bbb136f9b6f4175c235765888f06761de1c0e0cb261670c39b07d0aa243096df016128029e03edad113c82d8bfdcd6cc96a9c19be7d5015f13ef05f0d5a3b54808a104fadac4e0b1cf676b5830ece2016e84f56ff39576acbb8db6f7d0f4624e7ffd1257a314d684e72cd9d7475bb6665ca179668418bf928d7301c9caca55b7b90e83401f2489fa618a2ebafbf97fed6efca83cee810915d6199e82df6e4ed8247393702cb5d9cbde65b93c6b878476be9b3d3e5cb772c03c0ca31937aa1bba00d0fd15feb24c0984e095d820a8e9895d447f76ec33745cca6bdcbf24492886a8a45e6e36442e2e8efcf0417231c8eafeeae6e123b4847873d110159ece47bea3dc367ff3234a97c6b19e6b6a5a496e9cd2cadc6ee2bd638555a429670995c33838c3229f58cbf1e11b3835d7d518a9a361ffe294a356d9032abf0ca2c25574f3eb8f659469a244ec1e7780e20e717aad2c222178a0798ec5f0278f47d364ce13aef54659a3ad1f409ae4e3a24f7679a28734bebb683a69120ac0a53c02487f9c639224e656f1860f91c889f69348b7eaadb67cba2f69048a0b3b12d38c925518f34978d81d30ab0fbe0fc2f1bf97afaa8fb362a9bc55c9f8fb1fd50144866f85ad1a1d973c7a66edfd6ced9e2ddc27dffdf21d4fe74376d37f20a17f12778e24ef27d9cc312cd975e40bdceb1fc18601af71f69e495db95c41476f049b8b5009a25c9d4779db1852f76719b21b629e4c30c9afea675277e9f89048e30278ca25dc2b5e5a76713edce92b46eb972a65375a92ce5f3192b58599136559e92ec8742711d0ffc3740a5718129d0839bc200cb656dc6021c17eb21ecbb20ccb4e16fdc5968776d08cdf5a61d7e5ba9b603dfea74460218299682f2b8184ce39b5397bfabad40edc6b15601b1b35bfb97f7a080d99355285fd817919a6fef5dacf456d92274ba3d5b0a96a8a087e0989de1c0a32c5508c6495ef9552bc2f0a44722bb6aca74684604b47888961a184700d4e2c4354ffb5741b4b8ab918be705895f4a0ab100f5cbff7e17fb389be0327997281c8aa7a06fce6982abb8719bee5319d151e78c476c989879db03157de7948a412a75c2548afa33a108669358e46746e0b0766fe11a880e98ee2c98685ea4e08f4f2d70d23557e1b6e43caef0c19fb391aace2e29081767d8d1a5367f26d494e7dec7040bf9254706f149633c0fbdfea34a1c01f03172351519fe374e1fbad9c25985318b146cf8d766862cae55dd3eca319d3930906c060058585ebc3843b8a2b3c5cff0618a4908b7f3ac743354200efb14eef30af9b8219b4648cd01b2021843dd03031a91bd1179527a805a059d4d806e56fa9baa80d97e4c467496390c84dca6a6e917ec40d878462d9c7ba2ba68f943b6d4efa5ba57942d8627e8925782116bd4366628f18d8f6e1aee23b2bba290e6138724962e3cf11d57936bd61bcd26752647adbbc5110d2f3c71ce55228b4f5dc813ee29d617d1bd853e6e00eea43775633519d7b757bb338dfa3f6b17efe78e9dd27a85378f752fd534dcf784469a1502151a81df99fd4da39ab3b43354e2071156fe28f25efba9e82f88961d6e3e07079c7d2588c30b145f9bbe939906c3ea2778c4aab8f6b298c2d93b57e5f7bff10ae2d5166c26f5c827145d4e381e1186e3c67b318e5effe758b499c7d5145cb147909b53f4ad330886601303b702d9a5aa5980191dd9ba2c2b4b7ddf6906ab5581506a8c56d0fbe50209fa55eefffe99beb89e97c8b8e740733a1c0621803c5f95dba0ee2365f18f9b36aacd160677fa3b78ffec05a34d2fac383f2fc35ee62605724d133971d1ae17a537d3cbe3e2f1c536a7edb2ed798ee3a05b8b65ece13f32ae33bd2dd7d9a84ee24b9d1c9dd2c841673a5673330a8e7a6d1a123bff45fca82030cab998b26d4e04e1f024fc292c59d97d3f85eabb90d6d920babc1ee2dd2d1c3ce4569f721e0b14250e415a1d82ee0bdc183c6b8d3719e2758696f47bc3f32c6fdea9399149f3564de5768fb5de71e5d8356751331beffce139a80ad41cabd7929ecaf9dcc6d9e55ebc4b9318522a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
