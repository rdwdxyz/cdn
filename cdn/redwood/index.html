<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ab15da8d71939d012d5aca1a4c6f8eff45efdeca364b2d3f9fbbd41cb150081cae37ab24ea80f94c24fff33c2f9d75ddfd72829bed46ec6086102b5e91baf136d843ed768bfce4d0199e4510d83a9f969b863e026f8f5d95151544e979a8e32d9fab21110b25bfd0fcefd838042bc6b9b8b6ed9d52169033b26128161a48ffcda29c569fbb45e2d255999bfaa2787014060576ac0cfb177acca6123ec1dc4afa5e43a55008971c2bd5babd42afe76702d2e403546f5b2b73058de0a23af3fb1d80fc40de4b68fbb97ec5a45738a5bb8fb2117a1421ef8fbb501bab741bb6d4c13fa87803358396b183bc3dc0ba1c91e204ad69f7baac0378882d54cdaef5fe8bd61d27e637711c9c10bffb239b120e4fa8b9372468da09e4e8587f8c992ea6f682703aa63d15fb905528e377af89c6a118c2adb1c3afd6ff33682f95d4295b17425f5705bab3816264414f21148e6075f881e69883fe6af16a693c84d56fc84c3f2daf02fbf50d66c8e58786dca2d9a96632eb75fff28ed01d634a1d168d0650fd5196ba7c4e2e341d90d4bfa9b6a61e4a34a43b8c6144271f8aca228b892d6b989d3368e9e7d04e95e85771840c1bce44dc096afa922ad3353eccc54058e1447019c58207387a2a4fc533d1d89070f21412aea70093404224003f3bd995a0fdea9b80a0b36cfe5688bf2770b4ad9c7718e43ec41628238aa074e7e216fda2327c4daa79d682cf08ff6c5111b90ae38f49387f262610e711c82ba5c7169ee17fdeb7f5ea27b7a475535683918b4777a5dcff3a53d34c7b90315d4e0ab8a202ffbf821b23c69aa447bcfab272c473c17f6362fed373162c5bf53abd4f1d2217c1781964f199bef5f1333bf91781d56c0bc6d9ba94254f69705a7d4d941e3b9370dd7229720f229b5df7dcaf8fa2c707e682fb1a639e00842119fb6e7b1749a79083b79e0273b9119d6610e89c26b49513ca1c317afe960929be91782c7d3798696661304a5701ae5f95d719e415a13f54c9b1b367fc4a8fff0f3a923ae5449b2ccf668d6dafde76b7fdd3890b874689180ebfc3c6a6e1463510918604f5e0c1bfded7653384f39f35e88a2ac9134c58f0454bf17a4f351c11597d5f51096146eb51eb78d325fcb09f808b36843c5da106adb4f924a11c40b7553b325778ac9e5690fd41fb3b5ffc340c7e0c1f27da0c4157738f992be4248fdd7c0065ef23722f5e712d53b2843d9b66fc23f85ec93bdc4a977f614bf7a05bd9cd46d9813eabfec6707ce2dc44d5460b68075a2d6700d8d0467c647012453858508cfc02a9906492171848f94d5f5499306d74eac3f817e673750c54f0e09183f4db2c20ba4f6d1d669cd1ac76a41b8b4c5a9d119a8348378dccc425b4096f18544328f8b11bb8da6c4c39c12ec8e0cfa85111556f598efabfc3749c99f1513c31824e3bef888b2fbb72f5e4eeb187df1f11269312d2d9fe10e3708e850ed07f2473f089a6e55fc908f9e68dffcbac7851b700c823d1977219dd578dbc47ba92d900cb7197438f98c23c71d0db5597c56d83de19366e495846040208c0e88e5968b124ed4e42b18e39e69adc553afbeda778ce3d06786e3d4685a3fbe396a3340e12cfe99b910c02beaf2d6191e09337e5d7160cfef44a763784c44fb82a758a1f03413088aeb8c9cc44dfa3f5ee53cf19ee6bded4414c183dd321de5b112464dc679633cc53620a1f960eed999d2f899b4125d0b815ef3f4517818a66acbd11dcbba0e0e00af7efcba3a592dd554aebf6baf5804932764c9b59ba78bb622f5172f2d61fbea993a97b0c3ec8c19494cba7d78e54d3446f0f2867dcec6a6a94c7e039bb5212d483e07c5be0d371c2cd6a8506be05d7fbc6da6c5fc4d206bf24fb6403501e2293ea0c659f928e222ed3212fe875b12c0caeb6771bbb6832186590b6d44f18b96072d488302993c5655bc725da0e63126a066f377c5fe965a949bca6fb8f61845bc0334adf1b41a79331685ba45714bd69cb69306e1c3480e11b6d750c1edbeff67a7e00fdf1e23fcad00bf4b3ea00837f94870d3f61da8d154f02b0109f3a1ec83e5481e9aa3cd889011ffd39437723a6f52df71ca8aee03b1e806af569e7cddf9be2cb4bae27de9b77c568fc4878c9f0400912e40178c3c9386c292b40f191e625e0f9ea58b3a9f092e1ab06e9181e7b3f8dfeac21f264e8725192e79543ffd4f71e540278a8118328c1e46e1e61b061234ccfbfb588cfd5135a08cb1220af958c3ec037feb8fca2be7d6267507841e5259961e95dae23eabc152d17daa56efe174a618dbb432107d8ff3680759d0c187052c2030f451d7cdbb9f973f410304fed3eaa2039aca702fafe39f74bd7d659321801c6e5a68177eafe29056a43b0ee555c7db78087c378570fc613dcdd475f8324a3847eceda8f5b7509dafa122a7fb13ddc6774c9e2a0cdadc4cd1720e9de41cb4bd03fd63cdc48c69400b0ae4dd18891013db6ad72be2559e09da05ebf5094c765a7b8a710f2ed55f6c8f5463f51cc43b7cafa34d67f3033d00df0e6748a02c408201c4cb6c74fc7f81ca3a89e5610fe8c38efd801c241b1fede02938895cd0ca966cf4bf493c12131e34e7caa88c685c04445342ab2b3fe0b2216c60300d1b6ce3468a6867e703d8319d52ae3960fec3e2a30f0f791dcaeced86279dc4e573610531ee1d6ef94a80cd74e255fdf43fb305c7b97953bc7e7e0f8916928006e8c3c999037629c0a16e4daee3e3b5779b917e95bd84ce0eb8622ccb45773f8b8a9d21f81da10ea6a453498943ade46d6e0c9f4eb5e6474d5a6f2af073e235ce50c70d48f7115287fcf647b50d6013fb15cac9df87e447158cef3489f2d9d45a45c34200f69ca99c9c108ccb5ad28cddc9a40f8c79f3ecc5207892b083a2942ffded896e18d8fcf7270b24947c94b4aff4c4fff0122adc9b3794812313956a527ed96e2bf0eb43c1368da56faaac275012daf7b13823d29d8562fd8d1870328887077ed6b83a6092150598d682cfc0be9b0e4a878e7ac4fc24048230274ca502ecd71413bded5dc4448cd5840c17527691b5c916ff53c4f280827c5ecfa04d8a40e262d8aec2be7b8454bec87df736cada35446b112b6d5886aeb6059bd583c77513b411a1427ca9a534473f08de18cd80c7020aaf3a99358521e632cdec5d491c0dbe66674243e7332a9865b20698b0042b5453b6e670f26d934366b2b769a49c6d7ef6a88dfdb81acce8367a653d466f0535c3880b11a555f6a3165d7f2713726d66584954cb6bb05d73fa7f859f93f8738fd002e34b5c9552c23cd1a08a93259b1438b0ad49db03c42e1658f227f6c912c824a084e5944543a2826d312b24d21a93852cf79ebcfc39f9e8b4157a4727503f4999913b696bf1a3aabaeec1334fd5e6053cd23631d4ea151e670d70c807c132e82688b19b2030479d8d0c9f7be5934f0e3852433a58e7895ca354ab21ff8f842f220f21427727116d4742c81464496bca7e4ef67f947a56d4f4d67231f76a762240c299b7106f1b5f6acbe2e24a85121eb538cbaa58813070b9876042c7f27217055817c6f352449ba01e64dfb742333e669a29c48da4429f1572d6dad1e003d07aef8a95317892bb396271be433b134e2b2c6823be92a8ad75822cd3667d7b2630b1329b47e8dc52f3cec13365d016708bc1b24d96b29f2186e6f738fd4b3f6a48ee605a051609bc54db57f3e6ef400d3700e4d0cfea45a010a870d10edbca369c675b40d8917cc8cb0cb77f59e5ba4bcff71bebfc558390318e27f8c6e0140d1a1c4c401e2f6821be1f927e9a1760ae298e8d22538431867b5d33f95b2a6f09cb6ac8d2f94b7a545a8dfa68ba1833380b343747507d1c2b4003854a846b83455c9dc1236902186cd90d935ed7ef47f5eb3f1f8906a6d70ee642b58d79f721f9d494beef8688d1cc9adb62693d74870d8b1a4baf8fed8662f8a1d60cc650895b465e6cc0bff8b3a835ad26395ce91e7eab3a8af4c89024f2238ed6b0f762ccbb84fc5784f0b0e32a01d8550ac2765c99afc65fc68dc2891b06805c13856ee251ae669b84e0e7eaee248b8062fc4712da31e490aa20a8135589611f9e7219e9f69958a3da9249a2f928f3a189bacb9c32cb9501aa9dd0af1d6f3a601767eb2fda7802a72e4149f0a9f2a8e8b1dce0032187ac098f60674b50812777f2d6a3287799ede36965c9db3851c2a34b28f47af9b97d5e607aeb18329ef74abcdb6e5fafab5ee5f5c252070d5d5e3ad346c94027accc1351ccc5be5c2f16faaba6af9905c63549193ea5e44c60227420695d5315f89c076481c371ab3a250e235d491f259b9eca7892365b80418a6153d4a326f2e38a49293b76eb1028589ab89b09e01db35c1097dca7517b7997002894a2bb21f74416d5386230522f466751de2ae1cfdda0edff0e6b6ee4c72af6be6c680986c3c92d7835a21ad4d5e1dd22124070cf35a876cde33abdae9ce2f1f8bb42fab9a0e552794b1e22d8daba47a1795967e1728e009e08c56a71fb34dfc1c69b13029b8e11b5019252da10d26f409bd9735d44cc178d527731708a10465f571a4ea24a013c0b3665108d9a45e5982721938a3b8b90445cf2f78899d97e9718e48d16c191fae7be9bc07ec3000e7b2bb840d1f2b35e98ae5617d1e414f5f5db0f8ff8b64849b4515e05d34dd928476b66cd4cc7123e0640c2cae5b4dfc50aa9d9a7f4f1ff6353a8000b29a65e82b2f9e05f66e65a1c46cfa16403d1911faed0efd25283bd2eb90ac3205dee30d0b2380e0bf63d201510debbcced1639e91bf3b5c8f2d516fd21305efbb4ff00ce45ae332537f77b4da68b9a7d8ca0a6c505cb4820fcd535641824ba828e7d6cd065b5def29f47100f021a55d198926781921d775c6f2f210e5fd11e79de2e03fb43f6fada7bfdde3a72637272ad353b5d85afedda09ebe7d7b3f9e16b9a60aa59f326c374c881eb54f74e98c0ddb1ed6345e8e37cdabca04d16569b14edad53e3d06031e5dad4b627de033a7e29f8cd4267d9d4afa8d3a02b2e40787585ee8c8a689eb0423d0bcfbbc640c682da8ae34d23134868e540a5f94cc42b85a44a40df9a622271d55bc09662da72b4695ed0e1077f9d711867cd39cff1315e1ad3e76eedc0d6dae3ea982063095d058167a7eead451c6706e8680354fe6bdc49b66248f0f4d5bdb9a35d78a23de438558f429efc064260712d4a07de6db8b356caf4ef41a1b2961c8e4f8036df96703e9c15aaad561d029af4a54749d3b54f20202cb4f871f946728e24084b3fb5dbb12e05b405dd1462f8ee8d755a9af77de50ed611fad5f94aa48df12b39c2327349e08016d9ec6a78bfbd3217d2345b2f3d141accc165301f686291b1bf430ccf3b3af00d098074d4e0f8ec55f868fec0ae6f2499ec57d2eb92760dbcc9f71aed2dcebf089f1de058dcbd168ef283c7849c7af5a4b47c0f4109216e6a9b3c1b4813c430423d2ad7e3ce35c2ff937ec49cbe7eb544eeb3d9815f4368bddbc7db50f12a9c3695b789af0c6d66c51059cf702db63be5f00611e74e96030ea46499c4928ecbfbc3f3e014543236248000ddc909717cbbe1af9dc01b30f50c9cac08ce4295f0a5f547c1dad8a34a7a1d477a5aedc11ceaec3a334aa4efe22fcb99de87dc377e7e0c1f6851327c3a973b4b9f877bfc29870e7f38708af5c50a73df83fe29e7abdbd746b5007d2e36cda20e66d329e75c8d115812754c2650d9ead71b4f9638fd59c8ec589b42c7227545bf5e1b140f0df3455180f6b12e6124083f7958b88db845b5335f5395a534bc2861fb96d18872c9759ea21beb8e4261e862172f9d226baf4ce7e350d6d35ad11f47037892f76c066e723cedf9f873ada3654a1817d9ddfe4adf26c019f18605b2e4c7ddc6c6fd28ebbcf2c5e0ef3d3048f29409a059b93aef6d0e4670e0a56b9ce37214371e86b32a5075b834cb64ff86d94b4ac67aa3b04e37e21129d55e21adc7c0796f495727b4b70eeb18b525cfe6c3688ef6aa96d692654131b25cf1b5bc7baee6344906019e17ce7a6e1b46ca4614669abe1d8f2a6b85bb7955fc652d91d0c257b4de238d32cc09539c4b945ab969eba4d4e2e76528d7716a3cf795fea43583832481aafa4d08fa3b72f09ffb63cf5087c5b71f0839f954caabe77965cedaa67b0a7135c01d174d8a0abd411596eab1e76ea84b6bc30c83f42bdea1d7884def593895229112536dc0bee335f2393ceca2daba85bd56e72061e1d1f6d8b6709efc344c00fbe91514600c29878a2f30205db169125f354768c7b248597913589cffee4fe84355f1959f581c018ca72a5e296eb5e6ddb29bd0e55ad3c8a926969ba0cb60fc287ab83e13d12d41b9c6934f8ddda6a05cab3bbbdee7d8d5f461b91849a0a4813519c420a15eb5cfc9e41d970ff7ba7ae47ab3d4eba62e5518700cdce5c0957c27c8d9b41255581719aa5321994c8550bcc7971199509ab21ac4f673744d279b92511d2da2c02477f84a4c1b7d68ea23d156e8f90df630f04a99f3b6643301edcee664e2d4bcda6d88f1010686fb9dc94ebb4c7528a06a58c3108648da069235de90ea94ea787fd22690649c9e995762c68e8d11600a50d8bc2c39a6dd29a46ff42e38a7f2318080ee8f54314dae159ccca8a06a068d3153a93082c239c5af2fac1f0945d2a595c8ecedc5dbd9257cb59cb76eae647b9b070cf60a2fb831bad1bf5aeef0f188c0eb6a0b57f31e1e5ce648054ecb3c1421a2bafb12d01082fc34d78aac38789f989d03ab9a5faba1ffa88b8f7cc3e2b01be263436869192642df7d089f311fad2083810c430f3e98f7e713bf80dc01947638d57541c7bd0e363fac771de8cbaae725aa045819bcce9fdde016c306ed11c38bfc3931268668b49fa64fd46fec463804585dae291b53095b6029e31005208a1aebaeaab98c231db634e5a06595ab42962f9d9da840b8cb2d9ed2cd8d11c3e17002810b6605ec001e57f65b2e984a7d37e2bd90d2102b281f9d54ad5c931439ff7cc6ef4c7c7dba15e1568b8351c2d8486a885a2bb4ec8acd32bbf38334021a47af952fefe2c6729d15fa2fbbe8bb074979b171b334a2153bf25efeeb392ce8e861306317f550a86e665d781915059211469303094879becb0f2161e3fffebcdbd9decf18f3772d926d77457313798ec0b3fddb61932b5dbfecd544fb37daca9fa61a851fb636d7a1bae1444db99ba57cb8a565dea9609fee1f0e9cad1ffbe78cebaaade1b6a64c15bee78f48ec5976b9786d006c7913596e856f75ebfe781595c595b5e45d886bf5f60f9092a1968dd0ed6eb1813f965f312bbe57b8139ee7557211a55089366fa092e09343936b8afbe6cc43624fb72cf32473b3ae2512a296bf4854aef7cc4669dcb06016466ad8d600f5cb87a7941feea5588a612b81b2d7af8fefd72259cc995b685d4a9b376119dd5c7daa67ba318e1b6318024e1379bfadf9482970377436830eed09c4f7e48dba542493316c3da71a3cd84eba78f3a7d6c6ca3b81d72e008963b61b6912bf263045066d44eebadbf1a4b1a891a0c0003f91caa2f57f2587d783868425dd8806fcce5db0f73d0197e2cb9f6caf7bb683f9d65196dd3b3f39331e450bf0e4e27e6b2c954b7becbccd34d54e6ed0ded49e0cd130b55ea0f8a1c94ce59c7f117b21e62ecb6eaebb7b56ab238c5645463b83a1c32bdaba4bed676d18f8bc04d5f912e328fcdad69257cb77fdc882614acd3c7610012b95516ba5b7445278b76b0a49ad158231997db04c121baa1016942ac6f06ca1584b0c95b0037d6357720fdfc0fe347d92ffc563a3831d11e22cdd73f5782132a825be92cc6dbdeb5f5a3a00e4e40b86f66fbb676dec44bb7ea6298099d9855f7b74ee3e81e5847bea7548ec62ee0ec75cc17f04c9b5ac1879e74d434d4853eb0e5540ac9064b6fcac06d1ba8ad4f4598697625a18f2a7871a4463c6fca2054f475896dcff36930290ddea8d7c1a760ef67fb999a5a793a03424155197cba8fae051c45483f04de17cec40686218a07be14b34eb09b93dc2f033db9a420b6ad1e7dadd9bfc5491702e763e1618dd81e0612a4e0e5c54db4d545c99123f2bb51e21c5fff6f092e161a181a66a2d8647fbb1d7191fd0ec6686c884ecf1a3cd3ffc88fdc92b2f44c2f22a89f0a158e2351840f11873589b5e8cdb34d3761d50e0dc1098728f03d7078fcf7ad16f2a241acae65e7113d7da8a698c9d79c98edfc2f0b88b74b0558d888b859cda3027b105da919f5170522c86d1472a78006738575c63cab59748a89c7dd132e7622a794d413e064a32b4dbbf8199291930865aca2129bb72689f74f948847c0941d5b812d7a4a1ada2a19b84fe45f32c0841d2af741990e3da24e8339734bacabcb4b7084729c753348e72ce8a9feabcf3434ff2df2e3e1b971edcdfa7153539993e331ee7ced7e3631c663ae8673d7eb2aada8e9a1fcc904bbff52868e770b12bda1cd99aefc43e552ff4484f599cd8e231ec09733b0ba2c628db9637c95044f0801ca377980f262d35e586b75eb54c3ce81ae377a0a540691a19dcdf2956f3d0fde6b25ed559b384f86afac9cb80d3c3c33f013c73296653355e746aa983f18d649c8d82f04e81c52ee72d88b25cf7042fc57383f8b33ad97984102de96240fd24c5eddf35b7cd4150c9dfde654db6f8522529ed6f76c411ec33c070d4706a9b7d5170b44d2754faa54024b307535da0857bc6431c6347b22cc52d1e8797dccc90cb40568bf175dfded1c43f439564395bcae624f8e614acd7278c2e4b00a071016cedc34c8647b75ce35a8113f9c5f2e6f3df65f5dc1de54661794336734280474d4853b21c6363d4ae7e94f64c1e248bcadf2ca057234c1a0faa68e3a3e69f4473059ff525ff256cfb95cf097f1496b87db3c1004579e30b64abed24f46ab4c68613ea5830ade0ed20168171640c8ad11d856c15e2663e84d77da7f9393619d54eb69859a748618777b06a3838f0e1c9201742cf9c35097f8a3c28cc007d1c081baa28eda618028eb4399aa9b20e8f5d3ee07662f78441910c198158d37ab3353b8eb5a25d7dedeca46ea202ba748f8ca6ba0fec91dec0b4eb2bd2a775cde93298527ee72659c7893732eb520a47541d27b1c2ea6a1415f1828c2ad69317548cea8a2bde82ac70a119ca217e9f59dc73d72d6201c7eec003215c2dca1be1af0bf7c78286f54efbd4b707d9d5007e6773847219a0969c4a4172179c630bf90a8700ba09a5022f847cc9830c27c3c1822d66bb35d70bda91d69bbf29ec4e01f0e4a992e2031b6015f9b0d31df7f3f6f4f23d3fd487223d08f33e0f1c0747108dcd733f72a38c5ba53496387908716086f58a531a2b2d5927904ca1af77124b99d026255d0f7fe190ab741029c5546304c45ead5fe798b2f74d60da49115726d3a31093be03546e319dca58092191d6a3e1b2781a5d572ecccc0274659cd464cbb1e175f8376a72b1f2f58c80ec32e3714355dc8cc95a56664af83f58e249ce2f818d4fdc1e59c22b25c8bfc1b34e95f0989e2464d14d9a9576bbd95e0b6b1c3b08bc4f67b142100387bbd8712c3bccdb0df2eb50a2fd967e55dfb5a9c242bf256c7dc885fd2eaea6a8ac0fb36672c27a0bea74699f1ab9b8228d073f40030f33461ecf4832f3c8c7df41372a1144fabbafa7c2a837d39992441f02e85af2c0ff2ee360813d50bd7e1b82b05d77cf9e4b1a0d9a87e8999ca547b8c15d053e1da56b0c70660061c1fc3b674ca9a05acba128de0415016cd714a29878aaaae6329bc6f4f9b3626efffac571987cee8ec2b68684b7b515c5b41723bf2e9feaade5698a3bc7b6e6ded3436f6e536afdfaf45a5caa89fcd7e2ba7d5c874a0a955add8366c2b78dc6bdf62ad5d560b940a1bbe8c5fedf4363cd873459dc84020c16d534206839578a1b01b3a0b406957989c1d49020446597bbbf5fc346df106a7a7ed84f5d4ffce5bb453cb13be41b27028a3fd9910c99e807bef4a89e1ca828f3d3c17b6b2814a476892af569a3583fce4e480ed000287f12e30761ec97cae5d3f8c397aee5e5047f57280a0caa3460cf15ef99c125bddfb556a5ba586f4426aeb31befee5896bcf4ad22e9292f542c525b3b3a23bccd76617d06516e2dc179c328aaf9b6b6a63b149613e405e90e9d6df28132a3bb3d6f534548f71508ad9bea25fdc67a8f3cbc2f6c66fb2480fe12521f941ffc0c044bb775e4928a63e0b50c2f8adf1b0d8354912595b822e4b09bb7596b081f6783cc6b24a4b2e2dcf23d47e01dc7cfec00a9179b3d288604cc91a7ebb3457384c20123c0aa6441649e94837115541206de1390c754e4326aca49fa8a8c75dfe18f0be185270ad0fe0af5adecc9c880dad5bb971c64308d1229cb5e0f653755d1ed39d1b6c6a12c51989a94eca9383bca640a857661744920a14e78b36976aad7a097053841ad871da0735d6c2e007cb2d1f4745151fb22148f0de9a4351b818a16fd2ac006b5013a10f9ca1e94c59ad14b3836c6c216a4564cfc780b165ac8dc3446960a918fe5d7c773cedb8bfad116b2ab5d52db340e4c3f42f90a4b7892fc321ed5331e2deffe62a27582ebb5b9cc312788087981f779df32d30344d56e89489ce074582522ba30a4530fa459a11582a865bc5dc231768714d3e59110e938a4fe52e8994492498f1652349680af4621dcc18d6673e44a089308064aa9e282a181a655df73b44988a86b007eeb70fa2c7ef99641fa07bbe78fe6cf62e33b69ca316e56386d79693f550958f7495083eda41a08527e52860c7024940916e8c6a151e79c6b5e1d10283bbcfac7b5bccfa8c3787329558e136ebeae0cbfc8a6af30452b748058e4094ab085e91c926f6204a4e0fddb01305afdcd713c0f740804ed9c17d446bb5087c81bdbe8a2d26df6f74e0487c145302b728fb43f8b9f35a1a317ba8d7de432fc3548530d599cafad5298d302de99ca11b83b66dcf8375c531f8dfdd9a466ccf9ae8699202f9562be31a798d5192f8736f8149097221f633c459ef9aaa3630a6c9de23dd769fed84871089a441a27a29084504597c8a38bd1b9de82bf421d00fb4b670b9e80faed1a2250da1f10cfa378b6a502d507e7621b83160d23cdad935e69076f26072cf96e6a09fde94e6a7b1e96daa21cee8934c24fbb8c7c8af7ff5ea472ccc2365f8261fe503a88feb22c124ade17bf794196ab0b9d3906b60e52c614b8ba673f7a1e82a99639fb015943433e7404385434f2113e3344504fc6e8a80e7abfb43a4820bf5dfc34a80d562301d8548630cf0e086c883c17a04143110eeb2ce4318e612c05ca7ea23e3785762be32bab1c5bb529a1a45d6a50fbd7591cc3d4668224141a55e90d0d1b43a8aa485546da11decb88527c545e0d42261cbb068e598e6df0da81bb8eb7bbf8133b8f4724c3f1d4ca74dfb9140d45cd3e4326247543b1d9799e6dac09d5f95571ae88f2236f6f7d071f03472479f914ce3f46133c20cf0c483a6782235a579f116cf71fb7ff57dfccb21fc6ac501d9bdc3beee1bf8b42ea61760697d7e3421436f8f4b17f729a519fef7ae5d4035a072443dd3dccb034772f2e0881383c8490e1ad879ba489044c4d9ddee37db54fd9e0f93d81c59273743e1be7c18d7305b5cbe20d50bef7c319b8c0863d94aaaffef4cc5c974fa080328aea160020b18c4f712fa0101499b046dd7dabc5384033dcc59f1c70fa1bcc128f39ee2347e7f14ee98fdadc69872dd8ee15d8db3ade8572d2c050421b53dac74c5a349d8bf9194b9847d20a303f009d462c28363f6ca885eec67e745c889a8a9ed14c6cf0eef7cb66e2925a1abb1df67fed72e01a317a8cd82584b30cb43afcb3e47eba668871121ed5fcebe73c1b2a85ee3c1b9c2492421f716cdfc75a41aa9e7b891335eb8016f219d55f85d0b8e3d5009daa1edb47ad0c50a91769f2958e64ca094f303e066af42c41e5e403b76b35ad4f9522bd37e2aeaa608a658959424ba1c7e4cfa42c81db4dddc1f93d0c7fe3c1cfb0f4a96f58e07028f9c72aac833241aae368b49034022a430ff81308e989d4b9796a863e1b83b8fdab65ca2523b3b1b5b263f8a7b6b67859bb38b6b032b856447c64eb06a7a76cdcdff6329f910d0a55f690b9d658ef2c50a7a4dd89c36aaea5eea709596698b506d823e0a9a99587f9a234442cda841dbbc642ece1e234627dbbed0693b368dae60a312480c4d1439ba18a5fc2cc58b13c8fb326b4f6f4568dd9239a7f87a813d8e8ede90d5fb4c3d3877707ae81353c5fc57fd896f777e3cae581c3772d0f50a5631d387f94d12aadb2796ef7ccfe2261747bea646cbb6e85086eb74d0f667c3d724262afaee2655a3ac3cd3fba49e61a35c1c111fb14fbb72d1cea0e805221ba695659888849da4e6acef9d9dee312b37419ed47a2b0aa92ba3bacdfe9edb22096288c6afbf7fe3eb3715c39d8cb88c8caef3b8faa4b7bd82840c686635b8dd629a5ae2b48350e4e4fb66b2914f4f9fc3357721dde43552f08d61b28172624f6942a3388ef54e94aaf12432d3dd698dd422ddb96b9cdf0e032b92238076098ec6b59275b40565f0d80da8015533add08ace6c60dcd8a079e84ca9cb118e0739fe3836668b269771636c8253a40e11c0fde9b2fa6ff554bad00af391973cd4278248e99a0e640a05e4d7300fd3d5c17ad73e11e287849115d9e18bcea4cc71fea1d13fc1d354580fa22bf3d39265754dd11121c74c6038bc331e85084ad840841eda827252e73790dad33bc666fd20c5a2208d00b96c279c8756e3e6fe39852df2aa671fd935777609d453c8c5cfb8987d513f60644aad87ca46769521c3b7627a140e1392fa07ef5f30e115652af8ae8541464b72f7a85ee683ff59c3fa665731af6287b5ca04e74a66eda95f1dad1edaa300c8704964af8aa15990e3d73416919bbdce26abf135b734ae1597f3c447762fbdbb7ea402b8fc0e55c1165f362d25baed977353a72771427d03beaa2e1cc7d14d2ed6c181b38a2f3bc71d16f13405666b2bf82dc1fa11a7e06b2b673e320cc1585b344e1df3173a5a2071ce638f19b4e5203a48d25eb5bbe9ea3de6f5868585103e0d401e2e24d65098d6aef7f06e1d04c420bfb74d5a0c41a8825a47fc0de7aa1eb469890638a0f02daed9a0831cbe8b7da74662f7e539d923806dfb016d51c6f33a5c8617812fce63e6e786d0ea0e9aab733bb24a5cf5f5f818fa25513d7f51140558fb966f33998ac82e919ff6f8b2849506c437f1b37dd7cf76d1b53042380c616407bf3c455929b7aafd5130bf03c2cf822b700e950ae313d45765f54ec9ade5b9a0998665ba02e678f66b93f39cb87cd844b9172628d0c4d370734fcdcd920c3036b17bd0a6888281423f5d0cd80674b2133a3c308163e2ae8b7b9582629bfa167677b1581197f4c7f417720fc4adbed063beb2d1973cb840f7df26e60f0f191f248b4e974765cde6c16ae8053e8d2bb96057ed52269c97199400013d05f720eaec6ec44f87951a7d71fec62288c5df2341a1edabc7336edf5ccf7892a864b1cfeb84e91faf7f5e833528c7d27018b1e72de900e80c657b365ec92d59400c04d2441e54695c59f2165995a3f4b4639e3ffe1fd5c8637c102e17ccaef8d01567839a8830d9df35e2b3377b96462926f11de228a34f12d66e0fda86c66fe980b711748d5e401c341f0f5b6be32086c37224dcf0e5b33a52e446d4fc708a1b87d3890d258e9831ee8a96d67fa926dd04fe36cfa6fb91e51facc6537a61d4bf50c00efad23999d437b05185dbc5f5b9466512f59a523fdca9bc5fbc67db1cfdbdcedcd9f45c2cee885bcd4f2c48a7832f62d915ec6206abd4b0b3a01ee4f99e83008f52c298c45c7e6c1b703db9591584c53616c3e68173b0e59b41d03c3adfeaa275d7a9239873473ff9d6c15b787e22786d6b88618bc2fc5fe02b790f908cdbd1ba97b8bb17326636aec4ad70fd32caaa3365f8f9c63cfb5e63debe5062bdc5105dc3b0c8753d47391a98f7f9ecc4e197e9bdf134f57245eda969a18f8032b6de6dd1c55106361511b9426d2adb04db3af45a8ff71a8bae194d644f0111547660828e061ae8b8fc1146dbacd5ad6756e67a56faeb9ea1b1d87bbe8083e485ad5fbfcd377f2d339fc8dac601b243014661589dd50a2ead670d70085e572dd2a80dd3f9ed439d19845146bf43b0bce500dd081cf2034c4753d79b102584521ece54339225ed8301523eaff59becda400fe00db0d578a8a711d25db48bdb0797ce0b59b5b75f9764caaaa8cbb123a52b5d8b2cda2c0028f7f61010a2fbffa5f1f67dbdef40069cffdbdfd84114dd35e0e3c22677261ac806bd00df691a69d474c84ee54cdbafe56796454d0a52f11b032d81c1c2979a02f25a557a249d8e2bf32ed1f3a68cfa385b95067e970fc424286d8a591ae0a6d798e5558cc73897325acb292b48392dd0545cc5578973d64587f2a10f7c8af19259f79964bf304b3c43949980b7c560f3ec463547729bf712116bc0884c9f8ee41bba2e69d12c1d5474eb1052f5dfdc2483b97a4738db6ad6897cdd3903c36b4b45c39d126d4953df29e604fcbc53a3281084f59d5bd102e9d59f380f622ce13d513178547514802d3b6b9c3996165bb708f560b8d63048b31ef249f275c563c9ddee45df8f07c8fee92a4d76d7bcde5f3f56b27398c4cf3f137572eefd6f91bc74c963838315eca9c4b18f9f4e9fe5c5c6d8d9d52c4d616654376c1b9b0ad6a034ef09faa3f43f4f267ddda4c82e2aa552c13902272c04ca85fe0308d27cb67e95ff322a252d4ebb257a5eba9ba6ec7aba470e42bbf700f54433ee71aa80ededd0d093e1c5028558a91115fc03e854cb4fe620b70bd2bb264faf714bc04b0bec42655eddedb1538c2cd812c8eeefcb7d69e93828b5f2eaaf0d550975d7d1c0c23979951860edb9dfeac96343182397126b50cfe28b71b0b96c3f9f38266beddfad5e8dbac4ae838ca2cd1f972e0c660ae4894276632aa67051d1561a580eaa8cdf4ca95e44dcdf469711b42fd6ab57c84da4d95bb4a897413fea83c4042cd04fbe154c7869a0443d3689332fc54868b193a8cfa27f4b700d920ffaccb9262619f70a59c324076d2dc4d26e95bfde494fbee2990425fb4d3d7b3c0a5b16c4a4b266cfae1e15d0790a8390fd337b7616aef8da07138634644b5265f71f86ff04a5618f50acaa2106e985b81f619110fa9cdfbdb91df56acc810473ae2646750014ee7eec7866c8d7a06ba0d95b1a6ee7ae07c9fb303f72013143968c5164e207a7d0e93a0874a70649ee3b58c801455ba14d7a39a017a6e83f1669e90d02d0d2b59c91820c623294ecd139246d07da10c395849a064b36b7b12d407fa5904f214a5d6ac9d8962767e4813fd2652bf4e1e3214c7ae64830ebd0838f0e9f06676a1036d5066459ddc14c945c2a705acf6d1c26eed8c248b845cbff9192fec8e6911f5befb73bbab05703b0e67be4472eac89d66e57ea9158f76a92966d0e4b2f4476dd2eb1757191a88540974c82bf468855963f073a7f9e246c5cbc5ef78e7020479e1e80ba2f1c2bbc6e89fd0c98a072823fcbd084255a44b4b023acfc0131b25d89dc5e8e12e17e51844bf5f40f49e3eeaefd4c3f1785dcb4bd2d775b18d2a6b01c7f45af781a85d60b2276f651d5483ab5e389668b6fe8344b1e264dbf2a28670cad15d5616a23dddf9595477ea1c4b45b62aee93faf42e9b8067df186b08794d44be991183589a61ed0b302e7613f7accb04032d09b46601ebbf87983b1fe9c18ef3a6ef198fef1aaa06082d19491ee2f6a1f0ca3ed9aca838fcf42061d76bd392c1be01ce17bee564ff1fd6d3cc94a1afbc2be29da31bfbd8bfac4dbc50fa2e3e8d8185d582744054c92d7e8a2e985cf5524a00761a93df7bb0322ee3ada584bbcfd37f77095a52502c9a8a1c173dd2b78f39588eafe9390a613e2fbdc71860a1e1ea5e2e3ff0749f286f33bc6ffb1a3aa2417043be2419bd8ac85b02bde9564d57cb6d737a96ef566e2b1f62da9f06b398cc79dfe3306c7c3db5cef2adffd2d39472e684a78f96b90d34b46f3d9b20c75fbb46399ef49d417303e43e0f4ab98f3df1e15110e097608177a38582dfd308b998891827740309a673c595d23783481691e9ca27edc38906b572a49a527403ae14cec39ebab3926f59cb234783d3778bbedc47e9473d9ea18c921902a4b69f1c987d6a1e3cd94e59a43856d26b259341b371d975d6a0c306014641997e4720b984b90215f5495796cb66a8efdf71064f857bf093dc37260deecf1ad28788e27a3c1ef95be43aeac84b3a338dfa0748548e394ff575641bf8dd29942bc4cea12929e9440db7ca5a0b368cf695bad28d99f3d74d3ed2f62f9a8362c761c76209df11ea063adb1415fbc1bae075275e444e73cce11b476e38127ab1e026de7c4bfa475177adf13d23d57da608ace6a3775648575d748b633a184b419ac5fb79870ae4ac0b15a55337add220b7e106b7fb1a00b266a6e8b3eea72d029b65a6ee5d90d7263c32870c3aa591df9b0a409dc17d441dd02fe63f7fbbdecb2eca0a994c374aced42e365f2a70e2a20b605df96ba2259a974f72cbae8cc930b6044cb68c231885e217ff0551737cb2c9610014fa61a95bb92bc28c4ee8965a5be1f2900f825249975f33925d21d5f15ccbdcc947a02d3790b2a2293a37f7b7e47d2aab21b668faff9d0cb2fe21295f9a1f5fbe3a183e75e64ca32c34dc37950b03da44aa2c05facfceb62258691d553f5b0f7d9dd7bef3fa74e8da908b9a308d2a7cced8389411e39794528aaa435303ecc2497ac7208571d593fb2c343449e8002e49929e3e479a9b4c7cef740627cba0f63f5dbdb0b45e840aa46bacaaff95c179b1fc65beedc6ff016165cfa28d38c09173b7df74abfef958e4b6504c04c4f314ab99d532545cb94aed32776392687a3818b3851fbbb99d5ed9be4f683fe27a224b65af37f46c204505e4c34e17699ff6b59ef135689a7820e0c5cb8f9ed64cfe151a5bdc850fa98fdb0ec70e73a9af150a33c56eeb50e732a90bd8a85fe58a0b9605f3aaf766384c80e56379d8ffc29c868cba3388204113bc7a2ba062f1c87daa79ce6f798569c0c57e8a6f0279d23d230e7b33b286dbf2e081d226daa32272a66c798c776fd044aca3cf342a8dfaaa37bcb58b5523134e33dcea5d509e5a4f935efdfe0cc6413a4186cb10b270756d9cae67ea48f749cc156a66fd5cf932383907a18d471ebcdf9d191973885f888f6aa4f680aa86f6e4bbe96e32d4d6a7856dd4ebcca2f8db718c50c0f2b9eb4ab9061a938e43ed070ed095deaceb6b0510d8712fe88f4245231ad72c7f2de55ae209cbd7265336627220b1eb9147142cfc2c5855761f1f6001d5cca355a2af3ec2baa1afaf3c064780adef38bed6c0a17f5615949a89e2378e7eac4c297b3566a8c3bb3dc49242de222f080283db8af8c517ecf1d109ab9168aedb16a2b0358569e20859670c09a8a77c348be42536043c32ec428fc8e1c5478ffd2355df4cbcbea6517a7aec108424c2c2b4bb21d6d79f89030d957fdadb3eac446e32c62395960f22b627092a67aa37e1fa4c85b48627740f171bd0b0a1f4b33f61490ab09e12379d1abbaff3bc80d23e6f1f88270d64d14efad49cb3681fe4ac3098e2c92f0a15009c7b6c5fe9969ed09dc0334e969fbbf639485fbc368185a53233a9acfce3666ef34b7d46e9674ef9b4c2e27dd006bc84d6665057d5da230ea8e6e77058594ac17aefcda9e897efa741b706a5ae176f37cd7c758bd15b4e2597d4364217873cbbdc90e69b7c3342e1878b73f0b86b511fdcc8b6b38ecd1d1adae880fc7dfc15f6d08d4d62e31b7b0a3649873d390210eb0ac784555a49d62c5ec741e60b4948b3faa321050845e59ac9b294906ca7318f33901525355","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
