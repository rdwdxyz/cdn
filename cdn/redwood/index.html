<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b4b4454533445df30f0985b4a9d8a935cb9a0c54c7f64ab68ee913f751e74b8f13e5f4bb9d54eda6c1abac6a0d27e7117bef1bc8e54606ddb397059289a08a764be396a081ebfcbff6fee182186b038e8e495a8a117acee7ee87f2d54b3bb24134b640d94c6226b88bd3f50b8266074073492ce7858a3c184bec294343b4f0a6fdafd66c243faa37e1037531e0928c9249ec61c6731d8fd1f8c3d0f724a6e48d50502e622d3baf41842552cbbbc68bed52651bce359f458a3a87241af93fa2a5b12938b746a9d1cae5651989def4b7e7ab00f2129e46026adcad065cd85df25e206f0f7a2e4a01983f66acc7596f7769de45b6bb12b205c4e4699580e82d160483dac6d8436f55e49409bcbeaa42359a083c56d9f2c45a6f8ff09924eedaa4987d9ca778f7780e871ab004131683eadeba99fd821763cdaaccbb1574c412720a123827bafb42c6a7c6bf64356e669d0fbb08ed7bd0b07319f72deb1cc5007a4186d048cb35aa8a538326fb240a69a970ba17fc36768682d9cfc01735e337de19259b46abc5f0f686ae23731f9f6b42f813e9a1e60dcb36e8be7579004c7e8c37850cd2477c64d81e091accc564edeb08dda43a4af90099c5770757d68b765eba0c57cdb30a7bc9eb5c7210ad8e4903bcbda01f3adb1c3b532e0fb22a43c9a1beacda721db2015041e9b2589018273caad66d22a74cfcfbabf78bf7b3b18d30e53174f1ed2d495fb0776216e39a3e356d9bc2061f56e4586dec1c02465bc6a900733be5a6c6dbc8b8b2d404fd31e874d2bc8ea14a4586e0856f81dfbcbc5021be9376cce31ff838074cbb1225697321522ef8db4715eac3f2747e8bb1aa5a86e39d415ba8223210eb24845103c1c4cab0188921ae88efcde027489edd9cc8377a8205bb268c2e724384d15d8e62918bbf0140cb7716425daa505b6b857c0ef856838b61cb71bdc966d72cb750802b6d5c2b3e3590d36d4aa38b3dff95ba6bbb60f568cba72ee8d1683a48965afca13a1f4ffef0cc4380c5276538d282c710e8f6cc0e68cbc7ceae4ee02ebd70c684888037d05afec740ab2587d8d77ab0c14c784ae6ca47e062112eb30216f5ea10f90f6c4b1d1f9b3f9ce5566b6d816b036364cf28cc882f7bfbfbd0e451187dccc2cdd6e36a15f0f91686b39139fa3c0974cbf97cc7805a456afa568cfca5d2e169f2bf40055fb62d25ec42b7479b4cf2bfeb680cfffe5d1acad79ec1c108a547d125220ab79729c309e0f364851455f7938f50f1d5ff4d08c9c7a53b3b59418d4e3234cbbe30d3c2fbb3579574579226072a73a381555dd584f3fee15ec6127247f69bdef29f958b7114dcb1915d101c17d81f8d1273264bd0780e8c4aaec9fb479e6e47a8da95449d301320c10558bfd5e035dd15c2ebefb37421c99fdb339b971b1c0f5127a7ab09dcda88edfbcdd2d6096b2ef730cd2e0bf448970c7de9812ce7d119c27fe02e38a9154c8b349a26212e3d248d5de1c78e2c16080ae02471d7768693f3941bb9fc6e8581c7d93d4042bc945edff913e51648b5a2dfd1d5182234dde3bd9555332d15621306dc30a19dd3b311e76c16a5363c91574ed6c8d07b21dcbbd3671b645eca78e5c95cf3aec2232fd20ec3c436e326f53598f24686422538f8953c940e2785bdc8b62562ab1a96293d5734c9fd18c450ede103588e636b5eef36f8113ba7d12fae602a2e0f6e09d4a25f6de6093e64a38033d1049c93ca6a7dccff50d55ed5faa6d98245f415b83249c080e401813fc872cd94ccd6f3da5e28a239af51d25fc8752f48379c3c47e108a074539758b0522354c3aa539738605b91f1b51578f573557e54d6da5391b181c6c1b8ca55d0083d02fe6ad257c21afcb1ce3a9a40229f29371bbc68572cf463afb4b53393d2db90a2c5819ae749eeb1b53c3b7c03c062efef139ae61f69ddd7c6ca558cf17bb43cc69723352456800ce588d2e877244a3c9f25f8c304375452e313212aa1df36e96bf6e741d72238b5a0c71a5eba6ef0f27b993257daf8c2f86aff371be1c1e597576bd6c153302d32382c8e04764e9e1076c718dabe22fd0c697274918c83cce71374eb3a8c334c04e7fa315b9852bedf1124e3fd821dfb8656508ce56b95d0b3bc179759917740d9872542cd77182703074a6e7d9c589a5aeb794e934f8c1f225ce9c9bb38c11af3f0df51b1c22a4a1c8bcddd37cc74e98fbdbe8e21659c8350591a43185c9c97689be43df9467adc68bb61f17b03128973d726db079b79444512ad6dfd153437b0c80d0374005883bb100d6909aa79e59796d0d547cbab4d993a69deb5ab79c7514f5dbebc514f2bbd00ebcfbccfa2ffabaaf8795e39cafebc5fc6faee5cf4a75adc5a80e531913db2e6b97159f7e0050a6dd2279efe936ea20676cbfadd49777075178e03fdd2d40fe8c179315508dd05db8a64fcebb40027d8c3682fc6019fc197484327877b3c9b56bf61f67a8230284b19d3e9119aaa532f45ca356f593ea0944355ff2872cc4227ed4ee0c26a3291e0c34b0da55dc37c1583e2895118f33690d0b6df4883f0faae0047423b8f6f449cdca3c4b1cc4b12d336af430d498a5368d691c1b222b5e48e1f2cf6c76d0a7e8bb156ceb5652e2b56b57ed71da50fa9e150286cec9d8cd26ff4112ebfb1c179e69e2521ea8a592a1b72edc4e59e14cb8f48a978de6549f780456423fad5f4572adffae3a01cda4180cd27ee698b20d287f1591052a4c020f51a47016c09438f0c0dd500caef98c73532a189e9d4896a1a4dd20970b060518f19a3750c4cbd333e39ed38a66bfe23b9940ebe51212e7f79643e7670292abb2aa302430231bcf3ab3f58f81cd7d4f021e126012ca579df50cb05e2f5acffff510ce4960de9a6f14e86bbe28b3b7ba24b7505836619683b1a24ac109968fbd5493373bcd61083b3664a56bc5fb8d8bad7873b2119be7e263897a739de14a1801060e70fb63664d6e7c58a6f6fa35bbdefe17eeb3ea1550f28c36005dba68fb40924134abc29bee69199fff8b95c325cb061b556acc6c68030d45ce2f1ca0e8a6b74ce82867cf498bbc9a3397d85a237d6d343d8fc1f58c04fa78bb1f9230cec90e9c302636ab40b3dc668aebb69914862a758a1d203cacc934898c79069f89a13c14fcf16bde7f51ef446c83b56ad64a9b9d13d82fcdc4dd805547129e30129df8b9ba3ffac869cb5d09fb8b273c8e0e9e2e086bbdd4e79abefc9f27d2068ace61a2d6fd17d97de7e09af8ffaa1fb58c6277e3d26362d0e1b69fb15d3c11ca589d757c0a7af831e26d8da0c6f6ffd4206709fbea964c4d320e6c42e055cccc9ecf4ca8de6af966117d46b8c3c4a43e9d36238cd68fc0a85483ff7b4a389b97c03d4b6753c39a82c7729623226ea0d20c5ee2f8ed6534f926336eaaf2d85386049f9c400e2976d2ab9488b62a253b24bfb2befc7387370c06ca4604e633bffc14befb2b3b452ded19a055ec003251f27f71247df5fa2456de8a64a8525cda0a41569a6fb5e83a571b3af77a7f6dd36f622a857ed4aaab04eab74c353569c33fb585ccddb139b432962ffa50c4f496e97d532da8e057be9bf5c1b46a68f6089372665388ab2707e12699da10876335160a2b3c597c4884284433383601182f27f6040facc04d719750bf607eacc989bc1ea67a5468e2876fcf0b2235096f65234c4674d2de1f5c44d20924859a9d9bf094a94e9380de07bea31dc40b07af32819748ece1aac7b2f81da55843328d4342d6d73e193aba7ca88f4fdb20051c1df684f3fb822a168547924a6475bb82415c7b15dff70dfbadb3d66af9c531fe8f70de98ba36cbffb1dc269b2816d733b74b3401f817b2cb4ddca63be4116db7e73e0b58b32ea6f2dfd640b94267316b6a5847e899d0f47b604c637674595593d6b4781eded36f7c0ac876b3c1d0ff61605422b5e05f4205cd95e6ed0a31b847561af7e2653c57c213a61f58615d6903d5820a1c6543ac6f16f3608addb85ac52ecd9fb39e40cf34eb9944cb543ea21e6b0f932eb944910c1b0b462fae60b46afa68359cce52fa5a9fd024d4c905c12f377dd22fe6f2c00fb4c7c1ca278b86c912ecdd38a1b8c7baf24f034549c3070d7c5285acba0e105ca22817331adfcd78b4e66084b62b87a02a5f4695d81fe1436a23ed2d98ed3cbcee6b2575b295c428f240df6e90032cabb4fab0bf88f511bf55841252be6f36af16fee6e9c3f2f5fd195f8c5c5536858f5a17489de1d1d3da8155f1181bcb78f553e6ed48525bb84147bdefd6ea2ce637b22e52ddb99b70e897a2706f14462ff8865d0babe22fb883bdf84e5a3e5f914547fc22338b057548beb09f5e26f3e4310bb9fa037c831e90a8dd77a08ac4da28452e1f1e777bbb7bb5fb2f407d47398db2d3e574a0f6813198c4243bf7a11223c6857a650aa6b553e5307d87104ad20a46aad811466daa15cf8b2d441774b4d2bc96089d19eae1babac97f39919dd881087c1d53134d94d087f3319f68e3a9ddf9f5255fbb4d34cd9b2af8ede01359f6a4d40b1ce8e4aceb33253ab46066005566ef6afd5731f8c62aad2a7d5b00a5ec21c41a110e2f46bbaaf882a2a033850861542b7c6b51ad01fbfa6c32b7159c18a3478098f163ae79d8d408c60dc2c1da6d2228dc1a078da0d49a9b9a9bff2a23558e0fe107a22e7238ceb762edf4b0c3dc77e60a490e526142e884cac7a79858bdde769585fdbabb9694277fadc064fd7a3d235de6cbc012d02c28e0fff6451a906bc6a2ac360fa4a85d0ffdb1e37f027f169bbfa6abcb481f0c089fe27be2b5ad2efd9abe168a47d2c6c05aa50e2d5995d3e4c6e1129b36aad3752cd61f03a00124316f2df01abf870ad6951613200acf73e5f08e989d381353af8aad7f6603e938db3be62ec1f01ccc1e2e1790dba31d053656fb4c89017c4af607fe11aceac88e846acb0bc10676c500c02774ddc25726ee53213375add57368e4abf23e8c2750b6084f3322012b9a4aa88326e47620bcb7ce78a21591a99519d18398a1079d000ee251679dbc0846cf7f215c3548555b03aace15c5891796079ebc97d2b52278fa9572534f1635bda241510cf6abd7b9a9e413ae352b96160422aadc4d53666ec87837a006f78176a76dfaadd33fc736d3b00cface25eccff97eab46e96f7adeabcb1e7104417d025add8029bbebc4a7d44c0445057da1ec70907cb911d92e2f703dcd36b65d7b4babfc5efabf0b1b82ef0ec0bf6a71665417cd24c9d238bd9474662651da8477b8d506f2e65ad06603a16925d94ce4948c6144c3f9c6acb19f515dc114946905c14449ea66cf5b32109e1e7d69e94e6c071d4e2ea16f8e4fd9421d2788cfcf931db1d5ba8d332ba51f3f01c7174c070610763635e3726e0dcec68398e0b2eebdea449b5049a65a3bf4af48eb2d48f4001c1e44c930ca464f762c0a1c3cb446195165973cd64dd3f81a5f3c3077de2c3ba8b74a9e191da58d0f02ceda2fbb4017ea6e82e0205be15c11a12f86ff485382ee0c10d430a93d5e236e477188646c53cdf938d05eab60f005b84a81b485b6659f52e42fe3ba678990c242e572fc6a4dc3393d429ef2125f01d145eaab927967755ba98b1a5b08dfb7645496401e1630e842507980288937d311b29455113b6785e1d8f1e2423a80d48cca99be9c77e0282d743723c189451c71b29617a203bebcad27e4e3e4c8984325aeb6db166e7caa34160f78200a24f65acd4f2a43dd4b26b576f28e1342e2c2f49566731a739985e8cb67852926d81927395930b32f374e08b56a75a689be752f17b3f2ce68e006cc8a2eec4563a067fdbbae87cbbd1f4b669e5ebcd63fda131206445689cf0e7c2ed47c0486284adf81f27ee21a85d7df55d303423e66a63915a4ff6054a419c89f2413443a3d91ce2fbd09ccea1e08d88ea65927f5d44c0bb559ab4fdb59a5c756e8cd54e19007e1abcd9da39b2f8be20c8f7c7f49e9defafb37e60ce5db34411c7ac0cbee04f157b3dbaba656619f2a6a8736aa0f7f3223a916491210199a3b983f11cd45b1d1eb3a3050dbb38a61a89198bc7b675fdf46cec0a984996c37e82b7ec7faef07b886af590e447e960a97e6c1477ae37945840bbdbb25728f9e2b64d4cec81e3937056adb01dae2ecca5f8ecf116dbfb6e438f6d1587ea862430fe9c2e8d9ca55214e2fe835f8199fa656d16000a4bb547cc041c29f78eda350f64a7721745a1b2f49c035edac2d276511bf5e013b92f51d9664ad65d23eebc028cb0bbfc563d9aee290ba1203d5bc6a864493dfacf0bdb58f0a9a77361408e636dafba2fcd03e2c752b8de0806137638b723efcef87ed5becca3d078215d9a0dcbbfcbda474b4ccfea6246141ec26c8a64354dcfdddc633ab04b6b49ea45eb8f153ad3207047499c560ec6367caecd9f50256fba09ea0ab897410bd34b42e618599a8b929545f1ebf6640e699499223de43d3b0b420c53f1d145a6d2676c4c74b852dd17aaa1793c7d3bf0747d3f6e4d5f80a72b97bed3027d9226a469c0f459f61e60d791e480d0e7b8ed3bb8b92f5493bce352921c844677cbebb8780b60cee064d8c9d388d946cc70498b2ef16644eb1a51a0b3180a5e0e775caa11f61e252694a27bd0ad6ce32ce487914f0f84384114751a5aaf9f836975bf48486923a4133670006d6c6493bdd9b40ff972e4b6a10fb27b42af82bc18ba431c94a7fe476417ff60184abf2cb82f78230724934b015e64e1cee692e5a76cb05a6ef6a5fafce13a38316d3ef6d632775ae62853400837783cd5b28aaaad032aa1346c9b0f0068416c353be8b34af4c50559328b793ce3c69a18fb151449b840da00d0f75a521a099abe63064c26cee7fbebc41484761d3ebe72134fe1b5d160c36bcf8bbf8b072b6948d2a05c793dd026cce057aaa818107e66817ce0287601b4f169bbaf2744364abaad9568eb923297f30c643db9c0a2ea3ee7624549eb4a37c77f849b2301dbf120bb301ac55ecbd2ad489f6e189091caeb021118bd53b7e8aa9525796b480bec4092a3dfb855b93f52bfcfc12636d79126cd474e537abf3ef96998fc540ff547c3c8ce25bf7cba5324d0b169c0d287a33b819f19c424abc2c36a44597aff1735e7b5331931ad111f5200f4a6f39b59391ff5a1e93edc2b0608be14ed67d954eab7e557b131ab98a95be83df3e2123ce78ee9aad7613adcb1d8fe93b63ec54adf5fbfb4f33203b9e5ebd5dea8b342aee363b83b5c8d3d13feadfddaa713b69393b7881995a8cbb43e323b7f93d61defe9c1038eee8b31eb1204c3bb8e46ea90b34edfdca6ad8efbc430bd208b002b4db7801d663c8b878a1c72bd1a85077ea05f8034ae41b3e6fcc7d985a4c8ccbe5191f68f15cae32a2f083012e89254714d0a72e08d12cbc414c21287569c78b962ce7617e29fbfe695a3ff9b71637a5686b988c687effb32f4e831b0e99e9345997adbe063e6adabbb124177805cbe679625d206e1e1dfd9fdcecc11406b5b010800dc9b6b7f3e9448c7786cfb7ef06f058071ed123e6e946b03e0433de96fb205a15cefaf0095a1886a7fd335d9b873decf4b99d439107cc56bda3fe6d072c82c19f4157f7c0d70cfa5a40ea871c60a181bea4337fed907bc414f7be410ea485026d65654a422b2e355ea04a32d2e6480573713ab0e5a965a529d8cb3592e848ca03bdc87c6e2f1b902b4bf70d7fb62cac9386f5484c94e1e6b9e5d814692d3fd19048f575fb20476c6f336bc237ac4df298fc05d4984eed1f44ecec3fee0d6c652fcaf00017109ea8b37151b44965e6db0457887aa91390ca95577f7fa79fd0bb6b7c86b1a5c9291fe0467315b8dc184bc2440bbb50f1f7ad69b020af6bfb3fa38dbfbbba757afe932308e447ea4c0c091e4f62215f26cc59391a3887c8d611594b7137c796bf2ca7228bccf3e8dbc11c975a8601fb76cea28d8d8e017e5f4ab461777329b9f0bb8c47fa04de51a4f801a55c416f0d2d9f1b530c3f7ace80414e09b04c80cc6861bfd2b91368a1ecd64bd31b3651345bd56843016da018183c21723b40a82d6c41be730a349c858962c6a5cafbf5de844bbcdc57d229e0013043f25f7bfb38138b0fa4cd2010b8cc5ed7b749f10f9507f58188cf0f05366cc68fb769b8e7e90573a4e1559830ae031904515dff060fe023c5da1360ad18c8e6ac382501321833de398df7fdba996c8105a8e62e8690a57f68169fb7729daee621de1964bbd830fa44222ac6e53275a5beaf2f75ffba29eab73a81d778c2db3b6eb8b4ca554abc2a8becce7fee33db694d8d46a19772a3d22c127afc9b7ddf7d4a2d6e5de8d03249e8a1334b88ac1e0ece7d7a0a278376f0766952ad2b74b7d46d586563af9e1923ad195dbb701533a8570d79940c251c88807adaea411812869ccb14c6791cc2e5888741f5692b6635d0aa9da73bdca5db1c247765f1f211ba0cc34b202d2df41399adf6c3eb925ab3f2c727cd07ae9dda2d8da9fb9d4805733ef4ec1e530f5bfa610921b04e8af2dcb2e148b8eb9d619bdfa861110659afca1de87210abf951e35c734f0a354094eb6334bfec84727992325f2919cecaf3196e6ae7ac241f5729b65cdd5b5dafbfedf2ed52272e773141bf0e31177eecfe3910d93f97125881bf42931e0d76069000cd5bdb0e951d8be2c1e607e8916a27f7e9cd0994d4066f17b61af9b1bb2843ac95f033c17c9be8e19d56aeb981342ad13c196cf0a4e1b7f0b70cad7f2b47446f901c14dc8a4836c796992c0f925e262cc463a575cf68b4bf58cb6451b817788701c37fdd08eec7422b66291d07756c99f0c628e85602e9147cdc7ff6add7d70b043a2b8768c3890c447c5a72469a4b66de84a731fa25931dbcdfe54ee7cbdedde338ba4c47b6343104ec0ede51828528dca13847274870f4309a5a9ed3bdea66b1a9bc3c0e52da2bf4e784335deb57e7c00f957fc2f70de9d78c01c8d4f1a2797cf12622ce00eaab9f3288fa726c1c8adbd1f4672e04ba1c98ccbf5190502e1dbd3cd203508e4aa476e133cb47b0610f5a37c0289d2c9afee9b573f8fe14c5194b737d70c7ebb9a7876fa5734128ce84217f94449b945c95e891c09d7542f53463b09bb309f46144bd762ac6a2979bf2cb4a6d718a9a4e4c360f3d03bf0d921972bf78d0fb17b09524360260ad9c2c5c3c59132d80bef862ff6fc1b841972b7591ef1162d35c56a9dcf4f94fde146271a0767768336f0fb5c50e1f4658ff5c178fa84406cd24c94e872c8c87282c37734fc1126e930d7bae9855ed2bc5e8615a401b578225fd9439cfb74b6672399c3418182f020ae17cc9bbbbedd0c31d7f6bcaae192d26472424f88677804b3b98ea33272b00db5d62eaa714964d28c667dc58a0a8459a42c85ca0393dcd1b3fcfb5bcb327e7a2387541ed76c1c0bcdbb339846bbcbe117ab7dd8474cece2db3fd42e14917c07416faf480c841b26cea0eddf232dbff3aa5a5ff34cd30b176d4069ad1b389fb159129284d4eaf6d5c367e86a3ec39383a89ddb9a2306965b92159af1ddbd5e79125bfc77b55cb1e40ae4b20dc392f1949f9cad8818e589968a8aceb221ccddc5a8dd16c3bae5254406109496287140df981407430b664bbf480ca60cc56b4230d975490cec802cceb83640de827f69b505b85dd94ec88eed9a3122d9f60ae9e81f33d1fb2f35ac44bf482f62db9e93c7950429116489711d377c5db2e44dfbc8164ee7220f51bb9cf942ac02baefa09d6050ffa50d02a5cd68fab3d41b4839e3fb4c9644e58336663eba15dce30ef4b928d93ea50fe786bab40a57a505a43393ebf000c28534b48e9ef6a3670cda40d546c29c80caea49447f791493cc179dfa747d0ab0f02d935106fb330b91be025200550b77621845a7df30099418aa3516a327fe958f909a80f8e1013cad03afd8da1bb36a5596022a907f55ba25549c59a1dca77cfd6adfd73e7f5418972c3ae4bb6dc5e39316ac7f932c012c8f741ff8ff10d71f7a405b155edbc74853ada156199acc75fb61a65b7beb873300566f10b853226991acf5377972c2f683d794905d6ef16e17add0c13d753923e30ba1fd58bd89ea5acc66b65da12f5094811048b925f200eb7a5245256dc08636d650aeb3e04dc0b5ba5ce7e888bd1da197d2425c887a3c5fb072a9658b448e3533bf4e31e236147ff42482c858ddcccca89cb2989240e4b1be938a1083606c30c19783b13e8c7d16e2973addec8211ee2a10220830d5af3578b021d52479ee65cfa18b5c18a9629ddad47de5530981e18de07c7184b254bf93e5e2cb61144a0c674177f4b7d0df72aef4239ec0bea06e6a7579f89731351c703656d47d208ace18bfdd060b29ca7195e5b558e63e388c6e271acf6851e9769fb6607a3c6fd6476a40d3e35a574ca776b43b3e2f75c0b17000f060fd0c3c8b4e9eb885138f71ffbb4ce4a937ebe1ea451b87c05826ca010de5186d80e69575becc12f0fedc10520d5cdc63a418ea55b8ef9a239b82b077d89aa70781d5ae19324d292e12bdb0aeb180a3fb7533dc5b8a2d7417407b1d9337213ba63186854567513a72a964210149f63d2d6199822a076ce88eea5b6aed531ab0b049e64c9a92c84f34d1d62e6591498ea88b82e5bd04d57b2c0be41db95e10d8e8de16b5beeac9929e7adbe038c9b985d9a3fd38e08cd9455167e140f44e4d057fbfcbc45691dd4cf276a3bbb9f8969c9b9d671c154a83c4f3c6d2081e6b9d5a3540c75f47ac6c4b47c83eabb80460e89045c1ef10b8bf79ea4235a39bb8e3faffe7dc91e045677bcf99ec0001debade65b31d577eacf63e30e4addb30f79487083e02ed482da804f992ee136236b79ddc2a60768a2eae4d7d879be0a3561f7a81a35e5c4bae220832701da29eccd4e5a695a3fcd4ab85d8f80c1bb1ed0b944df26a593f3753c88d96327ca1a06a80a6b972333528b274d216be5874074a0b03ea1a9f753fb48930185d9f6318d335eb682ed971031334dd0d1b70820cea5142a51c201c5059a5000d531a5c08b86b83eb6ef5bc731cc56887519e868ff067776414fba22db876818f32258a7981a8390a1312f5db572e802ea1fac35d91e588bab33d33915408132655fe3cc0583f6b80fd530131b3c8d8cbee01db8383b061303a1ff600571ea3818f285839d26b0acd72cc562789d5563d526322bef1c1e625a9e6bef5d17fb31b93e08d4b313fc29247c8fb186539b47c9502e09abf985191c78add81e17f8d4f08f7316f31d2e98ac9aa5473f04bf58dc25a17487c33536a39bacbd6415259a339905700a7c060f72103aacf438bc06b3ef5ad3452e7e93635874ee9c87d87fe8356a079944510f6e3fa5cfd11477018f2e3b0aa080170c486721997008fba804bbed1daaf0e12b81a747f5fff6ac3d1ae1374835bfb8ce7f8b42235883a9709e45693bea076893c14a855d9fe15fc7d86e3cb3152b706575c0629ae9c351f8c8812ae2777d170fd4793b68a05a8ed3369895d6754aaaf167a3ed0038bfd6e99efb79169dda83b4c6787552f8289cd09f7a8939eea02971aa8619e0d9865f3f15ab4b62978eb9f0aab04ac349ac13c3ac8522ef612f04d5fa3e82bd04faf2b127b6437105dd7ebcefa7f1ccbd704ff018231f2c130a9e0df21ddd7706bd4dcdc84e7b0fb6224d7c8f1fd7ec941b5ad833e1e7f1c745a1fce863052abde9865f8ae40a814197d4056f36b59467918290914cea1013f15bf6875b0d49e1618fe8651c4eff3f9abc4a17fd042d634724a5af338c18bbff98144aa05ab114ac3ecd8fba9ab314d97b16bed24c2a1ddc127526a42020ed60ba03e6fe1eaedaea890b750fb7daac452bc7ff4be881c8c4446db248a1fec917a9b881726bcc37f4e8a2b580fb6ab126f072b7334d1a2ed59a80030d904b089ef573d44c1d9d6305a9162b9469bf21d92a82baa583567f1b76359390c8bff6d659be64a317abdfd76df8972ac77489cb1d8982818422f444c512cadf663596a307a472fc59af11a7d931879584390a96bd791d6196789d7b4b1578400011535b143efbb3003f0082dc595c46b165a5869f2256e37c74b778b16eef95d8b0023cf96ef986a4bc079bdca99902ae61b5ffd38d10a94fbfb77cfabef277b180379b6228de0e8bfd9a1e83325509075c01e2a1faf375def395500e4ea3333650558fbbec284b521c1dc396a6a23d216884a1c5180402e493d54a14977e847412297e4a4fce5bd4ac7c9aedf3d7e00a8debdd16ce3403c6beacc30d1042f4e46083c747e624f6414da3a181c45487b4844485774eb4732c9710ebe57540749a44c3be84ef009d64811962f0fa9706243514ced988f430ecf1c1587418fe34d024f2419ba333ca2a9c106dd2b5b9901afba66f517372b0ded1da53351bc008d84aa4c6bacec489bd64df9c94811e9d94180a4c1bc24fb455edbdcbd03bfd796826710d6fd52672fa037e6126e65ac23807f4b511131e901e37e7997429d9838cfed85cfef4cb589e2e33812a85c54e943806fd12e44570349b79b318d9fe16a71406fecd8e227a3c74b8aca3dd3f5da69a7e2c251de42313b4140236515913b454e044d7a9818065e8fc10cf4b4451cd441ed610be7bdf825b90874f46f5871067172155bd637c3cd2d3e176ed88ef77b1d5fa2d8004828b5c34eb7e94f2ed968b43452438e78a2c7260e248c632cd9aefee33ec090c7ea275c1d21150d8e6f00a4c698eae23fcb1bf1352d468d14587e01fa0b799ad30e406fbb893fc6645613ccae8c3e4e10c911deb096774e39b6fd37edb405103b1f0b0f48e1b8e5900e7835ccb15b08a1a0783ff3389833ad2950e89a49723f492c636cba608f70c25b84d57425f489ba3fc0d01523eeca0b297872e4f3d4b5ef476b5c83c13e73ca052f64ffb75b602145f368919469a35529616b6415229e3a13ee501644146c645427f145c357311a53c15bb5f6001dbd9342b98d1b536665b975b972dcd6a3a4b2ddbb7096822427fb222305da1bd9e703f62f4f4de6c2b4aa628501060204c732ec95becb072deb265774642be57ecbff7ee82294365e233a087f8335b5babfdf023931fa63dfc99e3d499f126314341f15a52bca2628b565cb5715777573257446eaf6575e74366f92fa8b93b67c58e50df8eb80dd8b7fb1dfc25d9906ffc8a274179e3db5d501b7cbf046a5ca3cc15eea7383807219b9768dbb36c7cd8b8e6d6b5cd5050d3abc2896fd6064e9c77e768fbe31825a635f2d94438791fb26ec34b1f7439e155228c307e5c1b45ef5d9cde7dd7afac4ff41cd7d563437bc576047239988f534802c4f7a792bbb00081e80bb1770adbffc5a51168cb298735c4a96570b0378c2ad1c13c0e42ea3996d3fd0d1c2558a82b17cb33967f98eb5471d55ac6c0dfeea74949c93fd08c2b2985ee1b4aa5ac38d8c1f27178152d63e7f8c872372cbdb56e5cf85348a758eed24b0bb1b88c6a9f075cfb98ddcd9477f81e3e3dc7cfdcb14681e6d4a507f38825ce8d6a6cd37531860d96c28f5eed8d911dfe8fe36bfef227c64fe0806f5b4351472dc5f7a464b88280e72fa86e5e47dd910319c38fdc32adf9a781dee026d484b55cbb84b048a7fc91890c8e82a19c2110de8881634c397ce925062b64a4ece2e42e699465cdedfc7d8e9d678de3b18923eadf7a61f94d32ec611f0a3a5ab9fd5c7ab2a0901f1dca5f68c559c8dc55a6bbc3392a952d48444c883c1794d40812a7fba805472c18cabc68e042eb288b761bf51ada2f12b132299e64f08c2a820dc3c32955f50a61c7db0c1fadd5c0e5708fe969eac8fad01c3a80bf27e8f3329e69b9221f2238b3265ec8e53be93a8e659ee09e2fdc60113bfbcf041791bd451d3de827403ec7a362fc31dc2b903b99e3d48fd3ad4ef71617caea783f09b74be6dce9349dc7254cc10f386bc66faeab977ec45d118add36ef511073b4332ff0b9a1403f74677941970eb9595c2087b07115aa6711659769a3d3553e29f721b132d1617f3e83d5213ad08775afb6c22d6a979e61644a8210e16d607aa0bc2fcf6372558c8a51df6ce97ab5ccb28d909927215f7578672ef9885c937c9c2caff99c52c228ee31827fe540dec96c343212d8fbc5136da2e60556a70715f1a9bdff38decdfc758f27c81eacac10bc127b3d1d8ddc8107262bdf1b05c57a549764e6779ab31a219a620e61d6e99f65a6fee54ed525e0497088f31f3ec9bb54c8c585f7761ebcc83bb272bb6be9ed80b74d23cfc67f4cae62b8a9f439c783f8a74a0ec0052459eff4ccb07b9f36de62cfa553d45b4bd7d62cabb71bc780e570f72800b5cc1cebf9de69cd15d78771584292db95b05269417362f147776feed16e83578146a24e13bf04f19c5ddaf58ae72eacd90fd0039abcc9136519053a736f542c47b25de07d43040efc390a05294423790abd4613502f4330f7f7a2bba1a7098597629a3a76ddde33a8597a95502a1bdd96d40662812611e1c926f29aa29d4af599cc8eb3e15f220929104daa22945d02bba8b9e01c58987c04f0c4f6b8e06e209e0594b1122ccaae798d8e4fd3f3f941aac89da557ecec385ec2a1793e1f6c9b49c3059657f8a329397bcd4b7db3213c6b66748abfeb74cb3db7c2d43bba44101d57f365f7b84997c2cfa26c666a7bbfd85c93921a8bb55e324ecc57270f0a1bc900cfb97f53457687b9eb6b08e4bf2ce94b0b19ea41ee3f018dc5343b1667deda30b78d1886e2691a1879bc1e50f0b51ff427168e613fd454e5d5a0d4e069e56f510c332bbdbb82b2cf199789a220391a129a0b1e9c492169e6010ae867a157c1c497959e4d47ae08b124ae0ffc4420d7a62a4681989e217d43ce927e3d3cf395478782530ddcb1d01fcea7c61fa4928756953fa4951c891d00c69a62f6a253ce6cb7d4d55435d485693ded1a8587f9e15ba10049cab04fa9b6a1051eeb04b29b61fb8825da9f1861df90572b4a4cdda98bc6d58b928937d933a4e772b0397396bf138237b5a958b3883e6ffc8d0bb86999ad387b6587f9f042ee7a44d26a4e0bd6511715fb5541c50086bcf22c79e884ee42b838f6fad33f4c3cc3f2c13c2bb1b72d18f5e814cc8f4ad8e95c26b67f761c11a3ef8a68f1274124bd5e9b34147dde02a9d64d071e9ac63e0c3d958ad199d237913c9bda21afe3095bd53aabeae224a2e37a0c38ee6afdc283ae9fdc06d7e74c82b9ae8cf78eb2a1d826503a62987fcdcaf1dbe96277ec200481411cd34ab93c58f47a74a3765f0445ec7af655153319c23ce0fe7ebef4927ba3378445035b98f7eada5010a45ad9a507460c654d605c8d20f524561e1aa4f64817937dcb6cc723911a4b476f8bd4eaf28b5ec42bfd1ab0bad3f70734c3f5a62e6971927745a31bf93bd5901be120f48862b3ecf75488a9e9f1f6b3a2a42656f059c1e07aeec700f4f54283ea05f8ce51cc6530096da33960c9d1d6e8563cc046775630f9cb09b2c64dbf2d6627a89458e8d0c28a37f1f1893aa3547e4a98ff9b280bb3691cbd0d75b34d1fb9feb4715aa80a191c5eef1e73506f0899d6022aff587b567b337bbd338d2ec1e881d85010d1c40fb3888b6893fc866900c97744b8869c0e146cfb7860cfac726e55e7f0bfabf0f670d49f7bda07252ee8ae9efb1751aaa08e36cbccdb7072c80532e47333a62226308e0e12439b2748645848629bc7e2e81dbfd7445e64a0bf3f0650d2c3827ae2a10484b38b529464d99a63ff884a4748ca0db2d6b3c9b3d682dd7360af1da33a4ccd87809f540f2626316a297b45ca454c752a67ee12b3759721151d348aa97a1d07e41bc385479435dec8d4c1adc6d845318e968f10b8cb04a498c54e3e9dd7b4d3c9e56f9533dabe3f75ac993db10fe59de552a02cd77059d4f436dc199bf0efcd529006d9a78d73b90b492cd6c438ee7ffd77f0ca660e0086b130e238b6da2d847df7ddf0117f70b58761935b8105867bc7335d15de3922352b59b15089a673c1d4107ac41d7429f34230e5ee12e23e610534afe9eb5e5378f0f3bc506500a5302ad506b4c5ca7469b5dd70987bf357eee43c6c4c43f358bd716e3078c7f4e5b49eab2a3bb108bbd8877e424f1fcb109b6762987eb4c4a72ef13f5ee80907d860ed69bdcfad71326c09bbf21b2fceace380c04444d34cf96db2d8681fdca853ebc65321cc9dcde7ef3115bf7ea641f2a318cb9f4fbf167e3ca9be7a9d7b72ac0c52436a3da6fc41eb1d7f0c38417d646ea7979c315a9cfd057990eb3c851bd3905913f1e246da0b14a1f1b45660a183da6321273e39d134b0121434aab2557a9306fee170a3568830d5af5e89963d324377a9cbc2ba8b9b30fbda58976c4de6fba90fb0fa3eae8d577bf0167e8ebf94c32e50084b401bd3977ad0edc23124726ca2bc18560d518cd33f9f3c2c2a65febc86be024a3420d203fadc6d8d76c322012539f9b870f4ef3512502dbcde175abfcec26d954c5a3b38b34058b0c544ed7be888fcd575e8c5fb3cf5410ef89b533927476cb2a016ac09b4aabeb1a146c5e91e07d715a960b2fa2892168c31f058e7577547be2d6f527367997a097291536c1f0dc9625cfe52a62582634bfadad4aed469bbd8984f25ba16e1c5f00c49b4eae93e023b0bfb6d1c37a99bb173df18ba4d44e5c9a78adbe51243b6cab2115897314d41a137e440f842715d2ac83d0686b43765b411ffabe92b06ed2166f59094202b5acc63fa7d98b0030831fcd7479d6a25977f21e2d69db9b64453b4f5fcf211ba360087a53e03dd3431e2b1d3952b65ee7a56a62c8dbb5a70b09a67f21d4be4f2861855fe8bd4ee7ef9899a9c391ee78e139f89c81a3cf159bcee41b6acd4e8ace712c0eeec72260935304746d0e25355bbf860f111cf8325aa3cbca18ab598d20e63e31c4f79c1d39e8f4c4173dab4a207b0003ee228dbfe46bd991ae681f38583935d327e1ff0c727a6a242cbad6a6250cf7679a2fb9e3c528f50e37d137ff051873b36a9dedf2cd2a5872613bb7c5ca63127e37788eb3e71b0558f03b4bfd966c7a315e02e07c1f84abe2b818fa95513b60bd6dec921c52931e0cd4ecda8a75b812342ac2ba788e99e04ae759928bd28edd85885a5770db028717a3e5143c73c7dd03c386a5375d24972a8e4fa1cc16ffd3427cf4fb265f05f98b648ed07669147310a93b58696381b2a8e38340853de29bf4dfd08c08b3e1728942cba4d0efa740aca6e8fa6822e11a790116e94e9d354f4b8e08e9128790f02969e6f1281c96c9983ebb72df9fec1c0a19879a93523872d8d12411eca995eb97bf9b414f1af8d94d491c86e02eaafb6360c667d823b0ecde80b7e1222e3562e9ae985fc0e1e38fbad7aaab19f23c708da43d85c1646b948e51899a7e019bb3caeabc594ce4004943456ea693cb9466e86f03fadbe2a5a7e3858c8b78a480371cdf12e98c9999df05985fb2d08251c23fa92a34bfa81f5edc1dac251d4491622b6dd2148d8767c77dfc7462d5f2bdae7d751026432ec7a49605747a933e94637dc8dc6f70dc35dc0a3501f8c57ca7a0f28b3b1a06c870dc0ea9afce0efa16ba940299cad18a47c81514fa1815cd4c3cb76bc67eb9b95a3a2681052741aab644e82197944db8a0e3c5d9c4a200a982050cfab6e97243376f714e9cd9591a23dc7e040a81ef67ff24fb6589ac0ab3996f461dbeca49013e00dbf3a1998ed6524cdb0efa88e514f9198954e7b1a3d440db7b60f53d7dfbd1389c131d7f6d88ed874dc3a0b32b565ce1c6ed56c8d1bdbfb8bb903ef27f58f258ea9f0454d35241ceded93600defde48805cb9625791f71b8539d49c55121c6377b50ffea2c437e6051e123629683e412860bcdf30d7327c5d7a5064361239a72b6e78f88b2baaab4b9d790b9538183ae0f113987a3e35874c4151664f4958695a69f41ccbf09ad7d43f968729f727ba6db76f5fd3d95bcf5a1d11e78c3dd5269061","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
