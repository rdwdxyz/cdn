<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d88115ceceeec368b85080d9811ca86b9b68193ef9088ed9a4aad5e8fe4ed93298191f20e46287a9cda285468f62f513412bcba676f58e21f8a1a388407dd2efbb9fdffa36b8c99fc4be568fd93c2f06d208757b50a9cf46b2e10e37a2d3ab40696fd20817a495528dab902174c0fe05b4e7f81823285a2c4dfccd028426e743e285aad4c86e1f4b906e820f686d94cb4efce7930d1ce8fad9a820c7df6ecbde3f7325a6f829536d32ec1077b068f5564fdf7f5c78c6ef5deae4d012d13d3515cb312b088a0cc23d2dd388959a71a566d650daff209613a2b24af797125bf03719227ea7b33cfa2dbcb25307d0d5864ec7c82fe3c15c7e45de56d31791140cb1bcd9ee0c6057895142938ee77372d028f1401693cf5ec0f94ae8c337f63d0051684dbd0663458c320f606905e78c2e730c5eacf79205f05f7171948c3e1b11e5888d302b6ab59a8919df4590cd6761afe2955b47ddf76217efbcef9538766efb612b4c88f9285ce88fbaeed877f9efbf4d99dcb4c54f18b1dd396735d0ffeec3631a9a12224c0433e097cff66891766863aa7206669869dbbc26c067f043daa668d15a3da0af0b28fefa9729e080ea0bf64eb9c7d3051b2a2691e9b891078c9ea0870e40620c4fc2ee4f8b78287bf5d9fa417c51c0f5adad2b61f5aacbfa01c8cba2d6816ac128f3406c0a3441168abc986219c17068950984f80c39cc9f622a5a44e484092022f690ae0f2bf78314c26c778cb127a4a30f8dae4108a6d67bc5d7e627b59df55916294640d723f830e816fd79e0353ac41c93ffb365efc91e12b547347e6a450ffb550669cd8af276d746d8b3ecf3db18d9c309e1a37e96892f54d5dec9e2040355adfa3924e6b8951409a12fd35d7e5b353062dff49b75ce43687adb03b6554280cdf4e91f53dd339fe59003337fb1cdb336cb3ef360708a7f2c5f9d970e34249ebe0fc1fc2963cc5433bef8b272459f9f7e1fe4c667f95c837a67c80d069fbf4a70b231d852a2503ce42b11e523ff6ba49b04a82588ecb466a4d3ea35850c5c31fc16545af657ba451b20c42e45adc9ff822976b121bcc280178c98b7d57b2743868683cd2a5e1022d03773c80f0b8eed05dbb005edd820397a13ae8fcfaf90e0306c2fe0c1e47240d71ec41e3971ee9f7d2497c5ac25d9f289b73930d9b659365c44a0070cbf680649e8bb86abe938952a446dd865a51af11c314d295a9a0df6240f989616087ae376128a4480cc55a843899a270e25776bdbccc093b67999419831440a5d32e9923df845f5e8df6f6229bb476105e5bc5640b823edb9937800c568c78197fee005c89590203abc77cab649070a75ba90256de4ba87a4032a7a232a6432ec25db5656166c5b78ea37b06c930d1b3c2fa856a4145f10c2de716c03e830561217f1601bc10e0402aa31b273139231487caefe99f7e0f56d057471cc35265dcff170ab642478fabf4cc275208a4ee4a6d7b8491111d39f9b72109bfc3800e9680508eee08f23a7eaee7edfb6d43e31a8cb1c6db8f6f8ebddb7a51c8adcef6df4a02e0d57f9363fb3af2a92f8d7221e2c8171587cb820685e5d7f4859993c85a2308602e159620b33c34c0519e33f909e88a258653c4eb31f15716fac401e3d21f1ba35de95513278e9845db5839962e2a176f8b0bccb1ae06389ff4a7271ceadcdf7cb2e6bb3db49d5d0f81ac8240c67562562bcd22977eeeb9e138ece1fef9fe4e692cd54f94a1c68b1666238b2b5ca661e8d1938b334742723faa23c094dfe60b8fc7ec07d2c1f87e13650ca5b2583e4ced42a11d2e4b1793f36b81678ed7685cbff6b8e4eae5e11078868ea1c1c543deabccde2dc93698471ace845be55584a0f01bd603fb6db4b9783fc2051d4de60db77bec89ef0cfb5c459647280537788622f46cd9e0965fdea945022d078d0f9516d731f604e29a33adcd9cbaaefdeb3062edca8d7c063022b35b655644d36bfd66dfe44485b8650f03a9af6dd06e9e20c84d6c3574f34a0c6bd581d1b84bdce3625b3e70bebce11c9475b1f6adb66469425ac79e3ea8eab91c17c1a286bb5998eb5bd087a9c9232e56a377f6f2a9175095b66a7b924094621b21fa8e07101a57d272ff75611a57c194e792c50665b5ab2349c5919542757f51500cc84136095b29d221b40f001e9ee818e3586175648b38912655f2721a69faac80dc7a9eb9ef1b521de93ca21e415ac5b6d777cd6f47f62ad3584ab887eb5b6c0ecdca89fdf4b5228ae67cdeb92f30d49119cc6d57dbf939cebe8d9728001240447616444493f9268303460e7d629c9448b344c7127f4a77a44d4a156e68490881cdaae64cf652d0265da31e7a7ee04ab7364ce0ca65a310f20dcf014a591fa83094e68dcd7be71569f92900526974db59f173d975728e48491cc3f051aee03aaf8074cbbf9cd53cb8917b64a08dbcc0ba6b6f831cac6dc80acc2a35eb97cf653e5cc7bb35a86eb3368467706b7cbcc5571981ab5f860c792939849288f35e2fa610fcc9235f5a3d05047adf537807afcb14f6af7e454bad7acedcf9c652da7ddfb742cb866fee7dfc9a3e7830587d3fe3d476486b0c1b3e7d19437390ae6b8651ce40d3273a51b85e1d700ef1212e444664fd7e550bfdb08b0b43a593abe441f81bfec385f2f38036f97c7f686f4053fb107535e508363670682a63dbdac026d7d662d1623cc09264965b36e3acb4f80d8e1c4b152665bf80534c281b0cb1435779693ee07c0c8f4450b09c77530268a79c13c4354a761fd84109f9537002b0f500310adaff66c4f4d8851db60bfefa6ec9a4cfd3bbea5ef10752ddd16d2bfaec1ce8edd6f3e49f1b1236f136346bc0a5b2f1a097f035528b6562ebb3944d12bb68f31e425c40e25ace47ec5441c344e85d11f0ba8d1f58fccc466a460b6f9c2d151c019ac29308cf29d68100699fb309760819b2660903476f2cc66e448afe7861e9e1d4d1c27212bbd8376e53062593ace63568f873ac519984ec0f5bdf85c84abecc38f8a51ea48f1ee24c4217f995dcce641c3c18e546385e0c7a0c1410669a36a891eff3506ea06deb603a28d8c8f62aef5225854ff79820f1f0e530093b90350cccc619424ba9c690202adbc687872db50aa88d74e0508b0de38c67c7c8f20756c6bbcf7b9552e3b025cef87f2568943368f80dd1625dc12315f9669d03c1045c1c034c9a630e57350a1dff839fad9c50abc4fdbca222e1e39ec0f47bf780bf19b225c46e6103aa2619d6866342fc71b31cde01c32dd2cc86b74d5d807091980a70f215b545a83504b0e04e5e871993f443231159114dc64c117f00111e14db4cdccf88ad6594b55aaa9c0ac9c725ea6d96e2fad6e1436e5f45f073f1e1776df9b08869220252702ad923e04ef412de9d50d0da9c71ffbf2484a5d52ff9181070567b9520d81cc4d71b18e3c584ad83a6c885439410e3d099a0311db6bf09097c9e11279f1023c3e1ec5e052f0f0def908eac9ce619ee4e555fb7229f792145d4bf74bff21eb1d60bd7697086a126fe647269ba3c5a6ad2ad50ce9921ab00b833c744f0b123a33b805a609f9a7fcfd1f072419e0ef73c7f4b243ce2d2a517c24fed1da86969eb3e8ceea94ad3bc66bacf726b40f9aae91bcf048f3a56bc9600f08220f4ffe33bd183275307cc7837a775ae2e6c0c48f78384bba68cbec243625f8b5b68ecb1b5a116541471b02a3fc06b670796c5a6ae6e31006b37845804b1b52c8c39c61953c965b85c781f919191342ccbcd8d6b3ed7f58c75822e3b3db0b8dc7e38109b03821ed653eb60aa5ac614445465b7926e5c8c3d35fbc7a746f9a0315d062410506317610614158e7ad16c031f5fc842da544ec90e53d69e43db179b34065e4aba508641e052111efcec697c1428ee3699ed9ec89deaae95a0629c1d500610a562c67e0fd9b6cb1782bcd7d116800303100b74281751e87d84a44c647396a06364e1c8cd1d5e3708376c4ec93a34088de8deea0f98963f87d01faa73c00c4b941ce05db4fe94c1f353f32a7906edd6870d88658e8d5fdfa1bd5184613ce74a4889d93b4b6c9372b834e03903a90680b21e4365226bd7331d05133ed1d74ba71eb4651887fb9e9211b45a557ead32d5be4fa49e1d9d82f1ff8912c1e3d9a92699808272bd1d8118c43d1724620d9378a0b9a6b3a176d802d0572a6cb2cee45e8775ba841fd1ef59e154bb8241c5f5c54e792eb0ab8f480826553219ccf76bec30968e19bb34bca2d5f0134a2f073e7aea1f1e791be871c956cab4d735f4fd5ee6d81f567e3f858694a57199bf241536a9301813c22af659d7b75e43dbe406e47f6ffca68baf913f65aaf84e3087534bc72d1477fb1cbcffac62486b460d48ec01b399d5916d1d23310bc9f47f001588b3bf88df0421e3a862ed39310822526af75ae0dad6b0216268c2e22737d4fc9623836401016a9c366c90b2043ebadd13b1c92023b7f3a8f4cd0f691ed0ac82f646d7777155cbcf4510878ff134999bd71c94f28798d8d623316e203c317dac64bc89408cd3dfb2919f9868131f527c2052943381448fe33b7e1e62379fd7b5bc088de14355b3cfdf054e831a22410cf24994d334dba343f146d0142fd9addc79f708884b10d4c3f3540c5b94b3ee2b42634e6ed33659b9f11e4e07d41ffd742e89d62f0c3045cbd881bb5d3d80c292fac8ea40a5a2c8b19a8ba67d26eb2df4deb48c26cebde61794236e5b8d7058f287082358f6288b4157c87c137981881c3cd22f71cd5130d76379b6033a5d4a7198bc54b9ef0a135e4bb6149d799b3eb6dd63863b38818f59fd368b80c48a98ef81be0aa37c6a555076193f46263f384935c753165326fa3ddc40ed4d1b053a1e70e8b93355fdc00cbf9339030f097dd5bee614d23851ac7ee1043950d0b23eed0f2c305f57af40cc7461a37d4ea006a8e82eb53a7c1233f1f5c4cb75690c7910005c6f929a3b44e7b5aa6eb2dee57a4bd80f662ee0c29129d568ce7a323077e2f4ebbc6adb1ed857c4422fbe4e89cf9a839213a5785c4e2ec03b49fcca4d837b4e32b66c466abd3e8288ad7a7cbf1b1917f8cb86c1f9f0bf570392b4e34846f241bec490ef007eeb078f13a7cfd751c3cf9491421e06f456060f5ea1aa137a2ba4c0696c84e8944fed912612466ff094d285cb40cda6e48fe17976ab42476430970de80e3940536860a6c40aba010c6c8df2beb544c207c9208d9b25cd0076dd3cc7cf4c6a5ce94c0b5b4605ea04e07d85d23d6baf82596d3eb3d792a3174d2d228d0365f306633af409caab1df3e66c8dd85a9e4b8783af583aa7d5e0623b8b3c0e276f0c16e9a8fc9bc0837b825b9f4e55217332ddf3c053a9025b6cb3b6ce9e32496b21e5ee03c4f7f6555f5e0dd7dea0cc9683c7579a77d7d8a435e4ea9e4cdb38060d7037df23ffc692d68b16b781149a725633221b309492c21336a61407495327fd7b7c1ba8f3411926d2284268b0f26d23a67e3cdc2356cdc134eddf91b01e4b2d951ec070962f1d7b39af80555eec7b2451463c83fc89c8c1e6dfd622af49c2532b83ac945d707bfc63dffcae2c7c99d12c0b9b897fa40e55365199d7d7ff01159c5482d0aa2f661b37d8c4e3fc5dfec6a711c3f06e449b35ac444ae85456d68bd9c25a5816cfe9570b39e0b124229389a47abf1fff5e63b0680c7c67f96e097f30c16b21ffcb2190efceaa665f476302f352a8ad9e787e76a7d9e8eae4a2f793afa66c549de345c29af3f478e132add0ec26f92b4aab5dbe218838808bd102bd140d4fa981816bed99e1736eb7914a1f768d860684bb8c3b31e082e02509def163e5851581940977268d1940f887a77d960ac5c1db88d7a692d3d1e0b960b9cad751cdd679a6131c5272fbd30a8e39fd35e179fb992effa6ffa778fbbcc1492d03fa436248f65bf193a84cf602bb6b10b15be3ef6d4c62fa3bbc1887eb6291ec4a6229bd2015376aba69035b36878325567f772558b241e26b731ea0be6f295749c5c014eef385ad5fdcb0754e668c3e8df1149a31f5aada05bb78366248e2d368bee82b672d08019ddc9cb1007d16517e75502f43f6c9b38c0569ead946e18bdbe9074da44c6e869a0d56bf04adef7fa7531b6767311b60b8d0b419af10fbe74650552758d9fa9daa17a8456986cf55906cfe6de01f7821bec7ad3b16718d659f04ed84047ab9eb4f05b95a586fbff111a0f50260d1c6f5805288a8f6e5b6de611bef723ef64b5f0d34e8eddf4166d25c3e11dc21cb23cfc59bfd0eff2d875244975768121ee75b5f5ffcbbdd1e3c66906e71b0d684c8cc87af0a4d8195bd58065426b712d74c8c1cb1a9827b6d6479bf84471f8f4d15451124dbd1deaa3f0b05a9e02f070e2f7c55a174fef8851533ec6409813122595e3f42eb33025ac86bb014864c6fac464f22d289d5ea4ff009e26895c452bb3120ae41258732dfa065e3bd89be3c75981fab5ca3bf00dd030f833ff01d1b9fadf0d45f164bc79a6a21068e6d6ef76fccc57d5da146e29b6f84a5d7dabdc3ae96ecdbce9458a48cf5687bdbdf510f7b00c9249c58ed1609124de73352ea18376dd2914b8c0bec30bd24d3caa19a0a30d97327224267e0f7610f6a2ff633c1dc368dae116018b63aa9f6f714ab6a89c7df4237e26968f7ec5267a582145c744b45d2ff1ce3b0ae804474f2d67b05659bc215f65e6184b3a3ff05fc944f888a85f81d0773acf151abd293d2b1e568b298bd678649f53bfb479c6a12d243eda9895405e0ac4e51a2dfb99f17bc9c1b428b66f63c37513a3f580d07e8cfc78d9a58df03b7cb032091c049b34d74a88813279bdb1fdd4e1a9e935e7c89d8176693b13d634506aeda7d6a9689e68779ceb518098c7399306fe1060c10cc2e227380e9f4c19268f2de2b8d1b4ad83d517a801b4a2ef690cd93c2b46e0760e6825fc705db525a75f1a60181620197b021ddfe9fda8e63d8ec77e0e1e9fca63e2ca6b870deb1a9f9e623231915a33929af9b01f0bf30124c0fe0315eb212f7c6813a41c7dcb8cffb2137265330f57d5af12ca7dce80f44c0260a8e21a88d0fb9ea17cfff271914e702a849d2694ada315b50a687375bee0dd889f496309f72fa5ba293942599122b3c37dd8c5c59d5a3770e70d72b5e939fc26850c35fa3591d833f1ed23f5ccd2f807ea015e9b948fbffb648646911fce9581558e7e9b5f2e45e3d6e5192c05fc60fea14490ca0801b558b779ef0ed7c65def24f1300dbc67c13991e76ee04c4df0acda90985db5c2392571e154b2ac9dbc77408da685c5496af4a4b508854b93178c599138b67db858e205df419b312e4aacc6268502a032cde89bb681db9e3fc4404822bacdf3716265981fb04e87ba1d1c851a1246e0ec160ce45e8ced14931ecd22256e59c58c1ccd374cd355a151fdcfdb381e63d8a58ec989ee5ca0e3968a65c9366a5aa0a955c52f52f8ce8a8993bd0c80f918d274fffa10814fa49c3aa0af395844752354ee2c1612e3cf405e864c1d1cd767bfe8724c5ee9e6e35f65c634bfbde930557d94a3b7daa10fbf14274204a3c365f4522854465af257fcf789644992812c4ad4ce9f0e5d84528e49244494d9fbd00c05d55bdbcf2296f135253b34733c4351c49da8c9a8b21ef8b2be4964af5b999955f0d49aed64e1efed2e57aa81936454c225f05182b9b75e98d6628c02b629493b9925f4e6963f45854213345769801e84ee3bad42eb53f974dd1fd68a2b4cec42aefba6add8da3de079d1313a9821fa87410a65836334923132f5cc1d894bc8581c249f0f86ec5734b4c14c4ffda6233c29848e600decf55691b81af049e2bc3f96ae57be04753314fd9395eaf1c8031e12a251b58c7fde2c31ce76ff0c6c95f2b5f822ebc07a8064d984289d7c4d696d495151d4257f40aa081e8cd7728f69d399042ecb902fc01489987538bab6a1e109b8559d9bb17ea52ae08481cb5fa82a16db38b0cffb18e1d5a22804d3aa857065f10636bdafa5ba96f4928bff48eae25587979330af7e233fb2deb012c6ac8ed0003a9309fefd08cf217df68fa3696ba4de860c5525213841e9e8b471bbf3c1f766de6b1c5758c53e225dc0007b33819ce1aa01dfe7fac8cfc7b8379eb640045e3915d33f7e74eecf5370f60006f4976abe42e8a3f9ef61a6c15f41dc29348dd202f3823d0bef2b79a4bdf8e1b6e80b2743d6f7e14410342e4d8a3f77efd1bdbe875e3fdcc460341b4a58fb7eb71b1b7354976f90ed57a4e9079e8bc0a5e4f8e52cdc5d44136576b4a889954645d4eb734e37e5a653584cf247923c1589c8e4d2d9a38a8d500865f01df9dea28d72f6ba485916c2c074f56f76b2bea9bca3fc51a3ba3434b159d04aff2f0494a813ab6638b7eae19a2b2adddd2816f1f7417b416e5632f446380983557946a3c63f7c6ca2b55d02c58a4647954cf8dee69f745449fbb46875960dbd27cd08928b4b800b2494e269feb37ce1a6cef888e92cbe34e481e08a05a2ecbfd755e81b613a7d7f1b855b9697912136ff9b3c99f707c4c5c272b38b30b9444d7d949c7735a309de6dad0b1f72ba89d8c615f3464d5d77815e0f2421c375aa6f7a845fc3edfd0e00fe8834530fc2fd145f58ff10bcfbee59f1e9ccbcf52c630771a83b990026af0fa0e67e73a005012f1152fcdae072b7530f54f82f852d8a2fdbd3651d74bf7a5bdec361d64875934dce6fdc12b1363fae7394a4adbe48a905d46574255c3124d05f3b3a5172d0bdd9aa305a8a6bd16159a477dabc376f62a1e10d804731cd2749977bf83bbbbac215c16588b7010e0625e471582e1f48b6beef09bcd75b735cde5a2fef2f45674aaab871a4abfcf224315fbbc89a430971607f44557f5fe5a397ac442791cc77aeedb93c3708e7cd2a8bff74f6338662d71c977818ab53eb815c1e79617d330a25041a5e23aafbec47e8f461a7daff02ea5c9d53f00ef3c37123b60938a044f08cadb67e4bf7de7283366259d061bd682d4e43ac14877b5e8cedc771cb081827bc1aa35690e73306a28608dce35e483c94d9c58d17d53a7047c8becc57c0cd946023a54b3ed2ad3dd9b82528c1477592d6df3e30be03bcb0d2be62830cddef7679895bb66a9f3726c0d0ec57c43e9813cab7112193d7851312a27c3a63c49b7aa9e7839760880626d6a4b81cee7bcaf668a71355b8a5c9780d94405133d013503ad551fd039a4175031b05b8b8dc2c6d925b895dd9a9439e9237e7d617f758ee36efacfe939d01043ad6efb8873193744bbc8cae187a8da0cd4950e31bc57a32b7d2d6946d656b90a124f08144a87c266294d6655129d4485588d2bf1207ee01a75a93e633d4211064ad927b8cfb72b1e868e4532ce04f46d35b3e129deafd2531f6bf8c21b609be85800bf14e0208cb0cf812ec47b63dfaa452ee9521fb3f862007353b38b851013695ae4d858ec06b50ca6d95d7f2043f74f64496845c79a49370254fdd55e43ea3ceb920b53c895bec2ed2b17b76481a9bf697879811cfdf1e61a105cf9e695f89be3bbbcc9319ec8080f8595d16ab127a85864c79f8110ef80b816974c4e35294659041bfe4191bbf16cf2729d2181a01e5b53e7735ba9abf5971ba19589ef9aec5dbd58f7eb7897c73d2f167be0696126fd65bd921e3e054a399a49c67c67c5fe24d8ff934eba8871fb93352132c659b6cfd5dbf951c094960d68eb298c6877bf977faeb1dbb2476455fc14c5c2dc2328f3f75c88484592d0bbbd874c749b3d6c084283c19ee23a5f590e0590893ff182b010f9bc003b1cce1fae1707077ed304eabddd622c0bbb7d71c9ead9f25c2aa77daff1564d47581a82684d7d2996700da116c94cde7a21bf3ae04c17de49af59a0f20d4232bc59161fda0c253e3debb0f12464e66c0311c1cc2365b7413aeb167b800c47b8bb42340742cf5f9060d6f04e0d82d93b9889ed079361c3b324ad2eea301fe0765deb84099e21ba0e2d983b2abb563f8df6f02607c83f46269c35479fb086b9db42697bf2b94f53d5b5e6a7c9aa35ff73000bd8363646c97de54da730ceef30c350a68539f14db50a82afdfec4c10834b74363aaa01240712682f23a28cd694f5470da061ce69bcf257d3f9f85eda480836e496fe16b0d217817716b8e802b20f234facd817ebb30f7747dd7c90d992cb7c17b6d10c593f0545bea52644d14a30b02965f98e7219d06115b649e676e1d12d44b83c6afe10df104d62cefc32cabbd5d7c835fa8bd6c61929511fe62721bf7bccb120c0b8d4df1a0603985d75b23ce62cda29461bfc6f78a24e9a899001a103957652d126d05b21312d019003789a17ebe4602d9c0826d0964e331bff0ab2ae487195270aca237311595ca22e2729a434f828c73da55116fdff47e8f24567d5890e8d6ad7f638ffdaddf2e8328087666974aa97afc4b7080f70698b10b6174995790d603a3572341070af569e7c8e34e966b2821f3c260d43335de8d50c1066030cf96f8b63c95e8be4a39a7a2140f092d7445f30e65f45cdd20013223b9a49f5812a4108f2b57598e67c8beb5b4f72679d3c76ef5bd77b55e4aa4870307dacca9ed94f2f4176c65fbe34ff115d7541025c3284d96612691d6d473d0792d2a823dbfb1269ed71771054c24f0d5e53d356177470b171a67d138f3bd416959bd75464df16c03c36b0b65272d2c21058a164aebaeb076468ea4428281a377e801bfe7ef5d48e80df62ebf859e05721566606e59fc61e1fd1cc623d032fd15e2d95aa2c1efcd6c58eebcb2565aa5e78d6aa99cbd7d46e7aa79f68bc7665ace96b854d5e38016ed63795087af3e77f219626b2a45b0b5850f94bbc9e088e1621a7de148c64f16ca2b4bee4b30dbe291662edddcd958e4063fa219c02ddef067e21b2bd7c83f57068ce407b00502927dbad098821fa8b7fa376e4094b0d9f15ff27e7db9de7723b6ebbfebd275886b182e3b7cbd1db26bba4908113f7dea64b2a35b2674f67b409f42066649dbcbba5a53f60e9555aa65c4b064e9e06fd1342c7eb4ed59ed94365d48bbb3aede0e2db5fef0dde17b320c3682bed89cf8bf60cbe99fd12fefa5532d6d75c32c7a4d2f7dc23e7357c2bc746b3e70d8d6de29738be68688cb0e9e76990955b3b3d67ea4a6ee642ffc9ddb87bbf1645f3944c8f45fba3c594d2f9f5407f538ee56daa7b43d95215d6dcba9970273d79a4725c0df5183df100f7d5114703cd7fbbc038a7a75e0146e7ba3768b8929138d3ff227343567a402f1247b8c63163cd820fc2282dfd74597267f3d0b758e4a44ee79f5e71a001941e8b9390c5bb212fa510cd5c22eb90dc3c05da9cd60f807ba4f821b4a382a2e46ba26f7c0eb9d96d637312072e29f6441aa5db6155b64f1e6ef974e395e257c9576249d0859861220c4323f8f95f04ab11d243aa8b4da2f96ab73afa39a8646abf213ddbd8cf4215321a17ea2a141fc5d8ef840425cb45430d3bf7309ec38d60f9faad7c9c0fdce6620a93a01a0720cc995c9246dbc31bc0f180176ffc3b7b74afee7f5c2442029439d665b95368552c2407842fd300c2e395802d8dfca3d59af9eec939baed4ab0101849915fd0108fa19248eecb9bc742dc6addeef45f8d3d82f5415af88b2dcad91ea167b5e1d1cc9cc792f52b557f67dff28a028ac699ac981aff64741d88a31a3c6750f3a16fe71383716bff72e2eb1fef0fff8e7aa2cadd9ec57fefc9af742a3fcf7f5404acbb378db2a487215fded312d005beb0b67e1b6ef00d92f2459b97100069e35e27fb942d3625e4b0ef691dee8f97826d2aece8126408c33402edcfd7f171b52d71bdfcaa8c4d02a0979342d0237a118ac689d0b6aa47eccd776291155971b607dd08381d8b2180576c74d414db9d5663ad3786e5e08105d29762606fccac68ee4d71a9909d2a4a8de604a175ece05a4b47e29b3a396ce5b1e3a353238ea28c53e926b3af8f7cf2cbf54cf5a70e703a8dee335ed5d19dfc05dfb556b865613047404c2940de6c5e033e9584861bcdf4e0a03dc87a5c6659c71b537b55b9168a1300c4dbf22779c2ad81a76d2d3968e2b1d79736653beb4456a50f013394945afb7ba2ff3b2bb9f0fc8c0c6fa66b2ecab0f8883f04e51a51b66d763a6aadb749947e8b5ae928870820bf86aec9ee81bee1159563ecc045bdf1df4b6aaa54d69564e5685c71bfc13b174b9e9d5de686eb6092cf2731309bd0c024f57ea2916127cd11a3546727a6e7e76ada6b5b611378da511b1e68f373bb35a8fd2b5ae2ea75095bb10edcc5b6a50ee3e2a96d3cb5ba3a77134df685b8f897ac178240cf359061d213a8f882dc422ee61e0afe4c5de7db8c7b349981617a7718d192013f10463e7c2bd65b0b64e9494591bbfad8ade8640432dab40f4133974edbafc7584fa1167f30d37662c540ab897b1e11cd5e5e58b85973c29b924e683eb310100473e72ca7bd52e42ce1b738358628288ba8dfa3c49a8a1d1c9fa3ff1e8271719174e55067d40a2da5c433e5262a359ec66d6ff08678d140b928fd2ebdbae03a25674c16d6962858c8ae30755bd64667b7a8791f4b33ce61d17101941f59910e4477cce499e929affee3c7385ad3b22caff490acc62b7da6f73e4552bb7194c8fe097d3786bb9d00783230f844e42d24069ba994dc79d84e116753cabf86fe32a44524de99f22df4acbbb6c6f67417dd519af0a3adb27de2b4c5102342dc42d8cb26b6716918dbd6d99a62a1acc26a20a0982d82987012951d283e703fc8e4a9efc26b8666faedea35b7a464764d7d116a8a64237d027a9a26f5186109785f083508a72d49b7f0d4c9f74347a7fad00e66d7e336b0b044abd470d1f99c855da63a4d2c2443f64d090654e43c2599f525c1cf2304fde6dc736e08fdcd2b7718be54666647e5493047780513cf47b6a8ecfb1b742f214177519fd2faba35404a54f9c759b2a4692a22d967d3e92f058fd3a75eed42f4d3649cb519683a9992a532761f0228b35d9fb88d3277c3e8e8bc78c2b1d4f562363be0a8e8b4692db13efdcd18fa89bb4bcf855bec2a2cc51c283e04c5a872628ba4f55d123e517e119321d085d442bb137b4160c183b7f65c19e88f0dc2175cdf819cb736db6fcd11fe490102d636fe75b85b65015630558142b2c42132af52b065a6a8506a8dcbf996d800727d62a89d1da81a6eeaedb6ea58daa89c4b065a41aa7d59900fe44cc1eda9ea1c68f9c63e1f2a22f51e676540294deb093f0725cbe28275ca568f457786e2e3d8e30b16b421fa7bd3791c916a5ba08ba56b8e4ba0d2bcaa06909bc5812cafa2fac3d453de18df92fb9678c8424f4b6ccea3a69e97db2c7365c93def4be5916feab319c740c0190ef3269f6eda2e4c0141598e38cd807f3d340593fcd99c8d0f623c32b4ab3de0ee26ce55818c7aa78c24ddc9c4dad0526e57aa293d4ca19a36cabe070c8a4922702669e48ead769b45ed774f3faefb2d5000d351676e0b3bb9d01814daac67e1e364d838b2d54ddcdbbe1c199fec6d38422b889d37ad62e2ada4b9a0324ba124e8c51813916e8d35ca803091fa03a54d12111b6fde560a0acdbcf43ff8d0f56e37eb035adf983f631bd341fff2cead46e7430fedd0a7415393800ee99efab9b664783074d3329145f6ed01d779cdfff503cea25e0aae9895e2c48042c17b91bb1e61a51fe2d45b847c144a88d5d1fd1b3827a45486a64a264074bc48a0bfbaa7e9140f56ff7c917918600d0ae52743a207e90ebe7d53790ef0a30b19f32abdb892aa4ec30568eb8d9c3aadd3eada5afad18036250dfb0b3bed5ba647f0211e7f765f451a9c159b033f3f7118c8a194e8b889724cbd52a478b69f46289317a3479c18d34b51ada46d9fd793f01193f8b83c8f1f9126cfd3d163139b9b0bec30c2603e68fb73f9b81df0f4d39e9bd5afbe474cfd220886798d18911548a93babffc106c0c42e809fa760ceb1c5d61a8c95104bddc8e5f00ab5b1e2eb54035f6d60e06ea65398484e8c4907afdc928f545180dbc27eca4dc27d5916dc9f942d6cda8262c87d8e7f18c389fb468aed0ea731ec2d05838a3f9f2034c7778231558d626dc23bb87d1e2320a01a4ba2019ca4e7ebc412d4da8efa4bbcead173cfecef25df8f5426c19ffa5a8dff3a724823c00f17773821396e346517fe85185bfaecb86ed26e2e13398fd37bb47636d3b60a8ad7e7ba48b39f5afda419be269e1a44896a1d25955b509d7a525f4fe05c69dd2207062ed70d9010a24507e58a784396928a962947cd804edc041fc6941c00eefa1693e7b424dd984c2769739b92befbbcb112fcd702412e733c9efa5663de9d98b203f9db709a425edef87578bcae54097498bbf08abaddd61efc0803dd88dc93fc3a27e892ec7423296944a18d4ea01b87744025d361433c9d5ea300fe8d35cc24e5cfd4f69e7584770ed345e854ea0c25c4e322c77a3e1a6b3dc14f355c45bad19a87cba095d68da8b7d1580f34a26ba65093878e69ba2e3df4109bc5a077d7c6673a6d7ef3bc3972f9844ea64b4c783aa5b1359c7b8fa084cb2661c5d953bf44f9b8108acb3039baa5358f4509fcc90702c1de572b3aa9a92f8ee9899d140b9e7dff14f821718eb6baa60860d5320461e670ac14912dd8ea7e38dfa023e7e84f1d5b9ff7bb44a7f8b47f31b2a7eb3e2200060ec0a076d08dfa74a862d28b791c57643746b48aa46e81a364ff0c19ad410b8c450e56fe03dfdbf81624e9b4c33ea3760e70ea9e65af518b60be26e6ab171ddfa60adc08ae27cd5d9fd3e75144bc61abc268877f1c424eac738c3bbd33f4bc9d86db7821f5bd316f807642721e2f864caca7562e53ff218dcc1d5f02a3f68aff5407343ce788f8129f3502c85dd84f3eba23925586e1630858c9c26ba7b0ccaa05720f1ad69eafbb047f404d725626a55dcf9c2474fe19f3ff089ace88ba29b7771041ea08ae77f29675f3b989f4a1982ff666a4ce106dffab1473d9ca791b84b04ecb8cd373529d6b089b172bbd907f165cdfa3dbc216b11effc53c1e5dda82d507d6e9dda91acdec13a84570b475ba2b47ff8f361f022af02e2f2613b97ee429577a436e49a31c6b24210baa66165e60149c648fd75a853d5923732d50b69b65dfcd32f6b6a314d9e31af93c16e6521d77b204242a466bd5cd0e74443d84d1336c70352725e5549dbe5972c3a5990d55583a5335c4d24c6dec1f795d418313f2313739dd537ce540597cd7c8f815babe5d1d3b0877b0971f0ebe35184540cac9dc5c1af30d768707ba249859c370c0c528887406f439bdc2091432313e1e3c5e2177eeda49ea8c3545dc413cfe1e31473028122497060b935a74e81916b6f3a698f7e0a5027978daeef024817b16f199d11fbb9821ac05ba99acf0af9f141b0f231c0506972c2cf19c2207b15e8f2a80d3836940fa417154018bd1b758fc296fcb88dc140990d1c42f75942f0ab8df3cd4ac34175dd929573172ce4fe05f10f2ece2b3fb94da7ec8d99baf82d17f6d128b8861b26401e0ee49fe0d806a2ff5794c4c8575ef5fcc6003055d34a8755f1334cab8f6d6322c84bfd210f9ea7412a5aa35e79117f0464e7cb24341c95e3e941fe5b5815454e41b1b2613a50a271236725e8e95c7300ebb20409e5d0a76fc4dc72720475e3dd554ff9079736b8469d2491c35b3b0b0c4ac2413f93818b3c76a5593c8067af96aabc9a6a6a2acd17cd8179f56108dae67a73005c073952baadea499709d7c5401caf8c3d59f6557947984d7abb22457c269ebd4be407c16f927a4f648372252d0fd7632eda0d23d19c292326bd5674ecee46d36556c95e0091e610f8a2c3a201da2cb0560e89499af79e960dd2b6306daa66b598173d2b6aebf091e27aee6e116f747a69b030eb40894fe282ab41440bffbe207e072b263de002ced406760f9d47e27a113c5080a6618b1806e47831ef85ed8712d06b68618e64e35d37b0070dde108361d5da4a8323279e422ec9feadaaa179284f51a9053aab3c700e387cef3e0fe1da364f31a5981275f325b2dc41f2e5bdae82437403db3c9c2bb36162d8568a292a173f3fd3e778d68d0fefa29f28da3f4cbda7a7a2c703e0003c4aae558b28e9e042eed4f8ef82f89c925a58c40579a1b13f6c2c183797b03f08ea3704a1a739ded544898bf08626eecc334204e964febe8d482a6059305518872c5f83273a25bb50509b0969819afdfe2b09c615eed0c33ae8d0cb56133952473083b1e52f269a685f7da6a8439404124c26307c81e1bfed084b045a3e0ad26533256fdabd0a70a748339cb3ada496bb664d3577207c94f8f7332d28f589f5fa9b2fd627515ae305f3a5abd58b01a66e50b830bae1ecb1df66f9417d15022b66e3b7d3c86c9a33930acf3643be23d1cf5e0081e042fd5f86dbe0165ec1f002c65ed564a119ab41c6a2237e826df11ab54aa6b3768af9cf708941fc2359ec7f9d06fadffe485096febec1619a4cc1b413949204e5cea25966d0fb47bfa9738a542cdbdefd72ff6c85066db6c0d9673c7a2e5e60c4824e1f0854b4986035a4c59e93e3bb5230f4e5330f8fef687145519a47819af84a1e353a48ccc53198c2061a03f8334f3337557aff56cfb714d221d1729286086b03456a1a97bb30433904504521d83210aacb30068cc76bb00c3e046c1ace71f2d0743cb129d5b2255b4aa624c767dae1a5e06f52d3fd82e31ebcc8fd54eb163db0766602f30e8cbdbfc86aa0dfb8da1dae9f8456685b178ba30554df4af05dcceabb948bc026c716a94a5c87fbdcf114ea412e795b4dd3108a2a7257c3c6eee0fbcdcc31478d54ed492e0bb2e0e63d5aea84b2c67ab1783d1220e785a49b413741493513b5b838dbd0360c82506852657cc6305ac74e73398ea7e78a739c1e280f9065b18ab61a1de345946efd63562da14d9db23220f3fd396f610e6a91cc8c0b6f7a747ca7564c0391a0b8cf6fcbcbca91c378d241bc528497a1d03e3b6e50b16ff16454091426b3f708406e6edf7640589108fa95dc0d248183a4605e26e55d2146789cd2fb580ab4c07587cad9d87fc41406e4e879f5b1b8451b74184b7fb3ab2f2edcabe29884fe333f551fcd29134c318dd269e624c6c72cfd5edddf4dd43b1651d9f105a47db4e9330143e23ff77dec7f6d35afa37c9aaa3bc1a237b43c5c7391721021d915a81505756644e908eb4b1a7d015dd2133abb3145aa18e5a3bd194cfc46480470f9c1cc3fd2669ea45b93fce992a2b29121123987afe927b3296c4d8694e988dbf9f0be0a33bbace9498423f19b183f6c40878e24d885d6b4aefc04e53157c71f3bb6d6ab63525e6601f323e8641b13e5d7c1f48da557407536be223de694e783319709fdcd5e4109d4f00106594acdfb3adacc607a26e1a8edb381e6c65ca2f68bb5a8d86bd4fd5c4b201402a385395383613da9b36e8b9499103afc6711c7f49257ec392b1bb424fad82aa180b1ce1167c75a2a7fcd6c1cfd7df154c820cbad3caf0f115f546b6fc5390a8d15a845c75366c6e85a20ff2c5df822a8bee75eae835c46045145beb72feb224a0cd14375f91226e6addf2637370567ab59ad149ebbb39e1511938e450d855483ce4c1bf453fcb9850ac53502a966f8100b1867c99f9b27a4a4baff9f696c51ebb5d51f0fcceb8aafb0a87bfbf664b997347d86970220dfdb777470a0b5f2e1c673721d87e8e49f84dab8d60d1d1cef8fed99cf850f70a6f4904d9d031d0040a0ea26807eb1c16610921f1aceb87ec2f3c8bd7628bed41be3b44d1aa0e759f4d31c45aac61a1adccf52ce157b1af49d7247ce576a88e280bb791e3343eba96b2dfe1c55817bf5ba30d66b5b1cab9a99db2c3403ea7a92e202f09deb92dd9d1f4e8e2b5e18a9bc9e1623b5db1d3aa1d183e77116b307b406c7afbc39c0bed7d2376762366073120da33bbbfb73263f7aaee514aa4f2156e43cc93dda429b461038","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
