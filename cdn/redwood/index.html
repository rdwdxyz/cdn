<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"decad58025475fd8bad2b7ead67c7233c2547c287b7a64feb09eceac3eae970c66eee5c5072485c1a684b5adc544cfa4bddf4db1f1d3d78825fca74ad42b8758e916176fbfaa2b8e7563e2e304486f76a1bd2994672c76e46c274ef771bda537c5e34e5c184d35c04678deeb11190ff7dbe764ce35d0a71dac329719aab3b10278e315f7bdb000a9fd784aa90db60ea67086169ff267fc00b89ece6bdeef650ab34b79955fa342ff7652a357f3a44726e49cdf173009a5e8904c0758ed379871c99bea2208b797e2145d134a7168f11a71436c9e677df2e551eda9352e934e1082d9339c6909d951134856523489dc23d50450971cdb1f8d451fe64e633efb5e7f9d816740c11f6a0c0bea8d84caab740e84cf412a8b62d0b375780385b64af3588e9b0c8df81a205eb8e1baf9ec8f1819f51b0a5a70dddf24dc5254b5e731fd7cade5a56621fa18a89c4be2b7fc7cbaaebc1dc0e13093be1e6142c369ff793cdaa99bd4f29a8657edfa399fce7d031365906b6e9dec59b9a8171431f976e972dd0f384f20069985ad067fb97baeb2541c93bbe934a62e4f8cddae93291323e46169cb7683a836bbd7bc0cf9a7a1393149eed2d7786d3ca3376f70123fdfae13e1e77ccd17c5a9e00f17b2778ccedb50f8cb5276fa59daf29ce405f4b20b384de63bbe740a36b6a7c4fb63cda6f4cadda0f77969e4f2b7df4546d40f530635d931fb10ae446e0041f39581c6dce51b5adab3b1aa633658b8576835270fcc51ddd1465fe86f8803388996d5b12bb50f6ee4a3cabddab241f098d453e3901545a1d3af791610a8128e4d523b9fb6db064eeb3e950c87aeacd999bd47e9fb5b011ba21dca4c5406710d7d9720124f4d710f3079734a23bc1d6c27c27e541091a40ca49e1eef3ef47f9af82181e86536461a0e241d4048f2e32cec2374738cc430fa3bb2b39e9d73d0d34a31c6b57c6a0af17bb8e53ae35fd0e9069364131d0aefcfa4c4928578ecfc3e1c625b047965847b761ec9c387d88e4071c8d969a01da2e67bde7c31ebb0c25574dd095005d6625b0069b03b2263dd27e4a46441a20b99b3e607dbb2bff090f0f58c2c890ec3bfb14b5d9eec588fcb0eb561051bae81c4d68f628b0deed1886376e715452c3554a91953f57109c1c6a6f3b06e16e7f94f40885c5c8109c7004e124e15e8f8fea7e0b2fb2c8de80fef84912d1c637dc2f1f28dd9fdff207273cf0860ce494a78991d5e7cf518a366ee6c5ad4839a86d62593d5280a8e1d5161bdf490b37e82ba4b8b9ac0919bd522a53f1712831ee6e06e373ad69d99c393a05bad8ee0ab00b02d7bb76ad16d29a50100d477a8a50a6d846e8e9d03265e2718ba26b32b31de9e6de1468b1707c9aea6fefda2178915c312f9ab4ae51f9110ba7bdc21bcfe8687dc413b3d6c895ba0109961013fc7db05a4e9c2a6683a9b1014e1346dbb10bc7b0d9acb41c2cea5f798df02c8b01c30174045d4f8a07eb0034c9bef42a3b60718dc0d11321c31996faaf9159b32a019e3a89ea5de6eb6209e118fdca28cceacc7b6b1db6441bde8d06bf16a6639539f0d74f1b6d06745b787e17bc9196db35a0c62b2bdb0678d9cde89654ad856d2f46e61a7e2ea23bdd93660f416f821fcf535219aa02521d6dc9566c12fffef31ad4caae507367f14df8c46b4d36ed3a633cc13a238f992631c538d6e80e6771e3d70cfd18ad9db7291d4e9fa8c5f99a51cc5662f4a815554fdf432b2451485cb00b074369eda4489bcc633778069cb4b28e8cbb611fae5defc6568c2d162a82e0116c9496fe69fee53b18c376306dd5dd96e787d8d0a1da07653b19b9e2af0187f65b810eb99a535b50e0807fdd50e22cadcbf2238a3c925d2461589222a809dd1cd17d438a2261693550dd4f7bfc87b1965723c37552ab71c1a6d7fba077924d84f20b6ddac6b74f306c30d66ee7ef2e1cc6b584a5ac2bcb1ac25ee39b5377bad4fd3b31c29dce0362ed401b4db41945d3283d201a13b5057d13f1a6283d1a69aee5b9f8a8cf51fbcb630bf996bba233888d61ef4d287ea264ed1907e597f3997454ef330cc84529a86ec36167840a23d1125a2c6e63ec9c45a060eef4f3ac24f1bdada92e545350272035da8471ce981cafdf9a77ab0cda89ed1e5d2009f8b8aaf68a38f3156e9137055519728e63244e2c4f9663e2e2be1396fce0351ce75b9bf1ece67366bfdace561dac5372d185ffed16cf8c9f2e24f7791940299dcb853b3fff2164a36e6dcf2d5ed3298f2a38c406f0121a66b58546572098c42433cecb2f029518b1c9b955c61a408f6a14c9d20549a3ea196a2a3e3f7ae2bf29df4970b95ef9bae28ba18d48326759de2eb191108eb98e4d9d1fb448d8d1bec0b86202df14e5193be39b7ae9f05997ac2e26df5a938eda6bd1bd0a3c745219d13e4567fe64b6ed8df5ed5c6407a078f6e7342ab2f12c05e4314c84d2bdd18e70676b7e6cb4c332ad5d256a65f4fc7e0ae6e378b271ab9ced7497acba25ee7b650fcd5dab9dcb3e0a8eb5fe9bb4e8c08d8ceebb22cd4e58509ae32329d97e41d0dfb027ce7d78dab22ef1d270a691b65fc4f184d313ed46c40ec49e16a3f481bf5a6dbcc7ce0cb9f922d2b9ce11a4791957bb8b99db94d737cc00da60df23d7833008827db26ab62cf949d8582abeac8444199a75cb5a1d81a203218692dc81ee7369659d72de0e37b9394ae13963fb9fac41bfc5bc5442023b4e708021f3da0f610821ff4156ba539e160548a3f07fbced488eef6131b0b69efb68b199088b411f17145effb4e93e6de3a0a47f0e74d382deea46279ca8b84e83bed3882d80cd9b2b2202aaec2ae25aabe69e84af82053b387830515963092728967570f12ef39eb350e6e4e833a52a0fcb080e69b11bdd9d2bdac0c4c02f25a6c61c2d36db42f07bb41895cdc3a37a1f1af0d2bad26c31f4fe5effc1de93e8f3fdb507707eb779fc70aaff9d513b53103b74da42eb8b5c2aabb6c62085d235fe1e9d377c68403c7311b5c1417667727abfc13f415581c6e8d578c40e78667190f51c108da1ef46a51b5ac4315a60f59980df4c682088fba6c423b3187152013ff0d19edef04872c447fdc640d4dc0eea2d55be1616caf20f8b59c815987e5b45fa1b542e2f3be34dee0e31cb73f54eab19355bd8ebc2ec9acc34490099deeb1ff907e98a77832389102f0c565c259c2ae86c30a1e70850b920ad4ab35198243b29be38038c28fdc2fb75fce17235a24a40bf605e198ef67f4a880aa1e6425e83a56a458d5a2dace3bfc5c0742bd01ab77f23dbee017c00066e2dac6e77562c72400902554eacc0b5d2a8127674082f04c8177c5aa3e0622be8920e4412d40c94d3814bff36bec6066a4bec5f7454e45da6c0e91d143596b00d61fd011d29c1c53315f2cc6a97a01d0806067186d3b3692b466a9ca785e21b504de0d01ec4839a384a1526950438e456763a7d79009b4c3739cfadc87fb54a79f9c7e43faff4edabb734f198475f1ef2e2629ead3298c9d10aa6a7ed3d8dc26a1c684ce0b67c26a8fa255cade3326c0bc5d6bccb59585a0187ca863a6e9d6d1422b5b8dc2695307b16a5c47f4d50e13f7805db724ad2067ac333af6a0c69d9dfc7a837db1098898d450091560a47a57d37bd64c520e10ba079c53e2ace5afdaed6c64635c76d8617ca23c0f83146d5e37d64411434e76a7a9bfa147f3fbc01f5b4f303a2007c0bd0ee6af6fc605016abd11df87c359a2d0b3588551400a91821c2756006956c4c2dd453f8a2be326ab991929908323dc24641f516b7674fcb6ccec0c1f1062d914c3114c60380225f58b93f60605764c28e7384c23d942049f5c17a614749f5e0355a1919c8ea425a2aafe7132e145139e3863ad46bf41e7e50f98f4f3216a5fe501e91d2ee963b1c8f64a481a77c5de12bb1f54f19036779d2343f6865988d2f2f75158864269729578f477e660b7ec59b728365d8a66880299c064d50bb24330c2ad066eadb22965ccd389ee92235240953c3e6c2b5082e63f2b629b3eef7499a61e16318c8459ee2b123ebf5d0ed7a9eeaeb1180442214100b9ce71e639abac1a0e7020924b03139ff0475acb234fa243aee6937b39d6709bdd4f5ca37b1eb082e78098bdc798a78945f5e0002ca7f8e87828ada06c4a5b1172f9ec48f65a0fba762b1f2227116df9ddbed78a27487134760047f82efc64b08812d403b66574da743aa5e8776b7bcead0dd273e31449250648bc51ab953564750d409394598ff5c87b442491389056c658e25a71133468bdeda366a5b9a31db7179d28669a1b2b8d554b0f5dbe8b869f6b6a0f78a9b105d97f461372122f6ab0d561fbe443446721cf1f79743471fdd2ae9f416796626b7c195b584a59252d5cffc16f60dd74f413a4b11323c27d13e115e2e47f27ffd4b37edfc6e1ed2a9a0d428b7f7321fd31aad7bcb6aff3294de2dccdec084342e8cc5dcf2cb1a4b9b0201821b82f123122a1212c9891c6aa56351ee1350444d4a1160dcdd7a442c3d444be8fb9a9d521798f48e51b88d34791156f32e022442317a379444470b9527449670da0938dcb4bb4b11761e2e9cc39d5c816759f394c48c909128ece2720c4fadafef9c291d7550c425b3fb64d9922d1a7153f59a6c35484942cfb803ce857688fccfe1803617e2785f3b3aa127b3d3139ff3b0c32aed413eab073e1c721df603effc5300ea6055906590c7dfb5727fae17cfe707c1672c6739236b36fdfc9b3d16bb575dbafca56be431885e52c579792f166ed3d166fc908c32b613e6334eaef5e2a492fc809a7d01e4e798e5844634ce6408c4240d08672a57468282d6a15479c2c9ba0bd82cd2a7c808d0881a459a6a8007f46a709f55e9e1c7f0f43971b129ba640cb1c77a39279c7409a38f1c3b85c96b25ede267b6dec76fc00449e6090712cd56cec7a479bcc599af2de723fcda1e9f79616f6f7a1ed5a0d78d6ed11b6440dcd66d6de3f7f67ae9b342e9b9e4e2ecd21ecff80a6f4028211aeb583bc62e4369c844b138379a43c7d3348320de1ad7b7350ec88fb0fae0cef4b6b6ff2789a69e8c862c54b8fb33e9635dcf0d7b88802d677296115564856a9a5b1f6bdbd5d456d75d6010b4fcc423e12cb94b2ee5020ffc1cf7883388b0f57c50fc0e932c6c2b83805aa1d1457d95389c668b748e4b915f9bac61acdaef31f691044563be7b365bf072fa396db82f9579dc5ada1d39e6c4decec8ba8738982ddb8e5c3dcc4d785f656f41969a6d8e30069820216fead3fd558200bee3a05c7079af834b7609de899885117ebecd5314c7020e3ae16358daded8d8bb94349d52e9bdcafa960b52a4535e0dd8dd52cc29fe05298830a72e5fbff3500c2a6a03f51a989447156069edf73e5f1a31a4b930cec711c290b98c627fde8ed310781509d9059cf35f824453fcd0ef0e40e7f42934472b00364f93a4cb15b5467485daa0f0b8c1789b435c64cba92a6d888ef0ac308bb5c65714693a91a6fc2f32320ce88a7fac62144ee162e375ac97dc4a0c36d95ff568424498e53785167bb7c564dd5a7247a6e310b71c9e50f9fc2c15c24c2299630088e6ebfcef7b73be8a8b1d1a8cb4ccaa93faaa2c810f1f50b6d90f5cf4fc9604bcdab9de81f8e9bd1841d9557385751fec1de7c4fa9ad74ea3946d32fe3a11fdcad7bfe8d163b30cac845ad2f9362369defa412351e14ee8123d4f2fc659c97afd62d274643898838fb25f8e848914fa951c26a876dadf3b4e0b4c9934f9a0d3e4a98e58cadc6858fc7bacb7262e4607f3efc79a0a62a7e36651c4e9973c5a2780e6f39d88f8f4e774b970532f549e5532f5e45fb5548bf58d0f5dae4a2bac421f674e3947032e34e446f5df79a0199f4d3d08f056d34d0fabebda4bb6fc83ce13460e02baa87d6d490f4cc7f395aa2fd9dd6dd8c33f3e954df6b751dd05b91ce9f3b2db2b7e24cd9a076dede9bb7ba9161e31c410b5358c2d3905d8d9c22073615aa4b839cd2334334ca869c938680dd38466bfc0d942df19a22a345964fb2d2dc846c6b3d1d8bd8e35ec33a66684e3f2d19dc8a20131d1cc0b9680efa69dfb652e7f799737d0c36bda83b6cca27cac80230fde8e92ef465e09bc5fdbc1c7fb88ecd1a43931086ce13e6fb6c63af900985fff41f5714641a0af25900a70d048a222900fda109ade765d6b5949984e29ee4d5779e92f37e3ca540cd941d38b83fe3076953e24060a14de765b832ef2e825f7b1c13ef7d60441f847e08999539e93a03f20f7897c2915cd0dbcb913185d18ffcfe9541d0a9971430f1d3a18413acc9eafa08ac0d3be4a0b99f57822fdb107b1ed17b5ef237c35903c01ae5c667c95ba1466c4afbd64d19edaa8b9e02c3ef3ab5f060691389f4abb7d98f2377076d9b4fbf6d6e370ae506585fd2ad408c16591e21e1e0be66f0e0461627d42248e19777984f3557600716a0fadfac2db01f4bc78bd09e22b6f9061b22351035715f0830a9da8fa6663bb27be4ecd899f59ab99f3007794489ad96c389fde5db1cb386d4624d83dd4774610d704334cad95caa3f29e56e30b54db001a61559d86b3c4b1edb43384c66c873f47f0299b3feeb96091611cce29e1b87b2e8b87a19800bba2365c6e514b149dc3cf2a786096142d85bf1bf0fda307b042b5bdfde347d5548973a8b5fd38305f334e91aee581abcd30fd2e182948774cb0eda6efd09dacbf0f229f1453ee0ab4c053b30f2b8384f5263662f9bef30aadfa31fd10ada348e7b13629e07bd5846f078421d2b5eaf0e04aed2932efb314a17dfcf51c641f2cdacb75992e4453d1923b5ca7a3af7f3e74acbda2c797f80b7d727ee51c0a9bc3b695bf815b2321e3bc0a0beca8371e87ece569ffc476f3c4a221765b0a08c43b9cadab832b0ea06ef7b42aeee6dbee375d92275d144e577a1fe945101136ca7c2aa527a02117a5c1868037a19e4114109d153765ba047ca4cad104d0b0ce78995422e5f70cb55915b2cba769705efb8ffa6ca207f56adc56e08a2496e646366d6570a3f4be603544be7a82cc7045745667d76eb0a7e0eeb400a15b867c7c73f9ab7ccf10a93b6adfb57235a1099fc8bd92f013ae6d21a82f0600ad901ff5efa4191be289ca3d6df3af86967d334b198ac2063f0d208b8d0c99ab0fe49122cae09b14db460b88941957f583a3c5f3891805e08c281566c96358f1065b6a395c840590d4faa49a74eae33a20a1b94d204e0b07ecd7f79ed1ee4baf7a222fcd2c786854eaf60b342c7ff43c94ba24f774fbd171141d2c3fef185cb7f69e1ca1595c5bb963c1c10fedb311f3c9c9eaa69216649c9f21690a6879ecc5919555bf16785f94b14c51338df62733eec067ffd47f36edde8b993add6dfa3f15c3e3b2a078a5f55a40771e937c4e534218df8640bf2cbf9784a4140dc17dcff25176566d5e97adbca86f568ae9f9a4d8c160fbf95540d58b083c895fcfaa6269f62a19a278218c46529a824be6adf1deaf72365d9f7c2fa11a483c9e23cd2bf6ccc3380b62e5cb913acea0b13ccf2b492dbec8c73ed9563d729c80c0183558c2ec088f3edc8b907e82c96391758cf4e48710475751bd84601442714310f3b6611d5f40a1d00ae78c4a7c14e8d2dc5420ecb3e895c0643e499b487cf8b37e71ee391077ad22c5cfd2b3e978f8cba27fc376fff1487985258b6b4ca2862239f195a8a2f78a582d6023c7e232e14a8177b6a05842cff156bb3d6c79f83ef8c0e4e357e83abe03f27958c6931d9dccbfb71bd6bfbd1fa8574fd2aa23aa43296ed3286533a0623c565179d9816a94e3a1a0d53838ed5ee6a9acf0ce1004e684f2db29f01fad3397979cd86e7c8e627183e010ab9a8870fd51623b26edec05a543f2dc74f225ff5df9910703ee84e1f9db93d584987b47b158ad23a756237e2c5db721ae01806aad7378c9363fa95d10462268d190441a9730ac53ef349cb6bc73f24a369e0997a4aaf59544805fbfe34336e5ce9f31893ffad91cc813e85e2fe80529957017131d940c1ec513c870d9b6811cf9f89158e6cc8745541a9dba8f0ab0adc2696a90fc8738e21e372a5d56f580fba07e8419da858b9f767e55a9ca56a49f43bfe48ef9c1b10f6a8a7f7dae979fbaee0b3a168e942f9a86c4df16d48d6e9fb7f10ab07167d46d98e5a8ec6783393a20bdfcb6b81fc6b1411dcd702d341d80f700d7af9977849309c80aeae1c13428a00087a468e326398fad0ca1c94949ba159e97dd65aa20535e2c14e733deb310e86889ac59caa92583aeb1aa0ca794c35a8ba4354fdc244e85c6024c42b74971cc9fa3d1e310c72b44db42bac7b75863b76d5987fdf55731fa07d31591731f0423167f61ab64475fd57dadfb5c2ee530b5529b9ded0f6a398d59f2ae0fdc76f9af2c0115d0a77ba029e027a5647dac60e76e0112d6885b874dd0197214d577ce00a7f0c764824f3a7cebfce82de3163adbcc474670726cdb06b1caa3c79068a2860e88c0d7e1623250d305368adcf05769145153f1e91433007324d6391d3ed656e2ab749bb112f4f78d61ec6c3585ed697d7bb530f2f2d2fc5e5fab56eaed152fbf9a3588f3d9a46093e4933502587eff1ccdc012763612815e07119460f82522ed24dd306eda9323f7ece09f562d712d19849d24e356504b3602f4c89e002005a4078e15a131c4761ae2e1ddfbac6a6264c801b074524c347cbf453fc633b5ffee408dc1c65839acac0b5039707585a4c57d4cd644a195a74f0499f52d068e5f7b9d064dee0717a16226db65f85ba698001d2d6257fc6b9850a96ac03798779e90396f4c1f6914f1b58fb40a0e3c4cacc59cb784ca12d6452d932defeb959d1f6624aa84c454d40893eb9a64e7b08346057d4d507f1987c5352821c37e1646b0b0ba61c55dc6db4fd00c03b62920ed208d2bec194bb9234b70b179c375720c0ed9b7bac8ac3fa34430b35aeeff0345f588889c530b4c9e5fb34c6fc918b3d7e3147a61c498c69bea408f10c6dd75a0eca4e8ba012d26eca894b87dc503d464dcc335ad6af2bdcc97c8132e7e46bbadfa0a8e131b760838bd978a7a7566d892d18f103deaacf5d8183da76ad86576ed6e48aaf76ccd42a2585fb1938258261af280c632d8e065b95233fb7ffc59a5a198ddeb9b361902e7467b6ecec285238e8609b957f2c3e70856502a87262e6fee464c28a6d598c8bf25c60ff356ffda46728fc17c6f137236ca783aad435010517a4c7fa829885f794374c151efc183075478cd4b09277756c9d0dea13ba0aec84d34f60523d17bc614a4b1e086092766f2601c933c76e255e8b2bdda72ef674aedb9a33c141c37cf6a2234456954e6a1a3f328ac7b8720674bd7e45708e8b6454d1433acb17fef936e5516eaf74c75d32e759c25f21cb40be1b9c538898f1be9fcb546157117ec993f497a8421a0b4524c5b538e716a470b267b41e9829e93b49eba82de48b8c4ce7b264e07e41b45424e243d190588040d5dd4c122d8db37e6bb27333c431c7815e2b5d9d3f0055d3865e8c9a3c7e6ece9cf47e991816d02727cfcffa1e9ad5e2342b296f61054153c343739b927a67fec086c329664e40edd46a126956f56ab62dfcab9ba09a169ee00dbd7745944f94f5dcd7752d2a8ed810101ca6ea8db9d8bb4e4e31d7c49e2f3ec4651fcc071d925486322e2b3a0adad009ef1d8d3d1c9cff38a95889c1f2bce3e5fb3bc7b761e80752a2fb123208ac033d1e096c212588773d1c92177c887c97ded41d7bf86c1128ad35f6cd7cca20f4a47bae689438dfe40b6b9eafd2922895d1450c5600e85c3824914972017e89757649506785522aed856cf6599bbece428e5cd303b2f1dfe9e0659a189d1cd3022ff7996c89b2ecc186912549a09e8c674f522167b5b6c5f3afa6b1b396d557b4981c406ec921dbb373cfbe2d094a5f2f109296a46542a6ca31ab27a25ecdaf74b5d38f8fe75df0f6cfe2e5da29fe7d7fc7a217ab2fc1fe618de3702c425180c036eb10d70af7f2bcae96bfad8e36db6310f7a351acc2470dc11f3c3d115d2db9d98f06d3cc8f1d6631f9940d3e7428a6aa7b76e5df3b463794b1444464a14e05b058647a24143fb4aecfe6e8cdbd612771a27b6a3bfe4bace4b39e11e31fa5fcc6d98498e27c9acf4abdfbb72628562760290df62df9540fe77f904c162092c79d36d4e74f09664e1a26f50c0634177a32b16f8101ea9e7ec129ce791f89126f8e5ef2cc831bd495527a6174430a59b5be54cd0768cb1da8e91110f0549afe2ec7f9c8312babb758c2c28d07ed3d493bd857d83a37a4b47476e7e8fcd6370ed5528d0dfb704e89f02e79d3d721e09928f1304233636db12863f4bd784a4faeebbb847786f9b561f3ccd3da4c7db03ce9fe7adcfa2976b97a8bf85a2393cfe96f2156f1221f2fcef8e2d286cf32a55a6f4814ff07004c4da068026c167cebaf7de5ece894e0bb75fe402377d9d451b6bbbc76007159d9d5b1c5fe666f3cdd8934650bae1b8d78ac8b8b03e74b20561180c9137cf1caa485699846ae3e6ff8adcd582b83ee591dc8d39a68a8cae1b22d4b5b840918decd63389fa3a990e4bbdf625a4ce2f344219ece94d8db98b5a6a5c4cffaa618e9338bb39714f9b471e0763188e285b68a0cc7deef48440fd702637245b135646f81def137494f13837b70251de9c27ec9c2a0f49a4c67fcbe2d23b6c2f005f922921a1f734229e22e9712e940179c8a8752e3ed043dc5a81721aa79119efe3bbdb474b3cae6d6d4d59612e1601043881b2f48edaeda2c3c056c14dac3d29873c0955ab6cbd8450d24e8194551cdb43fa2aafe5f0e5e98322d9318e1db236e5e72b53b5d5da2c1b5658027171385e02968b7ff502af661169a30fb613c6a1fb79e06bc3b711beab1f64e9b0894c83ea7343642403d4cbef0c7c31f6870b5f329966ac476278e1dab5831e572b29a869765f2295980b67430c399237b0ec296434a03c38b220a2083e73593a18179c54da148b426571b9de471021493ac6b46443fa582d06b288b7cbcaa97f4e5e5b508fce6930a46ca4a215bb94d5852f3ac1e58d4d3e1fd093a9f0df56686ddfac10e9692f8de0fcb69941de7cff91bccf3fdf616d9412e696dea60b1dff25463a50da2e5117c49fed12ba081b33f360c0637ec733fcf1675e5014be16c6344db01320c0715f0290aeb90ea2f8f820f6d14893e81a7e83a6b4d2c4cb1f45b0eab889f21ed69bce2b0b7797b72c464fb3400e95694532287112898262592e5a254d9bb65ba59fc46f346b1339d460c47c100a45dfb1731fe5f0bb788444db674b335089bb581e001131840f490000896de58f221f33f48f1cd037a1b104de63c6419fe23bfc5f9d5e10d51823d3e467a9b1000b81f05167e434345715a534cfa37f3310b3638b904583ce9362bfad9383b7dcf1973c451332e1b997b2adb426edad5908fe86b67560ca8ae6c72a331cfa17a01a0e070c1914298708addcd129157534c90edb8188c635c7d2574c9a0007142295adcbf41bddbd638343a8add2b544257d3f8b81b1177a1c2dd765758a1370ee6b463013274a9e391566683f449ab0216f7ffc3c8e9616bb4c7a32eb5bd1583490ffbe9b73af0b0f96b236d694ea301fb36de34cb06bd6830b01d58db5d80d3ecd034d5feb12126da0c778a8d6059d970b6f8b9a3f59cfbeff530eac86ae1ae346ee1ad62abba75869cccc9b02542b88c4e96be68e808623091b9004fb3309a219a0d82656ee879d6adca3a17704fe34c62e2f48113f1f09325951125db4f3f6cd72c09086519fba28a8dcb5a275d09f9e66638dc91ac3b986f6275d296809bba00601a035c899212d417f69e4723b198f0e60b255a2b5b975c54d22c0f671700443e135b9e1680f95d79ca490d4e197f72d645c32a9967e2a8e30a7934dac56de3bc6b9db8ac059ae01582df02baafa7e71851b7b6634e9e73730543359c44e4f37c7c35b031149fbf5d19e7269d84cb036537ef79592b87be9935cc907538c6adceb83b102f91c3703d674e7a85c2afcdd3f04a3d3d565c2937c3abf330065bad37b695fec90e3cbc18a25e2a91520cfb8fdc19f54897b514e7c9769583bc0d663d5787d874f784d66eb2ec50fb8dc290d51c593ccada5d1e7fb09ffa35bd7b2fcbdc488b121d3a47e947131ebe5674376e2e0eecda0a55518d60ff826bc8cc399760003c99dc91249d7039660e6f74a7678f6c0d7c5f7594aa4bf4f931bae5bbac868c203ff155e9ee6bc51ce03f695e0a640ea862f1b04aee4c28aa6ca89d4100980a70ec57df6d04eda8878ff77c665822c85350cd31519e761923df3e7ac9500ba6f91dfa4d2fbcfc6209102aefbba9a45bd0d3a6b4158f3489b843747ed584008b143618c9990ec010d3ed3be15e7240df0655ca0a64870c54979c17b92354e3336fc9aaa321728d2c201233a1350423c49ca874fe93a5810d980b3b872059cbe5e30ff1ad379ac71b797428582dc94e173ee392fcd8d8ed36af4c5abcb61fa28b78c7f40d14a5c4e19d1991e557d7f8312f761398439eb0f3c4a7a1952c81bb59f686035ea99bf1a285320ade9aebe93e601a22a4adc3714744b41176045385b906d7b16d1abe40b64658ad8661cf2804427a291defaad036fa91098fea493f0c5464cfc09fecd797e7f7c4d1bb216abd134a403fb13c0c887904790b5c78b6805ce83228c4d82786adf024c26410b1a219b5078be836bda7f17b9ab42ca176168dfd2a675e24af40fa472d03929f12572a8775e4c8612dc3b268fae960c253251f73769432af63a672158944cdab6ecf3f62d72b1dca9ccc754b61f4a3cd61278c74f8c054a399b5a38752dda4a56226b65182ae6dc773c704307ca8cf453664720afe818d76da5e6e86a08d60156f044104e2d9a66969099ef31fe2b5cf415b36052783cc85aa8ecb3690d8ade52a4f76635a1c5b9e38d5e893eb3ec4c8bdec604151120b4ab1f83f50b3e67ee294695fb7587f7d56e4e88a9c403ce9c7c7b20c97eb7ddc9c54e349f7cef3c2aeb6d39680e426c820cbd6b9a70e2c62267e27a20901cd5b0671cc3293eb965f73e16d6a17534ee78e4ea4985fac0414bb5373fdcb435326aed68a8d5b4fafbe93fdc03dbb2517614b21a8665f6a75186d6c470918eb62c4ca4cb0d03c61196970a8894afb448a95c41bd9cb6b317c824291d0c744e698a7df1d66c3bec3659f3c321b97d37a5c603f7362312a176c24d41f6855cf8a1b3e8bcf247c0b9c6927bef6dcd139bd7d07bab0994d8bc6929c78dfe70afe12efdbe3bff701916a58f90f59108f0483e4add4edc6dfab7f947d2bdece399765bef7071d6328dcaa2ecfabcac56be785170ad7c3fcb29431077a995a79a726fdbc902eaab2dbbfa9ff8f299060ecb335e2a0734518a6e8222e673deaabc6d7b6bdc19e644ff69c8ea45d13fb21479a96f55a6dc911fd61d827ad2cde9115ca7af7ace09f1f23524906ffba2d46dc57de46ffbe45f97a5b2fb03b1534e6c73f48c59ace4f4a5fefc3acc0a07c4bf136f591d5f32b265f05ae475f3afa98ad9dda5ea61c7e9a73b2eebffafa6244ef8b1e479325bbe7c2a1daedd05f15a9d8f46e8c737151fa9c1bddb708035959afd92aa3e08405ef30bd6ff3f53993d39c0cb5613ca75b81d94c88fd7f3a1697c47edb609f35126d8d52355b97bce510ca54b03b6de7e3ea87f4cbf90e9a9fd82d51be185af9e6b8fe121bcb377abd144139bfe08e087f9238c81c719ad6ee979f11fe9b2c3c486474facc14e351466c0a49cf3a9511703be56c16c18005518307cf69fe78767934c5bb712353d230797a2492dc9baf286ff7c40db0d5a297c3dae6b807a880806af98ee8a69a4636d9966cc9b08f35d93ac7f274707000e24677fbd0c4186255cc6fd71247fd281bbaf7820e7c567ef680a1e2c7686d14916e28e0f5363fd2caa80916fb188d24df3f3c8c65bdab988c86afa2f71e6ead67ab2e5787b13c3f392a3454cfcc9c43ffa1061b28ef1da467069d809612e749f3f0bcbf50b1bf19d87f720963db8d31841e5a6df7ac5294e36a703ef32d843fa4a808fbf3c1cd04bc44994758d8826bec47bec8576c3025837f8404bfe3f77ecef53589510362c069c1faa737139534ed611d5003e659efc2f465638a4d366c7fda624e86bed042879bab71b4649e5abfc51db5276ddf644a00251726975e0c3f791e04b2f3f0824aa7286e02417c192308cb0ccd0483b105311ad4e5910838e9addc318dbf4bf554c976fbfd04ce78cfb86395f3e3dc35b64b8866267d8b86a8dde49cd4b0d31261909473c900c1805aa924c612e84f7adc4f282fe59ad66fbd307d938d301e7021f766318a672e7d5125d3d12c5c78985d1b37430ee2e86fbaf2993816999d1a1aa4ad71affffbaa19be49f2a46209c2f51fdba315f949fdfff98ee60624512824dc926a5cc0478a840b1d5ac595f604af85d6f8ee7caf5e80eb6aeba10c5d7cfc669c560c8fdab443a1374364d61d8d16cf10f8f3d400bedd806e396042cb3e33fbeef0c968e0713ed2f7f6e3ba788622c8f206adb1f048ac1ddf9b1579a9948ca6ab7456e231fcff8a644fe486ec3af6c1214bd16f61951c8745ca3c0019df5dac481a53a1c8b8b484ecba55bb52708fe528b91e2fca7ccdc50e5ed5f0fa1b4d975e2c6eaca55c83ca2870fcce95d4f5a6e0d808016ad45fb2223e5cc5481b3e259d1bce9440869e0b68f3c891daacc2cc8d7f7f32b842954a5388c24481f9cc749fbba9796de67ca28262fb034d5681afb6368d356cc4f2610be7f38a56948bc02ccc313f10478c788ab1ed941be48713e577c4f443209505dcd80f0728f90e5d2de90bd44b7122f1058be23607b2869286c2925294cb669798492f7ecb558e9697c5ebfc74e20263b4cd5989176287d1babf8822fc906c8ae3b6fac50275f127dfb817b776aec37df7c59eea227d3e15cd2bc47f445f31c6ad64251706391015e9b2894c76499404628064d00cbd26831daab8d9536a906644386997f2a2ec7b33975717b96df562849822bc1ff4622d279d0e5c9d99198d70c600ff004a7bef2769b293f130ff30364233a2390573041c26ed1adb63db24444b7e5ba8aace58a63cbe6f36bf06fd37eb27f62754d62524448b658790ca2b92472a98071dfa42b754b9680ed0d37a2dd84a580c9ddc34e604e5b5825d9b5e53ab275a40fa41ec6be5a7e7f4f4e179d5e8aec076edb3a295643fbc122f97a129f0d243feb48b8c70b1ba1d49b732ce09b7edd8173e7ddd980e6b95d54dc0e8d443b82335578baa7364c60ceba4e89160e7d903b85f1f7a6da1692dae32b646156a91cf1b2f02990d2555d618a4244e17c16e4bae44a954e3c03472a39dd64cbef197c1eb41d187c373b2c32ff7796fbfe2da4a3690061a10fabdcdb85a339e8ba23dfd53263dd57137ffb46e168748c67fbcc026252ae7c2d70f9caa8144425774c37a2c954c875ac08dffb107accd472bd639f7d7eafca6d1b6590fbc2ab6752f0cd33fbc2d432446799a0bf8ba7ea459e6da5a3d054cbbe00b4f21126779f4440bbf67e61676ccaaac24224fdbd4417417f783136d2125013bebd8ce183add595496c95573478ba1184d04ad86c559c15183157394f3917145655291041240ec1eda8b550ff0f7af97dbf9bc47d6f6f807195377d3da795122008a3f148b4168d55f6eea4d3393b03692efdcba2c7a416698e81a3e130d4430dc3296c0b1d8e5774a4b2dcc0e4457dd9d83e44ad9a99ad1a5e74ca30e03e9f83a4c07eae80f54101649ec4291ded5a25b96dcb51c4a2618a32d28f7a22fa255b55b657fe53485adbade17c8cfefa0964d2a74f5fc098dc3fa926ceb4973302a7c23eb932b09be870bfb6fbc2810ea56dbab74ee8e5ba3e7f1bd80a102bc685fb675801a39ce75b0bc721b5eaf91fbb4a8a376355520b33451a9ea770719517c56e79787b459d0fca272868ca2d225106191338078d8568d5ae2a438ca79826865bbbf1cc8e389323fe2abdae6938ba9babd37f02146e0ee9c0a85b156ce91eee122852765548612010dc52b02707ff02fb1ff6997722bff206a5290d0cc0a400fcc1679a3ae1f450ec0d7b54cacda1aa41933c9ede9c4f524330fe68eaf98909151acacde456cf42949175a26009fdc182aa1a618c35ac89b89080fcbdd8809eb8d08ccfe67e19675b744fa6e4473f2812c39aa704fbd44de034c85a52340594ae61e1a6bceb5866e014459013a97581d6bba1c2e11c13217340565e31d02f39f4f19b0394e8dd7a5fcf36339045339697f32b0892998153e838bc2a81e311ba6bbecedd14dc03e7f52e1888d55e7a336e3f77404bbe00eb6f037e4eb46b2b6ad8e6309de78a5b2ddba821eb3952e828b2bb82580e5770032d6effa2124d7855f316ac671608ad734ff00e617e0cb8ae2f1b55330bd18e63b9bf8d2d18044ab414acc1bcf3adb55ca1ad60f1dce63267084af3cbfce3ae581820aa85b8f4db796843f2aac1742d6ae13213ca37e2322afde6edef5896b1f711127e2a3e693f620af3e8d9af8987952d8cc2cb13690e6b8f6d431a2ae36ee255134d244fcafbf76e46402cfd112ba063624d3d19b3c0fe5db17c4f53c9b19eb0ddbc12385719c1bd2d8464b8c7b24ed29d2592ea594fc12255f497e49884ee4ce78538d7ac6a083bea44f5146f6479b8eb8972f3997a92de8db8803499ceef4ed57a74d5b7a86f6957cbb7cd9b3cc9d8d67ffd99b6ab104c21c9e8b2f264a13dc7c4f5632f70a4aa5e5012be67b1b2bf0958e3eaf14e9b2d659a63a7d04433008f91f8ac4cf969f29c1d3f9b9b05473a30857250135fb4d954271792a63487069276ba303b23c5e4ea27c99c773b1b1c81dc0f8e4f3d8e349f43eddd301317e72f82f8b77c895a6a1374fc998468b30d3a2d703bf17800877b96caad21bf56b171f9caf99e140b67d2330ef7bebdd6754d3732aa710ac2e5db7bc99a96ea4f208546fb95e7ff0ce5e0d19d7e4eee98cce15cac598a33263138a139fce4b0102f5790c0caee21c6ff9340be932032d5eeabc350ae95c179fc2de9f2bb2f96c6749b8caa162560d2e5684a438a59796365e1130bdda85f82ed570aec75deeccb584d79fd9566e55d8a0bcf133843f9f2abe523c7dbb6ba57058509419d8ec3c25986319c3d888200fe0cdbde6876dfa3fb906edcde49f307ef2ad526cbfb777374546b77784e84e34bb9105d975874175e078ee79332317a7014c8a09d53ed11ae4b781709baf39f5372b7c91c3bcfecafc11f8087bf0d391e0b6c77e154d4795c5d372be4a4a90f04dccb28beb64ba03aad141fd507ad28ea65c3eb1a1dc6e2431bad91e38995db1a6e7f33b68b9487ba76f992e5e5a4f2b77cfcb515f51c9978a817c048afc0ff761282caf7f7eb656b32b8f79dd6bffb208963ab42df511c5258edfb12fbb458d6d1762279c94a6013ada694304c190e695bdc30d2151217ed816bf176b3352a2ddb7b0a36d7a0f6e03679494b2430a437f2c68d9c5e7cfbb0b044bb45e9ba4367b75d274bb7507ce9f56e11345607be89033a81392ba5fd6216e1010e5164e898e06925d0467663c738f4a0ff6d42efb5c9634fd54af6f783fda2106fa2352e1a89bf59f47e632b15054fc1ec8c08e92c97178dd318d510f96351f975478312264122ef8e390406beee39ee58054e97132d8ebf3f40fa48dcc75274deb205959ed77ab0cdb530dcbbd162a8e29f6d67d153cf58384d84a8bcdb9105064e536c9eedb35b3782723d4a88c5c91a183ba36aeb7d25e27c004e9c6813c5d2cdd64250e57ae0543e569a595446c589805367b92453bcb92fdff74e8ce9a6fb8b2471b7ed3e28b67102fa2cd7931151c81cf965fb5fe29d998e25e25d3d049619fb6850c0724a394b82e88bdf4ca1b19b90db9ed0d0d194a1190912bef78cde3e64dd8d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
