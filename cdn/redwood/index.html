<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5692b3ec644bda9708e08ec24616da0eaa98447ee7aae3b53f107ab5b814e94536118c706ecc58eaa0c0d012de333d32373bed283b5b3be43256fee1fed038f28134d5b46c5f2e78b311b27c164be19e4dd01789960bd7f5108ef23583c3ba85e07a73f90ed3cf0ee169432f58b17b3968df340df9914cea879bdfecdfd08740b7331e945134f5bb3d8789c9c5f9b5e0223ca582c31156933de024e6a8cf573f9a5e21c538972db21bda28d9a30796d67271fc2129ec9b5b09b019f5213f2b5c5699ce65b33aed05fb755b159a1462aaea2a0523bd8cb0f1eb79f02ae2a5f5d2d536e3139f870661dac60eed24f165fc15215c735cf0380c024968a22001cce6d661cfe394280e6137664765603307c6432218b171cf46406a36b895f189ae71e2ff24278fdb8c1370faf88428e5fa0b8b26302cb52860bf4ce9ca07fcef22ae76b9bee577f62d7e2fce46b53bf69e3c67780b55e47b9a8ea614dedaef10aa3712f3aa018f2e356adb345627de179def4f02abde62de81f5559c465736024772849a08670c41d620b68ed7e91a919adc83a632fc68c815c491e5f4cc4205e176974c1c427039050b906b1d275c4cd593edb3e92276e88ed0270bd823a86009c858776b84bb96eb1dedbb1fda74260b1713298bfb06fb1f9f3d23230d9101bfae6df17af7233c57ca9b16b03a8b88e1835f2205946ba6c42d475d6f382f125bb94e6e42c8bbe44351ae44db607a73bef293ecb345436a63638e906ba22821d2156499d465d638b5f8c0dadeaf636d48dfd96fcc373212e1988861bfcbe8640bec4d0be481665c88af3269e0aef650ce4209c92dc5b3d6bd2eaece31d4eaa055777d20c0a2016719d60842737bb8f5584db0c0b681577c86add3234de4c9feb7ac10816bf7c2f553e02d55331f484b98a4bb752b286e3e0a6e30acc9d4aa2edf05c01ad5c174ae65c00e7d4eaab9ab26e3a18e2791f0c662eb055ff6376c6d4bea8afe883ffbb1200ddb2ef9a49cfb36a5f47cb0ca3c311d5db02d1e10e9f6df222447a6434cebd62fa46eeb196ae490d0291ededabfe7a202a806f0e74cc847afbb7a3732882bce1127bf3310516381983319c5e5b6c0565c79d3c3d7f62897bab99873e48a9254a3fb8d6b5b87acab6e77b461329ba79b7dad71a91e113ac57ff82846a8859ff9f9b390469c0f2ce76b23a29c1ff77406f6ed2914e04a1f225cc464353548f02d93acad340f874a7fb23c412afb2dca697e480f098db0358738d6604c8a12454182ba1379d2b899f47a7b67c30f47461ddd7d03fdd7ac988753f4c785f65ef502dd3ad1607eb869db76a7415975840009f213e5c3770b90fc713fe576cd5eb3277de90507206a2d6de41d2d4a24f9428396f68cccbad1642327eb074d79169e8931133cf2940ae9b776b6dc375bbc3c0571521f24b16504cdbfe6fad959fdfa94d26173584710fd1293a9abf57643068e442d681951809336f8e95654e526bc979c46562d4ae5382bc7f2fc2aa286c33852291095a2c96175f2261cf6529ce88804d3471a48994c08c76db6677dddcfd684803e43ff5ea5ef4c11bd45f624c7d9cff93659ae72d0b46074d68fc8ea6fee300a401b23d2d8ed000efa37276297df492d5fa3b27f1c8c31ab61e7c4a38549ca85e7e677353b97f09f1ade509870c14129a6eb86d11180c41b61cdcd21bfb5a0e91290b6977b70ab6ec274de41ef89875212aca76e0398146c466feaa85708818e3693a94e7c26f6a1202bacc8271b6ad6aa530859c25dd1528d56c56ddeaf900ca1ad556be78228a8fbd433d574d3298c498489a1c56f84870e2b057e851d79654f31a31e1feac1f20fb862d8d181b79d98721ae7c2e7f231e1313d2e016acc7bc73dddcc385b7412bbeb35fc2dee24fc755248d45ded35b12f221837150ac7ddb78b718a753f51d5261bc128b01b0c7d973107fee09f06c12cf2b9bf4fbe6c590c467c058726d503a672706dbfb37ca98a7cd48bc324b630986f17a3232fba869a16358c4595f5595675d67cfb95e8f195ebb5fca2ccbc74a6e553b995ce32a35ff392f3d0195958cca5284e5d0eea49e4cf365d9ee70079ed669175820ebfe4a909a172e1fb2f43aeb809756b77619de002233b75779d73c5d2ab7cdd6a8207a4ce7f291cdfc514d1129b9623da2295431f567c2aa1ec6ee270e0dedc5c72e50dabad1c3b25cb7b3832dc2e7c7a52f97c0b410decaf2fe36fe26f1913ec4d2ab0e277beb437127bc186ca7fc7b404f6822f0208dc68e0c9895d5d3f10c644ea48ec1962faa4d24005a391aa413695845a2c584e0529f48e29705240fb323170e8d0724341c7a20f91ed9487439965b3b0aae26fd19a646dc18a05c0c610904dc17eac027d4fc8b872a20ae5778403e3fb2b40de3702f7f62e6bb510f25b405486f7ed9ba3a5d19d91ebadc3f5169de9fffc41df21db391071ea33f667ce0f7f8ef7e4d5034a03fa7b21077d71087c8dc0d117b7a06c4eac22350b96748c3dc5415cd0c17a06b12878783791e2bb20a6d253db568cb8550e20b4bfc06489f7b46d520e3f62af2d43494495bf5c4fd356e0e83fe73950fdf28ba0e4ec541b5581eecd0844035a7cbe92bc969802c2342ab2846a0f6f1de52d8e77b595bc9f38c04bbe6c828740420c964e3a73edb23cece156313a516259fd962f320073cf13745594dfb2819be91ee5e6d231d018d91740de0aecd7677c94d2845a4f24d38e045164545864b6e14e43b9da7819e5cdd022e04042eba4f090bfd2233d1fd8555f001370611296bb34600a83327ab3a7683cd4fa094f4ed6e8b38375d67634a0c610872b288aae76cf7e145df8e21e9ed7aea84f35983d6fb2cf370fd63dd79bd1edac4435d888ec9f73aecb920de3bb8f91098ac7e776ced65c79d99d3b46ebd181f89d6503c57bdcc53313b5e4302a2c1e58001f5a8092528d2a72fc5b2f3cf784a15e199db5bed8001fc4afb0ed0a515f0c0a2996c760d9b2c68381f0578aa302da4899c4d3880ab5e3f227f2ec2aac49c24dfba0757953958547ae88a93498dc255de3a499e54c841cb7c6f5deacad09f0bb768d0a632cb4162cd767fb0cbf526c27312be5697cce5db24624185db46f91f41ace359a1abd2b390dcd2828ef4b5f868bc9361fd4bdbe430da800c53a450880d22390bb3e93a21deb1e581381bb75bca7b26fc55bc3c191e73ba4880584410780f86c7225bd1132ddf5f9dd4ff281efd9c467974fa5e8fefc29eff4f7054f8ccd04d8637e8fcf4be1fba167b2f2844917983f837bdfaf469a949fb53a0907dcd7f3b4857eb38442d94f5a6e9bcc088cb12a224a97d47f827ac8b5acdc0e6882fc35b68461cb560a8d4512c25aaa36da206406e91108ea7b5a29a151e0afecadf0f5fb4198b08652de51c1115bb417bb4c3995ab7768c833e8d447ad28f150e5d119df64ad85e12a1f252ecbe1f967c08ce03cca9aa0776d9c502d8e69dba6cd2531fa3d724a715ff2bd625b7842218acd47a143f1470127b1d91f70b1dde4ae6bad5f22cc4ca3724ce77a6db8a0d824d66a1a98b199471dd4e9615d9f80fa8a3423723ccff83407b73b4ec6e89abda85ef09598256b13630c531a710fd0e65247ed5ec7039ec3a002f2110b30738035d4e72ee9760432b4e791ad24e2e6a2e557aa3e23258a3301fba32b69f3c0d3256bb50a403657a06a0c5f113352dcaf56946296ecd6ba3cedf0e37bb11592966382aed845a0780cfb5758aa75ed4fac96339bc5157b4e59bf38e2a62037cbebe4647b031721c4a6a7c0da887a1c3e8d54683af23c83082ff0987be9e623c8296645f8f38feb547f11985073f0122b79f83b8db00a0a2e372ecb5507b047648d7bf775b068d952ab5f246818cd8c68e4118d955f2c2364aa4f48f0c26fb76c0ef12fae40ca451a52747a2898591973cede7a50e1a08ba1a41a860bcb17a48387bb1a9f259a4fb3831db1d06f365b468b372b3a221a7625f442708d6908ec9a362012c3cfac1d81f68935d203cefaefc092772bc64f80a9a680a35d955145101dae204c874e08312c4366f9919f32b6b5064e03a59b80f6b8eb3269a2e4202bbd0711e306de1372b2c111b9cddb0937b5d1c16d8a08b91ceb1c3b910d22a7b2e4570f78a3d1b9f400b4ef14f5252f6f897604ed6445519ade46fbd08075af6fb00eed74c633e880cf0cf8fb82558bd37dd6002af561da48e37dff2a38d08c3f263510a87c736f5d544c19430e4cf4964a2fb1961da4fa8bc6cf31c26d0dc4562b32ff36f9dada0fea3461081faffd78c150885cf00728739e4b54c715b3c089e3f0e0496694c420dac0b0e67927e498a6bbddfd64748b355a7751e71535653b820b51ddb8dcbea1296c602d6e0aff4fe1ade70171cd41fa76f9a221cbab58ce5a27ac960b15b72c2bc8160a1d18550e98ad92df397d1719e49c56f6ecf588b99d8e8302a29d338bb7bd116d5d22f917941fdd581136eff0e282214d331179a9b66879f8be1326ff756ad8c20d9954e41532e177c9d111c9abdf1996dc4fe959a32cfdc1aec9fa444e9ce1a73386b2f5cc83931055609987133e47eef9c12e8ddcdc55115b37d00cdcea436e09917354db1522d02007efd29c48e9ee20d91bfc9d63321fd4e13bb5eeaf720ad6b43e0bad6a7f342d674e3ee9f172ec16731b12d4945b363e4a5634415f7a9c59fab545055cddb256d2ffac29622cccbd135fb3693135ae48c0fd8f0361e6d4fd89c823a5c980dd91cfe77e7850f89d2d113207c631eb06b586c1a03e257ffee5e0d9a32e78f63c0e0e3286b158d044023d2851eaff53bdf807a320316c7ef816672dc9b7d6f38021e0084d8cef213f19f5a9cdfe7d550e97e01de8a010f6685358f5496316a9bb04bfb7d131130b0c01b7b011f1028893a5b476f25752956080a23acf0df1354807a57618b9dec94102f8ab7045e0d55498ca397d7f022ad2783133eb5abeeaa33e427bf4b0ac810bf3ece467968d021aaa8346a16d24eb92355209c59aa8d1da232df0b3264a17cee2e08461e9aee193357b2fca525f84dc1ac06e92daa255076f2534ac26e7352cc836df8158292657bffb21ecc44936e29a9f428ad26d9d93f5297d98da801eb623fe0db21a4e3e1cd477bc35365955ca0d9fd9ccb98d48b221d565c222073c6dd0c08893054a171a914ae7ad37c047d5fb35f29f93deea6370171567845c69a8483fd10b91e0f05ad6e8f28a121205d4ebf37776aa4f3ff9038f68b7237b60da442c8c6624876d4085660345d36adf190acd7f2b1bab22a662b21d7f3d9302e8e038d9592f5b90162481f4aee0b05a715a6cc9828790716dfe007b3d2bc6e105aab008ee87d67ed4bc3e7b6fd82c5bd16107b127fc7ef21f727af0c0a4da37ccbd1ef4480c98c4ff93a2b0a7ab81e2b731921bc66c0ccb46b78586da23c66b1bd796f064e49e2ebe2afc1f48316848587bcc157a6c5b59bc16a0b9271c67bf6edb8a10f7662e9f46cfa4434fee843a31965aa6a1c06773418d2e1d99625c9500f5861c8cbf7f742d9c8d336705ef44401af7bbea673df9ccdb298e1f609f41179f238f8d7468b6049731418d1444e5850831f6ad279a6f0235102a927f4c275954f1ad23a56ddc0ed89fc7a604f0fc9b77ed6a0cedb894404bb76a3209a05c097bddfdce6632d225426717ae25a7b2bb3d4943f5c4a6657890cb9e58c3062722e9c804d2f89b3ea515f5da1681e2a624f3d4ce1ab5451810ca29caed690ba000397d2bb9746be28520ce122be1aabaa64f24ecd63438ee7ac19ebe6a2637f3d36997cd06852d04eee3d44ca0482eefec39c39173a03e326cba15aaf41da9f47f317ebb4fbfd1d17a8f5814b54efb4278a101cf35abb719d1d4badbf55e5ceb5d47c3fdd0f4337a4c5cf2e2b7d40a630d0b0d13ed41dd9db7d2a6d4b8d527d9b122b9b9fb5175a00412ad468bd894bcb0df7c0a4d688884f427eb5458fd50cfa70a60deb546118b9babe449309f31882e9ac20c674203e41083a37ef03885bdf520ffb15d30c2d02d1c22cf41b5d419dc8d716d132191b35e904dd1b0cbdb313e93eb1b5f573a9ad9d7cd79f9933fa4fa8b0c33702a17e79dd1079f8d64f50431b4830489529c143fbbff019daf0bdb69177e5a9dfdfb4ffed535eef7c03b4b689b216161162ec4d84062c1b10d0d8fb57269dc6ec6f8ccb60fd1e535d3c7c70c55c5be27a76d813ec696068c0550ef4ff1e6f7dbda0ddab0f97ec2f0aaa87a994141198b862bb46e1e1963a57d7b3923a2084288b89fa337b1bc91ee7b2a19dbd3a7590afb91fbefd3406753c7cb33cb80cd25149ab22522845e2bb39b131562b592bef96a26689df4cc2ad62b6d6d22a18bb260966b31261ba92d8d6b4bd77c38b20753a0796c62a93865e21b0852746c6b9290bc8bbcf134cf53c5713de29fc8f345ac1ccfe4067fb89ce289fa5cc7595835f9c67465bb486733d720b6929c1595cd4f07d029ca759671e74ac2c1cb43a3308920fd899eb84031d84c2aeb87c9d2b4057e2e5f049eda1076622b60f07cbc86d0561a518fbfac06d747e5ef07cb5ab5d1f98c5e9a95a12bf189c19aed079bfd5c9f30a50a57d8162816bbc9b486acea6a0479e2cbab1fc2e728b3df24fcbef3808e7a0a005323dcd8dabb92c36ce80c412823d462e1259412e3f5ccaa2f25349a433348ec77413588b4047a8dc987046ed0c488d195c493f930fb7ee356eceb5022370a81573941e59506b5355117372b02ebe843375760fe222eb34ef2afb630bef1b554ced4073fb7b678d1317359e93ba9f2d192a50a8379cbe45b460f5260eea7e5ef7077e6b5889372ddb11ea490c5d66c0a654c1a5eace269306dcd03e799587145cb73f3c570d119c6056a25a3b6fb59e052dfbd0295601c674b26b7ebb0168ae5a5c39f35a1408397c045425a0622b11556e5b584f87d56804e32882677040cb060d256ee258fdbf99541aafecdc8ea520e79fb47708a708906f09e23845be6ac122a6a6f0d1e107ac8b7bb8f9f17ecf1e17de738746c73ce9102d7a978ecb0dfa692430c9be9b4e56eb50ff3027ad5ee9d5cdba45a55b1b9073b43055227b8b3e0c5cb511e9040c2ea4ce201097697311212f6e6a316c99dff778173f8c988d91791d0256b27367f3a65c6c674ec5357a4dce75cac8b17cabf40943e323af2ec86203552c6a15a85fcae554349eff98553513bfaea0cc3c1e5ebc9da34b010579643ca05c13a4b5ea339126693a3d852fd4fa5acc7d4dedaab999ebb5f17af0bb2e30d49e0b158931a11ed3506752ffda92d495223108cd7b31e3aad086e8a2fe1d71337eaab5076886b574475990080e2d0ce8f01f4b33ce769c2d2c529c3e20b13d64d984a815e811cec2450c179427494db90ba9fd2e78ac046050bb8a0327757862055930f0f3cb9d781b7050613e0d68013802e2a218c6dda1b59e1617e12e9c75ecd74a54f08f12fa9b324d54118b8399476e21d7938863248a74ba161332bfee3a734886daeb63e195a59fb61ef7cbe63803c1bf4a39dbd4f61729fef56e17de1864c1c0142ff50143ac6e2cb94813530acc1b49c8836c333a17709b4238a81d4ba889eff27ed0374dbccb4b44193557f41cd58c4da7f32e3b24e580ae66e7e5502bc3cec2bb2b62a69760e75f7c61326d4b1d1b2eaac16dcce0ece57cc6daff7f5c9d0c2e50e1ff0d46c55b738b11871156dfbb31908e1d42690fc9534eeadb8a0708315ac51d9e63614233891923bbbb8e7443ddd0821eb90be04eb8f6ce2c46ecf38903e0e66700bc3dcc8f54eac1851c1a9601df03627fb0c9e9a08cd498ab24f49dee1f52cd40d47a51f642a4060d48351320793795fb313d174dd5c9bd58b43c9824e49871449e384c9d69f77c2e16562aa00b59321e3b47cc30a43864b944d1c2cd23a725c7af7f60ef40d34d5f76c5e86bffe03f676bf24b436e6f28b6e4444bfd2e75d70583ec79cda337734a7a97cb2eb8b4e0f2aaca5a26327ca5b6b46160d9d17776b436d2ead6a77a885f1a4021d4eafc490d43266ade61f2351e56cc2d01f327c8f4dc2d919e44ad7324e82e9745d27c9d890e35b3a11c98063274d9647f10815d7684745e3d66c0ce851304caa7ee916f45279e30af38f2bbf7bf8d0327807f11c4253b8a9b28d09e2b1e9de05f726c525a20c0110266b7be38c852b03e7de37c624eb58cf3067660cc0db4bc5063a877fee41cc39df2440dfe16bce44e62b850c15ab417dc2bf8e349ed755ca9b38f9ab99a547ca27fa89ec0ea02a488494a4c724f461bd73dee81f210fc29eaf5fa1685f495b6aea8d697abfd4b885e325aec63dd675c6bfd5f1225807e14e6564177b662430d32635b30e2b22341c0b894165b1a61c9ca64548b12a39fdf23347c84aceacebf23033e3a9ddf9ea4f986499cc7c1eeac3767853d342ab4ed8c5375a01f0d08fb964d9d2bf70029657d75adb4647b1fc8ad0665f4287d74f94252cfd922aaf7e0dfdee048ce23993c45c8342868d42fa893edb0bd52d7ddd8f236afd0d649a0648b1c8b7eb59d67d659c377929b722e1d2ef70496c5e23025ae183b13252c433c0c370f523cac0097cb330965577a3c8c521c537ec1ea7a7a6c46f00c60b62785f0cba5de793b0426f6cabbfa34ea2e7af29dd5eb3676ad49dff35613e872a001f26c71b35c8c722e3f0a1789e6b6d1196caf0634125ddd3309d8eadb92db1826d3e0e885eec5c573ebccc2b591bbb9db920c46e9497009ee46707d6b8d7101455994a1673d80c8ab037d43bbf19c0c1a53e57b64326f54e2831d1fca86ab92fc356d2ce1b2a406435e18aa0aaa3917759aae2a33ab0f28e7cd1aee0e3ae3e4f0b2afbd1e97b26e377f0caf71f58ed0a8b150da863ffe403359eeb0b6281702dfca453764880d2b8838c2c36b2099a7ea9b9e58681630d3452cda926972df4534b8c99714fd74c35a338c69063aa610d3cbf224ca559982e9b6f296d2190e81b02c5de9ebf9c0d8a41206c5e8efaf03092b0d4f76e2060af21ee401314cb8d2ef78ffb56f341c9799cff2aebf5cfcfa56304c79582ff0bb151454ad979c6bf4f8623f0c342bea2609d56fd93118459088306843404f88efc47cc1b76646162631d42e6b52143d4852471beff42115650bd3de34b0da2e2a6c8e57007029660aa14844a8b949d2cfd07f94f956ff7b0bf2a85198f01d8d87b287b32e2a8f04557e1e43a417ff349071a08521c9789d9e6193be8547a01796d19bbecd9f111bbe5751f95b2ce7fd7d48b5bd969893d4dfa2d8a55224751b4985bf70ae2e615dc8e537a5f14351b289e278c6ed62195191439af77f03d4f6d74a4658bae2d246b6bbb7f7fbc1373467a44137442cd79fba87d7dff7719bdb86a05378600d76d31377665456ca76d1481c75b4c1c45c62493fd5ab05b72256e700d31efbea9dde195b32c440e41065321bc3286750bf00ea37d3e5223bb83f6b53dc3c04b79db947adc83259f7f95c801f103e0efc4af4d029fc25530d24b12d01a0b74ab95feaa023b5354b2c0c031bf0ac497601114df782be096de4ab94b45076f7738a0ec1d2e136277741d725df26af04ec8a5c352fec4895c8b609b97e31c9206f691fa3ca15165530a4ea15b605c1fe5f05e5d384ce826a9941464645ce1b92193f9a40faf5f9cc6b0383b0281626a6c6ff6e447c93e0329b7fe7494353df15f93801a256cc340848daa9757c9b5e707b27e14707238b6685cf4741ebf2340cb0e5c8b598e8b5c7a896de418367a8c8e0cfb2f5c63e7bcc6ee8499ee53556beb6c6761246d6988e486ac562992b5bcb916cb2e2f273355b15e9bc51551ed87b3f9160b4485bca7b5a0ba7a3047e10408ee35dcf72954c3937876a8944fefbd0f443d23d99f152839120654b861d517796c270d9f28f99b7b65be998fe8760a6902077922b3ad8c257935afbc6a62744c316613e8bb2a7729eb4cb230463510798c816f6940565ce744ec3200064016c9e55f8e43b1c9d3ed2febdd577bfa4fb3d9911cfaa1559169c94e81e9d6226135d4717bcba6ab99a22ce9f35bb6a9d13dfb39bbe1813d750244b9db750c0301012f2f8a5d05561448acc200583e41c59d67c00b7fb3cc3ad5522c2a8b8e6165aeda54699a0c81df296139abb587f0205afc20904ac8504d7dea76e42ef0c35947d516652c48ae414ff54daea7ccf7ddcf1d93cfddfe92bf988e35fc082e3dfb808e4aa318211abd800cbeebff76d6390f16e25c4e3298270df9dd0ce4cda81deccb746585fb07328b9d6967fada675d0e8dfb45db4de9a9f12aa0b9f68b1165bd542677a3255aecf87f7235d0e2dd34a9616e800b03648f2fb7535f84fe2d16a08558434fd329d910ba4534d5e0030579a4b01d7e62ec07221290dd772020b1029cea76e9da94e089c825c84d641454c6b3daaeebd6ea627bf0e71340b6794c9f5040dd5edfbd8e158ffede45fbcea4bdfafdbfc4ba2a143c5acc339917d6c6b25cfa54d75bcbce2fe5559bbb991c6d3b4aac2c7d861117406f8d8126a52c35567b14b4bf7319ae9b2935b768b02e476240ef0a0068a4c4dfbea01a7fd9b0ffe16f66aee2689d3a1e0ee6a323f004ac3571ee3e69c1ab54771fec9783c070adc154d69532155a5d44ab3d7036d206409e196d0115e9867fe78fd33e2581d85576735529f82ef8359025a292eeca9fa575ba5bdd2de49320593455257000ea47d07e09603979ed964072109191847a2d4fd1f22e0951e78000defbc479fdda77475d47ceae26bdbda308f7a8839af6a7d0c2845cdc7cdb9fa61850993e2aafb868f1eafef7c7b1a5812b9d9bc8d568449fb5380ecdf11372bff01b20d1ebce8febf5fb0417ba360d1733685d85c4c58fcad62f2781bb66205ec7cf95e68c7f78b727b8287a285ac0cdc6d1dcc486a397fc3f3aba61453f6c2b9edc1ed2aec3559e4b2d3aa7159adf86262fbcb13d11dc0859246d1662d737ffc6b2850b6e8e7af2ee0be021283332b3a1f12367eda7baf4bb3574d7f21fbc6f9047defd9bcacb22e9c618c12416778cf4a6542c0d2e52bcf7b4e8d8a21b519118f4ecd99601faa444555a9b0febc20c9bf78af6f386ee8dacbf5955a7e6070bcd37da79d6cc499961723117033d6f9c6ef4063f4a39b753b44fc01eb8ecb9a9c7f34b8b30f9fc26bc8fb9c0214b46327c667c940c9cceb3e28a41b76b9000fb3a55a8130d17545466abac95fc43cda38ea1d492e7d2e1f0bae21ce157a87236e3816ded5179a86aaf2dca7e4b989bc78125a3ab18ce40870c46a10f6848e5942400fa12aef7458306a30b4229f283ad9685128eb5199a09ab45000f6acdc04946fc223179c91778d95c2fea95f1ba587bdf323fdc76d39798166ec18a3b8f83231d7d01f315393dff447de1b2b4d5f18a1f02d6c8135e79ae3b55978d865d64f696f2aaf794070c02d7175b7a7e13f196e360ea42846904d28fb49c46496d33399b3b331427ab343ae912dce456c52d671adc58df3fe771518da187e6c37c6c76156e9d6ff54bdcbb3d179fb17a06b525a5054ca4870d769da854583b720df8ee8468ec35c0358ff5264e487733c7479af8fc2ed9910e311c57beb867c3d0d388aa8a6b15ab6002428abc2af0df5c1fe1bd33d08206dcabfcdfd9b7154306d85147411bece9adbf36e01800ec0b47dd1f81b94d0f3d64ff38b21902cecb645dd1b068cb0b5cb0866141c9433f780de8a777e55dd77c8f153d58bf288c477002f379bb08e04a8a16d6a4feb49db54149824835d08c757af8a61d79ab6997ea9c010376f7daed0701d9940b8f7b6bbc88f0dba11a074bd45106476c23bf03559b30ac8f3c339ee21e87c561c6fb17c32713e2bb9fa3602161a441bacc97c6a6493e86641e7d8378deb083953b3a94bbf4cf42a48804a29ace09775f6dd67b691341ee6634c724e4fa8aaab18d20c38068f00efdcf45da7ccca21f972218af013e91b20bacfacaf66de5f5c431baa8b9a026c8f49117da8f447219e228828999164c28e869df3ad316c79f2e9bd2946ba8db9915e196c9aeafa47b26d90dff92606c7acffc5a5853cba138ec36057f655dfb725de96c3d5d3e27c0d38e0a96303f1d6bd231d021eef31ba3cf27be99b3d56a965bbdff5d16fd8dcfa0f8e1914d0228030666edd8ccb51438e33b8b77589579edfffa7c82064ea704172b51c1723b9ef9f6db570d36ee7c849c8f18ec75430cfda609cecaaf5daf4f57c828f0f55f9fb54e35f11b52b2662ae44975d50f3b6762cc39185d1d28729667e283dd37606391f1a78b916949318acf87b326a0667292b31334408e3c111806d194734d4d9d4fc5385a4ff678412360963f984c8f1f7bfabeb989052d0041eabe926c82ee942ae37a71148fbb0f843aeb5b556251d8110d5c43aee23e1e1e46e946feed31fd33394b2b3bf98ac63a88e54e25f9d9e444d9703cb889f4d81036effc8ceb3833e546b8e20f0bdf3d6e2d0b6289b1ecdc542d74d32a6923751418e182cd760642f8dc7b322978d8245c4f1ca705cfb04ea98e7fbfa609e6a3fd8a8c90dc024fe0fa11d3be40b8213cb20059089bf49963b86a15bcb909ebbc364f0dd0e86a5018a06faf6bc3d47b333ca33f03f7b86528f4b68c321479ee40a08e282689e9ddaa0d8d58011b29fda8c6319306dd8212bc7a30e7b600e2efbb1df10d02892f5bc0980181abfd4833b2f7b239d191e38c758d7d337c3515daf8f426c295b38c40151a3932059bdf3b86dfa1869c8141cadd788d6758379aa6ee4746df39fbab5fdb1239402bd82c7a971380b168494013ed4f71fb32a8ab50e5498499ace5df65b7dfc0f7d95bc0093e30564cd650434f81afc2d8906142f6efa0e064b9b0d08620ca83c03e3b7cfa0cd8e471e1d9fc6be7e99522fa18822926187e75fbd3d152f09935b76f7ef63837c74c9f627e9ed68fb3453d787c49cae5f458a1b7c43c5de830b1127b06531498ac38565ffdbb81d0fa3d9c1b12a1ad0bc2cd2ed76f9381f1ca06c3313a438edcdbde78d8f75985f12dfe181ab2a7b53673f51c30cf90b09a59396df549952f04db9d5e19c0cb6a99e3f91dea1971f014c7e0d14c665efc3448b085728df9885b951756422f1883b4d7a7e72b88371059eda010135c5aac1a56ac51ebe8fabfdb6e7cc055f450570ac7260c566c240db013ffaf8da316c606ee4427a5183c0b5387e1c83f534dfb7d9cdcc0d3fe24f403dc797671099589a33a8d213309df9b5edcfaa2a5d2b93776705c7f2d9a377d3d0b3764951fe0915f6e504d041a82356a46ea1503b943f6c2ff3f868a432fb1e76e9d16696373a8b162dc7974a2ba49e300970db8d1626cde813f31366377853ab6b058d4e12e97246338de5e290eb7f8ad1952e039932215daa594dfe74c419fc42942d7e6fb466f66d2a0b9c59d9d47ab984954d2711c65a6b07ff0a703b86df9eda13eed65b7044fa341bdb66083537f3f179df217b0bf5005d8168e1d10b1734c9617a564a50f9b94e07698c548f0a1642e9b3873d421f28204097b7d23e080974bc95031bb08da61bb74c78002d36902b4863dd0ee86dafe4d09bddba51109edddc78cc851adbbfe8fe0254c9e46d88af5f2f8a3e76f0d79d10af419e80b865317d1548d2132ca867290eb59b7f049e4b0c9f57d5b3fa91a71c24f19cd471d86834d25ddadda3a3a5d553f5d3be8b8b5b069142cbdeec83be28e42f1022d2f86ca3e05145138bebc7156a09cb33fb3cbb8dabee0505e2fdff1e44a549cb06447d2e85b0e2c997e0f59abc071968a5230827a62e46be8e861ddcf9caa2c77419d8ab7f978a32187855876be0800ebb182d19c4de480c26bbffe5362b0206fe6014a235951991f3f7009f542587a3aaf50502539379fb6fff5e4828943ba713b06c8cb5d8a5bfdcc34702481b9f5fa0deaeaa4fffd55543095d6856189075c9243400505e3289f8790f16c78898fe3f67eb34df5a36b0422e4066e53fe3e25d0d281616544af72eb43a1611f0d4bad54c8d8fcfbfe602329e2093a9c79dde2da0b589d0f0864d3d4330159092cbb3a5f4b48b0f730b74a7e41affdee5a57d2da45a4ec9bdfbe797ec36c121abac287b8acd707c61a360a90bc97905cea7b56d42ce11cb225a62a179e6eb8517c7d9035232ca700554473f3cf6f6d6220d95b4e8c026def0fa9cb3a8329d38d9473ab2e69f85b43d7506691a5a9061f84e5e0c27ff7a9f5fc67b081d69864092a5a5a3de9340daf7b7d0ce23b150588addb5753c68e69e9c6fd7fccb0a911a99d952aec7e7a4acfb50716c8db8ac6cbd2c8f27e9d710d79799b291d90fcce5566662b94b9dc961ec7fcf6e612110f79f489a9537112c93012e4a1c85514194de67af0ee18ca4d972261038772c4cc3b7e96ddc5e9d22a275e29d82282f0cea127a533334837752dc9fc92393bf115a974c031474e142ff03e4cb392b06f6be06428aff62b1aa11f9c79a86f52d469445aa7edc06e5e388ae3e738eadc8f4591cb1af5fb76b821ad045103e9e62487a947c9fddc94a63bc03e377c53fbb6e9ffe72a103d40ed7f73646f8b846e5d4e5068a46f11cafd8f9eb8b7e335cebb1348bad974e5815a169c4497308e289d7bf43faf00966be9ecaf3dd9b3c6ae1527312d59945e3abf33dd30579a6476d14f66e44f4830355801fe12d24ae1d9f8be88dab33d961d41fb1ac34956a3b24dbd2db3f5b79983c9a615893122ef1200a0e9a1f52c587aed71edaf051cab464c5436896d046811d83ea0b06545f87f3d09db21e2d4d550e5b2b5f003fdb0dea9ed5e7b03e38540c06994a4e2267c12d7d683a2411e85dcc4bbb581dc812abf8c4b1c1f23f089e6124d63cdde840645ca9ee15abf50d7bf87f589c437b7d8584b2eead57a57917778e062e5878b210311c2c820af81eeb582797f5b5923d4f363e006d3f679ae4c98f8e939c9608144c2d77bd2cb09bb2ea652128960047f4b016b773d5ca1dbe1ffb24c0c432ab4ffbb5f521244300e23fac27ffcb09cfab082187eb204b59bf77e8ecb9cef9e29d5fbf65257314ac9f5e0d466fdb96c060ecbcb64b27f70d966591691fdbec3fcac0d5a8238e5083f7ef61ab692d496fbab5980b0d84cd26e5617da6f68dffa25c9ca3eb24cfd621470452eeab6a35b13d9c82fff4045eb18e365a92f8ea3863d94b0b2bf8f2739206552ed215ab084338eec725c2e5460ece48037e2365f5a89d1caa59411399f201d3aea5c7ac4eacd5eb5b42489407758610dd518b2c4d8443287afc3775e4f0fa01cc7447af86d11b11056b6b155cd0f566c16971a5fa1ad7b9cf9f202f25412e87305216027fc5f17e4bb6a818932c484687175853582f6bccaa5adb20dc4d318a2c3711cc3d851e2b069adf26a80f975d8895afdadb65a5208822372bb6e843c1a2e23c09df52ac0983321f86f81290af08f73cac32d6cbd1ec82d17035855aec59db006349d599cb4d0c6cb4daf848aee30a952a982547a22d8ce6e58211417f5f2d3ef0a9aee4ac01b1802231f6fa9126cfc71e5701b2c3279d6d3b2c56b027572a39659e87f5ea4bf9f3b392dd969d23a8939b301df07641bb8cac6c279faef5d62126b80cf8f811113e38f7e5a330c340bf7d6fa8da5f066bb12fbdef54b3fbeca55a1c2825a98ab3895638796dc2bed3b5c8da8cb6dab8d0cca6a53d893abfefa83ed0665b049dd8ba352aeebc386ea6484c623f4e8d8640b83330f2a0403321bea70d255ee162745b0b24a897cb4eeebbb09cfcedd4f1383511b56089955654016ce1a456c4bd5985130a182b9c1fcc6596ba6147f5994dde5af843016f90d1c84419c90d4ef6473f0054c08f8b6029757b895a6bac8bc01b149feb0f25b8e29bcd4861d9a36266df0acd2e074d45a496ca3973253c414c675885d65a6eb0da8c0d94ef213b59272a499b9710dcef31b6d336be952705757b300252186d748044639296fc467419600faba4c6d4d16a05a262885c5663776bb47272736f01ff4e2c2cb0a3bab698800aa262d8c1f9400f31c1e4d31d2caf9e67a5a45f7600cc5e09be22525eeb8b76732cd649f566ba2ee8688180cbaa2ca0fe68426b04fb2c5195ceecd8a10c910b572d10be4a802c7c1d5bef6ed452c7860a141fd469d3cf2946e5fa937ef7ebeb64995317ea19076f0a4b1bdd1b98f43eaafd9d4d194b9a30e458ef865fd5ed0f1f480bebf2825f009cb8648bbf332b3c5a019484bf2dbebea5386cc462d3e96129f6f5ef24a2d15f52775c9f8fd2eb3a1763e7947420f7261e4025c61204305134ee2badee5957ba3b169586fd6193ce9564320a1a16649ec09b55bd230eeb2fa39ba519c27d7afea158ef6bd6f95f5039e1451b466b11484c7668811dd586e2b4ad68bcabf3bcb6953d546d5e672ab7fb0a63028055b72decc8172e08f72f887a30078134135b3b42db3e9deba4f836df55b54bac44ca51623ece33e373af3fa6850aa4c404928d04067b3ba386797f6d7d5cf06a21da68d83e8d1bf02de4c490974b08cc7af47e6cfdcffa96fc329bc62097066cf7a5234e0b9bae364ec0cabbb18284449e3834860ace5e56700a732d51944e3b7c2f85da382f7304a5b384126ce99984ab45d970e2e7dee25b7934733c85474cf8eb4f973902d18c3d36c3e69a52e883d51434476a6bbf27d0b46597652443ad1dc4a35bc5f9a8c218b50e2e5d990a4fba7cc7804fe5d66bcc721770e7bd1260ab09e8de1a5498e099e63b7dabbd733f006e0f149aa0f3accc1fa247b457b2b90acbb528ca57e3c331ea40ccbc7c7e17e50245b172914810a14ca9ac5cfd3e1f310c3740ac4011f4b2a8c5ac3a98ed3c7e4a05358aa61c03aeba3c300f252bc67327d61127f46aa85abbbeeac24c078232bcf25cc516b620ad5a725f3263e4404fb5c93d0289580e07fac3e7140d53963b57d21289cabcaa56d6a00678933bdeb492b67e8af1e81b995b034c25700efcfb0ee37206bf17a4c363b82f1594b4edd7b2782423ddce658bf56f79362536a2d4eb244f5c15959483a683c2802a29d12c6a6f0077d140d2d25ba05349942bda48f6816d420a705d8ea28517f974dd1323ca6c814aa307b688bc4a64e504c914ae028cf53becb1d104fcaf60076067746acc39a5a366255914bd6c1da7f78df9197d1753ba060ed1ad84357f23439aa56d5df5928eca02c838af4523c49ed4da2327ed419877108e633d2b17d2963cf2802584c783ec03b3b205f3cc97e5868b381cf6854c6ebcab055a7528ce350c4a55682f84a0c8d8dceb0bcf7ee617ded2d60791ae5b2ab05b3ed5be0aaff91d76cb0868f8d063c038eeaf80f7e6df640945fc1bc08b5a68ba3a9c337775813c2474adf68e064aedc5e65ee48e7a5a56df83fa62ce269329fb92a96e4e4baf89409dfb302d2b2c6bf3b43707271b835978c7a4ca025771a54d4517adc4e113c3e957ae7f6ca2666422640161e310cd727efdef0d92c979e4c34629ecacefa3e8888755d4b38249e00f5c045c56c7e7d21ea79558d7ba3fabcde8ac703c3ae23389f7234ef1e139c13256178de297592a0e66310a71a2e5547099742962b1bfe75c6f13fe9301259e45b88bad30858bba26be0003c144a5e9ffd12a6052d3b5c289e9fda8b0664752aea6fd5c233c286582395f630e18a744af655d131e7788fd11511b142b1db769f94f53728278d29ad6039ab1a38f5c664fded1703b43187df1cdbe02dde2b1208bb337cff97d69f31335744f7805d1658cc30d25ed12bbc341e24a8273ce51df04a27349f8bc2fbf4fec80b54a2722ce69dac480891a8fecedd8c2c00053a252e27814d4f48439ab2ce88a9da5261c245a67e7a795d9e856b65b6921f9c5e73004ca4cfa171e3a54e12221f1ab1adad300d26bb36c31a3bb82d3d52ca872af853fd04e995c9ec3b8c49890381c4ffc3578100dcfaf7b6a9767cbc656cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
