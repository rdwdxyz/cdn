<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81eb3b060e0a56aa0d2267daff3db4e2c389b00eabb0a0f7e3baaf90e2a14933bcfe5be41e355f813a2e497d4f2070a3afb67c48495921ed0e2dd8b95a160dcbd136448baf763fb8a24aa52e33a7da89590ef8986f300ca21132197a1f3eb2c85d0df9d66434fb66a887a10ed6102e35dc5c9aea4ebdebbbb5c0f43ec27d1b30554254a127b7c127a9126b5834460b140d219b8fb71005d12579373c8e8fc295e5fd6bc9832d6f98f55d07eb8e178f670b9de9c0148e9c1067b643fcd47ec06fce9a19eff6990c3e483ba96384a993d683c598ea03dd74f9e0a60389d8178662807a792a632da90d96066349a83e6b2eb5bdd3c7d26540b4320d8b8558b9aff4d965d37e18b3c270cf8a990cd99ae2dbe8b9a49bbed85dc28ea5ce833b6748f2800bab76261b269596b40ae945b4e96ee54fa4fb82c38776285824c9b890f39bd9e4aaf80c7fd43ff53630859a690410adb407563ed0ecb9b3d45a6fa5663a285a734ec5cc676ce5844c823b0cf4e72bc76d800093384251f89a373b2430eec3c2e74b6df0b80857efd96df9d05522b617448c2413f706e5f83c9238b28254618ac9f55c9975d2fe219d2b9bac2365a77d07e46e83433879d5278151b5b74f62ffbfeaad0f6f29eafb5b4b5bed34c4b9ef78308e460791e6d30e05c4ba4eb925e3c97d84ebaeb8babf21266c4a02a7fa02ee1797a27a38a36845e2ee041268a7ebb8259d5cfb0a65d1f373ff7df9cf465eaf56d5892e792ad1f6e53d5d92c5ffa35f0f1df9ba729a88da4a1cd19364f5fc5983ea27559acef8db98ae7c0b18b96b9fc66f45cb928f53d3e0150e92c8bea4e6071d7b8126fcb337394fd14e5a2162afc3a067e3f874855d021d487eb3b4dbd4ec4d105d32b7f7baa02a6bc1989d3c51c40aca5a563b4cceb6584e63561faf5fb8bd84742f695d450a0df90782b01b2100b65bc75d0467947afa0f6002f6bfa3d40afe05c2b324a7bddf304627cc77ffcea3b2dc86f75c354f3e4a499789610c8e5e0bf83abfa8a9edef3d9afe6ac4bd0c539b41c6c97c58c4c153363bc0fc2d14dff1aa2f1e23afb48e41a90351ba42b5ee5cbb9e2547c60812b5e9bd6b12382d033945aa7c13b6d85d5aeb56d3904ea98094f8eae3cf8eb4a14b8db6f7e2ca9d2d211b20834f1e2d5a72a0bff6905bc3bafa77911c01e416cc6e08199f6995fd8ae813d5d735405ba487e3135cf3b6696d304641f9843733d575c88c21a9f57c44986930896b6965ca3fc28901b41b90eb1a5a4ded3e1f4bc3cdec9db80f45a2eb38b78a90321c6e25d97f9311b4edd54ab5590e6a519dbd688200469974df293a5581c72c5d84ce511549482b75674d64515ae4fef59934a3970da92961dcb425d2b818ce3bc934cb730fedcafaee7af09c2a6f780acecfb30154e345cac35d1dbd07335a4da0e372f70b1a80a0018a70d3bc72dad26794b00b2fc6e97e801865f06b033cd65c006139b97d44a7cf88bd3ab5badd86ebc34107d2d1b4c17f5632a9bd7422a49cb5fac50095747c369918b6bcd64d9ffc2695f36e80b11f20b25bb1afbe26134b1fdd8f8cabd134c9d06dd0a976f56da1c2d78cba9047c8aacfa2886b5de57dd66f31d8d42235e9ffb167e81c72dbdbaa450946ad58e416c4a0823e820d4dea893e5d047d89b3011dba64460a741d77c34946f63ce2a83996c76693e38dc20390057c9a436de4908a92b1e414b7060af25203e54f416124429aa4c71d5b4e9a3bbd914610f181f1378a0967fedd0ac2c2a2d8ca007b17e30fd2fa59fdac4fd26a0240592e361a860bce9254800553c9ed0e80c619804ba3421fe0b21fe9232199b759f81a18248f4fa57ff0c174657547d55d8a7f3db510be24274cb84ef7448f3c375a2d0335d4cc0635ea0c5cb6bb42a85b3306a73bab4ed77c495ed8b12a4962be07f0c554bda8e3cafb8c2bf26e930511d51c9142a9a6c40ef4643ffbdb6dc6707f326c4aaed55b4c23575b257cab4d57d1f9997ac84ba4f16faa8ac127bb5357d498553ec969991a461aaf46140b6b6e3be30feddac3bb22bb4eda06b12596aaab2ea11fdf68bab98c0e9687a8e7a3f2d76efe5dcd3794db918871ee59658c39549059e3bc5c7bd825aa1c56f914c249d7fd34a5f4caa6377e9f1c546fdda56369edb5dabe50f2ec386d85db37afcaa1c70faa9ed7183fbde5be51d298b92c4be0661c808949019f716bda21fe24a3b9b2eb78a17e94ec1f76e7cc33b4d7424d71472d7a77696a9ff455575f65fd6f5aa0b67b8a29e4c4665f0e00e0a6e44599f6c1c499ec1aded71c17d605dc651cb0b99a9e8c175d7a4370be455e5ac0892baed54a1e9fe8e894afd1d8a8fd6d186a3750bdb3d03089b498dbbd810a3dd25786398cbd8cf3f211fa1c3afbd049197d47a263422f4b0ed3ccd4039ba54cbc8189c97773faa146b45f65921df3d71279594ce01a7ff838f2f6a037ad5e2c62c1fe3bf58988f60c99bca8fbdabd1ff7e6e2e165de5486102d694224357905cd87b105c26873f86f2f449839d135a878ce8c8311e8a5063ca61ee9ebeae5e63d5531fefe92418372e7ea6fe9d7322e6199495bfcd91b1f24e5035faba4c9962873c5ebacf6f8577e0797e001ef203acc04351d8976243f76592754e9ec08a2636fa2e10da0fc921ac97d6866132763c7e68146976e590b0a20c18cf6a1584811ca38a8d8ae161f2ccf799c55c2c96c304f9333d49dcccd25fdee78d03a28c03fec0d7ec5dc74f574dbb88b52b3705d31e5004a2a020e97e19f90a29c4f540c9845c1a7a3760ecbe4d18a4666d695ef4ac9a9ba28d41099a952ed6ef5a578799291075992520ef64d009d2556c888be31bb503996d2430a3e62046a34ad4940305b5a0cb62dee3e2476141a41cd163106abd9cf9c2cbc20a54edce7d438567b7bc0574500fe3c7942b1603acf5119c604510e96408800ed2a7c3a62af5dfffa6ba6934664f54b10bcd45398e1aa64ef87db4f3d68e9f448237aa76af6ed7e47a1bb30fc835604f2a8ba584162c3e9ff11d8d23b2c9fa0b9f01e4c022c64f39e05352a2a9ac4fac82d74c72fe573dbe1fecf76d2f28bc44e8c81859febd47132b2dc5b40096eb232c1227c5090c6c508c6a66d403254ac2ff548213428a65bec871038cb9a5fe332a535dac2f1777bc1a5520bffb4772335778e670822ae9c58a4735f124fcceec4ba2d1fcdfab443b95f99f280710dccd83bb900b1c5fb4b6ab7b2c706d87ff7865eb5417d3cd8ea614b9ebf6aec5e309347e5dab13c6837d0bc7c47c3e4571d87c4e07ec5623864f769fa3b0ce86ad818d02bb262ab0c67a9bfec85efed86fc437b7a03179ec4ce7dcdec1e135790c2d8eaefd2f081d48c4deaba95c206720c36ebcce3ac1b7959f2ad3f481115fc6fad36d41167f7fb5e491c8b3658c0d46c5b754a86a8c92a66d0a4ffc863d1c06ee3afd3afde3f66c8d2bc567347757f34caf33dc9e24a53a8a25af9d94c25fe349ecba099c8b38512897070a888edca41cae06029dd70195828635a763d5159fdbe2003f3eec0cae0d6f244b23f2e45fa140c0c2a2dba5dc75bf10ab60e7662c667158197e5409ecaaf7485c3c60f8697bc1350ab1013fcfc4fd617b9cc2493e4002108452fff5ca98078e1af655459775b22ab60fde7f2d677b72f9fc1a6f5023e025bcbb5eb6c4ab501a6f3f303e7ce2a81793eb8122e5e3a03c93730308eb6333390ccd42ff8f4138de7b46f00992a768a3804a758bd4fe2f296c7243559da841ee5b417341ae019eafe3ac6bad8b4a47443539c163b9769de22944f770dfe0a8be44cd89f9b1c4667d464d0c94ab5d75d184d7e7859a6c24681ba8bb0f2a95f46e8f8f69760ec049a1c5031e8e98652561f1ebef8984d35b99a335ab42e20aebb5f8e4d2b715c4f5f9b2a16fca36e2b8936a885e4d080cc706bc34f7ce3748c8ab595a4466266a15f82ff824cbaf40e0927d0c47cd637e7a51b07ce979c7beac24558eca2a566636904c0e432cb667c179e733345c3d32f0d9006585ddae71bd41ed89398a0105c23cbb573155a77aabe19ed36aa6e5f7d2ef68db0f5154a2920a377f5624cb0b96c444c2d7f190bafb70d69829b39ebde2b00ca5053873d2206795430d518f4174e7aadec3331aff03c3e2240f8a6ae0641d06fdf6f293ac9d35d0272f1e5c629d7eb97a1334d5f45d0faf6bcd539fff54b7da0c0986fcaa0ba82f89d084de4012f5249d87a0f34b3aefc4ab2361d9fb0e8817d09bbdb046cf89597255271b9d50011038f0530e041cbbfc7800f9cd6bec352015273626539cbd68ef6b8692cc45e8e722251d0758fd66e74e6295bb196f75c3c2d2c1086a5370a0b6b5db1c02cb5de0d1059f098438e201ddc6d96d54dfdf18db819155bb3a03d4bbfe3341cc9bc9c26cbf64e5caacbe0a79f945a9a96ee258edbc89473924b035a898791400f6499a62ce737b34c5172e9e4f397b43a7613d5ff21380bd2eca8b1308239e8d12715f19f5eef96060fff3b1dc8ce9b91c4f0a3ed7a382ff56344aace95abd8649bb77308181696d708990cfd12e284193aee9f99b92ac51fa7122fe32c47dd4c437fd149fe91a00ce477211d079790687696d9118d9b5338466da552d21eb119b828db92b5faff1f380ea1fc42c0545b7ca0d4cafe611e9e69febf4b969187cb35318e4acb212224dc11bd8c5e9c4d9df884a45cd6b508c4ed1b4a5311f0ca8eb9d5d57674c7bdc21541a1582f347cdb6a9a3097f96da5a4401b7aa1e0b7da1c32d42f987b650a965b7bd1bfe333406e258263c02787b5ae7dab62e35c71360496ed8b63649e8edd73ccad98f2de56f27b7804d05855add993cfff334aae92ef87c8de7ccc3ab117e28799c6170317c1e8dfbed3806484b0374807add22289ce694e4180eed40d37ba3a5077c986b48e0c97ed1844f337b15f01aeacd0be36ff329a576a5bb3159475dc0ded5b653bc35a6794bbec9b2496a835a69a85030d582e620f19279020168171a59cc5b97d64771d264a69405b0f0baf3b678864a89195041831e03b0e868da564836a87ba7cc0a0b5e386a8dafe228115ab805416977b12b7ca6259a20a07abfa361c27aa27d044ee5712d1b6fcab2e1301dd6406a50c9a44c6974daee2d3475e8a8dfba8ac5ed9a6abbfd93cb170b0ca01d00ce87e08136e878462d992258c9b37ddc290ec73d3a45163ca74e8d941fa298803036ec812f2379623fac239faf4848d3b499efbc0922694ddd2357296ef3b6b95e944e2b60d7dba47aac7789da0b2319d683bb9d366fcdd6fde92bb80e11e8625aa4a11c82c1da426421e52327a21fd247b86d8cb7406c5b0b01f83d3c80c36272c8f0e94ee7a4114bb3df267ccf1d8261e2c51d712bb1b0a59e4d544823a894842ea6c6f177789d5452e97edc4c7dd922a41fa327c02e1bd118c17c7dfba800a4685f8023a6f6125ee2c33e3e40c55f8ae0aeb43e9407ae4be22100d59460968b8575deb404b47e7b6dfbb45a370b9ace081475d9c93ca33ca86c79274d38805ee1eb2bb07884b4dfca31527006de4e1464f3d6192fba1ac5af255bc226df77ff1934e718c4be847cf9e35ac0752b3fcefb3404c690be855ea26396293f5a8c9b0c6b9933d95f5e5bc0723abe35679bbbd84c84f65c8a5f228e40746d97c1066bf0b9360191e117e270c6139b3297fba8aa1cd4958c452951a2b3376655941ad9cb587994dc34d8c6bc95f79f7cafbfbd43ca5dfd83cc5942e2c93cd49b40f2f3597d3d4f09ee01d24a62c3cdb0327fe8d3fbdf2402d8776569bd0de1b768f2dc4e3d070945b81a8b9d0ce2672bf9d5b325d6ef20e97d44f4d8c666a72b937dc79e46c6071f809ed6dded94a77fecd9930abbe91627a99dc93777ba7b7c36c192e57196ba497aa59e394a8ece56a0bad2608612607f984e65e4e1c5a9475ea3e1bb1dcd04db2444f718f9ebf809b19666348c6ed14c52f88156c39e76ccf219d95b9044e293ae38cad5ed212b12d35c8caba94487cc8b342d6429cdd2947edd7240c45a53a4745c401af4520a689b99c74355f47b607275dc69f31974ef139c9de17d1718c57f9d52026621034c3e8939bf44ec91be55a9f6fec2617be7a7b0f3b0f96275ab63e096b93fe55c86b34f256cf18de5c58de6e2dd53943f322a0ea282645c9ee87cdce19a0a1beacf420b6b7d3d39b57736fee39352bd81c324266b2b68220c5b2b3c518626a03ed00faa558420539dc609a007a9bdb5000c9c6e136067327dc0850f58072644116e307eace6d21d50509b940077825aa096c78dcbda3b3be66f53e4fae0c7d9e6fccf74a3131a94b1117c8bd19d80aa411c6f6892f2d2e35f076afc4545d3318ace614e0011f781a564e1255aed79cbf4012fda1b999ed0c8d810b4e92bb647b48bfb908946827509164557a6f78f33a8303c646092955b158bc68c105f4e94147ab5d964a9822a3c92636d28ba7c077eaca8b35fda1571c0c7749e9134352d04e3c5700f805c17ced9b137129c352153a15d23924a52f0331b35c1120d7c04ff5d2be0394fb0478f749cfd356bba390a822bc214448e7d7301d7c3ef38f128365aedf47b019c8491fc32f1debb1d18fd66b870183aaf6fd7ce55873d77af07d4de598b69ab87ead58c1b8e363fb14e2f39eb59752bfdea8acb866e390157429b617997f3216e214b1a7559504158055e94a30fef18b2c02ff96c97b7949707cebe67a1afcb443811788eb1380dc59545c6c6a030994a2a728e00e0fc8b0c6e6ef4091ceedd1b9e2e8a788c0bfcb221539cc73d5e6a2cbbce0818fbd6d5cce76dddc9f7824a6ced876c7c9351f252963eca385e4502b90680b017a5a4147c17ecf8ada882d4b15519575b43702b3806c17d319665b5d4b9b59aa0720fbe7d967ec8230f7e1f392a8a5c982a6c3e62b413dbcf112a5cb9add23a08c26c485881f1a77aeb18c91f905257c8f1c883bfd5c514eac0a5936ac4c9a39e54fac3c3a3b9c13a7c8b9ebc1a9ed6545e12f74cd0cb6a8767a97e00b52b6b7ba1b86d990a1c2c2b6d9c32c3d3be021989ec7b5fe3a9914c6734e5abc28d24a53c83be713c69cbe2e39f2103ecdd9d654cf56eecba8d534aa73faf366b9b20e94e93f89952cf2e5744704e23f1fafcc453cc5a9a9a1410049703cf3604297c570d25c7c0f8baefa017b01d464781f104bb4fd46da8c04b7ba8c26259a825a86b417b5afc403a3ae410ffbdc9c7a781215063e9f5a6c776ede7967a09c95c2e56af6f3dcdf8763548eb03351e1f0325dd673b6ebd22a22d57299dd50990b2a9037ed954dd4787204da4c3cc5737d7e28590c6fcac7192669cf4b51788daa7a86c743d6bc77f228f8c42613ae14bb5c613ac177136b16ad134386c1257a5fc5ad8f928d69bb8377dbb7e3dcdf7af06eab2549286b6de72ff02c7b3ddc99447dcd728367dcd5ec4b2cb344d7e584a94594cfeaa3b6c477544a390f9defef7b2a2d4032b58dcac2a2488b10791ba9c00ce477b61d6e9a8fbfc50dbe6e8b3c6a11ca8cd1fc033ef859412b95827eb421d7735046ddae204424ac19856323e12b5ca3303a5efa170ba67e2cde92661c7c2ed85f2d82853507ab0b14026279879067e3d3d58c056c03d9713ca75330790e5f5a8901c90448d29766f80b62b89ec7c2d29418d43e4551fd4e0fdf343656693e0c466b8d1ea87925def5c886003849930f527396394143af1072168fdd72007267c66e1d278eecf46cf63330b7d63c5ff0ac5159858e4ef38b435043a65babb3a84ff032fb81ea01d3127864fdfbf1cdeeb2654a5f819d83558f9b10394c08065e673c6eecfc42c6c5d1a4c6cb7cc8b71c5cc1a7dbd335d45b99b46563c9970ce6bda87a5beafa93bce787f6894cc34e6151833a1dfa764ed6599bcf70c82e2e1f9c049a0fd572278a91e1ee87ebb220dd799809ae28850fbd23c342ea6f6bca2fa597bcc3f1f9485b4edd65264d5b20f83926e276ec296d80ffa668c734806aca992bf523a9047214c058762d03598c5087caf325c95832c256f14a33cf3207d374694adff0f1dd6653e14c3cf9ad3bcc0cad130792fadbd22c88d7ae747d89fd4ebfd0e7e5c78598fa7288ed58479805f595e0c3529b486189a39aae0d2e50ce19cce6c0fa34317b8b39229b0ffb8bdfdea7532f758d507975d0e65ed590bac38c38f25e0e1e78e64fd287862f2f7a02faf3d4ff39f087af6cc261ed0e66bb90d9e130abe8e96de6bb898703a3ad843f2f5fe3824c9d0d1929928d272edc600b6164401aa490c55aef137697b22f7e41b0b87b0ac23a0c9b05cda94c343e2d0332e22e88de4cee4cac67adf0cf04c778327cf16ad1cb98c913439da81537cdf146ae6f01e86e74d9b8dc3adcf173f287d70683b0d7a796c29d32fad78f982b76d4270b09d773d0954d044bc076c84d65df28c651dff7e948ee3147919aa57bc75d2eb2dfcf5430d26e980801760056be9ddbf8b12e248515f701d5c548347dfadcc0acb426fb0fe408b9f6193b8921e55a396c681350df6edc4ac8cca7d77556bf0e7dcf60d5f897b614eb7fbe5476f4e2d1d86d28f7ae0cc03b067bac3aa571dabb7af9e2b88b77d0d0221c7ad8e47a2fc3e1db17ce7987151e09fcb4d661664012bcee0ef45a3b0c62c511a1691d051e866dcbfd7525964c5b15811ca1f429cadc4a70ff376f8db8d6f4d073d08b91454d53715490e21e5b656a0192ccd635f69b32151abef39eff61639ca2fc405017115656359ec89cfab8c67b0324a6d29738b6e55e28a824f764e8b1e771a109cf6198f628e13cf8f60579d9283d046374e5e538db25ce03dde3d80cc2a34cac9f7db53c4a1694ae2eff8f9ec7213cdca73158899211a836205708a8a8663c5bcdd5ebf8ac6bbc7dd518431ece5385dab34636cb4b586d26ee2f7ed1bbcf76dc4ae0cb441bd4811bd2401324fc6465c66e1f53958e2194b7e5b20aca9f7041f587b33fbc2a2aa227daea4cc492ea37040248f8017de40df141aa2a8a3dcb4ff8e9f8251725a327af480317e9db662785c98e0d905962cfcc277fbceaa2635f065ffa64a77dab5d0c37527e3d63467d05652fa4c5eadead161598c2f5bd44ebb46b3de36fa83e278a6cf19c6666d7cc357a04b1c3b7d954031c48820f035ff527934d7b0a5987b80a6a50b1fcfbbd215cc3e06d4cce6b0b3558fc06815a75d7c0195a2bb1170bb2b5b2d8952f7eed3ffc15a1be21ae98362ccf4a70c6c179a71e0647c259fd8e7284fe215aaf04d018fd4b245894acc2fb12dbb2f2aa8e6c7703b57f5f1493904e911b0053669f37393147a3ca23f384e8b345aa0e0a454597091d0ee721e3a1703ae3dafbe7009cd9ab752acfa8abe72420344d9f868db07ae2b766d274acca61d5d2e964a77d0e327412219bfb56d476a54d5c5b2f8e0be8e99645f4818f213e4ddbfe8302af236552ba04595af952ac6bd5467402e92089b30e1f2a9bda42562213526e5f8c2eff73cca723deedbfe7298242be5f2bab073b89987dbcddd17f90b77ac55eee7e02681336559a7053163fc628e949f2d1dc3f8528e496cb1a9db4f4431a8db11b91a0f03ff6d73c2e9dbfcd185b9b611abe9da1bc643e1a00a0141461960bfc4d023a0890812e8c48f40b12f7ffc8825fda89baf49b13896a09a841ab1f54b05d165626a9aa0b15091e37fd85e4b396c945a9d963c9c0165034c1da83f34ed093736dd4b69ecdae2f12169bfcfb40043cc8069d039fa77bd3310f0c5e3a5238ae5cd63ee2e1a8fd96928a73630c6c1897804833d3fa1d87195084e4d79ce921a90712ba8c8331a8a332620043ec6ab6f969a940fe0116694e5569ebcfe1a1009710735314d0eee5103d5b76c5a93da04fc7e5e66661a9151734db95b434368d4c976ae8e42d30239d46778e966477d6f5c50d9cb6e6a7d26177be551b45473fc4c0719da0bcfd5075e0970f9c8c6e3b1ad79949965e2a2b23a082de2bfc008125a1a56b5933a5ce6ac96f19f811e05c57440f531c00241f31563aa98ca9a95c98da5f7953a1959903fd9b8788f90c9f1629ffe20897d5e9bf006ffb57ca4614802696a8408b4f975bdee7824f14fc88b711cca93e793155bb435dc531661b4ee2b2809c6f48b19677eb04c7bfb89912c84ca3315f702968e9c1c25923b22c67be056f5b12dd11838eb229af74529cab013775b6d54638e4ffe52460463f8dc242b271a9b1ed71fae7ca3db238075a1763825856da947e87a4d7b5d2edf9ec59103b0546b9e807c30acd365a98d7b2e58195c58b34186da3fb23ae75a2cd3142f324f8413c895caccb22fca3374a1eb417aff662bcf2093f974f2808b516a17b5e13bd00d4a0739647293cd8b69aed204c9aea37384ed7ae3fdcf53073ed417c38b02159ca0795517a6a58c4c13de0fb7d7ba66ea465905f7eebefde5a83aabf55146cd731544f0b12389616b1da310ebbb32a3b317fb4eeb96879f9be0fe18f8a1d031bd6af952ef01fca84d912b6dccea9a7e23f2471d324d0c4013a5c431ad6f4a9f91f2413183cf60a8d00c204589a6a16aab1b116cc491a035c237866e94a14946928379c1fc1b235f85b97c612d24664db40c101938f1a5d9e6fd7b44d04670c0936840fb32adc193c148c2c4dfdfec870520451d8dc80cac4c978f885a412012c5d345f9e5fd8c914e51742a67e72fe8afaae1ccc0fc8f302b456a6ce61cfbd2da0dc97544bce49c4bf707fb535e3fd31c06d2f5e57e3f911bc7558245c004155e6b30a253cd5e44318ddccccd12949271c480922cf00d8464778358606d71b656f22efbc427ce73b8c07db5aa003d34c6d26621953be6de76d17ee01a7515e41c8d0d5ded8ab76cc6eac8c974f7dec92583af24be2039c3ff95728a30685dbbc366b6c7b0c4ae5e76f328d81229b55ca4a36416ec2b03f819eb2d7509ba37c0b474a15b5a9909bbbbfd9212a950914cd2e1e37d2c79d689e2ac2ad78fef2219a935842c70ffd045adcf5f4083c980be9ced7236223d40a79feaba7c3c5e844760977e3ec48d6df988f886ec011f2c91a9af5927beec49d7d4d077a9f1fbd8b27ed0046bdee6af851f187a47ea7a425156825c74039abdffbf42b5ba4979b5a5c44124b47bd80ee56b7fe02539f2fc454417441c6ad33d849f62f24e6f743c175c0efd6eacadefc8943634bdeba4b6c6a6448121ef53f970a887d9591f13d83b8d4c337a198836852d42724088588f6c0f5632663a447db93efc3bca6aabb4ba9926815049410c17fdc8a94daa7cb8f22b37f58b98ae3f4629d9c9c66285689e5d90cbeb76b8f4e2036f759fd6815b868d8cd9669c57283cc5acba62bb07cf1cb6cee83c720c1d60bf234dcf0b4dadf920dde478431d28baa70accd9183af05fa1099a7867a2350ccca2aa18ea7a92e3108b11886130de9bf4b9b28ccf7d86bdc7db5d042a6d3efaf6f94bc4984713f1416ff7443e2df80405f91769669160489cf0e50d7e6df675093b920752690d60a4cb19fa04cc72ac457b2e2035cfa0f152170c457b7540fafbc77597e50ed5065bc728983f8ad10290751b90a01a5ba9774b96b87307c9e143c7c4710c637d1730c88d70675d04505b1b8160b2ef72c09f8c39bafb1b54e240204d4bca2d8eaaff6b6d2419eaf3c71b5959e7461398aed0170fb2076023823794307cb154bb064fecb6a76caf557015595dd821c2c068d98260bf510cb32432850a81cbb32303065d3e71e9d4d3a9c7100ac45c31138bde1196a28d73ab07c970fa5e3c9be07bedc4ee50e8ab5c9c3079732f63fd44c1b2479d07c1270446c035b592bbff12e809f070cdee19ce6f9684faff9c246dd45b509541f3e3fe2f97adb855a760d0d4a735f97aab83602eb0f30977e00df491fdde00683d786ee50e20d58833fdb869b6f5104f618827774ab15098e8aaa3e9791f8203c162311b8ce25e509d91130a104c1daeaa6f6e60c62598e96131ba84d085bab4b18e4dc0a8c3640b33985ac5845324a3473f1de743c48e9ecaac45e5c8b504cdceec36048d9ffcb3eecc219f60a530a53d7d7674f4cfdafeffd68a9e27fd5f41389f3c84c6a971621f22cf3998d1461100a628c7b6387585fa14c6fe56917e8c16dedf3b9b547d9944a0c21f1189f258e52161960d9589256a577efab6caf8b0417ec4b5a185cca61a51e01c970c4f85ed306860e265c1492c2efaac2a640b7a3775a38979ab40457c4a2a405ecdc8a66ad693c0f7c38143963d7b92714e80057a3e42d58d3f1f06b31684bae0bb37e359c032fd5c15ae0be8b2f68eeb498d81bf95693397f14fbe1ff1a50d75989c0d6dcf66bd89fcef83e6f229afb301e72a9fd49fcffe41c5438748d8b77ae71d637e5a68463b35e62221725b0c30dc5d27b958013b3c52fa8fb0653bf01ee5b37d80e82d43f144a8f981aa24b24344d47d74bde16aedde14cb7d94120da59cc635845f7da8a9e077a671c6718c655bb330c6b7c4be6725d325ecd98751fecdb0a2a8b08d707d3fccd04768295ebe97afc85ef6d72adbe0c34d06307bfc15bc020a28701fafde109da77a1bdc184423c4e73a82bc6338d6ed1f04a1eeff0c5270a5a6e1fb8ed044d87271e6646c1d88a67cb0004a02a547520cad19d424c264db6d9c370a010b57377e0132a53fde542251136ada40d26fcee3a7b0dd73c00e23cdec04a474c70c172033d0056b024d7ce883ed67b42c2f2e46e0517056bd7eefde5446b38e4ab08f71c43a22a4b8cc7fef84c4c125dc34e5daeaba853ceffc60ad33f3ad86823799c2a86f6d4c61ceb8a60e8ec52e8e2668a4f68b7f7c99a7354f10b4cbcfac441526729cd9329d2acaab66104342f6d24bb3699dc2b2ec5cee5f9b12401d32bd0fce53864fe586e07e3451ad8e0abe5e91f199be62e32644667a9f78bbe68364a168b1b74874414acb0a84dd6d04fecbb94dc24e9972745373184d40d0410d946973d144f029b80c0c41d71e396053e14258ca28621e9b97bf71e7fa06dc9ee6fe2c594eb564fa97f9ad7c106eaf8f532d5972f8eef6b79c6469ea95ffde7641f9866eeb4fecd84d2b44d383804e365a90e48107b28ef21904cf96f9f3fb1d75d7f89610a428cc9b6b26ec7fc3c25a2043a237b8c019b3847c4d6b86dd3241cf1d1a4f2a778217804a5bfdf93f4a42d6c1a2c77ce8384935715b6ed023a035f61652c164d2888da5261cf85e1badc2e9cf273c952586312efe0c94307249703ea0eb9f01cc0c11588818d866bbc5a483fc30586fbe1c47e27cb6ef53d39729b6728e0c8673899f6ddeeada2e91c5590a9cee74f70d29f6353779ff265b637e07be5a2e456daeab7cd5f0c035eac8159ecd5e7eee7955e090ac55d58f3799d61816386dbdfcdda4ea07975934a8676ea217a04635845589588b53bc7dee12f5f2d308201ef9dae8e4173c25b4bc5b95369a0dabc3592d510ef6be0250349a7ee8d49290bb417f6567b2b8aeed73924dde636380e6a5932b866c247657efa4b677a4db5a10ebf5321c1a73a8089d6024aaf1ea8a2f80ac150d24a823b95ae683ef729b0cf8f80729645f65bbbcb42dd29a4f9fde9c472a6e47b9131fbe76c3f25acac469fbe557fc11a04518b966d5165cf74a270c94b80cc95509cd427d2170953d2da367beb7eaf6cb5d44c9125294e0035b7e05e8709f2366b70217d150baf5d1fa90bdbf10641bea96a00423ebdc0fe7f08848dfb5167c8d2c4dd4b0b6bf355d2f0465000fd8b3b2ec87a5822c911d7986b46bdfceb683732fd3710db6629e94f1e2dea7be53bd3ac327250bd201b19749f8ee7b3e158f0c389432314351d9de69f51c167c3911ea2d3aa0e04649629784643b05d6297ac417452060aedcd15f0fbcac27cd38628281a65131b76384d29b31ef457cdf3fb6cece12d899376db37f87dc74cf7a50993a71a38342b96ca16e563c256b9c5a3ca3dec898d8068dd4c93f3dd0b44fa93d5d48cf22df3bd1f2dd2cb5e63964e484d0ecb5b42f9a07b4c58ded3ef2834b6158c87ce3ae08bd3465c723114eb8edb8223c80168c7868597040d4524ea0f733672ed90dfa2f8f560fe59b9978e8b19cbdc3e9b8fc88ff5adf7065e37c1618c58741034197a0ff6e281d01fea662fbc09563d3997f62c4e8770446534fcec30a457b5ac664eb1730fd2f42cd1ffa4bb9144baef177ed2e55442cb2121b22e62e02c5ee7231176aec7108f057c40777fecfdf73fc8db561289099c1a3c936b7763c288a73ef0b05c3c8719221413cb2b52fa76f8b4416325bafd248c53c2c5ffdd6ba79a2be9a7990b31bafbf01632652741f0df5a613bcb70eae5e7e3712e00ad5add984eb1d3016f045152afc1d70f575bd7d078a30769735f2667475befccf92ace2317021f323fcb8ae1e1862b9e6e015d5791f209869aaa29ef06ac824fda96ff3144a2d490b730a0a8fde0f581c910a473639de1984f11aba7e9d1d012952237269c09323633538d5725e05c0a6c2fe19f58885b822a0e03ab9d63a206b0bcde3a8ca3c50add7f4112a22d7fb7475526f9ad5928bdab49243c515e33151a3d0cf3d10ce73415dcb1cb8b8c8446d44aa3a2db3570f206875cd4d4a8366c7ff4aedecde689c0f4fe675990445445bcd5d37499d9294dab275b4c9c1ad068e9fd59de6d55bb6f42675e8cb684b28e2787e828d4c7b1cf160e82adc631eedd6d8c49bda97f2b2cefdc7a98b104bf7822cab7dcd8ac70cf00d7f5c1cb3c15ec0e3a23d212c66d5f04f94a62a322961953aaf4f96e594fd925e97283a8d7365293ea98daf5515d619ac57811cbae871f3ee688add70414d3b966bfb2805951bb5e138d78d7ba9598ff20b60a554bc3654af26de8975a0224117a6706c9be02b5bee02706d1e72f8cd202191504a65734fb77b9f32b280050c2fd593304c53eab9bc3ad7d505d6132087569452d282738a55eb83485d2f458da6729579e1d8d27a49fe4d5d51ffcec3523ec3c7ee8150bb44ebf99a402ddcb35937056d599a68c3d5ef659c9a46dc2e92bea8feb51dbf272e5b1f9c147012b99fce87fbbbb3a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
