<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4703b7a554dae1c111a725cac5ec95ce922d254de8c433bfa80d3087e60084089d7c535591ff868f174042428aa5be960276ccb4c6780e1f55bcab2cba0c1ea6eb0250b78adb98a6404454ab06b2ac6aefd1e1177b5c627792069a42325afe37c7cb302c4315f39841ecaae37b325fa7599c8a151294555ff5de7ab5344d6e1b717a72c93ca3942b24aaf1021fca7223afc16112c188b9e992ab74cfbcd6d9c1792c11f7248742389aa5c36520ab37d47cae604a1c44d4e63027dbb4e2ddef4b7bd24687e44f625720458de0b743738c3edaef5c0dd849df2e8aaf354b3a10ae7ed350451c826544aaf2db2ba57cf3bb0ec2dd087617b1f4512989b6323b49e9e5401501f067c4ef41363c859d5b915cbb58e1bc799660c6335f4368fcc2d85f0459370ec0f90e803836e7d3cf5940cf835c5829dadc9c18b55097131156fc4e065d6dbfc477100fd3cfbc392aacd7de1737d869a69c9fda997febb29118465d774a9bcf5db0504c3419bfc548d095ffbac58405c4dbcd93fb89d16d407af99108137eae4a1a5046db3f37430810d14ab03eca7f34e4a3e34f09f127c9ffce7133423dc258efa2a7e53057c689ac55c183dc65c41cf979cd36e9d916b8b1bf3b39865fb7c0c3c63c06ebcad97e2adb1f393dee03bd01f08d6928f6eab08c95b9ba0893bbc2288527fb1eb06b788f0441555ae1b49b809d4f8ca65783ec5dab4237b7ef867425ddc026e682958a0057bbcf97f3daf32678770ecfef5654c07da2b00fb79586e4a1df59236b99b9600915beb0cc17a55f335c5a80a6c3d044db3ea9471b7baa7efd9a3f034702893a6caa229b8cdb79711d9e50f4fda782aba4068719725059faf32fa71d824c35f066b1061de93110ba33ff679fe2bfcee7b20015f484eeacbb3d7644feb9af21cba1221653acffea0c84354fb37935f2613cf8c9c738918c7cb2a04d297a4fb806319d178c3c5af7a344c1f9416e8a34cd8427bf190bccf92ca028137c8248355f4b0f574d5b0243602505d3885af9d4dcb3689b46220d172250ea0e3b60c9f6d6a0c9fb8f2c066c5ca5f04a94b9d3a500a372f3e50dbb4675dccdbb9ef359901a6ab7167687866934221d9a27e4bf722377d906be2bbf033692d9ee1baf712426a2207592663c52546725c6df51ee6098ad75d5819afb9b6d78c5d51392db4b8b0294c5705e418e1d9cc13991cd93ad2940964fba6aa29fe7983a2371f2dbf7b8f8d6526f287424590579c9e032d948976b697fb5e0d80049504f6eb6a6db9f26cd7fb2f88eae74da999c672233dcfea8589558b908025d0097e4560bae28b395a63cb781f5957de3c22058361d2587e6d95cad291802b2e7d24a032d8a62c16639a9516a961c1d154d20eab54e9dea209cfb56baa0b82717e663898cf75cf14b4c6e527fc409a8586d31ac6f99ddc9053104c2f0ead5deac7e640605aaaf156d35aa2cbd540c682a80a23815f41c5ae9909b047cff358e18efbbde0abae57a92858402fe5536d9aab5f7a0a0ff2f923d1a239707fc64ababe0d24feb0ee35f25d01edbc282928dce70afeeb3e08315ee19884933f129b7dc9d5f81367a169c2fdeb667643d6cf08f44e020edb29f4089d2b7d2a885eb137b14f5226db9ee3e15b7c9c4d49d61ae3b6fd17b4130ca4fdc8aa59ca4da732cba5226b90a276bfdcbf730d824f0ed434546ddd314f2c09e710460a57632a8dee26e15d93e589247c07339e7daa1696918a7742de219703e78cbba440b168095617335ccec86f817f45a161a81da2bb03283eb5b763331dfe1471abd60b069655ce169a6dad5e9c677ed42a18b3a7c4b63b561483633f025fe87ca056220cb383a7c3b41ef62f61422102eb985b430935b234b9de2711ee98c9f097abd7f7af8000a882f37ee6df8b4c4577fe0b554b7c81df8f0d76560194bbd06bf5656b9c4a364ed716a0956278858c4f00b36e52cdf658f4eab13058d00f2ce80997a09695826dcb99d7a7f491de169d0a6fcaa2fa5ecbe3a3108ed6de7c06b5787a61d4809eaba22e2b9c65424b52ddec042aab9a85b4ce9e0c521193f6b11f02876c7eaaf66d6453ff9ad1c291c3ff5c223822e94090bb67d03b3c0adc3a44ba1ab59ec0a767da5dc39e4e9838f8f890d857432ea42f3f27641e96e70de39e84d48b294504382bc614a8b34805a744d1e716297e900e5fc18b3bc294c1a0ee1dad63a5e07c7f6b026d7ca70e8e80beaec2d28e64832faa6f7b3d9da2a1ac24ae80ba4a96f38afc700ff5f3e69b08f23081a6b39b7464d03a9969f3073f93c9ddd09b6cefd3fc4378f4437b61bdf81f129d040db01368c9644ef40275315bff9a5ea79f08806878989672236c0bf2d3b79d013f05f47a5fabc786b98bf624283727c5af2a82225e441c93a21dd54d417c4efd324eecf926f4405b316fe8048220a38cbfea859056f41d02fb25a4e2f99736273e97f23dd404b85efb31f7b54be5e39d451cbc68a7195288cd3fe2f6411fc602ab845756b276f1a537d29012609cd9cf1fe5be331ef167eafc5d5690012ffa191891ee12da27e1c63e97acb073c9c5d9b2402ec9105d51ae7a37e199307eccfbcc6d5d8bb8590eead3077d5d6f362914b3c7178f5db6a9933dd129b05fa459a5a96a8e3138a9d2e24b053be92979f3fb14f92a72d5924e11dd971aa4546fd34452bb7e7aef1e1ab0c32a7ca4c45d06e03361428a739882c86c7d59b54d9b485a6227caf2884b29c8ec528564cd4b1a794a0d4e8fd619073196268f1f519059b6fd5ebddb699e66d94ab1705ce557f9b2ece7ae9cab32340f0c2ae9a832ec3e6990e2459a59b1c1fe4878d09537f9c57934617ab6676a8a744820261acc134a7612f964ee8fcf65221aec4c60b25902db30a083b318f1539323c5856fea22f4a5070dac764438c782e8f8624130fd49ab33c8aba2e8b5aaf7c5b94f7cc6c3ea32f268534996ea2ca9fcb6ee04021c2741a0d6ad4ec32e80d8826b684ce9046115994c0a3010676260b2af625bfcddc4339499401832cf83307fa1a25364f0c77f22fb5ae121a603c967d2909f0ea633878fed8691b449679a72900cfea7038d309118097e211ad85b51383a617c1206835e874413e9618f4acbb4d5399ae4f6c21906b0566e4764821db99f5c0d6d7de78f07893a97d68eed55a53d433a23e25a15a47734572d3520676bc67d4c89c7891ac6a5befe9d3f817893fcf46c500be51cf5dd2446284c76e9be359fdba2ccaff5911d1e25a77c068e89bbc468a20c7e456e420b628449effd53459533edbe1b01cdb457ef3e06b5f1cba6f0bfca8d270b19918c560e8b16d923778adc0a1914913d2931986abc6540d760f1640e0ea138234606e3da4cfc18e63b62bd6f053cb931e7871ed9707199ccff460c7ed06af82d548f9c3aac51855a866aff45ff257c694468e4bc24f660375b4725bd4471e32fed8a63717f3683a37d2457e7bcd8a0cbe28e0cacfe1a5946dff4c98bff2a16d6fd4a8e953460d337ed605025132be90d0f5824bcb2187389aeabf4b5ef702fcbc369f9cf6214e1988924d36763fef1b9cffdae23285800289c63a0a4a444e1a3afa7e35a8d2c67967f7fdf42cbe419e47fa59dde842ab1aec028c701d781f13624da4750d266d8d4a2d4d66748ec5b39438c9605f1f56bc98e8ba4cff2c2bfe47475fed014c4f4e1bc2549f8087217582eb57df7a71874f3c2a3dd513ad974a9f645c6e96c1b40f0d6e958cb62bc6b56a87172136510d7d7a604f3df6e3ca6be19f1b006fbc13e3b151a32e5bdd98f20dbdee5fe56174169a5c8f56677162e70a20a6f61299eb35cbf2da63fcc186cbb44517017e351b64c588c1d0b06ef6abe6adebfa4fdb154822f63733a66ded476d243e768e16e6220883a6b75ec44fe7f6c2a3d245be5bb9869f273a887d9bcef714e663d5bfe80a0739d5c8cd4fc78cb8dfb194aade227f0c9922df7d40f91a343d9d8219de7497961e3cee9e946b0ae1386e83eaed30dd541f0112f82924cdeed81c22961d9a5aad07d70fe93975b35cccfffafd5849024e94228e0168d0e9e2ee51ef1f054766ef9f7305d34f8b80c136385bda7a7ecb20c3408b03e8493a4e4438dd802326ab05e28c905e11d1b8924152883309e52f6deb42e60b82e1a81911980f452eca540ab2cc8078f42afed5cacbcd6d46fe931261fbaa73628d5a64bd90ad26d195b11229ec7a8f2105e270ed97be479aca60e0eefd6cb116d9490095d57ab7770bee19762534b275e6c6626f21946e7c478932e42abf7344f8940b4b721459810d84b9310ab2e9cd7759c92ecfaf8b5cf4c769b01e3f96764b5a44cd82ce0fd3e794da2aab337a32f2bbb8630dd3b0326dcf28ab9c578c3dbaf204aded28b6a885140eeebdd6cab44824469a64a32a783ce2eb5802bba162bd19a6769543dd840c9f5c4a548982afa6c282368f30b83533afe09e8e35e66e9a65ff913eaf6b54116d4c34bfb6f82c6ef6155e8f79ddbe236793f41e295e55baadb99b2b989581d6f1358e352a91be4234a551cb3026773c8336177c04d973e73e6e6abdf2c99032d5d3036ee3ecb32d5ff488f4003c34aa5e257316c1fd5c57c9f93793e6f3d11aff203cb41c22b2995c57aaaa7ab851ba054c63f2c0bdaeecbbc8d04b16a8cffed989133ebb91c4b9e5f448c7c69b12b794f441b3504d3238dab826ab4394e198c4a971e2501ce3e3eda9d88af618d173abb3bde4487108f30e18af557a69e40bf07c981af9b3df6619f037112cbc2acb1bca8c0a71cff7636d1d6c855c8e05cd5ff3d20872c82be9ac361b7f4a2fdc567a93d51be5052fbd9ca2a00fac34e88fa0830e18f605ecabd3c8f6e2cad5cb3cc2dc50b68ba8e9d597561038e2d84b8c37cfb199c1da990a8319b2e25f45cc1d80128a422a739431fd597340b57e5d50a32c347a7e2b1866ef5204d337fd4a19c724e008d6a946d2217f33456c4df1f52e2a0ea5215962e6f97856d1fff462d50e3a5ab2896be1bad1614edf457c087cf536e248d5e12760ffe9b2f8f4a7f3926a2827bd7275239eb3c7a683b158e8e67727bb926ea83ef24be65cbd2fa4d76b6e17eb45318df3f7599eb2d15d71aa83bfd47e7619afafa09d3d4ff7ed06f7dda0b605bf554581341c5f8f41496daf1a6626e885735064984d95a6717eb8ed0ce9e426122209371d9e8a0b440f11ead35f56240e137666bf8e56f6340da16ea71508d2fed9654661eb0b4c73342e657bbde6c6e10a18a800fbc5d84d4c0935768fedb1ff111c1a840d9692606d1b90e62effee31d3294cf3a100aa23af497533b1195aa86138af4d5ce4e97a30d50df151bcd037393af90484f2a8c6d81f62ad52d0ab2ab85f0c1e712a533ed6ffae8a66a514f58dd87472bb2dcc8cf09692b58e1a06f327d32fd1e0aa03ab6f14402e6bd25d4bb8a5a3b7f05494ac1d12f8c243d22b1307fbe52432076e2967f91c0fd2265772055066cb8a4d5d20c4014166b52fdd6c87297e333a4e1ba5a685d06efbe863774e80cece962d09f3aa6601c6891ecb7a178ccf3b3ccc60537e9b3060d0c92114e87da9dceebb34b19590ed3866199f3d207810821f79687fc4938353a4971c8557171c0a5e88214e03f8ee6ee0dcc92148532974ebcfcbb7172f37b2a1002f985029b9d400523f28816ae9db8042d0cc0efd5fef9b98465acb172a71aa6ec94955d253227fd69f75cc18d6419cc9043bfd46168fe96ead66db46b263f8d957c07ff5c03a2583eefc357ee7b78548f8c3f748c0e6d6af7572764b899bcee43aaf406374e8fac9e96c150415cf2de1ca3d5f2fc519d0a81067a685d72c5fb297c50b7537c7e0c29f35409c0563008cd230ba91b0565aedc02332343b92cd6525236b1cd866ebc4666fa0580636efd22a6c5bcc548537e9bb95a016405e5eb84d708fbec7b720f3c6a20a4d32a3ca6c9c9f0f6bfcee840aa01d8de6ca3a5f1b3a354bf5bcf924f71f5c81986d1e7343e93c2513cc3098293534fc5f81938dd8ea071ba387d2ab6b16937adc801e236ef327feb145434b6f04f10f3144cc0bb13bed190327e6e8087092f53b24f4258f0e9a5c5f2eeaf9552c2af9136fb2a7210a1d7a2d7f09a0b8735c7a4873a9cfc98625e096f5db79b71ce29116bc05215a1ac588e40e77447ed322070fa22327416050b809fc1539ba600a443d6cd69bcd73455c7c32d2fef42598ed015ac52f8d0436866a0797406c98a02747af92c9c70df92d82943dfdad1542ff4b3d316254eed2417e284b47e7857ee32af8d667a37792ee6d02eceb7820eab752c28ebc7d42cba385c0c53bf7d24780675e046b432e0da2ae135c058abd252e6cf84d1439a58126b90d3c4e2fb89f18d6ec05f0c88be6d2d33218ed70a9a046018f07430c7646c4f288a096ef1e39dd9eb446fcd6aac0400500c0c779aa914685990dd267f4a4bf1a1174d0bb3930ab1928ca0a3fe658fcd1ed60888d071a093aee6db1ec23c84c76997e23399c9c84a4eacdb883a3854dbd5348f0ae99aa386a33fbab4b2550e1df09ade2b12d0c2a5b7dda10c6c9367bf25828becbd274ed8fd730b207695372a629b1806271bc86082f84c237d39b18b73974bad38e2e5c32eb6a7cdadb00c688a072fce6f34112a076a6fd49b32e4666396da26b45bd6d9760dfb380895d18e11a5f8bfe1d49926ad53d8a9ca8d995c23c45db79f7f2c4b80f2fe438cf57f226b67ecede6cb90b0230f0d75a4316f4a9f8efe41a0703add8e0c2ae0d83e0687fcb1f591de17bb2f15cbb53213a775c7795c05d8184bf1e2d4c353ea459dd597b29c6b1e18694d30efbcc009ee7e3ffebb1649d708cc5a9c09de35ef75bbc9e3d22715023836b0df6d4ae773dd0cef2fb9b064d59dbd05a06cf9f508197cbf1e55838d5249d458b2456341e0adb8a1233bcaa885227a1de98f58b1d27ed00c980d5dc3ca40cd6828071c86ae88b9c3239519acdfcbdba593aa1fc45cc5c15ce0d60c5bb064ceb7e6f208047082c28adaf83e3414a46607e0c4a18c237b41d912b42d54c071919f7514a8434a9274def8278cf194c713c385f80248be53529b4520c187bf5ff39c04845bd78ec7219792c349c44b86b0a4bdb00afe09f75afa57e5feec20740db56e1019f705dde9a0c4d6ba131b844ec485b46a69b396b8b7b8208dff5731a5c8246df35cc6e2b36ad555541b243db52de589fca8b3e075b8dea0843a8c4555a07e135bda642ec4dcecd2d6a49f8bc1760228aff8dd322ee22a25a3a430c81f18ec58158a14498b39bd9baa842030963c9a135a754f94aa03a7c5069ee995666cff35ec8df2675a721f4a55bdc210046551d662033560ecdd14e6c0e33fe9855eab5f0ce19fd103267e309e70dced8bedb44ab590ed6d72fa89520def56f81c4a5c10d47700ee1bbe67ccd2ca01950df57b5aa25e4c1e5525ce5ab27ce73d435997691a52ca32c7c5a2ee872e6c5b1abc867a068ccbdba85d865ee5bdb996b9923a3ce60ae2e867f579722a938478b7595d81959b0bf33d0dd035b43bf90e4feafcb423b520264446059b6b28db9ea0612d7f73cf06f03e825bd75d7b04473b7f706850e272581a4c429f5230b4489fcf4bfcd7fb7707f1813c407bc7229811a19b1e6fed0d159d18da91bf0dbf4a9bd97460c4db47c324c196053c534cbe1c9081935619e8228324798abbd01fcb7e8d18fc268ce4afdedd39d3c93def0834dda5a130310ea44116f275f76172adf180f2b782273cf9b24b5f388f942b0a753dbb6d6957c558f69271d3812c7636ea98db7153299e78f552df8f76e07f07289564c61ae634bf7816074d7565ef42367078ccefa622d802b422eb38e4858f833b4944b9371d3acff92da494113a79a864abc72f3bff5ed824b4c1a63a145b10a3858bfc81563d0f0d88cfe487c4428537d778a5c76dcd86b484d04b2838ca6b14773ec4df935141ac764b66bad80f16f70e7113f942ae36c7fc848afb1580d5eba49560d8759a29e1d505ac772a695b4315ff3f74a62d9a0035e805dbe94f14f790f61ba682c0a8b236bda8cfb9164bbdfa44e76fa5c9e261e903915e5b41b7715e4cf23e4462e6480cf419ff81dec37a3cd0c023f2cd575bb460a38b17addd24cdf2980b449e88af4e457f0a6d9254fd7c18898c138863630fd8df372fac9fdc4ecf88ea98ca4b3719c47d95fd203bef9c93a2ae35648dbbcbf039feb8c25f9ce43ae1d8756eed39fa6eb1d21e3ff794c2403a2ce3f1cda471a98a88f235ced04cd34fec8f9a7642808a89e43143cbf56605f463dc51b54ee475bf4b94b61adc9e0884924b18e613d1f7a2e9850fd085f79f630ef29fdc5c3ba41420bafa7cde4fc1c80c946d876bfd96139599cbcd623397212db56ac3fb8f1b219748ecf8d77a10f239039d02ad7a15e35235c6628ec89dcb0c9e63d34003b8f30d353c1a389f65c8e92b2267b813f0da3024525358258801e85803417959cec4fb7055407c7ba85bedf0c0e833ee08ae8555b5d4fbef180ec144b3b1e843f6c7a750094296eff95332b9527100ed03323d1d8fd2a32eba781996168d7d33fc400ef31815ff3b8948bdd500292104710274a2568fcf55ee46bd444f6fd93d7d890bf30cd2333e2065e674d1b4b915064dcba72ec9b751a2de410bf00eab213fd2c81fc82260cea3a885ab82d1b4ca08b449f68d50601f9261dc1c5cf0c95d20ec8b72c8ce267e24033662f7efe556be8ab702bdf0b7684f806f64c9362eea51bd7a8202cde52ecbca01abfbfae8f84677687c48fbfb6dc8101365bb05b4e82703fa82bdcfb2cef9e4ddeaedf7a1603b6bba197172bd7faaa3702056498b1340c6e0f2cb573155eb8fa4843be75bbd6468f2672a6c2c8b9ddfac9e11354c8fe0689e59bc46b578a7906f8434c9ffe8556fd26cc187a6159d5ee9a792d7ba7fef8eea958f2c12bc1c40464beb51be0f5dc0c45b18ebc75dac559d19797e87dc5249abdbcc8feb45d9dd8874ef214f65c872dc3e786eac715a00fdb68f85232e28ddfd466676f3e744981ecde09f3b983b21bf0c30ef3d5fbc490dad28dd7e68c7702afa0d425aa526da11de08683b415db3261f9f3c675c10ac6b8a8240ceeb4eeafdbe54beb96ea65614fac4734343bc7d7e830ff5de341097dd463217fa24d41db41b3e40bdc38aed53d9aba61dad0f702d95c42bb4243fee428ce666a3e0c02305e9e9daa75e1d1405766243694bb0d30a17082ab4d66d3b2d49570f364635d79cf4e551171cc78e6f543a871aa1adb485c0795085f7250e7f9ae2d21c239d2261b495144a5ed5c8ca124ca0600b78db3cefef8b93699f595f3a67cbdf4a4f782649be9e1d27d1f287e02066cfd1821bafc8e1004fc91217f45a6d49f9789b46a1f0b90d0a9f29f3a8c9ca0cc2d05c7be30104d48fa8b137e775f62eadcc34467c32217cb3245dbc4472e83d7e8b80b33a1b2633703a0545ebc175248af8872aa024ebd2e9390df20208e9ecb41fe84f4970ee0309caeed37db405d20e428716b5844fb824b8338028f722c240cffdbbb3c23862da195fb2bbfb85a1153149d2d853a58ec80949af578c79d19e73f8bb889dd5f591182205235cd336c52f4008e1f2c2f29fbcedb814475dc1f92c7c372e2b322a41a1f65b22dded84a56e356d3e5db5e2608b4d25680ba4c010e36ec9fd9682b27550c540cb300731e897bc8b0f1b5303454ab171860615172166c4542aae8a3184f1ed3ad3f5402274582bacefffaed061b9092fc5753de9778650e8298054350a42768554dff4fe0494ba54d4710e1ebc4c0dec5a00bfa05ab940847d4a587a6328f339876faaeb959dadd9ffc97aa377ac9e2c9d5ff8bf2da0dd7a9da953ab2b1642181f929a980e5a35af2ad05a6ad5e09a95e049bb4b832a6aa529d524b139038afa4f45b89c11bd2db63e1bc00399dfd0f5f72cbff928e90bcea1dd41d0dfe63dda494debdc9d5edd16859e7c04e871870781f479ea79e3b98f36ef3f62c499624ed702785294b5c516a0f8e4e0a7bb94b785a3cb39ddb4195b285cbe8f7777c17c6e094a2fb070f4f0db5ccfbe3d0dbcb380bc338d69e200d3957c09caaf4072610c0fb540748b948a9ad8c27d0e05e6a14ec49f81eb9b7ba5b0b697cd1a38170fa40502c2d17ff66a7cd78e68961281d14cb5534fa51449f80404ed9a518fca5a87ee1368fa8043f3570a51218e86890fb0b465f69b0f9d57034fb50a6d7c7e69f0d6bcb9c85e1f3d8a308d4079039ea448703558e575ba734b179b9eb6af71c0991269346db6ef565c2bdcb2a5c35a22c2b36a7e4d564bc0a3cd66a36753b19578a1b275e4dfa1af438d585f068df6d1b94a27d87e5d348fe17db8e75e617b3a839b4986d5c19b27adf2da693aecec74bb51040344be4a321c6b1bd8ba0c0b260141e3827c2ad2277959e40f0527cef03a7ad54212e4fdebccafaeaf72c051093743383593b78f57414172a8ef97df103795a46ef6210c82b77d14c09a30d6d31c82944beafaa3e339f9e751c8322666e9186139ffb0da807873123a9429351728285ff5c937d5c0ae9f0cca2b7d8f66d54992cc8accb8c125097f7ca95b563b1e397f50a593c4eb39480d0670c880c96db67fa29eab5729769c30827e079fd65c293e3aa3d86916b113632ba53166430c0159304a368191eb60e491abec5a4acc710536409e76c29c0bc98a2a49a5957cdb2f7ea1d2fa0a206a721526885885dc5e0a4e57e754deb1b46a68423356bf4266ebd59ef243a7d66997c76f12503c34ab79418196f939b28b2acc902903aa76717309592ea376178e02a95bf7c1116d1eddaa8b922f7ea83bdf5a09cb2c86ab1045a8e9e68f5055e17312c9d3446b092d8d860c7796ebf7577a3986887fea342edfa884dbc69e74e31d8c11e37386869d2c88f351332ffb4414eadae5038f89d74a731a524a960607e56005d491e0b17f38d6c33b4893e69743d67331a1ff4aaf1236131f2d22ea2751fbf845f5ba14e72f76fddb3191c5366cd215a066a744984de9614ce8c21b4f010262b0e905b2066242102cf561438a0d6cd583640d1deec4d242ccd59403e070dc72e75f39677ce47993d7309c302ca5d2f3b1979f3fb72538bf089c6674b0b55e70c97cda77fe351f12c18da034965ced0622bd805f879954e813ef393cae6d75475ba14b58c0165c8cde19378e793ce86aff80689714613dbd781c506eb72e6c6cbab86179fd030550013aa4516f448aa73fd32e1bb509573de28c291174aecafe61fb49d646c1b9d64709b71a93bcfb99b11ad5df1ed57fd585675c3a460547f5ab40439a6581533698db9fa4947bbdb896bbf8c9c4cd2391b2412c7f18c87a8938c4f4e6ec1d5196c9ce4574df7a41800745e6e6dfe4ae3f2d1afb6291116df37ecd8c6ebdb5d2495c8f8447d0b5c75aeec97ff6463fe6a85cdcfb7df22d1e5148de504736b6cba7c79ea5357b69ed0a97167617b8a9db08e7911ef48954b31d8e19a10f4aae3eb0f234fe4c5788e93508f60bf28eb7b829bca4ed0f66a1d036e42380d9607f560e3b640bfeff2d0cc9e46f10c8bd9a87ed1d8ca3d7dbb5a88ee3c9d7f5eb50d1d835f0cde0457cefa97243a554fcfde5d72fdf64e3decf24e35d5a1a54dfab06f12b31e18ad6ca695a1a4c39c88dc2f8ddd9a5efbabe05f1c03dc9b437817829735a89e4d20304f42bca135641162283cba73f4d24b981abe5fb1e874b03051468b6e5ab5b847be80e2f2bb808c90cac166f875c514cb83d986bcac0f2b332f3c773e869266cc8de2bca18ff88ec671dd48439b543db45767b1b08010c525ba364c32f1b9d81357b64edaa8aed0b6526c84c3a568588332cef34236cd2fd4184e444094cdb9e926db1e41b87b960d38ccca472d7182c6bb55f5c2da981bb2f3e73b20de1241ad51730a6699ea64564ce58fb0ec22a01e0771f7ebea763627decb3d337d8628c79dec558323693301da6035fbb24977904c32b382dd919716a5de48469bcd20b33bfebb9b42cf76c44d3530fb14ba75fb626bbfd28e32aedcf1fda9e1e649504b9d01d121c119598fa59deed892dedcda6ca5a1153803be737fc391ca187a20177c205c1f1cc861d6f205b532f81b220340b78c7efef4e4cd73fa782c4a49ea407174b5c26ec4f8ca14b270c03ee2a6e31e9e215d0609a40778d8b538955b3640f33998f2ad0eee5ba8ca7622c1c839bdb908edc46c7fee2fd94e2adfeba5426a8e4194a38463f34a85bd1c79781c81a59f2fd02b03d13c5a0107c7490b20c86e71ea244de38b0e5a5d406238e00e03d2c0166c49024167c2fba253e25a4e94cd76bf09a5f2dd020adbc6e2cbff87c446e0aa7c7ba314c09496e519db6325df2fc090567749216ecac51943a6954d23056b33963eb34dc88a8bb9645ede25a53e0c680c6fa6be26af4f92e64f88c77fbd3147beec2104234e2e5cbcd4b579b68b0690a1f2708bac053d5a0d80feaecb0536466c60bcb2e54c95515c5c888238d04bf90bfd884a4318f862b0ded7df0c7e4d223407b5e009713192c0c8c96ca9122e681988a83e3ee17a1f6e73b5e4a3d953748872ab33dd20cb1bd25835a460c1e3380622c0ed28019d88af37b9417b1b4013d2d33992c3f845d371a2d02a785491b4d543dcd345f8d9c10d60431b2d30f3ce0979e9c2b853b9f21d2b95d63ed2debedaf36467fadc3cb62811a3175a7c6c7887f505b757f5870048ab7961b4427d87e0803f3bbe935ed8969ffb306ec342445cfc0b532c92966e96259d02c6c7bd7b9e316ad5b1c26a2f03ab11f9cc7909d5635c83b32c8f433a327aad18bc85f55a53a3fbfe44cd3c8753f1ec172112d8e52e976e1d09b69f287528c0ce29dab5b3fe16f6070b340f172826afa30b9b0f662ae641b563dc6e0a0b3674ffe1207fcd5ddd4db895d50ba71a0fb25beb04599c3efeb569b9f6d7fbc42e105965d26a72c914e622442a6b4b050f22e7946695aa1363109caf476f807a30e48e1067cf7ad82f9cf350c73e5bd509f515020344ca5468aa512e6dddd53b12c7d2790a5739ad306d57aa34bc24117093a5327dd5dbf057df61cb8e483ab1055b8b96e274eaacc4b14fcf2a04ea8ac2dcecac51c1822f320cd0f2824f2271bad17b581bf9dd0211ffd3b0326c49140e03926ceedb807f31becb586a8b237e9aff4f64c9bcd6595eeb51a3a0aa5345c61efb1ee167e1b8c78036f398eb6a21d0d507b2d1503531553d8edd7cd3bd5833b4a8d91c65208eaded5b9ce2abf1c6ad2809d41c70b5f2f49e6d2a615afe4629556407b5e8cd9e75cab17d56fa6a7fa064e868837f4267b93cfb4c71bd4e0bff57faca66597cfa6c63dda954a910687e4fffc4ffe0ec996a32c40725eb3d67ff753fefd980f5b67bd5eafa190a9e629070115bfa0d1e37a14f9c966de9b4e9420e78ac3e635c2a1d53a0a83a3dcf88731ce426b41341def16888416545f5976a3d4c3ce311fdfdbfc5f4850ab7bf4d2d8d0d8c723927cb2d23f1db48d9862b50fd577f349b885a00b952c5ffb3ab75a66d261df7744512b583329585901dd4993f58c0c4ec8f37f7dd2fae9de03261abd2ede81247b8c4cba4fef88a4689032e39d5cf4d098b168f514180521da9a25a657b087bba559716d81660392c27a93e0e90c69bff2411762c0a0f3a30fac9b983dccba96784bc6c1194ff1136407d49d5103239ba03a62ee414d9c67bfffe3ab3352b20a4a858bdaa842d33d730b68bf6591085126bb8ff50ec0b7ce2e1f82365eaa81e574d6f46e27417fafb648ebd31df71211912197a967377f10a9e7d194f92c4a1997e1429d916aa0873be6e823ce5efddfbfc4245d4cb15c3f4e77c2ceb4b78eb655c79b72384e5fe0e882ee6b8d8d09211283c8fcf85dd1f9f4c13fff40a9cb22a8dea2a7dcefd93e0ff57655323c1b4a42ca4f72e27cc2dcf706a89dbb6e6de30e59ffa5623a09fc3cff0c64d85a80f16c2465172b31418e858d07b1807805e5f42c9b51571695b86965e66f48af9147acc8b1de9431da026547b5d8e25c3eca78b50a0b12ca67e27de773e91c6c64bade0fd620ff0cd15207c6c14b830cf23c27079959aa7cde0aadce4fd464a5137a55eb4bc7b788ef4e8e080eeb37e15673b556e01762b59acf275848dfd8b5db31b7b0e5ce93c885cf293afe2bf7312fe97220f69ca7afbbeef15b8b207a9cf597d65ceb56048d9d2920d267d19406313f7f12d0c745c686179b11c981acddc0ea0d18e3c387955006563c6f1bb489a8145078277c22cf63a3cce048bf7a1e79e0eb3af7503d812c2ecc30a84de58304663e5cc8a47987e8eda2e553305cb700f6569f698404c7420fb2908a73f04121709b9724962bf77eba1b028db993267bafc742a821eb7c4249d0ae9c1fb8a349afd388b020c3374c0e9a1c5fa06967faa31a7bb6ce8cd36d7e8a7e1b32da873db328a1f89de9595d1171c49e2965e9e8801cc5acb35de1e1d1bbcaf9b7cee96d9c40113e09cf21d116b75622dbb9d1cf13bcc730be0080e2eaa8813941319dee8abb621d45b6411896253d375502d3c09f3afc6e53cd34eebc109dcc69bdf2784c36383bb5445c6dfae7c91e0e6be2e76061458adc45bd0f6f65cd7be31c5d83273ab6f3192c45ba2678ec2fe7900c44e95f182b82c99b200fc00cbb25cdc1f053fc85e36c988fcd7b7a506c1499b25db902c61673a7b5ffa3ff983c126e9afb269cc8836e904ed320c5a02d922b40266f9783ad4114db57b2927be39031ee2a9dc600a8c26990777513d50accce564e08a47a31f0fc39f3cc781f26327a3efac654f4e9c98c87aa51c5dd0090595a015c1f00436bb4acfc4b67a5a4a6a67c1ecd565073b7901fec059fb086a227344119a4f3889d1c29c119e0d6ccb96def0212136529b765624d0b82bada2e6550823e90e85044fcae75574d26e9e9f7ad5be71c50db87340059298f95e4620f2e20c54a7386657060e5fb2f5e1b1806cb56e188fcbf350bc91acc70da56832d91c6f43af19607db79fb4d26b7dd07919916ff63046e992b55499d7c9b1fbdb62efcef57ef721afc9996881502314b5d13b7d60144f2948988b80a76479a5d16216d1eb0f1632379aefe268a971a00d75485c415d29199cd09ff9d543a625f8ffc7b339690841d1961041af774f401e5b1b988bda9c29d25bcb15aeea7693b3e1729aa9de155e2c3d1de5f15c5022a50771175b21c80bd559a5619907e3da56955affaed5a6763182137f1120ee127eaa4bc5ebd9377e730aa5448d79c69da842984ef7f4b4042308d45d7450782871d00dc44d0d3dd5ea5505e7e784f5d8f6d08dee39cd42b63e050db14c2f6aad412fd342afd5e0170bcfa1762a2f86c532111b40e40a059da201bf95c9c7a7941b112588f2c8246e1a12d81f3de4b3b3563297bd105d0f7cbb50df651c837b597c9ab42048604f01836e805f00de590332782f254646f462ca7d87433a2e2c2f3b51222dd6301c8131102d685c4a568ce231c8c7350c063e6dee234cb145ef4b3aab55ea689622785c6236b166d71d2a8fe5f906920e9fa55c56978bea4b7a3150a3d6022d0600c65315f1d55ed1ef3f124e552bdc67d4a8fc9423d879c0fb335a826d3265bbe725d2b89fb2907003dacc18a15ed6fc068836fc02385b0dc9847b591b1bbb08008648ea66ae50019d1bc20b1cd3a2b84d47775e2aa61e882fe0c913758341b1f2eb263c46cafdf69e7347c530ee900722a72a368722f993facec5243f70be34f8511d3980144252f4493623ecfb40c01d64a0c788ee3770d9ac40c7b6debc7e7cd1b9edd67a6f6cee7b5791ccfde6c4f628f9253082bed1203f82ee212190330ab94a6fad428c197524d03c05e5819c520c3c8e918eed1681ac8fabd1f73524a2439ca9e27c556f5657c6b483caf5838701b3fa49776de2f66ff99804c6383640d07cb7831e3b046977e07a1db7553176f0c1852fe580f51a6d7eb29240de500466e3db252802b06b712bb570f37f4ba4905251c0568a6ec955caf339de85926b927eafe6cbc2e888e223172a09255010a45b1f9520cd6c925b6118ba9a9c078e88fea72afc277e01b6548d83f3e3fedd06506d289c6c97f33a7d0df524fa0695b32300dca20cde96e797b2fab7f506ca888eb60e70fa645db9e14c5d1119ddade6d34f7946690c4804300711501e4e5fd55c36d58a38b1869d4a381708c088f2a490c1d7e109aad71591938b6fb743626c76b1c0253d80ce93c3475423e85878f86ba1207dd31d17c07aa837fff81730642d852b99a8e756b415fc1e917e8ba766a662bfe65fbba0b2e5fbcec57d0e7b0fdd18002b00d4bc80ae47a814a327fdb7c0038384d1801b563d9cf192ee18777958cc842835dd70b5aa5765822c5f2d9f8bbe85765e523add0dbbba82e9cacbec11df44e2c6167d29225320a92d70fa7c3f8a931d70c36b5cdfd84d8376887e7cfee829e6ac068f99dd73171787011949b303a59664b3596fa7dbd40e02adce3b319eacfc0d4f80f247acd4987838498e330e5f1b2053c39430bf1dad3ee86a325c5acc069140631ed84a35082887168991ef8685e3abc5fc5bebe5102af7da086b77198d6faa93f83994e2e7987992690c30dabfa2f41134fa5994c1f2c8ce1bb07623e35b1e49908ef3217c767fdc2902b20fbfb3a2cd46ebdcf40fef64a1f7d2fbcd481e06f6fe54942d714fcc737c73caa775b43af7fd46ab93bef410c1fe5c7e85c92773312b136e7cc61ce50a2d0cc77edfe7966c04f274d1825506cbc8113851626d87285c1ebe1a8e9a9e1107329f7b459ad1701a7108f8705b2caafcbddc2e234ea2bf3457d755bbfdc9938d0ae14ab3a158f5850423c88cf888955562342b9870c47803e223e2e58df5b9ff9bbcbc405bf091510e7bbc6ca174a34abf724f6ba41d8e6e495d7d1e6c4105f16216ff64318ea6c51cc891d666d1c803d7a1e3157efabb6f0f4e00cd72acd04c96b6d04df1feed7b23d80c71ce7e6d1c5564c6815592ab9010cdee6d9bdbb0482ce5c5b20fa4aed8de7740f774cb146e148fb05ee777006582046ae42f994b565330839e1ce889889d710555bfb4f3c551f3cf962a3c5aa928905800643bf9755e7c2d0b0bd3421f18342544532bd1828a72892dec0ebc600b17f257657fd2e07d708d2d3287af9461ea6fc610bc9d25e940b68aaf73385b6173e8bf72388510a4d8fe899ec88c60c36d87ce9efedc8a5d3e84282b99f47d2a715d67a741c09efbf5e47c7db7f0731019c00b9b21c4e9df47e47c058abe728423d5dad5d2af0a9a045215586148f805fbfc4ffba903fb5645822a852be79c0a01239abd528fe410936bd9630cdce5f789f7de98b30fe38108c7095be7bc35e49ac4eb8ccc6c2def60f09f9b1b10f8479b8dd1253c76c3b83bd2bfaaa7a8179cecb7c49c8b64b94fb14044529527723b55ac3aac48574cba5b5e5f98bdc8e8ed7a2a85c94c463a60ec38af3238875cd218d9dc929c9cc2564e78fc68300ea68a7b81da892f6d83015d4105292173a4c705291c748c810176d61a295f31524eb43d4fe793633b726a47a42be626dc754a5aa8632e42f9540ff71d253640c74abd668f46e49a2607140bfd03ab7a5204e7218f15c8cb54f565d42d20427721429d52f4e99915c6ca2cf7ffc4994c3a0068c6c44ba8d21df1717ffab56fc5036ff116a5e830aa7dc9f5c6c0e6aabe5beef169ce57bb6f878cb9716f181045ee0983105fc6bea707a063f98fcae055632c06ca659c94d7d14a07d64548ec6390b4dd3f889da1c27ff1b7e678e5d0978ff4916a80c924891f410f2fa87410cf0e69368338e50f3d290d69d70b755b7ba8cf073865d65857024274d011b3c0d275cea8d490aef6d01557e191261034f87f2080f155a9720e8b45fefcd11948e4c8def5076bd274aed6dbd54c9b80de47e37b01e6efd55d160eb8fe89c185513b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
