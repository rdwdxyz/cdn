<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1e186995485703dd29dc0a97f407bdeffe962ca2d6e858bb7641fe95db29b5d3a3fab819d52b031fba9ca2b77ae8fce1747a64468c2fde7ed5fd765a71f1f80ed824b1eaed9d59714031e6c8b5927386e23b67e110c14a67418299206ff094972ff08364e506f6067de1df2beec05509330fd177c22f5bd89012a69b96b5c72e96685a6a3c06472a9f080b07e200c0100027a945126a18ab7f13cd40dadbf7772b3624b44de4d7f41401b780afe61bd0f3af9e3bfc6cd6647f879574a8ad9d0f7a72249a6afe8188fc1cea66e998619b26f7487fbc795378ad9ce015230da5e501d89ac602760f8fd4908e3d855f8c56bc7956831962ca323ac6839d6125b15c0bbeaec19eb796cd7c066e257fd64978822ea198551eaa35ab0032a280b79ed4a931cba00340c50d8c6bafa6f690e1bd00b44ed3c9132087755116ddaf1270a58e755b335c0db3cac12c23a4bb5311a3d080eef0c460cef000e44c4ab4a04a988de811e8094622bb8e36e58649af20d50895079bc6d2cb68ec3c00d3f35e204cec231f834c493437cb7f56e08bd49bb3813600444986f8a7cc470961a1e75bb15fc70f46e00dfa85b941c20f421025049f161288550bcf4cc8e0fc1de65e1d026c780f404054654b78bd30d135bfe0785a81d382998155d255e3250e89c312a2cd449b75b0eb41006ec90ad2bf83da53cf1c367d5d5f401fda87b83f408f7afd98f39e7c5899bddc324029f44e53edd3abf0df63baab0c9ec60abf00240935620f27f2d6993e7134fc974ed947045a87d684f2abe1fb7636c20e1fa957c5d78d47e4cec86c00f6e343af76444b0d8dcb0a1108831c6c54b807a23bb438313cb11b4fc36e73f9b4a92e56c6970601f95e6a388c0b17b45404b1c47a19ed4ba4db4e69f35f89df611831d4bdccd9b10be933c7168e6665607e998940bfe94cebb2888f6e176a198946cc322db954de0c381ed2813914d68b363f295fd67e1cc93013cac83532aa6d8bf86366de0808ccbb712a8d826fc6a7f004546940faf98bfff0fded9f4b20a29301b47344ca45a42c805244bbd2c0ca29adcdabe05aa8a44db36346043c676d3f81da71d5022a3cf4c51986ce414172d6ca47b07f730a056ebc93f4e9da18b495f9ceac2c1301d870ea15b1375095dfc982da56b15641d7ceaa111dea3f48210eadbacb5a302d7e588599c11cbd4125d93016d763139b03ce5d3501534e4992927e19bd12e3da39bd7b4ae02c1ea7595832e169c56eeb4473fa198e5ce449f2add3b7d8d99e5cbc7c0c89d54f1cf26afb5234702c4979664c7fd3d3f3db4e050b7ebafaf9ed3d15cb134f1d476cd48407b2a042a811be5f11b919cab66c34803225c76319838cf315f7b578b60fb05f305b151f9be1c4b497fd870443c06b637034fccdf2bcf8b832a4cc132ee9bc4be6b2b96149496d39bf8309747046833238993e83864519496b3a6c1315c1e26c0f5ca3b3c4d13324fb2873ef5c478900b27c141b38e899b4ae36baa1ffcb26c2889db80dbb307d0dc3edc71653646077ef0ca838aee7d233b4c7232f3ce4979b96200f451ef50a2e5a029b5348f817de1cb6bc04faa732fa3a46aab1ace1bbf1e0459705619221227e1c1b82afe6304a427a56ca9c8adb3ded8ae863b8ac713c573d6e2adc9d3fc499b9f4d6e9ec605bb2b978229637a9532505fa201d4fd2b36776cb796481bacf032c70582f0708b0e23151c269af345de20351801e981893b0e27cd4572ad6a51439d27cd988adbfa9ea47c63609605160f93c28c3e9099f4cf8c329e317e8c3b0de8734e111effc47a045a876341212c1d4f0d1ff98e7134a2fdf01d0bd3166b354f4636b9a177689f7fb3c0bee290df2d21d1293dc0604902506c1e78847f8a89c8506159af5773f4f99f5f0f28dcd272af756fc2fac5f707a2d19d03be47df3eb49ce30a1374a76cb82bdeae9fcfe6a65029090bb1c47a30a50888cd41ff9f9c996785a0a04b79eb5d5fe8812d052dfaf713f8f4a9b61e20c658df0b1c0fa3c76f15e26962f2c54770fdff213f621fb013fea8de33251cf2e186aca820ed212c20d1b38e35e474d2cf5f6fb8a5d7cad77b3849d5c7d041491c53b5398381d8db664bc00f21878d99949c288bf1ec5bfd50010803f6d61a1102f470b16ef21d7e6e19346ed75c60f69d8afdf92576cb98f785262dd2bbc05b5bd4e5db424d0f05c464e5488261d2601b60ae2d9bcffbfa506cb2a1674b6ecd19d42f607be6fe9848ce2cadbbeec3292cfe6b74569e7f6a496bc9b83b14a0f7a8d59c90ffb6056707da4f096fdd7fd06c211faed258b9eba9d2bb08558444fc01055987aae552b9b640024cbf2aef38a4ee16ed2ff1e557bb958c78584788dd4a624eac7bba5613203b117cdfe13bd0d390d321e945e9ff19af5a3fec813f2ce46f08e99e1c7f53d3650f90eebf04aef2a079b6a9e591de99781be0e43fa2d3ff282c6799c1782f37982317b2375b147144c07151f3fe7dadff1b0e140764f39766709da8c7fc3ceecf28909741acb8b0eef8c1e4260531dc7f5f264beedd1ab6efe6e2f542091c86799fc02b43e066a4e97db6fd01e7e8f005808a4774bbddb3a0dc9020ffd07ecddaa00b63f723343fb563c8acdca954dd9d196155933ee9ada725d3f82ee9492b2c46985b142deeb7724ec61817c7dda0628a88ed8fa3cada80eab2bfe1947e5b75efa40cce20725e273744d09cf417ae3ada869017172d6ca6239c5d22fc80d12e3fc333b5e2033bc678075965f24a53423b38fb841141e481eea7fe925b45be9ec7b273e973c514e6d9344cf7d97d3eee114af6778d81e5d50f0e9d5b18712642a011e65b10ae29158f8d79ecba42462c70ee26f2eedcd3a59dbcc00db70d95628a1bfa8cdb6be11be916590068313e3fc571b7258b5b95a59e312eafc313eeac2ca71d937b3c4e8f3136338ba84e7165d93b87f332cc95bdff40bf64ca7edf4e0f8074e9993efb5eeeaf2279d154cfe02be5afeed81c9d09808b6ffcd6f3ca5513c78da2533269fdf3bde07a4451dd5dced1f744fc9eae36593c9cfc0bebf0ec4bf09fed37a9d408c6d75028d5556788ffcb45541556353021d45bdf9899ae9baf11dccf95b88edd798c443a8f5a99a20afb16f126f90d18fb9cf02ee07628c986cabecb1a92465ba61c87eb8cc1df19f06eb6f68f675827641cc624bd7612dc4c2382e842d9b2927cd671c80241e6371039b6ff6076da7bdc7f6b13dc2bcd842dc1baa9d42288d1c200db59152100d42b06d1c5094b8667fbb8206bb30b25c176376aa73b2a8fc3316e39b9fefb3bf95f11cce57d7abab37c8015dbf4d73554959ce0481c5636bf1708cac3835ecb90e1aad50189e7136314e279c7ffd7ac500073f7df6af5da8db7b45b4db86aaf40c0be62020a027da5082ecc57bc68eb82f70904f3bc1377aba61d01db26125bb45b0719d38fdfddc7e90b4aa5fac32bf0b11df5f9777b43d8836b9fe47d279f84084dfdb90d01fdcbe0c999f0cec701adab42368cdb4c4801248d3d15ff662eff45762b4a405fec5d61964efda3c76f2d0a380a2391088936af264dc722a424c4bea37c90f8168bd1e7d2ecfef2c8aba904ce442ff9d14fc98b2da210508937fb37cab9ebce0c88b640d62df3faf844f188cddf978caf0a8ae28e2d8780ba4b20abe08777e6d38a93da18c363e8251c5b35014eb5becc404c4e970b854338605ded892c1aefb065e2dd198a1b7bfa82cd8eb9383425d35c580f5d9d1ac7d0b41f5e923432200db393a2573d7a01f07dfe1957ef65fc0ae577f64b4713274e9cd62d39e7b6a6aba16af2c77a89dc2c86c497a10c8a1c1193e477fc12fb52de97c84c0044508a5ea6cf670c7c97e7420cdf05c3993b6b6e7ff2c22d4d34b2ed9984923c2776d72df1cf4cde4190e9fc3bfe7bbd5f7215ac596932391bc0ba0faaa3fd88186417dcdd4e1f33550ab9345f5cbc5262484e0c957cf3a2d67bdefbb9e808a71882679ff199f0b64147b2519ae607ff02995b3e349a71dc5240bf68d867b65779258699355248e926ee7b72512bd4f2262f4b40db3a489389f438cf3663ef594f911b7d6171725aee8d99b5703ecce69b64db19bc6f0c9fd29731d256b59b57dd7744a8ee0d427ce1ea78a8755367a1f591a14f4b1b2c41211d61833b97e10971e43cfd8456ee7c5be5db532abf43667ed64058efdb7d02b9e57a705e2be1b07ee4cf72da5e0867ad61f26e7afb23f24f29e51e01caaa949bc125becfc8f6b9c03356cd4a3e9b3a5b7b8fec5adaa606d960a7c1ba40a79f0ace34e17ce03c0e56f9dacebaf4ce992d941e8b656cbe3c085764823cf76cd586730058c210fc4a856a06243bda5a756e34f7a60bdbfccd4ebb685c08bccfaed363454c8f80359d99de3ec84cdf664caac4845ef674e08879782941280a01f0a75fdbb45cc2e28a25cf48a3822e4152925507c19d9d48b3efcf206edba57bc0d02d5864fdaa2f1f797aec79887da1f3a768ca3d71589ff7668c1ac40d57d58f8045918d158bd532deedda8c55cba30660e7ceebdb6eef18c88a0ff787cb3a4d22e4e7a0c57023e30687d835e6ee0114c0a7cffc034f587dee259d04382dcc63d65141172dd94daecd3a06cc7b886646af4cb01bdeefc4eee1e06eb2141ec8fc726e41368756509e8d7a26c7ed4421413ef2202e4391fb4fc159d282847c78d13aab8abe806b6d29b5bd9711a5b23e4e3bcc2c7d8f5f7d6c51ff46b5a4fd8d3abdf4c2369e072c30e826cf9ccb3be4f862161024c4f95f8b50bbcb69d3c8249624b91239e7058d9fe40a9a70fc8a6c57b0cb343fb4051395f5949d74fc2df7745d3b8a85b28971694b9e7fc498612446db2cca2f4d7e481a54f062f73d7f9f4d104be3bfb9af887903e084e7aef9bbc542e739eb439ef9b0334b49e52cb14970a50cce593a86ca6852c79d638bd942abc617c056777e3284647fc5141029ac9eec9584c2f4fac1ddc34b94a96316b5b649c5d33b036e7c40a21f7bbce316b1a2e205ac1639cdc4345008793f82b508845797497d483b4d7d8e1186f71d2b7574fe54f3420b549cf01b18d809e3696e965457c29f3052c8445a89a1085eb18a707502f5f1093c181f8b2053a6a2b09d272cd4efd405bd3d1dc066d2b01718f0d744d9c7c31ae344d7bdd3a35c1e475ec73b485f6c6e088f6b5445c3f153d9ba3da742c18d278a3f7209098aa5ba788e644ef9c9aedc3b650b3a2c12eace2fa97e99ac40634c7dc30e0318e03608b4e87c84be2be04e82e0fbabfc2f5350c332219f29dd17a1bfddfb5bcdc2a555a409e1d02a1d0c858efdd9f056dd8a5133d393ccf67ab470866c207788a7a062380ce574412fd266afadc0f90c8a1fc826f646ca0f3b62d8ab98bbbe05f423683c5d9eabc40783431c48a6123fd3180c403fee686a54f4e25b585c41bac84cf4bdb6de33463c1c39651b18d02f62fa746fc299fde8cd3ba29d1d0f07476896c2b4e8ccb5316660210cfdfa543811ed4e048a41172f00ee6e19ce1279656ed03caf778a169a0cd223faceb57c9845ad93f055ba1466a8266b24e30ea3b1dd6c372e0eafdb5b34fa4781403d94a6674ba5abceecf35d598ae18f0cbf3e42eb94fe6a7f89e44c45bfc482913403158eab50d606238d5540e1d419f49a9818a3b6293d752cd26f3b7118d8cdb76942ff327213425168b232b9773a2a710f5410a96075a3728c44fbff882b7013cc2ec59c61c6962564fcacc21a9d94773a31e255b1727265169e25d7e3a8a0f3938a00574b3bd9e077be36733069daec439f2d26a74a05229575d6c02bbef5e365422b968f11d806b621354ea7581c63294ec8d89d57708cf594a6f2ae8201f8c1fac62684e24c6b7afc5935644e52bfa1b104f6931371a16033816d9ecc81e5c98435ac2e2cc4f745c5ac2d185664a02f386a87f081636991a67813f2e654205aadd9919c195b80cf2bea8aa21523437253ada621c127df261bc6283274a6167d689cf11ea7d9a20b009142ac4c78b29c96abff6b74e2217ce2838b51c7a1627f9cee457e454c3fa2003211b188b3965395b73cae694c919178c284567a466513259774263afac640b0a5cf7aefc1d663e6e203748b9c305fa3f8e69f2472d909fcabecd8e7bd39f800e8f7f5349c22a8015b75fcb335c845d30f1d72c4a41fb0007678260adb591c75008aeb6ce14a41ee07339955984ed6df2fcce2716b25d22b375967af4728b5943071d646d5c6f829a59f4d84f4e5ba3430c50da04982196be462df152fa63af45113fabd8bc1be387e8e58ee6b389f907c795b24cf69b8a123b1f846f28e867238db16dc20944e90dca683fdffe55981d15eeb54c14ad827dbda00e1e2bc869864dab21b3d52be3c4700d85b451798f06516914e8492d10627b64bd4677ee60d9ce8f74d54abd500c89f46f62579b72e8c85ec7c363e914630e02dea974b9b996bc9487e47ccb674efe96692d08e5a82029b11dbc5b5f46e7060ee734181a528b14763050bc568823426def46ac20db8482da8f2cd42290d54e47a3a8a1fd19cff21fc1b0adbb31069f458b97033b50a858a30a90df84776a6cb94afb172f0d07521c83f8f587baa047230b25d53b4804bf811e8ad4239b4e9f94c6dce085d8f952469614def18c08c7797a9b406650f4de4945ac5a1f08cf6b9101b7012bb7238e9f81962542cf54a869700aaefc5350c21d8fde64173f3f113b1aff739c44dc4ba5dd00e3e52c6bbd88c718419aea43c6e610f9bc81eaac41b35080f2957f4356f35c20f06eab3e09807496dc0930b06a1ed91a156ce18a32ae264eddffc8ec4c29d87c31020ed77cf491328f3d8744c1752b3ac3bb7a73cade2b7b812087f4d012b5840b233c149104f06cbffd3a3d0c69fb92fcf1ff428e532553c176f7cff5f8d4fecb4168c04eaeb9ca6d9c5a161db1ec2bfaa8eae3f236a312b7eeb2ad7750f6c69fe1b763213df0270d8f3670a162b75c4e137e2b4d587e467a91bf59b1cd38c1b5f308a7301a1b2cd747fc8111bfaef7b0365da616ef4d94caf82e1bcaec9aed3856bf8f4ed16285e591713c6203b07ce69ffdc51921c849cb04a50f202cebcc415f3cd7306a92a95363e4c55a8ddbfb3e650e945b373da2de224a9ca8f74b7fc42e61b41b3153a195748ea89280cefc9a3e7fcabc752b4adb3418b6c349e286b163b307c73f994455ccd7bc89dc07bafa4fb731a17af6750d85056b0a7e3e5a2124ccf2cf383031face2bb5cd76646cfd96f1db3c906e5bc29e371eef8e123210908f0ca459ec11165f2bd5ad2ad969e48f2d25832d58ef9da97c2c0a773bb7533cca7ade7b105a2e6e23c874945708e5b6685bf125e1d4801472811a93eaf0f978e2bc48ca8ccad3d6d5b6b2979d03ef62c85aab466b473ae68bff9a7cb74d0909603047349ab4e95b914a7e46fe7c68becd6ae0b3de1878a6e6971a93bb5260261cc59c5fdf9b9b7da077caef63567b379108a55e65312120f1c25069d3e7bff011ee4479836946c8be922f9879b9fef95ef4ab0dcfbe4e56dd428f4211f653c7a05b65b8576a24e7dc26789460403eea1878beee4a938848c90696df7a62f6bac87b8de6e8dad06b046c3c47586fba9ebeb56fc732fedb88df63f963771ff0e0964f01355668216daa1b5fd22eb2778a4251b87b7837c975ed907ddd48112ff68734b9d6252b4a3b17d78aa5bfb560707bf4b0b86b00039372e0f79c4dc6bf3fcc3c6362950e4bb0e1b481c4569c112745aa6149d29bb82e8bfbc90e1d81df3df545cb082308a1bc1d752c768bd84784cfa4dda92151e5fe6087d3bd84f6c591582ccc007a362c00005b2aef1926bc53cebcd517e59bf1061c270dc7e6867f7f077cc4cb05ddf6856d872f35500eba3b1cfdbad240b761314c8c6e6b5f695d9fb698b11d8ac45f7278e61caf06bea964cd6a00860c80c7dfaaedec0f2f5e4a8fbe74280dbb22ff28ac7e1ea864f51eda498d9c7ae9970ce492c670272d219b572762d2ca9a91943bb0925f6e6e002d18377b0d1894a50b9b363a10363168ca38b52b41cda9f64fd5332f1ec2df562e248f81b81b135e31e532d67bfac252f9682600d197ce36e497b7aa4d5ad4634e2cbeef7adab9563d2f4b264b2604a5fd7234d47b863e1dae728cd6588d84adb26f73b0354bce62736521be8302f84d1778443ca55c4338d88839dcbd84101a5d0a28211e17e71e504f91e2687eef9a3a4b149e363ac081ce112cefe7d7d2a492f7d306a12ecf52f5cf6aecfb95787fbcb68edc79cf4b6b6f0c4f037b4ed5980503017824ba7ce4aea851675fd55bdfaeec12f619a7092f06fb7d3cc8f2bf707bde7de159b481b1fe555b1eca33c53d4dbd788fa79b49d99410d5ff40d221063b2af5a63e28be0ae182bc36f7183cfb5e7a418bbb91e7c452120ba7f3484c0d991f6ad673349ed6fc25d9521f24fdc0d83869a4bf415f4e91c874f23f3683767d7f499847ed0ff9f3214adc9a4b43c71ac1f5ac6d9f1e3ee21c7bf80fbc16337eadba387e4e194b35e24308cb1dc3f3d3c63941f7d9ef91e948e5b08ed22baab7329f38903ac4f5b8663feb847706bdc99c9281f8265bc337346b7314c33b1874ec6a5f6293b44405edbcb91061e97ce5f44c14b9726540c9205ca35662316a2a4c2d6b0ac9193e00e6f1717d2b0fc648d705a3a37fddd554670bb6c1bcbdf736f2d59ddab6a53cf95c847e8e718fb455083d3d2396fbfc487606e26c18b1a7f590c7c94a18e196f7215a3a877776458627e03ed6f6f2b898a07ba6bfb8a5779da78b560b8e6c1db315739c5f95732f26ffb003c23a95dbba88ffe5fd7cf353a30cdc4db5a2ff993acc5ea7323bfe57288e5c328d920ab18583452c4b62db4e91ca0c2d65bc55db80b67a9dcdd5a8916f7d575b86d4a4af58627cc7ce4e0098902eb53e7dd7da3ccaf08150179808c8d56011d156b8831b9fbe43199dd33cbcd2f6790478fcc5111908b7150dbc21d75ef670cfd0f917aeaa53d6e7cf13bc70be0819e279f13601e947687296e57486533b2839c9bb755fe99e75eecd61345a538355cc12f59bff3f5e0a519c4b8d404d2a05f69fcabe9a088bd090dc73175df82248fdd2a2724686f7c0c95455478c0b7fcaedfe865cee43507590244001c08ebe0c8681a889c810ac6e75e97bca22d6907acbb868d3d0a3d3c7a92db357ca027ebaa04702e2ead19a5c64006fb82514d115622a627ab09fd99ce7cd9edd33292023b9d3bfea23d029bb4a89869195b4c76b8722cea26130dd8be2e5a2c36a8265594b16df9e997057f22a6e4edd23baaf6d29dd12ea2a5ce8658dc047a2c37e368ac6ab418936432a3280bf388c6c4a3d9a876afe8525afb66b62edbb52ae2ca96dfb44dafa33d5acd9bd3b4671dcd75c38173a4690782dd29ce6cf2a6c79fd9dd6e97e058cf0c445dabe60bd2a2f6d27bc35d2ac99e355d1e0773321c144d98977d5e2b76dffab826f4aa04cac7372d3340e606219c8f19504a4cbfa9d2626573a78f847ea4fb6f53940341b63f2e3ee9611adc7880d954404bcb7ffaf5833382af1e2867219f069c5d5b34b6efb7db91d6d266104a22dbc1a421589152997a8c159d991911adccb8bb546c99903831806cb0528c3fa9122f073062a9ecfa4cf0a8016dbe86ca5ca329659a15d30a5878822466ca5023b670c3503a031502c97c31b9003be466e7a1e5f506ba90961e1dd607c58af2296b2ca92f0377a6d071ce16a2f6f991553f23736272eaea96895c6aa24faecd3ccacc0c72501b25303eddcf3a6128f9242ed71c96c45ae0b9f2368193abd5af41d4ffe12862389a44a1a44bd328efa8558ce373de6417c763e5775115f9b13e68809939c8dbfe7e849aee77411b8ab59262c75c7359e655d2066fcb1ba3e2f2413819187a2f3929a30e28028e883971407e1e706f44b1defe74da2cec36fd13e8c427cfee703c4a18f50a792e122d9f8e91482cb18322316ab2207979a26bb7b046af99321117ad2f5657ec3aec3217d9ec0e721570d645fa692297a7cad033a0eb4b12b4392cbda9b6ea27748c88b18d4dab199c2b8cf56d1bcc091cd091925a8f4a03b56fc18958877e148630ca82563d387b7ba9992dd003fe379a2bfed17f0714b8657339d88ed66b16827fa6ac578d0c2cd18615addf1dc41f6d35cce1af286b13e2a8e1563cd7281ec1ee6c02218c9bc38cd192986c39a5743a85543223802d854c1054c8a27c35529a757e0ec0fd4c5f9e5e7385872b0762b52fe1f4956cac202a6ca09865926e3630fb0f91a0796710419c5ee749abbf6db1fd4453c20b6fbc68297ed76e3896537fd0203b8caf235139e5e8d8d6c1780b4c61565e7aaa33b1f7c04cac99feea4ab137a026c58d4f37612c3f596f8090671ea69efcf13917931df536f488d972b39236fcee7d87d8732b645ee3131920d75f0c56c26b5689114fb73f71d358e251bbf25a69d650a9de3f9dc15026c7ab5b8e4627d1d25e382dbe964540d58938dcf53755e882465e7926106a28b51b12fd4f9798e52e7bf89cf8b5ae0774c4521b3d9c5acb8db0a9cc56cc9dd6a2dd524a42ff3b552fe57bcd031be2de694f4c43704f0f00e0fa3bb0a78f53a3152caf813f25faad2b2599e00c7126deac0aeac5dc88ed669e6f68a453f07b7ec91549b1e7cc56b5b52296a74c6eb276afce5bb595f3ae91130e21707528626d9295cfbe78e9df715bb958fa8febdf6eaeab4f5cb4eb1388121abaf777deef378e7ace8c371a708ddeb34a56b1e67dbdb2898fc3edc497b164268f15c8e50ffb8458d897dc5ece3452deb71b51350631b8b597ad0bfdcb425fed5e12e77f344cb7accdf1d0561d3cdbb726f8f2605540a6e7864263f727f742ce00f9697ff2bc2ed31f2b29cceb71e83329dabc55224f5d770929659b1ce1140d5f198f1e2356686f18f94d3e2b4ddb10d72eb9e10f339140e90a146bfc35a52e72a3a4eaaac2f2301bba38a00a3b9edca9e311fa53078436c256e8afc99f16a8b3786417d7deac1365383f960ab33ac9eb5b750edb65544a637def1659d8887cb80be293c193c1009c40d3cd6540c54f4962a0417411aaafe4a342f824681adeacd279ff566beeae71ad9f741b01d153af3c4485df0287d9d8c9c5790c3dbf0d9f5d0d00de4ccaefca3dd5e75812435e4609e88ca96bcc118943bd568c79c91cf4ad42ec83dd7235cfcfa39e3b2d499055001a3f8c5cee8a13378dc68b1568d95c30692d9c8bcbf86fec2e8100db400394f175dcd5c36acf3526897fc425e74828ca31712acf33b76447d5a1c5fddb13484ceaab5f1f91e970bf05e4fd3e25ae3b3357b6ab0da4b6d5144acde6592749aa70f4bdcfe31b68fe72cac8aa9014e476798d7d57f42ab4f8d83c0a1dc5ed7819718cef3672d64987c88c9c5250ce5a06a3b9938f355ef3297630bfa365439284782f6cf202d0475fea48d600cf35a4a6fc20d3b901b0702ad06f16984b540a4fb0530dd5a57940f243f77e8c1cf63a1ea8b5f74e6f33b39b6ba78b70de942430a39f0cb12396d46cb003148ecfa5abfa6101567e17417acf26bf50f3d31e40e89e9f41019ea0860b257b110903a920f65cdcea8e6a973153dcdfc149805e06c8905e0fc9e12d94c8c36446b03166c8089253a083cfe76859482e7dd912d4a9368ec650c0ccdce1ef2d4fc2f1a413107807baacf219228b9689f9116fc2e0346f2160bebd36ee38562d4e6070d4df37c345b6e8ddb533983f53bc8b9b323cd65f4128398874837265de25df216090ad87aa569cee467c6b1d6071e2c3fd9c46212ab56c87122d4407aef26b4fa216f127096e0780d9f30b486f82500a16a5cc7b17c1422ebe78e78ab17f3b0fbb8cff985740cd41b39a209e7866e3699ad941201a3650b2f217cd6a6d3bfe75222a1cadb8e5a9172fe98b9d722ffd72afad79896e2fcef5b697c57efc827363cffec094ff37ee62d851b1bf031c01cf2ecbbf6d8d555f55587ec41881ba242ea166a16fbaec6732df8248a54a2e519bb271481bd523dd1cbbe46abfbe47ab72b1650427ad5a6a649a61a7426050ab77818c7a523693b371faeaf40480e89cffe15cf4082882d2626a6c1033960c12f6e106c05b1d3c8cba08ad07113ef4b6708c625ec79a6a0dc4097f5861eaa9111ea64ff5cc42d97faaff68082e00be420684b82764173794a344849399047bad3f826d62f95a659578b6517ebec0728fab19f907ed8f8667175a5280e9bb5794af6f0e309f3bbef589add412aa93b55e1ac10972128223dcf04f8bd8b57df9821ba2201743eb6296397ffa87b138534219746644be08378983ee3ed139fe83b55e665f9f8996b2d81ca85a04ea89f2fa1e5811ad151c8b3272f56c57255dc26f7edd1a8b5fc0aac7cf8e146c4a8302369ed91d28301a5d87cd7ecad13a095db5d15f1f4ab6c65a7ee1153428a09d817b0b34b3fc032117a4c38f01066c8dbd6579f0ad8324b1ed88e16efe8a07e7e4efc58c346c9786eb2bbb1560ad6fc92f55c8b0a96d36824dad9db0bb1cf4017bfcd086ce3e2ddcf184eb7f19bf272215bcd4655ce8011a72ba8cc8643a4e500d2ca564d57f926967311f011dd32a266c03d73ef6ba306c960fa47731676bb0308469b73cffec01727c420e720d7707a18a6961ffb40ca0e91177bec8ad6abad84a22228fd3a3cacbe966471a195193bf9c20a45db85d7523dc1b583192d7d2ec685310d01d93b8bb99923067f5a3bc20724bd6904628bd0058393f0e7e64148306ff0e67c8175156ef8168ef30958f80f2ce69871fe19a052325a7aa8ebed62104cf8be2dda3f6d33a879fa31a5e4423d634183dc7a9498c889d58743b3a882bad1ebd426b9c15f3f5973d6d3ffa8205a6b1776bda79ba2a8c6bebd19649ab06e2ddbce8edad08db9550f1eabbc2cc834a2d07385d10da23e889d3f6fcc550e45ae2284b9c651199a9b4a86f2c8816534179201710fbe62b1b5f0a849f6e670407deac04223da3d282e462bf8f09463b7e9a8ab766e65d71dac9292c40f5c8b55c7b860530508a7391c688137aed3935ff62b303f1fef72372a5dccd68ebf85bb82e8e9f0b7a80c426e5a2b6b3b4db38df687c3117bb5e44bedb32c6ef436f8c673da90a9b9b18e4488bf6b37473655290d6ce2fe84578e4161c9ec4963bc7fcb4f341b416bd74ef1150344f638c57cf346d9027da5c4c4fdc7887d9c27980089889dc68b63274aa6564e490e30735b4177fa5f220f400eb702b7a6d246d246a4ccd452a3ead0ec21aaca17c69456e578fb2bb9bdfd5357f27836599feff323119a0c08e22e4df1d74b4de66210f348b45e4a7b4758121dbe7344f9457dca61c6743612b5a6b160b39c9a24becde7781e08d89363b50676d8a95040b9ab5d61faa6175feb34f8d26c2a085c807a0d089ec3ad6f298f10edd2d60fe7df122cfb6ff71641382106af369e004dfa46bd59089f68c30dd9085d95ae7b4b9e4cf43dc735970f6e065ece7a4d778270f672d4e1fd55e9c46419faa98005dfdb9c631ed8b6dd6d050326242e376193697dfc4a27e91092dab7639784841dd2d2d2f116b0ad93809996445e53262c38f4fd28e94e530df85140c2d0f3c486789ce588dc8f9344090cccab298801ca85b9c51d027ccc6e1f059c53bd490f68028c08ff9047570987f32a29191afabc1616874f429bef401b99c6063377a59a05451cdc29a9b047b8b257265e7a5b9df907b5793817a2f3a2609491aa67d238a2e08e694c0ffce159ce8faac0e289d68d68fbfabf22dfb5d270612c4d0121d597b5a54e6e918da23c441450f72d8fe0a7b1370930067caa3a5cdf442020f688f08789786e7a995a1a7347b4ac624de4c9c03de20c94dc294ceafdd2bd3688e43f3697926c937e1e99c0908ecde003660470d4fdda2cdb6fc8e932b937da4f913a444f21d19d6c868bea816a101f19601e6903fd4594f012e6d7d4b09306fce92929911b5ab68d89d2da16697b982d3bc8eb0b21ca2b2bb52a1cdec9fa4cf39b41a79e214e6648fe4f1b9aec830170cdbd102022cde179812d1c13ba5266215b82ef8fb6b028fe47be9aa14c5004a896a621b40be3d25017657eb272c985542910a867cf8e41f10a773bbe96924824fe8236c8cd8a0cb0bfa8788a118c3e63c4de0e31d0376b0c2d35b56ec0576c50a251bfa04b53de17490580b4fd9bfe63508e27dfb3911edd6ed3ad0706dfece1a38a5800564045e61e30255d2eb91c0d5ab99826d56b77b10cdfd61f08a07456684c8e252ee156babadf9cc2f0e917b4b5c830769159824a0c82e4abc872ad07cae7bae5be4bd64d705371e742043fd073665beda5c6bdecd1a5257cfa92032c9052d53a9702c78eee44aad8d9eca7fd4e8746e313e8fd58c978cfe1e9358c9af5173959f16f84cf75b58335b16a27ebce8e8f75c549e161c1dbb7072eed3d335c9657f43f0e9b6edfdcfdf09b710e4c0cfcb1a7727b60dc3426c16fae253fcc8354995a6779c7524f14587f3914535aa2a1457e189ba648ccced48221306262a8e6176e1fed0df9cc198996a3813361b263556fbb69151bcac1f4f9afce2e54cf1f759036bd5c3b83961c3041b13c577391dc1e609430bc4028704d8a7bdab08897a34a24994949afea8ad32d329abb77005b894003620c538b6528fa2902c202bce964724a36c661f3fcdbbb2577d00a756c7b528821895e08cf24b3cafe7e13a5e3e99d5019162822965b713fda36bc0e03c7f1bd44c184a7695e1f916ca090a4c3e5cf5b2633aff6b30c3e5455419146789c8ad0565c82df05f1184f961de6fdcb9cf5f8c4bc81b5254711014136b5e834c00304e936dccfb88f1660015f6fa87abba57aee20865e786c5ed85841af67f04fdc0d9f795005993c8a368f786543c50c5cdd7e9fabbb729296394c9d0339cb5666d8f7e8d17bffa63f77e28b1bb45081dcae29450905e91a7245344829bf22db35ccc339465270b0c6ea767bf3845911096ad38971e43f04bc9451c567bf80a9b90e158594ca5b087f267b1e4a70bcf04a4840e11bc4b16736035b67165901dfc87c07693f553b38a36dfcc6550e050e584393dadcfd206005f0cf6cd6d003dce0f36f247671cfc608df99cfc997bf491caefd6f7b910a40ed644627a5205cef04ca6662cef3ee3e59cdc183cc8e0abecdff848378d54180f924cc168a5faec9efd487a2c5996eb158502d5d0600786e3b4e09d3814db32b65b2f0c97cf609eee77546874fdd86451b11539c814c23e32e6c6dacb5504bf697c910b997c7e84db7f11685bc4ea79e113ba2ca13920bae410a14bfca01e813bc26667b03b297323be48e41e60718d2a0e86ba3ded4b04bf109200bf7541d38d2cb9313a437cff51a39052c53fe829630ca7fe2f72ee9c628d2688b1193e170918a25ddbc4dd3823851880777d32cf57d1289fc2b603fa3d40648fc2990b35d81faee64910eaee5456bae143221c40ec6072c88fa451708f60f1c6ab6ecb02e11cbc053cd3939329a9da11c5ff984fbbac42c4b1408e6e7d6173a276545e4fc690c06d9e56d3f51a56f8076d78d9a51c689add8e9abbaa1800d0f5f887cd5a6b47f41f78b7dcba920977c27e4b386331d939b85faff3c7d0a8499387856c4cd54afa2750ba2aa364584bdf9692e7743cbd73cf86dc3138515eb8552c59cc4386e699f2e43de15c13912594d0c3e86524b62005bf3e74d713cfa4a8089b58497b331780e9925b3725fc9cef8cdfd175e789d9da9bd87c31e338ade21ef2ff7853ae2a4cd6f99ba621654bbb10eceafc2f98a9d59fc228b273c414b160077ae99ee2bf6a975a0230598a12ac8dcb128c448e0ec9143afa51034f20e9e083515297866a0b47b29b6aa728d77e86c5bbb98b74785b628acca1b691889b14cdf16d1d6b89911ec0bf8ed0aaa839bc91afd49f37461a528a41c032d5894fff21405c34725fd00023cabecff66435c1bd0ba823335df383d66cad88129b67819d11b99beabd170fb23321ddf42dd7b648e9e82dd917e49fcc360af89a6990f311912b23cb99e1617ca52cf85fa2a419a0a809f61224cdf1464d310585c0d166004cc4c24ae09953baef55815fbeb3f80a6df1660d832fbd76d41c10f8bcc3d06391bf9c19b70a85777cabdf1d0ce1a6e811430be477157c24e62c7cad97743c1154769e12baff29e7a19e948c3260e877f6542e36c5044d1cf5bbf7b81ddf8466d90633df7d9e0068b50ed70df337ac8c274e3d4e77d077093670ae3cffbe295f7fd0a5ec28989c5733802d3a3212a7b21a7d920de29f818d3d972c872b8cd1620a9c9e9dbec72f5b85029fbe5a1b60e2c52c2c8d4d04b789de0cf6e31a30ec8f44894399e3bade4cbc941ec67ef695c6bddb0f286bebda3595633326717ed8b6dc76f020527f9221212d303b05be50139a9572de7486ac70d1a819ab6a266e6be386dd9c41adaacf1c388d3496bdef5e42353b5c2b2f50d0e295d8bb04e8f3f53fce807fc6b1c88aa1e4d0cc21e47047c645a9a221ab68ad363f73fb05e60921242a3b021251baf1da9dc96efec6013db33c4686b06e426121ca17feecb3f32c6027438e87d9ead33f121d352bde9aee49a14ea0758a3e164b5be43312e70e1099234baa958bd5c6cd9d69c40297cb7b8bfe06c8c522c3441b798c5a9f23e22de6efdf1cbe73a1ec5c8426c8f3a69ed72af944ef1f0e9dc2635418a7a856803434525af616a11b52b04b24412c3c4e64eece496325ec673bc67f6b8db4063db5a4f51f0365800445e86b7674c92283052905f74c855ad6a3432517e40bf6aedb1ee70708d19c88f445e882991b53e2c02e7409ac718f2e522a83309b1ac2be1ccdcd0bfbb02d9f499a3ae762c5717b9cde55dba6ecc98826a33218e650b0db9a4154ca588527a3622a0d4e24bcadbf41ff528a173e940fb477de8d1c4e395951e32132a9d59f8b041b82f51be9b83331f9f6b50dff78c1f78e9a0242d8f6422710bef83eb2e00c16a9114effbd8d93f2e96cdddefef2d62c9455e9ef99ae8a1d7cf524751925e4c91ac9b45e5bdab529e7e79d0908fd26d8e4927e108f23a52478e15ce1a1c30cdb37f5719556d32f7167234805848ca54fed075c8077bca1ae43107644f2dc750db4619d7e0fe8ac32707b1ddd8bdcd91b391147e4f93511d96e359f038ee42d803ae377cf199a4fc0fd79378d3228324aeb2953e18ffcedd31080b337eac3ef721cec0ee6a1fa38b6ef4045fb40c4be65e05a7cba68637ec5313775f02249e8be1a3f53d68db810147149be28ec0ff5cfc83ccb359a8e3a7844c7a1180274d56405f74d9b0fa29ac92130ab449964bbb1b4b3fadb1b85e405981bdfdb92d6e9dcd1af9fea215fe234f73bbc4392b6e37e6184bc5b0fc4c117f524bcfde859919a6a0039538314d5617d49fd54a7b46c2e97b82ac651708b96482d41b78bccb6e39549e2a22092db5c6394f35d3a57612e3b75bdf87607b5cfd222e0e325d21a7fa72908c287e2b60948cd17bda36911e56d5a9a2a6250dd6cb61202cf64ee2eb8c825db21c6744a715b04d21281d7c4f4e3627fae630c53821d69dda102a7792dd4b295a5fcba09c0892da5bdf2453c3ff1955e8f089c4d47e0d19bc52a04aa945a9a8ecb58655d596f2cbcb6bf26299704beb46dfdca359edb34d96ac6e3bce1394b877cd477ccc90d367407f734e5f3b50e0fad99480ec4d83534fcd653e207d502d6154913e6709c827c137489b6620c00b5eefe4231bf864ce89ed83597c42a7eff4d023b6115d61241106c99a9a40e035478e743f3df90087c10da527921243083db519c04dcf22ce9f412003b93c2a1184c389eba8b867d44a5310ff3b4753c27b0706878a3403e334aec8eb57a90477315632e040bd38b554bb727adaaab11abcc4513ce73b05f886dc8955e914afe4f056ee4bed6e806157bb70","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
