<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8daffd0b29f402912a8a48dc04011cb7b3e3a558592b85a67a8f308102b516b2bfc9119dd2c174431578adba274bcf50ba8b9e2c592b71c0120f815121a17f6ce9bb57a28c7380082fd3438d59cd399c093d85153449f469fda8dabd82d76b4628e13eb29be71ca2615bce3b9c8b098afeca2d3b793d695e96a2ab158eb019399d974a35efa6de8c19dbfa0ec38c87aecaeac38211e52f14c749af9c3578e160aa59a53b9e2e41bfd50e236097850f923c5adb4dc0487ba50dc3370079e1090d777e36c9ee967e0ceaa9bf7f79b11d69e6c282fdb04f33f0e445f3a75614f01f55458f6b9c4f13566629b96f075803ea764403e2413f5a3f03ab1c7571a1ef4728596abecbc16389bd972ad664285ad9e2976a9c4690b3b4a60c9497777ca85b73f03eb1fed3d4e091bec519c3169d147879b6a84f4bcc29226f10af798a7b07bff570f785f6bb786652ea7a6a6cce9ec7cb571a00621c16b8843755d5ecaea33824a77f2e594776e95f9f85575ee83d67ee3add7390cfd448e52858da03fa8903e465d1b9a7e0e2c298136f900d9f7f120ffab03ab6fc7debd727d85df9d32c8aa576c7b670e3e53ac7f06cb34df6bc766695441c6cf0efa90feee473c41abfd8313eefb1f39bfca03f23e7d1df020715689703fc03ad799734369bd4c73d7190cbadce11d7e17d2559d841bbed74298f8a5f6dae550c5f0c3dbeabc41f37cd72a180ff6ea750e73dc22c72339d8febb3c1b9b3993207d7e2153de4f5af9b530b4c461bb78596897132ce6f50a5bd72772c12884f45d39416aa9ae2d3a6c5f7d2fa58fc164e3441f68dad7ff9d7ceffc30025d5fca3ad581cdbdcc5d46e5f0b81ec196ec625b03f85066607213d36d2e9190097d32930921c8851fb2f85803861ee733b1209cc47c42b2df7368d00ee3f52d919dd217de4c3a48fd9be850b5fe1a2eb54c20c0305897e226810783fe0632291bc6168ed3d0bd4b7abbc44994c799eaedbeec77ab0731a5ef64fddfed5cf2bf0be2d5721f1bab0654f15b83303fd2580b96fc400a18c4896bd6e6e4c369d5523562d140d69f99e92e2963cadda029099059a0b46d26988b328578b482b2b5e3790fa11d990ee0f69b9654613bf9af777dd748be94d66ec8f7b2c5a3237fc8933d47df09ecc3359464fe6791b69d651064dc5342a8e2f72093ef0058466286877bcfce78a024a1a397f0f9891862aff9a459f5bde0da46e363591a64b78967aaa4b47083c49fe2038a148d70a7f6273601e304f7e58753e7bfc7ba5e4374046b9f13d1795d340344e56954779428b954604e18f5eecf7cf648a3fb4207ebdf6900bf5184f962dad9fe9960a1ea81bb9acaaf7a058bbf0a9b351e9b02fd1754fc5296c2470c6df32ecf59fbc6616bf17c4218b4e4e72d3328464b14d31678addc45b075eeb0f86987cd336349af2ef1db4d417530b353f9b2b2ac0c027dc0363921dc3ebe695f8cafebbc8517d66a7acb4bdc371bc7ea6d178d72dcfbeb689b8df55ea2fb3be454569d5f576e9daba75d793f92bf7418c1900f6c795b0be8c6b1cab43d8eab4742c69f29d9837af531fea94d01de9cb80717a21891b6a56d2f121dff0356b9fc58d50b90fa2e9b8084bd6d7b487993ea653586a2bd3cc428c6ae16ae40c2a9281ebed49aeb5fb12b1558769199f576a7b747bbf424d2b4cad3caea29e724bf8a911d00078c4638a8267efb1e45da389d46b2bdd15e0b9c33351142791da8a1b89dd8a8c4d107816ddfa1d577230b1ddf9cf14ad9456513f83db1162e30ebb219e365a048f4592b3c2b7d52b8e084b91e7ddfeeac41d88eb287f62da869c0e8de2d142665c7a344beab86d2337949448478fd1a0c46edfc74c633848b62617ff56b72150b17b1853e37aca76c77ca604d1b6397e27ac42c6d4cd192fdfb176f86e3546fb38a55a94de1a2e507ed6b3eba6a7ce20359086fbea329d2ee2fb38e0c25c575b2f637e4fa301b0337e4b05683c67cc98e5c03c2c76c47febd3062a9d54af2bd5bdfac888a8cc148f9a7e672c1b7ec32e908843918fd01364746f66023e895cf80597aa94a3ace8fc8988a02d31394c8f306e187eb4acd084e5fd2e3a594345351253c89718101a91f4e02843d37f4cbae7ff1163c76f06dbb39a8e50baf9dc5ccd045821298ad8f90b780c2319f1725da9cbb18ac69c92b5d4c475cb986bbce19ac0ae77e7f5bc43272a84dab0455247ff2d9580236176fb5be99f176fa081d9f37f8a596c5a5b46df2c007ba937644d2a16aadcdba6dea306b23eeb359c2c3209284a9e0ca13e1ebea98f3f210afb5fa09134a1e7f64e9068b4cb9fc4ca3086b27f3be8d54bb04fe6008a5178ed3a752d798227d01920295fe21994e298cfc02b1c945d3747faf396086f2bffd8642813ef15068bc5dd94d66a8130f6961fedce4beac1a370268935ef0044b01030e5b02dba2efb00a4a2371cf2a276f2ef72c6153636f08322bb1adb9f3586c5e277bb0b732b4656b1e407b304feb4e04ac8ff29bfc71312cca336ba236b5274104d11331b6fd3689063489033f672c911864bbd32bf49f7073f0db64b06ef0f43ae018b44643b7218d6238992830dd051442486926303c3be59baa377019840fb0045353563bc00dcae79bb8f2ed78026efb6e5dcdc65f2a1b936ac705bb63c3082c267807cbefe57e8c3e3f0bc73ef2f4b71c5e2a57688aaa79aad0508fc1e7219b7288f4777c5f0e9b3895722a3d736247473187112c7d6378b5754dfb8875bd7a923c489c7485d3c912bb8228c56cc2643801018b34dde4b3358662ec7d52076245e42371111d094a9ee68db16719ecbc17fd68bfd22e1d18d088caa78d9b152412f8da373c5e0e549969315a3d38f48e5ac21a6fb87b576d359b098f44a7ee42267851637f3e166e47e49164eff215d9ce0c908512d865b4dff8d1945ce7d2169458f7e2dc9b3c3ec334b820c4c44f80f01a1b97dd2ddff29c153cc2cd892134b9f780a219efbddb5d22a64930ac140bd2948ede42bd2c06882203746524fb5fd2a291cb85fc6458221d1fd282852dc01226b98a7be462ae2f315047c98eb43e915db6f4ae8882b56fbc03e412c6d7af0c297e4bbfb7ea25871f30cff7bcf6b2cb6040fec809357484ee28a7f6b1c0203a575b67690a3c2751fe1d307c514d1f1442a5e80a6890a357aa73d4256965a01e8268c693056d633718a348d0fe5f0e5a7cba2c1c02651733e1caf7a46e2f6826b48b6b182d7b5d49ad9924187aa20c688ebbda233f8ce71b190ea1e7003fa48561af4d4642f8f8fe37f77604ba4c37d774e1a230bc8c0b41b5ca28199def7d5fb6ec11f6390867597846e0eaa5ab769985719a885e0987db4d53c7a1451b8e5f310c11d0bfa5e9d4807bce5f2b8f684f8d333c11523005f158bdf8ccac21e5f0828d4fb8909df6ed3ae20164fbfc7f3be3cfbf2a2d490c0936398ee5bbb42b6c231b5815ff78a87f17e9b0a985123a1d7f65424a1a8efe213586a5dc289e48195e51aab798e0217bcede04346ca9ebc35017d26232315c7b4b94e9d9cf074fd45c7d5f2ee339dec82dd4b91290d70641da0e3a6bd31a54fa734dbc5a92f123a2cc28a905700e747274122b074a40ca2e07abf48dfdbae826fb78884b93f41c06dc6415abc4c242fffc51a4b8a54d254fc3ec6a3eef3297c82f008bfb8a20491544a7db5b68efeec998caa7730cca2658f07cb03d2e780653b02d6480fcaaac21c2ee0a39133407114c55870545946f88e2f558c47d315c0ddbdfb13c84b9f3d21c3baa7516fb0d97d65ec923372693c8174f2693db826894734cfd1dcc28a72269cc0572ccc6f1ed65141db80fa622363f29fbecb2c119c2c752ac9743facb52846885ab1dcedbd378d92bbcb73d4a54c014c60bf47774b991f919f0f6d3410b6246e23f8e2e7a5354180e5ba026436e34a4df5a59a29658b7a5c256ea25b41c80aaafd28e56b07df5e47a4b4846b8c4c30db65f2d9a00ca69c6bedff40537cf071ed6e00180f3e47fb33874c6be88bad1e0cc74a2601c25af3664cfe54de71e4274996219ebeb97d7cb3c52728b35f43b87833b393762494165089427dde319c4fc0041e0c4894eed430ce2a6a233ee4015c464b9e80097d3e46ec5724ed08c28c6177a6bc3631ab74cc3f721a7be932c9dfdbba933a2aee5919a9d7ea427a5022264e96e5d763e4353320a3d5ebf3c9f2b9238f747c5d5767707a2cbb990c626df66f1230ceb2c870e7ecbef3c7508d667f5c5e1165fd50cba5192c3caf05301559d69289b0704d286ee71b8123f3b9ba0aa106638c9267b669889dcd0dc104a7cba3b4c1cd201b3bddca70d4e8c71877743d9e87298e7ddb80b187f513a357cdacb69f6dae03dd8e842c2732f8334088fbd54743bffc379506ef298f5d671ed4caaf12ba8bf02c583dc5fe3b6128362ac9d334887c928cdd7e8dc44457cbe3b39aff825fc02f281bf1030fe67f8753346bb154414c8b6eacdc32c4da7c6b75d823576096530dd7856e5bb5fb92e84959679e4af5a350c966eafc4afbdc93768e285d2b7451d590465219d400a44e78fe16307f409447f26d85f1479b5deb2c5a292161475557ceacbd082d57b1d296899782b15cd859b13cbd45ba080642085e9cec5b601d172ae3b7c61ae610775bf4c5ea6985aa9caba7da582393faf08a2d9b81770bf22e5afc3a1eb28b294a862f40ddd74ef9a0afa36ae26b0db0752fb28db7f5be74a02c387b803b77fb597e14f0ea37ec8238e511be0667578055924342192ed63bcea6f501d52ef1fa7fe04d22de689fc0978484f9016b7db3888e9194e3fd9a9426bd13e718536bcd266549d42979b952c109284129ace006d4b4760c23dddd2a01815b8a205ae095f2a8b31e5270582da25d83901744370a019468a5cf995c77f3bce2525caa860a98f6dd8183ae74625b138c16e9983df05610c73513d56524f8b752f851d58b11f9b2255a8249b94a745994dd0dbe2629b2e09c560cab54789a82a6e0fc068ddd3a9a045b096a87d2a5fbd7868e9e05b1446c4cd196da25891f1630e202fb88a1ea34a1598c2794595ca58e4f8b0f392906a0b7b680e32455c4db92b2174ede39fca7bdfc0e269aa115b5547b202dc5b624f0f08b34c2fba4cbd4397e4e5c10ca61cea4842b5a4f67eec1a2c89b27ce4a07514e80fba5c2b6de8b8c40879e32e11e287439aae97209fffb71a08dfab1d6422c7b68f005ec68d975889bd429e9da818e067ce8d5f6e2ad00dac9bce2f07f8bd1548f0e11db50bc8f4330c81a23643e98025d933d6c8e35ffcc4a6ec592b2a9fd65ca84e6b504284d1a8c7c264ce7c3934a111735f63eb5398a670a80562e108a9a66f10403d70e995f7bd192f9c2a17bd98de7978867ff21ee49febabc1a0d1b9b6da1684db6b87e3129ad8d1492b0a12606a2da2fc9f62b147329ff32995e45d9c3e26b983d55c8bf25b487f770d6db2a65a2c231b71c38613987ec38a97fb970cda3e3f785ee6cabb015d259e7123c0642698e2beb4d69c65af4b036ed5b65eb31ce9dd722d39c79464f093fcb4d4635779984fb81ff8f50169026eadd7a3628c1a374f8ebc225be4ca400db44733447ab89699657369dc85ed1d0ec04067bbcde7968fff391609111f2955ae541ebc9c61651f2d2e948ee539812faa6698cfdc3cf62b1992ca4a749491a6a8bda4697b471b5eae11dc5c200bf26766a3e7f4b4c58431d9f20e34fb5a2b3c920c75b4ddb45343fd199bc23013fd799ff75b5ec76500663e18707da58184ed43442b1de907b1024eac13a84b44671097d5fc202e421f5158460c56bb30b50626beba016b090358fb5b268efbc859f4c2db174d0d2d823f230c04688b25d66a41b0991b2b59177e7630396835574b34d22204604afc05eb922b72095b9fa42415a6999c4310108c7c71f99ff960eb403c898ebb5855bb1e6651084d7602bfbb74ae4abc190cc3a0f6b8ce88b2daaec3a3b33fc3d397070fc3b5b303e2e8d374c68fdc651e102d78ca3a3db976c9060b7cc6a9758b54f1a708664913a623f6fc1db6f568f9fa73d319778b67dd2c8b851625d5c1c661609871f8f84350dc54785a88e5e6a21846e6fa28c940f27af1a037ec5b4301da6ffaabe7fbeee388e5fe9654ea553924156470a75eeaed5c0f86fd226358333915f642924e1d100df3126f9be05551e04966346840d75e1cec2aafe9653e6142c5d335e91c88cd0c7749e151481a8c6ac75a6ba98e3d33141d887cf7250149170fcaf8223b82f056f1af8e9e0dc87580287b4b12d22817e57d01fb9cf9a55f89875faf448639d298ced6e1d4ea1a3045919ff8461883c1f5a18a3fd075ee555200ae1385dd07c51abf5bbb48f5ddc1ea73b159df23b8ccd82c03a658871dfd119a88ac798bcfbdc94d925c57fb825ab7dd149a99ce761c2ed627e09329782669c0c9e10b58c5186c7af9316528a3eab3a344216317f25b4d9feb117811a1de33f201f92f5c6dd299fe68ef0923adb479db7b47606c4745fae66bb27a8f5c58354c2c561c5610a14b0d5ddf65bd2ad92e5fdb3bc736ed8cbe1c87f03c2a5ff9a69112b3d0172c65710b8992e779202d6063330a9f2ed2d70a4e730339a358222859823a78a685cc05d60b00e92d27ab4992ab27d7170628ab4ece0bd5814eb007251a3c1b131b124bd6c2982003666283546eb6d7fc0436e91a747291a967013b1f6ad53157f50988d7fa81f4bb864ca62525e044be672fdcc1438947b486fc9f283d78f371cef3d88992b6c7208f0660b84ad10b881421409ddb40d3f53b7eae0668378c3ad0291366a65a437ae8844358efb109507c6e430d427bc9e70abd68c8ffdeb67811de4c077c1a9e18180a12fa41a0a66875b5f6f24b442abf3dc5a7e7b4a87a38d19ed124aecda981e39db865fea4e9a7f367f0a6f14dc2ab0235049ceef1ab37e485e618b0b9450d9e02fa697f5bc16baf5602340990ef50f2339debe0c499bc4d75bbb5140c65c93da49fb55c262e93812e4eeb581e0c9a162aaba8a88cdc344162af1515bc4ca521d22f8995272e512eecb87efc150d84aefe86b9cf002942526ddacb0339e0b1a01ec889bf11b3d939aa2c11a75eea5925348d68f00a71a6ecbb3afa1be22e795740b8893ea21987d1c199b9da2b1932920568e22c8361e15f089625992e7df692cfafb277757229e6cd92b0d548be96e37c58d18aafed531748a5383ae0d06b48f277b69690dddcd7db9cf97be16b57c3e6abb9d0fb5f876114908c71957f64c89f2cc533786ddd8aeaf21f5899b857087d5b3c501cef5518f2e33ec87f87d39319bc9a7070a30992544616377b9ded49bdb0aa8659485bf4e9f55bc1d7dbe4228e179a4300c1b9d367d89860efa1a7e48bb3004bfefb8967ff721ccd6cbd3d7f3cef64952a5f88c71807228e89de4c853989d09d2b303ab50f4690d649b4760f620ff531e88557fdece53dd65c03031c08bcdc5afe9314f5b2976476c3f27ff294081efe86260e1bcfcc801a9e0ccd468bcff5bd87273e61c1aac61c59791b4814e423bc5ded0796f1b2a9371e970a9870280d56ae84ea9e5b51c3607dbb0734f4293c02670c0e47962b4813145c57eafdf1f969a0836b93a3a372c885e40ce7715764c2e863b28e728be9fdc0444d96124a88650a77bb6cf218a1d106c871cff7b7050cedd845922b645678b3a4ca8e077259d6c64bd8ff505ef2c76bb865a4b1e148d03dcdeb7caceffacc7eceaf1788ecce9dad61d74edff99a78e22433311b399f0ad62df88a34294b8f4bc57ce9795fde80820a9b8f1a80e7cc9c87909126d8b177b90166c3a1d44fe76a44865a833148836d519014ccf56543022e0ed629c5fca30b700b0e089ced2bf19ffb074b7104b09933123fcb8a71a91c0cd6d7eaac87276e46d20f328a649d63d21cac908154d54736333d2302206500e924e37b88f8710f63706b6f668a84c15367f52a97e3de34ec2b1f1b202085f5dd8b2c8e7a6a8ae5aa727b3cb42c532961de829aabe0459b1ef13bf5365cb6a2ff30a9710f3bc20ba677bbba8c8a8153460a5c7b16c8bd89654b17a6a5a2603d5c59a1ad3e48f2d0720ecf9ffc131a03b0390eea930b264d885eaabe38e2e4f1cbaeb3402a26dd523260f7d4e25762982ca1f80a8bd767af68d21369f160139c22edafa742a6c5ebfd3ddb51bdf2fcc4e57984b07cb657fb4d128b719d45a4f9f9f5413bc7f7942df52484dd9ce421089c5790faee1eaddfa43e3a0348a5fe5784d65fce6eca831a149b132eee27aed28a8ab83dce24c4d0b24c518c4d1515e355c2d141e560dec4c8880dc4e8390bca8b63c144615147f305400462b8edc6474923b15b6fe6741d8d18c51dd06147068329911fd51ffd96a03e4860a0dc11bb930847cdee5ea2b2d96be36e8fb729b5988047369149c29dad1a3c27af7274d94d7667b00580c6465a1f2c032bf447776400f5d862adb6a8799f19b5bc3840bba9eda4a7b9b481506fa8988e16abe333059cd27d7d5a1e2a182ed1364244117e7f538501ef187b1a247f930eb17bf38c853732e9cdc8806d5c55f9ccc93293a90d08055d691f4240a49b5c3523c12e199309215bdf71d662bf459e8d4f7b0b35a98509714b62a9736887e633e915475344b589b4a39c0b3ef707ed3807e8fbea79010b26f7c72e160527ac84dadf012fdc59d79b21f20c8473fc6214d12d49702278092ad6f62c67cef38b90f07e202c57fe6b619ef80a3bd771c0f0e6113d0db8d948f9fc474c99f212041e3fbd16239e1e94cb16512c47471962e9f34b4efbd24a057bfefcb2ef59c28b7bb1134ab0754ea5d82824df2afe28221f18934c4b09b9bb7871fcf976f0c9184a130225205734dff715913c9443d28ac4de1a3e191887de848c346f890829fea0c9f9e56e0b5131dac37ab0ef289f06cb59c46d19950816c4a437ced75bb780439695a03757d552be77ac61b2eef23b9417a5eb3802bda8dcaf72807aa27a4f903526c3ec63c323816d46086bb62290fc375fa9d116ae616a9bed74b6ed9331422d91f7dd757185d57b97e5089817902cbfec7f98f8c75cce55c3933002f2f82e6fe008e16dd16081b2a3a327485a486277180cfe52450c40aa0afc9e7a5f826282315a702bfb7099dcd12a1a658cd0703ae2a4897116a6e35d848367a7a7f8fdcaf0957f0d85a95e8bc8e6a17f7671e3613a936c2fdae31d4bd167bc104287118ca4033921718f56a18fa0dfeed745491fa566e511e57596dd8cf23d8da5d05821f8d930d22ddc2bd4457b8cbedcef97b6600112af2fb7019c3e6ebb2388535c7bbc67ee95715cb8e9e98dddbc8246b260ff8ec2a24455b9506a3a7683a049debba9f45bcf171350597b6fee909d5c42c84506c61055f16ba1adea070b3d368879d42343c885fb78d8cd055a8de7407c583f38fdbd8b284fcde8dc8930d4869b27369d8131b65ca5de98af8fb05b411921ddec4dbc87bbc850fb839ea69cc40f9c2df48fe95524890b0fdcc5c4bd6e9a48444dcfd9df333537c1717c1ea3428af63eb6ac17dd54d9fe78a4fa9a7f89d64ea6950c24568dd10678a67b444f900fc23afceacf7fe0a9879731d1dbb2ed60a1ddb246da73fb704e6bd9e8cf68f93d88c1107ba3dc8d2c8067075484b7deb38405f04cced99a2ab8cc53ae82aea918f8a20ef70972ff4436794eb12b78d18af4b72cd675b63589e83c649cbf9b8a65fc9dab49129d004434ad203334e35aaeedfc277f8bb051cea3a7a58031d885f644a1d2ba3c758824099d59ecb732ea33289a74ffb5d7ad64eed39445e9240da4aafe7e673a23359ef310f164704b4a282b03f9e0fed31432aab74147598fa6c7edd003bde051c37436635128d390983caaec2f78ab3395cb7262f15c3a7b2fd0595e8f7957c93865ac360daad61fcf8eab754cb7a4d2c582f34f23e5f1cd6e7552693d69e5a64e8af4ed5d3190abd4fa28d0a4eb68ad8624a37be28c06812d88be83910740e7cf625bbc8ab1700f55b9d781eb209b2a176a065e040c6a4a536f4292e921677ff69959e42a9a6858a0877ea1aebca1e21a266663aa50751273e4cbee814ed9eecaa8e38475fefb78f5a07b02bd693a9c673fd886cd718e3f2db5e3b58ae7b3b431ce078ee56d4320e47f0db3c4a0342bfe8686a1a609222146a02081f31d32c1db7f7e357cfadb818a098f57714a8e7bc0983e78e54bc7fe2b5d58f5eb91699ab7382ee5d7d6094945e784261cf45d5ff3fade7f5a1d7706a21721dc23f11c207c840cfa39bfb874c1130a6b9aaacc9668ae079d996f2c1c2750a78390f9aced4c2def34e94c567608a2502a521ab2b53005f7009ccf20582da234755ad5a213f4ed507005aad052e493f231dea5aca02c219e3e7560898f21668eff542174de73c5f48cffa5114f494522422a7bcb1001000f62dc704917f19b4b4cc1c86283ddb8301de51e6e428d8721486f9da3d2c3dd4c8b4284866f473d859f98e7e73c6fa899e7d3c1dbff4e04923648889c6435f967ef8df4907acb81e4f89dcf043f855dbb12d329e7a567fc4a7a1de38732d86b2e253543b21c51b1abd607bce835d9086898934e5b98cdb203408817cf703977efafc3f8dea0efd5f5fb774d521e94becc2028c4dfc7e0508824529e01184d081909114fdda641c85d894bdd6f48c5d22a322e64e93c0798b27a63f9b9348bd94347a2b8ab1ee4da9b856d0257b09783abe6746763943407fcd4a846a7d26f70292f415d34885d720b5cedafbbbf1fc7a4add001eeb934722f69efe2e052948cbddeca3bf6c54a62e79a1a66f115394ff17fb08e25518d3b17721679568e12e33daf156c5b90e64333c966ce3fa59b03b112fc1fb2d652d30e9ebe8652615323b61d65236b0419cb867960d6c01de36274248cec7a73bef15d368e370128229f69945415da72b46e5d803896c256cd09003d1c9f133577bbf769caaa52819abaf86c7510464dd534a9a599e0066dbd34cf67d33e803d12f53b5773efdbbcf9300d2b0764fb95c412f617bfd21cde7ffca0c5c3d75b3fb1895edb45e69f70feebc0dba921ea36033ca1e362b72e2dcb8d0911edb83381b91b59a042a498cfaff3a4c4179cda74990e8abe990aca53610d440b51677f993023359423bbb74ed11c1b381d421a797c229d7de5379750f7ebdd7eb8e22de0b0ec4bbab70f0a3a4de90e13ea624adcdf4fa40ac4da479209ab494b28e35be52d746a03fe228092156dafdf8b21546c5b2977cd8dd9611e6e67a85835852cb4a3e704ad7a04d9f09664a58c04bdd53c2518ad17dc89f78164e699086059a8af7ac436012be1427e8a2fe141a1de23e4c343e055c6bb7de1434c699ac169a72e9d086fd4c2e0e0e27fc86fa57bd658bcc4746c75ce971774c905b5896c336301567c9848680a85d5bce6daeeba1988c018a57e21451f532bbf1a0f6cd1eeef045bfe58c5f4c05f66d633ad6bffb3d3fa2d2455248d5cedc116575039285bad53bd5ff993d4cb62042fcb9034b7ea5724dc66bfacd2dbc91e43fadce9af7541d6735b92c5b0b4bea8df6f1fb8d6101d15ffc50dd7e2a6ad1d589d371fcaa1e7a5ef96a6daf076e8a908f21e705d4f723046527c70a6e4a02a16a202453e861a4c52eb4a525780873f4fc48a7946c7de3b9652b8219166f97fc352a572d5f8a0cae490f3445b365ef013b3502517423d054606dbc0db9cdcc7cc870d5a76a28166af52a253c98cc9e4a8074edbde2fae23ce2a9aa33b759fa66d817a078a80799b551cce74d5cf38b7a19b5c91145eba99705150843ad4e749449326cc64d98f74630691f89f391af96e5287557c41558ebd7ef6320119d68378e8fbc094331addc91be6ac0f90bef06e250c528f35c18fc07d4672f9e7d0c4dca148473c4de34e6647f389110fdcbe2779b2f37194eb072c6ee5d77e589e2164bb6ce8abaf87ab58c3f195b07305f2c3377221024325eb3f67de5f6d7015b905be38734cc77dca3e40df1559974e5eaad4406441a3324fb390a8d1b070df3b3184b1f7fff54672b5f02ca5deffac69964d3b959cf498a708e2850d8453eaadd9862e3e30fec7389b5d932d22ba88265870f4935e1109dc3284f5057d7b6b5caf1302cc3f54a5049990b69a73df09d319a3205e36b1a3ef925a77c42bea818ee0eb421aa04f5a87bd47602bf87a3d8e990aa9b7fe626cd2101b29938e8d8f37ccfb014fc3f9f2daad83d67350228a58d062f981f9252680397ee6f2396fe07ad3e4c7cf980e37f4a4038887bb25ab3491878edeefb2020d202492eda334564ababaf8693083b7969a095690d0273c78f1c59af1cdb6594f8d3e84be238d5e6c6418fc9a8bf9d85983e96ff3c66336c7768cbbc09466eef40178ba6aa4b7421a1d2aeae1057939d48a665a4c82b7d61043022e6601a8ed25d6e75bbaf64fc0a1f08b2518a34a27c1e68222f1c5d2ba7a3c6dfdd7fa9043ecb9612313fec1c95c85e01580edb4d6f305e4602b4d6813339c63551dac595739a370b18d91495c581d29fe23f0b863b9c8b146adf493f24dec2ec9ccf764ae070eca299c3d1cb8f9020d5d282294ed5d7560452df2d428ed9ac54475971972f34a6f79a34ede31a9479584c99c16121220d36ae4c7af3d3896c55c1de13263eef17752df2fa754732708bb3d285ee73b36703df1a8f6e6f67882b636a5f2baf9d6198f836b7aefdaf926b07687a6613d9759e7179982be2b6e0ed0bd1155ab6f4f72e6282e5762b32c663f5423162b886f785d3db7b95df7e1c7e072b94f5353b80d094a3529935db829d893d6f00c502fdfe70c92b97fb904d92fafb4eb97a1ac3da05a1c2f8eb3d525c720bba4b7b4e4992336b20fd7cdc52430a786dd8b332d0a85be8a57277b1ebd98493184a4e0a5f728636cf572dd713bbb5f1f5b25ccb7c009cb558f2de20ab635cef488a513524f0456ea8234a25bd6f5b92e81c5d154d927bc95ddab557ea20257ea63b77d2b9c8e1ee71f5a684f6e934db0b98837d024f32576eb305622dea9b50dfc477ca8fd09fc5b678c27976dd21c0f21836b678d4e0c1ea1bdae1028a2a39f78cac1d56d64a8f9d212357611313c515b497a01161ef1b674deaef10d9464f67df348dc8bfac11a0388b3be0835121925d63347085143c0cfaf5c42c85a73806cc07bfccf3c0b9a706c17a33af17bbe2ec5258badd32f0f473bec7adb05dd3197106d1e6f18246ebbb76a6c09a7cc2249bdd495b91b2fc57fcb80efe0116fa2845c9aa2d4bdcd5d37af20bb3f11229045e4bea7bb976b610a09ca84269b700cf5efb2326035c595b66e4ec49de7f97658b2c62310c811ecafac5c24fedd0494c8692a6ec9e7d6b5de321a64341a05976e282f1ff433f0d8065fbcebbe39d5cdbaaa97646f40968069f3a440e04dc16f6f7a1cc4564b34181ce66029e5eae16b3cde4cd4b199160bc3212b11990247ae6d43c8ddb47e94f4fdd07591a85710e25ccb45c374a599b7852ceebb81a06ef7696b86cae5be73ddebafca6633e134597d2845e2df07ae5cbcbec69cade6c9fbfa3ffa419895e05f826b1e86f2128f2f82aaaa5c6fb5f00cfdd3dd4f0bc8af5576dfa73ac7a2c0604cf65cd1818c78d3bcbb5d3551285cd571371c40b937e176bfd4519d960899a2904330b3a9d4c0baad6772ea01e7e2aa727b9765e152cbf5c9dda5bac6bf8ddab88f57e0603a988e371acdbed812feaaba0ab982c54890a7a3f5f0cf58d60ba754e7c5577ff7190213251611bba682500e75e7fae8cf369a0029dc7d38d195642dad61be1a6e9d74483852f46356d691c54e52458e0219a8147c2e13d15e70cac2eb770c09ac4e706c042fc1717a36d1c5189c1a574a50a7877d27476042d37687a8e1d65185f1ead224f5e128b0082bae0810eec2e2ee6acada7ccf92cf9ec9d5c2c18c91d4a7851ed2e90cfdde9ca1f71ca7355541bc22b6a741e9b9a2c2b695623085ef276a53debc1b657104937fc12608f48611c7d46b00112bc09de31c9fe99bc997466b741815a86c54f83499678d9e62a9baec34e53c3ab1f1870322dba672ecf32a5306d2a6221c55b9b2bd05a7aa765494d2ac6af5671cb786210735539a3d30b300842f2d48eb3ac789d25992a7f1602baac5ec7d28361dffcfb2293e27c82f1b984ded9e3618011747cd44bfb3b2ab9f830be3f4b263d3c955d3619c82d026e3e4e463fcfea78566c1d2ce294594c83dc6000feca9622f216b6adef8696e2b97009ef1d0f9d87931bf6f03cd9fee683c0767e3807acae1c770a1df413a342a1cb17d2fbadfef2c2027f8e6a6198b60804fc3343ddcccd018e0e9859c53e66a9e97821f9bbc638cb924bd52ca021d98aa75ba6101e460cbd2d650394482c6edbbce866b8045f66fdb027097d1a1c13b4105faafa1db6386fc2e70331e7b9d01eceb7b3cadc8b488f894df18faa6e2850b308a6a41ea83aab7479fa932cc5fbf6407c2a10b9577eeaa9d9dbcc9280f4abeba58bb1c9a81dd7f096932b927f86f48ef0bb51285b2a26b070780aa4623342b9acdef9e97cfdd91bddd842e08e8042c9e65ef0a7b7db40ffaf06fb7b5e54c7414a62f790b166760c7663ec1492893ac82cc2a0e3cf2dfc547bbfafe5c583958ddbb69665beef1526a2a767ae84a787320a9e858b88a801ae36f24a6a9709797c0e86633b1400748533da59f158aedab724d0d126967efb2fb56d1f06fd9dab7dcd03f5ae165a8952c17492cdd7c6656375ae2e1c63fcc0ffb4a031bcfcdaaf3af5bb1555afc472eacf2b4f7f11e80e578a3634c8100de7d004995e80461d8bf4f7ba4af28fa7027a073d5bbcf0749a99b5177a6d41b28a0f2573b253eae2c870ae1c824ca3675974fa7f8bf2f55825860f89666a555228f6d2e1a94148474c4cbda1cfa2f2d384219ba7e0582aac5b521a1c1dd63f0067b6f8d518e3ffa175b465494400aa448efafd163a4ee3e41c9c064a4e454f9accd9699d90d60657b53a2faa37fdb573fbe9fdbf754a32444316865de529164a85b63df19471465541e2ca55e3ca0c1c64bcdf5f80b83a17f492d2c98afd2fd92172c8fc3d965e14704363f01474b5acf031dbd79c90d7861b949aa449434c1b6c4513ea6f2924606b4c90009779cb7604e02d1fc83bed8282c09463df52f255e2ecd8a2171cca81fe38662e977b509d8f35d9cc66f09d5e2fd9f0170dc73fcd00da174a74fc29937f60c66432505e7c046b95199575804c4320bff41686b3ef159ac947126f874f1d9801e31fcb66a1ae09d5b300ea2c5edf4dc178a66cb00a5c20860253dbcb940ce7d9bfc814d3c145a85241691e463643cf45fc9f2fd2e023a85b055b9519413a2dc38fada296765f4f41d253566893798abd6d8ad3a341f17bebbca173e5702c40c8c5f67e4afd0518c72787b7612f257240d2ea76901e8c93dec28c5dd2d09df97e46ba20529bee2aa26d65bcb1c80aeb9082c851106c10ec988d4272babb11847d7cd9e8b67755549fab4ee856a624146137f95c500e56632e820ca0311ff229dfcd5a27e3443a63605c10ab8ea79f711d939d41b0f0bf2e9141329a6f24abaec912716a81d1326fa18f5ad248ab3cf7de22b58909f53de8975241754b755c10e643f5a43ab5f4721b26cca34678c735528ce7f82f823628fd5d868a59d360123db41690cc7d79c2978369ef13daef20cbe39e47ef7e61fdf70df578c5653564db94d1dcf6ea16bae74c3723f489b53996004a76b0a2b0e59a2837fc582d8256d0de8667130772867fd901e893f04d799ba62c07b36404eacf8c5a27d3012b5f5e2086bff5db7dcaebffebfb6142f078a8c65ef932141b030689b45bc4d6f391e39995a41ce843720712a73380af7b45f07ce0c205ba23c728bb41a7d810937715bda4c1cf5e57d66c35f5b7e3fb6909dfb5ddf51f84956ba3f5ac8438f87597ce899a70d894c011f734bcaee4b8a9c608fb1ac7dbf41ed33d77f661bf19e528ebfa9a256080b40f07de249b84c149cf5848d34a955d1c20b76c42c0dcc742b45d67328f96dcd14f2ff7caf6a23102ca39c110ae6166d360059f94ab48381b19ca16116231e7faf267705d448cbb220d3331c5f9907e307a7f1c88add861320cfead0ac260cb85e522c5066f1855698e535693e81056284383cbaf78988ca313a331377889c95cdaf9f16d48126277f51ffa85fb79035ebe6da6a26eefe95ed56ed67d3027a1770d5388f21b97c815ab56971bf695ad65b93d5763b2c54ea81a7c6e1e2f2c1867874d2b8409005094f523be3a8e19936f4eca6be56596df1d458e3f6f5d30e6cea23b87b3cc48c54766c941e8436d05d542f035a6584a7df38bfea82a4af77724def0f446387edd0e376c82b8cfc339fc58092b17e3de2f433a9ca321814d13898fb062d2ceb5055570177d0090ae84f85d788d6a75da16800ffb6d29c9e082a199990beafea5b7d8e7f75a631c6559979af5d99d9537e0149715eee374146413ee524cf21618c4025f48a6dcd7b8f40519003fecb6482c956aa27c73ad8b0fe9ead073a3c6a6b18b68429ccf86faa790793772e22789322e67616d934bb7510d2f43882519cb80ca4957f8af56a6c1db4551dddc59246a0e5edfda141f5ae5e0af0ac766d1fbfee3d04e3fd6cced1dad7b091440e776bb5bba0d7b4fb7f2349e0d9fd0fd069603d0be1ca74247fc3a21dd443d457c1c0bb3a80fb5c3103d7b460b89284fce5dcedd429222bd41b630311f9a6f480f0ab3d426d37f2ec7128b305118d0f2038a4a9810075f7de221a7ab37599d994ad703964e5bb00d415e01db3c51094296a9bb54837a85dd90e334ce5da17eec06ac7d4abbfd7a7725b8e9a8da4a796f51ff376e3dead186563bb1a6c50df0daed6af6726fde5884e7569afadb859493a69f76da1cfc75fb13c472f2a8eee7a97351282a65642e85bb29b5bd21637c1ddd16b576069d8f4dcde59c4d3fcd8c300ba88a42750f2a4eb0c0532fde23a76d1ecc11c7f1b28f160fab828a3fd01c351e19e88548ce1bdf06ffbb7ebbd69d87d7a698413e53f98709edc53430c85d1e32c8c780435bba44ca6aa236bf72f7aec1a342a2485401df6383da68ea2b1f1cf3b6f954e87fee92f1831abc22923f8a14caaef6b1f6a42e0a86a656731958f0bd33238f2bac142acedffe26099d0ceffb56e38023c8c9a62516c9d48fd06626dcd34c7bf99b785da65723de40271da90bc679d0dd75dfa4a6e2576d80fd338d964a7b6656cef954b904d47ddc65f20a6e38b6a0662557ed2802a66f1d43b2b67b67dd6ecbab19d71fe4c34022396c5b9da97d833cdb0578934c2b9a5ed2753ceef4d192e429c97bdc3505e8ee940ef4f46705402b0f3e92fd9c122d506565cae763159e12a533d8d352264f0b4036a15f2d69b1b28a82723158354f6f146ae1e0de53be804c10773a79594429f92a2253a4a48b0bfa2025c79c5c5a0189c0772a8b32200222756601011b4a00c6ec3b2fe0344dd24addb44b50d78a0e756073883c75f481176e7c03df549531c6878852c6fc2c0511d0cf31474162a7d44e1d254e6ad2e907f4d29f0d0adc40a3b4bed39c844b8a2f4937755e62454dac8c78b0eee74d243a24869dce2275250b3cfda2da2ca207a6a24d140666b0294867d8e65685cfb49bb3f25c02ad210a3701910413be6c74d4ead3b876910fe7ce0f64dae12c836a43b3ec32dacce290aca48636ec4104da9dfe19f15d0fcc57b327ed9e6863de914ded58a877ea0c9ee69740cece62b21267a646a8d038b7ab684647343ddd4495afef010bf33669c33487ec60105d76efba5205f406247406c34c89711a59a54d6f93333fc06d21e0b352e104c2f6190aca557cdef1a7640cd4362daadc73a6793a7007ffdbfbebc839d29570eb266ffb7107d330617520dc5779160c3294c34d21f39ad12547b8f4e5f2955e16cb7e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
