<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"94e459ce58a146d506f6c2d37ba6271e24e5bfffb7fb58e6265ab6b39de5436e68aebbd026ec53309ea9133342f0ac8935a6406e7e3724c627e544d0d0e97654d40aa9f0e0273829d5ca0aa78be8ba8e29872e4bbe3feb323c313795fe2ba0e86649c0ca47a0921a6a67be448dae38d519c7a018f79268e1335bc09767d43efa4c000c093bfc15803fb862e0b024b9ec16fc909402d647587a608761a80e9c92493ae2e2fd4ef18f7c823a25465fcbb8ab3b62a54aa3981aa670261be262b64df4466d062b5069147220d109cf8a6d5059de337a65a241ddb4155bd06d4e5aa0d442d430d7ac00dff1d625b185530d14420169b0f34d7b5c4aa4b85cadb1102d80bd4d0e8cda808a936e0954cd5b00cfef00acd2bb5a80fe360cb6cad0dac3096ba051a45ef444689c1c6e87609e96d3c5354e58e8bf2ac8b321cede8ddc908ed6b21dbcedbc0c342e29c89ba67e5014125d43f8aa875a84d87308e93c8ffa593d7472eade64fbe8398cafbb213108a9496b6b5c5e407cb3181640d24468cacfb4f03c1d49101e2e8f26dcd35d89de5be34a063c1ee3e695bf939986ebeb6a071422296cdd60d7734b1f448f451a6d560a4dcef1a822285291bc2e02e4e74ad31f6838e8b6c75c399a76c30fbcd4c6b812cc8469d3e974f8e729f789b7b75ebe125f2cd24e8305f570a018e5e7c06183d3b9179640649ba5e1c4adb5088d7c9cf680c48853c1d085a97fc6318dc25c44a86e3fc7575b453be87f26ddf61d88c399c6f915cc14e0cf59a7233536b839780ec4ac09d02d32509acbb96bf5aaedcfd57dadba85f574245c8054c9b1619a6e932d4ebeaca2e52fed6ad289f6c051b6ab128a96bbde6f94205b655efc41f2a9bcd9fbddafd42421d374a235047774b6cd1e6aa08adcb5f2c9e31e4bcd38d2edd9a63ae20d161c8515545287932621722bce99d93283d9c6aae3f9eb2ece622753cd97fbdeaad53e2772c7e000ddc9b3ece446249183d8b1e72f2dde5ad2dbf675cb3d32184e8f71cf863a3dda0af08dc01a6e4bf223eced7d9f3bd11f23a93b24500e6847b323af38cddb7fb1ae380ddf618df32f4a5f0c99a0c3133dd78d4efb37dd7635ecd5d1c62387b94ab66041c42082040853af6c2ea69101de7813e701f1ccdf93b4ef1368f19fe703d8594b72926175766b8cd46521b67567073fa1e647632ac17c28ec3025444a19b037a7be4adc4175bc5767dc5e1f3f85da7c32919249cd5598d70f415cf367f41a8f137732df983a88ad9daba8a3ce91c086e227285596f3a55e194dc08e5c658ebeaec6a0363e88407cd80d9b377e2bb588ec196a14bbf3c6d8059d86ec683a3395567dba5488c9d93679eb8e81cdcbde4433013cb4cc1888a134eede198b0fe454a2be2ae806a183969844f9c8e70ccbcda9aafeb33f432cbba26db5f79252303362808eb04149fa6f1743af55421276d835b0a04aa07c9f74b2960ec11fba85d228a8236c1b10b5bc68caa4eef87ca92c59a8da1eeaaa3eea4739e5ef7f1283baf414843b9f4b396be428e880e350f863f8b5eabddb78f2597c65d594e5c8940b8e1b173b6d64d361ff1184b20ea875d3bd4f66587304a6f9da11c32968c315529a1bf672e6c709c4a6556070f5f03b09084d4295752ad9662a657b1a6bb978b0c24002073d0f6ee9fef21f5c96c62110dc9d92d6ac371184c51585656ebaed36c83d22dc8a1db8f318bfcdedaef1728cbe05acdf740765904927c714f8a38ac1f3eafa1f7af54f2e497d05198c8387a1f2545204a3e8506474d3e84097920742753823028685cc4b07774e43eaea0001a695f57397813e25695cb5520e03475e25f1939e83f56c9974188da689abb40c7db547d5f614bdbef216cb0b3b13429b379cee6c8e472d3b71b28fba7bc6b0e7064b9a1d46f420f3c9069ec958a2c97e0c8ad4a4a0ee8fd6dc701cfdafd943617fd54a059a1928e61650eb0ef5a1e0724573a2a89beec7f2716a8216407a891ad313f7de39ba5549f5e74691a552bc5e9726e6aee69030a1a2cd3fa5d9a7fa3890e6172b1f1b5e5258f2a9691a6f38ad27904670af88ef12b8a3cf11b31f749782e901923618396794e3364f0d26ec236e101620911c6b096f57afbfc45b284324f0d7bbe72639119df21b2afe759f94bad84a32205263786d3eee3d6485c61993e163f93fe37ae67a847dba5261ce752daf3da1b670b89eed622fbd3b3fa6fe97c4d4ec7b145c2b9183d79f1fc284017c385c8c9e4b5e334333de616002f890ff4b5d93ea457e539e5b885ec7b481710e0fa8b4451e611d0111f46053fddf0fa0f541c02cf7286f1afc367bd2c875867f92ba67ea61f2e72ac1e0ac3e3c536f0c284cdc7940b2d9dc91403beeab72337988eabea3a255075d9a9ed48c0e09d537f5abbc3cefe3b1beba845b4dfe0285b404c5032ca7ebd3cc19c8ab4708b43849bfb2e95742b8e981e44f234780ed1aba49332ed2336acd76265f04edaaac62516026e1c9401696fb86868066f97b2fdac8564aa20381ebb2ed5d5badbc8995628e33bee9f84652ec27776015442d5bbb5935afc4f9b1b11ec8f2c77ad70593726630ea780910222bf21a22d949ccd27c093c5aba109745e129136b1967ecc8a1b742a21dbab3a149e294546fca7bd46f1528ebd040cdb84d52931ddd87a41ad5d4958525aaa441e7500f3ec6f91f08c6eda3fa03dd5fcf488144c234f2c861b44d49509a6b41b926ff6ea976ffceeb74df379381adc8c96669bddc4a70eb3ae9174ad2f3355b5495c8bea41d68c3e5a6f9ceb8eaeb5534b23ceef578851afbe0ecc87f7c0063e436e384f5fa6d3d40d0e7f4b34c276905a7a7f94f22e286a495b935ba923ede3f7a778d5c43b17b255047d40434fc29d53934698c3a7630e0c0efc28533e04bc920cfb415c7c02ef957a5e6df5a1135a151d7c18cb7f4c632caad2148ce80000b1f2011cfa7a9aca150e996ab59cc26f1bcb4ba4ef609b1dd9c6e0cd8a1db624e625469cebd4a5fc56728f345745d4709150e06af241a41bc62af43e39906ec4352c9fe359fa3834829a6d5e2d580d3bf126931aa0e0910ed16b9c8c94cd95a058a661d1dc42828fd19a6ce6f62034afcbccc8388411b6c8bd6750257e3fe5193d0891edf945641eb852e5b3ec6d7c7708db8763776d8b0089dabfe506abd22a7397a19323665683fa7483cb2ae10dbb839c9ec63751d219ba19717b6f41af90082448a6e3308236c1a96f320d7d4e3daa5def132ee193a6ad3504df327ed3699501e2384724e42ec6e306c075bd6e83678de0d9fe01bd49a82e44accce19d316ffca0bb280a661238e6498209fef4c82d2df7c39f26b2e289c2a67d03bb207844e5e0c1b6ac36f0cc43eec7db9fab2b17b2c4343da994d44b102fc645c33921727c8937cfb8558006ea71159acb386024ef42e2933f695cdce54bf141322dc2603a82002037e37f279bce2a8f8c7b30cfd759d3a1aa1d428420ab01d2f1a76d28fcfc42e6b52436c23b4bf040e76774613a4e46591debb574ac48d4d3ad981d83ffad98c78dea00b40c39d401ea54bbcefdeab6561bb719c1c9718d54fe49f08ec47f1d9ba6fdcdf7b81533f4bed7b429693ccaa94e23ba4185f6924797a82345594a100bdfb0e5cc0f194ebb2390c3b3e6796e3ae485eaaf345b371f2552172ec9c742650a97b0c1e07589d7f2979025a996fd97b2603e2dea8bbc373ce56ba2d152d76b87d5575cbba7d3a6671defcdca463bf392c8cc34d4db609487456097e2decccccda2bd18b217ef7842e79cda89d5425ab9fa62ae088bb97984705ac0c86a8d1e67c92d8f372441bd7c4f50e44c67a0d6ba2ff203a6f0a99b9bb51e156494beddd9a93c7904e7ec91f1d5e3137c41596494c0e32dbb37ae401a936480ad80ecd0da43f5318abc6f2d0e27292b7125b16f265643a0e3026a114d1f07ee4ee9b90cf4143f32f7ca79005a9a011e74bae7c8c266852a7e280f81e8792b523473b0ce4098d6c127f971139988cb3991734ee5a23eb5da05f0f228dd20d45c173b8f2e28066b6f2d26f7138de3304ed113a8ac576ffc446a147e9110002fef64b08328dd7bd7400b7472c10e6afc09b9192330613b1d0c6b616c30969578ead0cb6b32ed659a56d56ea764126012ec1315dde044c64e95ac0b8e0b8ff22dab58cc515b45845b90f464a8fd12940701bd17ea177a3456db57c1f49aca31577e8e0c5fa2d8ca47c7641d4c0b58e4d2f1f9d3f494c5d580086a8b43e0073f3ba7b2407d551d7a08ee783534e357c881ad7d2e5ec0f6708df37de00922ba102dcdb1fdb02f5036c63f76b9bed2746c130c925e02f7866580df5ca7b588d26d4ebf33e48903a14f1dbed87abf25b88ed2f64dd7029076e2ac36e77c16e78871b6db1a16ae2bfddfe051a35427770369bec3c88b504682b1b5d36c23f403562efacaf1a19a5af5cb6334abe368055a31fb13bf54b77d5f05c105cc1e4d3f97c60a1f32418da1e998755a7c85aeefd613b12d222370685897dc5e681cd01982c118df0e0de4bd6991c225f4c216fe4331373813bd77e689d7f9ecbdbd64b6945e40397aedaafa3d0cef048cef697072d136693caec13024236603c230b2ae70eef341f34dc62954f2fc9588820eb29de35312d9e9bfbd7fb38faf56672c1b74f7f3d4cef6754b0bf535ce35f325bf2765fd9aa171f9c5b9fcfc08c609980b9620cf0ad24934eaebc6c7829f18374d4b955cdccf0c6a49aac23dd4298834322ffe1b94172c00b964a3981bd08014b72198cb1f3459fb967d42a49d123e68c77503b310d8d8aec7608ff5ce9b8f86c001cd500d14ebbc20c0065b574f29cd72d07e0f3065bcc307e650761d46b58fca0616a57ea0e0e5fab03e308195d6bde27aba290929a53851a1b19f907b7a25dbbb80101224f65fc86e2e06ace5cb1a59f2520a5711c27edd2efcf53ee7af6da5e8daa534996b11e900397918980caf520a988ad5bff13eff1c892265679eb910f13c2fa850ab6620b7402c00a3aa4c17edfa2d83bb2c265fc6153225a996a4e18805dd563193abacabb3c1cc620c2a2aef50aa48a266dfa635cab0195ed846433a6f10d1e97859d7fa605ae77b08ff8cb7e43a965b8caa027cc0657887f6ada5aedca16cb13866137502bb5392c7bd92cca7b0d57501b785b988a8323efef06623dbc056859e38031e50e923c09c8e6b641b8bb3c7d065c693ce17794ffc74ba92eefccb8d56866e3f87a30ffab05917dbfe584136192098c51fb9ca887c24aa2affa0e98950a6c16c827a9ed04c20472a3375a177d4b23f67323d461b76f61c0f722500782b1acf3768ee02de4f388b64f8d79122675a758ea8857d20212e181e2be2fdacc3b66effc886d765076887e803c31602d5ef1694f9cc792ca978fd9296d5a24de64ab396d92cc992bcf590aafa7513a55a941128d7effd43cf127bede3191117e52a71652ef33998c7652942fc470d45bd6a6f96c1f667888345707f5d5d1f87721795c1b923dd3632757bed9b5b4e9c46250129ec3a9d3aa2b9e77613d1a1b1d2c93553705203926ccb867abd9bce72d2e230798fc20d0fa188f84b58923b1d23d3bbbd8caf5ddab3f2011095d5033d390c23d795e5fc1c1e0e6ef5fe2ed1813a0bb771165f6ac827d44d590170fbd03ceb0de08ac78a4b682436b5fe374d0c061ebd4d29a4ebedd44835d1b633291cb5afca12013c9847b596138410880f2c4dd630c57d0c5fdb2d3921ea018fcb6b64dd0815599932601a7c67e3fb1da58b930bd6b176b9176934f4bfb114d8f322dc211db833ab0621a2ab406a6650846797085a679a87d7eb65055e8f969ca274a96522061ff2954ed58d8ad09e643d0d054679fd8fdc3f3da9b73014122f3367c704f783895e2a47c7451270ba5ee5f2d9484fe2f49fdb80ab6a8601cc882ecbd35574a62ccfbb29a15a3c63dccf0440fef225045a7cf5c58a8263d92a3ae41b6238b60b7bd4caa2602f1767bd2c8c654c59826e7df94499e2add82a29f10ac620bed6f89c3baf85316dcb277eca1bb21ec26a61497ea0c88cddb93feae3f02628e4c4eb8c0c5d47b5bb4bd57556410de60cc6952b4ffe96d4c5edd75edce5dbb0df17568d81b69fa2db861e783d1f4f103c9117896ef8c81bfdac628a9e6563e666baa3a7d95ac7d98b31e03ab80230b925dcaf1292e99ed37235f08f283717b208480726bf448c6ce716738ec779ba16d36445d563b12b49afd1a7c9b890f360fb5df7bb85ebf2493d2e85d53f947f896dd16fcbaa96993c770be0f2e04e1551312bafd45f0f111dc52c5224d914238649032b05526e38f004c317fb99f9f87b6468eebb3641a006ccb05f4bb018dca78ed0d11346c3e8379b4c2ecf11258df3dde8b9991eef9ec305cc580f3521583164721dedcfb0503e68eaebe1a3990ec95dbbb574f43231ae4c1eca1bf940a5d2a8021ec5759530d7b33b2e5e79f96925c6506888b76c5391e25c5d7ab397d5171378504c27234658149fbafcd1b3205b9d23276e0a3820317e765f6ca2a1a8fd6db187fa17eb3bc5db2cff3ab37c2562e565070fcf99daa636871a4c7dca54e15ecad2aa30269d6e1aa4bc255012b1f8b87cb621d448e7c4939644c648570622c417fefc2f719905c3757368bc9521dfaba3ec71bdc04b44aa50dbb1e92da7f4020bdb465b6c132ac8540352641383799221dfd69f8f7f0c78c6cc1b6476c9c672a7017fe506664cae049f6ed99877da855d8fe54f30a3adb05015a22d9e619cc6463dc0bbc34e4c12d56484011a342bc202c642350bf6397ba8882a274e02d2d6ff74dbe60f77d09c74fa428979d89f2719b7ee637b103929c2372f04aa99910318358652ec308a742c35c0d6e7c26b1666525dae830fdda4b5f35b820f3b79af0499080425219e8366b7fb0e1fc509b6bc7a56f6fd90fe0c307544acd6f5c6c7fa6be5c53dedac058216bd65c6eadc404fd3f038b58d01bd1199fdb95f4de4e89a468da5a767dc133be90890bba0879ba63bf959c5d132a47f390cb4c5f76190c8c8fb93663ae99a9a3f933c4b0e82cfaccc287258f3543d8d29876d0f2cb2b7ae4ae2f973fefefa8665d624252b5cab22c53035f30fa1d57e2cd3bae388195a6dc47f09992775fb8596b8a96d6590c477f2788eded1090942ee6b2260c17625a3ed074ac699ccd53fe88744ee3fa7e9006c31cd87bde61c7187f454df0e829232f67da40a34d7372d10e577f47e8374623be4b53ccf3b7dd7da148254288398424f69429ff4cd3c823c58c0b54001820144acc81e0e91fb784c1d805834de8e556a43ebc20eee9c746cf3805e63a2280eb4df23f573e4aa4495eca3174dd17f77cc40cccbd201ecddb2f4bb77470c931b5db6257b3d4b937162eb97ee0edafcb73d882758c6a68e7d1378e7eb8f9aea7ac0e1acc0d68d88ac7b33e037ae5dde0a4312664d1cdfd19662ea8ce19c4baa23b2f1225e409396ea3e4634598aefdeb2f223725dbc9f9ee0473eb039a9ce8967a0a5b890a7b26c7b52f9bd32031af0dc8c9f16178696c55c0084af03010e5ee13b03496ec23a5dc170e80074dd119c4449e5d2c803038238b04363a288d70c30fa51d3929c452e4362871d24d5b880e11d890a9d14ccdfbe60bd52b44925982afbcc7a4d38b0d4ab0859930fc452e86ec76c2a34c64bfdcb675252ce6fdb6cfda1905f945b25f17e54f24939151e4d97893b3987a392a5ad1b82d810e5429f3475cb7b8659aacbe5bdf220cb782681ebb14e425ad2e9fea7f214fb88abe4eb46e825d921593588e86168ca0a92ef16df28dbe491b690209939bb166682147eff8522ab0940488ef28ac1d1bfeba11ce9defde7cff7ad7d2812f478f92eab7c752bba45cf7be51707808f4a8e237fb0a24a094fd3728e6222edf950194b560abe170ef3badf7d5456067025c3af7aed5fe8780b78fc310770142b121d67c120dd83e7f5c352c09a18a4c6781e24c9eda5fa84a268077bdcdad574b60123fa19dc432d9ba647b32ce3de3c960aa1da61dfd32025ca52d15d6d61f2578175c813ea3ac53a7f844b5c56c2273977c93db46ba82a962332b14cacd5e2a9c2c3084c4428478d71a29c53dc403f22052688d51919e14816613cde0c96e2d8bbbb530e376e6cf3d97ff5ad9db4983b125784b980e7e5b166af4c68f51014f185cd5eb4ce800fad10a7dee2dbf0dbfbcf820d3ff4b2c18b1c95c8bad5e68e1f5f09effa93c6784bd52263e3e732deec6ab5470614df1d56d7973d94437d17c564c56f4909a8d24b557a5ac975293d41f1f7d762a116b104936b9444ef015a28d7d9378d751e2d6ddcc5346a0c295e81f2cd2c373687d4d66d8e1f6f827bba998add068bcceb19446007a46576a9351e9aeafdc95a0f758a95e8167d5e3b4e59d2b4349233003e1a3422ea3acdd7f47e64d0652b1f80961da3dae851066c29b6ec2651aaf2e1b74c8505db2360338987a6b33277bb47c16d04ad1bd491d419cb624380703d70c88126ddc47e49e0838ed7e691db79449f2ac345bdc125f3d6cd4dbd41d4486f6a77303261c10bf7e7b51bc2a2b4cf5418bee011c375413d0021e5197fd5c7bf14e5fb6af63a0d71e8f7caad8af6c3cede0801870e8d2eb129fc62b83c2be8c5e321e747d8ce541e7961d6a3a19f470b6d869c470a6bc483933e095a055f4cbb4ee6323f4e4b7b39e774f3b027544392c5258d7cf4fa7838a4773353ce33a7c5264c50bbe646d3f497ddaa95c3c1983acc235ce7c75d771b2ec27aee10f9d7d98128ef75b245e5cfe66f47c9539fccaf8effae6ac5a1ad1c34832919e15348077734c3313599c8d95f9c36cd01231922c59d842591e4ad4eefff8aa83ebce4725cacb2b4d89d553203588e044c88e69a22eddf798554f522daf026a7627cc9bc4f3e3722e81ae38188fc6b0cf1b2cb8fd52b708d6846d4bc152e72ee9ea4b8d3b945ee84131a964e1182f0934264d8db09d66c8094d1f509ccfc4e376ae310f0c2b491d114a4701839a87cd7808f7884e660aab1c48dcec8430ac394d2851abf88ea26e5149ec58a19810e380fefd1d078d9b1b9ce729efec22d40c75d4d2314dd3469e0e52ac0a5617ebfec9c0893e259b46d08056f7eb703698722c0e62b42f90ce355d25e0b3b43f7c1a0337766fb262e7678d8e011613a32091132a43b7144961cd530cd9d69f2a078bf506c64a2e28f9d33dd486772b22ad6a95bc7f799b66f60237d005e0de4423787c2d6f8e27da279e98776a82f7c07dfbf4b638b4616a3e924ca73a292f4e352a1bc9c34c9e57a743fac5fe73b1db19dd3a6a68cbcf0b6db5fc78235dc41606476cc47b84674e7d8f3c63a3d6a4e73314b3cef60be6c456ded24c8803f82823d5b1d9480a84dd4ed1865c01b7c6c51ce0ab97cbba7531df93d65fd16dd942f6fed76de2afa750935ed750ffbadde76a0490e1e71d1f59019462e7b4eb75c1d4564872820f132225fb01e346de0476b5ada1265106d647576083f8121c059571fcda690621b38a73da45b3729f4e24349b818680eb14f768b10a3785ff5712b8ce5040ef5d966a76242b1b7807bb1f03659d51c0725e37e93b75a1d18b9cdaf977aeed6036b5ff1e335824242d985f2e6b5adbd01ecd6af992bbdf7bf1766334c27169f9e911d1dcf9d3cbbeebf739cc568f436f41540e5bd3e3e43df3414381d194d103f39ff71b8e782659820475f1baf968e63ecbf24e824edeb5ebeddd3fa7607711ccbc72e29901c8a25373070d0019b0ae2727fb245b981a972a6c8071ec631638b70bcff615c956335addcbb91be6f4c78181ccdafdab1921350a756a9667a96d0572ffaafe306c01f58b5b12b7148f04fa0eec8320ca38508102afce32f8486c6a4ce4ab036ea77c34093d77804382e80a0441fa360e1a5d09491625337b63d3a08012371d630f70845a111a7867df19fa158392cb96f63006345333f32cd44cb9f83a62610d3583d20d3fa125144412e32c418d41783568b30dbad1e7ce5ef6628d7dab926cbf69bef386c8f065d36e51b12c6cec6b03bb4d45cefea40299ba19bfb1a375825da122a2d15d645d5982d1c794a7bb6f477cd8761db5daf2a095c04b827932a6d5a9efad65e21a1ceee8530da2669bd5ace3d8d17907115593927aada670b09ba20495d7c96c6925c016b9c6fcd080de5004d1c251a99789e0741a4d125c3fbcf4a3d8c78bbf5612c03961f740460cf111f6e3a3a573fbabd73363c35881f14875f3c8e62b219d6f793cc77d4198750d09fc9513a9d0012cc4c096a0513fc27dd9aa60716a8c62d4e4ff17953fd5dc41af577a42ace11a7a6358cc62af6082d1c3526be1fab05e1ca224c312acd7fd57b5e755443810b685560970126712e8ec18b1261a6aa63231614ea47cf762ef108d50779a4ab0e5d2051aa64aa994eb9f2c2b45982f4df0d5bbda368c3856ee9a1d60d5ab0e03c1b4822e6547355925c4b1df688044ea2d5c796e29fa92093a4cb5aa00b67429ade73cdea19f87e1a8fd7e02ca97c2d45bdb36b4b6455bd6b2aa8cdf3515df60b4d4d60cde9c13ee2d072f782618c7905f99e1cae153f245509a00df87a5f573d448363c2d54e0f9bb852a3f6b33930b0b05a606a74bcdc5ddd12320fc3b24e0b3bc3d22dff2f76b05342ba7e9872d44d343c7b369ee5e5dec2bd41178ad782c0bf6f9a218e2d58f6b879ea5d225abc321b0aa423f18b66b9a5cc650f7203e7ea80afe20e5f461efb4984b3c59e268d1c6ea8d6a7d21c919e83a8193b2f486cc26c7fa4583e24240b0710c3a7be16f886d8a864b8f3b57163807000afc4f0445bb280a62f1ec426e2698a1e56b0eb877cc8596b8c19733b5c0a75c9be7538806ed5cac592a8ed0eab96d1ddcf4dc216986675805e9d1b47c0dd2ee24440c6826fe89693462ee6ba09a950171ff1619aff46c269d807d1de4b4598f1d47f6cc731fa17f5b7cf0139fac1570e386e29e7634f9ff6256acf306fca5781376b95968c99831c5afacfd3b2331e3e9dbe220c26c71a995985b57854c551f4b2f43c6f550c7aa98cad75f9a9ae2923859c977473a1eaa070f5ca925a70868c5befbbc39d01515f319b9a18cb4ee0531c2157599523ae539d79b9bff4167f1692d2839bcfe27e8f213f9669a4853a96f3d627693b6d4ea84a33aec5d3e395cf0bed44b72060c262f5602d97eba6cc0bfc5c71964e9d6dc9b86c14f69056c6ab40d9b4c79bb9277b968b066c6a7fb8a67862cc84876a6dec08ea05102c33dc956a683442873cbd6909dc6e8e9c69f1b9446641d966da4a0adab5b97df546246a6efb268551fbbcb733531d6b902baf2a2e4f5a7df6984ccc18768ca7f7567e2fcca075ba214cbe73d9ed940815a68c87a06b2063e93f737baeca182832ec6c26bb2a7109ef3a551f16e757f4c83f1db4850dc228ded04ffcc8c5754f75cd03472c852cb941e5694c5d17ed756225ddb51f6894fcbe5f970bdf4fc3b16bb0dec5b7bb7b5a0a6b67d9a69ae12c6a082a1487e238612d5032ed94d029b3db3cdde5811c6f926747f9d234a1561900e0efdc7d45e4d08bd318e1a28355849ae7bef795de8e7d86297f8d7164b0a06ad7838898ba9d4284616f0b7045288c3943ab8b2cc7eccb75d5c22040269cd4fd622ed20722b7bc6f0de29b1d1f4fb1835d107cf1734c8d32211a71bf69001537031919d701669e22361c2563b24afba8a552cd19e7c1000a4d2ca7908c79793dda6c724a964eef87f86a3fb5dad9b970b16aca62b3c145f9cb4d1c99f7c58867bc091a6ff0dbf3b0555587a16da9b63bf706ae06767bc19bf8601591eccf462ba267c11f602fb731ea102a9e76401605080cde78b8c2804d6c89663b18d86413eaefb76988efbe0e241fe95e718f2294a2848f052b83b37e0331aee6dcaa5ebc35aa668e198e3d154544bf235722976773a63029996979752ba4ed2915d6d0979e7dfe5b60c492fe28f722b654852d56c8fe253d11806841fdbc2b40363b81c84461607a9fb1cf5953bebc5d422edb8a45ac1666bffb0a8b9d8aab259ba1a67232aa1fd0201c8e6f03877d7e6b9f239a8018733b0137a1c17dc6ee1f5a5d1071cd0b52ea59d21c403dba27aa83710a31dc6b33f5b71bb4c8d3b9955e026539d5bcb2c93ac80544f57c61139c192af8de826dfc09bb703734699022031468e04db3259cb02fe2d96547ce059d87a92e43019979d6d6c51d2cf53930799ec4cae4011bfa1c78ef6dda9aa60c877d8e020f4813cb951217ffdb2cf2794f03e57d8adc97414b6df7e8f19f48b64dacc9acc3dae361a139bdfe3e31aa127f335433f502e5c6d072b1eefcb0b45154159b54b0720fc9750c2e582575b3c7e0a139d9ec0ef8a0d13d2ff98df953f9860e59a4f7981bde24292d7b9987fea27d812717e1e7e85346eccd4c4e09d7ebc2ee9941febd8e3bf6fecc045c4954c869efcfe9d6a12d26fe0db339e7fd5a700120dc7c25bd8f5d9215806e7f794e21ab0c09c8709ff31bf06a7b8895534d6ad72ea5ffbbd7d625a70ccc67213c8f8d382ee6796735cdef012d75557d5e76ea72fe250d26a382f8267b6eb58326d3145ce5045601775be0b5293641a201d387bad989c7bd466e4cdcfcbd3046c3db99ed79637cdc8c518b232159f26ddd7460e8a3128a30d255efa27a5adde845b37efc3baf554087a0ec00da2d20aa0cf03bf36721f1b7c1ea969ce01c0d996f336b8aca87598b2e3644d48bf8e39fce3b46e933f8c70c5ef1866769bc518c11d28537532f926da7df0b15240038d7c6a15d276b53ffae9932b0a82005ff6c69823cf63d343b1d870fe437da1926c88681356a055923871e0a47fa2e56aa6a757b50b8b3a54de127182d617ca1125ea9583679e7aab3e3bb174ac3e679fafbf3487cb1e0b838fdd6fb7831707073c7b60a75fc1f7d757a8ace630d13ca02fed3192d5711ac48e45e9b5725d5cd33680b48fd2597fb941eedcefe133d6f812a4184efe984e24d02a3cd889220f6b8a0adc75025d02ed5d26c0d5673c9ede286fca987ed040ad8dc80ea4f237dba3c51953f6091c3d4d1116d00a0e7e78fc293728ab67c1e3ffc954f604aebd27c99e7bbbd8e45a10c81a6ef97cbfc01db73a48ad3f53dd1e610c007fe1ed813196fc347d55bc0dcd8c690a634e5f8caf8d0dcad8da49435130205e6d72e0a7d5d0fd109bb17bdbf5fbc8f8fb0efc21103fbcd915f0edea25e42825aac84ef90006c36f3f1af85c9fcd3c2b6963a1de5bcb0e5aa86a9794fcaefa96de697e1f7c146c4182a600796f2305caa20219f4d0f011f179de3d21280547a64f55cf5448cdac87b9b12d7862d80bbae08b1b53c58aeb66889f8079fae2bd5f7cd07c0f7a3bfa20f1e2048058e55bd0c3185fe916a6bf934df24f09e02fe522f2dd306e07a9bbde69f829dc10abe6e26ee43a832158a579ae7c54454e26e4ddbb9096b55cb07ef7efdbbe8da65e6a70a695b5793ce74211876a97314f88ba3208dccdf3e8a282840f42cbf77a4d4af4cb96f5c70a7966fcd0923b4fa243602c110cd587492b743def9ed5165776c986c1b792146c222a0bcbee2b4a0fc7a57902339bbe1dac23d9e1e4d0356ed2cc7f15ac3c124fbce9e2c7e7e13ee77e5f47067056e32aff92f06ee0aac00b5a94d5941aa17bc00b7de5a73256aaaf22a2eaa551e88f3a5a2deba0ef7f7e1ef22cec3368b1969e1b03c3b9e2242436bc663b702106a4a5ee2cd8afc0fcc602792c414b40ba5b8bcf51855b141172aef7f9574aa34c00e2126bebaab1b17e5527f5fc9389ed76e6e11ce6be29b1bf78817eafae41db03aee6a1cfb9bb433f0e5f1375d01b28e2a2940198095b4c3c1b3cd40183a39160fcca0d52f2acd3da099bdee307af302a22f337283ae74cd43463ac13eda9cc1b939b298b690a1bced586ef47641b0ce29ad2c42767a634dacba7e0c03664cc8d7459cd7f538f438d8123c227f754946343d16265abd4ae349c7a8aea45da1b8e79dc7db794e0a47c011336495582b51654d15ef3279b77980642d9f76f7d47b883f11e40df2aadbc6610fa71d5ae7120cdaf2e94958d5a71076bc8dcb3d90bd3de5735cd42686d88c7133ce9a54b15b23420f3d5db4883e77d69353d512b152a20b4c50d5db1ee917b39f18082b6220e7bfdb44db3dbd3a964c7c7415717d4c42aa7045ed3d0cb93ca4fd6a866ca708160fc3c176c251bc4eb96e9cd73b86bf2567c5fae60263296d1b269e3a36fbac06baabebdf47fb53e22333e10862daccc82f63525d34571e4a2dc131d3a02cf16359ec7075daba2a19de70f4da95988141fd888362b1fe382d0da3aefeb56a2b38066c1b89dde9e6828a75bfd5c0cf2b4cc7fe906f6991edc8121229eeaa331be4a4264582eb5387ddb47e2e69d42a457cb309a7ee3f6e78682e8953f34c3297f4da7c8d436ef8ef4c8d3152a8740569324b9e6553f638d6052ad246008e27234d80e862defea39aa550868a3bb27e402071f17245c08db57f53abb4d2c3cf928437368c29c94bd606fb15954ea8673a3bc36fb878d89b81f48bdf9a803b22f52c7c37962356b2598115d0191e33184e3fedcd7160aa3b1de2cc145f2ca692c3ef8f387db08f0299d29629fdf0dbaef3b4243129ff166d52bb621e89edac91a9c770d96eaaf549e9c70803f802aab0a3e71cfaca7c3d335e18d8f7a34568b37f642abd82a4636dbd9220cd590059e7997bbca0b7fb7517e6def544472dd8c8e3e9870bd6e868d8cfdb047702a4be3b2c25197dcb47d543f6009066172d7e8d011308e8b2913d4eb9e41ce3d58bae4d04fec0cae10533eb60f6581bd8b1414d09273330b9eb987f762c70c9ecfc4b6cc9a9369efe859b87f46c0d448a0c7e64a2b799660feeb43874840210ed03cd33e2b72a125bac2a13ecb925ea72b4ffcc6d87bcff507f3702179d07daf4170542ef502a2ab68e668207368a4a5d3081dc8b396add4f7d7fe6012167c7729276834c5e27436f334d329a4f24217e4bb62edff600ea1b41171168652b55a66722c72adcd75203715afc8ec7653c65d739e62742562e8ddc405084424517300cb2fb1a87a69e1bbaef6ea5dedae3c83bdb1af8cf9e1f17f9aafb31c689d5273a75706ba402cb4143ff17768be56de5fef6a37be7d5ce5e9c0415446dc24f3dbb631293d1080ea920b96d542bc7bbd573e1b86a2eb2935c58a48a19b8bd852e89defcf14fc2fee74f8be5b6aa0d7f8a17624546bb796949da63f5cca8dcb5d0e3443496ad919e5aff7ee48c16e7c25e22800bee5f2916c4bfee0d8d220ce7239e78e67296fbf06254fac7e32de8b520e107bdfe62e168d610b20adadd27b5283fc870b3263e9d955b3190d64804282730e6b3d83d49185aca854ef705fe3e387d2b4ebdffac33e7476d41d09b61e649887107c72b50e48cad3d37f27af78cb2dc635e188093af9a12ccbde33e1e9f49330a341421f2e98a9a8acdbf66513298a16466751291b7103984d9b7b4a6d6d47bd9a98228fe34ab98ed3ddc1c959223f7bd32576dc59fc5657654c4b8196458f12ebbde7a0aa7c144e588ce9e78f7a5033dc697d5a33687d27a6b2c132ddb19321e8cf48b113e041c78fda84cab5881d1e3bead6c185a5d8f8caf84aa0c23b6a2682ee50ef60a9aa9c7ce98ab6529dabce654b12dd5d53a73068a5ef7599bc56aa03399406db2af8c090cced7dce63a553ed6b21c344bb4343968844019c8af125b8c0eee21f554f6cc0af6ebd1f40b4c55d35180da063a7f1f28d19b5e138f4d3d25f5ec07760da4f2fe6ae814377dda9616e9f0ba8328ea11b88247ea2613ae1255144e613ccfc5cb1e620ca02a213e23234eaad4f875f611037e333643bee80bd7656b68a3a5342567176977bdd3668cef9567cef7e4401fc6e80d79b210196bbf1449c21b244973b41431de42d18f635402f7065b4af65bc253fcd8b851bea8fd4172ce4eb859625e29b5709e64ad67dbd37e24c2de6fabc9abca02bfa032475ee3c394b44b3d6aba0d70fb93b40b6275b1cb36599afea362504ec257fd43979e9d7e91e2d7ba01ea2379bb2ed287a69f66afcf697f1188cf30380624096882db741222ac086a6fc2a3a9ea9a3bbf16d2a1bc5cce075b6624eae84a0d439334ebafc8e30318f13089db04774739c9b411e57053be70b1b425008aa1151cfc88b10fcf0598835c62bc3277b7a6529cd0a95bcab21db60989b368686efe30251d4cf846d9f49f404292a4c8bb2a763a6a5fe65331d77ec3e48be72e39826cc5578373241cee85d0f1511df25f18752c86819fe9c48853063a75d8ef3623fc3665a9a9ffea3521e71aad6887aff226a5755c31483fbcaee9c8486d408e559ade21610340c49b931f5acb5edb7ad0bfea0ee2d0bdd1bc867d6705c23e4e517837f9d9bff3e346c752d2c864a937dced65c393ada3cfa8d43a83422a0888956d5001b599ab5dc36d7842fb34f09e32aad684a5a83df5e3aa423d0d517af215fd3e1d3388c00f211d6f07332bf625cc628fd08a66bb2d253009bbc35646b6a0519513a640fb421267b72e06a5f5184a7d339204ce8f553d39991dda894647734cec42f45104c4f45b37e9369fb33541ce2e80f2ee454a1cd1fe87e993871c6a362861100efdf00f064a28c5ea06c78dfd9906e8ef99bc2808ff3a6f676617c2e6881b0e236b044310a284660f7a5ef70b00e621f590b7a90ae0ffee7f680da31eded8574bdb6e58aa6359d1bf5377538b9071f6b1c3cb67e0fb308a926febb83667f365d6ea66c44919f4ec9be3ed08d1027f55d66e906ffcfbef59a2dca0b45e12371c39b3db4357a9b6db0779a2b281922139f7dd808be8ee6f371d1343d0dc3959496792edc72a8cd65fb4731986bbe0f74e70193780560301674f469096711f12faa8eedb983dfb3b5f9dd5c0800a16a10aefbcd481bfcc81ada73aed199ae508ea9e0d8ffac4229920edb4707873ab72336d3aed095ab83b744857420a6a97d3781300031bb26a1bacd4d13a30214f773dd0f8cff13552c412215a715f8491f4df57098a7eb3b91b34fd52249d923e4ea9f145b450726572fa13d7e5c66b721a9d8482969200475f36845be0f72ba7239fb63a3135f7cc833c3e15e0d101b8c396f77df2e71105ce8771f366fb68852cf5bf385b80034e64b331dbe7d88e84350b687fea191ca4f64fb1bf2fe1110737270771217cf1736c7db7fb3aedd91e4dedffa02cd70d55b49aefe23e6094bffc3c75cc7f296914440e36ac1618a6b9f61c0c1a4bcc9e654039af3f32034f6f5fee1c17b33cdb79443395d19cd3fcd49871c2d91d0f00622a5e289800c7c4b7fc7e22e03871c0f4c164141425baf70fa93bf9deb56c95c00073a95d34d335367288d264c319b6f173fc8a9aa57ea7f84f2c8fcf455ce35d2428bcf8d73dcd649d6defb9bb509753ff5df49e176d82b564ee37ed2e51233f2bf0d6e6ccce312b3b8d2765e6827745f78eee3e6a6880ff62f4e7e2079fb931a55fc3c48dd225072a9258592c6dba7d1cd15a7d70de2375ad954a35a969d8f0107573f0e636591067bb376f8a1247fe8782b75527988aff0c9b4dadbf199c12e62e244316e9bf42644a77ad68afe8d6c1f1a314d1ab38033ab5186da6d02babb64500ef7be9aca8ad9ced9e4e73c5cff0d4734a33278b33f27a785974778d7aba82bb81f763e5c10925c93239768d88d9d4808caa0e9ee29c827ab07e7689a3cf8b56c0fdfd45e5594d5b3eef9a3132ebc5aa4e354cc0a055d27c1bbb9e1d4f1e5bd708049383fbdd9b60deb66df4d17c0f92811260be4f9d4634f78ab128792c11968e2069376a709c52e8de2674ceeae4b901a14cc0582ed7aa915f9ee83afe9c6e765c8540f57896d772fe7da865bf9b7396fe8fd609400ae0503811efc39c0746ae7c8e8fa1e15a40e23dd942f739d8c89a16b6e8f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
