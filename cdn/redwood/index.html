<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"264817a6049d3c0531511f60211b7fc9f2225195dee4399ed132a2c9f85873162da61ca6c67cbd7ab6a0d1cdb7a5dc0992fa77c5456080ad3dc6750cf1558fde6028cda60d78777d01de195b180d0ac050bc6034770c4829002c7264a9f38f025140415eb6744cba792e8f779025aa5560cae2c1e81f09402ae2df98971888c5660bb0fd68dcb28b9cf77ce1e9adb0aeba8528dd42335b158b2e4504a619c3efbda310026c0544acdd50a5c2418c91f3055f28f0911b3a57a38d20532c7cea427e79037068040c8ccacdc5c75b43d90dcf79d3763843e06341501e930db90c051ebb6260ccd642708a4cd8ede579fab601f7436d42fcadfa2e9537e23fe5d3caaa95ea51eda45f567720f77c950a79b4d89d97b2843602db47621372f54dfd26309131db31bdda8609e095d95c489f3a3bcb796d6fb43ba69c9b57eb4aa60e5e1b4efc31b6c060e995a0286f0ac873db0c0f8e2d5693bcb06b72539136bd2276e57e154cc18a61626a07934035f98aa09edb35acb2730d907be3e7fa8af887f752e8e0f204425d166aa64fdfdc2c1a6e1701488e14e1b1732bf61b78ae1edfb95f837aed8018b5e0ea7d1124a3140fbd3ef5ed125729e3e02b95c3602197ea27e25ab10b44611687b678bb4462948c8de697795372787f3e656e9164a9dd8ae211d2ba04bf50d018fdf99dfd9ebdabf8dda5fe008f13d20655096bab9f11328e78dbc75fc45a4bc7cb52f9bc28f04b3549ff687d9068ee83ca522f8e75e5cb748b61f06bca05a44b36050caf5618f3b27166d84e1e681a37cc353f7ac1aad12613d7ad49251fc44e8e71db059aaee98a7c077ed2b769ae2110f921ebbaf7d2d5bf05a8e29a2765653b984206a5f990c5a8614e6dd9d7edf2af1edd27495a5fa186b58a5bf6c91b2ecd99cfc9058a3c39dbada290b5512f6d1a10e74be4e45e90181df5afbf914ce8f3e0536e881854e97ed95d8cb95c71e77a152cc4b849c1a26cb81811fc145e83aad417bdef6b663bdc3ed8e0253ee9232e3e0dcf50a64b811c275b20cf80b4d06bf682d3439dc4355b2cc08501915191d6cf63dc80bd02711b15f957e307af52ca9855f1d28a2bacb0fb2318ae3375a84c334aaed6cb4e24c154b9a7fc6e7321a3f7df76c90e9f788191164a321374d4fb67e1149b6bfed89f90ec8628113bf1a8658bab52a7c48f643427e9715c30f9344e770b2f93f5a36257bb74df5ab0110eb25f2863db603cc162e4b2284066b55efdbdb5ab6dce109b2ad5d8e4076b01ed3a3336211d4c42dec14ada8927448346d31e4cb9d713047237529b120b206c7be0356afa23d10ac1c541042f0c8e62095d8d4626e3553441073aeaab32fc78a04958b67c7f0f06975ed753277eab6b68fe7afcf3a524e0f29aa1012e49f6f0a65937599de238485689bd424e7b5332f9714be6c0599724d3b72932b066d341c900282b47f3c8e2a6017faf2660afe02b4c2ab8e69dfa81c5eedceffd54895323e85221b2577372af9b5f475ca877bad53c264a6cc237de77e61f3f8677fca018f9c6f0806ba649d576eb73a351e576ce6b4899dd831b1e378f02a58b4dc2cbaebaffbfcfc2926d6539ab39483fb4991e3d2bd3472aea5a387fc9b34aca2ead5c2f9a4e0360e286d101f63f71a0eff3cdf8951a3d701afe90d3b367d4df9442694825b20d5dcb954fccc72fd3089aaf92b40a95a6f2586e8ea1d14ce3b930cdf579349d5105d1e48290b57b0a0c265c4058741145cca95425ea295d8b32cab1436e262759bfd6a1631e2dea552fc45e18b610b4475d0e96f20d6acafa4756ade7a2592b7cfc62eb4d673cbe1f73871e47efabd44a0dd96549fb75bb33df6cba858b83ccf5caa395172b1e99649cd78976ae5af4f6e51e6720b7ecf4f4f4b33baeef453aebbb6e36533e95c51bf67601d01eb9402d584cf8d5adab0186abd802a5a2ec62ff8ecc434dddac644d745b33839ebf3246f22452a305b57524a65271312fdf26cf8b89bed8364f0fbba6649ee77999f62d438b5010a49b478aeb5a6f9976b7117fe1b275a070883880b1d50787eb5833e9f936bc92cf39331a707ba5ff204b1510ca39a91d834f4a7c0befaf949eac3f66615260d05b55547bad6961671b3ec55c6b5b6863b93659bf115ec06801d69df4d9c631fd9a52eea79d278287e6b77893d303f721beb4e7e5093a3c6537914a30257485e10d1f98ae5780faf0bc88b031c9bd53874d42702e7b663d0241282a2d3b0d82597b7967de5c60e61a8419a26a2907493c69a5277da3d0fe9d7380b2781c7dc53e103ec8dcb88f5078735985435429479a92aef9df3a052dbaf562a38d5627c1d6f6e1c104c8d38fadbc8f60f1a14ce1552296c25133880697c2a16303aff0b266a5f0ba1cc4f2b68d154d174a319280c1c81411e6f7e30173c340b71872a5d963e42be29886db5457fb41d38f59f6c38554be59b2b681debb0669c78ab3af3e5fc54df48a45291291cd6fe27e677679e8a397e454b02ca8e94214691aa106eba9d7d3dd37c3bf9091534f2ff780fe62778d95aabac8b66b1308810b0c4f54b4564b7b2d5ce11d44e9fba7b25c6b145d818377e6548a47d130f2adc977b8c91ae488df4807dcc22f0e65f1eac7721f6e6600b71bc11c0c16828daadfa4d96d9c04cfcb982e86fa07724e9f792559c40755cfc785546015009042000160a27937c7e718af284324cb9929d34559c479a6058d9be9eb71fa51ba83c4e838d879c166c1345bce9e39aaa8a2713f883f85ea1c9ce18ed6ef7d33b9941d6ff702712e2f770151b7549441f8cf9e5d02969a252f42e1b3b3018be24c5bd402b666c89b5e3878efe950c17920a29c048250ac9253a0aabb6108fdcade1759ebb42f721a57e39004629328960dfc50b679db1ea9f6c58b9d9f885729cc89b1607106e2b1554b137794fb1674d76b0dffdaee6af2aaae1b48145fa84036cfc00c1cb932014faa03bfe0181f8cbdd9cca186529f3c203039457c640228f913a4e83f84b87514ac69609d34616104fc891f5d51a6922e849019772bf506081c0c0c484cae63e62af0f65d9f172d640bf0e6a8e5176d231984164a0976a667725c96c61efbb2071e1e04c057992912923a15a85e24deeea77a9df831c59d1026dc968f749976e118dacfcf9ec34c7a21b916f515512473a5aee762400e25d54a1ac8a26fea9fbfcec1499357c7931b6f987b9e63e30d2f98269fb5dd3d3bae5526f347f33ea88293df88b5822cdbdd766cb9a3db0b98fb51247e43c2dff64c59ed13ed08097e63d338a9ba55b6eca6e79ff880fbabf13d073fa02bcea9422ea34addc5a9586f0091a74bfa0e39d065c741ac99c50d42a0ac1b5ec19f3fe6573b47ebac51607c3d4620781dce1f8b922e693439dbe83d514d61e60d1fa1abebf1600deae7f843be2724b1034c3db1f484eae1c474544195ce6e5447567573b7d73e44dfe1ff34be5d5531abf81c7f03bea741271b4d300b94409e2ec861d56c4bfbab411aa6b9774b64eaf06241966e1411d16465588b73e6e4ca02a9ad63ed694ea193dd8a16a6e57b4ce2974e90206aa744ca2e7b01775724077e62d48bc9b497719cb39997d2df33e5eeace80f414d318d9cf5f5f2d62ab6ac541af8e490bcb985457b2ef23a19eb3cfc37bb1a54f2c411a8f671a879149a69dac6f36da2e2106ccb28f5654b3e7c9b4facd2d2390b6293ff11b2df3309d41bc52e5da93e348093dab0711399c13aa7e7df4e7e9c2fa5586c5c638f3897694bc735e7cfda184d4864a16753f1e41593d4a036a35ed0c7925c36bb57b0a3051b4c4611129593d96e21f5f1c9aaa5000aac766daf93bd24eb3b519bd743d1ff9481e2ebb3bed07023931cbd9ff231e55d38279e3e0c4f667231f76f13ca4000673a5bedd76281d365d29df403da4619765a0f8381f6d3963fb704881bf868e70a27b309867ae9308625767639c026f8dabf06323e56d457d2f192af00e4dbe8fc31ed6ee6c992a84882fa9c97ec5888a7ca98bc6e0796d2defbd1390e2deb020f8ae24cc9456bc691f37dad4877f7598f842f2009729f417f4aea42894ce9ac0e543639e7e8e32336703deeac3d3a28d28cdeb3f1b0fa6f483be5a5d786f3273441fea7f01e119712bc7811f3fae2f67646d7ed50fcff80f013ec29a187ecd7886a7a90b6ed2912b16197d762719a23d83b2054c18c774fe7c6c3d2341213d1fbbe0e611e3f7ebab267b69c1893137eea6a8ed46c70aee8506ae8a8ced578f49e152cdd62fdbb651db040994e5fd2dfd3cbcd123d63190b6ea4e73cdb40a7254e5f128f2be41776774b2fa3ff2e0dc2b73e0d712f0cb8c19bb076da571d550afdfc2a8542d576f63a64a6947d4571f2d64ea90b292000da013f426f7a1a2de5ce782d8c7d2d92f04ba2c23a31af0ef1ad247a600eb25c4c7eaa1983e9e3497dc46385ece920c1c6004868bb46b94b09dbb162d3b0bca3ee5da2ce99f25608cbb644cbcf95ea2d5051991e12f4180b352d0662b68e903d4739746c93b17c1d69b84ab2b2c83e493432e8515b3186be41f203e2e9a237a885597f21f2761a3af243ffb0c9fac8ad738d224f53c9e15e5f6beb58a4ab338a0eabbb8110330876b990f8a89f6559fe0a01e405ddc5794d08dbe30be1a78fb953a13c6e63cadd60cc1167e24e0cdadcd507779c06391348f3e0b716f11bb697a72ef7bd98563f4dd41922450a2f58c3a4ba200d9ede26b14e9b72aa0bae4f200117e1b346bd67accef675ba02ee6ecf47d2500594b560ad59b0237089609e1a7f6975cfd09d9ee397ae82c3c8a4c4a9d32c8d39521ba4577e509b81c8cf50dc30d0c4a1a7e1da7ea481c3c200e731ae7a243b3c787d5a2e498fe8c0fe7a2b4e0bf65d17ee77c30e0822c0842938d73a71577308dfcb3a27001d24f8eab03cda1ca3319a82f90a2abac0a84e22b602089d60354cf8c5e8b18705c0cec01a01cea798f9f83f40d4a7272d49c873865c9652495a336023d34188982ed39c0142c0234f5bacb747e016d0c0c82a7321e2b07bd950818cfe1cbe262a0fc7450deab4a03f4116c2cd2d9bae2a9cd73769f835f5214b028e025d41ffeecefe8bcaf186024a68a8d1039064b554b15b0968e9fb649f80b60eb88592cdd2db46d902e2d0ec1e2ea5a6197f65ff231cfac766699215b1aae9f5fda565bc1300064150f8ef39489658a45aefec100de18722ea71aac51c90ce2c3a07cfc08d80063112feddcd879d017fa2a7a3268d6acdf1e3a75af4851eb623942205a89a14f2fa222ba9db1014792e4f414e4ea6f410a1177238ca1f66adfc717e322699b9f818d167471e4bf514529594b030d983ae0e02e903fc9fd36f264df171de12d93aa34b1b51e98d1f2afebd361a1c58205633c2246c03bc66964f8a6e80708618006e1eb71d7f2462c8983867f43b40192c12ad0a8be0077baba0001d939aaf87c58165d3531c5894d0764d59b89bc594117f95210e0d320327ebfb17199fb4d8704780ae9d2a4ad0c1e6b0d18ca59c820dab098b891509efc58f530d9cfe209791268adb40faf0c3c80f9b64e42a05524309e7011204864b644cc5bd4f675c6c21b7e6946bbee76dd177ed78802841fe085a88b86516fc22365a4f84bb40d87bed6dd72b34bb4c4091b0c0b3083f62614219585069f66d95f65ad40025ba1e6de5307d26217e8a93792172b5c2442ee65321ed38823617d988a571348ab3224c68fe5973b5c12d616dc190e56f0c80fcccd94d96628db674d953f669a23e24818a579cda1d7b51515dc2ce89d6fb7b21e645b2c3a2edc8dec7d42ad470d2915d2bb71f2cdfc1dc1a6f17f74eaab441fe22a70b7da098348f854264c710073acf38f459a1d5b9bd464f21edbed54692a8328a743f918c03c6c077ad4b3fe9796d6c29effed5671ec85d59a98f305d9ad649640d2221e54e06bbe2b70f7b06e5fabdfc1f68eb5e29517987f09d58f8d79084b4db321d58fb774a07bbc135033a9abb7acd96ac2cbcde97b8a2b7ea526cd270fada45fab6debd0601c2fb85a8bc7c1ab2cebacbac01fa398796d55446a12668b97c294ffa9ca6af320f8eab36bbb4a55ee104969383e41dfda1e74d57771c5e028f61e335ebd8daa2e2919e1cc1a996603260392e37d6249a0325b21562ccbf9531fea047bb48163b6d5b6b7889967d09c26259af795d2ae635eaabbc69e1b3d2cad6f08ce85ebc4ae1ff8c4d2403f5a3f627319bc599b859231cff8249a1a198f9e6f9ea6b417c39c9e47e09c1a4c7007618ec2cd88108ccaa098c689dce77120ea072b79663d96a58c213d99290dd2541e497d9499f8746e2f25da0d1bf8932e4b4c20c2061f4587d4c49391a737cb44991149aaa1cd0f2c4a2eecd52d61271e6391cad8923ed1730fc2022e56bf30dec74230ee26a99d50e083fac2925ad0f7fac152ebdca3755ff46a67d17fa278c5b55f46bb6bae05bd4526034dd8327d44206bd3e1f5c0038ba4d987de8d03bf4339d49b1da17f92f51f485a1e157464d27dba99e330ec485bbd0a7b041739cc8b84087781df7951754b0cd309925f413d00be8a0c3e1dfb4c8a1355181c214c720c7f27052f75c2dc50a7b3acf5882ba0663fb06e0bbe2b0e6a60e0946ef2ab6b495b55fb191fb6c6d7ace51e89b2f2357ec6f7f156870625de3a373f76fd34d50a97433dbef7303dba9c7f42ccf6b4054402dc10f0e5769f07168f25001066820df0bee74b73b1cf58e2eea44118dbd3b9efff050f74f0f8125cdb417b44f1bfb92ae524659cadecb62b038d21a8c371d6d733fc9df16c88dda3728d719a0f64b0d5f61b65fc342709e98c8905ef0d9d8e2bce5ce87fe3d3748e2cc5de064a628e0e97e3ae066ac53fc10b3ca15801047c6bfb156550a1026323cbc9bc9bf12b28f2fb80e5aa4d585b6b0f66d1c1e6a54839edcecdca2113949d8d538af1ee3916973e4e7029ef5dacf4071ab9612d46d8a039ea9a5a39d943e2f4d529c5d9f26a6be8dd3568d9582b3bb8a718f239da869dfcead1313ea92ad6bd28a6b1b2be333e2fb115d4823753b3a4c177cd18cca87f9ada447c0afba66a2a9a8ac612d1d0a783c11aa0ddf5ac7dcdb368ab454b83dcd6d5b3ea6cb7fef4fddd6e9b109e5218f57d37b38dc8c4d89ae92bfb26a0f2b161da886c927f93deb960198e579d9a74f1999f9f3351175bee274c72eb416d71011d7125258906ddedf0d5b45e68d38ebbc72a9c82b47ae8b509e7a5f36b52f83108b2f752ba6222e5bd007c40fda7e9937faea50d69b2f736d358f906c0b59c73db94c3ec5a0df6c1b0b95fa39a72c8af5d1c4d345cf3c9253efd22d907bba1101345e1902d0d67e75e4ec35dd598aeefebc517d150ce3b656c5ff27fa93ab3789cc5667fd4ba4555a121478292fe0fbd1933f1f603b7a983f9e0ec86c6244edc6f1fae74b51c0d28c2a24c8ea05583954ed17b27d797638089afceaa1f14adf4c5ee41a668bfa232b2d99f14ce39ec3eeac6dd0197f0e21cf7b01997c3a6ff4f2239eaebdbd2ff781e57a6dde88c594dafacd94aadb8c2ea07ae8448f1162b3faa28ba81939b1a3e8d43372fd3e61c464235de7a283ca619d9021d521d44aefb83745bfbbc8e9969dff6324c763a9ca6afaeb4ad5f08c6b812b1fccf3d0382ac318f54f48f3b2a66851cea0fefd2b88310d4c5a2657a9070230f7d699f462c20e5df0ccfc180437b7aaca07d79336b06ea59b72a31ff3e5bce76a341266732a292bb183a5b95202408665b28757a7d268d54d7a129b153e8fc33565afb66ee22ce03c7df2b302cf162d4f989231a646736e79ce3c1cefcb6573709715e70d0cfde0f5a9f4dd1bc48581feb832e27a54e19941effefae17ea95690c1e11d982768d2ec3cfec32b8a07421f2d7d20960bb6dc2646597fa6f55d5f827283c975295108da693f5712556ce8877e419bcc4492151862ab4089c7dac2c506966de48998f05de3751a45c8e0783d5f6f7de73fdb0253aa63760d6bff1edb6598827eb45c88a2c198eba8622019c66d9b2cbe7d28cd5bd0368de2875652786407ef1a6884afa34565d90a1c96c50f2e8ef047ae4d2c55ed06d738610e9a884f866eb047c0bec981b70c2503576fdc2db47ed0f71dfaf240d1a0b8c505011fda40dfb7a8f9b99d26cdaad1eff0ccc06621231b314e614bb78dd92f840fcfc1f5da928fc1ce2167348c2ef526df359b42384aaf04a39b6f85e7dff6c9843845711ccfc8bcfe34628852b87956c141ef66f353ae0061399e368173650a2e36427a09b51da82f01f8d91b7af325555f7340e309589741e3f3eb102c96be5287f3588a410b473f14e1bbcd96f7c4d93640c61293d418bb3da1088f1e1b5ffd950dbdb581329db0975df2a822f5b20bb81515ecbf8d044c8c1e5f534bdd16f38cd1f9c1df81b86943d1ea89c5b1c36e2f9d33e55d78e5306959137f210ef0ee24016f87e1c867971a8e6a9b874f55c5d35998c7787f1e469a56352a67b309d740c54b9e3845e696ab39437b0ae393dbf27c3de84318b1875a66461c0ced6f6f4711944a0795adb7cc6627ebc3f153932978c6e943e07c3a0e138cf2f45977f33491260e0e29d18f9ed66f02fa1fa57b77d263b8e2d1115b23bc054b4f102edfc55ba69c085e0f0c84e1631374d130a1580e0ec0922d769cf258764d5208036fa6ced222e69cd81dac4e9533f29da8027919f2f57cbe0fb58403e359199e7a039e5950c5364ef41896339536cca2cd63b841a7e75345459057e4372e39a1088b88815664910d3fbb2918d43be7cf42a0a194aca34074e0857399f172eab5572fa1b118347877f0369b9792f7ec8edaca1a6218aaa4da9f68677e1031429f939f6f7fb30eab2aa92977cbddd7897b264bc68c2326d47368808781eb3c1842d745a30ba59cbaea7007f5a47b20ff7228c6773f7105bfa8144b555af622dbf1a879fa136554d967789985a63609d1f20836493f0d36202222461c49bffdb9213b82577e2674a885b7332fad03fedd28f0b70a23873d89bb8239144ba4aca8e2516fae4f4dee717501453185da95a0847f80ff0756ca38e803256be4fddf42475d0d7dea944896239f5fd95daadd0f6f58139e36d67a93ee533b908a727697257b4ad186f701621302f8cce1b337c26bd1ecb408a0ced9bb6407aaf89404c21b765568cc9e4119beda8af9b973cb5035d9a320b01b7be36cda92b40d933e1b4a30e3deb61ec30027640532725d1668aa7b72b15228622ce922505a1c82793122262a768507df89a42818720f8b9c562233a451b6258dce68ffd12082ecda7d7232f4ead2077504c0d8e4dbf945c53c74289a54101a01423e1b836580e26e53f4c2d9542cdae55bc01f5ef07fa52f3c91458c7093d12797827a22ec97ca9601ce533b6f04f0bc295edfdae55294d03ab150f1833178d23b67a54935bfb4979bd1f5b2797c95d0f7ec6b9fd6a5d5d316c7bfb7f107116c239776bedb0dd8112da685ff6a0f65521c5ae84a4fee26140134dc07478529205743058cb937809b846313fb18f9d00c96a378ec5555ad5a6377cf2f5ad914fd661f89b9dd976066d81680cfd7065a49f01231d0df7053df123277da44f6be827621cedac90e1559de3ff2bf8d9a434bb302bc876195d992da55e0ea7e8e08785fe66f666f269d404ec477343edd5d8b829a4b110b42baacaae8cdc58f4939bcdc27abb76c3ad5eca27452913c7e0bd5080da344ac30c0d929957232010cd3638c1082fd26b8ee3179b47c3f4a3419114ee0aa09b98834841f7da8000cd832d7ac06df30d7c37418723a8411ef5a646010e4834e068bca493400e5fa0f5344d7bb444c7c5bf1f36523c9417030c2a750afd47faf9d4b8e6689e66ab8a97b405737df9c84d091e5d54aaba65b661fa068963b797a6cd8283515f78a16740da5c673ccccdc321ba5353b3a1b5fda374b5fecf57179a20deb30bfc3f0de97df94e8275a02538df38e0a7cb229640dd75946a56d81125d7455ac8a8fe00aabef88508ec1bfc1702100d026607e965bede36f12b294c7ad3a377fa245efd0ce1316d1ab9751e5ca9c2e0d64b1c667caed4bb666451a6a2b8a4cf080dd12d6c2c3f353ade77504359cf66527e094cdfe45ecc0f3ba190aa4cb8c5fca27eae85f7d330807498abd26a6d67724f21d5149c478ec825ebfc30d102fbd0e3aa19b94fc808b6036c794a568892a1257c0a5674dd2382b677116358c85beb4542d5428c6226b290ff6c2cf252abb54380c77c42623bb3e06c37d4c0e12af7a1f496b076864def8d141aff13364f2643517d8daebd56afa96edc1aae7e7c2b5705416d99b709ab91c31020f7389d65dc18db0a5c68f4141c098201039f06aa6a1cbc9cf728261edb2cf96f130244bf5c6ad53660ee3605d8d43108025be1438360a982dd3195d6719a3b6ff6df88a3258eb6022587dc753a8b7361d891266a8e00a912637c511dbd300482a8acbf1548cd27c7bc5cffe921f6cab1189b7807b81f80b7702eb074518aed378e88e4fdf87818005fb98d7abbf8ff58150bf177e65abda2476f824a4349c8536034720ecf02ddabdb49bf650500722a7bc3cbcb6ca0de804a91c57f96f9a3bb7a74b96839bbd2dbf05ba57dd6e0e88c04742ac50044e5c0c5356c8881ab94ca847bd1027b2e3a825a37552c438c709a1c3bc8dea0980c7927ee4c1d7c3e507f5128bbdc6841932ae79f10bad1c87db66b11bf8145c7b2fd640120e9bfa087156cadd9116b6742d10cfd9f68752b73350fe271977c2f99f0e764ea6781aa9f614ce61046b721d3a046bc7319120c5ffea0a2f29842eae002f0c7d455cfad6379485e45dd6dc10d9a387cde1065f044494c53c82e63da3301e003ccdee8c8b1c9cac8a862d67f249ef85a9a3ad7e97fe65257116e9332d651bce00be7d71c7fa3ed1aea77f8672d423b47bbe3be8a6f8ae2399ea20b718ad0f97af905f434a88722558c65780893204168e2eed931c9c499a6d139fb4af6f02d421f32c100b9f1b35843405001003a1215a82878cea6992cb76507f6dd086a86551b70630cdbc8f461976b1f6932adf670e3634d95fb313adb50172f6f5e0c594471c40629a52f27589dde500b7d86174af906aeab7083efb3381377c90746469a6fd63f836f75e8f64001126085ba51f2ce34ff019f6038d33a332abfeceafbeca530045f932e5822961069e0e5fdf8497631e76bc8a6f7bf4b631e07fe9ece7c3cdb6aa3feea66d76628c071c8b59cb5a2d07519804fb8937fc0adfc7b1f577d6744208275e982b39db115798599e27f13da113e018e034dc61b61c55c83a133f6e2d8dd78e9e0523f57b0b10da1aa85d5fd8423733ed1641d6ea86cc095cc779c26559e216e8a5a4e68cd33aa71fb5cddaf386824a6c9e950e03d1d336cd15013d0d2c7213cb08451617e833234307ed61bb7b39461b59578bd5034c5389e89d8769dd9ef2c17dad219ec7fc5f88b46266e2a935c2d9d85bf022897ea898f49d9b07f1bc8fdd855715b9d838bf0ae2340fd3bfa0f9e73be6ebb3c400fa13b2bc907ea7ca746bf965b03718d31431ea73a2ddc76124c9acd1fefe310c224504becb6b3e2263d03264a5f65cca26d543d37acd0de1296d291e8b1e39b7ef612b046da9a118555e5dcda64a1d8fa1e22d2ff904ecdecfcfb76f648e1e560e9bdc1e16b70f454a7274a255369a3d155f7014eb8820f8aa2a0c7b88ea18326d9beb2faf7132f7e1c45ff2eb1b1acc8e4d76b7ef43d1f339128df59f77f213fc914baf132824ca51641367d768173c5a75a4e81bf4e765a10708f4ecfa754a44d2758139768f711d7e57fe995073ff1d2675f3cbf3f388a96399f5c43ecc3df6e6fd4c46ec71b35a7a605503f4e9e5ea76e83979b7a7cc5310ec9e18eca98586f620778215064e7fd5ee4c5b560765352f122815768a5f7e66bbbb62967c2c9852aa2c4a198939db134dba5572ecfda6eba6f2e8cb43b014a2bab3e74002925793ee84b0b8f9f15f52c671ba9ae9cc39f6c4a21de507ecde2fc416f69e086b0fbd42b36a0fece9011b06b37dfa1ccc3fc15e40bf7f9e93acc73088b9b0b3b69f83cec6e3c1a0b43c5ccf639a713dbb0533d69d769f31584f3f4b75bdc4928dac58b42a5865b09344551067a96bb53286556b30ae68f4137b405309d1da9b9a523bbe67b1a499ee3534685c00e45fb1d32d0b0d19b67b767fd6c74b497ceb75ee570df2ec001f931953cf11e13e7a2507ea69d47879a7bba106201f2c75e8e753ebde3cad24de98e394eb8670ef3143a2dbd70448bd66fbdb93fa08d09084950b48cb6779c2ece9ee85aaa98097f12e8131797d8331f581d8a1b1de7ff12863a83c7f7960ecdbed1b088204944d366b36c6117b2d5131c4fdca4655b5b849feab929aaa52b7d70023cb8c97776b5ff9da7b33d96030eb336606a642082024011a1d0851fe6daa1bc033b5413af9e53d4d3e4c3be79a5c6186f2970370ee8b417d3845fe68a1f2e83f102b29f91d8ec8b43db6f01fff8b58da322c38dad943d5192bc48c0ae275befd4ac0f43347d90165ce7d0319471c676ca11ba16985a802a90c403ff2ad71db80db5535b4dd8ee0432b4395e8cf35cb10027f442964b7fe99514933dad8614d4e8394216a500950222b08a69bfbb874796537a93fc8540dc05517d55ca69d6fb51d68a170f3fb858d1207fff0f865b63bd933771ac97d872be74cc4cc338f6433761dc22fea4beeb1a929d836c5e76924f9940a78d00f8e18ad8e41db261e0992fc0f6b768078e93ad6319cd84a8b75063aff8d9035e0c6503d593b11f54553df022e975023cb6cc8cc6177da9b77311914de9c422eb85468ef20d0d5ebbcae0b7d4cc411b6cd8a4c6cb158f633872c62d996cc7af9d5cbe26f7a648b2350d59cf1d43be023c774d41fd54fbaf80e343e3bb68dfec168f29d739d54201ae3ba93613ca211faf558a6670422b8c2a2810b8c75ecc1f8c50df95b818e3ef94321ddaeb8231a83fb9dc1c55464d2308b592c1b1f19912755a1ddcf0c9626b72e9979d8e7d96918b1486ef58eff9e51ad27965124b6cc44734a79ae60a61934ae19c5d5bab3c9d30a703e9cce49e70a2735fb85c425c0e14033ab0bb16d5921afdd9ea0632db028b589d83e752b947cdd14894d2a5c8b193c3defb49cb94b8d8a84f3f6df424227333dfe10085caf45623b2a80edf487b94effb21b00d9880f89289fbe9440f64c2189a2bc5e1ec7abcf68a9125405b64e04f3d50eb21277309c405af4b9f26cb666b9287d4cac667488faf5cfa59483f4bcc433060bd9aac7f55c4215d29e51e5e659863a00291005d27b78d24cbaf8dac1f421d9200884855c23cd71baa4430d3184bb949b7b268adb934a63147dbb43ff6b795a1b882c64153e47a53de2cde37f134cf5011f962b341084a958ef9b53a28caa5c5dcd3bab5d6c0c919b79c841b7c9cdb44109b473f1c6a5f93bd140391a41a70bb4570e5e2762e0795ec9658dc301e4df1c92aa3e7b227e745d67752c59f3fc28dc4413b1a2675c6138231166b76dbbbbcbcf60946428c282a245333d08e1a9e55cddfafbe4d206af1a8f9f008af18118f62eef800b988a51087073e61a87623ee8ab40b92a6f1d0dc57a9f845a2af67df494d656315d292981e85606221a5f96cf801ba3d338b1ca633e0a641d505c110c03acb04236f1d104fe94f35e318fffd926cf12ecfc436989f9f510311d884d20f04cfc9d4cb97068e950e3393d7c1d3885108520a5aa129f78f1d4679bb793bcff2d516a08df8a7da47b8b0377b0c96cf2f80687fdb78e0ad7210fdb3720d8e2966c8eceef097cc1d1f33f4fc822ce0afcd5f0078c1580d98009f23ee98a4b2d90242248f33dd1805d85b53b4dc0959a2eaca0e58ccb0701812a7b602823175d6e9a0aa422ac799821c1d1bcd5efd1c9f94f46e7ac79c13e83632dfd106b66252f868c5244cc5816a3178d12e78a575ebfc3c62f468bda72e474aa691865fc05549813b18a98d3c7fbbb4f160200baa150f256f4103f9275bc7d3c949eb8087fb63488d6cfaba725a9d16e193a31192509356966d606120b3453aa2e0089501f26706b9b4c8d98704320d6e5fdae9bf7079ac8e7c2c3352f4bdd6a082312be8f92d0196dcf2aadb820fa60c18e999b14db15aa283cf7b3f46395a79ae172c8403df21d34e77ea25860f08122ac4f2a222e34109946a3ec1a4d9bbe759ec99c53b16483746ad737d98c19ee7c85a257671688a52c14d68431f6c335a6358e4df1a1f51bc2db1264f1d74ef902e767bf3b908159b291e7b139e75dac4d5d1208341898a3a7216f6bd688c07782f6c363c3cd070fed7cdc2184bae5d61e0c4e430a3c681eacb80d089381f65487d4168fccc1d03bc57f75bf7642a3dce3a94baa88f739d3cadc92dc5e016e9080c5d68e3b3af244b8d3aba4d5c1950a5e60e584d10b955e7a98119e167d40c600436ec68432853ccb908e697d0ca3fd1930a2e53895396746715355cc0a908a6369c2470573f6695b631d56edcc756f3e1131fc8fb79fc190c0ad1a9adc4c46dad948b83f51c09d119c020f5eaa7a2412d34e65c50a33b3a40914a319a9d2d35825a8f8b8b817be7c32e4d13de6d4ce3d936bd3d32ffe123b728232679f23450c8d23888195afd2e34195844986cad8a8b40f62db0e008d67fa6c665d0ca3f1979c7618392859393eebc5e1eea2c58dd82043d17098e5844bb3879a21c44eb42d000ad8925a1aede8205552b186aa029b7b24ff6c07592e0e4e733b93e62406a02fc6827134546849571414535a7f828dabda43d50d5a6c2350a7e37e5d6d93bcf0fda48a118d92cee99f77ca66be8c5653877b39a056486c9ba57114f2d174a9456491c2af613fac4f34e4b4bb6d105cdd5b692801cd427067e8232268b95f00f6ba951035ffcfff3260381c037db0ba36befc2ea0a784bdafcb2df16f42d611ee5bfcd5785fa4afac6ecb51df79d8f4e315e404577c4b8e03c573465d9ecb56e2feddbda709c608ef6d816ee70999750a2edbabefa2b957fa64bba217a87964f436198036df9bd37d8821b3524081ab65b7d62789b768c239e805fe5f8125ebe78a52f4b243739498ed9bc5b1dcacbeafc35aeed2738bd837baddb87925e3cb22f41b94cc6f2491a5e01ed69ebcb159543f2b778c10afad4c11c81aa03bbfcb3112deeb2d978dd4d8382288207023347c5dcde0fd0df3028189b85c58b49bd35b2e8da99356dd3eeed1c2c091ba43a734f55aaaf80e2fbca235d9152dbf9861c628d8938a5879a33b619ebbbe16e629e933cc24cf6fa350ecac004cca451dd32ec118f9a1dc4c0661af36238f60753cdd0960e36595886c29015fe2478d39396f4a139ddaf03f9e54e2b7179069ee31ebee2595e645e06cda509497e6db597c4d0d3dc659ff063232a67cb979812b3eb4e9c467ed34b95c443f221cd7d8809e451cfc7112477f9954d0954416a8bd21042592ae35430c29e0a7c25c02d1c839a954b5034146612c1f6182fb0602d7d2eb8c964f5593b85e8b8df5f778b3825b944422c177c57d60057d53c956498728f139afd0a714afc98a7e2b406dff63bcb5d06869e95f7da24908928e87e017e440eaf1a79ed761c3c577075a45a0ff4796fe3bc59e790297cd3fcee77d0104456b07444b326e50877459aa844b33736d498a0af1dc9eb985e2ee79fb82c5422510041b45c5a520a1905a367b2d56ba75dc3fd2b1503f7ac5b522cdb22801bbeb421bf43205ed8845ee5db22b47d10b0429aa6033b056f3d08595a94d3c80cd3b17f89b7abe069ba19c550dde25bd016acf073f84bff8b3cc59c560063280011ef575bdc759b095dc63cefa283f87fc62c235c65d3f4ec272d0f2b0a3b03ad7dc09b21dc2e3815fdb85c941a93974916ecd2694bf3e40a601bcdaf21194b5fabf727e8a14cb0fcb2870e08d39b7e4313c88a842745be694ad618d2cd28ab8bec3029874086f57e7a8045bce2cdf819bde5c498c78295b115fe1c9e03bbb6fa02b63cce16e7630286b8718ab75773d80cadfbb7e7f4185c2633eb8f7aa2a9ba6973eed11e75c1e6f26c4f11c401861a1dbb5b72545a4c2e15e1f56f7bff3c28b7ee112f53465931e7abe9824fbaee4bb9f44460c6d85305685847ddd639d628a418fd9922b765fff62a8cad0f2e1e31d3eae3af1944ac31f3efbf696a2d3fb87df864efd0189990ad6d4e6ea80d8b0a2595650f6cbc6e6c6c2c0901f7c8a58f494ce7a3155dfd937e3cd47d9310213ffc92420197eedd3a81a2b5a4aa8ccf95ea96e43ba5f4528076f13bdeb49563f3e5b02dac975ba80e57e68caa177d5db685f7452730c219fc7c8eea1fdf1d9669377693b60a2ec966cdaea1b5a6c48e61d376da01ace4cc951d7b722e2fe04ae61a26a6a292234412750b54f6e9832f16a376cf5ba1799eaa67e9a6d295686717dd9a4e4bf383103e76d0b7e9cfe0365b957674b75f75848b61ca99c0fa921b2966ca9362cc0010cebe756fbff905ee2a3289e4d1087d97d282acdfbd790defdf308b941141b72fb5462aafa46aaa16e163ac6e6ff7a84a2e94b30395099939b185c50cedd0d7b5e923f8516aeddbd02cc5ab3daf54c5539ed1a8d9e2db7f89dd5b179e0d73cf724e93665329d9bea49a420ea681e6f907a2c7f93f3fd8dce1c02dc3a754cff46e7e1af1a58f741f4b935bfc11fbf9c139212d33ee58275aa606ff66ccd0351a7d1217469a9e2de9c7fec449ca9bcdfe89231a4b108731ea7a73e3ca156797ed9c527d65827ee07e22894d9d6f058f2717431fa932e1ba629245ce7268663c347e273ee44b2eae1a3fd5ab75ac1547f8b8f8e230f5af4c763a9c4c32c343c207e35f8019ba9003138f8183c9cc618fb51f696974a0d4723aff33eda5d53186e60c70ee9183c2094e13cd70ecd91e529a196d20263a61e282b0291b06e5d5c5d94b377efd8b632e1c0f23642b8b7457ecc5bf8925ad5540bc3824831d4f07025d8004d019bde1553962e346e53943d8a33d671fa9539103a10094e60915e1d0e5b99b95696fb076bbad745805797e2271a9769584697bd96b5f6c3374c8a81198a37bc4577f2c9ddbd46b2042ae0e578a15957447e41841dc6c8dca9752ac7bdaa6101a755add37645357064c60f99ec779a952e3c5d3b1dcfeb5943f27dafc0e5a8a26f8e02d8ed0fbdb6185815766ea2c409632745a6e527c8f075cb81c0ea386196e32346a556f01605d82e9d47cfa21e4611dc2ee1ffe0decea6d55678c0d8cf43779eb4743c73dd29c73d7e887a9e063d762329edc6e23bf610a80fff9f8eddf8212546fd608346809bb93ef04882a625a9b40ddcabb33de62a60c50f6cef396c105cc37b3fe351647ff95d69447348b361dbeda6820f7c07f16f2202a6007d07f65ed7cafc756533e24e92085c2dc093b393f40dc9d3ced003d6d43f9d36314650bf75a9e149f5b126b00daadc2796b20e65f4920fc48325728bdff3a0da9a09654fc8361bfd71bc230c3c9e8cb99989ff909bcc6aad9c7b5b79941331cb5144348049ea2d7c96d34ed91ff267755193fb6db99851b15eb2cf651bffaec65a0a851bfa425eddf96b4499c52198ff87e0621af3de26ea771401f186a2c50efe00eaa2234338182cd750d62eafda18b52c3eb25606ef2099b0189dd7cd28b43ee16be845e809ae4bd42ecc0d3d5f17a8b7c0d5135f4d9fadfe19e0d2ee387783de8dbd6b8df6cb8ce95d752751711d103d846ba7deeb95316f2ca09cc005819b9eab440b25bf02595b00035c855cc7ab72a6f2b39e4242a9aa56751527719cc9c1fb4c6ee35028ba56b66c7df424f5500e724ef1021e50440a755d2de1f321fe7ee2ee183b9f5618405daac5d3952664e72889b1c3439a24f03c32e8807f8b066af312f8aeaff5640c43df044e20e513bbf4adc3dd914c52fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
