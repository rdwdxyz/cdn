<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aae12e13112c94adbafbd5460e79a9744711fe1033a575eb8d9cbd53d76813d1947918433c40be306d1f256e8a7c4062d1074d36bdcf2feca27150e041fffdfa4ab686102708892bb6ea732a3851ca67bea9214a8a01c08be3c9f2cc8319b2d35b3320f6b7c652d00c234f527e345cbad2c2271408355fd47fb371a675e8c8fca50b72ce62466cb801aaedb46ee81af613fdac0d68d9ccdd99bb90e9c8faeeb01512f61fb348e4ce06bd0981e5a0c336721f110466eff50a86d56bb7cc5bf31aace94f47c7de59816b6993f36d1ed803b24f515e2d338882397cb9ddaf2f9b6670d5dfaf496f81ca0ed6ff6d878036283eac16bb2adc858d2288c067322f7e6f45f3bcd6d8e31ff4dc2e7d237b2f4daf3667230b174ac16b02c8aa8b401aadef3a4d867335824c744a10b41eb961bba1907494ba1c6d1f7011881f03701644e22cd01b21cc0ad37ba74de166dced677cb92662e2cc74f4fd463ab781dca691e3427b7f1c0978635eed86b935ce419f1fae15da8e11e9e0f7ca608b4c81e5812323ae23e6e59bff94f5619e9472a20f216732dd6c4ecf2381ab8319ee86f91aa89005ecd11b2f33e245854c08966eb4a2f1438598a832cfc06b470a8913b0e0e4f2981cac9de04cc7cb7ccca8c6b46ed0030cdd5dfd127a303b5514b51c975f38ada2ab753927f55a5120b25239b6b78e1ecef8e9ee2142d0d482ef9a816795095cf13984d74cb036cdaf75bdd891446efcb5285490029d8c76078dcfa9d4fd5e9918d4d159720b0587a1e49c7b51fa2c26cd53b4d236f2f916947a664d9c15f551339b8c6dc66787e3cfc62f99378016f0f2baec3a4174866e8eb81756a60428af028f1c3b83f3f39c414730c7d36c928a52d29382edacee1258ad913aa49f7d51a8fa17710b5c2047197ea669cc1d79627bb1cc9f22aac788321f303f1d1d35356e77639ea10d6d80464d4d57e45adb24eac611ba3c393d92c4e61b12491f6025573b02f5db60496e3906a7c67d642b4048ad554e733aa2dd58855a3192de7b1793bf608f6ddded6de41bc7e27174b23cc20aacdc407b9c16dfb692f5f9b240582dfffb399219b1eb359bba50a5a095467128c759ab3b02ae08828655558c76ba251009d853e70834841174ec12d776dac9bac1e9f5b7951a13e3a0f0fda383a9188a55cef99fb70fc58bedeac102ca9a092ab9708476b6474506c55bb43e603cccdec9c1df099cefe7301fc6b6ba7eaf665a2dfc8be45add12c87d9707a234ac9dffb4f31fb5001d43e43db52758b3290c1d1de4eed3bf3fa804be3d4b1d8fc1ccec3a76420a49dbb96b87e3203e117606261285af4046179a6bc0b0a1cd587cc2fc4cd45d49897b907d0ee16aa1bd0a63b3e060bca8d6f94e49354e986725e66ec80270639707abb094599f511f4c9c133cc3ab74f1abeadfd9b54965953bd4c0d825653a3f8647d699dc2704b0ed7807051ccda84e60c9ad7fb3274cfd7524295e36b203ca99adf798ebfba6196e146772659b0f3147b3dbf0b7665f9fd75798416921ecceed02a6d211ebde4466551954df54f23349972dd24b6d80dbc9a4d2770161971199fce11a57d89bd961dffd98dfc371584c379b0f851a909c034750cd727c5c5fc18d7cda9b29e9b729e31648428773d4c72b1b491ac42e5f50f5d59ed89cfd333dd08f071708bc069e0a8ca8422a57ec7fac35526dc23116573acecef5b5310499b82eab036639c5e81aea0e4856c48f1edb8456d2af73b70e75c2f44e2011d8753b9706ac8f75adc4b50bc403ade4d4bee0cedcfe01634f8ef8a00ab43bb0d0976e8e1ed1f995a2773db1bb6cf52ef29e81f4f1fa35c2798fd19f685c347694498c76b31853d5817ee402ff320aa4261e7b50d302ce0ea9a4c37fb5a2e0bc0c26f48cdeec33b8a5a3e636073da7fd906f3129847e4a1d7fe274ec49c5278aa4bc6064ec7f54ea6b6c377e1b841e32991a08e4885c347a2311d91b7b7fdff7844c66a96c66168cf856632303ab9814728bab184d2e2c5747c02f160c3959dc5cfc69b2c9165bc32a4f67b8ab62ddca5d5a440b544a878e2043829e266ae14e7319e77d364f37aa4b95ddfdbef2a29f6815a19efacd59f3d76940f16be2e021ab8385d3e8e90f59828d533bc198514f3826dae4927fffd0b7b77b7b50acf228e801e9ef7c61b999fe4471243c44d005a1e7b775004dcb11bce424452f624475da45ec66fe6ae3976402a844fe5244732cdbbeeab07d7e5079d1a8fa58882c16b70ba58d076a88ffa5926b05b49a0a5d9602592d3d5fee431b325358dec98d47f312d981f9a6c6ed1fc36196db48aaa0e31afb1d20a994338a1f9a3e56e63faa90db4570dee66c19a19556f9b4d7bcea3186d550646fc4afccefc708f1a0afa7ceb98aaef05cc2de854dfb9c548c679e6099cb196fe6d395958d8cfe6e31beb2143169bcb3b8ec149c1ae29e2c43c2823399a5a3f33cae2f45e480b32af7964f0600c795b5f1fb0cd0a28d7190560724efc5e502ccfc2c7e558d06091f6d11ace32f226b86e91e7913a2cd518f1d2c85f5f99838e3743848cafd54ee1fdee095447cabc8d3e70d8b2991a4e03cf664d28588c9a071b0a49f8e63b1f86f327d1f3019f910ea08305189c67f0aaf728c38d39f3aa30acde6057bf2db15fea7e057803098886f39c271e0dc8f270c2a02855a3f9bb7195d9f6e9598eed65f65c3920bfdd97d0d02ce6049aca4f7c9a6c44ea90582fe3cbc273fa719d0403cbe650df511f91d47e8937e75e888347ea54761b15b6942c70a538664f2eb401ed40df211b885206c7987aa66cc1164a82bafcf3abefb37dbfda44cc0e2e8841f098dc9f1e71d27a94c8a2be90a564a5d019493ef8de8df636ce7ab682ad3bafa82265bf936f2276f3cf38ef77f3d614027e56904c96d0c934e03509506d4f66e7a9caa6b2e5a4a92f8500c228fd7fbe3998981ca913307b2fdc7adf6936601216158fcd2857c26a094573c9e1f004e18c4bed439187f5aabbec5a4dbe2f6673c3ba1498f46f6395caba3a8f2a37913456446ea181cc9502c769a302a4ae224e4e5e251de6cb8bcce535232520f9dcfdcfb9d0ea795e9d15aa75261a18cfb7ba7169ed224d05dae88f7d0670cf55c70f64637eb1757bc095e7a93b60a61350823ac7df61b1bb1c93b9a69eef02cd65c50c76afabf5046b854b4891bc20f8d0273a6312872ffca6efb3fa13e29eda986cee618c5b5fec3c0093e6e5b2470ea7c5e0122e716a839bb73e9450a22ea2f50bdf546ce5bdc82021c15a0ec1bdd7fa875eebe647114340ae66f35d6c48db43596a56e924d99ae7f5c0f33e05195632d005790ebbe55c0ba1a7039af42d73ca30b57bb9f1c079281802062dcb663a003c41f50fde2eba65f40914dc7aae3e9f278616d95b2c65725a991835e606a06e8504a9c9357d516f4b783d1301c3c9e666637e30ee9896373eda48aeb581c6c1f6d3961ed6840e04cc06f3eb002244a48d63c712c8ffffffe0dfa0f557c5f7daa08d73122fa3d831ce557e29116a8cf8e1374494629fccefd3b12acaeedd5836b5ae8156d9544d3d3e4a1f5eed1e6bea4af8f957f0416df65109b2a2ffacbde5dc2ae9fbc530a9da1ddf1834441051b909faafaca737d1582191345d497d08f778571efdcb56f0012e33c093e8858d0af8e7cef56d3b62a74f48fb3f151c6f3aa7a13105e8ea8927d039eb6484c9468713e14be5d9624b46179238727fbda1776d2a0ad293d25498e2e0f1333b8411999322476b222a8b77a085ca85a21376fddf68fb99b5b8880344a753c76571cf81438b30077e3f2ab84da23f058e5984afc26807dd624283f43ce71e5e830041f08c39a3ac8077d668289aa36d5feccb1c1fef02c7bac87607a516a126653d6e9b4a0cb42b2276ae304446a098523791ba2b53d4019bc3dc5d4e30dc8cec0b86d4b15c49bf1c22893549e360b1bbcd2e01cdcf0f9c21e80b67945acc6083ef91ab5bfc2cec529bff818951141f94d01d8879da6853afb45513604c5ee164dd2c91917098855e1384db41567158f54921c133da62d8c576bf65924c156803635bcd72297f9c0d62a3958b414a7c579266da6cf30c650ff57f5652624e08ced8d58cd2b4de313ca12e08077f716653cc1d29ce36677a597439ecd302149f9e9727ca5cd4c6e11a3d2722827d40885f9a185ac532d809036a35e4fcd1aca9985ecaee4ede3c643fcf113aa729b3b1ebd539c6b65352731207aacc8e67c0022129dcc2ba6ad18d931ef69c42f0875f1bcfd59fa394e81808a11a45e121b722ff16c65fc9bfa83b6e3e5af1d24de7f0432b60dca22b30e7bfa9039827cbcb8ce7e393fbfb288431c71b317a19338b8139738a8cb35d2a3048e08f1d8fcfb551e0f4311dbba7af65692d8049b80201c998f15744883f2e36eebda387601360de5794deaaf8e84d9d73055d93c5ae5430bbbba8c22a07739270008545a92fbfac4530eee20a136dde7499975798fd0734f68022f3dac1c55b906101c238330cca08aebbba0d6e32496109fcd64c4e99332f1dee1563cd979e9bb60d0b0d0212e80e25c259daf73d0f61d1b46604cf9e9eedfd0e36542d352511984ad2b4c8c228857ce8036f8cc185f4c66cd3c8f08765864ea039592e24ad3e6bd648163f90b3e3498352fc9ee2266998c833b6f06ed5a70ebb0acfea5ddf24503b7eb98b8d29c70778e41f5e7fc8741ed0cf683b9453319484887e05c4ab519ae5cb6422bbc0bd395d3e2ce468153da97f50e6369d716e5061c3ab6575443e5d2a53a84d6a965cbadfed583cd292fda75f51f248eabf1e26376c497336de8b6e1506f095e2d1f4bd65fb05b0c37241106a86d16dc773e64ad5af30cb41eff905ab3f0a67b3c1e6f196a9efb3c2be6bb543d0e261effdf43803608342419024f2690925b3d2d5776a4c148d2b1ea9402b59d5941b5971045e41c1894ebe7e2a6a1f78b6aa10abddf01df0ece302570b90c11d24b91f04ed3b7cd353b8805886f389e33ca1ef830f44c4adaa20e8a78dfbf905a10499e2848fa6cb5345cff1ba6712657fb52e20e5c1d298fe88557374d11e24eae13f536d6a0a902f3c1c90c1cc94949819b326db740a61ac8901c1a4041ad172f2004d90bedd0b3105a888650866cc932c4464393770aeba914c355e2ca88e6f85147dcaf65ba2736de3f3a8553024f75e83ead25d90815acf56dbe257f280beec2f8155e086d9cf2481b6a87e545026871c0f9b19752ae1bc0dfd76663d41aa13c2f6f95176ba98e1f37949a7139fe1cf0f341f2239b9f79bd0e2eb414ddf0eb0544620b8da259e74ee08f6f41d9e5f6d2b550850b85845ed9a2637055dded447273f776a6b5db1d54aa950fff05b87400d06542a643b348bb9b707aa298064859e301c4f800ce6d556ec9dc383e0d947e83b197850abf5919271f39618be22dbdc2412f045328a8285b1bb6ba0920dec7c05cf9cd7773ff80981c2686fabd1161e70564e5c03d98127d6c20246a656b17e9f009754e73ceb0be04739018b75230448c33ab6ddb8e5949c4aca51cb0336ee7ba5f29ab6cad748426554cf9a5ac1d96dfd5af28d24f65ba8ea68087e830ee7dcc301d8f041d8af3cd9f259b7460012ceaa986cd86467879d94f1fabae0d92fd69ddaf76dcb26dd5dd813ca212527625a817c6859e25966baf932026993ef0a45e0bd27c428d1f8ccf3f81334202c17ae9bc8425f6e57db5351ff34739de23458a6082000963b82f8c0da6c145c371949d05e8fdea622f71003620312c7273136795c90b8fedfc1236487daf4e51ed94478661cafce8be309c2e64f906c8f699bfb54e5aa236a35cf4248f2021f3b985109b03a6c9e27b2f85aba6c24ba0c2e4bf24f0ab451c5b71f13dc586adebf792f1aeef3a87396bc42e476951ac157ff9c5129e2e1f3c0b12c6abcf5522fb88471b6356491c45de22cc38600958d73ed77e3648b628775de312874f2f91b148b4d078ba778efcd41b6fdf910bca9e77905c1b5240a0aa1d4a54188e29b91b3391b4856121f0feecddba07d6f821467b112cd97f19b051dea153b03ac6c3c58b6b1866b421b9bac9dc37081264aa01d14cf3ba266546c167f5312cd82b6930630847e12233f4230947ff22024bae19a3f85e47a10538a2dbd55c3453a4c09911b600e8104bcd4a60f9e44ae86aebead1fc97a8c3bad7f5b6545de5e02e8154c7bf59543be37d7d5127dc0d02b3617b9f131c03fb5107ce28bba9d9ac746976d003c6d0ca0a1dd239fec83538100e39b85e2a4810adbe1066ac559300957a45a0e46becde312a0e5f94439dc97bcd66593e108c22489450b15ea267aecbbc8ca0e3cf44f9b1911550ab4eceb369f27c070532bb4fc388b6eff15720855b14f5b01f1ff5f7a460f887d84e18c43024c18a2f175a4d5e1e150f335abf9c71cd178fbfe084ec1e0699a677cf17eaf05b76da1d318b0cbf8a1ff7969f02ea584c0d03f6fd81c80908aaddffab4575add124dbce694f2173d57075385c697369ff8ab293ab1da830c47d3276abc49459cc76ee99fe61a8119bb8298c43c10ad8ea7dd7263d42b05ddae2a4549187be9baecda8b8d5c40cd102122c182403c65433b02c4ed858b3827504a5a8241810bf1a52b2a035fdcfea177b75bbf70057bbadc59b8019b30357ea13f29ea9fca05af6e4042aa3234215ed1d03999a65d4511d42604cd4e3b6128323ebef9f93a34a0021deb903587ca844827b463ac719cccde8228fab7f613596a2ad299360c4c86fd26a5e7e9bd81ecdb47b8201ae6e21de3f4806a9610308721d8bfe61f8a3b40daf34f1234b12fedb66b76a948598b843fbab30750d227de8970fd3fa09d399a701696017dcd0667b2e511ae7a3fa9537ee2fde53362f7c4564abd74f8627da5778d88bcb57815e5eaaefc1070371d3a7f0e1783c85a7c00e89e17ed943ca42353117c5afbfb87955d879e1579e6789e19685cc05c11e74ba7ee6bd4991ec8a910be9e8fea8bc6085a6035b56593d54d404ff3cadde333e1d7eba5acc236d17afd5fdaf16f8caa578e4f4a81bdbad4182385059ad95aeb253374e163e5f29588ffab1fc4b6f572198c0e6897e8310acb2d7caf2d37db73a1d8c88b3c7910e0166675d525c56d0050096742503e28a933cff6e6eb0cc1005e7e53e539e30001da0ee1d072d583ec1e08725802228de0b06639e8c78587a076275d2e3779f366c605ceb521c706d799157f2ea6488c9d00016117556beabcfee53fd40207da581bdc915a698699c15b0a999cad9e10d2ae37f9b6328d142847014313d2e0edc9a51410cad43c849a45de55a742a2ad5850d08bee567bd52d80384eb2d7324138c7271e1840761cda20a19320221382bc6ea373f496abc9f553a724fa6935067ba327cb27ffe9838441ba395e0bdee47c975a2909b6f8b5079919beea67343b5ba26a9b19df9bf7d4bb3dfd5c9d3c3aae5f30a40f5161a28450ab5af45a6cc04231a0060545b294ed3f8ecb54d5957458d30af6be61327606ddac0de2dbf4517f724bf6dce86ce39baad6fb83e0e108c84558df1361824e481068c10847702b30f10c8964ded74875242894847f88b184647a03600f642da039139ed7a0fb9652d9a5367f3398e5790235d4957262883de24efe294ab83714762447c2819167be6e1fa3ddc3d6c4e84fa9b178d7de0104d4d685f2a3bd0e790536bed659cade5e21858d5908c694be1c831a4c89fba04d1ef311b36e3ae4d770b8ef0c73d83e85e2e3bce1ec2b8e0dd3b028fa110f2cd77820bd9f606a8cedfa6cd228ed942a4b992ef2642fe9966b7af45eac7fa05f9f9335afd0ce3b1237485f167022d6beec5e0837e9fa4dcfc69b4db30bdb792cbff626fa6234c6b5ed2114ba725f2003bc9adaa9adb746ef67dbe93255202797c40fc45b4a38d1662aaea281d4ce4d85eda6cc817c69e0f9fdb3d6566bb101b66a68217771b65ccefd20b46d8f552ed52f077f1592d17c9a3d3a985511fe431503f38dc43f50a119fe4512a9839fa2347c453110795152fcf8cc64195e1828a48f3b400ceb8c874db07ed7f8dab4f4c0a938cd55b28711adc14e6dc6b9f1ce5d9516aca86e7b8b35d6babf3094ce87680946ac7e5d04a887f614d21cb7183d6a03c922870656bdb3926df2a5cf24d3f2fcdc46889096b28944c3634cccef92571f22d2b7da3e9bcc927421f539443b8a0fa4e812911eab640fc2ea8265d3176765e4e69a5627c7fd2e9cc1e7b4479f29a15f1fd41e1ca15ffa87b9002a7e70dbcdb3f6426f70792584cd55ffeb5f01e2953f877f1646082f5c0c52216d99b8b91f477b412bd331dafa0c411897f4874991c5c88d7572af77c19a1afc0313321ae4784643f25884e376eb4d4e59b22ed2b3e5da3468065bf395abef18822a2d78e8eb90285bb9bfa10e1ea455c2a502a4cb1fecb4a26313c4c42f6529eca19f6ae9c12706328de864a958ae3b4fe059b0315c94393cbd018add2fedd2fe4b4ddca204985709bf35851cc7296de0813da81d548ba8fe7823db39d6a7d9bfd393bce5b67cc01351bb0237d0b0143e542a1867938762dc40a354059a64aec147290597f53a92ad23397d1634875f16411579aaf2970846942714f0c12f868c897b6e6a947c574f6043ff09e0e292d52b1b1132cf55d5c1510b0c22161ef0fcd516403cd1dcd617369bf0a5fbfefca0e6cc95af6bdf30bd9bd6f0112c6c77755b4e05854565e5749bdf8c11bea0b414c26ffac5a661f26d9bce85ef7ae3fae2f0765bda9b03313a76b73184228b86862599260143635b595f9fc87b0ec03f8dcf5c7db6201096b83425b4a204dfcebb198c6216d39bcaf5cb49214a797ea2ef0f7867d006683d33a7444a6eab263732aa97c680b53cb5353973edc1eaddf73dce367f2f014442dbf8e2cf175306a20d8e8d446ab1c5a7298685d8049cbf4c698d41a7fc730924fa1bfd1dbce727016e04599350d61faaa043f8b908408b475d27178d88af0d50b1b7c22c55251e7b1222338890e9ece50f038844a38f056402a547c19a4d05d29d832fd0ea61efee4af14b33b0383d118b49f670b06c15fa2620b3421a05cee2b4d00c22cbb77b874a25e0da7a3855eea93b47f7ec419b09824e0c7fdbc62d46357335511de3377f6aacb6e5c958661c5ed81d4b5bfe9566f229f50df0956d62bb8eaca95ed1b3a0c111053fe9005f8019233a5dc4e312a9f872fa3700a95e1bb319a7d1d2a7a150d486737ea965abe7f6351abdc99186a9d70ab55367bce2ac5b6f750dc0225c4a2757be69b8ab58005a461c145793091a6f90006485b82812b61d8c0d4e7e525f1b1b6368165ea15b95618cee5395a42ce345461ddc58fd8a487f5ccd539ebe76b86136aaa655bd2808bb6aa310eebcd5d2e27b4a6dd11c5e8c934b9d084f80eb045c4ec55675f14ce8a6d1420b0760a471f59c7672b0a30dcebb277f9448cec58d868fb6476e1726f2d6dc7e667e8fd630ffff9b90ffc86a5b1848137fdaad61a54170b71e0ea07a15fb42cefa53fe03a3fba1c2111ac99641ab19128d59412ab8e145bc827cdaa7c1fc945b469ca764c99a5d7c625a55758b8a2e9b9b5a1f1700c0c7ab63779830d8c8a8d7c16d8e15fbc7eb362edd5b1363a03c92b466cae10c96152e03ddd94650f4ff47f627a73ef6384f17cdcdbb2a9660b72d652b87ea7904285cd930104bde52fe32dd80b98c01cf83c75890573da97777615e881a64f2a7a5eb4d54cc1b8f16714bd72daeec81b0abf7c4c56ff405f7665af1142ae887a82123b1d761c40312c1a5cfb03bdb70025c2011e47e59053a02116e4a821d896c213034502ccceba7f4ccf8043bdeb848540803aad950df43738653d7d531c91451a54f1d546a469cfdd5e1e88cff539a4ef25445c9443b43ecb6deb18e8706e0f0da33c106f8b5d986d8e74ebf801760ce17c065339ba5d1059c8ffd62ad3790be2f821450e9093ca852cb8737b79d79cdc361f2ee241def97b9bd555a44784c406ef591788b6df09ecd87e473750445ecb7c837ca96cf97f3ca6da5a51b3dd32ed30f6ab44d110d35f8c94bf2072df613ea9e9be8833c3b068def729170ea81522339509c19345e9daba782dd15cfa0c63d0ee3a97eb248a8c729b3b4f5b163482a9053c9de57bdcf00881fe4169b3fa907ed6e69279d8b5e85f9a5d85a7bc8136b9917fb86beecbf7e4dd5fce2b877f1d0f8bb3ebd5358ffd89f57701b0d6824e0aed3fda9b8543e906acc1aa492916d84f8d504071657f8b5a8de1122b20ee7093ceacc2b4b86173cc0ea780a77eeb7546b30744a83a922ff7f3bba3d1fba2bc34352d1e2c64c78bd9a00e4013d217905f7acc2230fb210844226ff64e1a65697362351f5745161a4a3b3a8f37922de942f6c82f800beafe4f0bba2b95c23c99264f886fd98d4e0946c986e146ad42a62b170f15a9cfc9f98194541cf1d2de7e5549f1668d144cac9b38bf4ad12b82b8f15d8db68c4f7929c0e4f83a0408f9623e0567158834e79ff9fe8fc7a3b9d2775ec000883e0b8331022ab17b17534db290a48f445b2ecb9a7db9014022d300bae2f6ce368a7d5c3fa819128d47c7c2ae8efc33c8614223028f792e25b820365e6bc928053ae6ec201c1e5d8329cf943af7a66b1e09e18a47fe9834195c4eb576a0dea6cb6e2541972dc1ec31471d9eeb7bcfa07717c8a038f17a874611006a21f9e6b12c43ded892895bda4b4cc04c665fee28748a116902b47e6dda677b9cae412636a2f870e8823cf14e2b7bd5bee23e556a2dd4ab56892b612ab0c57306925b2a32232abbc34888622a4a553a14b277fd2ded4988ac24cc204c2f6348cc7e381ad9d348b4336d46f6f5ea76b59681bed4d110472eb871f0e16f0b8db48c5f8a1afdbeadfab2358754bef4a8199f06d22e4436e74b8d2bd46e074548b812cc881a8d0892b70c4a5a3f2ebd26706aaf3f765ce367b73b14490fec3d8c8fe096e523fe86f1f359004c9814d893ae8f09e6b19b8407641373a0ec00f70900718356a5ba7cf1e209bbd000c01c4ac611443db276ce09555a43497f8ee6a6b4e9bf8e6de85233840f27ea595b8b9b22a734abf10964de2619f7b5aa1978a7c98dd1691a3bb50a890a218df409016dd897ffc6bc7dcceff290b92dbc4533d41bc9099bd76fb7fd27efac23bb2e83f9ec20bdd0b00f1f51df5caf787df5b38cdab5210316b8a672665f8febbec5ab9b09b3a3516ac90379afea6492b0801f0cf3e09fd47ca732a93b53c04a616061b34f89b8a521dc099fdb163c8c2dc7f8f25c169ce3d974059a471fcb8ed53dfa1c1aa0ecb3759a94e11296560d1bc88fbffab76e71c753f43fdcdbb5e42ab834f38dd1fc71776844fa7e1a249cff89231d19e7abf2ba98a7df28ff29f3365d9e53f8f95e8c64b4d1055aca26dbeba4ed6b86d4824e7baf3f6d8a9d8824bf2db8578610e56e86967488d02fb44fb0f0b4cbdbf0a18813fb45ea9c839810468e81e8b91992431d6e6dfb0eaf1bd301c74c15b3cc08c3218ff9b94db2ee26dc403f405009e82346af752e5ecf8eca3f6a72110748add19b0b0562dfc68d9ac608fc9256f731827eeae64b009a0a45ceff001ab351b8148f76dd06a259f4c558d5b4e90a1d0ec34dd7e9cf0ce9d710a39337ab4f1a9ac4027401e32fd2302a050379ea22d69eebb066b5f403c44f1c0027ef70a86da5a15401771443fcaa0dea2a3fb755a570a8c6d94212821fff8785b2e01effe3a3fcb6606d4722f265d3284cf11b0e20bd7b74a301fbd59976ddcaf3c9a803753ba5fadafb10dc1cbf1dc0f63f155bb73d4e72569e81d58e93f41d0d68f4f343f6048a781b6545e6b82eb613d42961fb3608c4d8f3dc7ad0e2c3bc56b500e2f7df36927178a4285f70b1640efc78c6c9ebce01b99556a5c0dac4f25d10095f9c8354dcb5c4b425e71bced997eac966f2054b8647d33133d832eda68fd652c75a2ca4e1fe0612771253493ea420737b9f448ba735836225489dac35b3b5e3adcc595e8e5ee2ddf56eefce2b0ea28f516b4b5c030b8d35e73f6f47c01e4edab099193c3dbe86fb12f3646a98a7ee281c3f172e57cbcf19809cb229f0a0ec691ca2b4d996fef272b8ffd1b6479d2d882b1bd1d7df93e97dbaa26d80f3d4d99291035fcb1966b593fc87498ae4be1eb0717cd842c05d592cff1cee1d9a7e0e43c95cfa23d1c57ccf5b7af8b399613e7ea6ede51c22e7be8a740434c266ed37e93e8e6055a22d75b07af897772723a4d762740f6403ff08989c0182d12baafd5431247ae4624b86c17ce0af4dbf1ee92a7915190f221249eb3b8afef47874d4bf9a4d1fc950b6cdd16327fc16b68ac0401c486b3c9c0f10d18e27a5c2fe8859dda78769414120f1aec8e16d7a8f8090284bfe30f8e0ce85eb7d62ccf369c04a9c3b5640063ae43988089ed6d6a4a620e1654ac4ee88891a18cbf439ce1e3b468c7b9d6c6dcac48cd1d74f851490294c4db7e6c8fcf064caa4d4ff26f127132d432abb3230ffe8dd235e8ae92cf4177230c98ff27956b4a8e8a056849f0ee34334901962849dabf4f6947408991cb77dfa358776f011588608f11231540032c373e00512957e75b7f3a4f382ce316328fb9c194b7b1f2d344cb2af61a76e76bcccad8383e6a89d322a15bc2df94b1e799b334cb7721caaade3f4e865603e76a1f715f0961f4628e72440c7f1b8a48b60f989fe13fe6ced9dfbd043cad066f95d43dc186a4f9c439634ab71ceb18efe0c5e7e43d2626a21dbbb1a94bf29bfb7692efa7aeb68e1a122ef1334e5b69aeb177ab142b09a028f357a2250ce86cdee22650b9b018a938458a56bd4d98041dbc782a62d7637a0b24e0a54f7ff4ef089f7c2f4bb694d3e30d1ea971dfc67b4f70d57b13bd7780a8a7f4efece8f5d99b577a66d15d1e4590f0b70702bb81e9f34e9a570aefd196008185aa2693f7f97a88274852b4bc78d0d8871497c6792ee05b4ecad7488a192a74243f8751f402ecc0dfd06e4988a3066b02fe9561b5ffa700b1552825577254a83700884a5fcfa44789b757affcc3f6dc98e42191c0eda68a298bf0d4e6a570a53dfbb3a8f8899a7e266b5131dadb3e8fc6b0989b7888c30d032b6819c0b79acd6faad6d9fb4df4cdc92d5c8ea376e7224060807052ac62e8cd177119b74cfaee5c4f6ad3c2b49c39db6080052a1bcb4db87e615c91cd79e55513511114d1b31f2f74ae926b60589d44a2735356979bfe83ee6d7dacf999a711883c8df3f4e9fb40498c2d89ef5d972022ea6f27980a58246e066e61fc70f31e8f44202a0b61165d3dea4c03bba2f9c04600e9bebf21d0389dabe3e301757e3c5e57cbb397434a05e8b3ab1aa565346f0464947e0417c4d5a2e896a2991330772e91f23460bb62621b313ab40c2ebb909b151f4f13bc59963dc6188905ec2923733f57235880eb6db65d49ffe2eec92627ec57dbfd1213878fe7a7cb58412b67eb145ecc41ef4e70bb3ad049f8d6a5b9d21afc6aacbe7cb8165017726d22dbc987815b8942fc1862188aa60192c62f07b252d87840f5ba4735e3dae0f41ad70e57adf010ddc5e2aedf518803911bc68e017a72a895d748c85a252090a3f14408c33e910df141ffdb62d1b2e22d07aae999fd1d808773646319f9afee2a80d0793e0520e8ef18ec09329e2603bb86eb59d88154f931c1e0ca8ceef97f368c7d9132625dd3a39d37c897c5c92dbabe6877a14c9d5ea4913c81a8f0418c0b6142275b219153d67efef1839158686a26afd66acc3526965324ea8aac3c7dad7febbb4bb42cff94e22247a90149c0c8daa9aabb9ce4a403b4f91f529cb23cbce3f41ac88c6730fffa6ed8d8052c2623578126394194d10e8f7f3eb9d4c2e8ab4667955bbbeaeb620dd42109eb9cfaae924b33557c4b33cd64ad8f6b939929674d2543be3b81e3993bb3bbeba3a1ee4d9423647821f51733d26c44a42bf9e3715e3632269cc8e36957224c05cbddfecb4652084e17dde6e1d9c21839b67be0ca068aeb01077290227c0d201844552436364a80442392bd00ce6040358955b203642434f5ecab4e6c25d61cde726fa1492bfbd7d6411b84914854247fafcca8489755e10152e3955a11c05c72ed41d052da3a4ae1a27155505a86c52aace82893cf9e53162ccf0526f3d09035360c9d01bd1083695795cf3937608e35d63db6376b7f32964b0d22bf4cbad1f067563ddfecfcef8e700e4dc05aab2c686f110cbdb482604020c134dd09e204d6e1021cbf27269eb1c488692a7db2abd956679dab1620ca2c90e209cf08280caf07c8d26eb9b2b8653aa3cbca74468f4ff2f1a2369d5aea07afff893f083882a4c15a1b688ed2a6636e86b2412bfbf5a8c41512eda905d49b4168a0779b82ac40276d83b7c3e1b56c908e8803a40ffeeff16e283019802fa2a50f0757d848edb85ddb0219eb47e84ca19cd982125795e889d5ca9cb1112d995b7507832260317c701e615f5cfac0f916e54bcea94938366d6145a9069a9452393650f0d5d9de365c1067a780959f0a1d4883c7ad0f083d7db3e83cddb887230cf2e8f72189bf3cfaa6a7585cae8d0b9cc9c4540f0ac4140be8d2b800e0f3ad9d211d40f88b2d277426a188f374ba6de8efada12a93e9bfd20360ed9ae98d6f8e9c87a9d1a8b5762e64aa47e9b80f2b85abe9805255f2480619596aa7ba2c64700dcc27be6215b784418a8ecb8d7cdc670ab0b5d59eae74de66e171d7843f2901010c13520ea46923e47b19199b99cf2cb2542f067592de95757958126097a48282413762f5196df739b380ededd73cb04c6ff98daf864ab0b583e2f6651d5a57c508b9b988c4f618f7be047f5ed40316b7a28f6a06d45d72783227af6e6b54021466d918a8eefba4f6a428c5cf27d88d79dde0ae5811be3039d26fb9c5111b5ffd33f950b213b647d0a12612683b2a5490c43d06c9b02d52036c75cee019e95599893f902c777806969167e532f28ed3364362d3eacf7023fc9e7fd9a430b7f30fcfd5ac680b914d5e4b8e91862711c27ad090e4bc4f1b233b431fba6ae61d9dead11294b378649f86557d0add263145593e8356e68cd38720c79e98fa54d6ed8c08149283dbdc4914d110562301d6ffae20f76b98e4d3ca66f78a9c0befa23cad9330f6549f7d1866f788e1de6187742c1a76b17f7bd99debf63b1b6de0409f6f939843c251f9f94e74a2af186cf5e6716d2ef5aa7079558e8538816074a2f056c9ac4b110d87fff6cd83859dfe7c6b9710560373ded5bce572f0dbfc299d88d66b7546e889eb89782c61be6d151381d04300ab8c02745cfc1daba4c21ec4b9e1ee6f0e0ef3d6dfa2293dbda7ba50fd25fbcff921838e35843bbea7bcc9508175d0f3118004a1bf6bb09c6cd352b9ff3d838f19f9d69f86e396dbb6f05adb0d83540fbb9ee91a9a084c51baf6da46de7b4f3ca0acea5878810f53708d4b53bbe9d93a15a2608a88d0864d43c74342168ceed87e301ecc7b97ffe9c2f15c3f50b8260556075995da40c6822f16d8e38e06531b3fc49a06c6a87ad8c082548ff3ff8be5536b2d4d122debc1e9eeaf074d7234eab763f18e0c0350a088a4d8b4b28d402372a7a1111fe2a1afd2469773059f78c5ef58774d6fc341561be62dccf7b9e5f8ddba66f429804d2a61d698ae271ef904b51b0215c990a549d7a2497c5c32a51a1523fc889c2540048135d00e218e750051472d80b5623cb0a7f8d9a9eb356feabd4ab8c6b9e5a248a28f1d6de6fc23c1ea614d6e9e0cbeb89afca4fb386f7c37e044b304ef18ce656599f28cdf62010fe7a7b200b77fe57b635e1a8220d956ee268c69786ca2feae7bfa5fedb8f71786e9e8bf6481e757624536ab052097b852a4934571f5c2c168d9d83bd57e1560c2a1bba72ee9abf84bac8bc563e8c1960332fdd0c7cc2936ad5c1bd7cd713de2837a0f8950f7187ace5287718cd783ef209a234be9a69f0452917d31f8fdf96a3d5f5e6657ca770bbaa551c94e12eb1a4240c2615832465301fc2ca7f06395db5ab7684b0ca4afd9176f63ce460c615a1fc19ae3a08d84a772ce13452884a7293e26561d098d63b75ff6695645c268397d3051f711d124011258bbb5339a13e97dd1849ea017686d9419749098676e1d77da108aff818b865c4a81488b388d9a17e18f0977bf7cb7933a71882d5fa72c6b2d477659576b3000900e798e20bea3fa97e2262d9038f3decb502bd4c146c16d3d3a0efed2a64a805560c80cb3417db486f04c83218494dc1746abd2ad40b7be4a416bfc330a801420949938addfd65da505ebe3205f41ac6728c168acaef8cf5e0c0a52e9dd282e65097f0618ce03ab50ab56e6372daaa81028f0e67c043b0a36009495e4f1db483e36a016269ebfec98326f53c3fea63469e530d0ac62e122285eb2ac80a065a504392ae63c278893fa36000a09a5ee08acfd0d34cae8b6efe28ff65ac04696c90e38f5e23a6ffef7cdd410cc7ff00cf0839388a637cd641e0ba6fddeef19573b032f585709c82fc2996a87c0d4b8b051be2a7ecf1296355a1ef41fc8f9b972d0731c025f4bad3e271540e049193a879109cc39e1f4a41a921a29013f3118987e95ae792c96a8db44dfd7e1d5fcff6acd9b850ec92c019240a1344a480994a90ec2ddb6ccb7863b716cdb315e22be62fb99801f5a0e4e405e48eec17efda317eff5b0bc1cec94888809041be98cbf8a3fe1c6e8a967120e3684c7f00a6a8c0bb299367c8e5b7b7b0c4eda041a5f090ff47029ef5bcec4a750c9fa68061f3691646298d1dc5caa5e50c6491d148a1d62acfc5664792211a1b64354e37df242746e486ea09c18980a5a59514f7e91d040a7963afec19a88bacd5c5cf4ad39e764eba5d16cfcfe67f9558da8adb8b5e8c4afb36db4977bb46fb93a5ff15f86736874bfcc78229dce0ec5d43431ba65259382a70b23195b43a67e47c8977c8ac337e320cb8693803d9fe2e3ab4a85247b37806838f1935372eb486d1b53190a723394435f2c03f01af10865a40f24a85eac91c256f8f35ccb7d9cf3a697af909a94c19c6007d23ba553b9d48403b5de1fd64c898504184d0a423c6be9c300e6b762227a30c84e95efb0fccb22244590f0456247af9d833e25e59e9d5c96bfdc224169bd489309e388e73859e60bb8fa76b78110111a368bf0d3fb47dc5f0ff0b2b09e0254e425e4eec7ef446e9ea4f45b61f42636a3ac9be556cd1b188353415332423178c532d9e04332c7a4e0dec9c924562dd3cd1cf762e2fe54059528d9360bb89b5646fa368019009bb193d479c464ffec7259e9ac93123599d111f98eec382c0f92270f1a7a9eaba950042282c7bbe702184788721628d41ec696620088427f64def67a7d5102e617ba0917fbf5292fed8cad61ff8f991b8e924e18335447b15c9a31d81d78d897468286e450e11d00c795251ef25eec2120f13a445c9a14be726a58f8898f22aab03ad847562134549df8785f1185d773c501bbd90d53338bc72b96a1114a00092f4fb7c6756e975cc185a51efcd558552a1fb90351d38c21e1eb364cdbf5a74ea5329fb341bc1e492d46ec57d03cca7d81cbd2768aa76771d8997d78ce130682dfb542afe51fe128ad844d599161a4f2e7ac7e9e140fd4050957d513dfeeb68068ba9debcc937a496af0a36623438d2d923ef310336e1fdcb8e690aca35a062d2e6bf4b9ae42cc1e6135c7b1eb020627d7aa426c56b548a1c2f7e1ad8887e5c76aa59a0a47440e47b615532468c67e57cb33057c1c25b1067d59475ebcaea2b32481e7ee1e9993ed117a5ef1847b0f61a75840626279d3bc7c044e24e97af1d1841e15fb115f877e67bf85607d4cc41dc145dabb15bab46f4f109d3c233b06de095b36ba8434381e1f5f134afd1d55cb1672f8f61df03b9592eb36edf02bea45e7f92f125bb9cfd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
