<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e230d93b6ddfc7c1103dca32f1396438443781b52bd532e0c53fcede55898eb2d991163c2adf302e48f3f78b159d2f2a3922bde4ef38681363dacd388a462eeaf493940f2319ae3263c08804a0847c97f0d68ae3122795209ece7ddd2441f929bd4a858645fccb2a7889f649bd0d1ef5ca61fe232ab6dc5f117a3efcdfb453ac9b98d24c999dfea382f7d44ecd816166f24712212c59313cf5547ad8efc6063063e38a9049d5c3fa8ed420b0139e689f5b3d5c22ede3e8e04e9823b95be2df688227de8f61183f7c3ecf202f840e29fe46cf156129c062974951ac45c8ccede0c4bff499d12fe935e12eb69822c2b6ebe46f21de76875d354eaf2bbee6eb9ea1704549d56f9be16dc01a79278857e17b4811b46811addd706467662bdeb994645496f56fe91815ba2764b1c309d9823962c849c8d99034664b432d5bd8027657f28b4e0cdf9fd236be927ad5a5066f34dfeed2c339a36b039692b0a9d194ff7bbdf19d0182e50623b90a011e2b33dffafd733b69d70cbd8c15dbaed272cef9d6bcb83791fd3de8a4dc16c19338b4cedafe8f54430dc4f121bfc34dd3229a2051d712cd1ef368e9f06e9d99ebcf64e8fa3329b10a9b8bdea55e33428774a331077093a4f10b9ca25bd75fda5f07db5d389ff2add9e01c0b6fc4997b1839996d38eefc7a2209c93de4a1cf8d7e9ab713f722297afde15167a0f2f22f2df59c4c05243ccf4bbee948dc65cdbdedb97a7e42002d9ea7754ba8882799d929768df0f5746741d06a1f5bdd5dd4fb4aeaffd132c43c515b4d3b173ee665c9ebe8e69fd86131287e7dbe7c7bcfea3960f118cb82d7db9cf094a0d3cd8b727dcca8c053f11e269145fabf2a5c94949d2a495791ad8e747302b2829c652ed7086102b48f01faf1ac1d0fae0d222970344b7c9cfa5eb54cd26ffaf81855fb0022bacb67f69fe7bf38a1550552397902236cdc20b208815090530db3bba6839aa21c70978697ffa20816acd3ed1bac6afadd259e084107265841f4702d0a4920bc0f8fd174cff4381c8c86a27dd4aad7a62ee0bf97c198383b6b5c3746d3613f2f4b9862a2642e5b0e34cad388e7450579cb353a79c051b672a8aa115226f908e485a8071fbc25a91a8538e91a5f97a331bd8ebe4c64c45a8df44d9d1bafab5319da10680bc067d4d86750365b3ea827915c53fd8e418b60298d074c739ef76b1ba35a4acae5e9c3213c4ca1857df23478651b68976b243c118c569d68bad567b5fcc5e3676b6a1b7d641655172ffef0c409dff6def1e7a740b2de0b0d1c9a5e06c4a7ace905b46b4e05fb8e2a52f5b49d89364353c377f8aee9d848fc51e1f9825b8adeee31d54fed771508a214af089aa2a6a8f5ad073af291e7a8e02702ce5267e6fc06192d4c19d3b6b1e5c4639d8e32077b0920e2ff83050460fdec33fd82723da5d945fde0ed224c501fe91e35a2c14497d963954b6c362e2b155b45456e1024dd30b3e827c2f827e2f0a816e56713c87e5def0e63c6c0ea75cfb07f60e6796192bc74176dbe1a9524764e2d20a1e8656d9dfd51bb5779897035ade026d5a98c38e629b499fb54240b4c2a2964e6d75b51eb22dec71e90e0dec68520efe791eab80c8f6b1882651f77f83084f06f8a57b8fecd443e5ab233432093ef24c6770e1b299a4695c3d96320fb6144f31e01376325d201cc1b017d481ac47cac05bf06b73dfb6ddea80579b1a7ac4811bf295bcaff2cc7370ba098a74e26ae4a6ed078b3781aeadd14f3c9697d82c7bfa2f69cfb6e8e3c9d282981ed1ac493caf84b0c4e39d76f3f1253649c88e5a4c0e4703b66379e2c39c6207d5b139e6a8ba1db4332819af4208f48a1bbe36197827e8268c5ca4012e5eef49711e54ba1ddc2dd9ca63d4579fcbd70824dbffd8e3ee2b5fdaf8d884ea4acb3aabd4e8f7ee5a5f5a08c152b60557b1339aa809dcc0ce42b5859edd1fec17f862181e74a24bbb601d846931dedb73c80e6208c25b965b0f1b561cc3eb5159da4c19699373df6bd43e8bf80701855358ece54bde3f1f318a19197dad5970f32bfe104f95dae3b33c5994f65155272c766c499c57f5209957aef884bbc17f8708b1514c8648dcd0c75a72fb74585041f09818806a24c074c0105a18ba5ccce7f6cc1e2cff5a3aa311231c338613b1a39b261dd0315cc08a7e2f822b7d1885cb3aa4759d04579db0f5668c5fef52fd7e31e6a63e8fc1cf6263df5f82adf13625d1d5ed1fad723b3bc66e65683bd954ef1be09da919a231f09b0e115973868f28f2f03ee85b86a283be7d23640ba439e1af3317d632116258594d21d7381863d62b009224bb20a65fa3a093000e972285a8a3f84ef077b0917c4646a71de5a1c08174e7af4cb841f0e0bd547b8f741e87e1e2f3a3f026f744460d477005475a4dfbf3cbd5587dee5f5df1fb44343722349294a28f8eec24a3c6b5176ba7111a781ecef95a58b4e0cb7c868a45a316663a820a22f2e86211f1423fbed80e9f783208d0899b8092feb54c474682e644360285439302aa6a94d723c94c2568836c62b588ee602b3840cfda5495abf6100a15ddc9cc07aa2d4a09cab8f2eb43d4165142037d3018a8a4e7008dc514cebe71531201e7ebfcf39b1b4282b5949b497d159edea814c5e46558be4647b8d51778b9d833d9dafd20fa858ac3467ac32ffae950639a7b9b2b97c17a9d68b3b34717dad68008715a88f67f77ba880174d242371fe78546184dc6aabcd6f1cb97002f69524730cb1608482b03e616673b6a0e8f869de4d8a12232d13abacc32077db8a1ada63f934cd3b0d2f4b246a4cee554fa3ba669320189daa472ac7c25f77f0abfcfa0cb7bf2311627fb038ccb38d7a4873040d44c10cbcffcfd3abd4240844cece173f4863df969de973f4f78131aae7732e2e6c4303c0ad317dd921515fce1c3950f8b22ace656b78d610a01129aae49457971eeff518d56a6f961b16ab96a9fee731e12c2f61e9997df1d5f4c69d05a5742c08d59d7eb7e790c5f7c4194bd1a7d3e26f7edb074bcedcab33b0a4aaf182143a2ef78effe3ffd1c1a0c0f0af8c63ba277017762931e632b238c04c64996cb04eb6e70dec23d212d90149a362fe7a29d1efa808af0b8f803d5a4b5a19128deb07ce2ce25d22cf45323278b86403de2a95283b9a486f161bfdcb59b2f19295aba14071bde10cc71f71e1404bf029ca44f1e869e84b7c93c09f9d5643c3684dcbc7d22b47536f55565c4675eed025d6194e7dedfaf8c769f320dac8cda9de191909ade546f875a99a7394a3f01534041a33e2dcbf84d505794c1a9082b3307c87e3704a2e22b6e23c0f627e842f4557dc42416f2c8e75d8a8264cef0748afa4db4afa9061b5b6ccc1edd149dc358b54a883c789e181fc8a224f2b0325d3f83f7b976ae2e777b4eaf019552b6d8ef6f1c56d4db516c2dfc78344b570541ab2d52b77d754713740117bbef61858cd86ce2c3e536f16810d0b0cf2ae3091d5e7b441854084966de2cf906c43adc3c4409b84fd56798e9c399758ad615c4a6ec3317eeac7d5c7fbc6c5afeb218acc9913df4cb9674aba6562b9a5be95ede1579a0840ba874b290aa8781f09c58858e5ae6133cc0d3c384c03a423ee6f6fb0cbddc56f8f923da6ddc716494334c54bca2e03d506075ed673250764e121db4bdec521a235965ae4ef1011edfc5f8e751265db5a9057ed914e152bd3ba14c187a6cd612a8fb48b7ffdc4933fceee0fdf86318b2d5bf05b2f0b8407414637f1840efdb151a90a91aa260158b459378ce915609c75f297e1c743409277f2522f2dcb9f7e9315d9f20a30d73b713c17d9e58d20b79340ca69843db5088b6819a7c71198aa2cf5e8f0a95c325cc3b9a787ddd12216ea67ed46b1669211e855996cce34bb80507a39881f27221b549378809e42d2823e23f56932ee852dcc9a3134e0170c916a5d4d92d6abbe68bbc8f3548bead7c93db59ee605dd3ba72b4aa413e1276c7dc6ec7bb8cb7bc54fb1900c6bac3c02039945b0fe3c36750735173946b9da55e463c6ee15e42a6babd83da6b1a26139321c639ce916e7031a9bf089e84f9bd084a3fcdb750df4a495a64405a6c657e12ee1582719b8b31f45b88be19a97b79b995d8be35aba3651ec19ab679d18213cc1ade60fd9776fb8e54e4077c51b70346c8bb59f57bba52a6075379b06ec0e3205349d971d9f3203ae388a203697c10476030066dc2bac20c824c152c654b943c852f2453904819c34139878b23bccfdcb650a3b46664265ed931154f69c112d9277b69f8333e7835118f9441e5f875a9db2da11e264e3c1fb2901463cac1b54c0bc7245be39b3388f128e18cfee91422939d7bad064472b8c73869724412b7a479146e3cffd9ddde850938b07a5fe3db5a93f4218316a71b1a0c557beb63a7d971b6ff8513314100ef15f8864a62d41684e2212df9c36e9512a43239e0f1c9b98d89f9097c1c3ac2b4f2a58b71b27d89a84ac6b271412afe0a939dba0be32bf7a7b69fc2c576b6ece78dfc3213be52bcb0bd9fcd1a8658fc4135dfa8b12cf0ac231e752754a7255206e3f83ee7d59736efedb3fa91cafa1560283cc2eb9ba5f1243de41313c807df1b6f8e674a42a7b9274b7665a562c17292297fdcbc0d89ad2b91f2b573d382dbf5687a2ec065f2ebc7f397699c668d6c8c7dda892ee8cc2f5410716df7867356f175c153f3c48d3f666bb3b38cb5cb4d1aff04e4d043ddcff5c72b0584b1db5ecec0152d4a5d46d7f96490cbe4915690789d43936d85441bf82e7094b0f6e1e6349352f5e9a8036ebd3b9f7a0a29a23cbb37ff6662d4c1273dc4ab72fc2f53dc2c0dace9f43c61b8f253b49d4990b2854b12f3d4b85dc9da264faaef357d1db8c073f9511520c39bc56e6afb02eed300a3f8b95ff781591d6197ddfd23d6ed4899ef911723f8bd532886542c1ab780a6ef59346bc0735385ebe0ddf9b3406ecc913e075f9b37fd3572e2ae030c76073d32da3efa69300168bf37a8cba4dc9ba7e1c5e9e1670953e8d69c735a48b53cdfce896dfb94e88e394e12e7461a4f8373533e9fac37261037d9e75d16f00b573dc20c360f97a6c65c6415bebcf54fab6c5c2db24a6653212097f8c4dcdb325b893d17681f73628c2747e226da9f5ce1a4c97e68023cf1f4e2aea708f2d47a38e23adc13d35291abbe3c125182b5454f02b6a482e9e56492c2625da89151d79d167f319a31c1d472f1f99ef851ba2c43330d43181ba10382fd04bc43dd90bf77df21c665f1f069024befff1fb5a4f8d7e62a25b3673f4a531ac18f47dba2b1439632898cc45a74f9c56eb579acf710dbb1d78e1bef3a0ff12ea919432e27d4015586025d88e33b54bf02252761197df55bcae04646d9a3606f6146d4e944f9e763952d01e3e8b99ed22f8de5bab5615c88cf715b3be459a316c19f9b8322a3ce66a69c77303646404e691feefd0b837a6d0b9e04cf3089c34ce1a673affb6b56e42a886e8233245596cfe4f38e347be9fa87db47da51f0307a393a24032db14bd1f6489d8c5f19b9361eb8995cdb93e5b1d890c459d4ebc929e4c29568f88206d031929658be859a62456f679ecbf2effef927c7edc0827c9f65f615f232aad26fa0a6f217b1182e399bc3aab23af365f69a7e90657bcca1612134781c37c499c43045d608d2a64f66d606d4e8fa4084a2e4fbc6098faf5530421a76d3c006c6fc6d13c2cef4416bbf25ea47b8eb88e2a3349b6c23be202e6e7169997aa161667475108031e3553c3bc9cf1af8c35f6f8ad54aaa80d3bbb06f0be82e8fca6ea56344314e3a04cf4e4c7dadad41b5696ee8910eb50ce02720c455de998f88e10c9c953fa25b8077f856fdddf582dcc16944b14b834a0e3399896ead04467eaf2f6680205558880ae9e3444977ecaecd8f00292ade71061fdd017f09d3099157184e1df92f43f8bb5130f25c56ad637b88afb145d68fee093eaf83778d9abb7f820fab108e9dd88814f56d40b115f41f0f3d8b985f63cb8bb667c24d06631961476a3f58a6b5acf6472f61eadc9a126f736fbee30eeb5d71c2f1fae1305e9082dc99c43e05710c23ea4dfeec4be2a89880f512056601b59d9e1fec9f2dc9f8482019e0733cbb4ecb12ed19c31102c06bdc7c472da5a7f87c352c62aba11a8c951da13cbfd535fc885d2542f1518a7e125cb60e514cdc8c5a4f58ba77cc73ceb5287ba68feee78ca70e48efc2f2e7e0b6026a35b32148549c2cfcc7d22d5646fed179e1fba04854a6c502d909547d636ffbb5d4c8e6504ad3544a12845823097fac1088c03f5d7eeb031b4fdc8d0083ae9a7fbbd8782e70c50a550c68c5193135338d6da53f2b1c6d0681b67dfd8daeef2e1f9eb39c62c72bd0008f7d12059ccf15d8fc66b7e3885cec37453e81004d52234a39df20fb45b615bbe78e938bd4136873de77d828eaac59c187d99e6f4ef13f88c70f05b3e46f5a8fa1dc17282bd27bf9a7039cba2dc5617088cb13b45e76a11a19c834c1dd5d52693e6424b41a78fec0e0e4c5f9c47a647181a761b7d331822baad9d692677b6334c2871d07bff6d5def36955059e4cf0ac024eb10540711c46027f85ddb8863f753515568aa1b26cce7ffe1f3ccb21365feda47157136205e984c603d41375d3e9dc9a2af1f3f80762110402571067745def21e513cb10f0624e0e24aed81dbe7c183947d65e0871b2c82c7baea24d2766c6215cac6b8c21d477a070b773d6d7f25add4da5ac693cc7fec46e8cb25c136c5fda660774838e10b6a29473ec8d06c59ea3b49d84c45c6e94bcc1f757f14e92ed697192bfb571d9fd086d8d67c2cf2563cdd7f015f0cc3f825ada213ad17dea4892e06d4d3534188b429d206116da2623a9fbddd16f0218013e107c5e7d78cc271a5b1e41c21bf831543ded8aa7a081ee1adabc48f8d17bdc3bf67dd9e54c18c1c25ee44556de480854b8e34dde672554f88c8337c204a07571749832cec4a586bc899cd6b8e18e66cfc97c6009ca8db714601a69fc7ffad89d10c3d4523fa44dbf519d012e235c0ff3bb4753903b0f965767f33ec985c1e75a16985df4fb54893e4f694764c6953128c3585653a3376036367df08c782a9e781d575bc5e9ce7dec276839087ab99c357acae6f794c36299e40b0bca0fed678bee451c25c53075a847b058b0929374767b1b563ef931df173aaaa14756dc180eed6457b7b52dab53693a9767f4dcf755e46f573e3f04631850c28947a8dcf9eebea60209fd6055740b2760060ce36ba89ff182697117c488df9ef8431b095e860f37a1038705d5d9c38da17141fa10ce93b320c33d35f922ed9e7db9b654cfe4f3236b949adaaefcc4a3bb00a7930d1ecd135e67305220d16c4f68f3002487a850592e840b9650f78b147bc86f9061d2de6a1e520a1faeb610c4379120d41cdefaf8e881048cef6612b3d1b52a6ec19b0881fc0798485c8ae88972d9418574eb87370428a5a92ab716425ab464af8c2dccc95e6fc0004a7241677963003af87d353d2a1e99ce340ae9dd420a4a9e805d7b752a85f9b0cb9ec79c40e4eff6fb3999500cb3039704708936977ffdc0a81ced6f4be0c23aebf97b4fff7f8e5096da1d138c295e11781e9dfb9da7eec1cac87996182f10364fb6adf36d03651a3c55dccde7d43de5f35c0889603a052177dd30b2bea386f38b5be9dfd39386f48e4063e0f0f78eef3dd8b56367ab59c8580e804b17a3c1ad418bed3a8894d81d58c691f06dbf656b2af494d2356085a6dee8a0d6fe6abe08e5f444131ae56187e9e6426f59f51e25cf9e35de80dc1e2782ad69263eb3518ee558e9b7c94f9c571a913abce436d098ac314b42f1e72183482cc9325f64a012ea38c6fd57c65edb8545822b527287277bd99b4625a304aa40d09348ffaf10f3ac9f94fc318c21f3418d5abbd20404364ea6b6b866564659a61c45e5f4051b1ecfd6a9685482054564bfdf8770301efa52573f8b825e67dcd95006cbada1e4f6f9d92dd7772e24061897793c89bc2a609587590c3357f38aee3706128e4ebbde58e7697d1acc66db2a68fd14c17393e530faed33dbf1244cd20fc272aea9d5ce50aabbff985e8075c3791c615249a9556bd85a794756dcae3e4b08d6a429df0444e1aadee7e950cfa6a3442f971eba721d27c37beec40038501fc51da3ce97663ffa9bc4f5b7a690feb44b59617edd212f9e4065ce96df874c44f527a4788336a5748cc1e76499da3e9472acce86da80768c0a2231e6c8927caf676871220fd116bcad9475124addb79e8e7f623f63cecc3b24c596ffb2c9f5838df10294c679bf5d854fab708dcd6f3ec941ba54faf78f0b1ece04142e22ee29958767c33b977602f1f78b378bf208c1416270adc9bc3d4bdb88ca40b28a4daa4de40510930987be347ae05f4c7466fdac26cf192ea349ebd28a8a8ab5a588201c950c28f32f301ecab2aa151311d305854f5aa9d473d0c676946d1882d3740cb2700a3f7f1dd9b7c0af26e4e966f73fb9675d5a4a7f31bf0b31236b12ee4213ba74b07a299df0d44a3d3b321c7a11427863a4198dcacb9b7cdc7d7c95e0ed851b04a2dded0657086428d92c3f67bcdf45cde50995cbaa70c83744df7bc3dd686eeaf7c8efed1f0a1add922e4f9c7d1de43e83e167b436d7220a38d12eab1fc3e4b74e0a66bf6613a19b686023e7711da92ad00cab54abd7782345502ab6acfe796c8f4aed66bcb6a402dc619f4791b432c5ab3373a5e572d773ec01625b3398f8f11a07f1bb99404a863475700b757e9a6854124fae9a28e00f388b00a8ecc5aa61ac12ff68bfdc0ad506d055e29e8835b2ec10bb7b226f121b3f8005bb4f919cdeaa86e9b41220de4120dd6dec12b093a3df5d545a380a451a8b84a8ef4827781a6294225e5fe9a2f42e6b043a59b5b05ea76926f8dbd9592c9e44e08e82438b97e7fa888246054651d852441240c7b013d505cd5f22ba0efaeed0154abb6d34dd7653b3f5db36308fe8a154d1e3871d0a500510a07d8e684dd4dddfbdeab707859f3cfc082f7b1e938adf8e02fc5f9edd331c09247d853ec26c7c3f3ca188e1282a2037f2448946ddd6ad595e5c46a6cd020df48ec2cf80f0b75589e0a6ade8ff90eae11f5704934cf99c0de3c8cbb8e38ed5b0d521a51c33f9bf3c3d62ba22b572da9448bf69cb8bfe7b6955dba2a9162baafd503b317d7a4782435f289c84cf0d97b5e275f388d8583bd6bd2d611bf1a5cdd184db8ffc8b4a49ea33e6f5b171949a7e3459da46ba90feaad4dcc72bcd130b55d6f58622a0c6e23d712374f7782dd98c7eb744c1ede4ed9414dfae6f2e1a9a510949398c8cb79fa646da856afb35c6a42e21298a9173a3bdbe20ad0a71aef86074c90fb0a0d36aa818632bf3bd7a5d87fd5c6355fa4ab1e0790595d82c2a4b4faa687282eb5adfd6e3f057a95e273a61ecf1c2b819baeea94c9c10b5bb81868da8a0fb008ac85b3bd4982a8313e050a92b6106e1e2abfec49fd2327149e67e3049df5626da3fecb6cd5350170997d3a91c29dadde33dffc26926b1f8d0cbbd848637af5879f5e10fed5237dbf3bdee5d5d1dd82365122461655ab20fe51ae61f3127de64c51f0ce9854308fd61abd3cf35fdf8c66de383fb686465d7878e8fc7d604df1f644f715e8bba2cbda9bccf40446199979c6fd8cf12fc2be195ff9c9b5a3fc06f50aef6b33a92325eba4590fa016fd598a153fe508f4b424da9ea9be50f9a4e976b42fbf5f49ff5d72cfefad677b1d96e97748d5c81041ef178e91423d8b3254d7d5c60f54ffe7eb6be72178b11991b9424727ce981a0695267e53bb950f99a1b3155089c2c8f96ae2e8ead90532568ae7a0737325aeddbc6e57dbd77386a86902fdca5960146d7a44ffb003f986cc2441a10b4b11594bc85b0348e7ee6edd1f448d07baf0fe70f25edb9941ca5a4d8141b3e227dbf1860139270971ae4536e6b8f8333807063a7361504cc0ea980fbe98f2347bd77e5e14323495c4ac204609ecb0a5596ce4c4dd0911e5b42558ffcd745f90cda8d7899076d06b480a42b8192026e5e39c51a1cc44f1b5455e8bb4df2941d8da891037c2af942411170a6217f2ef6ff104e97cc273ebbba86077103368e660a7ba3c567ae2d8acd98c574b291b00ebea68c9732c64355ff96e495a40d3639fa5958fd0ce430bc0d21a0f9c209411c045c68afae74b6b35f655cd3f1af390802b9edb1d53c7c1ec4cee61c0b77be040162e961a72ae317e7c0d2a9d447eef496c3b964db9c92bd99a88d89dfcb0a80679a3e38707110135ca8bfbfab165878631d6b0dc6e897141705719a372cca08b6bb9421df35d1b9f1a7f06192303ef403c4355f673752e5b907af00aa14252b9cc8a12f70751abb890df60e004ac50b38af6dda78464478ca60c4201a7b24602ec52524993b7b2f50717f4022a2f4c474456fcf550fbbae8dfe33b34f1e42a00f4e23eb9faf0bc5ad563f86d0b3c0a35341bb1e7db0c4a2a1b496dee3361e82170b53c256ded8f0b0dfc5dd5d00da87dfd6996463703204ef2f7262a4c2e6625b4c46c8024e886f85f0273e58a9c9dea9b3b2cf97bc2a07dbbdfdb69fc5a98e69911042b6a0c66b8b637a76d416e1980c78c52e1864b46d3c3eea31a047bc4f3a916e477b34a680e515d93b741c4f81cd208d190999626a5aec856d1e104d34357ae48b4cec476dc27dc7e6d6f183f2af3ac674a7658090cab91391d6fe03784f7c9ca98d4d36c306d17cc94363c3d47ba7ebd55c23bccb22b068e8bfa63c3ec842dc789b75e89441ad6b78baa439517b24cede15a9fb9f1556b7522ba30d5816e21b43751d21ee96195bd3d704f30194db0baa3870f4b90c0487f7f5ae0658f4ba1f6f98c322efe98c091b60f97e89a090ba725d1b6b04805ea7aa69d08ba598a5b32a58c85ff57c2114ae39ad195242b1065f099cb0a69ff63eef45601c3811f0b68630b148468d915a0e10896e88f06395deb5c842fcc6c52364566485bad5c812ea2bf85007fc829147e3d21764ce28cd61ce1bd67647c18a3366609fd07981e2076211ee1e167c5fd927d0bfbe5d757caa8ae1e19a944d2181d477bbd76f0c318feeeb04e1645f5d6c7cf1214752acb84d74b4ffe63c8895d0e857b019dae878ee8b23d49d787f9f1e89faceae56926886659880f6cc6127af804b532668f1df11a9bde35ad7b449782b65f08d5cbace86195b68e1bcb8f930ba68482a7d163a9fcf553ac75ce41c90841ba697c4c574fb288de1edf92a6d7eb34b7167a412875a160c8116e9281af7a897e5c835b9d2c1b8102ce50b263deccd767c848985ba17bafe0ce083e2e7e623fb99c0b3e249b41bd67878d123d4fb9b03de762ee40e954e1ba3dd493fc601996307466191b9d547d2f1ffc92d166878774a928b82174620375bdd2a760c6fc0b6b35c400f48446a54b7b5416099f8fb83790834ca305caf5b39260d397cf07018565bbe303fbee5081068a0a5cf22cc7b5d40c8fc74bd56f25212abbad1afe64e83965a8cf80f2516e9ec5afaf138a3a193fc0d81b1da48c1c30146ecaab804cd4a82cdb64354b7b3da6a5226689b68b22acbc21a0103759a3fa7b4aa3899d8377428291c47cd70d628067766cb65323c28f56460fa6a935d371230e1da7d77fe7fb47e2ece933e1e105a36b61b8774ba45ca8c6876ddad67884f6753cebbc034d81b1e9098673dc38a9ca097bd05bdd8930774493254efe2052311f8d051bea426e1d531762ce20e7546b3087c711cea0917d51357ee42c7df696d300eb8f86d121f80ce180feee2dcde4db4741fb6fb70987520a21980162b6adb4074a6f171da530978c2fc1bb279faf6107a4123d524824d9a2aa434750fe3646042532573b743d4bde636a3df6f9e4b803232750b25f03235ed2661fd7b5adaadd33623ea8bcae0e0dce734e213483e9396d5b2f276984c00a2056ec840be03a082123b9aed25c9df0a3599299922b958e449582752267b10675260ead84b7745a07acc039e5374fcf49862c90b60e45b08e1af6d3bcd5f600df7b422a4675905cd6c3c32b2c4497fa9d4f3f5fbda53e47fff4618a8850f526e538add3fba9f16abdd0644faf2222d674306b9122a00f6134e0a073fd30dd488592c0cdb88607fd69ba4f7855866dd4d290e50414a151e9ccf3072e90b567ca0b48a8eac3a6b9a3592e159727302069b535e38d7ae41cd07d2af4de97e4de992bf159dd6008128f6776a7a344f3ccce02b21af12f1bef462681ab01e3190fb8e440e4c9f129d896be86c35fc6e42f311cccc5907667e5f48a8483ffdff49c7a01b22c5a338f6e008af0bbb68e158b9f532ad88eb23aedaef104e9ed23f4cb332f183a3db11520a33c4cd40d7fe092f40d52e6695508c6ebb9666afaf00f7f1bbb291a42050393e8c5bc5fe5058a871d93413b0de26b45c47e55ff490f54e80ac924fa3ae7c10f9503cb4b4e47f680f5e4a8dcf51d17ab7f0bdcc3a40b5056033f66efe7788c677bb3936ebbf6a4681fa3d14659fd38d4e97cb099bebb839996a7ce25fd9d00a29612250ee5389fc51dde905c73514f0cf20baad2c72fe626412caa74d655c3494f7a130643f4713b8c9f5a6360f799ecc9aa95953727a22a2999033f39a90938be4048650465520c6965ae2f286b75dffcd7a9c35ee1f7a6d627ac00813ef83cf13c017eccc2f794bcb2c5179500b5e3eefc3d0747e78c7e8e54635cb197932ebb5a470ee9d9a4f7f32d042d8098d698196a991a4290af2e98be7dd9d1b2275d1816ea1fb694d2d543e63e0d7907c92014d701637b8d0f8d55f1b58bce3d8e696b1a5f80d562bc7f1a5af82a6442398f648ec6f5264388084712a860a22920dd399c4672d0380a6b3e9bf98307fb189ccd571b1ed03a5dbc8ec631f3782dba122ead3ac64bc98f3577835b77512bf71450ff2d73c1f1e26f7fb3180d675a98a20aa894d83f48ca3527a1bef782ffcf027e5391d71a02e0deb8b80536586d5d12b2c14fece6adee3757e3d65edb9043dbb857a1d8305663bbbc32444d0767f3ccc122fedfa163087f732c9fe4ae9bd16b8dfb83683c3fcce3c4b408e88614f8b83449340658eca171f547a08a38419117307b2d5fa147f04250eb0e5102e4531216959035cb54243f56e543ab5304e3a89482f0ed5e061b5b5b97e63d238190f55c88bf4a548019f1e330c3114a40227f30a9036baba00502c36f1b064dd4155223e8e5a0b2f22fe9eb191ef6046b164aef83eaaee3a8f2441dd40633971cf42596537f6ba5b962956dcb516ef26f07715b29988cfc6d432fe6ac8122d773fbf1d16b8ee4dc5ef864a9262767bcdcc4ebcb0710fd1c61960056f8d299cff825ca6f65a43fbe5126476160ab951d11e314728897b1ce630140a9e05db52a4083950981096a6af2495d25cc1461050af1f75d5ca42ede19096c6cb0fd60e29a4f22e57e8a175bb343817dd2b84d188d916400a0bc56cc90ab4bc2416228bc4cd560c444ad8003257f8f768c1251b6a570141ff4d85d760249f86979e5f51389ab1f1ae40a2d6a255d2c004526da8cf9578dbd7cd64a4552e0770d1659de02e77c78eca171b432f14f2b1561e1250bd0ca4e39242b4d37cd76eed5149fceda254d05196e2bec15845d6f98a978d00763bc6b004ff793b663eed04b84fb22aa8c9e4d91d0f77aaca0a08842a7f59a38498f8c7f7de9c5d7b9dfc59c97ec50534eca76a50e7194e72051c7ed85e44ee95ff0d188d87a368cff7911d9b8da197de31b02295dea61775479dd19c5e1abd3bec57358b8fdb1958a2795f81cb7ca1e885bd50095cfd0a0358b4c496943ddaab803d0a66472fee064536ad25be3bf2b45309d27a1313283e6e35189bd275c5f64a4e8d70d801108665826819b1fcb8eb46d06fda9429e7b7e445db50870cba512b7f113d65b1b6e6d9f3b2f5a0369013a8181371a887318f9f5ac0b4f88db755e65effb5502ebff70e099f9da9375d9a13a05186c24c584903b07675160333663fc530f6044dc6c37956b30ecff06d8f8f39be90dc91bad386ed238a6178f866ff0cf2f9453e5389a712a118b2f8dafc17e3f2493901f89c740cb04bafcc7ef7e0e4e6afca747c2055dc8a75df372cd9f31a94d9e108b106fcd1cdb65fe02ad89963ccb8c0b0c25a6f58465295aa205c987f0134b3f6af5d530b54c80a7ccc81c07723c3a220dd221258d1738290d33aaba95507359bd70d09b707fca160ae22f36cb25dfe9311103b268dd23fee8d85f421b4ea19295833f3ceba18efd87917d04561b91d53f406adfc774a71b2f6cc5efa3123f9a99e90d6914806a66a42c4acc4f92f29af760c5861deb3eb8d811aab9ddfb6b8691004469e52106facf658239b7fe5f10aa4404fcc83f2187532da8513ae8959380d3e1b3cd57a281177473e3c5c190a17f6b743d603c2c8ea76bf2ffe19e32246da7e5a91110dac6349bc37949ab6c5e73fcc6e9a9b1936c0d4ce74509f02853a09bb0219bcffbdf00c58337b1d70212c73dae94945c97acb680ba2108f6b7db840cc1e2ddb52847326a18539b27dc8682975e7b74ad3032195a1998fae3cee494296913d6fec9957d41cbc3d813c2142258f5d33d951fa10ee61ed6f08515abb957b6159f6959cb6e1fc78c42df780d9bb265bbd2d55ce8146a4089adc03e1f9a3c3921869bac6fc217e72c08e72ed5918fc4244cadef6f6e3da4307f72d8f2f5323bb3434dba7afa6aaface18550391ef4cd4c17c54996f07e47ca3bafddb8dbbaf4f269ad48c53561e355048615f41bf68762ff8ae6adfe775bf6228e1ce7fbe2889ad8e78958dee55f51b9aaea6fb0bab4110e9b983c3ea78177b4761dbc2410dd19f60e6edfca30b1e5caeb92e7a58a0273c52c193b4c23d76739682f38df2383c377ccdfa5c5804a6b6ed6e823c2d6850832d9996085d98f58a9846b4b0f747f88cc96506fa13d1861ba983022d8fa6772772ac7d07411b42a5ad1cddfa466c78d896b7cc528a3df0b32acc84d45b9941a530ffe61c59cf5f64fd7e3e4b823a916bd45a91967d52be0a0a15d39bb56e13d31da24713338038b8ff249b6072dde97d11d1ea87deb5dbe01acdfa7f8d0311269ff99cd3558d09675b4aef1e9fea1e938825b5333ebbc9eb1a394613ae79dad843591edc92bb06dcd039e5b0550539d8e352aaee026ddf5ec474611bd083b305daab4a0b35dff73cb49acf4b8163692c0f15828408ed1b86aa6a5b526d03bd4e543c2115b12794f059f5062208b11148ecbeded6205f689f2607b59fdfb14b888b86c6a0e5cbf6f46926adbbbfb03d1618c8e3ac1cc052bfdddbbfd820b6edcab8f32ce817517f3e630cd7c7486e8e4d9bc503e78dad051fb8adf9b170ad7d974c3186a1a0d5529dcaa3610c287df5ca5e3c4feacdad1d8984514eb84cfb439d9174ad04d755f0a479e3792ba0e74009f5f7b697a75d29a97555ae0c4aaa1b49d2767f8f2c00b4b2cdd52841aad7398728140923ae2de98ed6ec3b719a4ae618ef22bb8a018515064004c3fe7ba588bb412a0257adff394e5ea2e5f7c982e73f3064065268dca9c7be12b5f39eb7e08ef728e92e0e04ad487cf12396e6947b0b038f887b70e2458fe1f46aa6acf0a168c73646b26a4bb79831db6547b4d0581a0588951696a62fbba83e73a212edb9c2c520d0d2409bdfccf276dd4646e0811135f4f7bebbf77b1f752c67d130d55f773432c99fe47680d3b79b3b38d8ee826be36d152bc99f9e27a13aed92165931f856e1826bcfa3d57a5779942fd1d6a48386633b032e81629ea47d97f5a199b5dc06e82be5a81546943d470f338ab165007c2b4a82c6e3d3bf98b147f50eb420e7929d5d07d9a180382147901fe7df5d635b52f87d1e3780b31fb2674407c15de748c6228a85802cbb53b82bfe09562623c604632e287396d6bf906ea624fcb5c7fb234e86cf8dd80765d095a0de650fbb80e76f41cb701e95d7be9bedeaa8eaefa99ed8ca5ba68fc0c92e099e643568277553d7464ba441a04916900b1cf7e92398b6cd142fc5e86ad8e73b8d2cd152d8828c0b3e22668eedc8f4f5656e750b08c207df265874719dae4fde26035e650a9524e27f2ce78eb399eb6fd70e5dd4831d33e449b1bef926bce1cc92ded2b56fb95cd82c5040728102682bcc1c6d815b57f70b12212e9b42a3ed69960c23a766bddca1448a3f6ed8184b00cc53ec6d544a9835d88bfba9198e27ead469be82c64f246f424e00b6920b4eb11c60dbff1d2f83fefcfc8b0855004e7dbceef470ffd4a9fa67018a8586171e57c3335ce71de440706d76a9dc5935bba886d396b92b7c5fe5c128fd9f35a1100b1ea3d85a7c48d63c68e0c0d101447baf4b99f812939378bc32a80defae47942669dcaaa8a26f073d576204a63085bb9047bd4177fd927b1b4a087157aba373ebccee9fdad051cd9330e3d6d2a18cd8839c11bd380191796b2393079077defb9e9ffea2cfe3c64014d38fe2fddec042e7fe3ca32b24093900a523587b4aac4fd9b4511adb60b99c4399e379c78eadbd014e0515b94cf75d7350089a13b4c6f6bfa153dad242ac7e9d645768ef0f03f20990f48d4adc50f1c430e814c3e6338673a51ae28b0125bc72f4d3f1a38528f3ff22b0c0b500248318fb9c3b1f25b0da5a4cd5ce0c02777baabbb6db4971c2a3b52f81213fa7551eb7102099c74e137e399725a5af28c8738b00104d4428ab7259c0b20d67c0fbb7ebdabd86cb1a085b13b44095bb7ed3779c3648eeb661bb9efe8a8e2c726e546d254f5478393b1d7c641a89008c216098c861b2b6b6aad75b1197659acbd49081f29e74ac0b14125792af1f20f58215146ceb450c8964dfca3c7d120547ce5ecc0999e3ae7d1f4d5580552d7443abcc8f086c5f6018b506986b5bf0a2fa91302b5f5c2207a63f2df821ea91fd1d1551037cd385bd476522c85b1c2ca345c38879469f2622094737240461656a1eea0301bb75f7411f1d361cd24ed06842be045e34b79f6bf598f37ad8f6750d743847bef7e36b4ed3ee33aa397c825f7722955874f27845b3821800026ceb9e6f21a5dc0bdc4d3fa5b82e758d17414c4a116ca9d1b0c12d5bfb9a86595c2bee1e371c6dd173dc12f442693fd1beb26509811193ae8ddcb00a3054fade849fb26ee5ad4112081b5ee9decb3154c3a14a27895a3a979e3aa185338467c8126d9656c4c68e9ef7e10b4f560d951c1ba07bf1f6268100d9d36725f203a3338a3ecd68da1e2cd97cfe1de7ff3394c665979eccca0c471eb96ebc7f121c765df127629736caf9b229d7f3aa90c5e9b7bf4b5ddbfb51856e9b684fb706681c92dd82a27e43d77afdaa7de957d4c72a3741825af6202a305413616a1b91016562897fe9ebda0f865248ff0138715e01d0a6294d4e61c07635265e6141ffb293a3df1d662439547055f9f5073d6e60fc8b9b6cd54cc5910097ac55c84a8d417aff0e456923709d8b584a5244e36eaa6c69997e2faade50859274a8040258256fcfb2356ee3444d32903664ca1cee02dc699a21a67fa07aa4671456260f96ca6ee30ee73ef4cdfa5859f77807b4b53712d91f6f646862b503116fe23e8fe3a218b71cd857e3d0109e9e424f6fe7dbd90a2a340a9b29b29257cabf29bebac39e44d2760f80c29a98fb20b715ddef32bc5b08b29beb13d3a5909306c5ee9b53c0f34d7db288b72645118e91d0b9fb7ad7eac4c35667b13e865d62153012ba06222c112bbbcbfd2b340002f46839734b78a178aee8d86f21d5296d79ce449a117de3a79130b6dc5f9d4e5fa6598bd306d217b83203c469b1c966dcc931e4bc1f6ba01a71eeb2c2837eaaa05a1cc087bb4802be427f4fa2eda3cdf058dfcb75716229f7dfec66e41d5551a7e63991be51676a79e09cf1d699311295a865c23bc88e0a3a878ac87782fe7397fa895c691","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
