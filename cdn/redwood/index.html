<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a058e106cf463aec18aac84708e56691b06705c905cab7e796014a989911a908733578c3dc20a29590bd744a3f75f8ba1cc6c1b4a615a86e0965bb3c5a4facd69df2d2f381b50fdbf2e555153aa67e8314e0fec491ac7cf970f38e508006ba96e4bd80185b26362c75a5732de4c024858c908604b5cb9db79568dc99377b3986baa01d84a769c8c96a775fdaebed2e98dd3dcb0a2b6bf1ce7e06ed57350971e032e0f91b0b734ca81edf1739c96c9a23231ba0146b45ddfb08b9cd95b74c881575959bd6e4553937f3f6e4453c8dac89f86636514899bdfe07a2f1913689879a397f24f53bbe43a9e64e791f862c12babf8074208f3ddca4a290fbddfced97c3bc273836bab242e095842230f4d6a653c9ffe1bd91e267e03b8937ea80ea42186958ff310ff977805ccd8aec0067a1fc8b6463228febd7f1ed7d97d5017d69d76e261466ccb02b8618d103dbc2e14d81936bfd07838194df1ed5e2ca125e9c7f492b38bebaeb5beeb9c58035392d97b14f366f94a01bfb1af8dd614d26a9ccc6e11e58c8cbc6c01cd73413080464114d55b38388adc160939b9c3205b7e9820e9d106b2382b3b32963ea5e51ecfd880da5b3a5d61d0ccb4207de582293645682960509528a7b377c8dc2bcea3b558ffb2721c70e1db7f5ef154d4be07475c641ca00cadc4aaf5cc1a4895890b74d5eca4d2196784152558cf5a5ff70849d1c50155e30427c0d2b27b0e7358c81a6c3d99baf05676f2fa58f6dcb5ac81d15f5de2944d1e9826df0ad079d78a65d9cd0d5dc91ed7aebec9dcdce9fcd18eb6134b01b7577bcbfa7b03a53ac1a4bd661dfe69eab82b3a8bba8042043f400d6023c79aefe7628085cb3f6c429f6b521c7eefcd924f324fc9c9429302c7e0379f6f404ec6716d40b1cbd1b1d28f162eb8efcd67192e8b71bf5daebb8dbc3e4314bad6d7e2f33cf216f4b9304fdbe1d406744017ad77d5016358a18c2f12ef7f64e4c684f242251b4ec174da9bb9673589e46d1788f51e57621b1336d7e09c0cb0edfec9611ada0ff7ab10138ea645d0f82b09a4b30265db4a938ef3be3eb658291592c758d8b66528d24e74197c25fe8ea5fbad2fe1d049020197bbf0c7b4f76b7aa6bf3ea5a1398c7133b6a00916cdd4c07e5c912994862d092aed0ba09dabd46002e40f3b6b7b085f02eedf13f4b4e865d663d8c73c3eed5f4b2b7d33c30e84b0a756b697ecf5f39f237db08dc59b929d7346a8a6c84dd3758f62c23ac80b3119621379c1c93732f21b6d3fa86ab39e0350f3849b30346cfa8b35336372b520109cc8607291d689c71f6a4d90acdefda4373842ea0597fdc5c247fe22716d51c593738a6350bfb1d6a7ff7a07c75e26ece8d6b1480df90a7af47bde0d48a11f89680e486ce0623f5b9043b80c08e23e7fa46a222370e7f890b13aa4742915f350be7718b2607f9f1eba95b440b41793343f96de4faad121891b5282694e26e3c6b486d09aff2d04d8c38da0c7ebf14923fddf43925e286c73efec8cb3c29be3d899bd0ec493bf7d506fb986d0ccb8ca41915d2f52d23346594a532f8f5f621b7aa0ff2aa938a2e3a9e67199e7533223dc3138b923e151588c3312ac2a6ab87c9522a3fd9e3ca7084c1d6d087cd12eb8991974770f1fccfd3f165ab24f8a3909f1544fc5cca624121721b5546322d2b4f094c1502addd1b5f02df6fef2c5662175ea842cc2fdbeebfafc85a3b00f7aeaff9b83ed3339bb30dc525dfa18bcc8c6887629e828581d0ae45e8166aac1da5f250f3d0dd940157cfb0fa1742f5ef486f3696ae2a4f7079f6134e2cb3c0aae098f2e248564b4537705e331ce6663096ade1aad8df4b34d135566765d121a48fa8ab1ed9eb731d92787331eae1695e0800e34dd95b3efe1a9ca8248510519e86b81a3c04ccdca992f1c24aa7cd581fb8b0a86538ceb3d148b1ba82823e2c2ef58149a7ae06368caac4e9bd96cac34cddf2abfb55ea425f802ce5c0b65d7422f096f5b480c7f87aff9767d6b76562947c9a0db613e1adc98f4318ee69a9cde7a3c84de93e9924253451758eb3b437e5cfa588a1aea2a8feb6b6a04222e48587d70d643ce71a21dde22db924757d863eaa181cc9f12afb4bda749fe77fde482fabef0b8cd348a0733514e2187b5f13cad7895ff490f0026b095881fde9da8ffe108ec1855572b8ec2aefd3994c5c0a5fa9f4272f7bff2a478085fb3c7bf44390438740c44ede5ecb44bf56cdc9b5b9eef99229476326e7fcf8e53b54bb82223f8d1e01bb69be7ca195ca4cc406e448b70fed17992b0ac9a13fa7f533ffba37564a20420fac6daba206c76ecf9c2a28b6db8e7b939494714e755f6fc02acb4f944ad0f24d90190fd65ba5b7d4bf01dfc60d85f2b67292930a910774901a056de8b3d7fedc371377212aa4fb07eefdddb2f041707ac204faa7bbbdcbed6e5b420282e1aedf557809e94c8359e9e620c9631448db14e114aa2a92223e4dc8600725c2ab1edde037ee92b70f27f6e76c3f160eaaf388940bd5c781ce5ea8a7070607876955e2c4de29cce8e08b242ab28bdb30465c6aff0234a1fdbc889dd8ae5a713597bb8ddd74a5cd6f977c7e7f72258cc337e783b79a60a88949cec33d05570c4db8b04df69990bb56ece4161cf9de932a4d44dacd9ab3f2484d2571961104d3f7dff4b8d45cdd83875e18383bfff5d0e56f51c6761cac7966ba17b19784a1c8f903d40d503dea84aef8c296c634cb16c050f00c6e994261c3dbbceae54560938ee88d35b0993923c163469b3b86b912151c19a83777b0f7e20b406442c70426254d579d59fc1353c054dbfc073cc680e15a54eb4e886048096450114286ed775f00ba4ab0062a2d42e781bc8e600f779bfd1a8bc17a41882ee9653ef6c5b18b816e54be4b6715b1c30e978d14be5b402de875e68029b47e7360f5b69700cf617c6648b6a62462ef18c56f1f62a72bd9448cfcf41809988643c605200a06cb10ebaa6252b9358b2be465ef9d6ca8bfe6107d6cb5047fd521bb4fbecc8710aeddf7bdf126c6493e172c4358bfea95a44ef697d99f4b1596a6478a6ccf8c1d54beb6b7b6591d42859cc3de2a66005049ef6abd2fee47582f07013a52f2d17af41fdd6544cefa9a42a9cfb8c7b8203e07a5bb1a25336521cd0a440d7a601cac363b9d8ee47a6ae032f4c16ad87ed3cba75997abf7d18c9f3908e29120c0ed5e207bc30264aeffcac8036e1ad9532e5fa7fcfd32a7dd2052319d2dc17bc40a41d3b85c345afffc21a7c3013c3d72d41df3e0da0f3724666314676fe0d77e5b4fcb49d55c74b2337b281454906b99c3c928f3cb6c68e1e427210ab666dd03a6872c8ceecfc19c9568e6c535ffe3b60047698e529a4bc79189d900c2c00d4c18479cdcbb34ee57f6e7739e8b7925c0e31c3d4863327c7d691bc6d8cc387484c7138c7fbb41ed9ac43713bc5ceb2daed1b29bdfb778219717b24c0f05813a365e4c8199d36e42d0d5e67d5e492e43bb648a03e8892d8892f4176e06d67b1ea49be6d65318d7274f64c728eb0d695c91a9636b4182e3aa5b073b9ad803d1bc46aa432eeb4836b2cbe1fe060f9a75ff08c0f0190f4e2fa3a8df2dbda1b2f1c15fc423913ef9ab3c387dad9e682e7bfb7258c432e19e100b52255249c9e7c6d867b4e55cf24ed44f70b7dc7c2eee16f798d51e04ef27e13ff88a0cbf693df07995864e25a04fe3ad82b4d6f52e87383c0d9d2d320a964de3f00479d3b199ac274b85fdd8aebf468a78f4930c5491a4a46fe6fb88b85576fe17f3e17769062c9eafc95077f06dca499df2ff336ad6f11b850f64505a92fb38f708248a9dcb7675c69a0dfaa9a89597931095b8cc2d4582080422950c162be8b7c7053951250f1467b35670464c3ad7f87d6177fda41d8a774779ab712192ab28b200da7e809fd44aad02b0d2ab5d5495d86c6f7747d04342cd84ccb17474973bd424975a06cac89277d9ba328e247fad92616aaf70ff75409c4608a24fd887ad98c51e9ef998fca202eb98f57a71063d3182ced9fa303f93091c527d09dc6e07f0c771c3264b4ea7737dcfeeec911d0fefcffb66a73315108f13a36c0a5975cefe12c8bf8cf659fbf0c14b258a2148d99050df4cf7d221f6dd23a08f9db961bafea082a69d642c27fcb3fe450239ce1b32b0c1b4f69ac573fad1d274804ce8ac69c16a8e31acb5c7c5c008a36648eb8ae5aa38b0ae2fe1c4efeb1907e8de5eca6ac0104403cbe1a90e1e6badb7869150b2c5bbf95317a13fd639a2225eddb458946fd3444eec9e62da51534b7114582e8da177f07bace5b1fcbfc1ad42e366f7fc58c0d712f514269a2b992c00f5768a77081d7a67a2281b5e93187272e99bcef74c862ee9de02aea24ff4408f62de515a524fb42e2f18996305b6749b12d5b8b297b6624248336d24b63f52057af457aa5090845bb2280fd7c27db7d4c4d75b6b817590d3c39324fa4da659d2bce68bff33d088e0530f0fbad9e287f02e30febf4ac6f8f69ca07888512b7ba2ad9535ebb7d3fb45f65275f17a4d8a2fcfdd4b5de2d5a1ce889de649a555e93cffe540eae5c1b654ff36a0306239ad096032d84dee080585757b83072cf720dd681be22b340c5e757341847b253deac5876c555a0a5816a71fa785e224089b0440ff41340c1809c88a9dbb2e9e22ddb1986f789fbc5943021e4b4cc54e20bcd4ee7c368f7943b60324132ed678fa4f369a872140ccef20e6e763f648dc2fb6209ee17ac4b8f63c91e9a48dc1e574b6af8e04f3668b01bf80b19a74e74b8ffa02e0fcf78a1e334c4899ac6fefe81e83b7bd8f5f9299c4cf19f65f3002bfa8c417fc7adb713dee6622457a374ae96a834e2ffd3b40abaa9eaa9f4e78534249b203d2ebeb1382a02325cd12e79cdd7151ad9bc9e1cb980099a456fab80225c96ed9429e834ed18cc6dda1462ec2aa9679107eebc935d0a3f250b0d53a032abc64d295e90cdd45c29d7cadfb4ac2efe976a7d363dce28ed8b8b4c628fbe1bb78c9f8c4873aedcd59a60e8d179f318a82e5ba73b00e2d4b436b687189a8cbced4cb7e938eff262e80fdda955d571d025fb2bef5da1d4a8cbaa4cdb3618e90245f5f0be1d7152ebf4d344f2ba1875448b2ffdc14cf2207b8567a506b71f4406ba1b501a90cda1a0c433de534b1cf19848938f3bf083b04f1ceebfc144c2ea61b4e046cd9580586a9f8a7532d7e95c257cd5658ac701718cbed3c8b87df20f94e5832c094173299155e65c7f24f186f6f57e9f9cc63f0d0fb4a1f7eafe605caa2c291e2585b9c110329fa6c8107bd0e2b1467a47ddf4a68ed5a27f6b6a9317ddedebc9f69fc1a94aae5dedc993d01034b943f75c1872f923a28a979bbd2ab1fee46ca7092a40c620ec0cea255c575bcb33ba8bd8386899ce41dbc9d780def6a16b484ccfd1e2dbe4e19a65de2a86b57c05a67f89f183943085f570f29961b364d313d398609ed479c5bf7078c5c80849b5c5f161a3166026f583dadfd47f1805af963ba15883652dbb936fdec8d89e1f2e682491816dfe9ae0df413463119d7bf3e5c3e8fda546d8d6836c92a97c85d3224edd40ceda29c1dda544442faab7b94c9ed733ab7c617fbc5080e6103802dc6d1c6f57b7035377b6c23dcbf06d804a682b95ccdf5db83c6887929434b55f07e3ea7668fe9acc4a43fc77425d7975ac5b8a9265e9a1cf785ea883ce9372d1e03db97a5129ce228465ff98ab4bc26d912e39175d72202be37f42201e38b7fd3b7b462d5c7df01a91a9d337ed6a3574f10614df748783ea647f263afc512970d3bdac22dbac4bb5375b71162631816f7967f0be50a3ade2d28a8c240dee69c807192e9e33594c2324c89d7afa6ead7fb4ffe02de9f53b3afee494d9af79f37178df078286b457f86a404bc37dc60ce4433bc9ce29d3fad3f7d42d2b1088f9af7ea8750d6545a188264c13490094cb7dd75d8169b097b16ef2558e25f6a27793546e60ed9e69e8ef56d46931d53b727bc53630d03bcc917e1064851e8831f48088d5fa421841c673205af9d43c69299c876f7a8b5961b7d1f4eebfe162ed8a19b8b6d2ee8bf45b029900031062f001b619a527f024969629aebfb9266703cc2061d666c094d2f681d05c30661b636acffe61dd3feea5685d5643fb077c9ef62982df57f3224a76749d4e268d00f4310a679857c4580aacec46ed7e2ce5f0cee946f7d8f7c67636ff6d204af8a92fe827d0721bc9c414dca99605206c71fa7a177e818ee6fe16a4e4abb879193488daaae8534ae3f2eb646fff135c63cb54ada6677aac41fc1931383a39be33defe5a83ab8911b2abbc792b1fbf697e91fd9868c1984d8f7fdeb4f1473248cbf29aaa49cabdfbf31213bc2931df6ba76d8070b2627b7be7f568978f7ad88d4642c7ed001d9887c77d24f8e3dae2bb27e0cf17134597ef2a803e24713a24a0090ee9c47815061f942c2690051488d95a036e233668510f39193b11a27c2ce83e9884636f9f39a0885d691dded9cc835d7c3150cc94da5670572b30d3e1906a96cf8e349703e8b7cf55e2b099bcbb0ace6782ebb8ff612090b2f9041df2c36abc9ec17f176beeba574c10d89b62c675ea338089114baa449ef7ce2d8802ab69f5f46cd21891c42d0fe94c45f8a35dcf4c74af7f2c8b0888ffe310cbe61d4722ffdc6648a8114c5bf8ae7d043bcfffaeb40e3ac7944b1ebe209ee9f87d32414bed84eb0dbe9dc8dc8a01951a91df4958ca69feda108df31d011881c04f04c7643028750590a4ea04d51f55b4741549066ae099d60dadd5dc15925107f3fa13524617b033166478f10f67379255f70e45e4d50d9b7f60e88d477d2c12ff93b784394bd287e6562690446d80ee378340ca8a8705924ea201a3a942c4ce6b2653de9fd2305dad268de937daf150f5968940eba237b9f50709f607522d3e7ef1130460757c155ff5e665cf493059d01948c631bbecd750c301cc19ecac3ad05afd59ac20274ea880236135b2734e7cc60db8fd3cb9f893d55d37d7a7ed896f6eb329bbfaf7f3283b181ad6b94880241ab92bae3a620a4c69319a328afffd965c9cc882f0c8e5a6ff65bbaa4cde7ca229cb9005d3dc9724b485de4553f5c982d57976a1bc61065639e9449d995ea917b62787c6385a0dc1a10cf12d9e0b7859fe3e3bb792f18135e592722b97cdbfb2c26cbbb4b30ba6d0e15ed89ed1848b5c25409541403590703f8fadd3a65d3eff15cc54ad9864933065dbb3b1fa20ae5d1e1aef0188c0ecc8271858a0f3be8f4e747f7072bc2e686a34d69de0fe87164acabfea74c8b6051206dc330d50776b100521fa1b9b416e879f8a495534d351dedfed8fcbb4f09249088bd8fe608152ead32633e55166a3670fa655f8dd52c0d033143c3f52bc10f560256567d51d1df5efd74a31940c2bbb849911f26dbc896b03e635ab4b978fd66e830f5d3254921e738d8f301940eed7ad9ed67faf12f88526e4313e420632a02e5721bb0373f0ab2c3df85c843a0277981e395b735aca19e56e4fc5dbee5f76441a2d4cbf67d0cdba00ac14d7dfae97cf2a007f98b0a8068dc68d51e633369ef00b2895c23e5e406f25798d25559ff72e5f89963d768262bcb3620a8e05f419a09cfb85c0661aa4cc4fa690849149b53f5a756943b0a7e4cf74baa5d6bbadb17e00ee999963b69ac249e82d40314ec795d7b5921511c15866756a2ac494ce68744c8af55d7792e3534ccc196a0658358c998005fa2910c6ae12eee6a8e1fa3785a623e1d5380ff72e5e835ac9a7211ee973d89dd97901722db97857fe2c72dffac9ae70e76fad502d85a78ef3dd95cc76c858cdea7e7de5ac3e532d00d4d066f3e923c7fd3a495638d31ea61ec33b7790aeca45e33a001d2e326b9602d31a13ad333146a367b7b66290a87ebb92dc5187b01143112f35eabc2ae1809bb6583c4d83efa7724e141d3214d940913b4f258c0461d90d0948ce2db6e12a2929b679656a3e100c45a4196b482b0bc7bbf3ebf8fd105c610614d0725996a158132ed3f56a87347083953620125609fea3475da0aaad5a1ea8a4df66987b9b2c6ef0e07f9b2e30faa01b128d69dbff503940c6286f440c95d7822b254e90c959e2eb7550a95bf478d3f376f7cb4a70857a10466cbca19100b110f3d542dd1f01d18b8e902f165e566937e656c75498430ede7399cf5cd3a9613af1f996f54f4911cda04b0bfe119b342e11b90b9626d0ce44a5e930555ce58049e1383bcb33b2c290c494c950cda7b57ab6dac82250dad7142218ebaad6c2a3d7ba2f8d8af963b5cf6a487d62cc8ac401edbc2a224358f1a31e98e7dd784e81c05d6929557e3ba20cea7f13b9ea1c8797c46d67ebe3db0747138b63ef615f88de607c4f993a5c544b27ae85abb83432aab87f0d88d265cf0800712643e9cbaef847d4e5d4394d007b457f76d4f5ae2af7c9e6e566d6c1c4cbc6767338b0424352c09a802b974d2eb57489e349bb57efc65650d5fdd6d338c93ac6f49563f52ddc8c56d80510507acd1b2bc3bcf4f33b91ddeb5c6081af248d75aa329fea6cd4c8a36bb78194695055b7a4cad5ba9d6e9a7c6f90ffa2453ddf0a7d4d8cc105b2b0c63a3d6d95db853181b554c8ca3318d86111585c54a330104bd3637cb212f97f0e00425371d073d53e0ab85610ac7978b91b0d89b84963d311bc5e1e9f3b0964b9f5dc0843226f2696dc3844f10de9160a8dd94b5e8450153061fd916acb7f423eed81b4b48297c1c228e61d4b70b0c16a4e06d8f637d562bf8d0268715969c48a4aa116550f8269f29992dc221be1988c97774514fbddd7b8ca3bf259d75874d1c2c6746c3c33238bc5159d09bb6e757e24c626147f8a1612dfdada7c04ad6c6eed045312a97dfdec0ccfbf644d2893edeb2a3bc588ae75e386b2da8a49c912a49b0e70bb9c3ff96772bf39b28e5d9f130e8409e1a296d3b814e1067afee3dfec5df506879cfcd73e0c546c4cd62233067fb241d400d7a0315b42864775dd4e82d8aa33d8230a2a80fea7cd34fcf77663599a17209a0555253dff11caf9f8518066f253b680c85962c767bb8c68184e6b48fb4c49dcb6a9c9d542d81aba533fdb1160682081c1ab69be4d39b54765eea5a339ca8cafddd5be183b6244cd7ea45fcf76493ae2db7bb2d31d5131ec818c99ead70d55b0c9382795053efbc32377c86c6064ca26145c6b9644cd68d5e2d1448504f981bae79b35894d53ba0892fa2fa33ac3e2677feb54bedff8cc245479a512aeb2ca8cdb57bbbb6af9d5252390be5a27a352c0d2636c0d3a95e66a043686916e1a7948ce88494656ab876686588d97df7c998ca03d5b06a68031e3493b17d584ec64ecababd67336756974061c29a667dd86519b9675a54c5be9c5592d438ca9b1b5de3ffea781f3963cbf9e3db5bc072c6fd3187820430b051b5b2526a8b8342ddfa324d7a2cddebbd1df4a163cc6e09011ecf3489c8d28578a6a07e5a2ba176adfb9ed5546e3bfc3581fee9d6186254c2c459f86d0457598b44b9a602fc6f593fec85896ed751521f625dc96b822f3a7442dee0c4ad91df8c8155cf49ae9ad78ddb5d54a67a6e0e1b5694b8ddd8828e431544ee9d1768b49a58b8b82555a4683aa5eef900dbc0738a6fb5e66ec7594e7d259870edf9a832d58e8c9bc925a67df68f87aeb7f73da05117ad4b8d10e7985249c585de3d165d9786bfb0c634848b7e4148cdf373e359237fa5ae94802ec0dd427edeb75784d8c17fc509f9c7eee7c994b1197d6fc2e1ffd023e45342e75c502ce81f37b67b65294d9e2b7c3c1a98a2f3017125dca61fa022f2674ca69ce845e11042c418b27bb5cb1e42e3a0b079ca02eaa4890fa950488a23a5dbce36a145ff5981b63feb68713a65bc8bf394346167dea6349980e48dd8615ea3217863ed1085a04d8943fcba41bce67e3aad89b2dc6398d336dc430c1081ab7e9add99ff46147760809bfb333d8dd38d7bcbdd123d0ce68f93cd8d67e67a7d81766de37b7728a3d73066f2eb7925eee49e156e15a1a190fb24e6e1cfee3aa9d05962913c1eeff13a4dab1317ab0e991457bf5c7a866db3846974d9d5d9fac80361989e8fe6278e77ab878eedf67989b1b46cd6b8c0d846a419010355fc4d05c27e0170e1e849a1f5ac7a7fcc3d61ec4de2e2ba16b17a64eb0b713eb6742dbb1c2ede426b989b1353aaea7e65199368a6eefebaa6d3015ea79ee1c2b1df1f25e1518252a615f532d2b201c2367c52c144aa65302f97e311ae6e033404737bdeccd3424a099b40eff13d7228cebeb64b98319d8a26123d3f19dc4f1ec74598b79b7b96f3adc64aeee5571df23da575efe0ac7b9361df494cc9597d4259539ac64a2adaea78a1f876917d12eee01258f075a1a4b046c441faa0e190291cf9b1172b83a1b4d8b8fb19e031d4c0d34f62d61bb75f9b844d9e65cd65a45474b7a54f890ccd4a694daa982f8928fbc5dfd70aa0473d4d4ffe84e4859a245e0288dedaf7e3888eab6ce0f28587039fa9458117cf1a945375d3a5b6db39113bbb0c56481063885d2e82b7972b4780adcd1a4c07791500f3e3095439470d187a6c6c9642fb88808f901d10132913702d36ad5d5ee915167e621465ade112f8cd91ab4ad87d96e630ed5fde57b61f0bf255333fe5d3cf37aa835346688b48c13197f741c1780440557de7675138773ce539fd94b2f693467cd7b85bf607ebf8cbf581454f062aad04e04bf545c995ebdd3d09cbd874a348a45f598d4304220ac4b468006c2cbe3683f1f133515fb86bc2a8701b895e7c9e8360a2e2e3b24245ff01833a05a3e1058592195bc016604ca59b2eeabfbee6d6e1ae7eec86a2760430ee8b1d4b11007cb3098c9fce06ab360b8b147a8ddf77caefee87090ecdbcbb31504ef08807988b4f5de487eb30a7a467df5bc8072d30fd91fdc86b4c037f4c9c31968120d1ea1f2e39ce35a2ab3c482f5528bcac2a24b8dcc2870a34353c1745bcd2ea490673c6fb6f977478426c75680bda04aba875066f04a9f8de33d183cbcfb4dc1ed21f9909a85659702ecbf0da3b9677427167ebb204133f076611d0adf601e6b5d96705a66c7e9c2b9cf3d89c31eef042020584f856f8414b8e2ac8625a7bef773f72d2c176d00e88ef1138d9077275514f43aee99e96957e743da074db6ed538c47bdb180a33e0ddaa4e4eb271ff193661256009cd8264a2701049c79edb993e646fe0dc26a29db6c661726e628cc01fef19910fbb37db30b82556ef6fbab4d0afcd54d99fc7a438474354d1b1d1cca32a64753a5091ff022eda086cc4b437d9d017f2745ae0f1e321c71e5eb3635e95e09275ec1f87f6f9e302dd100481a099ab748e5424b1099ce616f48288d8bc94a99a22207e459db2cf0b3574d3f7bfabc1b78ad006ad6e7df258523bff1e9b215ac907cbd24d22bbb3bdd6399ccbf7cea83351f8be87db882735e02543255662a90d57735c3ae08476d94740d2a001b5ce17a6954ac26b55bbaf1d209e181056b3c4c733d33be60cc7302fd42228aae0d3f8b770a2a63b0989136ab01e5af7c201724c829a58c9771e9611311db3c5e802802517a40a5e52014b8f8bb2e5272ceaf681272c2149320c6734fc51979db48f130553ec35dc7ee42d4f7fd62eadfba3801ebbe7cfa42fca00f51c73399e46f6ac43e79ef9762f4da742b2c4916ade746b4db5fe8ca9c0beb50bfc0f50c75e27de92b989f74f5e22cc8da9b2ee3715a5000057fe74dba323694b7f58adda9923cdb53b1e3dc0b63eabb288ab412b161c302914d06be55e153b06e8bfe94e55a00d34c06ecb1a9cea92902be1a88e2ca7366d249b3afe21337398e3b4fc0a232a5c61cfaf459a873641f7cdb2698606aeba0f7c60f365d3ee69a02285500a6b516bbf2bf98074c809932738c64c961298805d7793e91f3a9146c0fa950a3a4689b755c99e6dabc57593e2b47375fcb2fe0a6acfb25ce258a544c2e2b0ffbd2dd4151027a8990adbc30170f651f44755aa3bbd2efa550d42c720a64531799f744996ac84cf4f0dc2b009a5c79eda76f1e8d7c8903352492aa6de94a915ed28813fed108e8f5fea28acaba1078b87095f18923c6299a968d41455a266084a02dc4fd47c1fb47c7f46ee265c7f517cd6cfef3137cf56be90e78feaa597c7f332b53b011a2334dfbd524b8233182fe449b22e27bfd40d541f124f29c9bf3adcfefb89f7ffaf95ba988240380fc197354f46b190e9ccb7466f4b17b6c90d2d992c57d6065670c3e594e80079b69eb1cec877a40b3d6cd05e98c9df072f84f0f9cdde4c7464451f03b9e4f59ffc754a6c0744ef91224028beff99ce2f1abce6efa6b2e87bccea3f6130764bb1fb8a9fb222f1736c9c2c1cfef4eefe849281903607d200ca4c77ca3042111835a172402ef242c7d97ccde103e06a6d94172824ec00d26e571478ce8c1d1d9b396b3cc41d633f1ad2b77074d486d01a02dc38dcf071e1117e71e7495da33871e6d128ec1c398dd630347f017103c9dc6e6dfecb42a0c9525956d21ba41a082e09865abfd8e4e349313456b2051a466a640894edf6db702577b5672780355168a0879d9a94ebd84c8770fa835b336e4a97974f1ad486b89189a99d00016707aa4e185efb414933dcee3093826a6ec1ec44f9d56ee6196564a8501624abac6d0345d9f08cac1faf46a9c66b5e007362680669266e4a7079c74b24da9ed83acfec2c68779113cda1fcb7df765678f0272e4c9aeb43ba4642c49c87b3f17abd2e05f08feed31c55f650995d94d68b29b2cb9083b36e0e9bb8228eccebbac772c1360baa26a5520f1d6d3e0259ca6fcf2720442d56a1b615b031116dfd9c6579f58bbbe3a304113df4a3ceced61c90ef6f46c162a3a77267d2a0def346ca913dfd29efd56b282f83ce4332f03789c3327e4d8b81e7b35c0bd841f412de06635f542de033fec51ff2f4a797bac83c91c52fe51cd899bffab60412940540b05ed728e5e1b3d114592e10e7f01e467efd49dfdbc6a7b984dd87ede808a229f85b616e8847acd9d4c3367badf81b99f38b4f0675e1afb23769e129b7441ca72255969359154e1196842349acc954115ba219ccc2911c241f1b80c42600eac995091a0d44d5c7d43ba24a94c73f6c40fb4ec3c7e50bfe87698eb0a0710c92577b5b9a57fc3944ef48a4c9e236e686f636150741c975158092c562c1abd0e9987d789ffef05ec389c0868306c3720819a830cb9591fa21fc98e36b2407573ead27a2a5e794dfff8ba566bfea8dbbe0b15ffe44483c1dd3b87e0f318775a8a5bf4123425d8d09f49d7523404e424ef0aada826687647e7eed4b7673461e69dd4f61a591214a5524665483239f544b794e2f8cfc1823b60badbd96acae3ec64ee40ee187a308ae60ffa50b5591b5e74a574cacdb7b717b4ea79323ee83dd05e1e2af4cad37e50b645607799f8d5324034e9bd6081690cf3d23f017802090c66857708e14dfbc344f1dfa87768f3491a912997e98878cde85db9cb025d4f759dc6b6b676f4fea26606f9cfcc8137e145cf9a6639a6834f10470584deb124585a09fb1600a90be253b4fd6e43bff35c4db9213e288d3ad29d153d775318b25f99d6b1608895d366734fb85d6a85755db89c265b63fb5066bf0d4647b0111868f38d1ec1908c76c78875d3dbc83f661bec61350378cc5ce48f62c4652a7c02df6de38f26ea6405d9ac454590a220ccf24dabf50f9cdba9e8ac30ca2c97a816ee358515cc59afb8662816a8fa755f453ba80b5498d18d00cd3a32d10136ae12f74d30d0df24b7a2e79897ed1fa251478a43411d809fa19deafa321b0c55cc57f5bc4f59bc0d98f22c0abe29850512dd0f053729ced9fd02316fcbb187dd96db275181f26d69dd1c4f1e3bf307e4fb37f08fe5ff8ac349e6137e2ef229c54f37e37ce6ee2210d424c0b836770c68a7f4965a54c013d05e6a1a52a98e0759a53b08f0bab651b0b598684709cab7199e09aa287a70c250f19a6362a5286ce3f47bbea415caf094e8c3d8e112f31f35ed7f6e81f653de94f869d13504a252b0c658665d5812948b08bf77365ae72ef64eba1f69cf191f09a441b6d37a5f7631fd909d6dbdd44d61f38b6c09a74681957157d7642ea9dcb98e75c34ead9372135723fe9595e09525882d60bc98ddcb361fc74a87268038179675a76cf232fa2238f168065db2c2109879d77491c3d197421303bbc41dd65e8fb1a88ef813fa1c9bd1a2c6f94ea613b30c190e15309a8d1e1f151ba1bc7bd91502ce30ec61ce802d859c7c1d14a342ae4564f21790b7829e694f49996e823762ac39933ec2c505b3e9d660cc66d8145412a26f6a8425d9624559e18720ec624eeb4dd966f7326a52f572b789490e18f47041c70043a3c6b80b801ad86c9b536fb68be1349b7e5f949c96f12cd3e2d4d94c9d4dfbb6b3f789929a22668c9a8ddc0419588073813e0b1c6e80abef81655d66d5872464da78174c3efc59f9757ca45a019880bc06db4db95fdf20ddf00a4a75090a4ad35a0c8d45fdea786f9dc59553beb5a3cb3f2e3eb1cec7ea8507d89ca639be7b2d014c20c36ee98269549628c2c9d50191be8dbf2c2993465e7ee80ca14cd28e73847e953e56110851e3148e7e4fd8925ab2cf3bd5fb1d9c4c83aaf0ea42e772584ccda78aebcb8a07d864e04d82b3f776e5d7ab8dc47aaba4d268217969268449fd52617afa7bd62ce687bbea8d88ac2038fb3e32cf6beefabc257da2e322f35292e0daa49348bb6c9243c58a4ff486063408337bd9377ac41f54f35214c78aa79fb7b7d83610a1c844597bd2f4565fcb26c8a1f783352fb8342848dc2972938fca25fc5551bd37f9c7240136ba48a2c31b2c774452518bf4759e35873c6113eeef56a9c817bbea268664b95a6be56aa4f1cb6eb070fb94165d44f3c2d8bbcd3287196b19e289f89ae3a92e22a5ee0ae25bf0af62cf8fafa11f69f909691762ca9079b3d9070952b5dc26f5bf36bc9e591fac400f083ab4c89049c962c568a41261dfd2a936800d3952594e554671cda38fa6216513550ee6288962216c01072412c981a5131371fb1cc0f4c1f1d1535cb001975021186b775239abe4ad9f9b7763974eb3dc129c1d8c10537d9dc3af5d522245fd5e05e4d21245af6a911ba68ee90a4c2a0f4e3661904faac45300768437ad9407dc664e8fd11546ab983bbab8d3c77a2775f39bd8c6dca777bc6d77525d09f68c034e637688cd64f483c13e98d646ac54f7810717e64a0bf246a90e96131895f9f0ace6c04d92788aa9887a98b572ef25bd96d989f4ef25ed6d298ed14e6edd225a2fadae72e64281a6389237f3b9dfed4d72b2f939dd4a4bb739409b1f8294643014475d3985d1d9ea449638ee5d0e8612f7ee5727bb77cf45c1f9f6b36a371a5813954dc6831fa56da1a6bd1188e183b517d8667a9e5b1f4d48d3b81cfaa16f59c3fb1cc9d696c0eb4d441640e56874f89ce5e70a0aa86d6e6e0d940c08d00fa7f2cb48e0a9176ef5fcc313da5ce4d843816f48fc82c176458814b4c1394c11aa968ca1f729f5f500c5272be289ee35ea270938ed5458e0246520502aec3db970a8d6edac050938ecb650b017ca6472e142d0424ce6c3b41f410125fd4c0fe8ec64116350f219c137cd575f0321058865e3de9440dc19b71d6acd6f1b1d0594ff750b8cf4ec4827a863c4c6d68b0f8c2b5e161cfecc8119a07a04b926c0b9152b3318e50692f36f19bb995076c1c54f4f18c522483ad5382b3f7a8d430f0cbd982a6f3c4876d3f3d79a02c71ea7fc3884bf443ff4a63d585a8d23c0bc83a43d9ba8d3f4ab28313b6dd3ce0ff55957384705e6c500c51bee1ec157fca66bed56eaf793c94388212829eba86a31cb33c759d3e8193506ef26a06f0f0179f041a682552abc885697fbe30b7dea716bbb960d590aa189b71754cbe994a7a10a098893fee6aa4cdd8fa757d472e3dae6a70ac73581fad7ef07523d835130572de37f8abf47d574374ec39aaddb43bf4b131a4918873fe80b15102bce83d39a61ef023be61bffbcec78a6171d102c3db373c1828c0864cc8e97a9062ab65902946a7849dd64e31d30c570c30471152e00b2a14b4576c051e9a89cc95409ad72d84db27390be16c6ceae4269e24644b793a264a58429522bc66e595877de51bdc94a04b7849f35d53034fa0eaebba1261869957fbd2247789e8ef9f4a1f31a7d7eed05e33cade23f254a5a7f3731aa51138dd0e5f270a45ac816dec1232e4dbe6c3ae1438596175abfd34ca9916e1ffec6dd7653418b3dd84bb2ca9ba42895e4001a82557d44f5cc812d4c480a1cbfcc21281d0090d3041bed9cdf69ac6fe44b06d6bff8f56613f534ef1c995e1a3673a2d78e461f311bd6da275a381c7a081856a7dacc56440951b25a75620137f241ccb60944e782e09f7a6db25f0e849f37ee4a39859b6955a6ffc67ec52ec878cb0100e42d08acd449e362411b9e7842728318b98a0e58199c1a237968c939c95c50cb8259ddf8fca603ca71c1aae218427944dad8498ccbddf8a37483fd08b48c409107311c4177d1f3b1e96dbd1e5024c952697549e6ca5695a0fb7d9268efcb546f9b0b7cdcfdb55be6c7417ddfd1708a7ad1da9b7d20d30b067d14a370d2c77fe928d71d6c932b54ba0caa9aeb9547efe9bb293a2029a6e41f44f187d85e4f1b333f4da0d003dd307820a0220fa521233fd447c812d5632a645139e3883dbfc82ca6e288bcb154b9f44ffdb0a861ba5808d77bca7602c40db0be4f4269488f6ce2be15d68ca11591a190e1b95a2771157e7ece1b84f448ead9d2dd250ae97d908ac1af087656dfdf678f3c2e3867d966ded2f72f313f89ca236eed4220067ab5b78e76438c8b3179976eba74447a45f60a1bef4486da7ba3b3852938ad81183d14b76bd434eac062f63928fa274fbc67b96f7052cab6e922fca68279db65bec80107493942257e7774c3fbc6922f64d2fb90a500f9e7e068f09632d91e8d1eddb9dc1fa33411c305ae5ec4fc211034231c80328cb789d3a1d53d7c47ac592c5116d91f1918a659f8dd0f7a55c3d1ced45ee8b14b72261699c9705e678752820d180064e30c9e092eb2f2c336f35429c98ff293cf89e9deecd24f95b39fa752608eef5c93a28852b27f18bbef25fb7a2043f29e945ec6d8909ebce8b1245934c5df246976532ebbe5543397e9e23514883bb45cb7aab0232c3862d9797dff4e9b3e85306b762d43b1c62b5d14c5bd2e6b51d9cb737a64d82350f62795f01e128385edf7e972271ec6734f02241d6799d4c0e396e2e9e0d0d3560e5007c5449219d4a78352c1600d64e1bee3b9419820a61e35bb37e477f9f95fb01c360da98ffb87c4405ade4e8961ea1bd10a9af70ba420d68ffeeb36318acb3733893156d2460fc9cdfa8329e7356e0f3e4ec77594b546fff1872e0c9b3871961f0b25695465cb22840636789e3d6d149829a81db92d1813d648e4f46896108ab0ccea2e468cdeac80c648e15936fc1790cc625aca6e1420bf63e23bb4daae0419a8c6134c6c38eb68670bbdf92c10a26e8a672fcae1fec402ca7f8757c32e3206c5bc1de474fc3608c8e7f277c305e94e4b9cdad00e82ef2aa990caccc2bc121fd7cbb6d894097bc92ac38c323846776b13bdadadb43af5bcc18d45c535030e26a6398e1e59571bf6a9e9e4e3065cf126471afa48efd2da72043599c5c469571c6f396de77ef1a51fe57f4adbe84771dcc23e0c9a13010bb36e3342c3fa0045ded6007912b137ce3f401c0901d1eca527bad8967ef3b5e1b4afc8119d0d174e18d5b9d8d4607dc18cd00f74d9651e9aa623d8b7dbc59b2ca88197b1225e197daab83442e3a736c14f5d04e20a8e13c8ae99b2c10ab935f33b57ab1fa812b384956a9514425995372733642bfe8be9613349bdbf3e713bed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
