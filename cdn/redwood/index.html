<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a79073f90d19b8a1eba524d0877810a7036027448df738fabf3e010c66d3740c7b3f8db8c9747179a055d68053edc782c1f2ac1f4bf18c133533ae61a0152a2f72c52e277b15e4885db1d4eb4313bb319797b9fc7ee6df46a1b0430e8a3e528869bd216862a707d50dae2e5bbc3358e4811f4a1eed51dd4d008f823788429cabea9288db19fffc9135a59b930139b1bf233b611b42d7c3e8b400fe4c942f482baf560498535dd191ad4ded6f9517bbfb54fb87afe4063b0eb9000600bb7646ef83683bee5cce1a7ecd974ab4f6d747b8e361733104602d8e79e070df6d04ce0ff12e4aa895f59391c09ca27dc52606a5f8ad10bf31c0eaf93274967d441bf88ab865d556662be1c9935da995f08e4eeaeb41fbe2a1d5a4a695e5cde51b13b0266e59d03d0a1b58e5374a86fc8f8d7a90853e1f246a978e04e3f0124c0bcb329d65e70ad3edfc2da3282a6549b62198600d501989bd7f1e040d99b7e62c7e85a6090e3fd54ec28f00765c212d4f8e41b3c48248b643bf122a8c866aef9dc3f75a30b3cbb83a66eddfa50f440977af35ec03ac8f9ee6980c0a95a77fcbbf8e219e99d736369abf6eea6bfe19dca4961111be64c9d757302d7dcddf430c0bdcd49fd8724b85d49300cdf0b1f9a3bfe1373bab29a552ef976e14221885618a2594cc6a25badfb2e571bc5aea596f937840acbce4f071677359efc818057a84cf784d5855f4135ca1811eddf27f093d1b79868f1429efd5d27124c4f9492a9d1a097dc7c855bf2a06682bf2d2be8ebb8d02839d9a191434af63ce9235c0c6d4de8caf78e333c2463b39894a68374c23a8904c26406998df39770b0f0e06a9cb5f2401c63c3aa26eb7fbe58272129341e8562e36237f9df316f7c0426d58a85c63ecc475fe98673c62fc63d0e7018bcf10223f30636db6c7c77f4f35b033aef2c5b59c801441de5d9ebec7574b1ac470df2a9e69b236075d66eb115b297add65a6df9ac2200f8e1dbe41a387a072b7ce27e91ac8bc5d19c7ed6d0350d804c4bfc5c00660312b72a8e421c5f6fddc7372c9e6fa6442dbad1e5e5a66d0dafd21b5629e1923d1ea672a9d000921de7e76f75f089699e05d56bad691d2ea8147b16921cb9b8855359c045a4872d2a03a20eb0ef84783ba915677c8865ad926aa0bc62509ef07bdca4b8de71696329114732d9b417ef1de3267fd292f03fa02485669e1f7be071c771e7111aa7ca13df7fa3f3444650e36fe6f9b8464a30e5b20e64fe172460f855121da59fb0c1d99ff1310cc656103375c94e2dfcdab34ffa1f879f3f020571a4f2731726312cf69c55886eaa4ae12376e25281d34fcebda781442a20f4bd9e757f449db92b667f27cf7b1b950e1f2f0f4f420c0226c173a1e1951f05b8d551536d12c966219e275a2b4ffd819a93eeefbfabacb88dc865d8e2876f6496d440ab7e4adeb48d0612a6ba6e6dbb74e94591b26f5439ce46ca4c449917b950fbe41ad41a635d80973ae171d485040318e68515354664b4a6c9b64b7c324c0c9fce17b9f001cc0ea76fa0d367c934351dfd46f675d2ba21123a4f84a3ab3c0050be1c1fc1d0fefcd0765ec9f7f58e7a1cc5db1d96e4b56eea85655f1edb0b4983f2c4aa649b562db926ef66877c1950a064637a73969f3df332a73be0b798a6b85252cf0f26ee2e1502796175df5c0978ec2ee8cbf6dfa3492c7df974a9fad13eb0b11bf564af4d7a32f118c2fb4715c955deb9d50b33976bbd185456da32c2564d965473ff49d43dc86c685f8693575e47cdc99b927bf28f8459add376528303dab67cc4199c8b3d81676b58bf6ef628907c71dfc44943c885db960456fccdbf80ca9a236603edcc71ade5f69ef12561a9effa2f21ed9c5f27b3174a3116a5391b7688cd72a167ad8e14ca2086b3b13692767a7f56655613dfa52bab437c4945773d13666d9e2b3dd27e4fd5fafc42930b200ea81ecb8278f5d5ddeeafc73194d711f7c57242d95b21f9e470314f414051eb267339770bb2d9ae1779dde6b0099af0dedf7668437779649ef42dbd90bb386638c7594f35cd33b2e684d6ae2d9d5c4635d1f9c640424e1012b55579093449edd14b8dad313fcc84354e8a907975a4a78b5f5199b4235da941b4f468f0cfa1c51e426c91019551c0941e7e65a5038bd997040d8374452948a26af02bab0641d8487d6f43962ecfaebe8204fafa882d5e7b55109c46453686d913eff86a5f7ac26d1a2ced26be60bdbec5eb48c5b467a3174507a28868f43734193871ffbc88fc9c6c0dc9d5b6165ada7ecb7bddc96232f9ae74e846308ebf15ff7adc933cea90156f924d8921e62fd67237419445d89c19112daeb9d11643b0e58e396f38f8025898f8f586ae9408629af06012cc01f5d480a3af9f090330379bbc53d1c68f52c3cb1d08fd489ce25289ed87eae01ed2d73121e2e39adc4fe42cb7881146482d5d034bb993dac9f7859ddbf62a512a470dd343cd0baf41ab09e0530f755e01dd04678499a5b3d7a9813fcfaea6f58fa348c0ca7d7e0d84df6b7a58c864dcc7f31e4b8765c5aaea714af1b446a72fcd1f635cba00989c6dd84d55efbe87b13e69462dfdd3ef1be21c5f516f4ae168cdcd03fd8f564ad2c8f41607b558bf3611fa16c1b769f45a532c67842af2eaba329f71b32b9637103d9cf502eb8017bd2867928a1ab35fbeef38dc75a363f3158cdfe87f021915d2fc1c20f048c80bec0607bf64daed01a348b8a106e7287945a0b87df08b89fc8e0d8f7207d64c8ff0b69cd50031795c69628ff2d3cd1906b6f62e8263aebb91e5ca1009fe3c397ef4d54eb1e3f1c8ff51c65c69a69b951350504124c80a1d7a48a1ff9a9b67f5d37f53c814b7df7db720f0cc3d1009ee1f7658fd61bb88735495f770e187dfaab6ee6d5da0b3f373dc1b8a879a7779aaea31a014bcc21f8b89d42f7368ef75bb17da36d88f3aaa73fa5ec8b5655f075fb36bc5003013ab76bb7f9640d0e648fdba1a4626ac4a038b757f1bba62450a807e2dac7c5a784be652427bfd6b45a9f571698052e0705dc9e6071389e292cd5c281f4ce71264d2357101bfa99fef435a5bf00dc937ce213179e98f9e6f3259eafa9afcdfe1507bfae416dac1abfb701c4976ab6b5f4e892644f3cf81f76a49611554168e25b467a0c46d1db3f2de8c5475c79d9381a53ffa12cfb9ad41b4f548401145c48fc7c55b8ef5ecd1bab3cd4894cfed3ff17106a5a4db6810503b99f95f7de450f8767be2c586d7e853949d81ae628c88aac6ea8e12d85e257f40b8e22f54b7e1bbdd44eb2ad05d98eba2a943f8a3291253659b448eb7e67d14a86fdbf2ec5ad3f4a30a97ca03c70832358b5334f8ab40f372514d28c7baab4a264b1a5e040b204c5c82ebe8b33f695bdc762050c99aced5c281d14beef2fe7da0b76fe432bab87c6b8ab6876f5a56cbb46ba2a025ee1196c4468717d7dd66054acd2f0c61a0dbeb3beda63095bdcd2b2ce60e656e965a1324d869393608aa2718abc461ac982c4697c95c35a905f0a36a4114c71f306cf77dc3d73460f9754a2ea561d7cdf9e7355ba3ed759feeaea4fb6314c78881f2b57f63b93f75b3dcc9905eb0856da8b719d2e06890cf7fa0dd3aba61e452cc44551baf71cf3c598fbd84813c18e482bcf16a8ce5daa80c90d29585f8b8f76ddb30176d4ba117365b2f27397e716a9170a9b7ce671a890eb842bff5d0182975742cb7873262f0bbeea537deef36ea855be1b389cfddc5583be9615479cb9911362a2fdcc7d2395d5d57ce76e4de8bf13408646c00f40f25390deb4eedfd81a856e7e23c19cb42ca16774a92795c85ac6f96bc2bf727b70e5e052e1d614f0227489f2555c924110a19bb5e80c695bebcdb97c2de89ee823e434922444364ffed0dfc52c675c01db11f42c9dacada0134d90d3097b6a70fd895f4682e4295a02bc84d4f8450ab6f0ddef354ef69169302725943195f6e4ac078ff3102723af6adb653328d7694da23848cd54cc316dd4d100a20967e7d715511e8ccd8e46c6f11177e894feaa7f84d7d200e26261fbb497c7ee91373a55d70ca12383029d980855bef75cab3cf5213f0ca0003fd93683ba2b0dcbe479dda986ce622f785e43444dbbcb0a89f0423825fc0db85bc74ee6f3708bc625bac8e80793e2e6cde1f6c3dd2b02c32771a5b83fed794cc0a2725040a7e436fc9b84795f5347d0c78dd323d1e4802078c7cf99d4f169f0c268cee5ba9c3a688db9aa5c0a7de53bb8e0b89939618c8535b71651fab10fc9eaf1f4661cfd8b034af80ceda4e696b2718afa442372fb616a9cc3a2ab5ee1a8bf09fe3b93fb87be70618e8b3b10d1a4e1acc77338ff74de5d3b70c97c4248ab0802063c07a4c5a4a2c7ec1bfeb6930a9faa08e71861cb4052fed1c8341e433bd349d3cedcb90f3d20918b1ecc7378ffc940325c5bfd6f427d9ea042a3b1aabf1e2544fbd9cf0ef00cfc7a8cf2c9572b8106c85a405162cb00d9d818010f684fb01498d484d140bf2be036809f5b585cc596f7900b5fe12376045a44197b69c4ffd5b0db874a7d14359dd1895cbf07c49ba0d1af7a1c32bcd214bfe47983b5da760c2fa16c4fa66ef317dd4f99349e2ce3033e127d6653d6bf54e7cc9991bc6e83dababfaa1b37b5c546224be47f84147ce9c214c3b381ce77d4f10f98d160c5f06453fca8d993aaa468bf66cfe97a096f43c03c9f9ed52c3dac484f863f1e9f6c1ee91f2ed5bf3b1bef16003dfef2c8200ec6bd93d2481b7ea4f2077cb7c85f1b141efd65aca8665e251f78de3a59ec858602ef7ee2ddafb4c8df4550497f2a0cdaacc8fd3d7ebbfcc735400cd30cf8de04f1a9640b9c7532cd45991b2a0029dd14b03cf29c6ba0cd45d286c8bab20839fbeae7589946ea9645c3f95b8544e1228965d63ebcc3af39cd56ddfb3d10559e9432b01b9e05332c5a5eaf1e99a2781c241e5b78ccab17af71f87bc86f7c5de4c5df7ef221078494ddcdfaf3bb9cc4bfcbfc339490876486fca24ded76681eb28c3ea7f671fa6197f24ac2231b11c6336c943b1dca86089db087dbebeb6c2022f41e0a571ba3da0d7564be590d25dfa635724b54d8113cd01108dd631994e3917594e5e8a8694497f7c5c6f68d711e5073a2708f29b7d2dfdab72b858a27a92b14fd12080bd639cbda624cda15458d5bb0478791abbbb8896c1813f85c10cc96c20ca56e944949a05130413f82fc480b5ac46bf2774d88a92ba3e8d13fea10b58b88ad57dffff57f7db8424f5f4804bab04877cbb3857a35fc55e88b7cf2d136c35509a849262614bfcb2d892f3e4d55ceb38928e25415866afadff55794afb2debe17c8f9bada8da8a0bd62ebac81bc13ac4efde294f513af6e22351eede29a3e6f105546dfca9eadf285bbfcaefe9b9ef12692ec861d83fa5b8d71151f6f23bee8640b0620e8c4d3d2e4262bc58d39d30f88bbbc333376b822e7d0df3bfc2d811649232549b01341f4cbee40336b0f7f7616f7dff639140b4248732711df1ae5b2299d2d628febf7783d8a9f763c7836015fd4436aa0442329bab55425f8ff1f2a0c153da1c7e1db80daeb8fdb85cf962f64efcd4df3ae7e0fe110915d9f0e87fdea91750826e959f352273355a84288fbddda6106b2468de2a59c9127b211c98c3cb14513bdcc266c96895e560b262a1f302112666d0b8402aa3b75eea8b60774eb56ce6d5a9d97ea1857a77d08b4f9989971f3e49f1a9ccbe7efd48811239168acbe47bb35ef3519109f9ef1a6b89462ecceaa367db8d394b5ce808e2dc2a4e93cc9b9ca57c7ad6793329416f53a30849e91762c8e7d05ddf842bc69a294eec28d9b2a05e9a642c31fef1c2d963eca1aa58bcf2cb99b9deb1311c4b6d98a266f1e816fe18dc0af4c727715e0662b69fe20eb6c961eef5932845496046589e33a0deceeb4291be9a7f397aaf3cc57d76a13f91570f96e27e2b88018ecd3db7c7ff3a02b295244930d2bcf040e557a098b90e2ccb213477319a49a38bfc3a0ab371be7b47991b2c354ecf44eb440ae5a919d07ad68742728facf1362d4feeb443e713715e6654aa7b5de19f0b931a710d07c6589d161c879d5ae586cb0cc4015b1009183cde83181d14534e581f1aa7a71c5402e978092246e5a67791b347ef269911716d2dc51f73b5b300ddef6e15eb5a1fd9b08cf00249276ac43d99fb3fa01e3926adf1f3b81d4adda7aa85b3d98bf955f2d6b3f2d547a4ae2370615ea4b57e000fb677ecb37d333c994cdc84f10967ee19c99e961c69d4af4a06e29584d3dd5208cf6679583ff4f0f9edcae152258fbe640a0cb267ee7151bdea705494714c7da6f433bf6157a3045fdf6239963c5266d90ce0fa40bad2837dca6a2adc3113806cf93eba29b13241c1d2a2444803a8dbca6790e28a5c077b6851c2dbac485b48326fb7955485aac601e0f56f9facbdecfd6fd4bcd09b42b6d4dbf8a3cb19735e4fcfcf5f8d61aa90886f3b1dacfbff20272fdb6010deffefc8fbeae13b2025f85622cc4e34d50709b96ad1bb863cbfc350ae74adb22b6480f198dc7acfd83fa03af076c7101d60175c4a4e80cb8e75014c4f7244c02faa632c22bcb6bba815fbf88a4b08b484a925fcf163dd4ad7461bb3f79c53c64ba0884900fccdb28d848ee962d5f68ef25a8f36158545ea7fd2816af6c492efedcb23a3322141c5889c332ac7def65a94e59b174b0c732163e51bf6d3ece6eabc78c93c30dec4c8358e7f117901c01ff1d5a72f71f8fbc2f4f413a8c4fcfcada1c831c2212a4fe1e29dfad4c76bfa494c04c97bb55b0897d77b615eb3b78bd3e2dd61c55d45d1a2ed7cd45cf5bdb4222c87905ece9619810d66b97b5f5b91deceaaa2bc29ecf5634915402e367cff8cfeb2abc131b5862850b296c226a87bcf71580e701b710f22432024a3c7a2f87b4a784a53706416a40dcde564ddc6143c9aac156c6b1fb783fc404b49339689a0c1c76f571a4d747adb1494b5ea7e3ebc2de0e8d64d29bdaff94a825813170a84ce758a6f11962494c46c56f4e9dff12087162ab0c44732e544e8c3245d7c212425db432228e79a7bd5e9b87f3aac0ceb1bf945e655c2c98a71b1f905854bcc074c0c7bd8784e82162f50a575ac5b69d09874e3ccadbf6f70c9f883fdb9da222b74b452a7e04b17fe14aa4532afc20f00ed0b8809b463025fe392cdf4d5edc7fd77261d77bdeb8d7684f98d8d63154c2433f47e10a470e1ce283ed85568ee26267297b6ef60ef31f9bb2f0f72db66f496decfb4db6d5728486705e5887a7067630131573923ff993143c847567d13f62a26832e0922c350658313c699eb75903a05664863ad3efc61f0a1952ebe45c6baefbf032a69e7b4df8ebd0be0266ef4d593cb03cfa233430ab0136ea432aae2c0ab236f13817aba7c471d7e762947d51600c6c31547d7c98ed1dacc9cec9d779752561eec8e472fcf373d3019972ec0b7e6fe024de48358dfc1f7ab756978f8ca414985495689c86452098436733a2180a1521bd318a8d00a5287d9cf618335d06a28deacaa9b6c351920363903982745d6e82451631131ad79ba1a9fc2039d8ef7b7c3cab3d01c20017ee5e3f60bd8f120814a2ae24ea3cc978de5cc4fe4ed5518044d8db7dedfa57d10c6b36e7597f710b7c952cceeb3a3ce7a4022dbe69dc908bfe80aee85fced23a46dd3c3decb4d9d6abc23dedfc0c55f4be022da6fca4aa6232c61ee88a4189eb14b3079799cc98a6befc80c5f413dffb19cbc4d485bb9a1a8a908077d226d3062bac92aab8ba4499f25a5c8106116af159294f8c91b52f204ec39d15ce97e45f12849bb4952c825745bd3fbb9fcddcc8e9d03c8c148a1283274c58eef9f23de668d5e0ba3e8b9256516c31220294cfa308bcc96550bdc1c5d9d61d57eff6a143fb158dff5b9a27419f9db2c091daea67a62a2380048b7b897a8397de0c7def134c33be55fed78c83d6d4aed43e56d14eb2d3a3248ce45bc7619a5efc3b1d751e85cfea09d3131c1766572751f9e6e4537125b1fb2312d035875ad9e19770a670e2df02c6cc314a4026d47b9aa6e12fc6f4e5c7b13c4ab4eb499785c00ec669a140b069eef01415c3ff488360abc6585cef36b14dbcf0c226b0d33eb87a485c2cc81c5176df84ce2314a5fc5c86ded6b9903e2e08dd64bf8586e9abb13a0c1a83bc98593f6df29cc0328604b16e6f05094dce3b6c5170939e75e23fb158dbd63989a178adeefa4ca7de87050b11bffb357357bebfa6dcb8b3b6e22e7ff349c5d6fedb6502cbed1f0fe7f76319bb4940e105c8d0f17ed6271252d2eae58784a3bba26697bc3df790db9bc93769872a94010afdd4723e22cdd8e48118648eddb9d450b67642696d999320e51ed6b1a695dc2e22656d1af15560f6490e784d37a8a5501e126f1ebd8580bcab45dd5ba8853718184df48756747207d23d5ef6ea6f7718c0d84d944728c84f80d89e2af4eb788363177a5156486066f2378e307556cb5698cd40623e6342fac27ad560aa564311dba01b9698fae0d0d3bbcebd28f9d8c2142cd2c12cb1394d1db3b2737f713608dab6df89643642aed0076406d7185cb404e8aeb5c544d17d1a233af4e0659c10bc216ebea2d6992b32dbc24eaeb4d7c8392b4e497a90fcae8ebb5277be3b94a51baa0d7e35d8fd27d6433b56efd0433db303c9261eb3ae60bdcd41518a9f2775864c0bece91dd5b2f2409cec4a4926c16bad1e2c52249abf28bbe3c7bd02cc66311121c02e530a0952b4325a10d9e8efbf6a964c0892d26852dcae6886729d2edc3190593ae29ecca3f6c89582d1876357eed1cd1f3bd689108faa6e68cd9a22847e9790dbacb27a7efb59bab47ab7e8bc2fe0789792d6e6f55fcb9c2745789c3fdc328d8f86390721fa81e8279462c1a62640a51271d5519a1acffa670b7f5b7fe3116c08158dad78d7409fd003a6fc4cf19c8e292fee4c1f970e125d4256371cbe6eabaa08bbe6ea18589a37d504ae636d050cf444fcf08ada133d7e4830c98a9f7fb7561813f1a5654632c4e38ede8251ce345b796cf3ad1c660fd4c188294220c41774121d0e5d106aa2fd90f49ce81ddd41ac44c0102dff9e852aea93cd643d7f17e4df8a165ed946fab8e174363ff03277a7f495dfe24076d1722d68a8c5537034f7742530ba0f037d4354fc28b59609fb6348a078dead36714cc29bc4163e0599c66b3e5dbb8e7ec0b21f357ffd5f96cfcfb2378eaed72a1ac23a3b6bd8797614d452d52cacf0a8081251fd456c2c7408a472d0021a7d6e860ad27fb7221462a832603ee40c6eced9c4f6324f85b7b1c87424f3dd33b4c14ec00565367f77c4c85f1fadee4504009ed28c223866a29e42e71b0c7c5bc6f8258c9840ff2f466af93300dc9822c0f6e0b6cd0468ce37b2c5306e9665ddf51ef2d602d8f9f901d43889240ad1267fa15cf45da1dcee5ebb55f698b332b4a985ddef063dc4da26097122755431e8ed57490ce9c45e483a07a648a5bfe0a01db610c563df3a6d38f57b60959175000757870b10f879961a33c53a50a1fc6719c4addbfd434d842bcd3920e3675a45db72d44df750f891083bd0182a9872515d31fc7c62566783e320fb2008c6a05394573cdcbefdb5382985e18008dc5fa5b858e70cf93e28ac539895db74587d198294294e61c304107dd81804502ffab78b036bb76d169a65a77f2b7f70ed2dc660f22262ae2664d35f83e5eae0ba7c9ba3467f38db9ed17ae28cd9f7d72c317bf5f2f77e411049d231864b6fb3808b0f321fa8ee98ffa5df2c50f29d6f757a5feae1ff728cca22d1978d36f46e9817f8826b4a60cdfae28dec6b938e322570bfec303c653af69f93ad9e793a664713b8a2322f1af5a6cf534418a717f481897198db86268254f24bb5ea5df2a6ccd8fa710046e10e3b4eac823ec78f9239bdd214cebbe81f062210be55d8a03f8ae821e55524b2437e5eec2e286251efc462b3a096e0a574588b2d57db0c29c33177fe527f893344ac153ff821eb6b6e21c0360606cc376d5f9ef4124496cf86cfefdecb95aba21fc6d040805bb885aecfb47db234eb8804cfe22f1d87d77db8ce491ab5c7e93ba1284ecbf0b92ce44a2a0a08b83e7d30f12f064387e14e146572add62f484b3ad8a13d3633a9d0d9691904528fb18a652f5bbacb0fa7abee74832e295cab51da4efb1758b7ef116f4031c0a7f5b16e728993f19852e049f3254206ef9c0db5af3e6241320a14a2454d8fed3f236b3e3051d45099eabc47471da60d618f9748e3f277627147778c205aeac20185269a8baa2d1ab631f6e5bec297a2764ebf7c64f2b249d53b14ead33387fea93663abb0d41515582af347722de15031ecdf583d37ae005b9bea15e54a740638c8a4608e7386b3f2fef7a4382531ae73d4711f26e0d42569ec83fc9ad4be802299a8360c49369f2852c936836bf99194b82b86f34b032acabe9e30698586db83ab239a819f4605399f761102f0dc04780fd90b81ebd9db89bddabf16f9c77f3abb8ef270476b8ce89d6d8829ad9a73971fb58bef1b0bd557182a83a8521db4e9588bd272bfa8bb7745c43cb2c4829701d2038cbaaf370554b4133c8e43e5a36a92e6853b8b8247b6b024502a4f704a952bfd5d9bec4505f0977e509649b3fb18d151323f42645e6604a903f883dcc3ca45e2e14c3c2503210d6bb2d560245b1d1e6f11cd6af4fa542cc394549a06684d809ab84dfbac0833d6e915df565f36171a2115e2172ded5a30ede93358f34892cbd272dc5a77df9793eb946736d7a9c9ac2851c001650216d44fd0117f7a26ecb1674604692b5b1d4149da5b3040460cbffce48d3a8a6e27094d5e3c2a18d6bd863c56598d5eda5dd911484bb17efb6371d42f092bdb0b478cc5e85b24df55bfe27fd30dec1d5f45001f672cbff085eda5c4a8d534476c499a6a1b73888662c9613458ad6a5665ed34f7773891a6b917f6e255576c3e21bddda9138c9dc19cb1b181c49ac056b7ad83beac9daa979a9513938e72119b741fa6c79e0b47581ab31f8308fed68eb304b68a1e902567eeb34a1aae81073617429a8b002d414b698a18b4ced28bdf3ea3e3b71937e7bec78d8bedda44a501f4b9472f71c26bed8bd62c426f358ad042c3624d6d7c1517341a5b63521ad9bd7e53c4da45e04ed69644eec0ddd3684ecc60e8b1cee761385f3c125c7799af05388c5c3a0cf74826885b7e56634c58b333fd4434d4af9976ecafa96c89ea2aebc2d84de57b45a3552f2757009d9e9aba66b079250585a140b99ef7cbdfb45d42078f7cec9773b0dda16cef1f2793196200a555fc3622fe6014d247b3a0fa8d60c1f2dc3941883b1b5e5d688b7f4fc088a225e10908e33a7426f22f7fcd7b1049fee4a0a712c12d1e45f3010a41dab669b61a72a4551816e9cb2efb39a716f8960e624c0fea501db1346ef40b9f2b9b9d0d2bf6e02608fc4aa10e7bc8aac7d63a2bddf61794021492e59f6e24abb3e1c5bb425fd0b9ac89f68afac455ad7d9f54f1f1bfea11e68156594ae0383e0ec5356ef0f9aab739085a6217a278bd774c09dd3cf7caabe99848c29e0372e012f48053e39442da5770001885cc59f7e0fc81f48ec889cd78ef0396cf95277530e6b4bdd54f820422a7a7205de8215882cd31523d119c54c49e4e7ebb20ed25d9aef51a23e54ff993893908558d6957b354c2a99a1571b9fa17620284d7ceb6da795f8c35f9201d1cd714fc1f1badeb318d5a3ad603f48f45e2128770f7a197678e4cd3e6f1b134ce9b20ecdc938c965d6f25177abecdc74fb9c2c4f17da0275fa7bc01941daf905636280f872f6600321bc3cd82a4a821b88d264ad81fac48bb4ae4d0d3967818f6e8de8711ded46396c16ff2ca0ea4a10d8a2c09a7378357615ef7bdd1e7fb8518ebcc57bb30ac0f9b53a7872d7d59bc92957655f9be41722c00a8b0e53b2032864a8f71d58543e11969a9d50b18ee67d0eb89f432082c39b1010984d952921c1367d9ec92a748ee5fb1f5873ad9ffbc015a6a165d4cfacc26b89689eb4e5eb4d53e51917f3fe83ce82130f57dc75bf760ac2378d14f9dd5ec23a7e001478fa85046ab0f553ba53594a80b2d18f13b7269175b41b559af97238c75082cc58d5633a0ec01e7f5fcc4f1cc8ff2046949974f536c4ee7fbd2b7672aeb6b7d1148efa48ba96d36306dd6be881dd37db17e3bbc414ed1826881a6b311b86fdd51c9c8a3985ad968555f9d8860ca88f8f1f8f1368cbf9881061475611b2e11dd7eee1c32ba5e8cab6c9b305a165408cdfe1843dc9825b738ca93cd8f16f816e5fd79e0ddb70a030c756b1793be849e1b9ba4a8b52c2aebc1d88263d98754d42aad0e9c7ed1d5c5caebaf81114522fb83263c8eecdebad4ef29c23f099301e54991d3b71a0b4a9434be527603027131d345015f6f1a53f902557bcff5519c045077c54454f7bd6716111cf088f9d295abf49f254ad46e98923afd6added971e064028a2f65a66feb49aa83f60fd3180b57e942cc5537646191ec59d71ff0454bd8bcfd47ca617b509e09ac6d1ddaa2d723f784cca1e0bef7659cb347cf564cf6fa370e2db3a87169383be955265cb4a9358c2e560a6e7bbd4aa3415862004f12491fa9b5be1b71ec7302988ef344a48b940f2c4159df30144901c0f409f363a5d7c021df54beaf52bc3d12ba05e7cac0bf818aaaf9c2ed399e1e104fbe9abd357d58d056503605639ac1d6eb9db58acfa1d078c16027fcfefccbdeb0f910e1fe0ee960ac45bfe9ef8f0540264be4522f1ca71ead594eca4451536f4bf43ee3fab8a2ec0cc22fb8801f690c8f9b2a9385c2d2029cb04d964c314301e1a783d49262a5c94a28255a54718348fbcf5df11368d5d7d849d4c92bb2ffb59ea3a2e82df696f43cc734174359d8c80ce9d2f990d65ed99ae5a1c3f993b63b129291bf7c4feb8e1c7d483d4e1e1b6f45ee6ae214fae9abd874b9021c4618e1f925631dfe00eec5ac34a0e062ee29b43a2a9e937b619d7161e0f8e404fc48ff267d260ed6258c651d05593cdb9010dacef8d4490a402cb8c8f48a137981cf9b7c6d880ad8a9b66d5ffcadb94642f8bc4b805bf903397f327455cbd7ce51f144f61c4f6655396c90509a214b4819027da0fafe8c81c2f2e6a5d81d9a00f6e2240d11dc10e4f14b9a61581a2aa253a5a5bebb35bebd15703c639d9b248ad60983c18bc0e651afb2f5617b891e72bb5c02cb80649f294ed659c1000f93c04018aeb0fa6498498874c3d23fb6727a6eac0cb8d00e5ffd680c53154159137c738e3d9c0c04f326886722c4fb0f3894422780b5798d561e24bc2a66866fe6207df317b1bb4b7e4aef14e933c7593159f9fe6078a2935543d77cfaecd0adebdea2161163ea9abd8f6a4e670be2a524a55cc3aee0ded664fc8b01ac2d51febfd96dfb151e5998e84333710aa4f843aa9b0eb3b1693ce23eb46d30502d32ce7be8904807bdc8577cfa554884bbdee87736a156587308e45275ac6b6a4bc334a4f0f4e6e2420102428b6da6b35be0ed319f682389cd564099603c00c0aefa84428aac10aeffc939da06104952b4da92847f4620fc9664e8e143f7b22f72ad45e59374366a21b266800815e3200783edcb78d7f5952b2d03adf11415891e4b413810c664edfe249dc0b607ebd2c33e85a61a8d122f5c874b7b75a4c3bccfd6bec5a7f0f2f6506f9926f0785e324e5262493ec6dcdc97b9087477f2c6ac7f34673c3b78238d5d32a39c92c5be68ad1ec6d571fd06ed4fee400c476d7555790ce2335581e3c68cd6b05eb43c3aa6b538e7af489176a264a7e07ae310d66d188cc2d12b850f70faa22a20e230d8f00d710d8a4997c73255a95ae89ca66377aa5443f9c4d7db5a1079a3cd3771670359cbf9f680f3a1854b010e5d0e42d5efc26f0a2eef2dd634bec985f1679d95bce46f92b9d8f92356ec80242142cc18fdfb864196b4ca0cf84873d0a37c960d1b522849ac3609676857f0ae9371bb3b035d450bc5bde6caf028ab4337a17f89ecabcd42ea4496920554980cafcc8fab3a3aaa2ff44c062d9c08ed5e07fc47dc2326a99673f727e55e19bf4586f0d81c6e47059f4c8bb4c5ab55eda95c1c906430b542777d1dfa0fdf27fd9babd1223e516af4f69ced92de9bcaae16b3475cb2db71c506f236e32060ce495f4e168d44ae2f1fb7e07bd514261473fd3d38ac61a23efdf4b35d2c5e600f317b432bdb23e9b1e070111437e5428b37b276eecc4ad1334941e6371fcfe66d9f441bba6760b349fdbd4137eec5f7ffc53d88776fc93f360ff994a3338a79637697c79d1f827aaed05768151d2e2700a87cf3cf12c682f5cbd9c8604d8d0eecb3f68b56bc5f9f77581661084c52b3f9b0ea63e9b364ce87fc39df080788c873d23b3487e4f979205b976d382e99c14a50fcf8c21a054c95cb9dc7424c9293e089c8f7a9566757266cdfb0e3578a05aef0e9ebfe74ea48b6ffcc80cb4a360b02e6d85bd2380dea20985f4dce4344dbb9d2ff708cc0e47f823db35ef0286ab81e63a79f74c3e9e8c0bbbf62937eef9e5c4dd2a81f2470bf8d5f5ecc91b07208ae582a5601ca6091bae07ae647114c90f2eae735f8e6ecf605286fe0cef933b87444fce9ec438d2ab78f2db594c9ec2a0e0231118e4a8a4adff8d8b7ba76bf3f03bc53e21b81a50dc701596982c34090501419b2838d66b557eb5807bb95f146fd8e0eaad847f1456942935089a57724184e7bf25a20798d1788d62b49ac2445f93bbad85dc5af346a4688c516d15636ae1cb097696bd34804629c14babe75ef9137db1cb44feda3a511a97804f2afcd9754aa53abf51fc1730f26a412ba6a17c82d0f11b1fa097d0311982dc02fe617743e56ecfc91317a86064e3d8792dad1a4aaa910c54a5c520cb34e53a57a93f397cec01e4fa3c57e6130fb18bd430361072dbda68e5954b19d47457605c3e58bf603917b6c93b510059df079a17c369ebcfb63dfc8dd33aae00fd1989ae907cbcbeb9c0ec3ecf608cc9ac16004fa7c757c7a778d2dc37e31ea5970a78a50aa4da31f0a8ee4474ff41adaa59e6200b568be1a546f0ec49bbf6f735491e415cd8f5d81a0be650fb22a471f3b3f333c26613ad81713b6669121df1f0ba3b4c2bd94e757a38f2179157a9303c4482b90aeb0ab78c0439786794152ffb998b553a90738c23edacf1f4889e89256ab8f6f84b58ed2930f61eeaa4289488a453c4236000bef3c8b819f8c239694d2bb6b204720031a299a6ef20ae1fbd3f3b2a08ecd6fb2cfc8c263193c583781a74cdd33f07592280b7dd326a0738be0a7586e609537236fd94f1e71d3b1901593278f928ac6e1a43ab23beae91bd3fa74a386acf4fd368c516ee351b00be4f1a63b1e96ca823dc86e7dc3a7001cfb4d4168b409dc97ef05e184e6f8de0b811726799238e364faede87d53f1fe8de5d45717c6bb408781d0d9ebd686a1987db87af6bc987e9a482b840bee4eef6d2dd7c4953e4891fbec4eb18d4b6d1fe08d842b30f271b162eb080fc3be9f1454477548ee505aa7af9f783dd0633e4156a57b793f4102372b9e14602d79c047a39633d96735a33f9ecc5fcf820d4bb2959309e5c6e951c112e18c10b7d424d6102cf038856cf7c0b3607987cfc5a7ca1fa7b8aa83083b857fcadb7f9bcde8d7f1c1aaae8c8dd02afe75a90e60d0f41d7200e886240ec643a7e8d003e91f437de747c2f1be29d3a3e71584d1908b318d277c464c2eb69ff160a4e345292ac362db5c6716fdd17cba83f2d95a614659cd5920973a7741687faeb4f32399e5dff16ab97adf25c71779ad71e804c5df462ec51b088f59ff296e7a3abb2494a8a19bb939f092cf4e438559fe2be45a53368e05609d4c524395faa0d5e7eda99dae430d6fef74a8e22849eec6c2f15958649f4dacacb79abc1e505b3b885a549ed9416d3b051085de59d3b6621ce33b34785792123e07a6cf420de82ee2bf5442b30272e7e59c9a52276e193b5de58dd23ed441a9bbc2d257749a1533e933e9e96cbaa98364d8d1ebc5e2d6b26dd3442342595e9126871d3838b4d97a969c0ebcbed894b540ee6d4650174f5e087f53ab339b17ab3adbb50ed0b411dd2949a88dda86c9f3b3365cce2f2d37212a4c70467dbb3826b326e5a15c6b0018aa05ed5db911f49848e512aed7a7b03a6da59798640849b29811846ce12fd0e3cc0ff6c6201630fa502d63abee2acbf6104152df893d6890969cfbac66c173be4bcfe6aad79b585bf8c163bebdd9dfa1ccfc2aa55b4f837c387f967beae57893d8b84fdae8355686fb6ef7aea810d4fa73f6122662eb9c0586ae3c5c1851d7e50346dc70697ef79ea381bd9a3ee4151a6a14ca88325c3d0e00c57f2cf8386eec401984dc9284f76edad7bc71a3b80edbe9bdb5c3690dac011c57cab7105a24e79561db82bf2c43ffde9ee9d1e1c2d9a90016f70079b71e4e1c233f092f4c480d38846729b9afc313710293247da43d096a4b940c8a20f5ff0b24a818c86a44a280b9bc59b9a36216c4577084a4bb554a05fffbff09d6bbbf61d30477729c1f5a0e587cff1d95c39fef259edff2284d57503e429cacd61bd5a7d6ad9f3d2f04cfcbd9f040dfdf8699506be226b45cd938f1a14d492039dd19a84f190c3f311b8e76f50580c1a3a43b81b0b0da172bd5949c7df07020c8eb81667b5b806e258d8ea0e828560da5e8599406614b7bf45faef4a37f9770b6020fc82f3224cc693215bbb66bb021af4e246a6377f0591c395c6690a1314e32f20c236088f9433dac801ff626b6d076522adc0ca3a3c6437dede7bab21cde7e1cb2355ae6638030277e1bf4ef2237fcd77afb16502c2b77c3ced2f366ed436d50bd011b22d87f8561fe25f0ad09e09a985730457b1a3ffedf18c5244fb706fba51cede143d1babc9e588f92ea76b15663995c73ef0452433926a855bb5cdf07df5e1c3b50e0529aadbf03c6040c44f58e523ec24356ef61b9f0a52fc5862060eab44978fd7fda7b51a10abc585bec5adf4d8960f6222115bd0e58e3f4a20de460b6bb35d30ce0a1f14c87bb00c7bfb4605838511f7d2cf1bf95b9e6a63a45353b104e7f0024249536636a31e5ff4bb58464ef455f16e9559d3785d8cd51450b248a9e780445f0a45b88f7ff3047e55d0b0e5e99d1b1752255b450e9b07b688ddbdd66145bba969a71177c58611e32440dc264ee4fc994e54834cf674a0d95dbd5db788d02dfa5dabf3a78a2738714dedc0500155c2a9a0b360fb49cfb8894c025868713eb09257390f1e37a42ea906d1393dd4260379d72c4d367566e882f1b63f8e2b92ede5862cbd8fc7b6a09633451b978fb846f1bbaecde28f1ad347301ce98b21cf7b85700bc7ad7f1217ef6c0552b41d5ae03ec7dda4b1186c145d608a7a37fc037028fb8eb616be5e2bfaad6e209807048ccc1c3d56ac718bfa3d8a25bf3f83e9cbfe7cf6453374b7e4cf8bee2db4cbf6f572ca9326d77534a19bc5aeef463318ebd290c6af8bfde55b4c5e58df07c1adc10c76b8dc447ca77305ae7facd5536dc70a4e2012527fa08f9510a037de5340f986b36e8f54963ba2cee2fba3836a22627bd818d810c1f5f20530a838d347fd8839c043b6c4e3555aa14af4126ffb3c0e2b631f5589ad026deac68f57757c8152e00d99d4391e9aff5ec2aeb3bc45fc24540276843c7eb0c9216492c7861d12fcf170ade7602a8e2a719831732d2b2ac03fd995a6b66886efd30ed4e379417c6991f75ad6795178231588278319dbd4783e2d82682e8b2a4d172752eee86cb109dbbbcbeacc96894ff528b0dffe4570d01e69fc2da43446bc281d58c0019bdb2c7bfc301d8ad7761a7cd885e99fc115a7e42eb01a8a77e99756198d3d129e5bf075aee0974c65c195fdcf9307b2d4a7f9592cf7118bf08fb57247b21a0416f76efcfd9613897dd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
