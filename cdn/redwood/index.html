<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2fafdf845adc744b81270da26c704040ea82955173e397d4d0e06fcaf1d071e8c101dd7263e2edeac1466af0c7f0e68f442e722ded92d48f4b0494a12418b950e2e7f22f4c97737eebf94cf5524f79517d0245b85883d1c285db79fbcc06cb46acfcf115bf22decebdb23126dcbd72fc299718dfe6a09859b653832cf36e3a5dd7dc5a16d91449c2440a59c302480cbd8d339f6d687c9b89e77d4cf00ceab6967053b91ccc4b159e2248115944ac0a2574a51bdbb3db678ea27eeed78097f64da9ed4164a4092b346af75f54334a206a4f759e294481d18c89cd05ba0e1c25c3829a3b30705f0f15f84c85ee41edd4a794b726c3528abafbf35eb98d2e9657ef1c5da4bb2a219051e017fba0d40e6b8d7a35292abb4afe5af4e99d25739f611e8bcc045303f2ef9e9fb78f4ec05df18ff552b353d7128ca0c5515b1e614abd5391994d75de3ca21ab7d1503df5d133078864c3fdb4c35e7425032764065ad1aa132547565470f03d60f541803b401a3dc9811e0a35c0465d9795411d9e0d27906bdf05411eb57e4d4a7cd7098c969f42019dcabaa98e1c42e1718747bf3926661b6af904b8183740bbbe6ac142f8219752d258b7584607e6c2be7a5bc381ef0ae648c89186c121d3f7cdc000af8dfefd3aaec18aa86cb30be0d1ede6f2b99a25081ed16520cf0235364dd1e330f812457b54a6faf948b0e4d22b66d5c5a93989167a8df1d6809f961adc72e27ed2c973d6fcdeefdc11f55b3641ae1c1985a94c3832b2c2649539622108d73543673b0690025d5315b0da0b284aafab0776a1d26195d6dd40eca13964c54e14ef8c05a40c69d1168c60b380bc6ae5293d00dafc31f81cfc33d597dfde40abe794d5e6c6f9f7f7a98a280628c1ade604b533286d212ad472cf88b0561ce77c6f788da8ce9e897605b01f89829aedb7633b66ff1eef46e2fd3cba24817630f11bc6adbcf420f548fc48ba18ab42bba9aebee161a16d7aff6fc6c893b344089c6b4b3ebbaa6c86f1f0f53d61c22b187742dcdd73e00db59725f73a4c014ec40c42c8974ae0827a2db315d458ac5634bdfd8a367cebdf24935172da41a60b465072502de24e6bb26824d0400f432e04dcabc49b3962c8eeba60c0c9925adc8be28cbd4cc7e2973d35a09939850afa3552d417f5e8471815a4208d30cebec9bde59297f9a8077401cde586c504145af7c4f323e6107ac3e29a3c56f6ce54cfc813409e411d8a013d55f34ce2551e1452fd21d1fc96406b06425966ebd1ce9757ac5b27914d2427f85453e59f4096206808e72b4b701ae3bedf1f6aae22f039271623864c8f3d37eff9b0591aa7cbf1f919723e41df4f86c58a0bde33523ec8384349d3f2a83d2717a2089b2f0ec71d0f79be3fc08c3f4a31470de219d7c4d8dbd06394cb0edaac2f4ba7ec921e7758953d458df3193c950f3b4b901927831abb88ae828c8daa6fc74334fc26499d4ba410106783a67f33bb0e5b425343b1e16a301353acf2d05e02bb7989f649552afd22dc63abccd4ab6e395ca993f8ffe86ad44725100aec3cabc97f3405e28bd1e36cc30b1edec5db6d9ceee234d475f2496485190a5df8cde7ab48d01591cea385e1094f3df90202ea7da7d97b17a7c3cea4e37dfaf311296862b2fa75cbb478806d8eabeafc2ea5391dc2588f84b23c07f25934792f02e141a6d614dbdede1fa5c2a623ca1920d027b5dfcbb559d4ed040cdfa37d8f9018b4442da5eeeea6aa9a0e6b473209c48e9eb6f6f6fdb493f69e7c924c244789b4cea228b440a67c404334654c060d94ca437051369298409717015edadf8d23cd14b75720ce46709c1a1ebeb5d8756b0ee9eb643cc48a87808f57c72daa83bf11d2075d1d8d46abd174911da28a2c868326dbb20f91bac7acc4de2dfc0e37271e301b54cd2fc658e1ef11c87cb9ca0fa21ea442d95d4f413950993228e93b7aa021cdf35c49610d0faa64b57ecf285a78d846289ac9d6796456e04dca5856855457f401aa36a8b76f04abb1509fd636aaf93a5702664a57dea2dacedd5677a32a57f49e3c61c536d3dcc5225cb729b728379db660e19153b85fe322db459ad42e8e752369779606ecb3aca1c4c4b6718f40f54f1869e5c7f6ff85f7e2dba2695a2660a5a85a3ec52eaefb53559b4aa9dfe65d7aae04cf19b1218b049858081e49a717ae4a378773fc9c8229f9324dba8b1fa9bbb29c965ad9142449261c78c8f06cb88de46e4fca935d7bb6b165f1e00f55a2f5f5fdb1b9f9de2225fc4c68ace392c1c1c362ad83fb85448053c2a15ec3585916d10fde93db4df24982a91034e93bfd95f8ae4deb7bc094f98f7e1647285fb3d150dfa14e96a4bb9ae849db5abbc4613cd1788ed7adf38aa8df928d28797abe3aa92b3cffefdd6f1ac6d9785afb7ef6de8335d295139c6a6cc8e250900ad415e2452faaf207cc3a16035375997099801b9f1c513b8eb72dc6973c53d41e9f4660da8e0e50c5556eb7ca34b823502565246b74bde4da69151fa653fb693e1b6f0c1c7aaa1a4438b4880000dfee227308e47dc89731c82b7770c669ba8c53770b57742c9b0da77d04bf153bd5dc4274dbda921b50908a257bf7a5a578e9fbc10f9a4e3c27d21b439723ff861faa076ae7cdafccd6a9885bd238b874f9db033ed26a87c2b90589ea27ea2a03a430b5257fd564f0ee2a25380250e725903c2219285792ee5fde696b1f170f37060ba5687d370ea920cb05a88fc75a883ddbd35ba4d5ae260411c31e8353caa209aab8e081d1c5a394c7639789306d0219637556f03f46e3ed7c7bdc53569ea90350ac43e943c419ba7fa397b3911155b08b5d65680b86997fe6d6cff267302d8600c178a8afc893b2fe94b7a9e8bc7a205124ff90671951e19f9a0814bffa5dc36ebe31511a2ec9b6af5fe8abc48d80e5d4ebdc3b3a21bc0b5ee133e205bae7f5287347d725509799410e63dfba058b41aa7eec67945f70478c5d9901bb7e1ce71048025564d96b510d4ffcb85d06f44544f6936e6813aa2e1d30c2e4c69dd7f2130ef7d4c0c5e26203d1e9085fe445e1799e0e98d6b74bbf8c0681621fbe74ba9b36327e917b6ae6d6c8d044e20fef08455b6557ceca7f62c536e1696a44258812559130e1c60a345c914be350cd6edf258f5fbbd259a5aef19c1bbf698d2c058b2b40b2bf3ca86b3f2d3696d8128ad23ad79ba027124de8ca6199ca575f6c845fd455bdc23c4f4cbe4c2f8f62b7229188f5f13abce3984a3db1a7eec4889866a44f1289909ca155c086c4799ad0b82065f088c6274d046245500b927990d9f058750123395bd9234f7d410e27e4de11a56d4450a051200f6ebfa3b54628b866e6ab34c7746717dbc0f83682e8eed410baad6e9ab4c5d225a887d9b3ca24344a3f614ea8efb805ce98700d4a548b03248700138ca818c805b57a14ae4554518dafb9b093d0baee8508216b28e8d98c065b3ce8ff96e332162ea656044fa0cb11089c83193766f9481dd783f44ef64447d91c8d065478301fe86f73ecb3d199bf61367db0f9362ceb7a7e9b29a7d940c667f4be53074278b8bfac923de0640c0b9d4b04c72ee843b1d523dd6e9ddf6265b22d42fdf9d922ff7b4efcd1d61b6f9f44c20f74303f15a718cb155862f0467a4adcd8ed1484434e432566ad2fef28f0b4128f22a40ba8bfbcd87fec4478940ada84771c7bb4a609fa7694f4920f44ff994f48badb989c7105962f3926e7ac65dc741e7d4128145db03b474802acc43d58cd47551c56ff2ab8ecbce610b0294f2160935c2247af45016133de5ddb51be6c2591be76b9b8c77f81f6a41e135c8774c608589429a3596814973e631da10b4e3b02bf2e39bbc0a02f11d621c236aaa538e5fa512a69be7c79ddd4726186192aee9eee533f6b93f28a013959f5b9198dd3ef8d925f15f66af4a1ff90dd1452db1a6c14186b10588d9c603c11335d268e5769bf36d565c9bdf4d101b31196fa782e164e02946dfd0cd6a8ade2c027e3cd97d51f7a43d6db201bb3595eb7fd7b134cb43c4e5b11bb00c9b6a895e29311040e265e8e07e7945d9ab68942bdbe498e9a2b1cab1fecfafedeac3f9e6f7ce8885d3933452e10b8dbd9d51ae36e1ccdc3e4ecd2c6288374325cc67008078bdb3a3f115e529a6120d06d52f84d154babe7896709186099f9e3102dc60de061ec2d0e2cdf67d8638c28b22507d1e1981094c16bf18e834a81fdfa4240b1de863449c7e66d8cafa5e4ddde1fdcb347b7f2df3a729df0f96048e37438612f2f6012a3d7692fe78c7e57f232878cb7878a21371987ee65d8c12c23b01460276d9715cca113b6bc7a9efa99d509d27dc99e904c1e297c533115cfaa081aa955cee09d41888b6e6b52d28975d361cc0e46bd629813d246edf5602619ad50d1453e16596acbe211b5b9501260ceda1155a521d62f19ee0c22f76133b67671f9a25b0c3405420c8f186b8227031ac236f7148c49d7543575d6f3ea29f7f400474858ad98828d46fceecce2642f273b7464c7b509850095adb0a14a08dbabf14c223d6d6254c5be8f806fc7f506a79da0267dd19e9f6de105005eb9932a6a37d1dcf5f8ff87d0c37f788eeca3d11eece5bcde5716fec57a269b10cd3790cb63af0f714dc7b1888c81a35eaf687f510ecd50497070dbb8f02d34ba6ca90d17df34dce9df544c3e5c1f77907d6943236c6641babb43e44e186d659d83098648c8173a426d42b0f08a279c5389fe50e07125f9393684328ceb8129b32d4cc047e43aeb50031a60b8499ce03ddbff0b2cfd0daa8c3a1d54dfad430ceee1c043073917302020a0b9e648ecd53d632105a76c639931a7cc746f55e485a57c45353317ade202577f02991736e0b47100cf6a6bddea70368f83e639063e06944ede1d449f04218b6fc711be255af2884d2d564498b88f3f987ec6859b6515fc4aef4734e0d193ea881de9d7ea1f4a456264ca3af9d4c3f557ebfc3570ca963a34e89ac375422162eafdb6691f643b84c87a01ee49d86c8f6bd817c4a2cb7154f114bd659b61b388e410e17d2e52eddcf0b830a1666c0099ae988033f58c45ab0a37f94fadf4b8437a3084adb68fecc5d6048405655c76b349ca30c3d4fc34b75bdf183ec0a777604672d48975cd1771998f34e08ef7016253066279d1aac723d0fd32c89c38bdd086f5df8c0a6c2a94aee2ef4adb0de90336b7cfcd698f6331cc0c4794672af7648a32d985c2e6d7c5fecdc7c0f4deac20c208d2a9386414da38825a856d47d257e29c68f18d9af63c1b1c8ccdab52470716762027d3044a0554c151355b6c2197ad1d6f99e55742faabb7df0980c2a8c21c563729eb060b062448ebf8afb95cbec34b788cc499a1092c0d193cbf886cf7a16b2f91cf6be1f688d4855f03c70d599ed6b904e28958ec38bb4c7f5e5eb98bfdfd4aec10183bf466cdb17edd72cd4352a8976d959a1eaec392f1cb2bb89bb042613e20390c24f58c565fdc0d891198a9964fd1e2c832c21fbc3d45be5a82e766eb096e74d142678178a41ae97918a44240042b7212569f345a28fa31a6b72475ab479dbcce2ddfa9efefe3d7dcd7528e506192fda34cdc39e6e7564114f8763b65e0eeec3c59c7008d6961095fd1a5e37137cf63b0d77a946a82e9af646cf2ca16d9e6f501e330037b7c9caeb5064d2cf1b37b4dd61ab2f7aa61e0e81162697691be81c355f7407f81739cd7f4f4efd0c3079e551d7b50dfedf380d33f8b285b34a26ea60424b2d98ee3cd3ebc8f21a94b2391c33676499b838dddcbc1a107bc78f4288d2eb25ffd1152ab6eb1a75d93621c09b41e00d4b4ea57fbf0b8fcb2b3264379aac1681f058f775c7c63b19677f1ecdf33f187fb91e9350c733e621063b7c1d5582bb78141039fe8fdd8543fdae625255968602f599029974905a7a7386d3862f6ef3a0e55e958b71a0bda610725ae291254a4121186bf3c9b824bad081ee1e3522123a207098fbfc871b708375d8a51c5e2c2c6c7f54866d26947cf2013ed2d9aef9839c18fb87a995faaf6f31c4d0c40eaf77b919fc5313981be59d11c35bfe376f3fdfc394a146111fd4cb19752f9f931295acf1b3a5a3c5b3788b022f21de8bc5eb6813ab19899fc7301d5b18b674cf2b19544133a3e048d5eb067ceebdfc902a38af14681152d4dd1c6cc236f3b388cb300b521994f8e632187198c2a4885d8ff5488fee52ec0702c470dc2583b8936d0ad24c8ba2eb38d0dab92a2277a6d5452efd6095a046c3836573f071297e48b5a6ce30d84d2a7c975afd62c88b7d7140561f99d77a47e9f452df5144584150ef11a351bad49f128c077228caa5aedc98e13b18332ed45dbd2672aaab4e638d0fc9194870b9f2736ddf5761218797a1bf50c9cde5294b4513bee90027b279bf6536645a25d51853ec994d94772310f1d12eb895db0af91d4be639076fd4b484d70414a63ca36710ca22430454ce5e3d796f24f78619ef889de1a370e6b85012c5640be14913e2ce55d8f64ed5651e7c1d47b7ce4cd6eff431dbbabed8a73f1117676859d9ced9bc2ecde00e9d5ae3bea2c8b74b68dd0961460fa4b5871f43d2cb876537972bec3830de341ab86bf002b29a0300e837c408261869ee684eb4a67d76cd4ff2288070bf04af18e63c5dc415826ce5d4dd81ea176722e3fd4c0473c4c61d690f370ca983a41e45f9fe683e01d92513ea0fcd7be6627e7fbf8724a007ff663e214d4ff6f6b8c5987d026345af22fcc495bee9d5a6f3eedc855cb4f285d6b922d11329384cc3e566750a3a77a7482dd750540dc71c9f6751a7d9e93fde535b2775730282735efddabbfbfaeef8d087fbe0a02ee148cbdaffd8e15cb651e925a07639a6ab076477237d6fd31355889260f1021d8e8dae05c550b1267634cbd3ec54c7fda477df6484644ffb85a813c8e68c0e4cf4e722600b562c4767369339bb7637189076c992431cc5b50e15edbef4d1ceaf1bf0e59d1c692cbe1c4ad2a15c90f079bb27670d8019e67fe9e88fae3be0be810f00d7d17cb420e8f8b6fd29fd2e024d7a80cb56610e5b89fed0a592e4de1b3f74bbadacf2e9ffc5750b1105e21f0fb1fcbd8fd54b5c1d215273fa13debda30912f3f867cb0d8e40e77edea7e91fb1d408c4416ce4095e35da81a29ab51e7b86af546f66eef9af4719d3c968398b2232d918d95d395f8c5666677be7d88c6fae893b3968e8145d8b6d7dcb30e1d4238662aba52c2bb8e4355666a192781d03c9305760d272a556a7dafe31f00321f348e4e6d1c782a75081756aeeda58bd9fdd876583cfe84bcf3538acab7eb8edb6fb1962268d111a66f8fb3345e480c3b1330feda08a68678c7177efcb4c542a2b01a968332906e2597d2d5106ceefc6385e488b3740890e5fbba06ffdcf61d525f7e6ebcc8df064ffdf7ecbaa722a01079445def53872cb19967d61a6ab5f6dce0deb1cede57801db46ba49194830501193dfd63a2e8fc66dec259da10e0e95e0be6431d673a3c2bbb3bbc432811001e12a412a7e0e6ecf6a19bad02b2f6944b20013f53e3c189f7c1c6a84d09121b793426fc26f0ed0bf57cdfe1ce2f40c4c0d3e595bbe73cf05c328ba12320f950e6f1491e0150aabeee9368d7fa27b03f2bd6cf75f46d325e103cee18ed6721ec035a45072c4e134532e3233fa7485d1ae588b73b3d8eee6dc1ece5e9051cb5644887b3c22cc7377b6faab6a4ff5495fd9961b0a533807ffae61c0c5d292dc97723782f117528321d0ae4c8e4e4d1fb656e0bc6a681f5625b937421f18170a2061560c29fd858d57bfc84f83cd51137126c2e192b19197e78d1a796f7d7b1d2f439b54837a76cb882eda997dd55ee04438214167d67efbacdbe25dfff1e24a376d6c62d3113b2a3565400faa5ea2141ad015e61fcdf68d127153f58871333b7b6989b47f0eb536017310c79e5ab715c1202f608d0c360dfceade6c4796d585b4f6250ed26afac88b0358614865e969c99b6d37dfa660c03ae7414f13face9b9e7071b93259f766469b47bb6c4e07bb21215210ecf28f22112c54f4a318b07775a3cfef7a2c8a117769f5cfe821d4971a8e84fbe97fd0fe7583df76a563a4e033d6dd6582d245fa928e869040ea9fe7f3224c2c6fa537fae5f4c8f62189eaca8995eb2d2f7ec5de811c3213e0d838479dc87fd2f678a4eb57319a86e2b27e3ef963b4099b19ff58b125e8ec66edc4d234f069b7cf2c535b7ab0e3a045ae4ea69fb8cfe59db97b9de1664e167891a0725af2da306de529a5b5897f7b08403d6fb8df5889d4de430f3dcaf7f3b77e70a498268f10c1c53907d10b90ea08906c01cd7992513b6e6d16b284d9854be1000140faadf9ff9dee55719093448dcac7b069d6ac6d2ad63e8de5726a6ae93278c3f4fb309699ba14000b98bf99f3edcd95a4ad2873feb78844dceccfac3e50f4cf19843a1e4c21b80293f908972c29df29be1949d4df2d3f80d91f9a46b2a7f6d9c8970a9510b4c4b138a266f27d9d56e270c9c7e40050444da2dd5fcca8c6b658718dcf0f05faf315a7ead60bebf009748e021a7784e22940c28a0296525c67aae3ee9332c788fd9c80c73dcfd455cefdb00976c0c07fcef679c02acbe17ee104a710804918400733c35c73f047a7e18c3795f0a947642ede3421e43cdaf981122ac3c2c950c9f0b0b3e6c951bc8338dbb7ba3546d0b87051405d1a22a89ea214b4e9d804be0584886412642f45c82d0092505e80b8cd7bb3a8e5006eae27d3e8148add24edf89c0a6e1b3a41b7923223e858ab1189355d4a4134f6c4d79520b610308c6d3f3e68a4d6028f54dc710727b8396bb3adf0b54819570bc57234cc2685e1e403d897a1b7b5cd2726445202cb529e5fede6530a5b8531d0651a1c9d90be580bd940aaf2aa8e5a17d053dff08cc85713c17a1be54bca888070dcf124760d6e04ef7068042163b41a9c71171bd97de7ff768dda6fee18654349e6969e3dfb8261b8688b5814a7fb4e3ad694c93b18b0fdb2a01725ce10cfae27ec3d5b749a0073c743d30aa1187c8fc7038406c87710685e7e120966ac5a713eb28070cb323a5331d6ad49990104d9c2d2f3c822a96b40dddf904d5112ed78269f502f76c623164be01fbc3cfedeb75c81be735fd60c1b32a16e0702d9d0ac42864e52a3b4666f1c41f525c7f8dd5e25addad4bf2350bf84cc067e8cadd2aec30e219b9387e36ecc8bc4240231220ba487da26e45d371119fa89e278aca2ad1f9d66a46cda1d2155cceb9460c1b0a6cfc826ee1f7d5388120fcc28127cfc90fd494e5cb12b7b25f851219ed6d0d9c7c1db2d010e0e414688568bb8e7fc368bfd3f5e3aa63fe27056ddbd4ba5e4b4c66cb74a1a08c19d2f9a9f85bc39a87f58c46a105db3a6486488aa6fdfca0ee76adee89a0f7ccf92f0cc3b487b6d383af345f451cea03560b2eef8426873cc0b799872315062555302a0c5d874062a6c1d88c9f6610087a42029a98966310061cc727b33ce30d83fca077ba4455892207cb70fc3f2150bb6b615544bd8795133362fc1c5dd62e2a86de2b7e754d50e9ecba8fa6bfa79937a7a5b6d1458f8e06162393c2f99d3f944ed69e337c9b932904ee8b726368c18e73b82a9700b0ee8c55e57671ab7a842ea749c3b5f73768b211d95ce6e15095722e594bed61c90034f001abd2f340e0cff21dcbfccab36297748c7c4de84b55807595f93ba6fcf0c2cc425dc939b19141e1f8182603a26d3a471b43d6e3d7680691fbd0b07bbc7b02139c4e11099f313739491d7e968db629f16aa2d9f9fb5191227518868b0b24c8f21b44e63b3548e86aab0736e1900a205c72553647cda2c8aa705af3b8e0eefdbb265c7826f1a042ae6bcc9897413cfe38400832b5b4ac2d4f02ebf7ba0fff2f1ca46c3a05ce6a95d27a40d8588ccc8d8d7a78bce3af015ad2f7eb35eabb2722a852a283da8636992cb31dada6e45b488d7a0efbb1f89633b92addf36130dc75b29b7d8c14bd4368187fdb03d72dcd059f4a9720978466aa9b4e56b75fa26c5b3cb3cf1138e48fca01f774aee4180f43054f1e9939a4458b3ba9d6956b6d2928481e8e8f3637503783320a690f4ad98a083ab87ec25d0c3abdfab9ddf9f76dc2b52ee404dede848e12e6d4bea2940d604b097d3c925f41d4222cd832f3a69fad3bf35d5854224dee075128164da6ed8a99cebb39629cb1aa7d59d8d1afdf8afa03c0a16cb97c18030aa682ae40e9058cacd650d1d5e7c8f1b62acacc29cb85fdbd2d39f4d9cac96d34b6dc0349641212ddacf755d2146f973eb67f22f64e8c4cbc3fe4882be236c15da3ab409020fa5a3219e96ff15188aa55b3670dc70c46204d3d7a9f2061b5fa965042ef063a280532ec82c3978fe5da9053dd849c3839deaca0b4fe269c319571b78efb21be2d72e5073b4c736ffe75cb6ff7ab5f2b30625189a5cf88b476eec97852836c494d567044dc622404ce92123f54165138f6aefaf38468bdce4e0e1f08d559a9e218bf3c51bffc9f59eb978002f9647e29ef0e0ef6e2dfa084c00cfea91a7323576fd5bc374f572ca5dd400d1c5fbaac3c282f7f5d26c95f67f7d705cb9a90f197b3d82e9074a4e0c5f6cc3f7c9231fb7f12eccce6c7920148333d537b33088baae31029aaa1a5e74874ef2eb7b07fe93f2f365d1de342fbf514a810ecabc8a974a4f75b314e006924581589c2ddb4c26d4a4a31867cefefb0bae702e1852fc536a132a210c6e5dcd5da801eaa86dcd000fbb7e90c686355a69cd71b1b0e1802bb89664eaea77499481c12c2b42819a82d2c410b782f2f715c7ff38fa9d863336f542d57e3d35e62dc39f2187709e2cf5a872be877fb49e5058c466205005e2f9d86fd5c3b932212c083dade674db48aa81a93d23f27031d6ba29fc2f3fd75201d2478dfbcfa338e3d9af22dec25823c0528113b8b10240c730dd75584e00443caccbe4715441a90d1e64fe13e685874a5ad916393a11d3310f8fe98434900668feb77ec46d56310ee6eaa6200590de5c411a29736d278ebe435a0977ed0264726cf2851571dec6d433ebff9f9ae1cf3ae1d6f7c1402d07e62e5ecab61e2a9047ec3c259bbec5c4a6cf9948290b2c680b2b9aa539e3730930f484bec73fb4cba4424933628dbfba0b8c7edee4156f85a04880824bab85638a30732cdeedc580f50ae2f2c79412e5567fd1992f356d9f6ec02a4f7452d31598d68eae118a5747fbce83c04f330cfd53354a116132529cc13c876d679f6d9b5ab844dd615aad8b30fd370a045c661125334792fe779862e7d7396e6f0e03db71ac57c46c0c73771c325d189c9488387ff2960563cc105aa7b8557c8fb445380eb0a0b48b327e82c6c331952345e122e1db543c80c903c4c693b3e9c0524f389df09938872fdc93dc2f55d73b7cee5242058199d91f67d59f04227908a58b8ed98926fdb74c559556d2fccaeac31abff4ad1c809acc6d179b95cb5c3881027c5c5ec5909925e6983a9ab452053c3271971afc3f6ed49122fd6962c104a21c53c564c4ab0d34912c0e8c1f414dfd84b80343a2492858993fc062c4e3ff8bfb02eb272c72053434d8c912db4aecf48b0a22ef28782c3af7d55d22c2ab69a5684a1cda20e209d3e3951e23160a36ca04f7345e143877a7d2b0a82caec05583cbbb9cff89e90876b9af232d6f25e76e332f279aeaca560401215d343820d05edad8e59bf4479fe4af46cb1328acacdbc1dedbaa6c56f8e48bb80c4f05c3d57972816628cf8a482a31b5ce9911dbc5a6c84de27433b65a89c9def64778ebd470e63274454dbe60bc206e27ed493e0c6212b948cec66a9a51b29d3f5fb7e67f49cd7be8289a9f84285cf77a12b1cb57af9cc2d393fc2e4607df807ac77374538293ca5d6d250fcf306fe2f241b2dba4d0cb30792bf31750e05d982c717e0aec9a241b602f3439f74f7d598610e48ad38ffa89512adb96cfaa6cfbe52c37c0d797a357a0dee53911731d579535f2fd3b1ecdf90ec5362f2e8b4400788ea97b52f448bbd6e5109f0354c2afd5616d09e6dccc73cdcd7e8a619a95b7a53f072061460b4812a5f612fc2c4665640f0905e5f5fd1386d30692e712f3307943c25935f67333c9d62e9d894a8f996efd71ad3236643ee5495ae4b81a2847341c6c1ff02fa9929186cea1a494c6f375337b6b8fd67070531eef968f68fe7fba4004b606c1642c089c5ec753550bccfd28080575edfeea03d6cc5ebfd4ab7d1d4b5d567749bd326b7e9505b574d64326230a8b0edc0fbc26fee03dadd36a9465796e274917e599cabe7e5961b98e76ed68f96a82ef40e12a42ea7b508b4dc5a25de44e5371d359eacbcea05d48a5c42a872cc5f753d8769f802a9ce24fcafb0bb63d582197abea5dc043e93c37f83356bc6e3204114716e0c37285e00a3f814164803fd33f31234b639446a8f6dfa11acce262223d268ebfd43d38591ce0ac8a791e52b82c3c32d2a68aa802646610d964c73a0d823152c0ece51d0e101d886e64b2fe3b6117ca998fcf8229f9d1f539bf1c24c4c909e5c8173d8cb21c894ec41f0555e91124c2cd1be6dc175cf4517adb91c85aa3a5ed5dac25befe4537f9932d277ce382914469bbf02307652fc380809cfc2cb4ee86f26243a8c42d6099d128aa30fe1d1c836c2f34eb6b7e564594307a18f7dd8cf6559a45c428bc2ddf907939a2410ff116521679fdd2940ac3650eb0fe04cc4a614ee29888fef328cc789cb17430bf9b1b50663419a54419bfaee9e037dcfdd6b1b93b3523ae4c4368762831a3ba05c15593e3cded582bcbb442f585fee3fb6afb68c99937d6d312acfdcdeee10d23b6de72816ee2bcce549cbef842d118ea92b7457b0674237eb4eb16203d3e7c797eb4d78d4f5272e6be26ccc05ee20b4bd31ac333908d5791e0aba2a75c42b996046beb69dfc1059dff6fe6bb1c006c348de19c1cad5c1741056e7c1cbca8a0a2e999473230e317e729036b5dd695a6dcfeb0dc9499d3669baef4254f21b960d6b91166a1b85f19fb4b56ef1df1432f65854b578bc1ca86615bf81304035652a3897b8c8d499076e65983128ecca8e476d7db1ebc21f68f996bcbe4a0d71b68cfbb5d8da230dd0d5f6876c1434c35f73bd12d617db10d339deb91699d662aca86fbfb70c3278d257c45ebe21d336d48e4a7b3e7eba1dcd066cf99a7ad9f3b41d00b7368ae07962248a84a16af31318c30e1ac56b37da7c094a4566013ac41174b73849f407c2da4cd7f6e59f9d5791dbaac0508bdfbec06d2d76921c415921161b7d0e1c879a4789051613cfd44e78a71e40dff361695018eef643bab5c5196ea72c3b3614d1f25a16296dd9729a353492c6bef14d8cb79c6b6aa39c18282157b1a2dd9f924e50e3aefd0cb06659cfca2abc2c673aafaf3feefad3c9099905f803803307ce3c62d09d45bc54e47e5522d2e6dda8addadcbbb3ff1efd6f145f92574151ee76cc60d33a16205ae96d3f7d6a28fa8e40886458989fc11a9db2334182902b757f4824471e4d2a6a346ad99ab3e4a4bc1cac3ba7c2eb2aad7859cccaa82598758f8946054714e282a0c57133f5df449c4479d4d601e931339e4d11f084686ebf73a6ae21bead6b5acdcde5e55d384a535e66bd8d19f0f60249055b5b18d56e57495474ac832b0a49f0e2c61ba57d656d656c9063e8262dc39892dc87fc8842d5ea9547c5066b0b42c9a1597afa9a882c3f74e492ce4c54b013966bada7a1dd9200e1620b6695e6cec2e4688f8ae799dda83ddd995e45fd86721aa59070bd8307c41645f3c8c28e0111734b9e012c5f88a99f58e753350354a92a2173ac6c2ebaa0c597dc7c6f2746c5e03b184ce12387e0b7ec2909541b001438642bf470cb0d404921e80737af1aa342717d7e3d177571bde8b9e7901d00ff381afc05b57d8835ab1277ec3a5c10258b724d9b8c0c6c67f38dd6d0f980ff100f69d3ff57b27fe311aac7d7a9ec3f83924fe240b94d9a768a46970432e21f44e9c3d222548e60dd6230fe0596fe87e7c0e2ca9085b3fcf06a7b17298f79f454e2dbec1e90443f37629cb7240075c85a62fb6cde5ed4bc8020e0091671b6e69f594f333e92e6bd28cff363a1377b70a9d54c8d46c92da7a4d098becc315d8568ff8f1a59b8645d666179e409ddfe4e8e2e16dd48ddb3b061fb3d028c766faa8261ed0b2bf713e177a1212b36358bdcf94b8a49d32bfe4442d6e1102b984320bd96ece7a6749040a7ac0730b880f00a6e24367ce3e475668c82cd29e6af9e75370cf633e4596836ef225b034022152172bfad59058d80a7d7d1f252a4a51eac6ec621f8ecbed225312d2a894593b4a9f576b816557086be00abae9693fc159da2cc2d8213969838b65043fb87cc0358dc1d905d530136f63e302a2771fb484ae4d97cc6887102081e035bb617438b8d7665da622a8151a29afaa44509abe74a26b60bdabda186b5f42227f4308a0a9f1dc94d7dbf24ed9ece6b67323e1ec28dc759fb8699ce5210adc04a758b335e82bb169d61492d790b402ce44649237b7bc5df6bb25c3a1b56698d9471ba7f552368702d47b15ff1c2cc28034625c240dedfe97faa6148bd5917c514397c4ce32ecf7ddcd9b8dc58885d3c4201c2226111994d7078811decbbc8aa1bef3405213a7090565e7d8d039e4657c07b05841c433812cd2f0c11cea7fa05a0fd607ab3288e4f09521ac683bc229aaf9b01abd5f3e7fa92d26ce75e0087b356524e0cdbf6343b35cef645630fc83c6230114d49e2f3edd56df542b24b0306a726b083e4010e9d69c0b7278ae008abe3595227c610df5a6f0c6458713b6f0a1f14628e18ab9ebfa4c094cc64add574f8172d0dd9f9b3da56f5319717fc5ffb993a735a98665be49e7a036c612c8dea7323aca18f484cd8dbd6148f5b041b0ff3842d4bdc8242858927badd18b6feac30c1c77180cd1d8ad56ca4b865ec12d0f9a4a9e6adc2dac88b8151b2e1d25e385ce04083c246bebf178dbe5df72ac2f6099ac0e70fe575477b7cfff43d81a6a9f36d45e1101952e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
