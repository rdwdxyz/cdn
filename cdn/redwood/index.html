<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ad11424f03e35c0624ebd6b82cf6101f61a162ec8392fca7ab9703a610c702981cbec9c1b7c73ce95d066c82b1ee3c5329458ac4ec43e65de8c42280062b8cc5e1f84d637491a10048500fd023d7e718198d4bf1595fb0ebef957400de663d8e0c2f30c66f155d573a912bdab75d194f11610acbaf12d0091b20dfe80b101b2bc479fcd1b41b67450cdf52f256610c93666a2442ba2ba8d47739b6682e3214673f02aa17a76f2d1faf54704d64f33837703743bd1a2be4b3256f24e706b1a9e56bc0422e2b65f82186229c84db47ba35930ee9e73ae56ee118137265b92dc4cf835b1f1b705d78236ba950a484da30fe2d6abb459e35c8d2599c52265b7e334d2637857734dc9036a63023fe2807b7441fc1e05b348f50995e48a8526084e33a669b6f34adba7f4e9a8356bb5beb7381f510af00a7d2af00fd153ff3149d6075718d6360b5518d476e7ef38c0e9fe08d352dd056be8b788e356827df752c74b195ba4920ee8e99fa2c2b88937620471f059549a489e353bd2783159e611cba55f4d529ccb018302c468dcd441958959ab40c07b10335df56517975952275bdd8eeffc559b1b277ccfd064547fa9e56242a016e8825e5ffa536bd58e699e91e1df93b96514baae8e4377bcb507c689075b6e1989181effe6301d3143e3c8e6a66efa4a0e54fb39bf5e5d6e2b164a58aaab04de8dfadb6015f020a1600bed89925f474ea11370fe7919be39ff614eaa25ca70fe05995000381621498c40879c8216320e18d8580c52bc6fb1c117d9032fe7a263be649f5ba2a4561771ebcf19a2c234508face39f583fff64d93bc36df9e7e95bf0399d1e933b8821fa42ba3fbb9c8c53910c97c7bcfa0764bed8fa412173af84e5c52dcf17a2cd3fa7c7b6db6080a15e88af77bbb3b3990446f09295a838aa7cde49da3f1c0ea26b8248cf62a92f8b30bf5a6c3c761d04e2596ed5b25a3a478424f654031e1853647270d62f70630150bbe8d12aef182b44eb9c1c226031939c74d98c9186f7d3100d704837165b9be9beb95c18862610bf0b15403a488416be1a064e9dba129433370400771d8f02d7f4abd536046b3046bb7316617bb541bc719415d41824d43f0e5ccb2ad77664070fedca8e8010c16a5851636f37bfe6f536e17ff32a6c8e8a413c3a58fb6159090603c4995b4e4aad6860fdca1f7eb08253fcfbf6aa282bc7781599d90fc2619a763267808f07c607ef847b0b19322747963275f0c3988abdf05ad6f5bda4ba71ed293fa50e01928817705128b5e6b80a2de0b4e750447d19e0f19fb7650ce8404712771232a48b6bc3a97ffdd4171b0b05abe5ff9ce121bd2650ade044f6d933a75407b778909398bbbbaa034a124feea500a0f6b4542205282474ac728d64f192577cc521e0ade8d24557372a725f043ef26080e092a41cbde92c33f2282e6d59b754cdecf12a5a1fe8719df605dc73281ea94379a18abda7218719aa6b594268454197d9d786c75c9f4c7eca712886c7d78c46dd961bb8dddf9cfe937d11e50bc01268540e4fff010a641bea894be505d5e94252ea23f446361e8b562f70e8ffa181c7aac60ce1e68372a723c82b6095ebeae5ddd164617cebdeada8906ec6a73cf1eeaa93e71679239d9f66455bc6d49dffde6459957489da186932ab9f70bfb4051db02f9870c8da1636b26db467f84ac4d597334e21044d75972436192dd0eae3d9161e2b11decf0bf4e4c771b5b985be70f8588ec38884631db53440c0ef96b49444dbca224dcdc651df675e4f3acda5efc691c8cb78159b2da6eb7456c97983f4460e0d5c9b295eb4dfe7f914a225de9c0a34754a85fa54256c37fd943972f4ed3806513bbc9397c7e57e3e90f27390c44857f7d4cee83f175a012b611e33e88724c2f6533cd081f86352d402e0732f744e43686527b338ca5334358f72841940d99d327cd38e7e094c3275267ae9db2b2e45230d1c47d92aee224b4f34890f8644c3928cc46f405d6afcd80afe38cb7cbb53a3188752fbf26f316fb693362ab4ea5e60d1484d4499eab03c1b504c2fff2831babec65e8b3f58d547b569c8334f9ba096e7c3fc1120654fbc7acbd910528de12e93f6fc852a5e81c1318d0cd1e3734e42bb16ac72085795cc79a9e76b8826dca106b956cca1d250911a3e472bb7a2800223626f110cccf341858c5b1286d9086492b66a7a87d6bc7b71544f57f97fa786908b74124eee37ca838ca0497b0ef2ad6b281c842f30b11cea4892f452cb14140a79bff40cd69e639a08a36ac82bfbd73fa8582415a19274e88d2e18959e5266bf03bcbf9fd68bf6c54aef5faea7c7f96da9c4910c00e748b71ae234b321ff22d66277d1875c325cd4759b8803d7e4caae2801d2a2dfcc2d83509106a6411cb4db0bc36e3ff398f7fd872a5819af5bb016c0d40e43f64db6d0293af33051c7476042136c41f35087441d962518215f033a55780d04179ab37a0278e728bcc474ddfbf7194dd345afd8f19db7c64803eb0e13b6b6a6c3ba6f0acef9e01cd296f901d654dca925504751cf2c897b864b7b30d14a6a9588f08429913a924aacf4b8b0bbaccc31c48abec7333cea983bb7892fd8bfa5934abec41cb8a9f4536a8e883a323a04d26ad34a834081472be1e4a075212fadc31bb82dd76ef558ceaa3a422ddab8ac8d2b1037d904f59994c2c798d5deba5434a01617fa19ffbfc76577129e0735595a9d08504d4d2769bcfb1e68e5c369425eeec5540ecc961b0a45214f1219b39bc851bbc43295dccb8ec721d3628d1c0a151f3efa70ac27fd16406d2d9c1805aa7271d5ef49f343db6db65f0c9245928632662a51a08648eeff2d2dcd3589998052ff3e48cbd656a21e792370ac613eb605398c7461fb9687d1eb496b83e0d9e21529032c4e31e8c370995720e046a83be4df6c7ac08a1184285d4b307a7cb291d3f84477bc05df378c4d00ab0bb082a53bba74f751842bf53647242e3bd537b320939ac389bb7a9e5bd12db163c83d289413c1a36827ee160024fd06da1fb342524e0f0d390b8094bc5ff86da51709cbb30030e4b344d86568b6655e9da32fa8299e7a9e51253f0d4fde56b92bd977a7d0addf41058fec5bf44d7cd8c4eb26bafb29db5f5e1cbd2efaabfc6352e26766fdb850d8282c634f6496b0f2598c55e9fc60217f9d6c8f0dd65410fc87176d29bf680889c4675a9e1211f5424ba55ec18a86a1f5d53a4dd0afc4b298d04657cea430bd5d9d60968c97feb7d65cbce0b5ffe9af77c5406c8d6a14e75c0f98700c09d80247a1b67ac9590b03ead73442463ffc9fbf2bd9de457c2cbc74f157f4952e2b493171e4ceb4c828c661e26b3e2b922ebbeaf476a9ff511b37dae4cbad1d3d68d987444d1ae783a3d1bbcab02fdf133092853f099a70a2235fde2793282a001384f9243c3896552fa367b58d128fd4cc9a5199ef01698bc9197fc44bc77a74e6b28ffe73599c9b6d0dbb4122e07a7aa1cfd046ee2d45df3906a90e0b5ae1e17ebb1464f276a7abac7a0560a30f88bad949fb1db382608b431dd891a5396c100da3c87c9dac60dd84f5bfcbf89e9f6180e1554956771791e50dad13c1d6c988974431b798b24d4c40a17c1196e07e11ac129e49e05d2e8a2ba707582c08febada3fbd3442b5a31ca0b5c9f2b96c7f041a31208507b7da88a9e4820e0e162cbd39e328cf7d585a3f14ac5e59840ba442197c8ae1a918e96711343417b55ca9ae5ce8e0e4ba87b2839bce52f690fdeb9b2371ee5012f477cfdffba5740da20bab2b029b064c7cc12d0455bb1611d167df14f2d22e7369ddde8ebbacbac5cc9ab5b228e8ed39d50725ce451e566bc078ec6f58c47d5b26e55b33eca896d0171b3dd23597319fe24e99885c051a2cca7d9db1de0edf79332cb84d49663883c10eef7accb20ebafd1386019f01c8bfd1adbe8db650df6193dd2ba0d07a1d490825a4321b747d04a3a62e490f3eb49b6d896e0122c56ead6d4557bc7c835f24243f9ebef583bb254d32f8c47e16162ad82328435624b25cba1af58c9aeaccc6f9249c9ece92ef87f54553380f70e62415ad39b0fe22c8747d514c4d466149fd1768c64d04e05f41d7b7282a245ef4d1ff74e2ac0bcfd46718861f2f2ac0faae900cbb3cdf63eb51b475b3b085262690fb66dd6cb0ae57e8ada7b5822e1ded8376b6f5b8c4a150a938743261b3a6213104b3df1df57c1efbd81c6c72f441ac8dd3fe2498ea0eedfffe8cc09014f05dd306c89f7fcc0611041c217131e6824bc31cf6ae7f11aa51eccd5f15484395540bb5cfe0623b9eb34599ce4b8c3988b8872af72d6dbd2ecf75f7e34ddc18bb513f7b06f9e2b6745fdd6f0a595228adb431ebd80e9300035022c6936bca0dc0093d8fb204651b14489aa5e89e58b9ebec60d350521b263c412e57679d4dc66342034f816a69c1a3056d05ab45c5fb9aa997d365894be0783e2f2f31843ccd8a39cd98b023594fd023eb82e99d9fa0e8f707273c51ce92fd84fc23a8cc28f0679405fd87d9bbd0084d5310b2dde09ca3a25333944ed584e1cb80e7f638d8dbfbe451604d9cee0f5938d2cc69db2e39e12873faba14a79b00b7733484a72752b5632e6bef13cdc94490bab14143dd93eb2617e4536d4f613c58fa89ce86e6597750a61295e554cc23decddbd31265ee7cb2d8cf3e4aad65fa3cb10d58a2362e73e6e530c7aee78a11f2d47b28199bb94590c1ef5c49ac6ea999d7ec8310f3428671dd810bb266717faef7daf084b2d05da2adc63a3b0999c71b9a9e29766634baad35bff5ffa3997ae9739ed3ca873a01b69fabe68fea5e053fb4253a98b16dbc185d15b2f9c4cba9ed9d7077ce7af4e437a452f8a9ccf173e5102fbb2c7d7384f434bd0f652449ead67dd0aebf9e947d8adb652e3e55454b4b022e9a4bf52ebce0aeab83c24665a450d08370d1838c4ecba212a9ead7f34817579c695b9d5056288371a492000ef3677363f315216d51e28ba0eece1a6a207497e01a1426f9df027a5775971c6611030fb5dbec9bf87c289511e8ed6cf314ccfdb59a07335992c03044291f9f85104c5a8d3d0fdf2b28d46cbd11dd8116329b62a957990bd26634ce089a8b0998bb7d3e20f5724269de731f881c934a796108bb449a4d091291f8b33f69752ce065b07d57cf8ede67feba9b9a52d22aec41b14393ebfcb5ba5d13a02926f548421c40ca1f4a3a0e1162cfeaa9a3887e40cf06714ed98e29efab4224e4dc46c6b37e6446df06eec43164a106760e6b89a5f277ba889d5ccbeeda3f4ecb401b8ab82fd5e7aae1d8d8cae3b8efed0583191a11ba676d22911e96ba7ebda1b64e99e1141e94d1366d83b637f2ed09db8396b1491ac72755e7307c7669b4c33d6ed5e1c394e8f1b88f8f51b77480e267378a98e2bf7ed02829f62dc28e008f0841f427dafb77a10d95ebd319d17f486f3b15163fa0b12c672958adcdb5629b332028b832ed935ff2296afb02425a1dec988ee19cd38f39b4ec4665280ef50bc68e64743d3a90c94ead842a25f30947e3c380b8afd7bfec426b01189b1054de6bdc9dccf0b14f6a513ca8f376c69315d564e72e04070d32d6257d11e8fa83982d823cfc1ab335d84e95f6c5ce4ce23a9141b4004a03dc452e2fa0ef9c2679d3c38a2bec849d212174bc059550605bd95c822e7679b552f4157ec59f97d7d8303e89f1eaf9bba9e303da04c3f9b70c6e6c95daecf0fca8b250b89623a89d8b12b5f2cee9b2fd10e05ca17be4bbe2846d554df9ebc717f940d247878abd118bc441526f9c548bbb8c96655e396f79af574937a47c96573b3b58c224a220d7a7062641077741fe64451edc302c8fe0637d5152a10239cc4b93fa8f2948d0d065b51ddada8cbbec676c1cb2beaa7576be1ad62910dc003bc19d0cda3ada6c6a78bf543fd6c6f38b1e09be01892712a9f977ae1a6aff5f74e44950919db71cc33119744c932068a57e6bd615f703aa335c4628ad590437317fb3f84b3fa04082ef6429ef4439c01feb76a521d77fe0bd37660ae6c65a1432f796d906594c8f32f446dbaa4ba6b8f4f79956f57f8b7dff2cca9dc2b2694569740ae8bda8931471b2128016ec2fa8ce9e6add8424b53fd034e506fb9f2b13c2dd7a4327c5214bf0225243081c88cf8487aa4de07fdcab818f0aaaea99fd666751af9318f7c269d4af9fd2089f20fc9a7ed255d6ad65ae6e5fdc239b5266ea6f7f6cd53f4dde09b0eb9a57cf774fdcd67ec4c7f5bff05ef32d0633df8a02ab21421db2d480f86cf04eac1ccf47f593aa946512090801a95fc57e0ff32adebf463be38be074d1b46a6eb0cfbc0b51599c90c653a9e6bce6f6ea7b772cc3e71aef46d3876fc343c799fa42c047e06d5cfae5d7b1f25e2f354850d17a678934e957079d292056e0e6906fc2c3dda3382b6fa843ffb5d3a9b770d689c419abe033763ad041b4052edb9ed34cc8734a33e494d11fb8e4fb603b9a6edebd0ce3d310d904043936762a83b949589a11e4a1da846fac41cbfe8066a9c6d52a267c20d4e2c47613a9943d5b377970d2a3c44523d88d391d447df21026edf0bdf17785925ebb87a8c954d875ab1b7376f44ea614057f60590d52a63ba803d0eece20b8c95ea5033199bf190581105d1bf86d17589d5375bed139ba8babc6d95f88a6d50d9f8e5ae5282335d69b49e08a09d03c09907cedcd9c56ad76c65211d9db310c2baf3895ae0f4570c167459e7b3f591c21894eae01844e750367e716b6a4c79f535854da76254d6a07dd211912a51ae83a3c3bb3aab0ec8d3294285c1ad4ea49814cb5cba4e215644bb70c5dff7b16e0ccee4402c159cb35dbf2e8b5ee68515ea9db09c71fc768a55b3eecdb724e0c77c3968a6db000a79f4aebcc54b839261f79d6207f2f0deb52077745db41e5d4156e122ec3f8e2c6542cbc26bd0203f8d0512a07dc8a29bbb0ed1d2a6a95ce7c33931c20595b9b8b8070c2b63d69a42db789f0b075c74ee1b71f0c4073e11b219c9925e8cc381804fbb472de6ebe09f1f41261e4d79bbaabd57dea419dfa7fa9bc0170d7d7c02868810c5ca6b3203ba7715048cf5b1df6f544cb9c8be8ba04ca9afeb09edf4f64fe42751777ffab14743b161dec3d484013fcba6c0ea536dcda5eddc997983a0daa7e459d0bdbbd3ddf80d83348c5408a4e297b3654dc57c7fd6d251eddc57f3e25ed138f8169815b8eb411631dc522285bb5138af1104d8b2cc67173c4921b9cd309dd4518818f4e2c88b033f8cd129d73632b82d2d77ac5473d68f371b65b5243fe488ce21ca7948a7c5ccfff3328d85b581c7aebde4a69723002f46f705dfe078005431fc74b81e49fe79260fcdf616ea89380ef5648a0f217d8fa4057fc21d74d6a4aa730abf6b6c4a441bc1053666578a78bba0640dc25f64947179eff7494e233ef82cb254d2daa8e9ccac7101a330caae494bc344c68eada6fd6c53e0a241b629a666952c5890b4d01fb87e3a236408a572ff5bc462e41f4b8c4d1dcc20b72e9cc966ff8e300c546bc88915a1ecc85d9a8d35d12a3c071b9b79903f14f1c18baf7c0de6726347888fbc3d4d672b42e11d76c8c7bd268ab84d8656ea63786eef0c0b0effc01d07b78b3e9d98541061eea89935c8b76d7f892d390c3c4791f8c2284740b715242f799687522f3f76526edfb0ffb8e97fbe0a782b5f5f0c4fead5bb3896b5d6b3ba87e955bab84254793896c81ce1111b8daed473ec87473ff09e73ac4c832fe457661db9d39fca4b3901da182a30ac6df580b6de2aade0eba9737ff59bf66dd9ce9e1d8cf2c4c56ffbb0c7d5321673516305941d0247b05b63d423ea485975e4f65e50c40e93f2be2b42cc931400bd6087a3f847ced641dc507c9d4a746f0bd6f66b2928660118f61ccbb67636582989ef8d8d00229b0a3d31806649f3eb2df9d73f9cca4d80ef77f6873a025673fa53ce89c5b7893265fd601e5024554f38584d71d72116997d55122d562f7b559595ddafa83ea3fc4eeeccc3edfd1ef40f2a208189d056a50c2b9117003b95e16a639d904ac403af6040b88eef77d0648e4902731db3d89c7c0585d8ea0284b178e0b25c11c329e6776a3b296990004929079bd4e86115000e091fba7b54992bb052ebec984b7ad6e1af892d64478ee350cedf3e5d5211b9e81d45d4da66fb6388a851b159ae01da2ab5d34b92f863b8ac712d5427b23a74ead318c8f22d966ea786fdfb42d34342f0a2e053df54ff96d82fb12d82d7dd76b863ba5d062d4a1b4362812b62fc62fd0d7f7c63d417d010e5d35f671b1299216e940a513ced50ca712567fb8f453179947d2ac92b2633cf609e0489d09ecfa1fb133f15d90709d70cf160e72bf14b497864b001d36e47be158e535e07d070f7feb578bee9a0532c0628260c499cab80254e5cd4213e5eae41e516dff1515e707831e3541ebce08a19c6afaf845638e34f182a645f77a8d0553dafc999a76a01040188828461c3239790184d59c5ae7d83a0d7314e035ad2920f40c6795ca1903b7661fe8f12d76fa9076ef5e8111a444779c1daa5fc190e8bd2470f0ea284fd3f1b764179e7f23a150f2a0b06ddc8c9512ef0f54a5f287d96468dab83bded43157cf6618401d170462669bf44917861a5cfe225f8c9cf9d8446f85002ff258d06c69585d050491dc45ee726cd7b5322b4ca23430f533a367e7b9e0f2c37d324025c72307120805d474785d0b1060b5ab0f821c9102452c67ce4d422163886e44475b8a8d8b3a12fdebdb5300fe41cecbfb26cc44239b983812e9b7dc0fed5cc61cda618fc3608b7e048550aab4a8624863067bd890cecd4cb1f34d38aa77a4ce8c7b242ef4c3f4c5f7f16a1f74b9cc64731cc488e17b09f995ce6e469f67dc48ed2400a72b12c1ceecc07960305285f6fd704664a2b8a2d07f98ddc2c69c4e79a102dd5c0ebf6b5051baf7b916b26ccb0fdfeb1ec1dbb09f24b5d345d669c932f27a5f6631e35474a0325030e78748925e97e93893cd71ab6013b736c6fb8b53d3e612b105718c7235cb99909a3ec33f09a63bbd3d748590c0b4e33a8f311560f3f5e77712c757d843e51b9611165a1857280da2fc0525689ef4848a5d06769664450f8e23f43bf096853a6eef0ec6ceaae380888fb5b53f2b9d82e7bf18b04a3cbf9713143e57111d148f9ef1fae7d790af935700dc92bf35fc5d8687a5fe984240cce0640800e2eb6479b1a045304fb0d1f6e281b2f070adc8e4b50a1e8d4420ca16eb1a109f16cc90b36e650035b39d2775e83b3a1d39dee8bb71fcbf1cc7d69ecdd933b76ee0eb0d40de28eec4e1d4c6e257c041f1b65c3020f290340cc759774be4ee1ff8b9d2b23d2afaf5cae0c0a4b24fb15394ac0b917c5ceda7fbcaab1f5aaf8bf3a361560431539896001f1ab7228482afff352d81c37919f936d13d2e16a9b9a1e462dfb95b8da281cbf184a9eb555d073e837abfdf9362b2feeedfc6caeee627baeccb022e0bad5322d6dce78f6c5fab2422da44bd334f757ccb4911023092bdb89868eab890c71f1b35c83f52c9f91029cd7393c47130b500e89935cdb75138f1571d74a86c1fa9fa64602e4abef763ca0c35f23d200c56f9fd35fe8746415cf3fdeace80e4e45e677e5f1b92d7ce46d48c337eeeb6cc9e1c1f109a9ad14a6d848b41863304c36dc2dd485bf23f1e4f239a3be6c412c3bf851412afb19284ab45a530292200293321ab5c7d0c8e1139c1063f036621f83d83ae92f65f20a3695a46aff323733ec8ab32e923b0f4b3455f6fdd06af3ceb292d6783a2aa9f510e16831ebdbed3a2417b2f4f84477e85455de1e8c8eec353e6d7993958e54c069e1930c70679675303eacff8907338b58290bb91317ee8f3eab1c0962e0af71043f1763b5b86d5cd733576cf7a5ad62fb3d1ad48342e3ad804a0ac29a9fe92d271af57d7cd5e6ea1a3c0a0fc52d01300f976f7ce96555fffcbc31abbd6d9b5fcaf0a4b38dbfc5925c78775f1116f65ed7c51ff841d12d1ec6898c41dc734437fa6103216db98a615371319e11841a7d33ddc9bc382d63e0236b83d6d9ab33ac2e16977ab04294eac53538feabad257f478c8932d7e8ff01d138420574c32d4f94daae5ad97793ac3e800b1211f39b69f60c582c93eb11b9b21e0924a391f3ba19e5b6a42f98e01d6c073b28d10abf025440f3839a668eda95edb17616881a1a864815c319f19bd9c0227a2cc8d63af2751aa8945c6ca13208ca44b0d65116f4fd88e5a62b41761b49a8cbe8a014541292e63c00b1cb2a2c6c6bafd474ca1b24184ea2bfeacd3cf0b3bb13f36a57749eaf154d186adab5ffc2519b671cea4046b90f96f3aec976a5ab4e8918b8223b679f102c61971d3ea88f7f6c9fb2f2b3c1b2666582757eddf296aba1875cb50b0e54508495705c18eee78db42923c3cf08ee8de16d08d5d25adcc442faaf1e0bb50a4fca1a90dea8d8b885f94934b52059b0399f090ebe4f5894405761efdd33189985b2e9458e3040e35e571ad2ff30c3d3f6d8c750cf86c483b5d4c018634a4d4015db7bd9d000760a618cc9abf43efb4739275e75247e5165c4f35ccf0bc157d2802142ff05c6b49514fe33b20b6e0398cf3e787e2e7cd32180f7509ef140b8985161493d9b6b9bacc0f4fff4b6be1f1c238d132865332eb7a358e4285b13cf07be69d337ae598c0072a5e3cb9816717848f1b9c48c50dc9182b784aa1432ec5ad1e4d2dede56ba4d07c3a78c96815df5e54cc0b5721886f6e60fc8e98861f3379b41667908703db88485535270d5e438860328d043312f926133cb367d0fdc76e67a7cdf29f3ba653a633953602f8b83fd4a59fff64fb6146f40ae53287762b8f51c72dc5048ae7817f4d1e60979a5b3a17e42b6caa28334d43f70504cd2e8e1fd28250f97b78bfc51d75e3a36c5d2e3ed92d97e87c69859fd2324ab20eb9196512864d6fe5bda84b88fc0ed0130350104ded3bbca07fcd50b7a3245c35bc6070bf28a8cefdde9fe9886f2734dcbf18b48aac3d72cedff548408b25890e75a1047d4b83470b3c98918f3507fca315d34d4b21c744db9a1e25b8575bdeb8b09c9e6da788b113401f7311fbf6ee7ea123a746c1b4f0c93c44c88ba12d5bac10b85d4eb913ffb7d08f6376b8365f12a4275f2d40ec3ab691618b89530f35fb1fd8dbc7cf11c8c41c64bb03c5175d9f173a257898775e830e0b55a8c76b0f248d6f8fb28df7e19964a34ede3a679e12451ad07360b7a410336500b66779568816a14d6bb6e6f7f5c93ff7fbade351bee51271f7d834f5b2f0bd715b4017c019ec74c0b993854acbf82acf97cc75d4c474c8101048c9b9760fc9b15c17d5d5e16a9dde300e0755549b8200f23f9a2fb293bed1d1a0696a0782a34006108128049e692e80c10cd5d83e4842e4524ae1ab21ae2ecf29761609e9570eda8edc4168d5f75b9735c5b174033b44ac8026c2e70278a7b520aac26e5327573a48eb6fd2115773f7504372ee7948481d98e21c778eca427b068fed8acbfb6bb7624cd9b5a64e8cb2e35428aefab476c95d4aa9d69a0c274dc2c2e2cec5aea04126de7cfc86edc917ed7a0c1395890faf311aeb554cdbbc5ce2cb33ad942a4902e19e880b419fdc8480bbd72805c4c74210cd5d42e5db966721988cf39e9bb1fd90e4af9849b8bf7eacef4bbec4c11db21821d565f11b5c4bbed3e829ab9e9b24768e0a15d9b3549f28917b7d63a17b552aaf3a2d9b5cb5cf697e86a5c77e445e53bb196c587119a6ad69d8ccd8d84e8983256a899904e1bb01107ab79d43f3c8d4988a15e92595f9747593de6ebac9f57fe79a07fd55c7eda903fa8164249ea869e189ef0a0b6348d872eef11678a3102df159ac219cd52b96f7c7c1233505424f32791c773323b3bc089cd3615a12e7715ea74cdb52313b4c842add7f12967d970abf479515fee986f248cf279db97ac55ed00cb341611d9bff85405499f7eb546abb088bc70b48cdff034e21e8ec45c7ae80717f098ae268604562aced05f4b471b580ae51f0678708e53ce23e250ecae9f2ebe87b23e6dd5a358e873702bcdc6f46e03dc34505f4d9def97ed8a134e1e776e661fd0182e761b489708e9f7ab5f3e90c354f75e0c0490c8855d32e536d313afe2f1d214074e012d2989324c84510a216d4088b9b27ec7886a1bc2de4ab51c402f9cec15748a9b4efd45a1c0e55f0c4ca2b6b99fef580c0ed8cf94c2fef635f467ab099eb8dee857ae6c86d9e61a4df5302a57337a61b29d8e05d2a0524f31c46987426da9ab4f1eb2fa017759a9458cedb63118900fefcf2641d15ac3ceb84ba0cc8787117753f647ae7e08c68909db2b3bb0ae0cde56b95dbbd9042915c748dc52350c37bc3679d70889863691a06ba9dc96ca7fc72d161c6a4545b249d6ee5ffda9b767472f8b0dc83a15fcde327d7d021574f374c035dcc9421ae7e95d2dcfa24c5f61973622e07c78bc6e0ba12a44c97651984e81df042581fef94da09b9fd3006b18bd4f37d3f66c5d6238e88a59c3fe7b51f2d4c596b7fe9396390ec6d52b9441c60942e87ed29979bd0d4dea527f783da5fc6c5700056a9f1754fc2f7d94f2ce615e0e32ed6f543c8f3935236cb6503b48d45abc1ed2cf5b3625cb6365528e16d0af29dae380b4356f55a9c7ae10ffdef5e48d695ce0e6312ac42babbd01cbeb92ca923684cb7ad28bc6c2c11f40bf6e82b1aad3785cae0ca600bb3434e52ee2e9bf42e72544c80b0450065a8c39c210b377afe220e86e0d9bdce4bad66aadd46b76ea259ac1ee070e760ebcee98d63737a9e74983d80a93ff545e2de8c890edcf46088b930029e166cb9f39d1daeba9db1653356f7928c5a941b23f01090a582b4bb3422bb803456d6e4e17a42e977b3bc0b3ed59e1d67f9fb5ffc80528182c7c94591bae67c3914c7fe60ecfb6c4028f8df94538685b7b1ba615226820d955d3d9bff5c9700242de9e8d4fded322b0d96437061b991163c3c7da792e3d0d580318ef9f61aed24c7d4bf2a69c44be44f68a5ac1f2eebc7612fbc1b8bb84879652be75beb29df47ed08370a5402ff6d18312ee3938e6fe2ff05e9a6561de9101bf05ecfa2286cb4869ec067e9b87f05b0a2962d8b831270e595099584b9fade51adfaf966cb856ef2e73ac466412f92a860703ae69d85296ab3e3ded6b75257dddc3ff6754eea0a586e59239cce5b3f07b6e4e2c131041e04064dcdb9980477f21c87f4ec2c283d6eb9ea6b2535a47fc92364f5a01b2997a42b79791797de43ae57df66ec210782998c4d0122bdd4192c66dad8b77b6f949bf2b05717777d1141cd009d1eaeb381dfc2313982ebf56490bf7393eac83bf1345832bf9a3a2246ec37b8056775bcf880df8d019e6ab885b778fd6f64349eef88a44f4fe956f9235c1142e933c408c954540df46dfec8877ebc81ba89793d14a2d5f7219cd968978d60d4636dc16cc4d86aa1754b8b3d2751a17077f5087b6350e4eee1f8ea24a497dc1126eda9665c662306a9b72f23021a5b94af26b6ea5c7b0a6e9528d493ad9514c970ea1dd463a14decb9a0ecf50b54162a0a164d798525583075d8f4fb68651509991e5dc8b867dfdc3e2ff838154dbb80daad65e9b69c73af5dfc76950938d4a32aa18273a4f024cee6c23fccfb7adea271b2f66f9fee961b4c501bc937bd90dc8e6a6b3220fb535a37cb55a66a23b0f1ddcf57d50ea9511ad539883ab9e88670966592aa32a68857277f8df61abe864216c234d4a9a37cf9b84c4274a93239d5daa637b1d607511b07aeecc67ab64c62c25d0024f61383617308992523a6455a4682498fc3b59f74a4ce38bc5a28d7cc470efd888eaa01bffc350afacb8e868cb816889ad4f20ad05ecc70a7695edb7d9e0a51e5b68b91c2e689707c58c21af1d16d7af1cc5bfa7929d79e5fae04230faa2e7973a43a810c53c06dd37403a17ad86dd5545fe6b7b008eadf35736d2c7e2b27bceeabb6f09e16bbe765abffb30fea2c75979a0c8f46dc6258aeca6ba9af7d6badcaf9b499cfdbb8e500f467058f3d59f4cdd8ccd797d301564c7ce50eb141fb386f9a5bd0801fa37d4cd1fcc2e19807017b4eaa539a3c6b7bfe3d382cb652378e070e48478a7aa684e6c6c1582e52afef48d7bac4f8d231ea0d238e4e3ec739e4766c3cb93473c3bfbf057f70933ffc8d60c113ee66727a56cff0c527fc8d08ab7a8debf97dae8803b636ead436c17fd9c4ffe2188c715d601e7e25f915c9e4b7854634dd26878dcb999d4e4645e841bcbccb186ba6ecb083b87f29fc72a8418cb09399bf182e2460b51672b76c7661e54e227cdcd29c5032998d1c03060e7e52444cf84f107087cbbc9f2e2826c9fb8fe0457b7f97e34f9813f6920701978f1c72d5b01f56008cc88ddca72eb229e5f42ac1ef36f0e22d425930a888f052778365055db268faebc8748a8172be6090fc223f357c5f157f4e7a3f15c5c911762020d6b297d762ea39d1eea61e615a2d8b54f89456784691ef4f7240d3a4232d7d9dd0c2c2543a43c364839a3159f71829b247b30028cbde1d6680c6b1efe9370c509dd6011bf7af41f9c0020ee551c98516e0e68f614cc8e1c65e36e412c4c502b8fc7949b562412d56f0130e8c2e479a6b37c464f1fa7a39409b48ef72329341ff786576151073cc7c8901f0ed0467e044cfbae2cfbfc6eabbae8619c676bbfc31817fb048c2be7d1e2f3fb558f24816770bdbfa190004fd853acd01ed6673964e743a60a9ef45838fb78ef6ea1a77d5567dd68b9425fed544f1c77567b0eb82581d44f741956b03cf07001f903cc37ec088f20a8922ba5f786d043b2d2bff4d7e56d4033ac2d4cfd6db7a74f394932c5fab24c1f3e550312fba760dae9d6e7528a59ebf246b3113e48eb410e5b7c76cdd7aa30aaf0ca4595e364b2fb48d82376ccad28114391617e9d4958e5f73c3032d778c1c9d040b3d4c0bf5422f43d050a8477e6869af58293e51f9d454b15615a4c4b53cc69e9ddf6dc90d21a6cbb9a84e2ee34280466fe67b1d9d2f09699b3b84147c74a596ac9c38fa3e072ac8b411289aaaa400753afdbd84606b5eeb622821c98dc9a9fb08defb7dc02497d12253ccc7f528b5d304d2321ec8d3c440c03f3629e9204e91a1cbecfae7f1000014e91a086ea330096b380fc9178a362f98da7e0829994e0166c02bdc0757a271969a7a4fd9a7a2e969a46a6762ad55d6cad580ba8bd817ba2447fba30139fc15dbbb25504d4807b92505c6bee5a6743e1df6d12f564fe08683b9f2ea198e5811547b951ea62b2dcc7d50539e2d0ea5cf58edb408da7d3b3fa05598391da4d498f62afea8c8668294263fad2a6bc18a5358677e1f652efa736f397c2860765159cb5287b03cc3c6858b2f2155795987838b3787d63663bcb8e0df2c14cf92e07cce77206a6de8624987b2e73c6ed2913d5ec88a258959fba2fe9ea188d2a19f280623507456d3bb6d966f5fa104c562df5a2c0a6817bf2815830a15c54bbe45a81e3c6994b3bb25337e1f7de94192a05e90b6a9b3114b219ada8e5c65844ed49b63b536e178c7d9549175f657d5b0ded558575af18b29f2eb1b8112ba3a5afc94bf8b6b6656e510ff5192017d51703e91d0f2f9a833b2e0f87b9f4e78a91a1f95a9c1da136ba2a9ff762b97a46f4b255c665e6ce954b70c7e0a6d4b9193b02a75a41114aced14ecc8af09aec92731dea5accfad06e5f56bf49fdbd2aa7dc99d8eb4a46423f9559ed1b869b1f35973c12762ed9c4b92473b594dd883d736a93048b49e21e84cdbb431736a5c2677513f2b8257b8132fa4abe46dbe126eff08af2249804a540ba9ccc209cce041fabb161d52e9379b2a95b245992765ee55cdad910ed1fb17579a8ed8d312da5be7c433c34474631b0b9c1c50f3cd6eec181db3673accc61b8a96f21f0513f855577f05c476aa0892f7c951cdfd80b8a5f3a633f6fb89cf3ded1acbd8375bced1978e83fa3aa5386458905d6c5e8db7f70ac7332f78382e63039c152322c16d86013cfa27bab3943fc51dd73110d37f4adb9fb2dff9f50346d5e589346b156cef674792ed730ebabfee5139bfb64abbb3c187fec5c267636815c80079986828d4957e3185561f923f6c84624effaef1e49c5ff78cc73373bebf524160231a3f1be36fdad6ff203a82e8bcfd0ece8f40843e80ff95b79fd446087e6e4c70ef2ad9146279f0c956c04f292d2939d60d4a82b99c3847ef1382ce3179565581e4df392463c2ed3e4a0c75e5a24365d6c45485ae283bd587663af595fd7427b1c1e13161c4115201e5830a2a9bc26bbf82d87a0a4093a9bc6c48e7bd56cda68d5494b20f62a789d4e15496e999a793a98bf5c6507e51e94832a545d64e9ec31e447dba3dd07a7f9004a5e16a685158bd7d7a9c48c6e5d2e45b215348afbd7c21fe182ea42504a3cc19fc8ba3b9f934f99506df176d9c0fd6830475281c66965575277f720640973b0be3b9618687b874a3ada46bc88194a13e3e23f34613e41ca3b4366ced9b1aa21ed429ef7ec13360b4c32fe2c6a433639ec20f3e03a423e2cc3fb6c128e1e904e926657c6488ed92705b7868100e6660bbf40dd0a3a1aac506463562dc6b3487228e8a193d071b57c554fe290cef25f95e934f535cfa2d69c5a10a64b73d95fe70a65e6913016f6eefb12ff6e6ccc0016de98b696b21c20174680264faf62870c201c5dbc88e0f4fae30833a560c2e2cf7a522cd9a2f342a2e8e446d39c753c20482fa1d58829bc68b3df2f8d6bc4737766f966c5632dd37bd3ebc8460d1806a6331e9c7bdcd7cb0952c666c8cc78821af7254ea34e1ea92bb4bbc7b2af062a9ae578a9fb08d6ca164289071854790b127e914ea70f876ac4fd88b0db80a11d8203cc08d96d6e3940fc9620cf58ce1d8df84d83989fd3293f75db70aa27bc4259ad4dcf95bee0c5af88102ebbee04de83a75315c5aa811781bb3f48583c65335f4830bae0601e86ab1cf96b85ade369e3e516f3ff4e57f63993e5ef92d8b71793b3bc2359e89cd51bd730b15dd8b3a81abb6e99f93dafc7daa2552e323d2cecf47ecad923f7001da06a31e3bb2f2d7afebf719e9a9e2a72032c4351478f7b47c21f3390f71da45a3ca679dc623e6aa59cd1b9797c768e8a5c6bf447b9c8fa8b21435c66a84deae5051b5b915a98f1fe54ae36856fd2e9b6cf483cd34781980d25b41f355c8bf32a67a0b60eb3a82da3385b1c98627661544b78897acde1c3c646f1f7dfe8744a02d6ae2911d7fe4afdc01e843c1b23bfa6131cf4db1be69dff34ed12e9fc2d860bccd0e82eabe6a2b03d08ebeb77241d9f4dce2f4eae2ae09a4b1ff57a028224d7f3857a43756c73bb46fec9373e459023a2e52105097984e726635812b1cf7dc9f0b9e8d47f42d2cd78cf5050be50b0be99dab790688579bd3f0c1cc384005f65289f93971ee27e8c93f363b264f430e8c0ddf0bb4218f12194c42a30f63635b4527bf4a703b9529e5df4cf8eeb976c5c8c53695580d4707529f5fd14d2ec96b065d1b1dbf67d8a4fc3d9087d643a85e59b6af349e714be0db0baa5e907b18a4a87e5302e596e2491b0328efb2bb7e092a5c3bfc07754fc4462965fb09d03b43227c68b9a52c069c6a5f1985c8f447a4227480c3fd338bd09072bfb4b4ca66ceb1977b83d66225c50219128357a741c9bc93a380da9c8648e0e298e7ae6f8992e410c9f71f9aea0dfac31a8229fb3807c96f5b47ed002a245ba1d64e38515ee6ad31c963b67a1950fe052d0b2c49267ea4ca22e47a048b554957cb70d79efc658a56509aa04a0ecb4c0d47391c4581720d8aad21c41074ed873c6d067a5b34f15ff60aa2f1e20eb1c96283e6b7403b1b3bf1e2a6ac237edaa2be5a3c19ec66fb6ad04f8890f9b683980f424e393da3023b281af34270048872957b30d268a089230b0747f4941bda","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
