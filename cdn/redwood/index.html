<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1a54f294e59cdeef63bec062655a52299a2c83baf6acb58aa82d91cf4162a6368941864cd0a1b8a9468bbd6c84f1284cd6c0d70694635bcf04c9ed53b00728cf8ddbdf18ed3ad8671a2d6c1e688b06a544d5598ee438d362427a57c4b221afda41edcdc4daa560a5fb6fab00e2a904cdb70cc88c4182d52013859ab33a8d4acd986af1a9584d14c0bec491784d02e211b0df21640858d890b90602e2401b7bee91d60a4023de0610d28931074c05aad70c264d95971e9bffdefa59ddcbb97d15409cc07150d79d981936d355a4a66e6f5e13e05402177784195db876fd2236ee5722583ff3bf9fc0f3d992553c53551d095f1de1b58630c18008ce797294aabbbd47161e035cd25db91842595a8b4eae52430e972c04f54e40c6d4d523dce12eac1489a7e709d22f138ce63b7065d68bdaa92886d3948bb8600dd9e4443b24c8ef8936906e2da32dd9b3de0ceb176e1ea1c81902037176a8a4724ff8651d1e4b377c237f7802847d78d9feefbd383e4a829a353c971310b0acc9d0ebdcee3325f17deac0c93ce97ec017ad04355a7b82ad2ff5ea422f18bde1ef1753a02300a3034fc215ed1a9b5ef636466e0c0989dc92cce2b856d3cd1e4b077a76b12169044b0068b4cd46fa930ec7a98272112d4e66f653322ea7814f5f2de23d11676ff285c9a3a69fa54c571c43286bb3b84420a35db787f44f1094d3c5def69a1b0ca973562f8b6a6e31a374215d2fc5fc03c255f16230c010d3cc67d6f318cc1e520e5562e13b87e0be5d0498024dc924318ed0536c73cfa4c38a9db6ae9eed7d8e82dd001cd4578c1f796013242676af6fd631422c65b9f9a548c36e2fba4f8a21518c2cc764360200eee685d341217584f4178fc7fc6317f229338bf67afa064b1c411df542758c63d00c3b666df614270c66bee96c6865043e031567b29f038730bdbab8840ecb93e85eea8310740f309890095b10a1a0068a70fbe846d8296b01b1349c9d5118c4ecf0d533104d5d66bafca7b45fbd1515da8a192a111a0cf1c4abea412723fc7254abd4c1e9cca1dbe34a6c3e3a9cf9a50c4c9b994da2406bf727e8db8a7a4ad4c6e543012863584d055e508ecfe52a3a90d291907bbab2da83f3a447e28849d1c1bb7ab40d7b49003a6cb5cd050113d9dff88fe81605dae228ea7f64fa5d8563df191edff6054f096e593a41a9f98b22388ea96886f955aee6fe312203d1f40b5d0eb0644a2c2e732a25acaf4a1ea78f89957235a5323c43b641774c151d82ac87248db5982d94db5cea7542f1bc5636e8bfe3b27d1adea539fd0b9586eed705938bf09758412494db59268aa1d8f97670f1bb25392635a53e15a894ace9e02e3c4ef7c1b9df981194add11ca1bc3f2b8705d87cd4c4147403d17b4a22393fc7751689bb34d51b7787de99a9e84727bf124f547adb04670a4d6c89ab86eab0d1f97366afed7105ba51f7a89bd398c524b6ce8b50836a91a50689abf7587ba692344199a96e9d4800377125265f5873214ae0fd76a424de49d867cd8c63ef945fbf69919809481bf796e8bc627c16b0d96eb1b7fdd6f109fe8d1e72449c79224fbc9bc34d96e6ac0f17701c1c8dd701a506923bdf6331139b8f00b17551c5ab5864801715ce24af60e661fd1517deb1008e0020e8935b9971734d12995fa6aae541eab5eabd1d432d14eea1d3b1b730c4545529ccb26b29746a12e01511615ccdf8d69477df318bbe3664aacd87344303511fdbc104a49efa7a7bdc0de9eaa4bf0d2d298fdf1cf263596f8bc5f02d91d421666ee16d71ea3e16a725632330f09dbce1b9fe69a970cdf1425cb746f6ec497f1b732820c8da00fe6b73d23bfcaffb41aad2f0e59b3e35cc44449ac941f164168e01b80acd7109e436f4078f62592f39dac8039fbbe09f1a7b7911e060cd9da224d5eae00f7694ee8fed0998b03f519b39af79d70771ff5325bff66b5291d8e032b1a4c551a048f1272dc61e1ceef92d6452b5d2d2d55b757a6855290709385389f4bdfbe14097737b7ab61fa5769f8f6a7aba9165e49f4c0b8a12dda2320a179fa25531cf5aa3179d33f3d71d63e48fd9ad60c1311fb11da74fbe7cb7d5872174acd4c5e08d5eb1ad363095656877b519262a33232548c2d81501df0db0a6c45757c1e4ae42ecc0d4c8e7275947cb30cde1840c1d3e6c4b267a496e3994d2163bf7bf9ca9d45d81a0a639a9155a1f0c3628d6919a78e1729bff8f1d09969163b9b802580eb499edd92dc079f84340d7d8296cd53f4330d05eabf13a9958f97fadd123c1934d2e1e9fefd9b5a980ba2bb79d898cdf0c4a7508fe209b5536bb7fce2d0cf3dd35142842d22df79d32a9da7239748549aec83bc8648ed76e4888fc34438dfa0e70dd6aff65a466d6bf5b4a42be686403ed2e4b7162760980795362f5cb3f6aa9d1a97ed9729bc0a0b38fc7a981e114fef2c74b73c484c8d045f53f01d054273154152c9aab1fb3d9267d0403eeb9b1a93271fe96d6385dfcf540b7251b7d748ca9c46fad2ce89451ff70361af2bfd8e700a44e2ba446dfd718f698cb1deb466e4d54ae5007f1d48b27832aed8f84cc8874a969943b859a3d53356cedf4e9ad286a710c5d1542e7486d7b5ade860b174841400a15d7d7ccf25c5e90ecba384eb979d2edc5eb94e33e09b8c61b53a40eef97d30cd1b9a1d0ef7df778d2cf12cc573283d7336ad9731f38961bdb3df4c89a068fcb7441a720d966f295c5c69d7d235a600db852cd24de9077350f5447f18f56b8afd821978cf9a5053245faca16f7524c84aa95abea37ee68553050b4f5082b12266621da7ce33eebc1b31bfc12ff626d16ad15fb07a8443bcc8de66ddf845e89d786e1eb797e0ad2b6ffb390fbaee17b7c15d3f00c984899a3f2e7f1e1410200fa6abec2a155451239413fe3a90326e68a82b56c30bf2340ee3a1bc60f386e257c2e3cb81fd1025f267380942a40b67e308fa3192f3f870b2c5d92bb4df83f809f6ef88057e7ac9c0324df617b819c6ae6eceae4f4d54bb5732c79513eedcb15b5a3c885379bfc6271d902461c782ad385ebd123583373d213e8dc58f9524b2b0fb13d7dc6bfaf7dde003982c5789446a63a15fa2025fe649c2bc8de6ce1f72fa2898c805f475b6ec9fff6dd284f99864e98815b34496c5ce47b05da1810b4ad52a5004980466305db3d304ab0309e464fd9497dba0aa379ca8ea6d8cbc6894e63b3917778e6e8788d1900949d348ea06befdaf78734efd6894db5887f66f522884997cdb82c0ef767a932e3e8cab9144449e9cddccb05da26b2262be32f23c205d874dfb6b85b09a3b5dbbc54a2f9239ed329ca774007e34f38d1e14e0377042ad9c262f8515f526bd60a0f12bc6a8de9432c4b0cb62c18da4e2ea9aaacccc36877892f8fb66f9f299e162ef65b44f900908e34279f9225dccaa8452dfbbe6ad0e25925fa58ac665c95a18074136f24d8bfba7241a2a5c4e05af640a71d404e9cc8cc03671a902de74f50d2db60893e33a267579dc07af355aa1797f1b7097b3487d85f5936cbdcf2d5db3d1c3bab6d22acca7e4cf26e0302b6047920516f928cfd849c6df15308baafc84a7362001a8a3ff9fee8d4d823bee66ac4e744546955b6be28415a5619ed90393c273635e25933000e172b867d7324a9b2fe7ca8b2beff76140fcaae198f2ec0ec53b414d2c2062a14601f6ce42ee6e36f8597e54f56c44dc1e4342d21216500cb85b9fc0ad06f70f75b4a612495ec76731a928d761177bb1b208861b9b6782490536e4c44f24d4194397feb5c064aa67af909b11a8516a41ff40a1147ee9d9192b0bf2ec4fed33c622d51f4195f92261d9c9c5f20d7a6ff1dd56f759b9d803b4d0e24a7e384f2ce29fb8a3a168f55e3dd75c2f277c354476fdf0d56adc5d1c593362f1cd22a7bb4e491b546ccba810405cb868a19f20580f836a864acafbe86bb274b63cd5d8c6b3c22714c23a5d54a4f656b6c10695827049fc3d2227c1117125eef4c2be9230e16e9bf7c7ae33f03c30cc9be933fd24e20de242d4f621c23c038811d920353d6a9a0d27db68e826768881be95f4dc7df2b5904584cfeab64037ad98f183c48effe3f5f2535aa4ba965b2fa02a0fc8752c7412d8d6cb83e44e6013787455732a8eea41b492f598ed68ece1258efb0ae7da2d4d4538ba73864e01d3ba559a697fb4f6e1b54b80e97705cd2832d343f56a2963098b059d6aa11a13eae5dd77813576776916a9b028f2d5093aa5971ac745a12a64ed1b0111c748f78afcae675127102e4909c1ddf57df68d015a70029f1dbacf8672095572438db908501e67328d0bde89fbdee9eff2873ceef7e9ef1ec74544dc8be7010884d0de2c3f386ecfedd35d983b960cb5c47116fbfb440db4bd31c2ad3881a229f439b6c6df7defe7d56e4afe1641dea8c03a025663cb9ace12ce469b4303ab61af54df81e51ef92484cedf5efc21bc190c916d0ad2d37baf5268707e272b339b514d569b5bb2eaf78caf42a79c958b3d4785de32884726f6c01c56376cce742c384a03d44e33a1e4bfd2d55c2f6cdeb1d027308a14476be4cc7165be67255c947446fd845fdafd31d452240fb182ece97107be43b5fb2c97f0242ea93436884eea5357249b518a2d744be463f81ec550ee4a8ebb7e437f54cfbb025d2ecab5ea3f40fb7e32e4407f0d0d174f9e3e1cf5e548c2458d20e6e455aaf563ac016e830a6f650f4e856afd3acbfdc5980ed152fd438ea1b60337b3b8a5377c34fce5faef7906e395cb6dac340900064e0fd7dde69f655e24d873e9a89a2e587fd79cdfa07119e5934c0d2f24d0474b1f915bd7bdbed5c80176905e9df55830c6b84edc06af0758cf84939de3378fd81ea9583a853165b831dfa656fd339e3d84b515e8aa1bdc38f7b343b8f642730d8e21b78d920a44a521da006b365913cdfa622f3e60291bff23216c893c152092f1f8aad19d77cc6beb8b3ccdf34acc6a6ccb53137bdc2f2c5bd679df09bdc66cb5ff02a8e6a8939545f64e051fe77e116b895cf70b8ccb39ba6f5ee5a7f63a7f487510ebd06a317127f5f2e1e06a6efb1f259f629f9932c694dae1620a6ef0de7c4b94cb1f2612022e77309d7feb61fafc8ef1671a87b383419d64d69a7145195743b5e0f60b2da8028645270b2094e6e830ff45a02c8d831b05161b709832fe86e241c57213c6ab342675501e583f19ca0927779cb9640a9908abb323db4281c0915200faeec9dc13e01bb7397792a90dcd62af5c511d2e07cda6f3a29416c9256f2bc6c6303622e0e4a36ff43df17839c35a387fb919d8094a76bb3b79d0c01a14cf85c5665605bc7142e56a2de35e2ff2ba760e8f1e92f50f51c828bd765e2e7144aec6c2ae7682c8966201910ed47272aab312ba052d423536007b81b5433c88b3462774cf5981b52c4eb27d1b7542f9231539bf9e1353251fe314eec78e501c0074221cca0565ea4bb798565ad63fc3db0b11e1f76309d9622c34aafa123903abca6e3dfb1a7417fe44297de702109edb08890133313313eb439f3763726f7566d521af191c0902f6ad4532b267dcd1b672f0f650db202170404529be0e9199609ed602c627592d54cc8c6c142aa4017271cfe191564eaf9531bb2a50fc997623ec8172785831f662a4c3c010153c3e4843eccd9d75032d2bfaa1ad01f081587544e4fa9b287e69aae038a68b2af8f3b6899ad422e63b56d82a04d2c28fd449d3b5b3bc517c72bb5e8e42ff4178561414bf5c56f4b861c73ff819209f4af6c6e668c512206e77450b6f68b5dda74a652688d5610230d99a7c35928c8c0db7dd1feece57c9e583c17de96585dc4b87698c97deac94509d642074f14f87c6e86f3beae23035ee11f251eadea2c25dcc777de9701958643a62b2e7cbbb5b3265941b1a7ab840f7317545bb18fdf8a29ee47f135e1a027c9aac26df40bb4deb6c6ce4f2425b46c2e36cf66ab6b24438394e07498ff1a36590d5518522374a9730c0e1133206e7846d16bc3d41ae60af10d543613a9c9aae55df01a414760685c06af264bfb46f3f47baaf567616f7014fa0dee2c1e09726e2c9f4b942dad15641624dc25aec94197c6e7149c428f779d690159326b2d180441018b4f9672702c4a8285e6d463929793c46724fa41a91d062ee2e3a3505ef6abbb3915acee73b9f36aeeca0329dc369ad7bad5a88f67d3e6a787fb0e2a9a1fe6664275d0489ff6dfbe51499888fd2b91f3fc0f8b9bd05a94fdb264c0999feacfdf33710a4a529099958343faacf367827108f014aebc39c5d73a38364bbdae10d95384c205bafe2a131ea55373c7a399178c9e1ed7a988432c55a24e6ac52adb8da3ce974e8264775a7775aa095de8a09d7cf2f6ba99e111dc419c4547fbf802f340c2235c48006648c8790f7ca677cbe323ac5985947aef1e54b22d7b6005304182b374f3636d05ad008f2d771c37911a5106d4db41014b87874329526719f6055c824ecbebc7a3ea948fb0ee5f8ebee506e57a8e5b66f6c33343af17e3e7f5ca1f95e2460efc233e54dde4e53212e2478dd9ea0cabded4c23f9450db49e708e55e80c827db190b4955fad782b504b33d6dbb321015eb8e6a2cabef8f2f8fdc17ec984ba75a26e7b6b4230a31dcb507892091cb863a0ef8b37af1a64e03ed5d99567fa57811625b201da260bcc0b8ed2f2878aea4fe892e85acf40af20f8f6995eb2129eba4a9ce1ab589dba600a925b2dc251d5544fd3e853b579687bee116a788208192dbefe1f6d102a9987f92e308c6db83cb3b3eebed24cb448fd5dd3d9085c3bd4e187a02197a6802559ad61b060c3509b1051bcce411ab5f4ca50658ec5432a785302dfad36f8d94d16dbd7a6647914801ae4f1d4582fa2634626b477864db536215c3d205fdbf0050a19f7102b157e9c5405876567a4e20ddee601674f40288943d3b5397e2d7a0ff4b4a8977d23058b4fd03f26f4d5b657d404bb11126d314216561ab5b69055a013392b4dfbaad740dc8acb3fe5325c15a9646734335a22d53d8a474e0fd884f993ade927687f52e5e400c2e7d9b2bde358fffbb0c87bf8fb0523467bd6ed008220750280085aa6cfe06779d559b9798e796f2c97aca8b37badbe83cfea2225d393df79f8ea3caf75232f5b8b2f56589962a7f3b302d285dd24ae1e64f12bd3ea2374d0d5db1edfb25a20d303e884c57a76e55fbf006feba5fa29dd17fd35d3a32dc497772a7a3d8a47293947160849c56a4e5c07da98ea1def36f1f41be4d7c256300aad998df40c83788ba4c584d8bb731dc8622b4f7799a43f9df39ecf7b994342c07adbbbfebeee76119607d310b6c0c08729ab1cc382e0654d96382144b02bf0fce0c2fabf5b38644d262ec412513bca399af6fcdba074dca9f9e5d540aea0908bb503d347018097b98507955c2148a3cfc17dc01365363117d4e645d5f33856ab6b1cd76bd738247db3aaa45ee5791098992b49c9349268024f9f0085232a018abc0a10dfa5f8ee6ff542cd0aec0f3e96546eb252769a5044cd2f740659aaed10c09a26e9d351aa883b3d17468d7018888b586d0fbaaea30072a2ea078c6bdb3b8cf484b6e953467303e8ff81376844dd3cf5d9c70713e72c325337c48b1e5877dc0c9d7db381a31ff6363bac6e99cca5fdcc82f001e5d3bdb4e47414375befeac72bd660d07393b730f88739a91b90ef0a0e176205dee1011c289536ac500cc96672dab8f990ee670e7d78680bf5f4e08c929a0babb8cb4a5add578d3168e7bcba304e380bbd601dbd46bba4e15742820bd7fec5254d7811a6dc66b74b638fd75fa58521ab06d85a19edb0cbd2a19a7f44d63d6bd0e15038f678094b401281c64b746b818d4abe39cf5668cc01fb6d99d14a7fb642b952c80502b658dedbd74b4912c85a94a0f0d60881cdcf0313f03e21b8f1fadaad19ddf00bcff8664ff92981c4fcb1102b3d95f15adb6c8c1f70f375d3d43ed989a2f0119f86ecf18c06e6883a9f4ed9fc72247da1ddbd647d8c4ae3fe83fd270ea247d16e2615bcb843cd55ed5304f18ba1f0c0595e332e6214461d5cd82040f9f87e240f3f6a7e05b5816da4206182bf14bff9ac700f0289071ef3564682b09f49f24ec54e8250c532d21eb52f3acf82d53e3b8c11e913a5d0a02db32d0534a60e0a70163a48fd4a2947fb642599989e24a934a12040c1a63749497de7a62f9172c4577fc0b1b53b3f94059976eccea28afb912bd65fc378f5dc3621c1ee80c9b06efc8399f0482c839901b18a938e4358fcc0f7d45639e20dfa07b2a28647102772bdf4967ddb65ac4aaabac99b9b59ce1faa134ae39f24f1ee7d953e01746742babc557e308dbbbffe0b66d166eef70cb0aeabb83744abf43867abd9f83ce08e821a8b77dc177e14d20326335fe5f323db1a78a162ded17e0d8fcf3b13f77b417fb268b3e8aa8fce7a289e77611871eb420c105a656f5990a8fd8d0071ffbb7c3b30a48c89a7d532927aab8756316416616a7853d436148a13008f0115c33f7ec02ce7bfa0f439257d17432f9e2206aa8af31bd8d82235abc9e9648f828f534395ee022ecdb418fd8d7ea40454338dc8a2bbdd794a9961886b0d5dce9439e9e4646f165564b0f6bf04a8cd13b0b295b325a9c42ec4532921b468c13124ed00b6f9be83914fdf81bba16d72bd2e7c501f0838c8e0df4e1ce0ffdf526017937395438f47ee7f89bc89e6ec5ab462e239671775e45400f35d25ef423e84b563518fdda9d8333e445aadd97fff81c313fb2f28dff03daf696ec11cb4671c5a0a24c23169ee50e923be13f17359c63cc4c02ed03e100ecef5ea703a2d502351e3f01ed4445a7a664df9c71f7d990f748017d95a8d90b44f4900313293702f75f2a4b2a99ead13d9f0f362f9219dd3638214fa0658700a4e382b2d9133c60640b611021343caa855b01b72a0ab2a00149cb4e4c6531fe4476ddc712f25125bdbe0cf427d3230b4d51aa2f8be2cc08f181b6ed87c6be1b2675fcc213ee2c8b61704e41926980a23996d85d67b02b0f3db257c6ca0375de841bfaa823546d1985ca2595bef07d0e3e2f263d85c7384ff86850220be6195046c8602e91ebc021c203b195f648571caff00672926e7589f79a64b7b02e044830a70be8636f0fae520b1ab1dd4940055069142d3ea365288170a4214dda3026e486ffbe6e4e1afe467eab94bed86971d4efcd9b468fc444491bd1dd6d2489ce41d9f82ee39719c5461094cb1156f882528889c618125943d957dc196ff424f98484849f8b3dc77e6db3169b674320e81447afbbf3bee4cc5b615ac70cc9bd066b8e3b42714e84a3179ffccfdd0defd820d8561b03362729f8518f59dbf7a92a4e6844041ed79648bf401f622f25554adecda5ea49e98d33d1fbe715865d882442d29918646a9b7035d179bf6e79b281fad99584970fd59466928cec681c478f0a0ac81bbd9bdd54f8487fc091cc749c6d2b13dbe2b297023a8adbf73a2ff1278a574743c48b1060e3efa43f1102eac1eca749f02bd2b0a313ccc2b95aece4efe60bb49b971569d474951990eb3db911b3bc3d80db6ca55a79d43a09e8a3ccf83ec2413f1039534c313f04e272805c6340bdec4ff72b158b1901d12e5309a549af4a158715d3b036f8546093bad6d1047ef1b4ff0c317d4358f7f8efef1eb4b31ae52492c422a4219172c19abc9d3c38169a0d4efcc26777378e854e768d343c60beaed722092167e61758a2f4844036116f3bf77b9a7717de9622e6251311bf378a97779562d0c0c8bddfa5f401c74f602488e0343d6312ad4871b349c59f58b651e7235b1c1798459053a5fc212e9bd50be6c9ac3133d7a572ed7bae10e091ecd3db64c6898bd90196d552e1c5d047db2e89b0a19445d7bbb76ca33d6bd12f8e4ed911ff0581a84d2a56dfe79daef61daabc2bdcf06e5097411680a460e6dabef94d3672713f64b4628b46766e0dfc49a45ce4f7dbc3cd9575c1fb9789d4d68dab209fc349c99456e3e6d1def76d2b1275492876a2a53433baec3d6b0caa23c3175f31b5a2ce023368d8c0231ea22865e35cabd6d3c4aa165a72099d9492d924b81663c495042249bd9eeeca93e7bf92694631f4fa39c72e05dfc7d97b8fe6ecd3103352050ea9f18a81758e2736274f83cf0ccc7adc27debc2eb9ab8efc55d16297c6765501bf45ca853bfb91417d2a7ef1f2b51a0d60a08b432f6c14d0e685e674aeb1c12946516c19d413614a930a101cd41a5c3e2b6b73d97c98984d6417136a7d3ca0e6f182c120a5fb1e9c53e6752a8cf1c1f0423e0d8ea1100d1f96c7c07e90b7f03858b3531d8f1b708ba0741d8c017cef2bbf4bd0aed50b5cb719d8f1bce7a995a99b3274b71f84b61daf1b26766197141b2209d420c9be0f2b94b94abbecc7ae19bcebae1bc55802759f45e23fd779df5b222eedb944fc1905f93e2e17b7455024574404360f3452064e4d222c8e33f29f9e4c5dad27a9b24bbf825078b903339c33d817666f6aa6555be95e8f13914f718a1c39788dfde6520665f82b46ff4df207b99b2cd742b0458df6f46e548fd930e248660c5634a10bb46b69e30f151138feedc754b031c9aa13a292a8363ab50d5c510c2e42b3c3fbaa6b93ceae9e9886f4a8fd28f9d2825a3a386edf1a0efaa0d8e540457a2748396a6b1da774a05e077a860d2767e01ca58a1f142e8f031ed39ef8e969774589874afd22ab0fda0550ecc9c6e6f5e2d9c1752949fb523dd72d839fde94c7891d0fbfce5b3389cea1cebacf7251880c88be023d5667f0963edb8aa7cbf61183ba84675a96aad654effb44d8b0d04f0ae7e6b18ae3037e17ab3fc3cb305b15aabe8c450f1d169194631fbc08eed3a96c8ff40092aefa68f090e9b9ccecd8dc26720d950972723bfe108091d7c3528de50c38e4fe5de3d4eeab5d66c835f5325af9345747de30ef56aef9b2bd23e09f8ee6b250e936d56406eb38d9b9c4ecfaf2300ca9883f4370e4268d4be03a898e1fc05ce39bd82bc0746697b426c802f34272c56a9c41298f1f8aa7f88d14ce404d4f9df89bcb8c336037b87260d0b8b28ebf667f469785852f4e88d04186115e0d74cb8d8bd9418f4b7d7bbecc70300b6cc74ed241d6af2628e65d0949fdac51ee31d918f693886401c08f1e6de23072c956d1f7dcf4d4c13c0d2168886730769f26f5fa539c07d6b6229294955b0bef80eb475d9603d9c65016047cdff7133f58edbfb052a93059ce0369b1c776300b8938f8300f9e667eddd7486a135e05236709a710d588851174857307cb23fc9f40b0b1e876e21d12bfd50fc6153ce8d4141f2c2cd710a2635b015dea14836d85fc8bc986a22851780c0168a3dbcfae32b847bc76c530f0b2d0a8a37f5d6097f48b7e27c431fb0059f1edd09bbd1ec3a8278bb11444e071024e38838bf61b01adcd9155030bbf3f54b979840f61f1f9fdc64c408def99123f3c11205dd34cb7d4e5a328469ca660a527e578eaab61d91aba4ef4e25afe67279bd742edf33141eb16d780e61b16b381e660a769984c3a02b0c3fa5fde42a445b7ea6c9c59230703796c77237df2a7b1575c9851e0204ef68bfe8504ca0feef5f834e84d065a5a54783a0248c3bd10319891943aa2d028fc693dda98d6d4c2e575e4b0131e70ef19638f19d22fa10844142ebaabde9ea237f2c2743ae52300f460d6431d5409e57c482cc859392ac969c985b5b82b8becf0d62d969aa7ea2e681ed7287e5b8150202c2560624707eeca4dd34f271793d9656e6263d0c430f987bddd3ccdb33297627d2a2c71e5dcdd8536e177492f8be463b1c9e7bf413d1fa88656c75aec190a3ae038b71a76888f48c6760ee4d5303dc682b3fbb80bde9abcd2ef6d056c8944a0ff4ed8e8436afaec3def0012a7689462f972ad7d61b9f4a7d6215a21a28dd434a15b29050a2f9c569006b2f8d1704fb23bd3012aaa3089c0c729150691363ee83c5054def5afe453b6ca7a1de4d6097bcdfe6c092a06db6b82a8d02c066e1a8d65c3822a1e733f81f357508952fc5abd0946409647afa695aa7e2e067a61a5b67a9d634f592532c6f28a9587e5af3560c695809203ba59c51a931ac7d56fd576f69efe54e7d671b6538616036480d5a37d97534b3490f57f22fb083c1f449eab6cbfb9896f12447fabbd65fc01814e3f4930349c5ae96fff15107378fab003fbd7f6920b46efa6544c11cec242d84222a56f05daebf0a2bef7da0a9c371fc972a40e047f4223c6da7dd8348664e6dd993a4319a1e267b18116055c4ae746e5aff01ee7504c9ef44338a5c562d69a7122ca83fe742a0a795d039fcb17d3b1b07793ca1fc209e00292eba5e3c6f9cdf6f8e2e08a343792e95f4fb3abbc9e0b1b74e0f7b6d55eb3cd679294d789e0b26980836bd5c19770898ce2ada667b0d6ab963c8d6f6dd43e0123f836be851d9a12868aa1603701b4048ecf86c616ecc047537f57e066a9ad76c7b7508f0a64c1dbb8899f7afdf8f5b0ffe7feb5fc67dff1ed0e82b5318466e622a0ea60dd0f61c524cd3a8eb121cb2ba8975782082cba4d80c9b4ca5a5e2fcce460f104acd3fad590c0c933c09f0af01d17e106d92339001300e21e013264797b6f85a3ea6aa0497be81718f7887894bd2dc3b9242c82060ea7fb20d8ef707dc905d71cb0a9a41e860d2582b102744db3d75a811545e184f6324a9e822565c59ccaecc18e9023da12c8202213d7208bde0c718ceb7d877271c551bbdbb26c4bce1d6bf008024b3311a68f3f6e2b75b4c0b96e9d978681acf71d3c8ff4c774d75781959491fae5a77692233e8ab9ebceb452caffc1a78b4de6b1cf5300b8552f1d8a6e2b1e6e2a0ff4c9e102ee810dbe3151409280ff262fb63f57b81806a43d44b8977f691233d482abc54e820b6584e3ee7949965b141aa25ca101caec0ecb361a166b703e4dc2232fa06fb749aeb6b031187dcbd34bce6de4959fb280a94648f40df32e5ff9941747a060cd6dc2d848f59edc70eab6f8b3f4869d0d9fe8ae6b440a6ff46177637448611a078d8383300157cd37fc3631c81427295827d996af4ee08d3998aef35471cd853a44dfcda9551561e8ccc0d92a65707737618c12b4888f2aaff60c42be987d0fcaf3660cd224c41650a7e8d1e73b07cfc3b62235fe986b53874e0d236bb30d339a35ea7253ba1914b88f5b0c80dc186421f82a53e78a4ed49ec9c89c1effdae99c9c5b1dad2c31d19295250fe5796a6bad7e467ac033cca1ce12887cc402b587a2d08ef53b16d7d05529aa47963f0073a42d1888b928adb2e4891a933d713564be3ee3a059d4a05c0c41c81680be940dbb46194cd26c89e28fe27d86a44b0fa8c513bc2cb45cad032a019557857a08f567d756801a208a654457a67fb152a75c73e1daec1a1ff27c5323afe04a56fd3ef39512a9daae6aaf2f3253f3b11ffbc0006e234d9720d67c08f2ef309b0a4dc0ac61acb9d2f97fe79056db545c93718f2c8907bd6829e26a91636e4bf4a6f087d589dbf527373bcbdb05a22e8ef45b9ea5250404b508708cc21433d660c1df230e3475ef1f5b05af63cd48979ecdc4170df1daeaf29a83a2c083fa6e25dc7ae58f827a2ef329a553944cfd219d68e700a8d3f7d04d483f983273fa633f25cb732f811ba1045e570143ed346233fc25fae9a74caa92e56c49064f6cea253c7518c022e319a86c78ee47e3f3e968a709385e0e483d89a2e55c820b2034a43d36641fb1c0b2d4a9c146f50f085f6d2b04549f7ceddd8059ecec0e1ea07fec5c5a844d0e6b0b4388a6da99c524610b1aad0282123c92812a37889b0e54d77d17075712f98a5b943ccea8b8c1b32b87a376301792d6fa7f35dfaab3656ef6f4bd41f26cf7450a59406166492a14cced00417ec4305d48e3d94bede4ce610ae3fe8a1726c5e3cfd1cfb0c848212e1f89ef64acf6fd66660783e25578a0b4805e9464cfa0c5caba0398907aa15459b02a4b30c4b36eebf89acd29bb33e83777e920665113891503af1f61e56e4fc563f385ae1502edb7a86cdaa931ef449afea00e834004266d8af3d76ad7aba47988176ef93deeb6c01c00de05144299e9e0577975e76a5695a29851d84418a8a8b94f4248b3173a072c037ff60449a86cf6bb9b04495624a60ee657826056a4ae4597db351309b6169adf1f54e24d7436e95e869feae87c730f04863c472ad33cb06256e9c343912d6f7310e8fd7c6b831e87f3c4cff9336e1843cb76289351c4045e7133b0038d077f434230dfbb3787ba4586d6bed392396e391fc21fb63b39bcd205938282dcf13c0c8282476eba3edcd4c02fbb0ac8107c1cb3a5246486a2dd00e1a75bd70c14aabc8df0406ee93288abcc9de1c1fd2183fff4842afe80bd967c656a064a12b61575a532420f59432afacba014cfe63729eb20079f2c418c73f72fef8046bb94b2806c9648c727234cb48a84c05657c4a3a42981fd63e165436287568b90c50cc44161aca614af62d9170a8acaaf7485280eb06b0223be0899f880f8320f5f15e4371e660c87c47f86dbddaee0e69cb5a5c54bffe8d843ed5013b344fd484319be77a738eb55f226218b912c4606646346f69de3ed5df7c60e6f219fb89b319458d00cf55cd596c5c06d7c89bce4705d36eacda3ed810de3220e4685a418fb42ec0d5d4c38fb22cd846366c4c94c8a52598a2e57dd8acc3119f311a2704c2be0798a33b2c6af103667d17164a0ad12fba5f65adc22ea16def0a74b1319f88414a3395186e01012e267b221d04b1aaba54f5c58ea9dfbcf021a4c2d38daa2acabb2c1d7ceefbd077b1419d6d5767aaee191c03e7e6c998d977bf5221b2fece6845dacbfa8d13a54112b843ba4b8daa5e195d315bf425173609bd6f3d16f02fec49684b85fc7e60e0da491b1f7db9b1934b8a3549da5357c29339386809c0e9c0399438bc4d6595535eb106fca0d0065581496048c4f6f9a5ecda59550c4ff5e82ed0fadf2fbb5d1fa62f5c6e44c585a8c45201fa5750f343d446703a428a33e6e2b796abec39a65fba2903413566ee6077f4cf1539d58","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
