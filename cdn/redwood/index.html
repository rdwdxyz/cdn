<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54e2311807a6285877ceb239a225723a46e3ce9c07b7684f392d6c2c8b6c3b55a97d2c5c0a1deec65765bb9d882e137443e1da0ecfe5dfea0d1840d5312c2defbae6367d4a68f1e0e4c9692ac1e314e2b5e0291eafc30cf4ad62ae00f92626c40a0e9333a2b1747c09b349ef3ed873e8dd013f5313b3bf41675bc534cd4cc3bfcb474fd6ca8995cd454f426e6243ecc614c710d6e70b4bfc8b46e62ae3164d7abf3ad1098b61eb9b8606b66316c5a3fb981c8de778d98dad7b6703b49f12c8b91c10ec9fcc3e5982deef1f044e5719ededae8ffefa9321c56ee72289b4fc09a2a3f89e8e38e7c5fcab086678bcd572c9d75901fad9d9315f13cbf59bf03e5850abe3b111a9036ad1a31df0ca256c6f15afc613816bbd3502a60f8c94c319dbd5b83d228d24e4bc3441d852a5594988347127b1b8a6a2797af7c4c7ff5c3f35e7f027a6b2c59632ada3ce10365a928b268cb11b082fd7cdae22901e7c640d2d419df990feda4002c8f3e5c1676c4fd0e4cf92554e537f4f7d33333e14d761f8294be06c93439c5f0cbb1859bbf548fd56ac19a005492e165331d0995cef55328cbdd1bf5e42ccd543d230d32ed43830328f00a69bd93291c042a27945cb26250d3391a3bae46527f304ba8e01efd4428383d573e3c381fafa09e1b21a383bb31b109ea5a76bd7593852f74f83a25e9a343625d2c19126e8121697c96a79e8e7995edc6209afd254ccb6a91b9115dea88d330fd6c931e554a8d9f7b38b0a4465d3fcb269330ebe476fcd1c1cd7ec68d30f0e666929155eb4a42fa6b6099a55d110d331efc4e22c63dc4e9f82cacb498b8ae5b4d6cc170d3180b4a75a44eb1431c75d05db9675e16ac71cf4934db7078c1670644eadbeef56007a1d74692d93e50c77b1a7eee3d598ac9273fc9719fd0c01d6a93c238786121091f01935e4b5418bfd482c1a33f24c6a5223a4598ee13a007ee9c61d67b04e0cea7545c59efdd0965a2e96528952ceb557f55af2a1f2e9b459c3b5fbb85ccebd8242b7c58dbe23dc5d8357a14e65d21aab327ad21e787029b6f1185437ab74bea0aa75fa9721f46b386faae840facc7c1ba9cddbcbc5705108f08477e98f678122903f84d3909a4829df0491164c5ada31503da089ec495f9208fd5d3509f927c950a9bef79b8abeda1f34ebfbdd081785bf28f84a0469c6a5c56c5fa739f4604c37192ccc1f81a770a927d3c4429a022dbb1339ec94269dea6ea830394aa226a4e443a65b0becb9e382bedddd587e4116fa916fd8d5d15b3aa7d3236d53327c948d7e59c199d2838913d0317eb009070a442b47d968008294ac2b9c603796420b228270c30337cb97aa6f26be04557197308e5ee1def9301614703d123122f1a9d6219fe4b158fc010213589cb7f0e774af9d7c301a88699c43e2c031ea984f5750a2767b4aca9e3ac40739c123ad3a520484adb46dba4c6949c5e3cebeea736e5fc233a241adff33172e5a32c5d7000a3b2ffe24195718e856148fbdba8bf9bbaf5268fb1d757e23f2a9463ee283a0513481593378c8b44bdf183efa068c7bcb75afa3651a5dd95bcf76a3621dc3d754af1635f330dae8c14f8b0a25cff32f9219df8bf62db9ac92316e71e498b20dc2b04ff59dcd58051c5a1a927ca3b84481496eeabb79b19d2927fcd576768dd8c44f2ec6f3f5a43e1b01068c56b971b25c7b2336fde1ccdb4d2ee8a9848bfb8d446db5ced4d108025ddf24070bc07ab293d734cef9246c258749473749f640bb5c4bf82d061f45750ca19406f7d0a0e9c103cc6662c90b358a481e5df65ffac503e2d5f114cb4fe964489f67a84d7adafdd0c47d104553e8c15f1ee95759e4a518b73299aa631dfca7b44879a4a8589ac211a7adbbf03ee169785a461fbce880ffa2cdfbba14dc0accfac05369c722c92408c6475698fc74e91f5d11094dbde4889bc54b8f1df45b09c04edda2ae6bd9947f780444b445daf24ace69cb67cd999fa97af0f7162662fd8708322486cb0b8d6b6f6e5ec0896707a14b4149c84a4e7d8d1ca2fd0ab4add5b37199e9e328e5425638d5a441be256e4504e02c5a053efff676457433ddd868d6f6d8327f2165fd508490b4720c808dacb0c8ba9c977c07a63675c9ce236009064c788a18b5f0c94f4719c6ed75a7673757a85e36f33e73e68def6dcb25e86550870a8b4dbc1549155c2d15dd57d2b86cc51c9d0f3aef91e3e6cceaab6594ed99da3ca4fd9785dcc3cef09c84265bc85e52ea4e7c1d2ff9da9bcacb9b280331616a099873af13a4d6421c76fc2a23847ae49208a2f24971d80c7a44434963ffcd5f0d359d8d3f0dd820d0d182b9da1ce6c056cbc0ebc7edf7560ba68ac622eaa05c45644f745fbc7221f7540732fd9b7c580a79f645694b2cdce7e17cc10fc52454758f7aea3205ac67ab25ceba29b1e4eccea38916e7323ba7c7fa8f39b80b777a7692309a9a4d3a56ba3339d79caf68b4a120c750fbb7457747b33e0511a880bc182725a55e169c47cd497b16765be76c6b82447a875778d74caa848c76d42df04ae42855ba636fb31dc4b591ce53024b755c93fc3d2b5ce15e7e834cfcc42c09135bd80efa52ebd6f84ada1b809a2d3096998fb8c2552c5dc4c4808bcb8c823dd808c797a464e71f968eead9d3898d1f6cad5870cb6075f6f2a933c0402e83794e63507806dc3ad2134aacf93ca63186abe830dd07afb2ca4748078f32d6595968a16dd89277114d868f73bb938c4b0b56f14f71d0826a67e3cf3f21dc75e7f6861e551ac3f685e5c9a9da2eeaedbf7e1f63b122d9f6cd0cf74b21a94171c8d464455cb6d3604a903a5c7c6c1ee7424f1019312be608d436c56b7c5f4cb89e0d9229e522946ba5a69cb8e6b464b531f2d1aad62eef06f7367312ce160546f5b9f344746e14e53e38abbf4530a5348f84a2fa2050cd4c6fbfa1189092d8ca92a09230774c17a949b103884851c82ae17d6b58a65ca4e04471f8dbe161325afe1e7d3ac5e8847bcccbde9c78f19bb26ef9ff228f5d47981fcd1be5b68379d6547e83d4266e4d4fed5188c49e8378314048f1cbd32bea1f413ae5c78bac952020a5b0b3b995528538c7a103b0dd149f8aa2cd564c26b2fef63f9dd6c0a15bbe9130da533a6bb5833c35b4c192d23d62f497f39f17bf79647e2ecf23645a22b93c53f97145d0349426d64b59a5c260e34913a1fb4cb0bd127a117d94e78347b726c388100c196fd142d9978bad7f40ed5115b3e1392a0b5f4a1856570991faba6eda13ee8527c028d3db1586b0d063b13383d5f8ef7021a74adbd0b9acde10c82ca30f4e4dfe150e426713ccbc29ae79db1d96068b4a1eb59f7a21b1637c00e871486ba4192ede6832a5c38dcf6cbc2488af4c636cc7035f457ae2ba2e06bdefce3f0c04283daa6e5b5262eae8c9302d5918bc5cf623d5abb246209cbddb774dbbc76aebea21aebfc53a720338a50273e6d2e275608e51c9050fa0c57fae8c91c9781323a6107d7933fe20ae6e7553bea111f713bbd067b963f14abb48e3c4053a9855ec4159d838daea7234092e1ac1878b72a9fb96a70f9c8a07c169f0f8099b875da2db12ef4b7f332a828ef4d19fe2c240a5e20e203dc7db7f7e954d5468faad5fe75c594cb589c958c396492a9488d4c5354a58c6d612088da4f527a90fedf7bb05791c4aa05bb3a096ea2cace8cf73df2fa5d6e06cd820134cc72578a2a9f13a2c2129f56dff08ba32246783c5cf70d9be3dad16a013a3ea2120ac86672b173d5ad7aebf70d8e47898c87c9c192bb97647a584be7ae8068e1b5ea80f4ff42f112eb448bbcde479f1f3df657f4b07fafd7ba738427cac02b993f6c50dd66151aec8ae66684b7363b300073acab528cb72dd2ceebd97e4d939f907199887745f6cfc7ab6f598155fe12814563a8cea43ec52ee2b9a047cdd2f1fdbc7b902762bc3017694507d0293a65ef67bdbc6f3fcb8c7cb70972e1c833f822a601256f4081d5b3cb2e0ae338e63bcda56459b5ca9393a795c2ba97e925d3d5cc9a6c68fdae3799b422d2dbdb2da43f99340b95b96e7f4e17b0104f8d95b32b840989f6436226e629175ae40f912b2a744abba09ec01bb792e67bafcaa2e912140da316fb807d7bf6d9dd7995c084e086bb01fd82635025f0e968722cadf42353f41ec1d39dd63198cb83741f755f1c168b9c769e43123a496bf0d0980a98a97ea2e20ba82a7fee61abf7ec46966b8c5970dc5b6dde76440b32e648df313695a62cc30ba5acda8098ae1e40451fd6965f058568b28230bdcac032337e39051bf0d629c150d7172d947daad4fb9eee8ed5b70b31e779cda8cea9326551ce551f8bb7a98190ddea34c6767e1a7e5deb7cd4c7df26172ac277c4800a81e6ad7702277548d800b87487cf41e4e41210ccd4bae22bc344ad1c691e98b85a65806d94d52ed4426faa194f4beef3ffbed527e87c11158df04f53d3914fe9bb67ecec5fc6a1c3a1507e70bad99b0e85b19e7cc9b220a36a0b72f97cfb1035e1140cf473c79e4bad12e22fb8fc3dd40ff400c5a68e71a7fcf35d64c9263ac052c571d9168ab53cac9ac45e7839fcdc4a102270864f71b24aa958524d4d420fcd01503c56b5f2240a5ed1c80255ee515be1c3b0b7ea79c657a0a2c5858d3f8a7d70ebc45a19faf321ed386b565d8f83144e1e72f4d93c0b20f4e36539b94608cde65ab2b296128d5ef72850decd4044f4abc4e7b356417603be1a8e61a4ea45b0cb4ce9916eb6d103beef04de74218a544e342af9ceff1595505c7cfe84d875977527a86ca26552e521795813e0b8a48cfd2c337cf9f1da9715ec12989b735b56f56c445a5329deb32d043ad08937c3d69dd1d83a6dae59559ddeebd59f48d1f9e0e41fddb746266d7fb78672d4557e17ea66f8f930212aab5c3efbdd5a2e20d47ab3d1becf350f0fef20a7576cd6da0d1f3c63c8e668cb65ae1c458cf451f78cbc7e10297242a669cc99b8b9730ab2aa6d600a4570eb3002db67068706a5ab62781a1f85ab7a824afb23a4f668f03980909b061dfe48c24a0f78c482bb4f97e7c31e774f920ed51a41651155f65b97fe2596521d0eb73060a9b85994c75a393cfb99be03bf5f98812fbf38f2e04e298aa2a48208af317dc0dbf0a5db730c910dd269b5062ad2660129b0add25fd05e4862bdc961c3ae91fef08272a6508739a0473cfad0e451d62b37cd1c14600774918002845e3e54af8ed1785d10cfc3eb89cd1ddf4d6b767604a2b80287d8280f5b1f8adbd5ccbc8c382c867985527321c33d2a14e0593e1773006864341cc1c96f23f1e927ab31f536bfd782514216e0cbf8bd2670f4e1ce3bca04714c0d76639e8cf9ef9c1c3b8b42b28e2bcbfc38d460febcba596a767e3f622b1ee31add594491e8791bb272a68e773929a31ce80d5f40a0d5b82b0223c78506ccd6bd9f6c0e2788524749e24f4873e1c0f36b9e675fbc3a30e3d2f6342eac25365bb33f1171ce5f32dad7ff173451020f0857f74bafdd510a8729dbd79d7648d9d42425334f46636fe75bf675dce2fdf85c1545288916858977a857ab0726171b59a60b8ff431c26cd4faf4ef79c959075c5008e882d32649baba7f9fd4d082492f5e2de87deba60d339e5b7a373886b278a1f886349067a4fe214dad23f95186628b25899ebcfafe06d30fe43abf3c707c1d3ce946b0b06f053890730063f1ce8b4b3c5b5a72422fbfbde7ec58207f6c3eeda55ae9ced10333a25dac2d5cae5a25d2340e913d9e06dc5833e6a9a56afc06cf9ab58fe6dc71b7b5791085cbe45483572ff85b0060b4bc7feb337952d7e88374e66091d6450645973b6b7f1ad05dce22f780a3796f29b47d51cf1d3366600b543e7cf3f44905217b3c2f2a20f1fc243c3ddd87a30eb268a8e46291ff75cc0040e3af8b346cb792aea73cb2d6784a88f6f94cdad85ed6ae683a4dbe876cc78a4bbd0872017f5939eeada5c615eef17f60bc4512bcbdd1b4eaa4178c1f55baca1aaceeec49daf05dbeefa837ae433d495a55ac5be1cd3d8d658b5b5d1c581a38a6616eb89826cdafc150540287c72491c75d6a554dd10b9f06a58e64d16184d8a8854d61951b2dccb19e486cbbad7507fdba63395fdf1362c2d6dff2af5299cfeb2ca7cb85e100f2c982a60f0d13ae2c39ba3ca98ccd446771a2b553a4e9acfd8b5195d698216cf67d2a9fb9007662b22e8281c13842748cd9300cf6eebd072cfbc3f5f33fd895dedb9ff6029d256981dd33e856763e21a81c7ef24a7752e95906dff3470d17dcb5e2bf281bd5e8b20f9893722f48509486feefa480fd718e48ee601e1e19e11c73fddfe0d7dc0ac0fc9c47ea4e362d06626779d0a34cf48f7d26947fb1f1f10696daf8a3f730833fad23321bc7bfb6e5e8dec2574a425425296ca510ecc1e6490fadec6f57801ecd7f2852c1aaaf1e4a13e404445040a663c856723c2fe0cbec71e99a0a41de5a7d19f13ad6a87439fb38d5a11747db895e0549d678c13b57526198304714520230d7a919c159946ee625db8e2eb2a00c7fa563cb30a8f22a04b64a6601dd4efb63225ca7836d0291374b90fb5bef90e78ba439142cf98232d30a9543bb63cb131d11fe6b6bce956a3096ff71c06476bbec68dee2c2bbb3feaa5a2e5946873ea9e87f5cf6d60858f1a82a5e4d03174c880d77dc3d5674fe13791cd988008bb2ccdcb6e62894634b4471719a8ab970ceab6fd5568879bd1bd532c98ef3313b2f65e5021cf6f064ee9aa90c244af7662359c6a8aa301aa91221bb47d83f940f404ec9c8c9b74ed0d0079336c7ae233441173a4e582178b80a3de6b343c9b1f1b90ac216aeb938eea2786acd97388502e85f68cc57c7b03845569c32f29467362f96ee59f0e52263bd3a01f8cacd71790d1ed9080decac152b1a1c62ac5590166b8ae7bff1e0153bbead2d315ae3b2a719f015816d606d621924b6893e1924a9b213facda35ed90085a20ff7f07beea367f80ae833e04e3668dd1b96b2805d5fbdebf6cf362cc23476b5dc8dccb8c1cc19d6675647d99f6e664e5ec491516d5d10f0427d489ffe55d82d12cf61c63e128621de9636d9953cf6c30f90631ec3723f3b0aad4a91cf94eb7e36af0367a474e85d5400849c06adaa3c9c12a7f1f3510d05bd8de7fec64755e682334ec645bb4c1d53b553160980d0499c7323d1600d612a9890473639f00547fffee1c809bcc7a93363a182e0bf25cc7079bf57895fd9698c51339ae49436c76d90dd16978ced74dee75d109e33aaa2b5be6c9fb4af19e1bd9d1f854ba22b5ce89b2c5abb7d4ef77dbf46a8d50492c2d6f210ab54ed1352c0d1e1207d4e6d34333526e11278467a19fee559891b43bb675bc3a55fba04a71af96a09d5d10ac48aba7f8bd3ab94815eac2684aa682df15da0c28785fb396201942a4aed9119ba81bf098625639063513eee43ce470b4b501867411ece71a1d329847c2acf18dec6ad5e9bc72903419b7913a58b72734784a84033dff29fafd56a23f80598c7f74a191501404700b03533b6598584a835007a9d76e6753916d608ac8793fd4a3b6f6d9b88a7d568ef142c53f723913c95e7c505405e72f630363c8003cd5cfadc0de3f4ecc8038254a8fa79a479f3895f900154492ca9ff9d0cc39f5bd38c8743b9f2e8c1da39271b4fa39cd476d892ac5132ab1ede31247540a0aa9d725ed8e37bbcbbe6baa64025cb037b60c13d847c503677ed64b887487592271937dd74cc2089a60588d76c1e00aa1601209ac761e641dd8d0a2f473b1f7d431bfcd6941218e77691ec99d5a2d1d9d416a9be5e9ca7b3cbe1dda524aa8cfdcb650d579efae4816f325fafd8d94e9b8adeefdc142e55d91cba4ca097893cd822b8bae4540535543bffb6a4a419eaab009f9d59b34c568a394f77adf0d4aead9794b9745e7539565dfe5b46c5935d71856f0e44ff6d19c963d176f335b7dee92e4c79a3b2a5d6eea6ac64b821a4066b83830d131ced74df77d2d22831eea60c934450b9df5ded7121509abd5b0ba9a73383f922ce32fcc57308ab7a18989825a634822d45b6cb3f3cced690192ae4f3c6773e699064d50dd6971972271fdd4ca335aa90caf0ba3f889967633d8f23a48fff3d3a27cac6dfa75925059079883e30f104abc119aab0bf0416512f9bfcb29e40479bc30871cfbba837c76b3dfcdc4145f03f3f5d870339048a1e88bbc335fcae5e7f7dcc4cbeabf9874805a6046381020b5210f3d4ee89e8dd9ef829f7b09f13ce8cd20ff0879c960b3bf69ddf6b64a79ca1294b81b7c0ce09a2b3f5343402c8274cf49c9953d84cf3d92e20054c02f45e42b1436d55f29e4d6979b82d1d411f09fb33e640c60dd56b27c852674c1f8add5fa862bcab9c68002cd301f29255ed0acbcceafb78099ee674ab4169aff0856f44aac5850dac82f9dcf0995929c3d44b9eda477c88a6384d25478b3c23ed66845f19caa80f6f82b02d7c0844bbd7be412e34842130aa609e8e44d9c5059fa39db105f7fd4b0a00414d5018eadc04ccd56ad7eec3d593685dae772864d8fe0a39894e9bb8561cf1cbf074017fb0bd74a114dc57a2c8375105bd450504cbfe745e9506767d369f4fc4ba1ee678114f837775518edb8913f0aaace0acecac57bebfdd2ca66a862175f8b448badd9b94389a6622f65d1e70cc4918ce569e78a888e22231a3c8f24e1441a6fb43954af7d02310a58822dff67768122cf7bd137746cb6600c72cf8ecff7c7656bbd5e51320dbbdd58ab36e90f3dc5a9584d3887b78303cf6dfc70042a80744c3844fab307e39b71d9fa6ff1c41f1b495c225b4e5e4c68f2aee687176d5573597c6c2194cc75bfd6ae145a7cd12d2aec7198548997207386f8f9138b1650fc3e51f8707536c4ebdc1419cc7f8f4779bad384a2acd6bf676c5202fb3a8b8714e8feb1b904fe01b055ff73c3bb6b1ad60e50556f112db77e6e9b1470aaee82b8110c6304f9f1780be2841522d77d27f6ccb7fd754a9caf0e3302fa0f3d868af5e55e7a5afd818cdc6207932c641a75f02f71a386dce79b7ddb4e8fef61f2dc287318b33f3e198285af45723464d4cfe5311613389370442ce777ef01f98156c97fe5e19a9d21a5aa7aee4cb71eae2a63af034affe62889d322626122b9e72c7dc2069600525fd4a3a956c7d1ff0250bcb95ca552ae1473700362cdc485603aba882bc7f4cb54f2bb19b957daf816a442821f60a8b742453b4d4ed44023706eebbaac325e3948d40283e341250beb1b3acbe5c220bc71f6e816c2adab953f0c6986a8e5dbdd606f0b8029bd436b46ee96c95d1e19477ea4578a4d33d4c745328f02c0d690e6e9e8f1ee2c2f1a0d7103d698af41d045e2f064af5be7f3b5d5edcba4ce54a7c75ca320fa61b0408a2a9d2ea76252aba8fc0028d55c70cfca90308e64bc0f657fc6bd05a89806c739535027a29dbeb8bf234221f6a6ffe9bad8e93f4a1832ac6756e759836370c4d5504e406975dce172e93b1039329a6e55a53cf9f495b5155e8bb9bfdfc896a94e30e8d2c301df7ed1ebea4291be6f34f59121c73833b4be64fc8bd445db91765815be51fd72a337fc7279eeacf13aedc9e17cba85790d959cc085c1f30d2a1b843ffdfca65093a9d52627ee4f658df58dc882d33372e26a0cd3377056fde7158db4cbb745f0f423cb83641fab0c205648a8350cd9069b07e426de1c0edd6df7813eb5dd379f7ccd3e97f3f7c3815ea8420e45052a59460318fb31729a90fa215f69022dcabb8c357249a648561e88305546223b03ce0356f5e36da1d7ea9972770b85539214883b780335c974f78109faf3b784100d65231213f017b726583ed888dfee5c35ad96c9a81b1e2af0241960f5113696eb84d2aadf4b056472309238d9d3cf820a977ce930e93285e87cbe8e5979910bb06f7b3e9ad572af5a8f72e46b9034aaabeac0b860b36667efcda1da9eeec02888040d491420b6e514287af216d7ae34a089959d9a525cec79579834fca231b0e533e42e79b0676c53f2f4faaf16b406a1a67e261c6d3d9f88089a3e0c389c3232dd9ec928a10f6524798b119b58730e3fe240391b2e61f4c73c44e6888ce1c592e559eae7128b5cb9795ac5cb05cf04ef113f57354f414c77cea9b07d1896f10a6bacf21fe4c7e3a532a7808606702520d18882f1450c225db5948d15d12055b9347047e8b4d05e361e3710cb9b3a88b05423eba40dea5cbdef124c0fd3d700706f9659ff69460a7b9e1c51865e2eeedc2f12c86d442746631b76cfbc986877d41f44e8edf15bfe352dd69ac19b66bb9136fd36218e1823a5a16b1e1bf0d5f5ec81bf8297e7ef5f497216d9601fd888d653bbfee344cad0308480d2a95d8fab007c36009daf9233e47581769b418d368b1743b2f4057c1f99f577e8ac0bc94cb373a499cf8196ceea5ef602ee46c63a8675608a23040401d748202767b3676a14300fc772f0b4526371bee2b34db89e1d5ba15e8de427226e1d9c5f611f4234836441978e9ab2e0d57d2646512fa54ca3cca0e5f366ffa5164375794434116f6a67cb7e95f7436b6ea44156e496ff3563b795e7e0ef61e236e93c8f0ac98bf3447ba65c58938c2ec34efe9b1b54b3d30c0d6c625b24cd588f155bb56e16c3ba59aace1d400369f639ae481d8a3be0ae8ede52f43651e9527820395cd5eb5845e7940a4b9dacb7a177bc01c7067661baec123fe5883b337d44ec122d08f01d8aa468c9f91fc9d98c4e43de92dabbd0bc3ff934687db6b98fba9e0d13cfae66fdb374a2ebcbc9758939ff2dd22a682af5db02b836f86403840dd8c59dc1e44f9c48a0dadb3b478ca5c02f4c84dce91dad5c1c1e2dbf83dedf9ae73c3e297456da1b746f5e81aca91e2fef6377c609e6875ae12584cdddff113cb486ad7206ff950bad7efe2f8fa9234368f38a39734dafda664f32a18243017af7b6010ca9b32625759616df59a8d9b80a85e5d443b517cd594b15466738d80f24c14f80a56485c40062eca762234c3093cb883903d46aa094b0f5e00fa71fef301b596dd5035bd36f438dadfc01832ec01f8b1a12520f0bb3aa14bb24d0c2e451d21789bcdbc827bf0932ddc251b0ed0ef63d912af7aff5ef69745ce274789b59a1760c8184bfb354ba37f2429e0a74fe0f7cacae5f6c176fb2d2ae588df61b144ea14b9425c7064c1ba3f804f34da969e8fdb654dbbf42f45bcbc1f87ef728f7ab27700f8c7e7a763eb188fc28e851314a0000f65dd05f2789f92a19bec48baed42272c165a6d86cafbd97fbbc2811642a1784c54a55ebc3165964920346ef37139eb8df3925f84766e5cb9826cd7234383abeecd612f3e97ffee273937cd80c2645f1d74214c8b1f5abfc9df5baab820f6d4afafc6a9240dc1b22205ee78a771de173fc959daf8cd2f5133afca11ccb0867832f09500ab6067aa4e785aa1549307b9671f40f570e6f4ac55cda57a04827c2af05a41384c83dec54f0af8c9c3463b381aec68604274a63b978c0c074b9c8c71e1c04eec081fa335d7e6e16b96a1bc12ecdb829519b1dc6194bbafd19a1e5e73e8287a146b091048f35b55b821f50f8369ccbe691ad3abca1641797cc28a71bd12157e7b15e6208ba93e28f781531f7a57c8e96339e3b991fc2a6617e760bce94d02282a48e6f3e5dbf102e85b9d5750a888a39355c1ccb18f49fff92c80833e71fd1b6fed9e98e91f629fcf5f6de082744db4cd9b52749a42bc0f04740960fc53dd2615568c2d3078a8f5a3a559c02e78e64cfda532168d5db46a4ae0666b005ba3bead7ae4f57a3d3feebcf76c249876c812462d55ded1ddb570ed93c2ebc382046c003683531d05c3f3938bcc56e7bb4821c6b1f388f156b1281ca94745720bf8a38e660c49dbc8f6f8c3191a3dde0c431c15a64abe92ccaf429852843cd01d260241751eefe10c8e049725af34d24c48892ec9add0219d69e1181dfc50e488665f97efb0a4e679863feb60986ee893b97f796a948159855f98d1ce40710bcd6a082df3c0f057d825a36412a24b373dcb1bada33c9841ba3c296b96490ee06964f69525f74cee3a10ac6ab46da60238cc6947d29866f0b645e0faf4129dc9060503a07a4f08a765bca8d86e5376ecfe6786d74aab04a16efadca96cabdd0dc349727e35b82f58c5d25625d69ce2950cd6a842da214880f06341219d47b38a5c7c1293d14aa395949b064e575575cab1a14b64809eaa960094ec3eb7c558dc8ecfd9340eec77922379f6d56dfe981e7bd81847839ebe279ac9c4be17cbddc99875f95aa325f2fd251b7a2e9ebed5cd50de86389fb9e0b7b4df1613bfaa096660be39405be20cfcc047c070fbb90133408df96d9cf0f70b951944a832b31f34bf5b77cfdbcb6e9076195df94be6be5d9b432632f1229b6404d7d67a52a995179e5f4cb7d626606cd667a3cef86cad43ef8265874ad7e03cf1adcece5dca542937d5a7bdd0f88204c95ae570a54ea971ec2666bf0fa6afe21ef66e0b92841b883bc75b1f8807095652b30fed241a9148fa6c805634c5721929d5323bdcfa898b4710d69ae914bc64a769d3027e2e914aa7d52a6433970df2afd7f7bee3d9a096645937753a11f0a2a2871c128d080a55706b2649621a9aef4cfe183f5d550d247d34e1bff2d6ecce55327feae865f423877f594ac3d4115c71e7b61ecaa829a65c85298705ea40cc29ab5de21d7c9be16721cc32aff482dc56d7cff2fe88d71d0c8e48bde72d6e9755f4a73f2d8fc4ba05765c84912f73de4651e5fa48ca478ce10f1168a70112f1fefdb779f5728a6d8489f65e5a2dd47e1f38bec4603ba85b0ec6f620e3007be4cf4c5265820b4eb5dc43b36738fb11ad69fb8b31e976a84adbd20b970fe8c62beca33908ecc4a81cea1b71ab7c9da2e8de8f1a52bbbe6b2c6952447e9454a37787bebb197babf8a3b735dbc1b46529fe8113006b970e73b43279cf2ab75442335a8cf86176d716360b0f7f6d2f4a9ef62aa00d31e800764658b09b9849f0536f43a94df1fb8ce6ae2affab9007acbe90c7c4aa4cfc4b5d9d3db129f4fb858ef3f02cf711dda2d29ec8d6ed6763a3c186c7addd805234c8b97d3505789c91734f69f9e1e9510fcb816180e4d9ead04cd163d5b6fcfc3e64802660b29f8423ce4f6ba609f28cba8e8d903e2ea92ce4f14b7767f69aba7bf500926c7cae17168bf6e8ac01378367c13ab3274b01fdd31bdc641b253d42528e7d356404313e31f8d129e568171e7c1f1401d083bbd31e9263fc3b20362d1e933ac32c718d2cba7f050bd4c20d5f5552c75753fc84573ab790e4dbad471285c5c65d7cfc6ebd48df9766d001c505f1d778e1ef057b083bf0909c451da0045c05f4344642223f7cc9cdf4e40013146fbd6c019f3e7fe55225d290f08d2c098970489082164b309cba1f6d9d1930023846a3cbe852f29941a8635192b400e0f7538a70d1d4d2a6a231825fff5aa5d3ac529178fa883ebca0ba2c96ebeff449526a8ad328172ffb94142af9d1a1799ea0ddebaa42c97a809e0ddd64e369ceb7284b08e000d5a76d8943df83ffcbc25614d1ecaa54cae3c31ee4284d693297e3951c7ddb3295185da68466b86ea72586f481519533ff39faa48afbc39f16937d19209c216f5370b1eef5fc2064148ce19a2ea04398c5a04606cb046b5eba616ba8b19669107981f2aafbc93b6b77c2724301bea6704939b5d615f4c35f0228c923fd858b739474a88b2824f5a6c4b629af468abde87d88fff9650414212e395133153361fd900f8e97dada24348331e8569f2be220db18083811a01e1fa26988d662eb1f12759bdbd8a07f00dbd3b1f7573d915e971e3732eb3a7051896cf63ead6cf126a2e688a9d7b1af1b356187f0c8ab0d32c8aca96356f8b5a3278513ea302c2026b9d03d8d22eba0f7a4b96b9b081253d1e925ab46700eadeccf35509553b7a7e39ad918e06b796e3917a2ff80a633b4a14b9354138f62254d763aed31a5f3a0e993a606d96ad914b16448e59fdc425eee1705d0086a9b6e83353b3205047f5381bd8517d77725e48da589b39d097b1e4368753202c876999d52643a1e4b39244dd29ca52f460240e329a505210f6bdb2358a7422c9a9208271a0b943017a8db2327ede7ada4b691810d521ca0252bad2ebe43288fb2e2bcbe4f5ac7521685824f37b6405a100c8e610c01beae9d9f55c7cafe1cbe297777e5c60208c75c906bd25680110446ea6f5b81046b7d4e4ad32970ac885a8913bd6b41595658da83d6d3497f4f138d55c9ce29d4b94620c6fc1499cb567cfe55e953601fb998ff0bd4de172e652b7cc25c77dfdde62a557b36345a7bde343ddc21ae63a304c8532cc34bb25036c26adbb6a03ebee0b1844630dcc4b2c335cedc75e8e1bf61365bd75e2b4b3607c0926729e73caa2b171aaf9ebbc403310a06fb00688755e30f3d4eb9bf5b0a0b9f93f97391771ee6b3da35c8b6a620aad0e4083d7d8afdcbe27b0834f57d1a9a924eaca06bbc9f2bd5063bb3fc37d912787e4eaada8ec4a070918d370e75204784045204542f88ca7b45bbdfee41fbce63c1d2c595c5c1a262c848a04a7734acfc0e6ec074c4ecf197ff39048fc3d4b0f2fba851fdc76ab9d1b7d7a5af27be39bd5dbc1307d88a600a2d6af853483e7ade89e649ca482f5fe966efa92bfae88d413e7acd1cc16a53055fd4cda61df9143e79511b8305deaa0051976eebe9a5d3998d75bf63c17528a98f83a3d4cc3012b91f2de7affd46fbe533e31355adace9ad208554e4b5b5025a2dc5595bd86fdc9379b9a09e24d3e63063f5b1e1e1966560a8c4a89534cd229d9e3d4337122a90c3a4626c44d0f26c776b6a474f0bb12543da85ddff849cf47ca3ca8e648554094b9e75218bafe3a81313d3e7363178992e3a77e87bdb4ac4510d9f24d2c62d9c734f65ba19eec2adccf5296da3ecf1a044df2302a320c4b9889483fba66e8a8c6fd9bf7caae3be6b3b8a58f1dacfb53316b78047fd4e7a94f9df170306cd99dff0cab71218f541b597b46fd129eca097e00ce3a23321ec0464d23edc0eb653472925193064096612f1edc7f669497ca86a6b5a7eb842c157d1f7813140c0c706dbee996bd76fbf6a1f6e99dfbb6b53a0985eb423c4377608420307a80816771fcd601de6cd0dae171a0e036d7ed75aecfde41e0a34ba04ebdc23c3fc0788a80b30bf5409fe08473f4a04dd59c56d6c69d78e56ae529637cdea10befc9358199668db1fcfcbe2cf2e4243d8903f42f867c4d4fcc9f9affc41d6213a70b544d058e81364298607b977e482db29e31299115f2a4218a44bc776f2f2c12e64d9447d522393b9b9ccb0cd0ac1bc46d9a9a63a4ed77faccfd62b61d8c4d0148b16f96b0d9867a2614920f2630ba564b5e0227a44b1676672ae1c0b45243ad3f19bb8d138a4ed0ab6f6b727dbde9d0a84df3835230b62c2a5d91b1da9c148e8937fc11324316b6e775a3842a61f3a5987f9ea1d13d14a07799748ba5966cf5e5fcb06a03db4f97107c6d0ef32188bbcee901c89d4d865c052aa14fb43aba6e94ef92fca6818440b4f1baa6bc3957b5dbd46677de636b43efcdaff9ce4b501a7d7d5e3a5edb2541f9e151197ad7288a142ac3cbd0022e10c5772d77925984fbefc073df25e1a3b1f5e131bcd5620b41fb5b750b843d10caf6e71e119aaa07bd392ecd3719fa01527aa51b2e4fcd2d45d09c20caf2d80fe73bcfffb0a209f7a2644439c5091b1050b42fe16c193d1be03dfadc8651fa0975f772b70dcd4394e250aa629a792c3ee921d05d42a1dc5270ef16232ba71035cdb2231bdd0e44775e40aed9848439100a746987f2a3624e6da94c5bc0f379e7938c6d14a9f82d50e114f124da643e7effc63c5dad978e21f001f49fd53c4e3ebf7270d5805e51913815c16384f25d3b2636b83e07b5bd3cd5c800ec111373253a4febd920c7a39d7c4615e42b926910e2cd0826ec724404b9e4679a58826e12d9064187553a7c3d23907f580f76f1f3c4d74142c0a7a2abc7e9eb9d8a62e77ce0a2bc0f63983853d168cc8ef1333e8f143643cd7d491be2aac22b32a6a362e434d7f807a6a451b530af2621e66213597a866c049cd6fbcbf6ca2afe2dad01898ee2f8fb7dd12715fc43cf6dccef065ca570b8106f01fc86b7c05a3bd4b84fb4b608a50fe636449811d81f99ee83f05f0b076b0ffb0a629fe4d41e62c453438c2dcbf8316f240cd0cf93eb2a1333e66f6d16b63bb41ab66c53878f2b5ce1999ccaa0e73dcf3318a6a1df4389a1c3ffeb316201bb49e27dcfa00f5c0002e3e08c01de93c250aad5cbcddc3850a93497cabf20f34c6aeb9db89858d368711d62d0d30fd855c9966f0912473c8c898e7ec0e7b5f61c78f7e8ea7dcb0e61b719d536a53e62c9cb90b4db72d56c0db2c84c8b58bc76dfc25d77d9f6b83a6fef0ca76911c32cfb905b89f05a95c9eae8713e7332e9136b9f58a56718ecc36ae2dfed07253ca0afbab945b89cdb14e3a97347072f49f35a8dc3a41632735d1825b0f85b7d6b4e286864c5dc8e0051ac5e70510e274a76f7900d34bcf1b8b450d9c182032ced70b8170a8fc0b754390d93bca39610a1c82df41fbff0667c164562f1203042097b0b04f1aa5cb087f65dfbd054ba3185265d1712a717ad84b4e23b7e3846d889d6be415df8c95900ce1fa42b04bd5ef631e7127b3c2c1ba401aa188fbe7e33abb9af0263f9be40498ae72d2416100fbd040c0a3d79704407451a2fd4ce7026b157844a598d9ba55bb4b74f504ed798534eb048048f54821eff3fab39b6347f51a68bcd922d8c1af7db46627a563d73096bdd5b3e326a1cd36627c9f2a027c2fe3139066308815084b96563876ff4eac8bd3ab7d8fe6c0d98833c7952fd929e9917a2ac56818635a3d257b7c6775fd1d064aefbc8e5c37fe173ebc6b02924c3185f9831bafa351b134cb59d43df45a24d8e37c459ec3887f88143006888955aa7b6c1a951a57b42527946da2b1fc5ce93ae9f056465b7f8a47e7374d4e3179c485bcd50160e5df69a034ed169acea04bfd96634845660c9797196561c9d1c9692ec2dbbc492c7a63ec4b2812408b696ea6cf4cd74eee91fca9f7af61f3d6c25a6a0cf4f42d37ed8a9e3dbbd8c6abf0d6810171b477a20edc4ef15491a59d65bb83d4b9ce95c92bbb430c69d2e056d47bb051de13d1dafc84807486846b0de04ceeba0f6fb276adcb67011cb29bf84e371c7427aa3de7e70b7159b397bfa8a2839cb40ff4953fe3343c02f149ec4d74cf5e0b24be0c84b6caca5ee28a3403545054fd204cdda66c25829a2eba86489c86bb3f046fcc37342cbcd5c863419d453388c8d80b34e7bb3ee6834dfdd34b09cdcc57467f030e310acdb890cb88477944a43dfef38ccae811fb83c2ae5b83bca9e786c7919f3a48da6fc35ea86b68ae2513490e3fa76a5be4ab99b89f6c027052a6a65a2572721a2423f7a2db3b142b7225b87e933258dfcff6f6d36c12db4dcd0b3cf9e9ed37666043b3dc872c07fc899087023b7cae8b6c65b7b0ef7fba55d3eaf81bbc844f49f635fdb8b778f655f8e6bddbff96cbf12eb403bc6bd2ce5a15dee1b9663c3b330c4781a5503f48a135a6c988566ff4f8def04760bb0c15dc268da1f405d75baf7bc6117e720e0a039a9fd1adffad7f2b2a2e88ac54d4c57ce193a5642bdb15f3a141b539237e3a4b2bf9bf9d0341c64a8c3d2f43063446e69baa617e2a4750d87810bde3b49f54570bddddc3c22e073d82b57818dc9c2b6f130b0462ee168228acd638c024b829de7fa03347525d5fe4fbeb3944e3319cd13acad0d4df887bd2744c1604a89ac9572c4655a86ac0c077674a44c4520ce67e12c2672aad5f7031885df6af0ee13917fa97fdfafe318e1a3b4aba1ac2c94144c09f6fd811a1bb01c99645e9968ce4e7033fc1f03329ac3a00e94","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
