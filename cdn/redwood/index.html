<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"100c4bd13a2250ef3a316a7cacf4fd596d3a008ab8b2792eb04d79fdc6a5da55f8a9c3a0235f32ad267c1538ee1298c7fef2f3589b3bdda21861a722a7f3e10d49f75179821dd46a1ce67202e1174c2f517b5c8d41bb69658b39b58f5da51b5e2295a2816895e2be7ba9f26c4f91bb0c4a5d7c606ebcc07daf2ca9c26a7d3d19814f4dabbb75be33e25e4e1d3ff1feb3e34b2fe5ff24503101f00951c7c7b2996b60e526e456af3e5b71f36e2c95d7951f4e04dfa0f39b96f3a6e3ee89b757af5e311826cec15c242eeaf72357776b7cfacb445951fae439641ea697ad24c30c84ccb537e44c2aefba8b8c8fff7985e5609ba783f9dabb464c4f3989ea0343737959724e72bf0abd4e8300f116922d1ae561a45380176ceb73005ce035d512973124c5bf668c7dcae2d302d2e1dfd33d1d1f927aad816b466cf51bde906aaa608822db2f0b0c2314b6e2f9174852921aba0da38e0a61c51bf94d156365103a86926ce38c149290c6be875c897b4aff326691fe8fd9e90e9b404952953f341e71d9733aff492d9f96a22b82e6f891d585a93b53a7ce5628f504ce693c43e8c3efc7473a96a62bcbb2f14c4678f3b5e8ca1a0daf361db0358b3b3742971c478bdecfc75e392d5bf8c2f198e38555066ee956f2545466a9fb7a3f553b77141d228b34808c6e41a95e1b58f79be3abc9f5527936af8997c1bd1a779a3a5971a8d77458bf0c42ea7bbcdbf84ec03a9844201d3b5cb6df62b51fa8f2e71220f3f951affd0d06822e821f30b20ab90580765c36e0bdb05b07106e1ab669137bfd9fe073850b429aeea59a943147a957b8127a08f324eda36c54c7928496eb5e39f6b274a03521e39ddb3f9853de1a8ba41b59d4ddc6374b04d999ff4144faaccdb191d1dc01e99807fee0fa2e0e4dd660c8763660ae2a5b01de0edb48c6a6680b1e45d85e8bbde18454644b9525beae128b17d515b19c75e97e668ae332335fef4489fc7eec5529514bf3f7ae809b6c82a7aa729177f3862330eb40a11a63330f76b90a35a86e4790256336899ccbd419df2abd31eed3849543cef95acacce41e98741a2de2ff4e942a0142b17f05904735fcf1c8bcc52c3b41acf8b6d66ddb07e3646cbd065f6c09b80474ded076b0d230c1fc5193c1ab99581457a46473cf13816c7a95666c697087f08bd7dade428b227ae5e2260e3d942d90abd44f9cfadcbbc1b6c934acab6114c587c53760f6826ef2f9962c266392d7d49cb0616531980f7a74bbe674f943bd90eb0ebb87d9d623aa97636ffcc43a6d82f78c08e4a7aec2853b869e4bdbb9e6aadf62665623dab72bc493cc5ab745b3847873ab3d1f19292b2db1c58eb499faedd85d1acf54e65d7edd3a3545520b33c52c3a448bc9f918d5e009e6381b90895dd74a6bc235e2424bc0cc3619caf7fe4e11746b28e17212d06ec8a1eeac29585db063635bbd4f9973ff83811433e9ff989e0f9deb81d1d01b95e69a60a4b69f0bdae71a1ccb18590397781c18f34f4af0d44afd225b4d64a657fc04071e2b3e10cc63aa5b7c93c42999a01fe73757392897f760e5132df28dd680921cfa926b39c4ffcb5dd22927bbe80704f93a611b75a8d13bf24bdd046f439f1893bd39ca2d8551795aac9c936e6b241c066c866d0654933be98a2b4281d811d83cf1f24f811320feeb15ed9dc1da3e52420a570f5871379391ba2ab05d5f75e480e01e269d75584f757f60a066ddde2af4a7163ee0c0b6771a8a1b7c5cef4467eab8c9e7d5416e266ea0a05229bfd73481c92544a29a56941bb993cf3fce94435d827d9d12a8a9550865f2636eaaa348d931ce361d061e7ca1cdc5c530ea8b54998230927c3f4efe21169bdf211a4ec9794c382b490fd204f82cd6a41319096dfa884e36db7e4a0ec0297b18b7f25c27abfbdb1c3cd4d774f46489af53a8ae090709d1c363607c00e3b02ad6547e5ac19c9399b49a4652aacc00c1a84cc626fd69b360f017860097f192294fddd5700697fc8a771f2e516c5b0c3066755dc126a25ab8207ac592b2a6aa9c571a83eb3af11f84c179ad5d5b326b8c8e4f1c0c2cbe6bbef0322a6423e94794e718805f3a6f90d04ff9f6e8e92cc615cced0a97746ac467554c854c28436258769186bab6ff2d019098195b2b50e7f717c276354580467422f758e79c9794139cf4a590530e3f2d23781468df8173a3aec605b9ca9b4caa5548d4c9506f52bfb95888ef8a96b3e4e33212921a739ec3f9a83f688d28f31c786f3299f3a0b5705a613d0dfebd5f51f73d654b8d11c3482ac22b18b8e54be3b3c771f108e9451732ab999015d214abdd9c2c1fa8d5020d84e53204ef5942e5a58c3e07a34d6160a3719e87f9772b8bdbe4b9f47eed9159e7784b0efe183bd5fd69514573e78f75016381f56d8d6aaa389844348e8a95a77b3bc0a59575eb50e6231f8a6a7ec42aba0245c85deb14f5ed8f554d4abcb34500e4c478e9da452fc02c7f0a830708f6a788ef367543b58f61a2cdaeb98c84cb0fc8f77bb7222c3637db68101b158e172c78ecb8381c33c6c9f452eee2ce6e2b6ad3a84cdf5be409b8d5c24e7b7b6991ebe8c8dddcfb3c611947221952e661d38171e58f6dbf1b66c15d2fee25f688af2cd5629d56691322c8dd83fba9fde69c046c5790c49e8f35d5bc1bd035046efbacfca9a45c60e05a5db50064689d42f1713a59ddda148e24de0ffdb2d18013d7529771d7100d97592a3c6e51ae2740a19616eb02b4f2e727a039d03f2e6ff2ea5eab8d971d7cdb39f22a52a59261a595d6c0f1586172fad173f0d0c7241dc0ed38f155f4291ccd0d6edeaebf46262ae6966ef0df4f9ec56e231e91d787f4d9c6298270420de0ccdf3e6e3cd85b6ea4ac894057a44b8e4a137cdc1ecff3f9dce4ac03a3e0f93546a1900d0bc44d39b515a8b3464ca11b601b48b62533af28aa6bf91db04aebffe8acea22e6a5ad3c8afaf6e730b8da01a2abf98a7515ea59375be2cee62817ed7ad9b489b5be171367fbbb992d32723c293552fc89e913eb664745b6f779e41df6070887a31dce02cb395c4fa437dc83e415a30b0fd2adab9ca9ac63ffede946434ae6447c99b23bee8792a1a2826aa32048da76cc8170eb44a82237429348344ce7bdfe18d1b333c0865c1505f7b46861bb50111f064ef35bc92f0763a91c95c66a4bce6fdc04f872d5a2b17bc6e195d67479ebd311a17cbcf7a0a5c66d68e3079cb07b891f1bf8da8cf78a632bb00c9026bb029ba8f561d0e901a2e47a3209bc38cedafd9ef37f0ce50b8d0a053aff87e751a1622642e0e20dcdabed2e561b1df13912552f4fd0e6ba97265bc3ea70581fa272e59f4f16d172b01d217614a30749ee8191215b4af8c640cb88404de3e54f760905d3bba36691ec115d4bb109530f930e425de51967a9cde2f459a9a1630fd7772eb61709c9bf57667a809c99026a2343861e34a60025288d002f0f4fd6118f79d6981ac2ca1add3a5e499b2a15b41dedd7259cbca5d068b7562679bd3047d049d5586e939899ce982837cc4ecaf98f8470756ccedbcb08f4f24f69f559be239da0e0050a8adeab4dce9eb4d529f76947dfd81f47174e95904e7440e35d5d553a96eb19b2718febea86350ebd8fad19a0156441d94fbef79cb47445219dc3ade95986e7b3dde77da930a1c61d368f0ff5ee65be68e18826f3d1bf791f93c0139f4147f73047c08193d841ecf55e55252cae2e6e99cf8d64920c37d3cdaa76e0622bb5876f90e4f201f20b0c2c8cd10a8db842b08fee48286cd6c991bf6b37a8b8cda094926b804d76e7511b287828fda71326ad34284fcdea53777a99b15916c7dd28ce8fa375f37025387ba01043939071a2350b34db7db8f66e395afc94de5e0c1d4b3bff3404ed18b4f1f239ba51bb2ac47dd70fd6e465fcaa916761ff1a625fed17b46d80b090e7b3f0dfe7a28213ae965396c104ec8dba56428346bc14d0ddccde8710bb3433d9a7c080ebe15464ed233f15fc987ecfe3643d70f0321f97a3adca2e70123a246ae71f56ae141f7725f017a6a0a305d7ceea5bff4035fdd9d933750729f72c4d13fcb657383bff79b17f989494dd9247d27b3266a34badb11d7a51530980f5e04f52dfef46f21981602ad1e4fb7e95a0ff5af42329769aabbb037007790af7d2a7a5dc91a2609bfdfc5137509775a66bbac01eda5b93a8458fe845eaab8bf9b74a760b18ada4db405a00dcc47b6360e96cca5cfca808c7201fe33b2bd3108bb1a3918db123e3e1013dcd62713c4b37131854dff6e527fc963052a24c6121707f9fa6014ee4d346180c1f0f3c80203fb276cfe67b11ac26faa6ebba7ff1125f30b289b26ed8bd8c5900d58ab4ee86eab82828511b75ff04be88d020c332f9117a61e7b1108bb58947445302e121187ebbb41eeaf85b8a3b99ee6efaf33c4519bee1cd2441faf9f94943cb8915cf196ecf58b486e295bba8113398b4094a4a98df4b01f68fc3b71bf55cdae634b13486979d6a427ec367cd3e637ca0e0f66d11d3018c486a2d7319e3c0aed18017558dd36062d23b685290553fd148ae5485d815f95d8eb519cfb3dd74e415fdd0a0b9473df4a05108d185a98cbb68a31b6ad0e189a7bfe735167496c00a8411d43b0963c6fd2d5f8f6bd3c4cafa1f88d90d5d1360bcba60d077a17a1ed8b7d63be7e3ea0680d4b232ea9289972a8b1192804fe5201bb2b44dff6639badba5a294d7e089c5630d3f6a28863d69e8c437e34a3edfd082ddb6ca9c5747369e4f4e29881fb4baed1617e7598466be9c661ab3ed0db4312dc653498709ab74319d53853e9c906f0545375759ebb5896628487f83d5c43dd9d98e73db1c05ed4172aa628960f292cbc75a0305334f517b21ce305508b4f5414dde73c53d4b852cb9a0a151ccb0cb52910f63fc76a829a61266f113c0e5ba56ee9838a2aadd54ed63e558442d4e813f6c72422918a5bcf6b201df4c98d5bbaeabc185813cb6b41a8747ab58292958c9f20ac41f694592bf088c55f69f0cb8c88f3823509309b5f8b3a21873b11668cddd5c0cf1971198035b4d2a7389c1e1f428073785935041fade1c215bcafce35d77fdacae1183f9bfd15e4e6ad26628366e5f02b50d24667f644917e841b0096c30fdc749d9f9b799b8f2aad7fb730eaf642f23db3b7dd8bae3693ba184d7b882fa6f7eedda1982fcac9833ba882f29fa9bad84c27724fa4685efab7164774df03a090d1d3d28985647e2f025877ff8f2fed5953e4cb6666b0e06e1eb544fb97e634c4b8ae0809e741c51c8dfb74916a6b1c601d14edeccc28151d2a6bfaf7ceda0c44b42f19a820cecd5993c0bcbecd20d3569b3c7ec128d887d68cf067294dcadb8ef37897fb7315b19d17397592fe25a8e363babba39144dded9d917fe5ffd112bd58166cdbe4680fa5b3efcc9b76976c2e8efc35150280c54c9e5d06312d6636b133f3b836148caf58033d8ee641631c4c3cc517ab227d34b9d2514dbac05d50ffdaf3dfeb6221341c089d550ef0311fde71a0ade058e50f669acd43c5535795ded8e4ecd7683d8b233cb19432d9e233722ce263404f3ac0a4dbecb49df266e770a33a5e476bd241980c52e447dc87c204f5c5b9b4548e0770d32a67a3c188223a7cbc69da3172683497d934b0a4edc9339590fd0e49739fe27938ecff2be0d902bc05c77118a8094651a4160d472fa9a3118d89b4b8fdb9133f0b0f7e8fb374b5142a2f90a3c97d1bd1585b6b8740f489db4641ad66a7324e3e527f841f92a43ef0a58eaf7a88a7a18fb6008b7b2f080d2d88c7c241d228ab696cb208d456196e58135ec841296dbec0675803d66b3672e543d5799ce0fe322a84e358fa0ef3faf0c0ff8916a1ad12d7131f20f72fafe6c3dd523d1b821d622c704279526abf247b9d00fb2bd00714cd21ffbcc516166ce708d5f291e44d7ec2ddcb8d4ffd7a2b9926d90a2c61c0a27830df1c8c09973efb0a7ad284c93bf69176b6050c5d84180b57e266bc72e47f0a9420dd52c4d7adbe16fa6324873177a4152e0c74c57abfe9b18954eb548ccab7ccda2a19fe7884ee73433f51dfca2dc183c9e5b53f827e80fa59a1986c55c75ceafa57a4140a31aa77083f041d47d635a127227b3f14976d1574949a47ea999f1baedc46c5aed21288671656c99404ef7ea5c4219d4b949faafeffcee0f87354418daead84d5a62b4646b21b4eab6389325e4606157add0bbd0c8fbddf14d5cfff16f58c548421c4467720bbbe4184eeac761bfd6f2120aed594a9b0c8fabff582270764249bb05c4045477db7a5ed8476da8f530be8c174152ebe2236c2ffcee7598161ca14603d8015bed790c96e1eb2298f77cdd4a275d633c344b32dba3ecaf034dc48374f52a41bdf29caa185429a2326b46e28852d69af6ea98a54f72d74acc53b0c955c7a145bd0b976ea1824d2398b14341ac688eb4df4ae938c954cc85451cffdb94bccb4a590dad096bb8a86cd961a7a4b99b503ddc282393a8b1e063748bc8d6bd898272f886aee7e1b8326a939bcd02ebf53f19ce785ea493e8f0332e954cdc6bb6152ec110e1eb3d1e74cb75b309cb4c2ae56528166b0b0c4992733f28a91d87f6cad69e1d9356d19fcc878cfbb3dad6e700278e5d37470308f5e2f30ebdf5ca1885df378d9503a0bf9830b47e7f7bbdd502c4916372b63cde0b50d3a69ae49b44587256a030a7e44c6c4b30b87847a8d306934d677f1f960e655abc904f1d8ffbedab6ef275899d2f54ad857b29dedfc606574f6646cbd229d941069c7a5c07ecdec834f7235dd3142b8ca5940ab39aa335e6e376b7c37d23831a2c4c2208549778de689c572188b68284443eca4a8323e9ceafcedd4b7cee30b9eeec1f729acf8ecf2cecf5eed7b7ef7daf19da4854c3ca91e8ac5e85b5c9dc4dd8852556fe9031a5100dac537b3635b423228fb51077d5441075ec9fb3836045e8daf89921734c0910206773731038464b88d4e95d3f1f4a8025a448ca43ed57f17bb0c9ae91ad985b6fcf32f20579f76f065b7caa4e6ea22abcad73542dd3bdcba25be9d658de960dd5ee1ef58bfe5ee6986aa716b49cf9383fc733dc7dc10c1464fbb2b744686e3245c4e20948e912525235025d76ae2fc739bcc6d24b83f23b2ad46eb5e430cdbd859238dfc00111f601241fcbc7938b35be68db2496de75aeca7fa64ea05bdd6654c0875444898b6a59496c2dbb4562783249d146e1706f7acd8d4fd0e7dfec7f76c88f1683df7788875cfdc2ea6db055ce2efdab40a2954a3b7e46e686d8b06734db078e723a543412af74498f8f95fe0635098c0ec0820e69695166e7a46a965b4c33aa2b6a688979772753eb61d7543f2ee9479b4c65cefa411f324d3a72b156c8d0e74beb2b41394b5dbcfda3f7baca537f52a725042486f4f2633f9c0eeb1b3108b3d6b40d68f25250bf0964a180ab4a1cafc5bd1056b22d9a962a924ccddcb0d990974cb773815284c8a64e8e2d0838c991d45c56816e95c39ab3361d0e6e95eab0292fb777803b541321a4cdc29a586f75fa1f8d03051b21e72f37464c55a4edf728c511e51b49b1c7002a95c1ffb9c27a00b5e557e292bbdd92907cab212d6ddbddca67f494785f0a77846a208992b631112f34731046c6165aa85864e940111ca0046ebce7f3638f1dafd0f9fc51cbacd0f20bd0453c6bf577e4510fdb10373af857803785d629a7419eebbe2bcf43e87949b4a8686d5df3b25230189da106f80b0a0d3a964ca0116261e4de6015d7a6fd47ba026ea6d3e8a444067232d5dba3aa6ac5a0b9c09be0f1da0eb86350e4e49fadfd91afef4cb261e8f66a2cbcc50dd5b4762811d312e5c5c4a10436ea9f32e615dc7eee42af5742c4f77de0865f3524357e04d0be1bec456838df818c125dcae0e2687354a292efc9e443dcc003b466c02a7a9eb7583a306a9a2e4bc9ede738c22049486d30527287da003378aefbdeae0584398ea0c6aded15ddd9d658a9c1179a290cd2473923a5eafc5f17582257a2d43eb5e789aa4f18edee9ae61873858257892c84ff8dbe636f1f8ef1fb019d53c50a5496f9ebe2a7328582654c8c28b86fe14dc54a9b8ddd675fb8e64df2e27999a762898bddaa5ccb13e2898c8ae3c08caceae4fe094091616e77cce7b011ad75e63633b85dca725519e556c84cdc36334761d6854c990c4a4f8d0cac2628adc92f4b36b78886b7bed1c3cbdb3efea22c232f681406777d0117b34a7b48ac4d43b5d89585a0b562c63aa5e0f82bbd14db0d6d7e7f548209318bb20955743415074f60f15c7bc30c29f8c0ca2f526d07b0b453ffad9dc3121a2a17e504f54fcef38437defb05593b7bb2f934a5cd8e286a9c01a2a5287953069ed22f93edb88044a93e1ed2e4ca4166bf0f2e0ca4f51d2b464934d7439d0dae6f8218c9ac6ce348e6cd3b041c0da68de2ca948c9e451659eff267adc16a24814644d03a05179b7ff45157302703e5ae608c62dbbe0217efc06319b700eca7dffda4ffa45d93804e37d192dda10c9b362b4388b186e7a50d69532223f496c30ec7b1fc16058b47bc67b1b383e43b74a475ab3624acc7c8f18c46f1664fae52e4f25da7e9c55784cd76a980e37025d1f2a578ef7838d8419203b17c7e9ddc31a548c76c633583ec63d716269411c241740f3d0360d137a4516ab4bacaef2a0f5adaf1677f17726f4b5bf0a774afe990210a5da9393eac95b6f816465645c8a830ad63f4a515d7b0aae682ff5ae977ef484011df91462bec1200adaaeb63198dcb47896c6de09efd1a715f297c97936adb621e74ffbbaec16ed48d6cb083aa5baa8227e203686d24e1cf1f650e39f3ea0d4bdf9803bf263a53a87e260f0ca5417e59a962fb0f3370fadbca2c7b1a026e128a0d06537502e52aa8f49bb7e0d44fefc798a1479fc739a94540281e200c78f4d516c280cbacf544a5ea4e48d213aca70999debd4e081b6b88b13f5b6e76cf86ea59d6406fc8b0166c5f88ead8e134316b4fc491ce968228af91f66ae306a627987398378ff079c9a5b189a4739f0d7abc2a0918f4e27ba3348cf9b0ad7ad1cad836bb537ab7d5bd9a9d2fcc75ae3d54a7fa4dfd181f7d9f48c49326cbdbdccb888bf4fb3a2218a38f3b0db10675b9d50e76dedba76d51baa641ef05c032cf08ef6f1773d9ec70d1df59b8972b6c81af611c117644160cfaee79eed34f40aa5c9f420e9b0c57ab564166fb01dd6570f8b9a1d51487dc799f0d7bd7cabb3cf1f89d88190d51c8f17dc0a2ceeab893ea8c90f85f715bbb950061a4d05e55608b7b88827a86786624f0ce55bb35a502abd5ab81bdc3fe21336f2c8b90928f0352f5592f460a2d76c7ed4ce024cd50f50d7fb8ca6a80c552efd92f8c5f965b240311c2f57aa67e0404c133dd5d68d6721257ccf785bbdd0cc166294004bd7bc8632dc2a30000c88fb95fc23b1b8beaff94e316f9af77928751445ad06da292d4ddb94bb2ecec7bf8b791469a215af72b6697f76c6ad1a3a448d024c4aae12b406904d0d9b691923a2962255fce5ad4e42a9cccfea153d9eb1cbacff8f18b67f3d082850bd7796bd62a3b6cb38c7a0b55079da3b64c3a3ccf8607d7e60d04d4ed59f7fe59adc0dc78f7bcc9ec6e5a8a3f7acb09c374b09d47ffbdde0eeeb21e803e0575452c543e6eac17ca5446a309a8393a3901cabd91375ebc3550d8dfd8d0b65dc1c0b95a9412e074dfa1cbe39b10be348e69a66ad2f95b259e6deb26a4950ffcf9854e74a379691a0685e15cbbcb7ce2d3544f75954b56ebff1c41cc1372eb65ef78aee3549a0db377ff83d7685e54c0111fdc8bf1290016ccde27dcc686cd19a28c62a90dad24a4a8426e55a52c241781ea142206d67566af36a16cb13536046a121f49fd0ca67ac9119bd5c606c7431d011b57c847ef256265e7031c8b4905351dbda962bf88b87fd69187f375652ed13a16aa21fbf892122667bf3248b6035deb7efe083359039c9cfe4834febe803caa76d22f8c84a34152991a5980b38b495fc990f015545765d56c7cbdaa98b9908f6cee898c74d81d1fd60315041514cc4aa57b18735be0507dc2123a3245979bc5cdb025e63f4c0d6b783946de765199abf5f2a52c85375b4f92a581fa811b6d69f777e00e7aed65c8145da61d27a91fbf71c4991ebed9b09777d2acbe2d96d4d7c392723526f212c9fe40e917c03d6a694fbd1c611b7434713e6eccf90046af04d335e08fc700b05bf58651d3acc8e4ec1488c470a63a5e52659c3372742974f48b413be7669e1970a7454b7103433d71689d2f75fa319dca2490680a381515d450edeb6f0d13eef4c31b32ee72265ce7fd0117db551be11b878d67f10f1e912aaf697746dc0eb31977cefdae52f1a8f34cb0475f5644c3ff5fef934fb65b76a6895893aae9844b97cf392a23e2477c5c15f06bf5ee714a56da8d0e43df4c9037aded052801f79513fff0d78c5e8d2e56db034b370d8d13aa4dbc2045e1d1da3bc474820fc509eeaa62475209b10adece130ef5fa0025d9fce6e9d594af0a25fca42f6e37fb1856cae3dd99b33a477877bcf7ec479ae2e2bf6a4def260099efc4ff1f4b5128ca48bd5dbbd554a2e2cb6609243b8296da147e80b3d532ac3f4ac9316adcba5a8f16dbe993c4093454570d419fef220fe31e97011cd6e60643791dad3b95df76b7f077d442686c3a58ac856cff68e16514fb86d882911e5979cc2d05eb1e2bd0e78636adc37f146fd3119161c7f84952dd3650ac87c45138f3abb5513935d617c95388f73105d166f73f91991fd470716a5b4dae691947615af5d191ce53321caf85dfc771e3403cd1af225b17ac3e4d46e6a94adf2e182a4b8a376262e8fc2decd7f311a591633e6bb322b124814902c6d1a0b2c4755e5aaabc0a6e539277b8b8565ae93d67d841cad54c2f2d66d4cd45a0f95ffe553ed479e2dc630d1e461e68601b991e5e3e35e32cef7f0e351782b342e58f4b83a0b5a9a8d5d423ea951373cb16e7a4bc5dd47acddf7d8a13e60192a01cbfb0ca07579b46f60e2a89d984aff774e24b60fced2c61064a306fe61ea2c4dc4b21bb2763d33d6da304ec624bf941096f8a0c5adfc67401cd2369d380d405b511385137ec226b54a55ba88e2cacaf8958221b278a9801812f6204f66786d8816ebc00482c8ccc7f15782da953d19e8a318020e13b4530248672086ef298731817d0a1b679d1aa3ba35903e6a432a21bc0d08d97d36bef4fa9709bc69604a0d0d9ebae81a0b8988252e0451eebdb09b8eec73242b927a8f62a50d326bdfe436069c63b940ecd048e35f6102c4def611dff59c5a2ede267725f8587d535bde78a1f0bcaa7dcda609182847884676d97c4ed91addcd368b45b3b6bdd50611ff0a501ca5cf767ced8e5c82f3ca48a0b3f0f3a2835a466d5d1ed37ab6468e7c87b8378cbaaeb99373a438672f61253f1da9232bd747bba1f9c9f6ba902e1eb4da551110f3ecf23d7a51d093a92d59e46d406479babd91a394b40011ebc8a582749f64d774759e4f56386177c6c7435929b761fd3252752bf349031e6d2ba05fa906cb67a98ff3dc4479c5f303945a23b2b01a556236fbd6419d93e708bd1e6723feb3b1041af4a5dadae97fc05b1446edb5dd93a85284cacef67ac34dcb3ce46847112a337962145176c55a80706633f6f7e90b5411494d42b74fd91a8ea336dff0d1fe15ff147c909864e175628de438553960a5ac7c1ee941c41b09cda572f8b0498b0c53a0d01654830db5ce8cb488bbe2e487cd43e2e12f52eb56ba9d812cfdeaefef7ec949ddc1129c5e4f3da10fe30b91a4a0a15b8a35d9205e03a326e66605dfcc51761b2db61216b76323a111b3fe5dc49e2afa74c313d15798d80720062e7c175948fdb36b758be239a8b518cd13d450c104868d8b08b9e80d8e63daf9654ad8dc90274a3298bbc7c5e1dc6e3ce0fdfee032d0ab62b11807b1696c41a646bef8de31d939e3352c969ae96753197816bd7879ac88fecc7824fe7a671998bbd7025f4ef26fb1ed4622fe666b9175eb9f3bf7ce9fc380bf3baa0fa8aba0562dad64d8d7521dece6a4a6588add1c74696f4033c2e1a2688327bf6799b61904afdee29bea4bbd98e5ec03fd2e88067fc8e258b1638dd5af5749488d396e6521025558d168b87336017699cdf45d459a8b26b02ab4628dc0a084ba60807723eb0295c79109ee616eee4c16ad9bc66149efc86db4a2667427df4084e71c0c0d4e1c3dd956b1aec4c66d30c51a0a39f7470c95aa5a2eae87e38a5294366c993279c75a361428e77156caae42674912d3cca1ee2e30cdb309a3fd134365e15d780915127bed5b98e1224470b1d0b350b01fe493d6d762d85519888cc1305802721b49c4ebdfd2ea60246b106badc975a9b40816ded7433276f607b2e803c54288feff8d508dbafc3a64ee192d19d6a8690e2cdca45f768a974566e7f2d2a68335640b3546ddc4c72b1c291a4b43c14ecf2aab3042ef67691173975a639270f0089894a9f9771e5ab0b5e76342fb37df1b959e489807b021821ec376f8e2024dbbce1f691980d972496e4a04680275683f0bf335ac6df053c0245cc250d2d57efc1e7208db7b0603579efcee5d28ea2554fb9b0e16936d587e3d4cd17f0a299347a9f9e15041316898bfdb60ed3d1e28f1b905d31d9076a5287bc232e6fda71f08de2dd7299caa513e6ffce71a99e82913cbb35822252ce2b9f93ffd8b533eb50722254799079e53ff1be5a3644cb53fbc7f2f62d55e5b48126b431729e7e5deb2ac8308987386dee181071ff667b407560ebacc829fe0d275df4b15389329fc2b3e28c4578a87c997b9cd3111ffe3e6195ab14dd51502e1493ad568c134e5df59c41779975cf4a62ac3683311c82cbc5579bdbae1368c79c362e0295ad12cda87d324d953a5eb01db716b97f411d5b6e0e211ead0d8815e918be2b4b702798a493e2f8cd1bea1e231faa4e12df9056b016818b6c9210488d3db7a62096a49ed47ecb938ee677c2fe1cd0e22a8e5cf88f04f35001674c11db56053b33034ec30ef0a3ff163ea4505f4dcbd2d11cb37f850cc80bb700e5c6b00fe0881290016672165e676cc649095f46ab3ff78324fc6b48bd5c6381ea897c74b1440dc6cfde3464230a44db7c0df459291e334a25d914470a5857bf23b9ae7da129fd5b629693e44966943197e3f5d6c01104c7a3dcc22ee6a0704b849ae8cf068d7c692ffbad599e2d93b16aed88df9302b5f27dc2e68fd3ab28116ac3a095efe7e01c8037f83a60aa748e2449295e356a553fec9478bd6ba4b172da0fccc24445251801671c424404b07e7ea5922e122c1dc15d28220dfc31a1845af139e136932546ca5b4e7ae69e5f2d9177fa4c08881f3f5be640a56551280250bcfb8df833085ee3d101a10d2e4442d6d724c83a1c8c5e6ccf4bd24fc3572c9d9b8da278a5e020372dda69a494758827c704b03681caa1530c7c5a2e241d26a0c41b04910fc2f3ed9990391bea40042cc52034b6124106945b2a35bdbfb73dae184d8f38dbb94fac0b1fc23715dd452b7624e2e4d4552b644f689fbfc0455e84a7be73248a6994e2ee4ab9e0ba2369aae28bcfc3c957aaa1b64f09a0aa3df20e1eb79802e81e8c50af3d02c536daba96cb54362aab66d209fe921eaf3ac6056cf6df7f97f6b54cbbc476f149c87117eaaa64b6c3e1e1d378acb156a71db527206eccc61ebc8b48f22f2b0b5656627ad4d4acd8c6917f7bec8b8714b7fea0b900a4380f51daa0f3b042d047cb165e9cf5bfc4be76bf864c5f94dd558013761d8ece1cabd0d281c02edd2a471b9d82290765e93db717782bf81df22051f55d57298a5b3ce9a6c935d98bf3760c031eb3543cd482de58b08e42348a3c4e458f772955243b19ba85b5bf1a457352b4e0a07e2d3782160e4c16c6a9e2c016d5e6a9f0af1603018a19007046fa0d8afc10647712dfc5379e6bf3c9d66e65815d9b8f971cd339f2db2cebfb31c4660a865c5e9489b16aa26d0e61868e8753ebeaae49f9c9763933e4d9041382e25cbcc523b118cefb36f5f506846953c38b234a4d96d7356863ee6074a3ed6370854cc9ce32cc1175c9735467f634b23e6e54aa1a08c60713bccc96207e2039e9f1e0da1dcdc4026d895c6f65d182528fe61854718957cf7e83396a4ac6eca0fb299ec1d1b725c7de6ad346399d1be8a3bd3a50a3f9e556f97df628916cff626338ed845eaa207d79642a2aeb54165d698edd758475a35e4d0e71f7b668d06662f0bd00b3c3bf5cd5b00518db651d364fb6f76451f001a484558dc20f2fc636fad7cda65f81e6e61047834f4d2a25f6b04664120757f405b8875a97966fd1f4abb811a3788d74cc34f0e4515ff2c5fba145e7b5abc9777f36f91c375da55bf98186cd19fd72951ba1dca7adce8de0b859a2670ff816450e73ae356d4b2b4dfc2fe9f06112d22a1d973e9b8bc55cf7350e685cab2406003d53ed3df8dcc9340243cb484957e9f0b67920f3bd94eaecae723064d804a2dd77c2fe5fe970cb8e446e30379f6fd198220dd2dff7cea1ef8276e202c4d48ecc8067c6c376f717757b96df716beb21302ee35f60e698b0434205b87138d14c01b258604ffb1416df36de86d23357ae7c2646e2a7aebd43da5c2b4fb4198f7eacb7d68d0b9ea5212583e58218d4ce36fd7bbf03eb4011195c2954e4aa9e9a4d3c7f184a119d4f4b70af494be5308f3deafd4e72ad21543bc6482f03f666f70103a6d1fd5d43427488b0a93e7036b6781f1e1f2cd47ff636eb070c826286c928e3ff4cce5865f4922a23adca803bad896abe0a5d93820bd3a62778164693fe2090c610becb191e4be3916ece23eb95651508c8fdecff13d50c81ccd6277d2fbed1e53a7013681c22bb05d5f2e025ff37695c0471a0e2b63c806e691d1f7aec071e1d34483003d39f2b5a5a9d35f7ecaed59b066eb41630aff06b98d13800bd4a8762c460c1da67ea694b36bede4c7c50b8fc0053450137c7ecc81aa8c8695e59aacb797780d57ac33e935d35d108aaf5cb2b06e84f50a89570c882794dd96259f44f30d8ab31d88acf62d43eee0b11511f207b626beebaf8de9e49793a5b4d0d1d15c64042236ff77d4aa3b18488523377a15a61623aa7db9a2a300467605b7c5853ffa8c502608f4a0a004b763e58cb7a326e2538244e79ce2783781276d56601f0d390b158b38207721fcccfcb4c44b260cea66639f1e29e1b47c060d762a705ca53c6f9447e6e5f145538b2a200bfa11199f39ad8d4d1a467c51e11befd0e516daf8a7e96fd6aa28b26ee0cf9a63a5cc13b7aa54599a0fed9ddf129586cfc1e1fc5a9e7d60ce754776d59acc76b604d8c5388f3dd534f043fdf8079e160cff50c4fedf32ab78c1204d8795678bdda32e698b47630a78225b82a8e75e7aaa52c2f5eb0ec9bb87045fb86d848b6c17dc4df7791f718ef432d7a84c3d260aab9839e33e90c7e2dae4185ffa418133df90eb0260552b013876eb6ca82125e7d706512ff849743115c74cd768ebd1f517e833c47dc9f3bab53fa45d67d7a8b9ffd6764f8cc13f39574296beadb702e710786667e6c04cbfaad8cdea1ba7593344ce65fb3935bc2b4270990113f0511eb9c1be19ea25dafb0f72d029731ffceae78355e6d4d1c679a1ed3c22003462cd461481a544c6c150568ee9787f4a17195265764ed545237f1e8bb1254a32ab4810be427576ed490b1f8940c15002c6ddddadd63fe69dcd9a0f30d6eb733d96ef09576f105b05b7c2b07c2be23995823b38f9b4cbe21f6b150a90aac3a1815869b48c612e3ada10e2bbd0258de8afee0327dc119380ff08b3517b8af514f8ee41ceefbddf9658646b5faa027a75b3285179b9296ccf2a07797324a01c4e2dd47ce9c63e60a039d3ff57c8d7347f946551020f773bdb04c4320fd8a87198a010fb9693bd6f2a737b87acf1141f1ab2b5b9892e8f4919605596a61a6ea6e27d9d835a29c93ffbb18b1b7397fbb438353af5d2705d2038990069abd3cfff203ab1782dd6d9142137ed94aa9361e83071bc5d27ad36df8d89ab81f091c307246e83d6ac8e7b8a53d5de66acd5caa9cb1b19bd1c0c987db38142501d3ffa64f79634184abf9bd5417a4ec3dd9bf56b7ffc1bf7c16798b13f576aa0442d233449fde5936382ef826ec2ac3530c9704e7410bb79aec1a25d9d4085710671acbfee257b193546a7d8ede0278495fd5579d78d32a1f657bee95452da491232e33ef427e33884afcbd5466be0652faa7f3c0a2f520f209a653fae5a88b9b2449a48fdaaa7c45096f4134a03587c7d791266790773e2ba41ecae10025ed71c781b233af41907602e108ac286767f5cfd7ce3bef52409131c30dff5f9dad84f4b08152076bd15f7d7f06241421faf1a8317085348fee4623627aac112e14fb12ccfa8bfde8324eff87ec8b34b8767c0291e657585eff3fedb37004e52e2fd47b58cfe02265eb32796bad1c8ce2d297d0cfed12bf2ab1040d7a4185838b24916ee72c354ccfb5340c3395e6f57a6b101ef90d828e79c72df7bfe006324dcdd1518f910881ea91771541468a48795638fe8f4b271278471918ea2909d254685efec9768daf18746ea04a56dcded93d3c3131230a126198bdfa496c54a50ca6d755adc1e54f65d820f15efbbc5eac56141fd677364ceaadcd08d75886ccd719444901c379c5e41bf907e3c67e85d46e3b8330d2d239636366191fdd657feaadea359566501d7968efcb4de6e2317a79ce68b1f29e3ce5d8ead0bb8a070337f208b609801c5890506faaf7ef1bd19f3ec40092603d199fa77dbf494e11adbc20fb517f3ca25ecdd0ecc4b69adb912b86bd4c1085717389738eb8274a596832f43e458aa9dd6676e5c988e381ce4c26da6c7955a48d185f7eab046e102a333382ffe812be33c41412a6be53372be75cba118be8616ae5398c6324e9a581bc0ee2964bd312ef3de78a596666494a1844d7c30624b34a021dc9102c7ea3f131d0d51a938dbd950234774731562d02dae2eef5bf0d80c56de95903a28dfbed88108a7dba38dca44ea51460d42dc8c9d4ef2888ca4cea4b44431d91a5e22a1da1602d59900faa153fb8eeb6feed8863a96444698b6930d6ad7f2ec2e76a1b0e685f4793d232869379e038581b27c1f43a2cc00c72892756cd09b38ca23d54c9dc3e488854b4415d0198098f0a1bf164ca14b8402b389bd43c4f0f6952794f68075ac93659fd54225da5f260d534a9e0ab12d2b18fc8c2e209ace222f44ccd4b6dccc580dc57a9be8df7fa257ca52a2dbbc1ad98758212e14b0191ca913d13f42ff485cf62cb50c4cf0e11433afbcce0afa45dd846c2fe732d58ec9d861aaa87c3fbcf2a2da41354455f3d83a76b286901b05579990232d5a536556a2f827e1edc890049768c5e0a7b19f29d935fec6ddc2fe44816d4d368f4e11197e7b53a55050658326704b3eae80e00f6711e0995d60c5f38e3f98b3a1cacb8f60efe4b1193057b1ca2e7619946b5007e0f7eb118e1d2de0e91859ec657beeeac7f99c5fe28345c100f49f86d45b527a9f0ead55f121a4bded9c225ba6c9820bfcf5d4e0bf2a30e1b2338f82bf5619f6880521a8872ea6c4a135e8e49a372c729bbdcbf242f14d8d612c49ee461ddd0e96be4256c8cb1e54ed5e27be9c91f761b62225e6668dee9446e4c8df568630de5f7965048e3c4ab1d51490bdcd97d1ac10f0ecabed02f8b99e7a685893c092dbc73dc60314c4dbaf496674f667c4f5839e4852d77c080ebba6824193fbf7be6a212aac4bbe4190947786d1df40e42acb524a3d5ae4ea8db952d379587c725bf5f76f1a3dc46f284239d5cf2b47928b341b8f7f627b6a76183466e0cfc547753be021b66ae210e29c331d506960c080d61f530b42c914717d87c0270f90b69974c890e92a6157bc1a32b86459831cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
