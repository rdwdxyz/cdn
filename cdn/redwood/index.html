<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"62c342157c0f1ea2a64991ede3c66c712568cad81bcdbbd93a84fe151174e0546cf808e59e690971897a028d2c8b7327ad194a1beacac47c61466e0541259f6eb261736b907e7bb9c44c8b706ce26ed326889891c0d592b56aac48e719b9b695d48589878591c93d468f8ff03b09f15d294a63c5e7c9aaf863b23767ba32b21b4927bf981c5739432c7fb31098c3207b6e7b738341393ce077a4bdde004d88ca293721d4c9805522283a33669e28f287cb7d0582ac4af386afdc0125b5ce617093630fbfe61c353a5c60e52d61ab50c9fd1f0d326b77a20e95b5b1085c1b5630d9162da47685bbc8692d1e0dd173d013196cbda0f00c27aabef9e0720331a481c34143f8a4562416af1519eb4e2134d36843b3dfb4d236a3101c9da4a608583c7c7b5652036446adf39993c55c1b1a296380f2c7826e956d78948126787603e2165dd434b825ab06146ce8d2cd0b9936cc683cdaf11715ae2edeb8fd5d9b58f24165a00c3885339daa91b6c38da0133a361214c4b1d49576a1b1b499fd9d973f014815a294d8379ee364369c483577cc486644a44870e9828bf3dd87c429b6f6a3b1a38ad8797eb8edc86836230126c36a6d7a3da5de62235a95e6f2d1059acb8a7e3490a2521cdc759d21eba309f0d4a1d6b9a635b0efbb2807cb4a935c3eae628627e89c1d6c41b845b76edaf80b031a1440c838bbd60af268e81598773aa6353ecfe985b5ac905cc45b4f8763530dc1010c5e16dc4433b19459b750e20fd0a8d1c17dcc947e2c1ae8214fcdca36985fe0a46e8ba681a7221d3a3fec75778a5ea5442cbfb91a746ae74751e22a2a3e3a7806a39c72e7cfaddc454abb4385f1a5a55367bc8b1a3d952250f5e0acbcffbda403eb0acf4276c7f9ba6ff4af6d84978f3554933ec6d1d53f91c07ba6bcfb3952687ea4e638bb7ca8be18b4c7957b64a3ead0cdf0c1c7b8ab4cd20c23ce05d73a274fc612863ca79ab2607c327fecab516f4f888057f30fcef5d5bd908e42b444ed13acaa3a471b0c7469d8e9b402e3c21f3a7a75ede966aa2ddc64d0cf017ff2f0d7dc7c2d845b04725800d715a3b6a5f7a3005d64fddba67dd3d1d272491710d09732f802811f83c6dc89dc1d5e364b7dd684f51e07c62ab6432be2084a292f3b99de64ecd398b5710bb163eaa5f6d3438701a81493ace82cca7b3561e8eae56319a136af63d80ab3c5d39db021f420dfa18f49b4c047036b45e5386e6c8b0913b69f055132f181f4d798ab503135268908f3cfc8596857492ac1e4b20fd8908e46f5e67d405e839cd14c5f09a3e7f93cf41a2943760b3368ca7b3799d6047dae50fc2eb4aa932e18ed52f0197c2885c47989dac35082f2c0b25cdbada3aaed11e737ac611ae968d68de365004b56955ab393ef5f342b93c8eeb0900a6a84b53e9fa539441946aad12797221a3d05fdeb18a8d5cd97f3e6ba058e120ad36f80a59f210fa9d26ccad2f8a0b2b1c3beedff3f97d0cdd0e4a802a59b46161d43e307444d69316911b073556d781ed857ab38186d3e79082119cb5ac5ba6783fe871797140432cd6dda8d86cdf865f19325c95f6e2210dfddd418cfa519e7530b0b1230f7cf3500ef075180e14641269a4dba44e2445c5946da57997ae652d3c4f0b89db62e1c26fae751d6d1e50b47a18a24417775464d89ba7ff76baff966c8b68cabb22970d57574c4324c522cc9ffac8ea8815ca9fe6c628f13c9a94564875d08c37a5f9804bce4a704a7aaad43f71cbd968137b7affd815764faa2035e0fc04e2d446ad5d0120af777a9d83bf95152ae3083ddc7becb07fe46b0c122d725dadc4422e8fe7d5db6258a4a83211d5518ddd6a803f6ba13adb4efa765d6013d3d96d8f503ba608211cf021ec0f4175d70d4c7aeb7af7fd6af9a8b90dd303f886552925d832286dfebe9256d80441e5d8ae550313c4cb1138547f501bab0a41cd0d6ad164434b54d5e9737cfc534e30cb4efe5d01d86d6614a0a118df396387f90f0582f82f0cf57ce733a417072d1d078f15d09b9e4b5de93b9313455b26c31be8123ef41a9d0b587a63b83fc7eabce2cbeaf1ec303c49403d53ca728f870494eaba634f71a79e6e1af6a51bb9a10e7d8169d6e04f3a08d017b0712c08e79a6796fb3f1e6f77b5ddc18717637a01057de9fee0e44aef074191e42f326c7fef8911728e06ce5412163f737dadfb2f5fa7e6e2266517783e6987d30fa43cde0cca5797d6f0fab5b3c5ad88f45d48e673bbacf69641565ade9040904bca49910d0357f6f91d02db9f511b1b18a43ca84e5e7987fb3193de9792e9233edbcec0ca030588f15f05cd6e69ca19a60f87038faceea266bb616d7b89c70f645852203db3068036eb2a4cf0fe5a386a002290a180da887f932cf2387d99fa2bfef80a23ee22c1f5ecb7f4bd9dd0814d4b4a14727cd111dad63ca06fe393f5345dcadf0f5b9949c50b2df918ed87adb8ac72661a49d47df808383ae0fe9b0119bf700823a96ddb4cfbdf7d671b7391a85d0f5ac2730629ec773f7998dea34891488f1437a07baee2ff808b8b9ae24238d5ef68a7157b671108a870d562811c43a281533d8f05dd90b067be839f57a8a6ab53113cb598feeac36cf661aec2f80452e1aa426f2b64d97fc9a5403c23ef08a495605635f0a60334348cb2202d02e9c5c7bc2cbb2f5d15e6254fd93f6a91260f1abc62f49ec925b2a75196fafc3e583c043022a6b18ea19df8dc05b98397cf141f07e5087fa2b51f5908e18831bdd8c9ebfe91f51d7ff3a07358126a4880c6c73f6d57b9ad5d7c1bc38c71ca1152aa741125904ff36cbd81f07d646edbdd868f25cf3f5d472fd3dcc46c0c23a52cf95663f22f396b7d72d5d6a0fc5894aaa8b9368d535da52589ca30b1d94a507e4a2f22bbd252e3516162c00ac146b7e9cce07efce1eeeb4f24426b2c84fbe59e688425c6dfa55d2f3c81573eeed36732d5d1b47c39b1f843a5e213379c4dead56bdca0cc5328f6c7205804a856c6cdbe5186025e00596a1f19f9d8864705a65a1a143c3cc05d85b15aec2edcd01e7dedebf20c0da7512926c971a9efdbd4e30b0cc6db5568b0257748221d1f72050b61362a8b5ec50234e4fb015c02481efe3aa2bc5c2540125490a08f4e282fc089c4e2e3b30fa4b5c4e34ff6966ee0ad2d0f523bc899dfe96851e85a9117c2207a1abbbab0ada76018b461385d048a4f2aaa7e8ecb47b310d081d23e66ceea13037e989db7268d964869b98d3dbad682b659e6c2a37671648b9104744fa9d4e092d2e58def51ddab14fcffbe1f989ca4d34b48b68237a6bcf0a879828606b40e696f40733e943a5eaa7c0507e58794aac3f6f3ff1224530b390e595c49cfb429021ad0c92cfffe25341eb66e4f7563b39f591364dbb728048e74798e0a4af8340949e28098e4b17cc69e3c2422a3e929fe929dee786a273a0d601f7d6dc54657f865bfa419364828efe48b78d5131141d9c2901b4c38a9a4d9919756d04f68520f9d9d97267acce263a5b4a9b58e3f5bf6a8f7cd8c5bd75d44ece1759ed325dc98a80da3900eae9bda35d9cb11cbf3c0bee403c4ed733c9c969569be33ab109e9f643090de41bc7a220803a031d14a49d9fb5e7ff87c640416152f837c7dd31af6aab7ec408b3987ad3afb21fc2906b530e8c4ede18363e0f75ea14e1c9f7bbb48858dc89650f2d43d52a719d3417ccd7ab08a3ee3236baf60886a4f61bc03990d8576d14a58dfafed78657cf3a974c1e51dcf265e9a41c499c93c022778e1a23f03abb4464a872cd23eb59d79f9c35d6ffbc619cae90f25395be5ff0005634f5464dec25d4458f618895d274d1183ea8a3706b3595260dfcdd39407e532f6a9d236ecac9f5d313506e320d6ed2efe4da7b7a7df5a2bab0e837e7d9ed04027611d6f80dfce15b46d407eae647827b6f631d4b046b189d010edf736c14baf237c4854bb1b6677d2bd66a6eef686c1d12e4d3282a23ef439c2e61f44f811e01985f0327ae4884d75fe5ffe33c4942d426d64b771574f0e92d69944cb96c59ed3bf5af6f763dc81ed2faf96e154d05cbb122a1489271cbbc842d43c07fd894d423a4cbb3f84f211aaaee14e16bd2b92aadd82bd44b1adb4520aea5a9a4106763d2cbfd60d96b8726234b3c998e85c05f2a289741660ef92567705dd9ccb9e4123a98e6ca50dd22e6aa111f34d0bb25cc49132ecfa0b23322970204d9fce2e63ba14c67f2e8301db96c425a2758be85ed97143c83cede60eac5004cad3095f1d8277141ecf8e8776449670dd078ab3344de6f0f81aa55ed60970219f1730f7c952b5dc66be4a43223b2abf5b064f2b5ccf087891c239c0b2e3247f744464532d1f2723b1dbfd182cba8ccbf163ee383c6005da1b380edb2c86e775c2a4cd3dc7bd44b413a138623ee8119a61995812d076967a96bf7bb43ca8443847be480be36b90e23bc695afd786a2fd461c4328fd80a1f38d3bd1f0a754261ce41e3e2db307be63a14888d912560f9408e02f2fa7a92bce993dc787a36f659bb0e65c838c3611c5942352337b5337aa4f9c463ec8d42124eaab93872638ded0a2eb00141f55bdce74610472b8b40452323e1982a0ba656366a6f4db0027258d844cb0da9e98d97590e7f63aa23bab37fdf701674fd812c4dc081485355d1bfc6984f174d7cfbfeb3ef7f8925dc24727179d35fa666d3d81958251e9974fdc94f2345c96b3648793b53565b49d4576bc833b7280ef8f6dfc230ba5a1bded2eb1e5ff56e349b5ea2be638e052a571817c5522e52ed9fb04fe3ada4306f43031a1a66a71cdc66686aea76c1c87a13503b9cd231f109a88a581f38007f6f6128cfcd482dccb5335358c5528a5121afb0d93fcfbd9f9ff05f9fd8630ba4dcfff7dfdf3ed4f7cb19919da7bf2ac2a7dd168113fdd4a57cdee63a48f214dd380e6dbdce8f6c39cab31adae857af8bb9706873dacb00f7806854bb55b71550bde466960dca3cb228860927958f14735a36716de58029e5295ab667264855f765a75f13cdff085bc59e5936351312d16e61f5986c7f4da5a155cd778a60117cd0159326b8693497e3d312d78ea4d3d5c33ea1769021d447529ac9e94166fb806d5b118fe0400bcf624aba0495497f4b7ce92016f92e267931a1b67180c7e1351b1ef478628fd0b0e4b7283e936eeb1542fc900be3eefe2073aa99db2964ce64873fc6ed1956b52f5def7c35b30838e35ec8b74e56a2a1279e5b911cd6d4e65670f2c0d0578680c1341d9adf556953fdaf0f321c268c8726963599385054f7223766f92308b6941ce8522fe9ce565bf5532142189fc0a2660540eb4d2cfbd6c1d5cf42508434fade6992ecdf78472cf8ff4930c1f2cba51d245cb556545d07968a77c3e4f6fe2188ad608deac0d76bfed0f744589c41598cded02adb876ae3b89760dfdee922da6e20d667797d696e80a54008c2d9a9194883ae4f29c9b6be4dc5ec70f35a7c720976b2b964bc2aee6dfce0da37d83c500cd640ce630195aad6c31c51a34a10f91fee31bec7cc843986dc5b59b85999e72bdb558da47ae9707297c01af8ce9db5b2a8682343938b61d51e6879ba2a53b50bdf685d4ba47e1f323bf9a71b5e27e85ed77ab9e80a7104a3bffdc44fc2bb231d07d354318bdde68dc5dafbb281d8f9b19020834493cac215edbb5bd61f4cdffe3d8ed1cbcdfd70c587c02823a3306831a3d12b3d769498817028b5abd543bb9823eac8fad06212796f41f7a61cfe035bfa1e88830e126a3d724c224b8e2b8e2b93679a9b1d7e942437f75635177a9c8b8ad06e473789acfb2fba12584dd3b963b3cff3ca3e5c49291954d5113f5c201e58ff4b63c323139f6f42418e7b39979d0ab68b2a5be4411866b2b77c4e021d00618438e6acdcee27a06d784d48ea99c93a2d4a73d8acc0990414d24fc8322d60ab19b0d0b2fae5957a92946d082bcc716a68712ea2f53ee0b4b86dc7e99877d584495d9db719fc3837289e6c5f29901cbabda40cc887eba17e48e7698d9c2ab8fb57c9d769a16e87da234631015f2c2a07daafbddb87ffdd2ca220aa23660873f566a7fdbfcc4acfb7d5e5335e0f359e3ebde017cf8f64d574144c008512c1bbb0da95400b06a5dbeefc2119b9b42dc969eff85c786d145721dbd84686aac189a98175efd83398628ef9b784999cbbb4abbacfe8fb9e769f78d67f2f2be1ec85a49c8062f8cea4fe5b260e45562826ce50b195db4fa1abd75c87b973b5ad5b51b238679c20b1c0d460a5fa8e9530efb8afb017ec7d0b1d5d58601073f4c51765f567ba382bbc102b04b246bebb0806122e134ba9b40308c2d943018efc3d7d518182909dd7bcb5cda523a7ddb0924f49559a058f071985f17d7a6bed13b30768aedd5debbdb0562a0f8654d5364c35c0b4afd78a1b74b59d704132dcc718ecedd15a2855a384b9192474e8585a0f688b86ff77c606c0445fd28001dc98051437fef44a9883d7ee7b179e8c7e8e1f2c16a99c4a00799a84843bf2a40d35d5611151fe4f85f3edd270305730943673227b5b2517e057003b7f0bca3105c78d2357063492e69c8f462a6bfc204d1ade35babc95f3585f2b2ee367f185c530c0953b1c5ee85861e69a97bb76ab7bd47b83626653e8455d2ea1aa55d1c2b1eb342ba7b0754de214536c591ccdd536e33c02bea96b14f9378dc9533fff39f5db0d4ce611be340b9621518d15d0b82990ff0f48378f371f53a4796245a897bd3c3d09428c43da627567ac111288deab52b8915834f908dc09f061c87443d569138b8c222b05eb036f57ea0d46851bea45cb90b94307b665d84fd052ce9f52746f0876e81f0c0a9f15ea4c51d95bc1aa697e89902b60e6fce14842456705af5a6dd01272db1d35a14f007de6bde17851e58e24df036f925fe91c825c9d062dfc84997cd592342ef4a6cf921f3f3025579fb5739cd98828bf7606b1dde9ae3794671b2a8bb5008212e96a1db5987f67a292db904ca6e9d28a858dbb461d259270937e4e8aa70d489c77685026bd96300ecf6314f70c58a6be2612c586bc4e52856695534f0a45d23522163561e74806ef8f91a70f61f7342d1dd85139b48e7fb0f39d26fc387c9492b6457e24aae1a6d233fe6e979365c6f0a48e9ef46aa48d321aed9d00d92d5b41841ad3a5ea0699f214820c42a3548a8c1a49e2c6a1608bcfad751ebd152bf0f00b38856fbf3224961bbdf06ddcb2c5d95a09dc9776a94e4cc49c4833cbdf2488903b1b3d01ee28933956f384e51cb74091f58e44e553e80ca85a2afb4d4fbb55a1d1939fdc7316b51900af422112de2898b704e317f79d1ae1e66da35ee10491fe8a281147229f9049d0f350affe5462835c2bd19d3ffe4e41828fe78d94117a96cc6bcdf1e16e753a8ceaad1fae8f49ca66e4bc692f2a2cabf45d4667cfc9d937ace1222d928f4ffdf9d542c1f43f73228ebb6fe4af332e84ddd697f78213d440007f1ef1da95683a7a5654c032a35b65a3d2a711f5d1c61737803c8a631d5eb164028a43e684c6875d6dcb88f9f051cf36b6d31d3908dfbea92d6a4c7632c5f363ab039362ee000d4d849528625d2fbf8c4a47b0509d85e0cb1356224de9eceae286aa0d160adb17fb8ebca2e1666d6bf9526928814f5351cdab56449c699a7f5b5d82f6936d0d2421df98468062a06c3ba94be08ace327299f9c9c7357d340eee7e778e95e058d5364e54615c73edf638122fd073975659d97327ac3fda88088cebf03f9814bdc7a48feb33d5b87bc26dad3a4ea0803eafcd04c9666c3a17fa06daea076471d4b620cdf57589a1f370fd214c90fb7a761c5b02499c67db672b3aaef76c08a28865265ec1cd1a2a103abc9e195ca6c1898a777f4d46e8a8627c543419ccd250f93ccb0cf1a20ad56f245f32960a73966a1746b57b630203b16b2566c48e7f85f22ea62371983b4c37085324966258b2ac6a1d30bf4455a16dc9460b543534eccccf844040fecd25e4ee30a9a0f47609fd750a8b71dc8407b60ddd1fd56a2f32ed5d90eccd1754b3e4d3ac168958f7ee5340112501a74776ba07a6baa454b361588c63fa2f7b1a420093c0002b2dcc6e4116e7f90249d57d0d51a6683a4b7e15828d45b3413a0faedaeb08b1fe84306a3ffeec2a5aac99da912434ebb0c004bfa600ad4f5805c1c557b081198a201a20e8d24d71cae111226748f13eb4b14f1ca23a968f5e5756227610dc2618c70802f5cf1fd89a8f3376d76ac835733c2ed0111dd8ff4964be6f6592643cc6f3e03f7a6f870b866349718853fc6bb4450f4a28b156c0d156723e49e841e1e6b94b8d63855be4ec3e062c1b98c4dd97067a7f410698302b316dfa52a1a51f3c6518c12be86c5721972b3b41f7f01ef680ad6c5151ec0e63533c84559b2ab2204bbb83ebc8fe4f0006c1e7a305045ef47fa1b33f98886a137d98d90445ce30290b2814b022dfbc0fdb471f1bda2d60ba46915e95e82f93d7bdfc8345fcb4026679b87d83172d1af31f28ebddda16fa3d6621addda8a0ef9b0cfd7371f2529b2c4131265d656a233bc56a443951ccacbf2069a2f1be23f6c45acf0699274846a5012302705a49639516fbf341bb6d420e80f9e90f90d938742bc711a3c19a6c39f81b9c39f52c1ac9bf92053d7b6e799c30427409060dc105f338228e0972ceda2da8a2e6ed0ccd82d97a9a46c9fd8494809752106ad08eae0aa8edf24610f9945318bdb120a26ed3f91fcfe47aa4b3fbb53ab1ca8ed8e30bc55f10d3f9a27505b80face2d244decb8e8092fd144176ccb252902264d52468d41f84331452e5d326fc1e6286821d824f7e68c5998d7fa07791c475fe5ea1420c06c430d91a14cf04c3f727ca71b35553865e3102ed772c534f395f1999ed9e9fd1ca01293bf7363e5ec94a96174874a8c843eddb1eb516d42089be0765b0352d66716e69215c8e5ad2e82fd157b999e8aeabe944009ea142e08fff7efed89c000415eb63006795f06721e3130ba16026c4e511de5b7c419c0cb9a69847ea2ebe50116f9de5603103ebcfb8948ef86469e837f188605964b53711502bbc67745c25e1c527a263ac4943beeb7ebee532c9b8b9940e4902e669aec637692491c9d2e80d5cfaaaabfd42e3034c7bc0e8a386057be0e5a3bc0b903d2aa79d9ea3d766b32e685d484359610c1738c443b814da0cf072e61214d8b25c35b38068ca4ce49983aec3db9b64213bbd17f69703386d256a38dc2ce52b58fbe298da0c5741a4264c0840de69d8e371275f17b9bbf443732d7b189ea6111603374f230050b681e7acf2c90138c40dcc9247aeb9393fc82347778a3f1cefffa40a3226f889f4b47990b99b90b3921b148a10f7fced914a6fedcb35907d9930893d61b15974c0dfd95164a562afaa1fae97c552ddfb42e7473e29920d0c00fb363ec88857bfaaed89c76784e5e6eb59464b9e6f1710a80349e7c828432466f28cfdd7cd2300e73de06c4a1621242fe9a0728d46f9a921c86d221b7dcffbddf00ebc5a2e49a6802312086e28a874e0b95eff8ce5af287c212ee4bc78bb58111593be1c7c5703d015ec5267d2e5f99652f12c182f3af3256dd40080e966c5365a2bb66a11c32b71fb3844a797488a5e8db265803d06c62a7f9819b7824663bc2cbc60ed4752b7f557bfe1afe92583c0a52ba040fd8bae404c96b3349a7e0d7ee0943631f75f0f2529f520183e00d41cdfc4b7f193adaf317e2b5f2f9df3164df5d051ba1d399d74122a6c315a598b7d07ab665bc649b4cdda31dc44456670161e853e9f125becc4f159a97818b8a2bcfb29c25d5e7fe5204577efdd5157539b2a1fea3795b3ec8ec228c119b8bc6d4eaf774e5cc0a7e3075b8ff9e717f49d6888c0f52e127dca22bc58bbd73e645e332531d774c3803776ad6f0cef08fef4ba48a8cf5d2dcee270c27fbb28c4b783d54d7ebab8214d967c6ce80139ecfcb3ecdfc1c24c69c2813ec5c13b1f22609b30bf05d350dc24d7568827f445549d611644e0974cc4b82e5c9d083886c296abb03b1e3f92b6564453cc128554535b466e579a9f694496e5356323576de557f0498366c0d07fb3f46cf6faa1c40eaab74dc6b45991559425639982bf24f5b67690ef236a364dc68aa3dc2bbaeb33b58892ea4b6d5998884ec10e18f21637695074ef9cd722d20f2870c654625d73dd8bf42fc52da1b5aba88c15fd09a8d33e2c19907d53405a0e47aa299f08219114e768ed6152fa7c251db7528d487c39dc1f757b1d4bbad2275da8b512cbfacd7023ad659aa59c0a444a5af96d86c1caa820ab7b4f5a7f45b4e74d5ee11e28e94555a41230625c3502ca65f2e0db4a6b78ef346e85b5dc33d68045b7d73223e928967e364ffd2561c366df6afd4e8f3cbe6e334560d29a017242044f6088a9cdb4dbbe460ba3e596e3a44528ccca0848d63024025ff19000c5a1895fb253da3a7ee1d4794ded87f8ff7ae6cf42af65ca049efdb57d84b2dbf8bc860e82f0d6e362462f50cc1d57227f8a2946f8eafadc56c129300b09d4defe6ee42d28ee580f113a01ef89e78e0438ad17b20290b42780dade6e45a96bb60d8c24303af71882fc64d06cf3fd7a9c420f4d73e5db3b8142bbda9e2a5c568fbd9537443334fca94d5966d4a8065e2316603346a8092bd812ed810b1e08f0edbdb6bca61bb2e6a1af25381848c9ef9a2a79ffdf1ac98b773044038650ee1e6633e9830cf6bb85e8696b376a21b18a61c884095dc9bf8677fc8d7b09505b528c8cfc39fbcee7eaf3672bf41eb1eda0e62250c869d8320e6802bfaa7da4b01bac603c140b579a6aba65d648152eafd355afa336153080a850303ba0e2f363253e96c8ba3f18b8111d8d597f8c81250940545334a619dd3c0fc76ea89cd9f803978167ac7e0fe1a6c532fa4769dac2d2b5c3cf9c0a423acdd530055734fe65ba71879d8694d00913b537c5b3c45c132e70689ee001686fb7b2ddfe822997667597b01897e8f13b6010ecb89bbbbb9ac4b476cb5fd8630f7f876ba09dec76d1f57685e8c9a3234d240da2b6be9f763207794f77552e8c00e01836c54f0acd24d6292a9f3a268877cf61475cd7105f1166f2c2ecc9738011b1490c4c84c0aa16369f66e714023cef03d2ac032483ee039a4923861323fc0ac5f118e4f64baa0f66590ba41d9751611fa5384fb7c3a212893e59ff3e156db3c54fb51a8f79aa59e4380c02bc07f34b0e3d8a43605ab58666672a846e70e35d6a724b19ddae8aedbb82d261806d3fb9ea155d89ead96f85a910181eeb3146039954a8f94ace4baff000db7cd93fb8df76b3ef539eed92dde32c13fdc48d399077392d3d22cd8a543a7b93854e834d1af9e32da825bf9107b11541d71b2dfbeaf4a98ec60839209bb23b270db7c0831fe369cb6c0dfb902c64985b6d70b1d254f7ad9197a87616c6649bd6d1956bad8a692a6a5da32f3537f3e1d313a99ebb620023bd8c248d746c6ab57b93636ae8cc4796eac808da6e00097f5cb9efe18accc56110fee135084b0ab009f4c696ea429a780e1ddf6a1d272dff7b27447cd13c7328e4bc330016d6cf2696b8b226b3fe2072c80eeeb19bb67a3ffbc9a5343d47daa57a0fad258cc86784f06f9f3364b52b6123475698c855cf2af1a182357cc0345b9ed79620a8cc7392ebd24ea3c83bc4118d7884b7e35d21217b605ffac080b7b3a064eb44d681e90c7434537f6486188eaca1378c8fde06412917db5ad7f6408cee7b0649298eca5f0350275801cc6e2decf885672fc69201bfea44c77185a39e3d4fb9b59c30164433e13194d074a1b46574d7c1d860af0a99539c76c0b15d682ef78a30fceab2142c36717569818ebb4142ea9917b325259e58d40a33a2068328e066a05c0e37bbcbdd55760247c693493f02ed56f8436e277680448da71a4748f65f9c6b0393bc2dd76d801109ad07bbc0185b3370ff131393dde52d8db5faf7c23c66cd55ec73d49751e66a1f4b3dd0af3f4a60c2ace32fbbd1bff0917c70127324b906f09c80c4cf1897fb378401eb61f55a2557dd700ef3a80372597b261458811eb73e99aaa3f3ca3d8cc6b65eef511cbc48d2784fef6588c3fc5c53db0e9a97e3c6a35aa91c1cc0c17e553523eb315db43318c4bb79870739389b9d0a370bbd35aee2902c078de0a5abd7c4fb091bffa726a2611d429e6a770cdfa6823443fa6e10f91622ae8a2d542e639e37c8a05699ce61a9eae8673576b6a41b1b30f747bdf5325edce3132e9c69e5ef8efeb311f424c61f79eed6fb4a48209a66fc4b43c26018725766ec8e0853125056cfde76ff6c45770f1acc2852ea0b60e9cc6de14918c6c1e65789f3ef17a48f186da2d2127d0cf58af203a441801e4f68329a93d223d3d47552e1c0f2447c161d800ff4c6c1545b33536b66b84378f58522a154e5a03631b8c4c94eb240c3c084291a1c2eddbe3de06b5ab26d7cb0c3881bc2e947c8186641aee6e9d4dc980dadf71c93748fb28bc70ee7ce1b8cddaa04bba515c5182212959e6d0636d0e4388d0f155f79ab34e97eec56be9d35a999a8f3a8afa23b0a3a48731fe8c66e2b8bf201d3e15317f68a9874bf9130bdac7961f97cf6adfc1bfab9a7eec8bdede59bf5e7e2323f13c46226ae98bbb8e8448663fbca40df13cabdeb75b2df77d44a42f461f17ed0a79bbfd718d3e9ba3420c023167fe9176d12e2eb19daedd703a6b225acc9593f68ac8074b8ad880b7a948f0f46e80f0020d32b2f8a300461c810a5aea90a49c7b37e0f12c79fd71cb4426a88f14cb772d92e161027ca1fb0fe31352125b67aa82ba903281694d7d08108e686549e94c7d79e2397b8c0cfb4bbd9426b89bc4b40ab93691f845ffc2e00d2c34d77a2b524cf9a11be3536dc7fe452e38e84c311998c1e5f0e3a8316a207872a5244c39b32f211528cf1bcd607f196f6612778b1279c6cfb96ddb90f1071469f7f89b98cf5d43812f41ac3207ec76c51b0d62cad05149693d7132466541d6423d87f2d8089a17f5b54106ff8d54b32ae08d328c0bb934fc734f0f893305942edeecddf87ff1403dce42aaf62e99583c374219fe56d68cf43a381a016912feeb8d49e10424bfde8c95cbd61aae4004259ffabf12720abd483db1140e2c0bacef8369217634157c4e2cf534ccd8a7ef284679d545666b4a636331d62149e507c2dca4665eb3181ee07efb251844e5026268241d22d442af2819bfd4a08d408ca122d93144665f12848f24dc0e1557528ade0ce0955726284c99eb3871b3db232a3ad163de02ad9bfc4e166d7b073a4382ed4864f80ae070995e313f9ddc70b05f17c098a5e18c7aabebb5eb2231d2494bd710d2739de126da83c8e04fe265e077c59f6a8e92718191b89549496bf7aca3df63022ded48c14cbf156ca64ac6f1ff5f20e1351266d4158486a0470818914214b8ad1e6dca49b92c0d9823f686b41021a36447fce37bc68728618b43af12a6639fca2a7c315b33cfe60c7b45f6ec70a8a00bc7db80ce222e95d2fb6bce4b8b0e99a1746d23ecdcb680873f586c7bccce9ba75a7eaefdbd3fdbc104e4afbce222f956275b9a6b535041f2261aff0c419cb934f8014bbdf76d5541dcc0cddae409da0cc415f99505ca5cf56e3c09a8212361a3522b9dd3f62028bd73935926b3fc32dc16d3f6ad014f60044d887c024bd3aea783a481f3e16a28d7320499e19d32a8ae05809c7b4b7fb19c9a1bf2763d357ddb438788f55a20a7dfef9a215e00f237ec37a9274641aaaa9c1b366db26ef773d89d29545d266d86ea34df8a7b2a6b55a3bf2fa9be7727b9299f10963db2dc955ad3f2e28fc8851fbf8893ff4621bfebf0548eb019ef104c0f1bb76158c12327b4390080f72960d5bc969698e59c9331bd2f979fef40bb80c9690d4c8ef8f1b81291348b1f205254f2d71e338b54c4fa37a83fa90e00037f97f89c64ba0ec942c006429d43e5f91d48965bf83882e80ab529ef8ac3610d3b94d4c5fd792e6b271d5e887f0cd5c05441c6af47373e03380da8de991c797b42dcb785f41dad495f83875b11d3d9cc15f3671ae69cfe71bf5e7e0e02f58fa57e85810a15aea64af58ac5367c5aea37fa40a9278d76b47fcd1e10cbdc3ee0ca7b4d4342d8def6e3672a9275d902b618e2b260eb9b4fa2a570c69ddcd6d9787b33e535fef28faa2d70fc942dc3030912d80827f7143e3e71c8a16959e2c5bf2c1651e8ec854b122a569d33aa5ec0a81a8b9fe32e1b2cb1b198d97d5aec39927bc742421c98e41f0d24279b005696bad497a8a2959eb8d6063a14ebd0ebe9dc5c0b4147278f052e24da61033f5544334adf317f4eac9e9115fda8e0b1eb3d0ef5cc6f88159b14e483ae5a171af1014dd772e415fb7f6518f1a318611b3345d3aedd038487c5414ff61950612de202aa5861cd83a20ca32dfd2ffabaa82536f23d3dc750f3ce992a88e58dd234d1d8b0459104a1a98dc4875c58d2658683b8ba37711be13731d1fdd6a5a2481641e0c2614a30837fa96ee26443e907687da34a2d6c1ae10de80164c91188f4fd8ed945316a2113c842634204b9d8298cd2aa01a600a10d9c0fd8795d0cd25d486348f9d4ffc9bcc01451ed551da4052654796638d48476eb187cad66e5e1e10ad0aacad55ef85d8a0dd37d909319314bf23c2f46a7223e136f68293d4776f9df107507b575ecef317621c92c97fdde05ff2556740e0e594d05c8365a3de1d545c21d4b443596cc2939cf24902401b764ed9c90fe3e2cea1abb2e0749546394e8bdfedb83efe73aba37fa1b741bffb9492d1807da4e5973ee141366c6017496ccab8f425b0c586a22d723512c354ea43c31b6e88e9123a872d5082291efb88189bab3edbcc9ce7e310602f58a20906afd7584c1a03805da89866949b2c40b87a157788731c38e947ef063e8ab22e8187eeebc38171548952f31d12dd31c8c55378035466767f489ad26c37a20a8ba7186d58262f373e9476c6640166d35393d995e5d9c4ea178dcc6eabc29e8a277f243efc6fd2d0ae6e5cddce8c0d2afbcc72582fbcb3de0487c2215dc05e16e4dd78dd2f157ecedc136865722830e9d0e092edd4622276705e12b2821ac1ec0e2fb4da852843cd7cc04cb29ec8ff7f11ca0e9691b51614f62c18bf1ed3140802950a8a80d81db29dc7d2d6a53c21215c6791a3198616725e89e0789df0aef602965cc65b3b16c053bb6dd6e835b6446fd22f82d4215eac6c3f2f6bf6a46f3844bf5993f92fd9f81fc86dbdc6a0094c57d8022e88a660b6f3aea5bb73d1bf60b18b026218a316ee02eb3fcedd5abd0fc34b24e8266060b7047cb11feae4b3acd839ebb2be5d7d780a4ab6bd33a8013ae1ed44ebf84f469261c1733718a51da6c2f2f710eb55a484caa4cff96b8a4da538ea6e85d536956569c920b68aa804863a8b04ed08b59e3f6b7611a7495d6973678b2e3bb383e301a71e77380ba92541d11a98719ef8749e537c1a60d3dde9a8f5e152611ad364fd7db5a972e7f44678dd658bbbeca0e1facb9335a69cf03855501a6fb463381e0b19918e3349491303bbd0cef4186331fa1074d3339f5ff7025f090ab71b319d58a557376b301a7433a1c4c56e07c763a7bd8db223840f8f13c7b576af4438bf869f2a1516c8f5fc2e8acbab1dea63326c8197905fe6e0730c5cec3ad70a9c9eee2283eb11f6236ffb76fef236e8edf6cd10fba18e993fb8a96136bacc9cf26b7ce408fc145db20ba14a5cb6ee204b4431d046f2dd4d44c4d8cc3e2b9d6f137ec604133e3f038e950b8fb809ce2bdd670fd3b050c8fa6c939c1422840e36e5b3a8d972f9dd4108bca0f2f5a8d03e264f0f9c98e31ff1e15d9939f062e2a91c43af5a327e20bb63adffb3d5293794e7ce39d018695d478c38345870cae6c4bbbbcaf2a121bc9b155c0e449b31c80c89b9a4e51d11529b564b5ab16fa2c1d583d42d1812c749803a8b49f7e499c02edcc0de59545a7d0d7b9bf89252722f484495c2df3a1f55102e0417e79755e96bec06cb5ba6166d52c9766971009ce15974e903356d7c9c9e2f58b09400fd1d9de4589a5440223aa0d9da556fe77651fd590052a4ae180b5ac5603539ed0649540c054bdb0108b85383e74b5acda91dd3593a801d9c63e8136f10068fe09ea20f66c776ba10b9deeb086b24d2a596c45a456bda740237cf0b80c9593a0b816de0ffff375a9f9000add7de29c49602734ef2161abf40cc2e8075acac9dbeec99ffa07f6e8f4a2fb94653a987dfef96615f996976ad9936de57fb94671587192f77d673766b9fa4396a22ca4ed332dec31b10d5164dd66114c79a7484f0e1ecb089275542a2122dda4e9e155fc66b8121d000ed1b80d04f97d891a7ceead8c5e14bf68507caed50461214a15f7b06b1aaa8c0068d40f31862f75e1bbfb86254f2660389a54eced7654860a775d6756f782abab3da32d9c79d1d37a386f4da1b26e6794884a64293e799ab9dcb6d6302010837b23a4bc1e06ea6409d7bdf70c452aae1753d81b91bb4335284879cce2c5b8d8c3727d314a9b80466e182c14ccc19166988f3622c8686a220f412e638ecea83c086b4d655e1d1b700cefdf7c14d8d51a688576fbf9a94bd71e3aa41f7a562d55db49279809499334f4909cb54f5059467d743e075dc74a67b3802beca71e720920eb46fe0940c012657afbcacb56b3586ca747bced69ef22fbfc93a00ea2faec2c135dbf98afcf84a833017da932f14314135e31f6e175aba1a1ed100faaddc932e17b93fe01c98ebfbe5e8c392e7a32df8a38839d045903d220591d37aebca0ee5b09eb9f32ea50756b06eb1449bb8a8bef27c412c8f4add351b447df27e711862a73063aa83593110bc0df58cd51181da315baad3405e4d73498bfc2696be529181e3024ba261e629ebaff9474da3c409ba5d219bc68500a9dd533167b6dce96923ee4daae07194a5b476cc4f24c676bc6b3ad7134a8a2b805f8f0793892a51599a0d5a206228037280b83b02389b0d40da87e16b41dcbe7dbb6285e01404ac8b842bdab4e5ffe07fc615718936943072aa3eca1f5a8ad00963e68a2edc0d01e80fe2e25eef2529694c362a71350f4585b18150276048c16dc27ee091118217bf9d8327e979da0fdd7e8372e54453904dcb148ea8438d1a481dc0e2a5939a40109dc9f68b97ba153405428d40818aef4fdb13710269b130a6ecf31ec884b172b23c06a1a07a0ce36df45186110f30afa21dddf40fe2c4d6e0c1711da8a595fdea0ce8cc278e418f66d0d3d163a68fb38683254cd3b60a84200778e5cd0ed84d7a7121bb247a6fdfa9aa07fc0b3a9fa25b53fcf7f093729962a2a5288d85d6e15e17cd12d586b0c18ada49844763b14a672afc3900c88572847d55d3f5c8370f7e4da12dd835dc4397ee89aa3460509fb222838b6cfbab7c1a7e8c6d71fda028524778ce4eb936502251ca7ab07a0b6fc837aac0116394d812e25005708248066f05393fae8d19b74209f6c4a072d1d796da20c0ab38e34efa30971c72e69dfdac6e59ee8da7cb7ff647b7dbb72546665e6939e259e9e2cf5f5c197483a9e021f7c1072842adb333913b7f5ce5b6d2be0117516b7c9d7e35c2911b7a9f829cb8ae7ba9d8595872240dfeeb09e8314ae8c103daf76d85bb2f15349df540a3b8f80af57e5bf067501f500769c76f729bb5a6b512fc2c964d1b0032b22b001892a057ba278d91a4715388a3c29cea10c7f7b69ba3a17ab4455405e972fe6f84cf41d46dae53c1a6cb0037e0f32f896e988a8bece087a928e8345f29485b6e3e26b1020a321d56082860e64e4f01d5de18a2facb0f45da7fbdf3374f659cc1a5f7f9437c966f86edd3fdddc4f66967714521b089702018c40a39b6d8218d6498a01f6333241c0daa03e49ee6d4408e90bcfa2e15af80bef8b6d6720ff34e19e25b845b3bfb35b579c63b39c9928b9a5ccf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
