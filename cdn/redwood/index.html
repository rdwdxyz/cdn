<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e0c12349854cfa48d7a6bad2076a2d2a66b59bc27a52da1e3b5d427ac4b465ba9bab1cd3816ab5faee84f1fc2a27bf8e01596dd507cbd38c0c0db7dbd3c6627b14766a9a6d9bdde419077fafb7e7d44d3a297e53fe1abc98f033a1fd210893322ad92078435b1429e0bc9908ba06d0187367d5bd743e1c84ab50b2954a2f8bf250a6b5959b62a6b2166836cbb2212e5aef3bd14f6d731b467d13f31b49c1cbb904b7c5ee353d466096aba894537c77d166cac8769043f690154961e5ef77ea803735f191271572aa264f2e8ce8acb7ec8be1eb680170576549e2a43ea24fbf90600299381e93b894cf34f732ce69ccac44d2c4002d520f65544bc5caa89e20622c3511177ddd42c39278b2b06e7e24594d8b82fb3de18489b317654cd60d24c71e1f1c42394149a897c206986ee2f732d78ef741b3656ecf8993dbae3b37ebe06cf59d289980d6b8337cdfd0b8696b6e7a260a659d8a0cdcf956fee9259a3f57d31ba26cb029d1eb9ffb969bee7c05a69aa75449e860a400a6e9fc086dc01af0e377c2f2ab65ef16f804ad3c3336e25fd1e7e13b7a75002907c0820c1080531fa96f12851a76297c297d388c9a625072609d1ea27bbfa2c643e97f63270fb4e353b60f5ed9782432f95e804247ea65989b2e144d1d5e51590cee10c368dbda2d5e97a54e8dc5bc4b7c517c6ac51da28233e6405dafa3a0c4ecc79c85725e09e1532bdfb0a8488419d1d2aae9e65356f050550b95bfdb0afe0c8e1b28f0298e4b517617e293e52e04f667c772c6a79b8c536a76ee0d0f3c36824918f952b3f88e52277a559f06a3aa0fb733886cb079609a71064d9937f5ab9b778b8d1c5f651574b1e1ca2ba49d4cbc51b0dab3842f95aaac87d547a6e9ef7079f3fae15555d46745885b1440f7497d4db739d559bc586e56ad9367ecee4769e583cfcac6ce9dd61eaf4b4267e9fae0674006f2d5650f11aa152cbc6192105a429f09275e160cbcfadd1de73cb224eca426a3ac7e7e612cc062b7d007b829d7ddbddfa189eb0cb65976f0e0e4c6e5bc823a30c854a356135fc25135555fbf43dedfc238bcb5b5249a434ac122c2b02d23b0c861e48faf093bbd607ce21c5f779a22a8165fcafdb9cb4976940a2698d0b57ad68d37b2d9b8b89552d2371edf868a843b999a8a48119067a5380d63ea272fe0cbcc745e11e830c6d723cdb06a05a25e7c4c83035f5007327483cb13f14a4c9e2a7824974bbeccfb7600782916f8d68eca4c1911196e627af160ec23167d34b26880675f284693fe132a70cbfb1432c8520edb7d49a8b8ee0c830a4b9faed3b48ae3b359fbeede3951ec665871821303b691cc8d2c468f2e8db4af5fb735a98de20ba0ad2191b94a27427bab405b056ea127a8335c1cb188280a4f4d4d1dbb37e66ae7383794d5444f0e4d8e3f35c32703973fc9aa3bdc00512ab2fb87050900f78afe775f1a863439f072e1d82d57db99f6b6ab4a8be846aee4035c5fded2d0ce8991bcb41c85e5a2c4c0d61135de6fd787083d44e0e874cc311463b39298df5f424640a7a36a0a27bb07b8cce7edcec8c382f2cf2cc26045d6920ade571ea8f53fc418d8bb50bc3ac7a48600229910d88510ad5d06d3fd3f4cc864d4516e5ad983e8140132cdd9c4b54105aebd407492bdbf8b1b60f33222cf1d15af75dc0518b00810748df6fb007569db866751acffb4436bf8ee1ae61fa428278a6c7de74cc85f2df0b1dc3dbb17a08c787d22c65cce4c73417b4ffb151f2e11b3e7a9e2c9399e0276ba54146984f14dda730bc70db15a6e63e72c4cf0ed7e0e0d23ea5afb49844d8baf0e8313945066b14946e7763cabb6b4d0c924fe4814abaaa78e5aa57bb75650cb160efa8367151583e516884a7f17e1d3335709f1f587dd6ba0990d36087f41866a2d7e3d99e7899a83fc2b9fe2e575d6bb8e5cc16b2fc32c04bc9037eed43aeb01a2aa4f1bd1205ec00d2364746042b8e3c21f4bf76c3b39dcc962cf493b7a91eabf67b02a4c8f06f4a070a5052f0c0bd4a38c1bdcafbe34c037f743d93f08708f2dbfff950172bf0d157897a203f813c1259d8a2c9e3ebf598ed8519b6685fb18384e76f7e9d5346424e78f94666d5fc4a7bec478b06d21c0ff72c0eeabfe59faf238a8c7ddefa43cf355990ab1843351a32e22e52bab0ed7f2c2d9c21b32c503d16978c2ac4975c305974228bab00bf22ed4b2f0a3f94f02bfcc8aae80eb19533d7b4137c08b3a0e2a6ca8e493457a80f92c4c65a84c82bf69a33ed1952b845ad2f03346666abef2b9dcdc030aa699bcdc735e1bcb366f5806d093eb3e8f6be0b02653027cb638fba38cb2578d4ff58289ef7adef0a83a2987acba161fbf12276d1de92841da2773e0d9f8a023b71e5f9c8cd6362242334cc710ce298ffe552730f091e2a8019273d6e25cc0f2e7a3eb7f82c1a98846b0268e9110ce9f8bf59fc19ad53f078f9f23cd0106a123fbf8b092c9d034bf9f46747035381557b70cabfc2d7a678426071df8834b5696ec705d23353b5214b01aaeaed8b8099e06ca8414ab5013da9cbed4201352ec6edfcbba212e04a98a8a75c24de535d7e74b29dd8f15ac5b0b5723a7ff12010c456a07438478b2e8ef3663cf1ade5c8a4394b23a0ace66ae1d3ab7da16354b19f66cd800f0de092e4c9fd9003792ddffa2bb71902f04847e78807ffb7006d387aa49ecdf1cfd2fe95113f100470d6d11c351f16a22a2a06963c91572c4d93607bfac812e94cd62de852157850c83d57b44f21398c58937064636c3b01e6922873a71458e56ad3aa30831d82d4fe8d7929a3e9feb5b65ba07bfdd5cb2fd9f0ca76cb2a2163e0e33bd47763cf618ad5e8b2ba62f0c8fe274c078640510dff51eded32046fc701803e00f8a650700930333b9ef1ad1eb971ba4179cafafa1639264e32f94f1dad2e26d674f6f9fd89cfa8a784a7d8ac6f178c2d8dc4e988f3a459c8530e8b4706e8f9c62a13955fe8d2e74392f1c92b8451c149f62a08bc94590b5d131051f3fa819b05865785427665314495f75faf87c33e7560c4799b36af06973bdf596122e17d57c055409d9d6f198576e773c068ca1462fc93e5f3b9acf390a5b23ae393f181efc43d8c2cf176cd13df99f5122daf026cf12d8e88f64c80dd8c48ff6bf7640fe9a09512584933884ff7437bf438db3051c7e7fc45323ff83a4e6e02a9e9b34df6b2f2f002c5bc318c484c022c4ea43215af84f15ca3eaad7c00a9c73125f503b587bbbfbc87622453240b2beae09a17fd931b74c9de3d0b7793749290c974c091f7499e6f3c1979424457754f6bf676a837e991827397002520149fd791b48a2e6fc761df72f37d9b04c6d061b6ad4406bf785d52f3e021931b04b2a1752aa8dc3716579071fd7b30cb9b88a16abfc3dead1e9fb89978619cf5b8da4eebedd939713c9ab38648da81e4f5aca93ae08b33c9be36dd24cdd36c29c62baea543ca5e6c1cbfd2a44a726615e27b6147f01449aa8ef3633a3e2928bfff12189228479de2dcb5765b3cf2704ea1792c99683899d840ae273a89ee3034e9ddde6d37da6875adedb9504c20b371c4d4cbbfefe881e0e41c74e950d3ca0294abeef9c8d31025c5982a624bb4c0ab9e4b3a86b119ce713998c77796826e1279c5dc40258635de4c34c21816540d0264e8b7c9712fdbe62b49b381ccba86d308eaa53af6cdca5d7993e1955306c89cd8a3eca970cf0975c3ffb24e50aa68eec1cbbf92ff37e5a3e1e9f80b3e69a442ba3c9f29f579851ae9d9aa62a5c870dc266940e6afbe056c08613a988f2efeeebd09f1bbdd61401679d5c6164f19145f90599b0029037b9ac9812592d50e1ba3476dcbfa3b059a1dc03ebefa5d77807a8958eaa7a4c2f266028028ceff6d325c5cbcee164672ec479e2d4569e50fddb25fed33f55d03e6414d6c5e2fec86ad8d2d94ad15ccea2b764de4b2f9d5e86c3527a3ecb065647e3f95a087ace138da76f344422fae3520a7a4354d6ec6d4545e63905d2157838088ff57eb11968b06bcc60d4d743f3beb730092055e647cbc0524e93445cec20828cecc70a2576fdeca8724b70a08666ead85fee77d630cc30263ccf31e2e6d69409f9b4a7737d54cd12a3162bc849c922f9fdb8f2f66551846de4edb0220ec346f12ed546f16fb7f7c81e45e67a676c8739a4210126de0cfe46d977a35ecdd84955ac7d1a9911bbea8109729e5194ba2129d0917b86a50483755de00d753f833392306c733b731251af1782cb7ef52a30e9522e0186039dee950ede284b60c687f224ff7827331ddde4d4b3c217ad128e90b23685a77bf6e1adcf07147634889d1c2c83799c0e63a75d92fe563f9b3db86f99a51bec5bd6cca2398fb6202e41fc040ec712bf77bdb11bf55602a7499fa05e44c36925a6d7dd898224597eac5cbaeb071567b03bb5893c9fb3606f0a572ee07bc55c5e95c4fff63eebb2358b7676121a36e6272d14274f8d40a11f2bd653293db14c0a160f9322c00a50376548a374068250571dfefed87ed21e7c6741be4ea596dacb90efa8ed208f98e64575a5a8c76360488be6a12a7005d42a59bcc993c3d5c8d362493c15c676e121a4d939d967a05a7159417e3f6c3e2ebf77158eb5b798ec3e13c8e31ac8655ed35aea79f2f3f20c3aec7a24746fc6bc9b62a698d57ff2d7d2e1d015595b1d5ad0ab086d5234304e30c219c3b77ed3cf77998faf362994b82ba68302c270469ac9e27504955dfa5b8978c697c1d4a41406662affc42f96dbc1b8fdc99d42a19e5187492123bbf39835fe74238281fa44e3a9bcc5d0a8e0fb27811d19dd44eae05e8c181b7aaf159843d15a58a2758265672d99e0cc70eb22140beb132fc31c180cb7e50ca9012d989f0baaba01fb6600bd8372386fce93143ff477b29d0a499df0b5251ca74405eef3cc51d2c6c2c3eb9d92c9081dbf59adc37bae6c424a3a90ab36a3e488718be4e6e30ef2d4ae00e52e673661a2dcc80daef83c59884a88e49eba69cfc339d4a3aac37c2f5428822364ace7e3e2257a360c66e0d681baee9699024cbd7c9985e99ea22f4e93b3603224b59d2774f89d3d678894290241cb9b8e7c9754c0fec380c0451e406a2423c67a96662e0bed78df93d0443ca7b7eb123025c4f0d5aa67584b6f252c948a3b3019b7cc8abc2d2302645b4cdd989860714927a26a9796de1b15ed884e6996d4f60336cb7a1f2cbfa53a59708846b4bc63c0e317716ef6362b3ef0f879404712f46174ca0cf02698a4457e574b8e2bd64198923fe30ad846a3bbc7513106f19fb23ddefa36ec64dc3af4bb90c25bd9e13e43c831a0322bf1bcc01437f82ebce5dcd9399edce2826ce6f520de7d2311583d052686b3dfd8d660b271eaacc7aa2681b58b0328842706b5f4a8fb679fe8c3a35f20f0de9c4d8d2bdaf7ba60105261f56addf982ab4ac569bbe4e99bac567d1ca1a329b8bbac6f4e910a8ce1336b7352a6d383d1b3c2399e4d67ef6643dc3e1bc8590ffc37b2d1da5f0f4ffda68338fb7fbdb5f169a16c222949dcac592a609f3b4af0744fea0404ab62928836bdb32e5be20f415578475862ad12020fa8432507e59198a9753270e9272344434d36cf58de58251a543e98ab4c74a82aa85122528d844bdac745bf344c154c89dd35fb8e80490ca6179646af6866b1f15ff754d38dbf4125ac3c7bae69b4a7662e4600ba813555f709d72c456888f8587ec7c94b570090e0b0b20bb7a0c92956c9e5007e2d682df744106f5ecb885ddd0dfb2593a3f7bc5f8535370ed695e27e6bf9bd3866df797e20324dd31bbd1e53313786b5f4a9a151a92ec9e2df047e355d3908ceb6a028c63d7d617cced42d1e0629c0b7b60e140cc71f7c7e9f5b18776d5425387506e51867ad785cdcd351860865c69dda90c5f690aef8cf052c18be6b8e9af04bfbba6611dc140bcfaee7440c65ea9873f7e57b11c558aab36faedfedfaa090243e98c9d38c8f8b5b7199622acfb22e3ff327e0f4b11a39e260f302d5f0fe9162100c493b15d4d2ef0a645999baf89a4e7c359fd289da7e57765fbffba40237d802084253cc35a0ea4e1f04bb18f7b3cb9b9c736270791a2aa8dee5ec20ba5032c81716e330efa449d20007ef129ec7ff255a4a338c5d89677ff8fbd0261f07db57ba44900a2e8395175e8652cf861da46eecdca92d8b939307e5fa37bd275c002d1fec438cf32da899ad779297e147cf0ce9effe1727a67405a3ed1c9c3a5c4843614574833969cb7afc061b83be9e79b7d4c20684ebd692f9f1afa6932e45979d427ed4e7b8f2e8ff82977b358ceaae8977ad6a806dfa0d297705bedc1ae148a99d423ca03acd5b211020edadd5058076361587b33025b90c8b841ad4a63f7099d44b1e64675c27facb0ed6846ffc88efb1cdfa88ad7139215c8f9c76646fd0a99b1550077c4c3806aee2ee3fedb845b009baa1cfda1301ec7415d77d02aa7a97909eafbe3644a8405e5c515ffe19afad855785493721fb70d953fc2eb9b41e84ceba94a6e9eebcef5f7fa48be210d611ecd809d2200d9200f18a224563424e024e5092db9a3d255d4a37d93ab43ee5c0587d00b34f6d1752b0ea8aefc4bb065e8c29974048d336d3e575bdc2b2257308ac16782fafaa863abae436b5f7a39f171c5ab4957fee7bc61dfa407ea7887d3c52a3132bd8ecb98414d59027285f18a00e4503efe57de26e55975a4a4fc5d3dededd6ce3833a5852ddc0099aa642751f12d7e5465a68b1048b1309531594482995407045da3c266f91f80a7ea949e3808dda80a187d946dbd17b5d22c5d1c1ba6f48d95aaf8fc003556b05eac05a57b26c95876cfcfc69219587b8ef79bf1e38e82296c0625525a40df9dbcbaf7ffe733e215b919dbf95559c0b4693714da2d57b9edce6cfbb0020bb96486185bf6972bbdbf12ba276d3cea3083bfac025c20fe2700ac1f641314786da1b76aa810a390107711b895b7d588ca3c12483b0206dc455b5ec27cad24ed7e5684a9763458766ebe012b7d73b5810c6e14a57b35cbb001b14753ae74e27ee6ee1aeda54ea0cddb3bec868afc662f828ad42d53498df0b63262869941cebae45e22972fb5faf044eab88c4dbda14720aa67563c7bfd686921567aaee8a58965105cb307b170d7fd6ff124d92b8d0ec087b1a3235bf00d3aa21b428bd1ee5c75da2c3f88052c190e0c8d37c8c01d4e2da9948161b07baa39e9cd335e1c02d20c77e64791251b08c17497f9dcd6e1eda25df3b3d46069eca8cbb9b6f6821882e71c5d21c15d14b5de9c3b6fae20775a38c57b111b462cef7309df59e333227f0de7d2d1aea1164bb1cec1b05049b47b2a00a45e730c8f06d3a03a0a76b9c4c9860397a87a14e377749779e69ef6170a01f19579ce17e4be2b49801bdb0aad84abde8c9c7c7f8ef8a9129e3f07819eb57d8de6dbd856e8ad6a9c0e82fcbc7f660e7c9b9e61f498b927b6e8d49655b45858dfbf12f0a3baafacde8401a016a2bbbd49e93c4b784c905d1c180b76a17f3fa354e4bc0726d7feec956ce7b263de49b2899f98fa3182ec68cf74d48ea7c16c20fec79586505944838b06d5c96c3b3375593913aa60660c9a6fc533bcab372c31113c2711e7dcf8219e5039664b7b90cb159958e0829922eeb2619fe1bb84eead88b29d137e933d80ed309b35d94b4e9cca55646f8c2e8471a338999522f264a456f67f29edb501967ed5f1b067844caae4d6cd8e28fb50c31b451fcbedc54f9ae55dda44c7bc4f6ba2dd6589e5fced8e9c09a7f702791204d75f84ec3369f3262547a02f3eeb27ac14b3a3657a6bd96508511a1d32fa0f7741c2ebb1295920ee0144b531cb78db7df8df47f2c7f7af3b344d05b9ccb4ee761b132d77ce2c122414995e8b74731503097325455ea26e55938cd98a6dfb38e6378dd4469710ce054048db681784c699e660d6006f1e758d81248e3f8651b17f9bb6c8477609cb37e158d740cdde18767ea39a34e8079e1291991338266ec3c69e3e655b250208f4c46d99dad020a3992be47e1cfbe5c2530d40fe59ba9aebbce10cf2d23b0a8bc75d0bb9f43ee51b930509930dc0c0dab9c8a36786d0861a980fc8f2945462abbc8811e6b7544579be6919b7d1d55f24d046debc0e483324cdbece67f0f9bddbd97f74730df8ca3fa6743de227f51dfffbae9d39676f73be4a8bb0c06eb7034ed633bca4ae57d59afe216af306023b0476b7fda1719940540c29caf3a517256add81a6fe32ea104dcf81da3412c916fdf791206b88b7b8f543fbde5aabfb4e96d64389e47a0d9a6b4cd6a2b06982f530385e309bcf6cdd2c4ac6129a0b5f3bdf4d6ff90538337df8e12615bca98bea7b6ba25eacae9e83f39d2521d9491455914628584a03c0c6d45220e3606e0ad0676a1d914ceedb041499c93b41fff5844b5e9864eea66d1b5cb515ecc92840b58d7d5f324087c4b11714e476b2f630125d13771302915b6d5792b83459489873464fb5625550e3e368f947123737b1e1933b6fc016a1df1cf553c135e8119d4fded6191b9c933997c4068f1385308ddaa77c19f8cef6b2463488114051509fc7f019e756af931efee17465536b9c3e98b47735a369f5429057e4405eb894893124304dc08e158c5198d31eb274d49c85b6761fc76d2084be3885b7138ee91deb596c6e133630c1141c9de5d1331b1c962e5827af67cabb911fd0d7fd9b6bc925a638f37969c590a0902b97537d1ca6acdd28a6637109be8090ccc4a15efb2f8236e242c9f73d18b9c5cccde5180d33ee91b43beb87d5fc221a44b018ba5d436e4b755b811b42bf93e6af73860809510bc6db63fa393a8cc772e5f03be93f7513be682431823412a3112d9da492e9f3de823f5f702e3518ab6a6778fddd0dfd7dc0afb06d9191b79e3dcfd77e67695b1577cdfec6e3b0166414bf2787dcdb90ca9394000b5c975139cc8a9aa04da293e1dd81dfe6facd4dac862cbf697a24c883651c35e7ae56701467d7bf6cfd96fbe4fdf919b69dda3d21345606dc5ab72e6c265c799ca2232089bb0882e5d8b389a21dca34c6601a89a11bf98d0f000cd800b12b5554316a35089f9659c7582aa35153b237b162ed46f55c41be162d0d82cffa8d9c15453168452130be1d861de3e343abde3120f3e3c9a54a7bf110821c2992bef29268f51003039310ad335c2c66282083db1169b11f8689b46e37b1909947f83ef8ef3f368971a70cdfcff9129f19f32a96e2c1139bcfe801ed12f1813d72ad92f9dbe7cc335860369be8eb5dbce9673f47aa41dc31b798ce8469111f0b12f987a0abb0c4b40dd44a1daae83dd6b8f200f18ff7da401ca441d8aba172a0dac9115996905b02e37bedb44f20d76ef2c8cc1211105ba1e134bb9ab828fcc3c4c341f2e111d79021014e7a81e83de3223227efbb9614d0d42ee7f53bd465fa6b109763a7ccf70c8314fa9acb04a82f08fc2755989bd57074171b38bff3b3d3e367359fce73038265a94a80d9509dc5a8de0022f868e0340cd5c44708ce25eb79297a106b744128d7a394383c29754aff9210670bab4a2aee6ad6eecbdaa77d42fac64ab851191b8b4e5dc1294dc253924864b93a8e8064fea9cdcf3a0cebb5a78bc48d05a9c9b0ed20c1599c1ab77b3cb069d9f2d004fb17adb5604a7a520789eb00951206ef05a4436fddceb09feda9abfc5aed7eff3c3dcdf7d5e726a83e98698a0caa80471bfd325b34a7f336c5531048f237a94b346f7d879a5fb5ba97046f4798d9c48d7a84c6fd6adad5b72b74d602a83788dbd087bec0ac35350b62e5dc2fb75ca401082bf68ac1b2f3b125ba12501fc0a7c6eb91dd776ede8e40a7df9fcbf5cbae232b8699e5da14a70933a1c19669146ad1680ad84acc3883d098cbd97cfd09f18e76bf944e447c384189252f44d19bb8c8055c57e51f5ffd650f83d86c25897866342572a5ca6bbfaf5a03651deac445a1afd0b6e8b8757d2ba8f7cd0b4346d0f1a515d423fe67059086de9656189e462f20c3b4202486a774d1428d704bc29500e0ff6a032482ab724434639f305ada116a1f914ca5148507b599221f47f857fd97710680a5a296610073b8316c45450a0dce5feaaa6d07b8b35ee93be400fb291347de7eab54831a45b1ccd811ca9ca4e6f6047e668a1697ac2d1c55d756480e865ddcd46007255fa5e9c412ea147e2d0d658d39a5967a7ea2c8cd7c3d794db20345daa5ba84b8560fd7596fd74060948c381dec29f7847ccce225432c060e54ac8bf52e0815cc8f430bbf0fbbcef33fb2ce8f94e7b214a57e8998d2f30156bb719d1c55797a3230304db590a7b48e82aa03ac83bb46651e089bd0800b76e8d689ec010d208949d9822fcfc760ccdaed400823959f2316081e07e3171b37ebda244b99452d744774881b27fed2aca7c3ab2efce98128116d44de03672383dbaf2ab612d01db2097a516ad0ba2f3dcaefad71c21316e1b9d0e99b4de03aa56a9def2f9c8704fbd4605c3cfc1f6c83915f99415bfa8e623effca45e05dce721354c2f01607dbb5ac969ff92ee21eef5349671419723ada4aeb003e28815bda0a61fbf3adf1fc1bcee2fea60b9a46c02b22c1f9ccba243005eb7e353db54ae2f7fef09ab3b3944c21e8a8a4a264328fa3e3a268456abac11815a6b539bc333c0c8db1e7350af725da80a3d043e3c77a3c4c82613aafde788f92f45fc923669130bda010d036e22e171e4650f058bcfbdee249a68afe7333cef2175525e4362577ce3b8ee0c664b14f24c6bb79c5b15edefd1889800e2996b8c33cc4a163d52a672bd06297dfc91381c95df90e738841a953ff36e3c35b734b11b58516e81fc2a7c683e08195ecd557a80100d8a541d27e8eae4d92cbcf1aecb008525f4c381efe5265275a0c08227bb3412b047779fd4a688448b2985841a28e35614fe893e5996dd350a7237937a53f0c42bd1b73c51503a87ec1abcc9e2a6372f22ad35bb429d0300e5738b85bf78359f6f029831026f5496cb748bff6f07c26f3be659af9477982a1352419c3efa265c101f7023c2828ec2c8bac6dd5c6a194eb5f60505ae9d7ec04e5b27d82fc6b8cb19f61560989bb4ee5b034021c1c2c19e7326aee1e96afdb02408babdcfe6610078497c0da0d7e01612f6624054567d2e209f889ed10448819944e97295727eb0adb64409d745ab18760215b8e71f08eedff155cbb90b05caff8d301a57dd2e943dd8c0cedbeb13abf2d479bce744e57d1769e7b850d096b6e65e37ad74ceb7b22cb464d0a36c0678e8f5e2c78ad3c2a1beab4e215d7088a75ea6706be0356e58e6ed953615413e313b25b59c3b9b7b19920aba5f1a48ac038c1f585edc887ecfaadfbcf521ce5c233d000839ee771fbe3fe856d84524369baf4d214cb93f1167cd7d53f941b31422436b747c0e846ece5418f8fa403cddeb12a09d05951b292f911b6c8413505a7c038147823586be797f1bbaadd55cc2ae7f1ef3be47ae95635b7a63265ca38825191561b110b77bb9c7f855b576ba545d28c46a58806e748e7e11788a821f2bcbf4ff47d2d4ec3ec06080a3a1c2bd1a7f07580a2b85746a17ca756502936d688b39535516ffb60cda279b513c423e505ccbf0466878d105d51ca700f37ee06cf04a899ac521f409446e39bef4243dc467bac21f4e9363c342c41caae5dff979480648b43222afcaec4e6b060adbd6ff12bd9b0a7c5ec2f2a8d4747da23aef5d0fed940800a1d282ee9978dd9176088e1e14eb2f34fef7d87828ffd8bd91cc320c0b05490bc6e84be9486a7c0a743059f332c4975a44b24ebb69cffb6fdeb04f66221283472ba5c59dd6c721dda761e1c620fbb9d780628bcc0ab74cd75f93546c5718f61522d357298f7e5ef0767eef85d1977582de0b28f6d759d2b19a84efc781f30ce331bff87c977467931d16501af8e9290ef9c3892ee22c3adedb5ca742e760751d82ec63c3be32f4a07bc0e59b9e5539709d3814b165a3636ddb6c870ddab65c3b615040cfd2121358229c6f247170246c7155cb2621f94c683cc6e9ad473106f968cdf6dd215d401bf1d9b9bd9fbfb8f17bd920a7dc06d1d3d6f78af5ece6e97c7c1d0837d4ac1c82c5a74302b9a72f5eeb63528ca84b31b5d07537b3d16510400f717781c554034f3d74265a7630cf06911366093320a5d56f7a3407311660c42920aa1e0a8f0fe959e2cae04d2c2309919e228cf3b8b5aea70888779d904b20cd826c73c922a4cb407957cec3ea80390505df35f9bacdda0fb26d435e82a5653e48f378f6f0526d97bd1e6a47bd3214ee9027b87e6c71d1bfe8d23b4f0569baf15161608b66e7563b2b73b24b126670272ce96b19836ebd3218fb47cfb3012e0dfbb5ba7d4f5dc8efe493c95f3a7c1b32a31d7f9cfd1c6575ddabe2e39927872d30ef172184504f1a9f2eac96a5ebb0e30cb26fa2b3f929bcf67245f49f412ee6163d30610d0a3e2c0c6bb8107e692a777267bea19f7598a3046438a8638f77dc8d77af33021abf7e602a5bc5cf5ac2eea88518043074b1158170d8a30b62a5c66909eb960493d8505a3a853021004a368e88b74f0e20db8de126bf1bba2791c84181a5fb020abfa034bb9cc6af3f944a87255d14b2de34602d07d97077404d0dab241d65080e6cebab4b0eb1af2d9df0916d69414b66874236e45c5c3527efca2e7850e69388a62053316552c67344c9d51ae26e087c42031975ab592a7ebb3315714f7a5cf49c5f751e55324524d5d1fc4c7a6b56e455ac4eab84fc87b93b9e4c7d7e8e72d45c3eab387d035331ebad293f49dd13b217eebde329033f5d80f8d52b7efafce69d6bf54ca970be74b89331702281d235f20f1a9499c17da2159becf2c0202423a036feb34e2ec4d60569e6c348cc4053b94b79ca0fde8e9dfaa25391729056e46056223c4a8545543f9d05fe8856bf4ecae572a5ee1913bcce065b8e9edd84faf941e77f466fea4f5a8ac836523d8c0c8e9cc796d8588d919561fb6f6613762b406ac60f4ff0c0dcef0a0c4662d09960fc88127b97d55554b1da8c44c0a09c92c3249e0e96360a07a9060454e8b07edffdff73adc554a55e7442d6fabae320c36023a537cbc7761549f82ee5f1a158610d60d9de5051e541303292d9bc9611ed9ff328270ebe8cfd160061f495708f9b946af936a26d7a9badaec8f94b9db6060961bea2215f3fa81cdc456d27d49e7b607935211ed8b882b77ca482b2dbeca6ead1f887a120fe20aba66f78523a18e6053336cbd6c319a3ba23a9fcab8659c07db69579a77af65bf0f04c702b0e414f715f959b1af16da6e268533b68a171b8f59b37fc0e598423a0d5167a8c146aacb58259459ecd3d552ee2cff44558d2f6146a457f14e91dce0a5d7f782667c039e51738ae34c1eed41094f8d247f015c41fda0fb664a4a83134c67bd36eb5cbda0d4a77c9da13cc46d60076d8f251960e17ba42cd291487292e49c6cd23cc0ff39dcbe9c15a911ef44f3fd834ec51c3c8c1b6555698a29a843e58ba80096f56aa7ec0ea2903b52e5a9123b12a9e4629eb6623c96db99d0b37eaf7c23095f438582e176e331b879269e374dd3e1204802c6fb1a1bcadd44c2fe9fd7427eb9fcacd9f9b256d460afaec8380fa5d9b0221d1033340adeedd5ce9dd6162a92d158e9b165002465b4cc3ff501a505e15df6086583bc367351e07171a921c375d22f8573e4e2b7a9431580524a5ba006974580c3142f82446aa24ad07440f8dfaf44aeea8b6c76531573077d35c7c643348ab71d29a19c4b45fb60805373d730a8ddacbb74c242a4d6ffa9b076e88c7841ce9fe52cad25991d0ab7e8d0e8f70b0981ccc5e933883fb29d4dfcbbbea915976434493cc0f74a118eac316454f9ac83b7e1ec7b88870e1f7b1360520b097140ce0d3af1afceb1fc24f8562791031986026c68346df3f2c9454b43783480567db32eff283d43954fbc2acaac0d592f41e71f6fc78985394555a392197e1e769063da30b830b126f361698938c5baf88f2cc308e710c7dfba4ab271c07e8a689afaf7027a1e13c29a4d0ae2d5d3b753ef25441f794405a685f3828925764c9c4d3bef0d982255b974785eb3b6803c7e4a495128f550c573db59f6daca74caec862a79810938757d7de96975e150e68260a2bd2309b88c8794846705a71098e7d98c3fb3af976d15f519fb49b215e2fdd965ac513c97c470d238c2824266ca419cc4bfad9c7d967d1da1e6d1084f7d838c0b1cc03f207b8fcda8852337db9c1cd2181741a2954ae9cbf80394c1ee5f1104097ec7c5daccd075807d3f859ae402164045131ffeb89f2d1d53c8fd5cff2b0d334287d5c6d12ba4a299cbd0a92caa0a37ddd6e99435b558fe9b2d51a63bb48fe2eb7bafa86d565e2e965cbc06b80b21d4ffd4f29b006e2ec382c9b9b936e837ae15728ab9a43091d35d8a7fcba4b1f4255114d3528258fcc19c9f1b720bc64711b6973ad4a33d96bf2d85669cc437a57caea01565c40aaeea27a2cf67d9b0f6e9e747275e195a44981ee75d774ef819e44c9b0bfc725997612c255892dddc038efc0cfb59c3679f5031272ef446c1421c09bc625cfd0ed849c37e7994f9b1dfb4e110ed66b75587abda7baab56d9a8b70d61c5a33d4e04d9772f4e4d189118583e33654cf82251d9780732e0c112de77bb67d25dd0e9f4609c6911cf787677f05dc2e6c6068e8e31c2ab2e4cb21201121d656362b6113a57a4e2b9794fc58dc1ce65ae8e9e40e0bd19736665729fb9835629c7560eed70056380c89c142e0d42a148f710ec5a6ee9120dfc1de60c64382cb5a46031414582eaa737defef81f52214ca0e2a4722773d908583aa38995ba7bc2cf62602e398b2c1ffaa06e66b32f6b66bc5f3b5cc84a550786e3f7bf598c6ce92df621cc0607c8d4f6dc12e5d66cc95d5bec7f872ffd57ca169e184a0625135b2cd2326f72ae4e39ec7dd85c15b734b8d1e79f1129a0894fb15ce8d78dc6f0b6614232c18f5e514647fda12ca750dd7925c99f2fe3e1a4607d3606b86247dbc032f8225fad1d4ef05b7b0cef097ce5a062a8b6d4e41950e317adbae28c480ccd93a85ddaa0a0b450ad8c6cf806e040a597eadf9f2ed92b38839f9439e9648c48ec1a5dd8d32cad03544ec9ccb525dbec1b55a8450ab90664136972b804e9055326ac354fb73e5dfe45bff702372cf06890a2155efc683b18edf68bfea15e1ad24006936ebb8305cfefdcfb758e8598ba29f3fa175cea36857bd0987f71c528870f3f0731950407bbb1202a396e533f436bd11bbdb5eada350c06e848259b3e28394009b708bb525c32799a5667c329bccb1d18767ae7b3e6720a009e50bed87d337e500329432039fada8faabd6165024582f2bb5022b8c8cfea65faf5c9c9f125000af8eb71a7a9f0b58c4cd0f9778b7263389b2fa54ab85349fded5e4c046580c7eb9be77e26fb66473c51a08e18141e3dd9d534a2cb7f8a12a40955e96bff7666195806b37da67b801f98aea127c347fd83b31094f1e911d6b2efa790558b9c7fa65285757d7b646f2ffc5ad09cde81a50e4d0c7d17d9b6f1a322142472ee0b4eb1251eba181056fc4bbadc702ae10fc939f6fa5198dad092023c7408ad573fb71e430dc88f22fd95d32fe729196e161bdc2d0f1121c7f3d9b0dd30aa323a460cf61675ace3d02d6d04b24caab623a73424b1593df4bb857ebe3f6e23aa7a8332fb652afdb37e0f1b148638a9d9fdc68006e9c1ce6cb869ba1411116154ce08ec5a2c89d07da679e5debd57a64fc35b846270d2f13deb910f7e766cf27e02db6c9847abb500d08762362a3b7b88476a98d63654855d174e46adabdec0a046d381092386b9cf8ec29f104b65eae7d9aa165a0015365364b153db9d1ba7ae9cd101b98334328f67f62864619499cc86c9df5e40086bd2582d92c7ed2257fb863204e775bdeae7ef187e33601d1c6eeb6a422c06ab86a8195c50559409c7d300a41943b51ad56bcf2e82a093fe504ef5f88e96868970db99cd0ac640009ddfeb93151473a6e17eacaccfaf6e73e032146828abc7463e4f7329a432b378e521dddff91e4ad75798764178120131f2cb10e9d1614e77be6603796f4871fec5af47320eb5e0cd0476c08aa6b345081dd7d9079cef68abe38aadd3b6910f8b7dcd50795678001d52a8e69df033a8008f3a09ba429b35d757c1c6789291681bf79326c0abce0d45b0c5fd307208e5ff9a838895e1a4bf204118ff5cc41159f4ce68469ee021316866dc42feccb755cd1b35445650f101a4b3dc5c5b6d472493b844d887f2785d25afd5eeac928d0b18489fec2217a6a593ba0c6c465e21accf7436e90422218c6bafd45472634bfe1d0260f17899154630cdd6b2fdbfb11275a8889a8c2011b0b0ecb844897772b88b5a420384cde623c60b61963fe2bea98d972bd9bce3677bb199694a1abe182156326f831a17663ebb77ddb842a3a1bd387fb0e82e2f5bcf058ac6c608c8888f1fb66f0b958b121aa6cd77ddd206af5ec26c8e52b93de8f4dc7f1c611ec9bb2e3350056d26dbff90db97c8aec355e57e30fde98ca696a8b01bf92b851c83a79f2994482fc34962a66cbdf0c17d9eeae17376995868b2470b74b7df1dfc2bc8af6a1c94016e84ef12869dec04f913009059c4a7eed2efb7f5f63bfc02486ba21ef193765930180b8136f27f6540e6fc4634e8b50fcc74706a08d59f4134c428d240a825f58d48d5c441b5e9c695f98fe03b12bf0fd309ee686a923982ac1029066716342a2ea4b2df524053ac6046d364b07685090abae0e106b386057bd83929cb8fe7b6b67ffb099ff6ee555c33cd0c0d5614c36a102f48067b9468db2d4852d502421d648ab75ee72740272475774d05eb424f9054c039f3e21fe9afa6aa2e0172c1e86b35e2a41beb7915a04916353467d5fafb1a9ac50ada71bda653f82b4cabd3ac353d1803b0e9589877834b8aa51a2e5f3dd1ac5aafcd2b8a4be7bb88b792ef4fb8c333bf66b9ab6877898da8bfb0e90f4fc08a02b58c5a1f085dc6579465155aa68207eb101e161de6a0ca6f6e126722dffca73718698f1ce1ac8f2a8b6dc50624330f47ecdf2981c8aedec5b987c278112902050598c278802e8a83209cbba9af658e8620c61d76fd980d377eaec56b1a362f19a7c9a27690ad412ede1ac0bda6964dbc448dc16de060949562f825de8cb85def550f1c78b7fed83240e2ad3696c5c8cfcdbda195a76c786dfff41db405aedacc4b07198a26402dc06dde78fca47181aa5943ab45125c8b87eaa6e50102d476fc815cb1716b777922fa5c2ee79623100479affc6ea85293ed6527c757c92e2b49ab62c9f00e8087b60ceae3a1b9c2bfbda5c63f3b428594d725797fb73cd917393de3ec5c0b3b760407c5b79ab730876ee19f63287243d5a4d353d1d6142889c0887965dfe828970ce43fc544478fc56e430ebf72602c138e77abdb9714f8eb44c484c4f653cdf5ec402ea12c97646a4b86548efda67b2f8893cfb89bde8f448790fd8c9499a73b73ca16eb762ecc1b8cdf834941bffb96bbb7dd2c9492ad022d82ada070191da2b76a952f2f41ab2f9933d4ebada5d940aba114b1dc38d5c2b6f004fb3151682154712d30eaea7024c9aaac99e7b30ad519b9fd99a4b29c2e36344b86c16282cc9dada2314ff897a1d99ad9020736739536c20e90d81363f7cb2793f63679d266add5dc7247f9c724ef403b5948698a5196114caa59e7157439b9bb2ff1115fc07d5fa4587dbfbf2669d3fc5ecdd36622625a4e7aa941b6b053ebd4fff6003ac40d0346d36ffd5504fccc556bf6e0336c313717e94507faf8214acc97df35bbfcbd5c436033f54c6acf1b40f2f7fdd2d0bf5011e2bda779d31daaf6f4fa8db30d83e1ff3a811b47ef229497b63a8caa4235f283041737c83cb1d64acf805058d1c1ce8c65","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
