<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d60d25d105fa18cde56d27b16d4a220f1dd5ec114b53dc4df7c5a4525fef39a087a118c65bf65659c99a2b2a78fdfb2bcf9e5e900976d45346a3e540bc8ab163090845eebd6c132d1373ba80514bfab35e44b17962f4514fa7f446b40c2f059a882f0f7c0b3326bcca4e4ff0f39ff2ec2b8844922b4c646403907303fb68937a7fff76be70fd49ffc4e556546c847208404149b41b0012cf6c23359d19860fb26dac642380fb52b44174488ecea248aba56b1b223ecfeb0d61ae745b476bf4b9adc7922b7bd4e4c3c2503c8fbd1e2a76faefa8d5837ae81141ebcaa7ecc32de8b96dab772671c894a584d7021404b3db656b6725d0f41efb039728aad16fc863586be064edf8140fefb92703bda37fb5ee46777fc88a3d85ae020a5a942ac98034d2a361dd5b3bcd17bd677b08b22e2f74027e2a5bc82be64578379109a5a5ad98bb78fb237895fd6201acdf826cb4e8267e047c5f09c86a0a359ec9af0951dbe0a3645227150237d8ac943af0df5fc919460ab7995de196140f8cd00343ed7ce77730c45ed7375099061758dd25eccd8fe671370aca1d23c8e7f49c6f7a659873a8dd8d5000cf706a767c4cccfac3c6bdb106229e959fbbb6977d8f1ad9c7d20623a4eb2d83abe370a483b8a3fb9fd390eb73741a9eafb5805aaf3ce40a1d30442fee1fcaea4f2a10b746b164251a8d4cee1e296f0562ef9c6f5f2ed0df39cc709a4538a46b902c5ce5e5d98a8ac7b3d975031702dea22ab2ca5e073318d400c9920d32c4a56f8d3cfe02550a877741d10092b5a90d7f3fee8a5c1fea937238ba281706fce455ee81eb768197a2bfab2e9bc78266230881a6bed63e57a0d50b25b0c5ee33247df8bbae607a818311c153dc776bb3a1ff282ec170611c409aa907573f218f28e7ccbcab4ed9183440681abca02ab4e487f4df0d8a54a1ddec3b017c11f92ac481e7b2fabd58659de0075e891da4e2ae2223b1a5dcd76474cd1bcb66bf627a29efcd9eb9a910f3f55cc49d38a785b213c88166dc901fcc8dd1032b5b9eb4cab6f06994411f2a7a62be5eba858b9958e33d560b6aad346e1ea3e17596b4b90dfd924ff5d381794912c80093fe51f974f39b7a3d33388980117a19e826270b5e1cb7f692bf052f2fed85d4b918adc3740fed23bb263df7e5b9af1a199362a292d846a0d797534a3d0f014f1eb3fea05122fc4f10e001b1b78175b3816f6bc79567bf3e162678d80a75a9ca3f4a38db9e1042108acd2099f09a7eede6e648c4d4251cdc7aaeb4244a5c957ce7693b340630fc8f205dc167cc0efd1e34500fa0a4adecaa2c5d12dc99d8ca50a93d24c5f143687fd1c10fdac7bfd8d7255b3c7599af2b7d1e9ded613924f5d4f2ac18207831f14817e55ab9242c6a5dd5c7255d6ad11766e697b55b8c4250450a0de19e58cc7f16fae599838fcdd452a5209bed87d38e328595297ce6a7c30434db4c192e311b588df27b828659d219b2944b873627de89110c70ff3b22f5db55b4bc49e77fa1438a8f023bad5d539f7382ea3654d95cde11a6add57e5ad45637bcb626dd95fb359c58af67f3237abbff23bbfa18b0ebae5205a1c04624f09447fec269005d1f4cc233b2cba9b88b95819e6672ac4512fc46ba1b002e070f53390e2cfe7e56da153222e82f8960ecfbf251dd20bf269e67874a3424dc2f494e781fecc780d0af245571d685e0d0785cc09859e787b170ae6cc99005970631e4c773ec728890b44057998803fe3c46a4a31bc2c5074bfd971c99466bcf9ace61b0896b80bfb716b05cbf7cbd9b2db10fbdac25ee7e54268018bacd91a9c322dab3db3a19c228010726204ace4b2bb08bafca6941a59491a17b87c81b1a0cc475bdc0e46b9bc07107b0273f978cbf63afc3a72c1c08a8abeaa2ed80bca0d409ccbd95c520747a5bcbd695ac1b1b00812dce3ac4290e39bda2f9a55c97e2b2bdee3929d56bba6797fa66312ceb854ba14feddf6432697f48f5ec65bdc02be75215c2d6e9e001ca0d11ff01e4821e749d9f16184117e874f70b288036f8c05f78637e68fbcf1e234f8e675866469f4087138b9d76f8fc3bbfc013974912b6aff2dddac34867ea83a3ce6c49337fd8e3e34751c7c6c29b0fb3dfa45533bc2e7d21223598512640ccd8e854fdfe41273c8807e7fc2b0b95a89ff45937212678011d082839b58e0699c8965eaba5c201b3370613b4e97b7279931815b1859f127d2595481500d03b9059c89d5c58e787f3688d0ff7816435bcf9431fa8bc27177a4b4ceb291acdc5003c26dc4ab27415ab50c46debc0ca8c952e77dde999102ed03e085b2fc8d035f792838459a7722f0d52a84c26308cc990012b5ed64cc8f5ab46a5f2ade44032a4ac19bb11f1271f74058c41d33d88bab2672498c43f21af10b686c83313fa0fd84f933b0d6e363604b8dbd177cf2c81338d013f1d87da44e15d8ce3421579269d757bf69de5ae39f043f39f3e435b0de9dcd39c143d8b7ebf8170cc2665c4321dbc595bb43f233d6e146e2449e6a1794d4fcf05137ef01cdfabc68f5d6f7db451a49e673cef778ba401ee6f921644e10a4864c8a42317d7e52764238180e41c8c0a261803ca9596e601b7bfc905badfaa47a5d732ad4572e29cea8fd50c468bce8067d364825be0d654e866b6147e2f20f2ae577def298447af38dfb364a665877e682d8a13c508161c024b51a86278dd63520fead63efe2043fe9a0a095a1b3498864fa104523ae9819a3512c2f13232bf65eabe7a649bbb5943405ed85c031d1d7a70a8de3eca573a06452eaac392be02db434a97da5d13721a1e9e27656455da3ddb78404e23e9582b25e8b0aae72f9b575320b6718d36b60a3c095b65374ddda5d889c3d117b8a8c3fba7ed3eb55cd14b23e35ea54deab384a9c7337f1e1a083e631f0a314ad4fcfd7c14bfee253689e42ad9964a77033ccf2c8d78120792ac97e6f692eed6bacbbd2d3d60c2a69c5ec65a367a12f4edb81c24f03655503d302917845f0ad095287018fb196a6e4edb953324a1033483b9a92a7578398b1910b612616b0b5db844d926a6a1419ef945a5d08fb2536acf5d3ae880ad77fd1f361fef5bfcda05900bc151073e1639157ac1820b0c0d1b307b82d3a6db2624bdfca641843d4a70af7b06c910b644cdfd0a6c07470b8183774a105c61dd9b2e21d4e8827646f7b1d5ec311ed9c04108c13845b84f66bc30323fe370fa5e75590077750263a26e6931b07f21f7a2f3b6867fcdab751d9bf9823fb0f13dd427981b2ba7ac8366a305662ebb7dbbb04de28ce0cef9d073170f5f686446ef853b5086169a5ecc548ca373d2b9701f2c774e078d4a3d0a8bbc6319e479cca4579c2670845d0240b639cb82df57fbd635fe51b61346f5683db9fffb4c3518f362ac032f1241440d9d3ea079352bd8a8d1b1646c475735f9b71db44de4922678a893f2ff1e7c122dc86f586b6c3cc724cad34a6e302f3c55daf48c4b619f54dcf9aa2540e7a0e2b1daf35f2eb5d0ab38c331346969d7a4cd5776b42d58ac2b98b22cb89847caa713f76d81faee9099922f7c5bcc41213eba5a7ff310378bba36d6e43737e34dac78039118c3eb5b38f1ce02b6743e11722664a4a11ff5c5aee0f7825953fa2a43978ef6af9166d1952c634833b531252256cdc25bf24d86d63b73d501832cdbeb420ca483ca84ebb497cc6fb1936ce044f613b1dc28d72db15a639cfac620ac5e2e4cf2456143edc27cfcf0d749daaadef12408b2c7ddaddf1584422ffb661123f7f7f10142b95ee93bf98da058be18148aba2b11c4f984650a03120695938d82807e76f4621666af6876dcb53e905a43271d2d22d509ecbd2fd5f8bd10a500108ffc3b654c641289152d1aa5bb22dac088d881fd8900742cf95711ab8a55fef74eec4e92382db14571e158ba73cc1a0e9df929e8ad3d19d4fde57c52b9bdb4c1c612a93cab56f93d8aa7d2443f3b0735dc7a77a2cd7bb24da1b3cf97c29ecf2b17a9ac528bc78195fd697a5a53c133ab7646cac89b298643156d74eef5eba514d29bfabfa6396c2b242c7e51c8f645989364b6cee0ef63643c5348657cee590667b00a93bd29601667a68061748ee62985df22bbad2e7f8df924c9a0e659001136ad49024b6f44c33bd0c7910b2c7353b4916873a16e738d337c6d49c8428c550ec72fda106410ea8f24c510cee067497149895d24bab9749789aefdbc8dfe58cc081678dcc531e23049a7b92e4510b5ab51b76af59a914e2e482d9994f3dae9dd8a9d07170424f346a1db62c99d04a4bd2c7ffe8c359726063392e64e4674a5941cd7f273f6dacbccd01adf30c4004f6b4e70d7574d85cd9ca0ede559ab013e6023be2f3ba3b7fa491669d04b2d0857f03aff5dde6d85bce6d473b098b297f3752c6afd4693a424c3116633cc205ebfcebb6d2fef064a173b713591060fe07f745546f524cae824bbb36e5861d348f6c796eddbbcb8869114c49de7aeb351bbf564faf27dea29c3e68594a7a83073bc499ff1d1cb8f00eb3d48c6e9dbd7f1a6608171cef39310d7160b874849b6e556b6a533583122c297762f9b5ee288c661d356048d5491bae86d2485e3923df0bed1146b5973e7b184d9042dd88b1528564a6c1d6318bebc1d16db4dae1b062cc8e8289a87e268dec0ed9b5c23d6404ecdd3ace80cfb038b99e29c2ac07c798c2eb5dab9664678c453fe2715578d14b4cae21860ea11e668108d3ff8b8120f771c6693c762b944571bf69076f2b56cfd390815de363a5e3adb7914d71f69ab471f7d67e2d32db303988da1a8a1db33866fbe145c32d33fe88cb792b600ce93cb7f841f6ffea94b66fcbf074026ab0cfdcae1445785691527f26a99f52a42e1eee3bc52dcc0c27bd07b27eabcccdc4bd935475037cff0b002ca56aa6e62986b99696f8d65d72c2c0a57f98f369264711409ebf2cef0c8046be9cca788c33a8d7513e28471ca210a7b8589936d11e916e80281407dd40a61167633eca68f1c7aea78d35d82db0121087237b78fdef603909e6982a9b1830545a42ced9ddffb4ba9297305ebc273708d898ed6181d00de258b4933f25176cb4e216fba8cd8d0f20dce7c152b59fe7535da0880d62e44857a9bd7298b017d991cd5590a0224c2689fd2532a8c9f493c477e29e8b82c8065b58cebcfc84eb1fc82cdd1381626941886373f146fe3dc62e89c88597d44f08d88f84fbaef12154a5a4749cab66b90e6c884b5a734a1389508d02d127535a9d13d81c967c638cedd64324f035d02605a4df1599e3e61a53ad09d04d69b5db0c1579796d418f50d84022555412ce9fa15b8459e2de49e83d265fb87b85a671ca046d12b55743891506f70741752acd42ac90de31d81e0c58d3deb2bd0b15c2fd98f2398e3b13e5df2ec6f7384e02d1c4f3bc8b1c72f6b6b92a72f1d0c6196a702690d7695c37e284e18dfb11bb09758c6f306ddd711639a3d159f2bd03c77666b801c68e601dd7655386c196ffa4966d963b25ec8beeb310b519922238f41fdf0dbfb7e5857ef6db836f3cf9eafda706ccc9a8c363b380f2a064bf63cee00efbe1a64c4d330d35685832e37c35ee67a69058d33970ff03d3654bdd9c342bb7215e8e105abfb1c6ad868a6fc52eb8b26d6deb9c003566f935b4f169675f0eb9a7d2186bc024faaf5a73f3b46f34363e4607e9e37e7ebddf45f09a829d71feeca49ec74bc09b2f2eb3620e43cfdab2f7093f5f610f65a6264296dea24b4751dfbe16310fb4de9f9d809dc6c2a366043c9f1904e3341d232b18be910b9cf554cd39be0aab810a45223bb33a8cb7c64fb3a7eb0bf2aba82108362c5be03b6a7bb99ee258fd3be4593a84d2472934750598f3704a8609db7de05f60329e09a6a6faffd58342a0f4bcdd29d32532aa7d6436acc610d46adb068d1f38a6618864350fc822e4281f759f1b3db60c82535f87a0489f694f37c0978c9644e1c3cc893fe5472db7e4b77a963a76c656d6d0aa38c159dad755446c1e179c9b8bce4ac96e64ae396844a20aa1a6a7d99f04ccaf5722ec02c3bec18771f135268b8e32a4de3c851922f842bd1ffbb40902d09f77cbd256722a7d2afc49919f721feeb0c460dea02fff181822b9e6bb5376ded9f8c26af85cdc7b0e539b8613e9f51a60f4e4bc26795067437a312b2931de5cd078b6b7ec87198322152ed3588bc6bd48df67d9847b7bd8cde48f3df944b12274b55244f597987ba9d6931c6a2e7c34707afe40ee3f072c4a924ec3e71d90857159ba516836f5ab58c920f0b014a06b54e07ac64e3ae5a7ad3c1e9916e5cca251f88aedab3ea6426fcc80cc50e54983a936fbed9b7ea993d665ede42cc87e7c7438226a054ccaa961309fb4a6d96cb0306b22cdf5c306c96accf194072c325486718d1134c54454238a92d2932eb52257884b22194d7e4eb49ed18368ed078dfb45751317bb501f93a266e9669ad9142befdd8733cedf87756c9d321fcaf7163c686ac9164ed38429e8029c7d865498c4dd845a937a53a8ff8bf7ba580245f9537afaf0d8a11b28bd8685272038b78835d63516058bec42a154ea2fda0d270407a6e2393e13c9d27ee72a4120efdd073d618048d1df40c7c52c82791caeede88c03a23a9844051d42f24f32f69ea7871cfc59b1fbae7a278433672802815a16d83ce98514d17e99cb2b7deb25adaac67edabf97769f734599e6dcb54b8d876c397d7f8e50d00252760e78ce488276f22f59e400d818b72ce7206ba0a1d75aa955bc28f7582173f2d14f7bc22f92b2ea8f32ee883fcc2b03a57a2c04d5c0088beb73466f131ce57085c152f75d19b275534906179dfa4500b07d7f14a54aae9c7d2e9c113c5a343d9cf19c439d56d3db6767875decc24ba86f52b08c8dad27473ad6f85023c1cd1232bcf0243c2ee719a32d0c061a94b0f29f419055aaeb1b29bee8c0703c5cb8b1bd2382698687be898eb4f8e38f3b68fa450a58b68001dd3d80c4ce1ea43d22442db8d9564507d77e6b6fe13a0d7ea2bc72086713d93d60a5a0b4c667ac6753e31de8524e7d49999c96e49cb634a3ec6dce7c60cca0f6c836da81db08992ed2e2f2c287b1770d8d5d09a87e7615d2dda4211cd16ed89c108118867cb6b575a8a83b6526e7945adc75fa571c1c0ad10903112b41ff9292a7711f48f2cac2eeebf5ef2cad650208829e23f38c266d5b7053d405b466f4de2d2a32dd412c62cbbca5236d27765707287b40cb2c7115a124f396eeb6ed76c193bfe5219bb2cf12cec88c111ef0ecfd16577c32361367a6eb9c3b4b864518ed46de5bad80ed74a19fae432f65bedf80cda97f1addc006d66e099f9020b1fb38498ab9004c87e83559e3c1f2c422afbd5822e1e3cc71322205d28dc2c8271dae56f847699bf364fbd78c4fe9ec34084eac9a7f180b34f6f48b8e75347b7ad974f6534c1356584443866455f5ef5f48a5e03d62e6eb637d63aa60284fadc79b0f436bf26fc09e94e3608b73aa7e0bd31713e83b6aa6af1b9487903fafa5eada803678a0cfe3e3eefda053ebcbb1d4bf3fd7e71673d29481e102840132638b2a28a2cb8be2627e1dbbf0f2d5b5ef28b3310a621547ab655470e6c2612db3bce83f966e080996e7a9360e31433a9824f1f2df5e0fc87e3b57f2286cc67e5e78f3ca87f9ea4f378ead50f1663e988718f899ae339655bc73c8311a0f3dfd6ca568a823472c3a2410df4e24ff915553be1e0cb9fa336e76753401226293c70559d020f8cce46fbfe2ede77659a448b6654dd1bfe4a4cfc1eff131e09684b6240b1f1578c097627a5baf171eee752b5d5aa44c2d79f1deb8cc068cdc73271763bae199f419977d880ab13c52feb76dbae0957e382936bb565811cdb08dcfaaad5b1d01da50aac1f495d175778f43fe9af7c5bc2ef65d674320c148776d4eb8d795fc0d77e20a5f69f1bec51f45437d23ee8f059fa31421c9394cfc945d3c8b8fb9026e4a2e3d9c67861f0bb6c823f84fc4bfe9ce82b23d0315b0e7fb271718d998591e165e6607047e70e37d53750bed11a617a556bf6c048721fbdf76f194cb06fe05ced153a835e497a3a6d6eba111ba855c059e21ee91b08b8210763d2b21ad8b8311b89d548643e1cf28285a2457ed7e852fef6ea544c172de3f2b9ee1a05bb78099531c3c700ef885e9d40e4ffc52e1461141854a75ff9c3399a067bad9d8f6bedb041bf75113e7d7fb2106e5c1e53aa5b6d79ecc8daf7f5445ed8e7dc805e8863e6f91923a52df3d719b52cb7c91a93dd26c85654ea6b1a1329175691a0b218e1e9e844a07d201ff9c4e4d1cd5e7b5abce60884d3ac60fa99264e300f0725e3e7622a034f9d7a79388a02f4b3bcd589cc7237d60b8b72ace68b67c7f8723531c8395009baa14279dc68ba636cc2bcad1e5876e4e40d9e78add3821f8832ea72d19dce4b6ebdf197e1105a4b96b4598d65255672b3051df00c8a54a47be77fe14b2ca947f1190e9bd4f42cfb89965728d7ff38752888da62781aeb482b56bee657c7835f6ae3141fb7e19cff5ae056c56f44b9918d01c4cca106a2d439f348db2e2e85f36b97a60d767b117c98975864833ae1e81c0d4484c95fcbc4af0d9a3fccf7b4a1e590b0ef908f5b3112ef8615ab143676c619408efb349c05b42da80138adbb8c961516ec3585a1da8d4bae485e03d2c1929774f6cbefc63952f1ac93c72caeb939ac41323e782fe64f9d21ed3fb1e9f38ca06cb886bf60b51ffd1311ca327a1541aa964564fac8c05aff57ffe6e0d4c233d2e86c88112b37cd572e0e7d974f87861e4580238c84aa2bff4079305d429ed8cd497bed9f913dd5e4494b8fe2d05adb878f7fdbb3c4a4c16f77b4c4379c106a5a2a4a410cfb1b30446749d7f642fc15b60c4230e60de77a6a07f5c88e3a9084d7b3d91cc197c63ded3a07b67f8f91f3a9be4e4abb28223f384659fd7e3220d76a8fa7c75b460c2707b314cb5f1daed860aee46c2b0ffb0c77320bab110ff41fd79459a1632ebfddffa7c2984f2735df7aa28e6f228bfd189637c706aa158b7ffa1fa77ac7a97540b9acf074f5fc10576582a5e05ef00068212f4454fb7db3abd9a4f62a68399cc7dec8c957c0ff7923b11f23030676437c9d0cdb2bab2b81f6fb293887ada6b4c14b01bcdc7d30f582f8d058ddd8e557a8e8c78d8c3238ed896f0be117d3909d8f8706713aea1650a9f6084e887362b4e69f1dad2b10c55073c28611fcbf0dc6c28dd3daa83d6404bc00e23c8f68bbeb883a3f28c0b46cae5c520f21fc8f241363d9871bc709a92f4a34ce2c557c6d3243bf703f6130e237258bbd082e2b6e10c2ff0821f848b7e0e78f798bf1e9357d60dd923fe2f73184bfb882503029b42f233ab5cdb59028aa2971c61d4e7daa32962effdae12eab0d74e3bf0e8708567f9f9648f26cd2b82e8cb283e84dffc1c75eba2d9ee3757270f0bebf793db6be8bc02f4264ecea523b5afde9df1a15eba1007fa0448a2705f811278c63559e739b1e304ce1fee685a7cfa2536ae592cda1f897f0e1e24cbd08d8f95d7e8f04851fc287dc7c43c0bb2f24f700841a2fa776808faabd8ca6e4d63c439efb473b5147b029e600502b2f870496e67b6fef8cb07701596359b8758b935beebc43c49941ed90ef51f0226566a6f0b243f15dd8583a8efcb51d4e869900377ffb7c0fb75a88e657b8cce4e4380c21ea1d6ba48f95ae7ccdb309544e90f909358a0093680a5fe313d3f9b4f849af0d57c2d76a176b0b026cf0a92b635660e4721dad1df552b3c2a0211e3f15433137e09df59f6ee22cc772c14e37cc441da6f8457aa5c76177c6b9a72e57d02e9bb6c198bf3a47ed15fb905806c98589b10bac1d54a9ded2e9183bee54d9e3fc0076b810cf0ce14118951c69c315ab5d16aaf74c7861cf1c23085a9bfea398d3e785ba18bfff0df183121beaaf4307e857c3a124253346715f70b60d24d5353ec578353ec45c88c36b6fa57ea041ff223f744203aaa0a21bfd3906318e59f35f90e42b6d3d450cfff729da8936c9173494fa947a76ac0fb51e1159c18080e087738bd1acb1e3f96e8375d46fa422df4c8ddc3983b421bb0cff5b68b3af44bac757bd4918d5325a67a3be1fc35fccbeee3bc92ad68e1468712d09958026e4559ca58d6778024faeff9def692e9b8571d44b75aa6047a2204832d227acfb0885cecdbb00c239c47502e6901e0ef5c8809bf1b45c5187fea8e77c24b3cc2224a1272a44d8a3e50a57e6b40ba3a55a0549c3ef9a179c01d5463c9ec610733095b40cd689264105d14957cef698942d23c8d6bfffde01c3f97ea440dae829f6903849d454040f2fc419cdeef5f009d9fabdcee70666076d0e49820913f6a0c9a25c0b5b96a1acbb2ff71288454838e35320b8249dd91097a6c37c0cb118e10c11c10176eeb38d457cd56ff8498d90e81945cab1652e83b275a2d12878bc8a6d6d520062286a202a2b5d4d60f6813a44dbe4d74193850773aa898cfd24029253f7d3d2e7b6e951dbe1bfe2f6ad6d5451259991c7fae2611b7c63d600cc6a196e33fd20b3ccce22d3b1ea47f4556559e718a97f6c1b5e7e83323f511012240175fae073406eadbc0cf4267da0d9c8f117e24f12512dcc63b7d1bdb12ded4ac300ffcd704ebdd41b8f101534715cdedb6fc7879aef3f09ca40189bf30e12841143b0c9148498de351407190dbe9ebbaaf11c66c2613ef7f26380cfeaa9b9fb50ab97f8a3e65446b1547a7f1132d232cb655f4dbf95eafac5ad92029ba63dadfc82860957ca6091c32fb1642af3ac4732038dd093ab478f1474a18e1cb9783d8f1bc1762f1005ec064bbd18ac3b4a771a8bb4c9581cf39d1093b5400c5c916afc1d15b88dc5d2a17ba91407cb14fd182053bf4a86affa79e2ac24983f2b7eadece001c2b530c2a37f9ee72543acfa8a71d58a259bbd62acfaec1cab331f58abd434bd6d3bcb3267d4f74bbf558acba8d05fa67bb4149e4a2f0055777fd6d72b77b879b0dd4666ada328370f5f4bc56e98f2cdd893a682f499acc889d400086e17c371d70e96b71f700143c6b32c800baf4542151878a1c12110aa2e9c911a45adcc09bc847533c433fb1dc86e9507927d1bde33744a744e854535a106acb76aca2a6b55dea669eff4ca1c986cc8813183ffe3056d15f192c94742a544290aae21a4067b8074d787d72b8248c621a2aa53f5bd5e5ab7b27b40aba98af1c5517c6f5baac4d9c2a2d54d0d7490dd726e9af96d3d47792228fc5af6d5d6f32ec19b618004c8c618c02c0be70b8061ccfcd70f818104c74e7abc2e7c3428b73aa46286657ce06c21b6efc146f31004e3b16e1e76e67d59a6b44f9fe09ce9c462bad148e6ed0b8dca0939087e00247c937adfef61ac3da35ababfe0aba9aefea89646f77334bc6b821b23b2f5823ee2b766ea163d79a4d24988c447e7db9241fbc30377463a274c47315d0bd143772182a6b0868ae386b6e916375e848dcd345d5c7ac09463c6c0215f97f26db3245a46ca1f6921a18ea300ef59b9d86e686ec5f6c7ad820be6664a1a6b3a4371bb0a1b1da11dd35a079aff703401d3057bfe451330afd07d03a67834c13755347d75fc1284ca6331f9b5cb4918b00dff1e352fd604c18d8d6a3d11f9716c7c5b5e2efbb79104b4259a92176f4050a7aaef420cf607388fd02f62c7bf32623d3e8cee91203db992f1defc9169d535f8caf3bf091dfd7974db6454ca92471cb623971246db26d65c3017c4787fa5d416645532dc5137d181b891f7608054a1816b64fa7d01ee0cad11075c81d43897014530c01b9e44da297c5b2c869b35aaf4452e934015fdcb63bdedd982260afab110f5270d3231d73b04ebd2b8f97867c2c7b1eafafc50b2b058d129da3a6156e066643f394df2a9b11a450ec8260d026a09b1e237fb68a117ce3cd00db969b957809961c90abbe206ebfc2222f81de60dcc55a9870bdf5dcc78aa60dea4b2a4f8277a895cc93bf866348cb97329f98fdde9662c4a42b21378d234529064ab0105cd41ccdd3a4756f6ee757e8e47e425276aae6fa88ecdb7af0062a191d12b2041085a84f14b6fd0ae328c20506aac82c164ad8b2a8d6b19f02780f3b3d57da7cd0042fc64944d44452c7575de783dc07fca440a2eac4029b8e93df5e69c9de03854eb4bcb293a13c109b2ea5a203a4707a92d177a1cd86ead5c37a6c4ea342eb9f244e9587aeab69de519a8181f89266ce67cca59e4f255bc2b69b237c485cfa6c7a8c0d02941e94d79a90dc182461da2b41448f038986a2e5c11e60a3e436021b6150086abcd1f073178ca254bee7f420aa5dc987b0dbd0d1575c908b572f9f233dc54c1528f521b65f55a325ef7b60efbaf96936173b6217c359519c003a32870362782967d78114bb693106fc42a77dc8b7a23226e1c62c31e74e84de6e47a16b017fa112e3822f315529c94c0cc186738a6df5c11b8022a038bc5cd77479f641463d011d33876f739b5c0ebb5975e01922bad974711a5e9aa465f3ba800cdd995861fffc7097d9eca1d7713474913853578ad920da79bbded4eecaae77de4ed31fd97178c87cb6f1be77b24436e24029596ab584a48e6e8f0f4ca1147bcd45fa37fec23e54b342313581ef9ed0d94178364bfd301be7aca8e2f02b91ab60d49bf280451ef4ebbcb4afc11a9874d836f9d55d568c930e6d2e5b71614d17db10a7f05a683cc8320cfe477f0841cabdff4d40cb626931977b04962d276dfbd265d78fadaf071ef9199830ddf86db99c7fbe7bb537fe220257de20e779b5e3a7dfe284b649f2d398f400fbfdd99f985af2f2668187a5182d593de40b77aee9c34e5967bea052db713b4f1ddb5a9da36bd17108856f19a812572624ffbcce5309dc3adfc051ede7ef23b3a3321ee42f254ddef22dff68a318f5e73853551a4bf7f30c9ec4f99faeafd2561831a25f9f4e041c010e44f13c9ad6cb9c319dae5c8c3880205d36b3e7981009cb3f995926dd6f9fcd4dd569a1059cf0e2d39d9de3ca8f52f588b254b10d83d6b51adfafcd9c0ded1cd98628022967a53ec5b0fc6f0739dca5ce189b8b32f9c9be15d019f1b6805e2f6d32be1252c8835e6776819cfec8a8cedda2403fbac4f88f70fbaaa0b35e7e92bd72e7e61b85943b42577d231ee78d58f5acc291777a661967eb3e1cb85217dbad580a96a0e78042d38d2d3fd96e71c73735530b007c7e6c40f2fcf74fa1736e9fc02a2eebddbee355697088328f21ebe9d691438b5e7b17ec0816e6e98a89ac73ac2b74c41f1d24c00056efffaa94d2215594841a46c4ecf16d9e772a1a0b0ca414c7c78b4052950189d794b50e7a6ddf4fe49f66d73483ca8726d6f0575d344a13db68a5ca47ad65ade089883baed66d79676d4e9c3c11f963f87018917fe02700281e9b5d3cb861088cfed587d84ea2e105ea3832e29bff626290973b718b61425640be0994a074231d1a6ac2c76828f447572c2b304329e39d34d62391b0071c48ae0ce8bfbe194ce717fda45fc9bd7834f9eed16288f16897f0c7d0d0815420094a86028aa586f5e6c657ae006721f25fc0ebf981bfc3488f89d664c15073f74a467bfb607e61f691336e9c92eac1c4d1abafe5cdb27dcca4ef46ed70811447394afbee421e374d3b8d8b01897f6d65ac14cbfa8bb48eaa88cc9fa79e8deecc02745c398755a2e7c2c02fa643e1d54cb5b2d1ec8cc33d0d5028dfaf106e02a51c37932a96a45dbb6923af2f2465a23197e0deb104beb551081b80f37beab1cef355f3b7663d9d7fcd4a46014405c316a7db81986bfae9a180af61b8cac6be515e249f0bc6981d8e24ab295c11a25f4f45a607c4a88e9ac80ad4680f20a95121a31eef1e34ce35cb38b2a7f11803e38fd6483dab4ac2e143f26f99d6da6151cf09cb1d69529728e56c5610e4f79e2dfb0e6617d98d8831850f774b3d5f96566551adb4597306d3c70dd56012255cea2a1a5c400893108c4f37c375147138374e49c61801d82a35ae404a3dcf526b4a56b2fb40362f917925bcd017c39a2313217db9cb5314f11ac960615a0a1241bf386781dba3095be0f8a6cb84cfaac09b59563e3a9f4b922fead5b3afff497da35372e06bf5123078255a276781feec8c2761868e0b95caed3067ea4dec8d2d8445c4e56997ac4ffb462fb9c5613df92d780007edaf87efcd8dc541799384652680b329f5935c7023ed5e31edc37f687ebfd8571063fbf09991c678d3c1c196d2e98245a7e2aa4783e2391c39562c0648e8c41aa70ec7f59b3e464b6bd43a3fcf5602b606e693ffd8fafd44e07e64d756cac4ab8a4f9704fbf678ee28145ea997a1716f89d396587aaf1acf0427f89941abfc94d5f120dd15ec3f3fbfd9fd9aa97eb5c788a7a99a7389ff25a3e35ff20ceb3fd7aaa93024cba7aeb6150ed9a329271780a0b3def9e1dc53f319d8366f5e53f85346fe70baacb3643732d012df311f026210b2ca2efd3a44a9d27c94e81f5f284b650473aa8a47222cd266980ad30f05f4f3f174095685d89ad0ff12086cf3ce8b1c843f7a35291ded8d9bce1c20d8c813deebc4f9581b0fc28b1662c9757c927f94a58a0d9913d8ad51d06320f4efd4d132ef0af06b510367b2796495f24aa2ed1bc83b3a519be70a5b767bc86613f42d88c4da50acaabcc90ee26e348b9f90c3a62772c18eb2a473070b0375d89b7298febc2d458689bbb6911f89133d2f1473ded1495696e4154fef1804847241eaadcc31dcfdb19f948363a7c95c322b41f5ca81542de638e18f79b9465bd74da23df50f6325aa3b1b9602593e8632dfad02adeb029d8887b279664c9893fb437f6e35e863acb70ef7045378e14b2a3827f613872a54c6587049155e81d3cbf4aa318ce2c6a60c15362e4af0c5cacb59f236e271d7f9829569c8c00697c37ff1ca0dc27450fce6d18d64ed1ebcb1631ebcc077608eae7ca53b5db2f04e94fcfa027920905eff708b443b1ad940d56d99457daa8c7ca4205650a743c6cc1e2e0080a5046fd269436b71c54b8073141d072985b2632b99b91732b39634eafb554c62cfc0730bb8beb01183f3e078a5d89d49d2ab5d807dc6499ef753dab40defff4d8a44987bd753dd090df76f941b97c90611e83c4f087e5df007497c7b5eec3931b812454fd0113f720e789feab6fe7ad4425c7ef86be066ebaf6c02e4ae26a3cce48aa9cd2202ff39a594fdb7cc9753f3a9e85a7ea5e56298e3bba0e7f600768fe8479cea7e7e9e0482db91d645055fc5ab8ca9612bd81c94b9e46f0aa9cba5abdaab5625ce67d69b2f8de5938b49f0116b89cb95d66a3c0261516a7339ae8044f966aa1af5030f23fd7c49de47f8145f1f49c3cf02f1e96bd46646c56eb0bde8966b0fabed162f0aa90325c6bd4251a7f76fcd8caac144eb66d868357d6c5400df934fe528aea0ed3df19e27a1e06fd0bca373469b8d538eba90cce7f1c6457adc7d94b63a38a8efc5d40fcc0edbb6c0b486dbb59e3960ce7341b489f2ab7929b3e644e4bdb01e5858c66508b9a195cfbdee9e4c920b131d3e6fb24517f24c30315c902795d1b51852a78e992a3e81d305cf618cdf1453d750f55c54c56bf7d113728872aa846590ccd6ad4957e98e4f09074124354b7f8ed864eb498acb91da6b456e4501f682595ab9bc673654fe007d82bce945d5fdbda133cc4a60eafc5b8d8f676a97b41ef97db86d4fc1de6b4ab0b50522d579d2114457d44168378e9778b77b4b573c997719c8991ff4a9a2a94aa17b6cf6f092b4619905b3fbfeb080c9d02158819f44b59a1b37fa0778b617853102cdb9a7678a0c5978c1ef0121d145e625fd709b0b4bdc5f96a61f3237f2288bb103785b596971bdd7233fdb4dc822ecc3212a64168a5b2d0488e9c153a3c999528fc553072b9c27df39f38b0110639a54efd978539d4529842b1d479f451dd8a0e0ebecdf8f24aa3e85971c2f2e1951f222265c9b497488a71a777fd99d970d4f2f0833c73bae877924459910c9e06cb5cc273725d73ca239e5e7cf803d87d99d2cabd8ad4667436525ee13571cfdd05cef1eb9eb13eb08c4d3a7cdabe60c77697b95a2a5005667c45662b2b80702c7c516a63b152a0bc29af7cb195cd239519403b7db1a24d2035cfb9d497b82e0c54061bd109a4937090677ba03710dc358702d81bc09b13f62f1c5bc3510fc7184a33c02a2363e5e37a79da7a4ddba41b965d4eed213ad192d1720fba27a86abada6924a297123a3e0c1e96139e10e4df002523509e0756fb2793079cf2b92f173410d7b457a612f479fb471e8f36384fba5a267b503dac4a9307ba3ef68f484fd4dec1693d7e324531b8d0e2448ad8e588733db9de9462c0b10e156662c6eef94ad41e5f1314b325069f937f6c02a5eb3c2fe0f61c3f246b29f957de81ea485807649883abce5b63e9e16ea89aefc8dcb17383bd16897371c47f9fd72fff49a9d90a1a9e7fb13eb460f7ed60a9e272956fb2ed8bc3572018daa23fb4ee9d8de3f0b0679b7528f0187b713d34817e574d1d93b3596820130e5a515ff8ee33356bb914e4c45f4bfe5daed345ab7aaefbc4f2004b381c6fd98bf225cf27d853473ff59770ccc729267c48732db576033af92522118fec78fe908db1699cfeb0e6a2b5167c6d5db26847f586b816e1e4c4868bfb96e9671acd9fe9d279fe76ffe1db6a12d16c8cb6b8b18b9d23ca919ec3dc0d0a2919adf45078368a36db231754a4c54d1f63df2f636f00432f119fcc67085463d47e8719297dd670038fbafee0c539cf6951b763037b88159b8e4be69deb697a9056f2a0135b73ef254797e894e0bd86992928be1fb8763a8a5489e16049d084207e1c8a679759b750b72eeb8c8c23a895d982ee9ca83c79880c9fad5c60eec4981dfb478cdad44bd4bdc3c25d70111faa47cb90f371f54263e7dfa6fca5f383edeb0cc3b38a627f46934166bd5113708a93dfc48940c19b7a61056a63ead0c98404a4acb7f1302b987d838b752fc9ca02d02f0cf2c0a9b70205e0089d998ac93f8365d6b56302e9b9cf6f9e6afd89f8034f56cdbe37464511a5a2904a18f0cd8fd20039dac8b83e7a42babedb9555eda145f4b5e8d1bb61fdc51a0d2313c8b0abb677c3e449966877bfbd101ce50c1754a7b19bbb896d114cb211630908db0fecfbfd664709298ff33525c5067e546fb5ccb52f193c01e701b4511b063527d334f48101e133007e5355b9e46b1ceedf8d7ab43fd4c34d40d1faa7fa50e15cd51fcfd00f8be0b2324088867f38186c16325cbc383d4ee5fa8b5028861498f9140033e34e7b1585201ec1558516db8c99146abe3dcaf9ec64c982fcb62929a0c530aa67abecaafcd8c2b2173f6fc268f9b3c6f5ff3a9c1aa8afe7f7123ae5053953d307927a37c0cf31d4e2f6a60a7e372c78f5968909a78b2c4aab86a6decfc36d2c9d17e88262bcae8386b55f7acf6acb43a9e81f17293bc0f36d7c215727c6a13f76aede5d091392bdb198d0f40a4de0e9ca6bbb5e913bd94840399dc980f4f84ba78f476c4775e71d4ea3843af3fe2f0f58a2c54f731669613cca8dc6e829017c968fbda0db9b3fc6a4010134dce88e0b946dc82202ecce058eb2a64fea2868755fe2eef26e5bd326ec542700efa86c17312de4b2a46faff63498451e76ab385feb1e48b29883de5265c49dfa50b69f8020c087b795e295182976af74390ffd64f4db062adaea8bac22f73e669b44ba4969377977d5e32b2d5bdc293d73c1b0d58c7e37ae6bc27948fb7634225b4cc07de75c0ccbcee7c89622825735b1d4387b4846c2cb02a3689d5800b6e505b9c47bbb1e556fc239db68d5ae7ccaf5bdcc8373582759716db33b9d543d43e5826f41e70c28702204dee014d03ab55816e9732139bee9690ca0ac76278fac3bd2c0ca0ea8fb94f67eccfe1314746df3bf68241986faa89a0c3de058a1cf2cb8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
