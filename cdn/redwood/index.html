<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5f3672f415bb699bf86aad18b3247bd507fe4201b6571c5f8334e1ed1439d37584792f843d35bdd4e3f50d0dcd883800650b53da26ed70d61736fe7ca25b7ee0b8df7ead339df90356fe8b6439d3fea1932dec75114cc49ce28329ce7ebe4d6a561c613b4f669dbb2148e518fc58ed8c48af4007211d63ca9ad4977792b97aa692ce38850260ce7fef9681572eb46ed2bb80575a2a13e2a56bd25d61b82924a2fba1b2a2144ac8454d3a578293e4a77afb54ad413a2b2608e41f2ee7d8f9fe7ed700d77c093a9401b6177f4fc7d6c40dd09026728253fe9eac0859a4dda2972e7c794a2ad93b0884e4dbb2a185c0b1bfbb97bce09c7b18b0cb66f007ba25563823502c4d5301510c32bf3c01dd2990176a285d3878cfadf5a608931983fb7d1f1782cad505123a0eeda45a505d87962dce9299540ae9ea4d7dece4a2cb54bba03bff569ea9dd06210cf50b0503c2342cdd728dae25cb620fd86154def37611be326da1a72c3d2393eb43ff725ab76692e6da77bca75f421a22daa665234c6950db69216cfb26d3acd4ef1316c4442c857e182cd24b70516fd3ed2e15aacf732fe56744da9b0c57594d18ebe5b3c4d85dd065d1d311c4502e5bffd07a791ca520a57fb6954f63a2b8f27e477d7d7daf0dc3667326ae45ede55629d59275234ac2c977cae35273a2111818e4c61006b63eed8027483ec95d6ecede46aa2733eea0ae6da7ac7bd81cc5e89bb108ce66f20d6193feccf155e7cfd149f29eef86e883c116826c9ee471d094ad2749959eb812252185f2c1d9f54e687f08d64654bcd7a6a75f62bc3748fb9d9a3bb67d0af8f191a0def46a302f0b8a26b9e298bea3b6c4df8147d42fa90b9c36cca704abbe00c299f943ec703ace8fdcb991deedf74f165a52013b30425cb3fa0ed9062ecfcafcc7efff9bd8c3ba618291f0989e64130063ec4910c1b9626ed8a4155519107c2ab3b2f6ad822cd655390e730abd408a0593f98845601fb694f4a8dcc4345c2b0af727ee6ed30f0b07727b2d1eafccd202ab76ac93fd8db3266a5108a9804ab6e04097dfe65a473f244630d052ad81df9171202b16b35fbe19a4eefdc79d170a7c5020c81aefa23b3cecf4a64c94e9d3117338bfedc5e6104755a104d293527c329b5f340a3682cc028c83fc5231bbce84dd1357410b56cf470b0b5f199d2d5aa2f57ec84dbae2cd46fce7008d2a072d852765df11708c0945892a4d02478a9011b95e0c2bd4b7ef75404bc94924767e4ee15e00956e942c703c8437a11a3758b6ea9510e28d252c21510e0118aa0735cf5b651e58afa802e79e4c60f61079078872ad9228cfde6a4f96f489db8217de9667d7d75eb11c529a6281d678d6af8a242f66f27847a9cc60c5bbf042755c73070afb139623137c755c3088f717625a63002a632d8a52759a0db7561fa05311ec95599839e5e99edf596db265dad605c67b1524bb74760909ce27fa2bd37541b2c9518dadee7f0371268a9db5fb9af52c7b3f07f516f6c02f9999d6e5d1607f00195c0708f6f6067a3e1df006fb84b83a405ef50529b0803542c7150fed21337ce29890b9a4a19c703476abfba213b921493c13d621d059bc15bbe9fbc3d3a3883241812e547b9a169b61521dde0294bf3f62f4507b4b64d4bf249bec4dc041de914dbe672d721d284b2de51c2259c5d9a51a9f46e358a58bd98b241e67f17d84336bcec5426ddde1f6d327e8d9645b898756c9c259f5b6e8738f6d031cc9340bedd8280f3afdb0db11bfc0314c0a17ae96fb985382572dc5cc5899a67075ff71bf65e1c921823b7cdb84718eb60569364547e00d867fef649a276eb20974d4e8ebfadba9fc4fdb295bc6a6b66030dce11b0ab5da09b8e4c0a6ed0ec666d443971bed1b6643e05a4161b30f8d074d71935269eccab36d0cf1afa54a12eeec465540c5915bb339b2ee7c091dce8924c0ef583e98b258fed7824492c4f11d40e348f2d0791b213a1e349acbe00d7715fccafd1715ff115880ea7f3a168b72407c118d03292e3f728234f4444a78c1f7f141253f5bb45be341a973b939b71c63973e2816911b0fed30720514f22ef82ee0996691ae20a4cd8c4fc13d4030fb20108cd980d5cb54a8c098a9cc761ac82996b17229150b4413c891590db24eb4e09b580669ff58ccbfe4e9352dfde8b44e202202ece33182767eb90234b647ad2f2921ee1fffea642c6720b15138bdfa37fc890d0821a8b43efdb90066ef86a7b63392c53f23e85df9d5f5ed28793ec541cfa097847833185f9ffa1402e1179581f77b51877b0f93323c975812be12e63adcb5497e3d51f7d8e7c67e22c86c6d84453f42f2e10f6ead536e142f93a26408aa5a8f771c77ea843d5a720c16ca9132a99acf39a00aae021bb3c5890f3797ba2c77e432fcf130157f1c5092ce249868420d6bbaa850cf01557c8242c686497b5bd52af6133475833b8f615b9be4261b68c4c98ce607c609e253420a2cf443f3b78e4751e9d3355c091a19acc423e4cddc17d3b57278d360ee3482024d7bb03c76b50ddc61c3163f8ab33287da9d380fff43122bc91895cddcbd2adfcf5994318d403498a37208a3e1947e4ff2cd93d2fbc140f356a152fee471164347ca8fae374dede996deb6c1867f1cfbafe4351a9442b9e4c5348507b16317979460b2286da1b53da4b6bcc25ca864216bed3419a2254679a341f31680bff21d9cb6d318bc87d14e3edba3ddc38ffe7b226e5af12c299bc9494811bbc4042f6a41507eb0734a9e05fc67ff4bbd213ae8d61dbed42d7514c147cd76aaaf95a7b6ff318c9637f3783e46e820ac63535084d6345a4dc4644f9967e24576c57d78a8e2c147581a7bb452e850ebb8e97deefb8539a3dcc9781eff47665c975a5056b0bfd0dc9dcbaa5131fcc2e53be0386abe7fbbc7074fa2cc4ee7102515fb082ed5d00ff9c4054f9e335c261f07fae6d5f707c322af7d985fa3d528e0905df80e088f4186f39f3748d6caa7e56f0486b9804df9d4e9c6535d546c068cfb1366047b830413b63f886ddaf0f454a8d59a3c32c493ae0c4323e0db100771c4496ba9c8c5e146183356dcff639ff768bd97d5fb363cc53ec775270f4af0be19789f121f3fef2c18408d1c4b2297ce214d2cf28cefd95c65fb819654bad0c629cbf47f25e6bcdefd4be6538ad919e02c58c7cfe44330623387fcca8e8fde7859ad4f4713f101d76c322950f08ceb948c7fed916e1247675f61943cb7b46b8335dbcc8fba1225e98e20f5f16af82512a886b4698c31bfce655be6ab32f098ba0ac650d6c0f4a5822fc4f3fd43b733e78ce0fb30ca77760fab5c4f7519d43f9c3215124565e820b2bb4054da85e9a05aa13eb6407f277eb1ed75f74b3fdcc63ad631476d86a6aad114cf1dbd21dc4262ebb97e157acd6cbc5c9b749663829fe239cfeee9e0f873363c52259d1193b24cc71ab998eeea33e9d3251aa5f588a29e77c0da0babfe361072d37ce00fba0a49e5978b1fb2d6de2943a53362d9f417b15e44a390ff050e0a1077ddab0025a53bb22ac90c6205ae6d828108d760c39f0a3ee0204254cf0c7498256a80ecfa3d8376e0ad390132d64f422595f79e099df64481ddbd4ddc0673b586981449dbb06eb3be8aa9fceb75ed6cce12c7753bc9a2fa087fbf2e0c67c52d84d8b77736e1d1a1fafdea0b8acc3a9ea336d5d8f5460bcf8c00e3ff20a3c8bc55e8686fe89c62519b904509be0e84fba943f337791d3702365c8f7f78e225d9307709f1208f30e0b1929d62ffee80a94ed8c479e69345650681e85e1f65801260ce45f0ac33bdd0f9b285954aa7c569d117d0b2422d78fdaa8eb673d7d346e4959168be17688b208cdf5581d0cce7acb80c4c2f0d8a7da2005b9dac36f6bdad8ed035eb96905c290385c8a50a5f9d5fe2ca4c461dc8620fc43a5451b93f58d99c760857d48b238c731ebf2aa43b9b95e17859f08866c231882b087f7e88d1118d1f883d60f6f49717c4cd21932d58ea2c581dd71221f5e0893aef3b578d87eaa43ade00dd56e43a714a1d1166985732b81ccb52f88c6dbf1d255cf19cb96a758301318494e33f25949984ef983e17a92662e0f123a766581b340c3748934f3a85123c5e576c70dfd3c0681bef49b443264144ddbf106699c5ae0d0354e6251c003ce286f1ac3581f5fb59b07e1f51d7fed0a5db5f4ab584c54b85e1e6ace43e08bee8f883a3fe89ef3c40775eb71d01174497579cea6a435630cf9a15abe99f9f12a451a44f6cfbe84fdf04b92382858801477873b117aa4ec2871ad767a31f017521f97300c8f5102ddf8ec7ebe5dd298de2819415105e8d403431e5ec8ac2e7c389715506664b693e6161ca51cdc81523a4060bfbb4f7d3e6d7fcd948681d7a4e3f483217e7899d38209376e9b03e59c82f88b4eaef74b11a2d64704cb03cf42fe3f05999da410ec4e31127967a271abbd205db65610a6edf6c49f9d81e57e4574dfe7043d95a5ebc4e34c6751340083e843efe374388db788c4b6045f221a9370ae32c9c71490b14d5e88aa977630d451d16f4ae2b8a0ab52c3c2e90e070ef25201252951d754bc142abd21d726b7f25c7b44b6a918092f01e366fee77962a43ae01ceb213ba3d07e050c436e66340ba625900aab8fa2f267e94ab9343257f77cff36ca3bff461b3427edfd56842252b1ba2582e953a6f21adf8575130e464ba1a39ff7edca7420b8c1ec859c5fbbf18a92ad7f4d1314f1e36b9e24091b2a33cc0f39a7315ddf9796ac32f80d135ef578942ae88577c539a47c8a41226b6ffeb1b2fd18fd7fb100a23045459c0e5634e281df3f1b12d1641472e7f74f36eeb6defbd0f22cd198b816b142ec8fc9441bb5b512d46b6afe5569cb395da462f77c2d9338792af950dfcc8a0b310459b38b214722d760222c705446292cedea9a618306ff30f9843cc946668f40046f225fff1980d1932a771749298c5ac46fe24aa6a62c8466cbb2607c2030ce07b49a39249fa98b49fc9596d0b75465f5173553d0e9b368b80a5c036745606eba8f43b9d596b8897169a3344623b79a1933bdd909993097b1dee5fea0953ca3f73cf86fb94f0b767bd5cf830da35f80b54537b3182358f8aa9ecfc43e03b568768a97c6d0748ee3f5619a811e5b9dacdb1aaf61416331bd76d5b6d8b8b756cd2555c7e88529b0122fd92b59d35db52d75a719c18ff76d6f57e4fb748c15b8325945e0ad58e7e762a47876ef2e29f0e1ff3ae264af16638036c111d9cbbf6a26e0315766734c63ff79c8188e36f43a05824dd32b8bf845a5ecfa9d23ad3e1c618185e4c5a7dddaa9925c93756f12f900beac408651d5669efd96334e89f94d3a5daaa3f21f0c5b243f61b3b3946da8fa5cc3d121113785a9a948f090eea8f5f8bb65a76b07d8bbdb20034eb043a652493f76141779f31b59c05aae4f30798e48d5b87b273c4ba7f7e5809c3b6af6ac49d3f94c27a38bc9a5af09b430623ecf6955012d660fa5407c64bf215115b5a6809dade56bb2b4a302a93b09a793a302b4b4cca9dc5d20b51583df8a5b1937ed9fd7bbc5b6726d441ef71229adf4f4fbdf86f8869585ccba7327ef12b100da7fe8a74bc843b319f6b8c48ab233f34a964b09cc5b4b6e75f211b84a5eb887ecd9d7a6711f58d85ef2d23118c7af81339a322399c46dc6a750c1f4d8d4417d47096e3b9b3d59a91104d5e1f43be1007499902877c6861aecd8deb44164d3840cb26c9066b2d7e27d58b3020aacf0061ad41c91b59ab21163ba6f9b7cc1af0505c43026078241a80ba1589c8eddf66eb614629b6a07d97015dc11d8f02f6b1cb406fb040eadecfa8d4ebd456a809e04a989850dda6ddbda22d44e5d3786f1562077f5bc8546f89ab21c4114fe45a47d5da215eaa3fc697910766ad77838119ceb5299c36e71254f559027fbbf6bc0e8b0803e6476975c532297c14764bdc0811dedcfe55985d7f15666627fd28beb898efe3a22dc219d5d215c3f4ae8db16a566bca5f8fd40ba5540171964e01c9280ac65fccc4aae6bf3da5b80da16b26b128229681932914bd553fe206e86e14558631f93a89c36e5128809860b83a0515062f876c8c2a3f3b414b5ebe7b194c345164dfa367765b219efd3d97b1649906ec61b04fda381c40795b8edb90e3a7e8033ede3479d0cfbe3c0978821c79f1e74dbb0d1507842b09c9de0f25600172c8a7a45faae528fb9f5aa5019cd1c3f44c0692a0eb765a0bda01249e16f0c2a5fa94eff1c6999873cfe138754ef94be589629be1969c62cc09c50dd34b0777352dda1dfe4662c3c838ba81379b84ed47e5313ff1d7b205366107894b7207ebcc13fcf7b717799ae0e7ccd7ea6dfb2e9af2667c0799c8e67d0de74f8630fb766a66d28bb9ff11d67b55693524d74edf657d582f9fc4b5630424a6eb0503abdcbc21096ed6a370f3b63bdc0febabcbc39eb29f65ce46cb70965ec411ec72e069fcfd439570f1fb3f8e2629378d054f1ce9f9ed724cdb3bfafe0c8cb80f8c7c91b3a65edd7639c7c2cba2982779f886033a9755d6899fe036ee8a39db86ba94cfc78c8bfc1c9b47d4a927360503a195f037ab9fd0d67ef984c937352bd7854dc8c32d326456b106cd4cef910b1dff0245785461ac4b129712f8084920620c633a2a081adbc3a2a38143019bd76057361f43e05835722d289c0490f1c0a05b1fd89e35a281fc837c3d035786de3c2be70c038b6a39863c4e5cb598ecea723634ab197d337207818654b365c7568afc2906b62582009070ea02edbb46e754a9e3b27df152aa8f5e22700dc3d9b77d3e8d3766e830a3f5f1ee3b02aabcf6437abdd11844cd22abc2e78681429617e4d901f1a084484c524317cab3e0dbdc1df3e985837e612ebe0c132430a09e65c93f108502b01cb9af5a914d79b764ac1d5bc45767d7024235e411b2de441e7d4ddf514f63a21d764a5a58aad92a8eb6f6f16d4c443d2690fc6d900cb7a68fbceb519ff8bd3aca6f479c78f157c91fe14164189d228773caf5ed5a0eadc2230c344a72ecd61656f35cea66fc64b17a625700000973f000f5fbf5008311ccd71b878e572785d5209d86bef6d1baca07430b479602dc11af9c0217f92138866a1a42e4352639b30a5048a168ee75b9c89a74fd4ed8c60b0a7caec73cd658b92c02181fa182d6be5c6b5daa50d91e1b01830486a7feaacbcf1b655def51d261d518bf188d39761eda48b027f6d7528c2f894b9a2cbf061ee8cabcfe3f060e90c9ee1b061e2de83edcfac4ebaa56deb19e3ac47dcfde1021c61f36feabc0a161774fcd059385c588c4ea95b453390e8af5b69d23318f0c080cc797942b930cb3427d82d05f3ff038d42fa76c94f2041cfb97015681a7e72d5af0c17ceb8c8d0ae437a72fee24dc183213e752c46d97d8414a777f7e899042297e9b7bfc2c7aabebaa2e8d1df36cbe707329eb627a9b978e17647aba13b50dbcfd371809235980e0e12a42b9455aa4044551007a22b0b1875b5ec0fc24c91075501b845c205f5b61e76c9ecf65cd3a76d1ef68a5a63f5451c252334f6d92fc1f6eab0c9f2c1a5fec781f27e83e4ff88c4971332ea95244d473505ab1ec937a337c46269a8b47a31ef33232e825aabcafab24f4086b04eeadcd0d78b942a575674b7aaaf5e272c7393347088909630721ae0f2753e792cbb5fa80b181f45b161fe2f526a72dfd7b30c4343046babf7905b248fa63e4a2d148894791e9e1d139993e21d5cef9a14cb0ce0110be20db2b05edecd13fe6d42fec5a86dd5bd715a23aeb318ce3c6d51563b1453b0d1c388ea5a1f2830c1e9b9635ed88b24dab524591f78defa55b8342e9a92bf1fce94d54ca8f13d42e044b332a16e9a61f7602cc9953b967016997bbc53ddb66ffd7fc4fd75804dff9e393cb427861270fd06814e471b0b5ad49356235359c6414e4cc09205a6ff556a7d900424af921356bd55ec28def0bb4f187abd77fa41d2b76a3d24811a3bc803f759833d4df22ea9eb61d5e318c6f0a2d465ade71a4c4eac4bf4aef5aacc7127c304db29114e62fef42d7cd77bedefd4976d6d17be7ffe4fb526cb9df4a4559cbeee38f95d1ba4c622470855690cb53d8504c29bbcca37bcc50af0c6537e8cd9e6d3f7845c2725bf3130f741412e7c6d2527e09826e180962bfa002b2084a341752189909f437174313c9018d90ff8b089098109a35d87877daec11b1ec4d27f4199b3ff0b54bedafd1d8b9b5a669250e3dbc8ac3e75c9c1870f29d9eb79ae9ca4d90daf361b780c6270b598d5ee41670e91e06418f5103ddecb9b1e2ee6b3481854f0190dd0f8fadb19e7f58142d5faf5c31e767bc93508a6e8071001d78e6b0017b4d6b244ac5a4c9c99ad04b4c0c32f8992532d1d88c64aa99608f2ff4816785ba84a3ffe9751a046b128f508bc9c517b410f4c5693a3c01fd3666bcdb35192f087e1bc325ad1a9f0f0902becf2c73d49a675796e9179bdcca4d6351a1ecd93114a91fe9b1ef988810d23501aba4b088f9ff729962bdde4a7f095c6165ccfffc2f725f837e7ad79018e7386402c07322d27a138c7964035e907ed368a695f592e50c2f31fdb6e4d06744d8ce303386bf7c42213e84d3217ea53e71d55cf206f9cd56e76913c05b5fae047bf030f77a78f68b713cd476c00769547e57720b9ce804825d870f9e5603bcd6c88e76ffe784f91b21dabb02833b7ead3badcd9d4aedf597053cb5edec362e1a5878ef83266a93342400a3934c4c2a7b55f8816b2cb2aa2c37daa2a7193560e683423002a349f35a589a938a9b980b430aaac4e8e5da21623b382f49b12809409cff88c3506534e4f2f813ade2500b3960dba29325f232d105a05af916cd1991b906371c48966829162bdda6e0c4e4b4ff87072b2b7490e40c172fdc3a4a2d417b466876003accd4deb003b74d2f0c76722df0181254f4d49bcb8449d30d276d7961f6e2bbac70e8529347ceb6e24d9b3afbaa6090e9234b4faaf4a1ac1a16212b4ee3376f2763f78a87df77a03b061eb1388d87b2da1df409d5fbda0e1fef2a31f367fd56cc8a28bd628487cf3812cd46a7514704c68d4337afd3f26d90a3189becfab66df157696792640902c7337e3f372349c76623707e88f32b82dd8b20f23c642bc42167978b2b167e9a85041bdce04ff62dd82c3c5a5b56146b9a36f2403d92f664f8b3cbae300c0235bc647be67af3413d8da15584a9d197fba9ffbeba2999ab2541cbdbe4d894ac026e82a7fa888c42655e56bdbe094b74e2d18fc37e5f382ab31ac48be4d3e397aec956facaddcf8ff8a4b54a431dc39b0ae7d09fb5d54da9943b51f8cc6d2f431946d5c9b7d677e400684dc012f647964f3d13d02be45cfae55fd5ec2959c15a6bcf56eba370e57b27d9406fabe8e0166998d76367a206d3d6ddd37636f68e4c922094432f4c06624457737a3cc722db38b758a5396a0dc97bcbbe7601834a7173d1646000e348c3ca005b24937445a31ca1361efaeb935a6cc9717cbe85ed362004b1450b9c96a9ef7b6a8bafbcd93f974cbc87d784142912197040fa1c57d9273b9472ac5677aa0285edef5fc14563627ae403292128c0f38afd29b3931f5c9b5dff06e8d4cc33d0f81a5286510e7e54a14cb2d33a08c885caa3812281055ff0d4e5030d09fe24d87b2b03451faebf59fb9d87740fe22ada68b6ae75950a74d885045817054e2fbfd25101e01aaf928d3a2672f0ea21dd59f146dafcba7ffdac89c17ff090d51a7962c976866f4f740f32a07b5932aa19343e3654114d524f9487f4ca9e89981e43ec4c56aaab8d7ca520e8d9fb2a69e75a1b3af5bab883fa2d7d0c0e42473338d67e603928098b000a29f7bfc3468c5be889534eb29e1d06f9902489ead779465eb62f2cb9782b31a8abc2940c8f6a1911844de0498e9964c7a1728cca3a9c3f398938ab5d49c4a66684cec5795df6355a8147b758db8187894c78ca0ca60772315b8bbf327eaff68ebaa5a8c60f5c238ad8e40d62330f82cf7f13afac0798c34f27b024829569cbc7ad12b2c4dc853c11d1b120afa1da2c53ef01f0f1ad0f35c76aa09e9506a4f97b2f0996938eccbc5e79f5fe0e014c646ccc001ad6eb4880a2522f5567b552c8f0fb895c2b8898b9ec90c51a4791cb393f6f48e8d07f98548a664c4e21a09efa80a7feb0085aae4ff60231ae966e1f6dde1931f3f6fb8ceea245781c619e61ea851db2e01160fae40fb4d3cc57692f99a89e2d935d15367ce68073171f007ced7c7e578cb839c59c5c8205d5a49783211e930e1100a2c19e27365090e0b6292aa8f3a64d82471d425b47b5a9dbd04444d424249a9a974ef23b849c0a65923a75f069eb265505016e0ece9d12d5530aea4449f547fa3df91dce78428da5789511959291d24be0182d3bb5d2770b042337d692e3f437ef17b225c61a22b2261becea516b8c8078b94f53dd33c302e410db8737acb89cc8c74ee8e320804c76c482a0f8eab4821e94931194add3349e33a6a27c10b3427439d37297d37c94a9e306f6374854e1099993d877ab5dcfe851832d742333fe199c60a84e63d1a5e15c1178ac019b64066932d5bf13537ebeca69f81dfb20035cde556309a076ece3ad78170e83b4ae9c42ca4c4aa774646f8e26c3c04b2677dfe4a4e2507e9009954ff5c13977f808a037ebc3c31f252d5923f93440cde6b79d9cdaec36068b1ae12cfa677860b6c6fae607a62c05a21a05d9c991613d4c1b49f418c80763bc3101a358af143e31b56584c3c0736081b0edd452e1f9e4abe96ea99638784adc284359d9d0e89d05869b145e6a9767a8d87a00009793675f1f6d6bb7ad3dd160953cb9ab1fd3375d2f580687caeafb525f4b66b8298a21770d8c64346f619ab88df6b84caf7271e17094f870abb6c96faaa4214beb8f8e5e242bbac903ebeedf94ee12469b6e6b84f917e67ffb884890c91d66e0b45ba65908c15dd68fd0a6ffaf5d786bdf55ea0e7f42b8abd15237074ea6dc8802231aedcffdec68b742d8b91a3f919066bb1aeabe8eb780674aa34cd4f7dd60c2a6f00dfc4f3ffa3b8410f6a092efca8bb08d04528928602e2cfdffc3982640331335dde02e211d7f0e1002d72e02775c7c3c8d81f04de3c77650728345800d4ee5c29c3a3ea93741767b57834e04de05362f538eaa932ae2700be5e384f786e338eb98b40fa214af21913ad51a21fad772c13a6b1283d3f63e87d096d88fb64be0aff7b7995dd77628f48f76faf072e06ae7fc8db25c68ee71a4105803a79695c99371026b03c0beaf4b8c30a7448be95fe8c6191021f5c14fd0059e11bdb49dafad1e04eca9825b1432953cd458e761a6bde3ac66190a942f42cb103a57fd7fe94942327d17e82dc942ed35b4ae17dd2e23e70cc0009752db22eee3906f91be22b1d77a8271467d8653d28e59d6810716e3bc95674fdc3e8016f7c79a3b857ebbc964d43b8a13f4245ad7a419e95846a05f2d93c77fb54307d0776bf0dc24b6d5107e6b02657bf17c5c5af32394cea80d231b6c7c04deb905fd8a333e2c42765093c6b587a269137bc12ee23d3132533701d0b24c269b13dea8ab6373705a8d1c691a5ded738008198d98054f4241a1926c600d8e63164fffac2587e1ce1e587dabffdda2c31b3bc0eb0285b6b3450be1282f7dd292afaf0918c33b35e0365de4e18a55791bdf2eba92ce8fbf7354de57a022e7f3831eb57c67eef21bed7aae814fcf7184142049cfb21be7ea92a88bbb423b20da6dfd80b7b45b2368fb4adbd0a29ff8defbd0002dd59f3600ea066b21b158a16934154080623dac5903181a5753b81e9d41779ac08a9d7c2f59eccdf0301b640a83d19350b20d782a7a28160249a2cda1d1c4169a1bf08dc15d2743c70cbeccb03309bd75f8c5f3528381e703550a3528e1679fa8740639ba38bb8ecf94a1e18f2986d84b19809973572fd1cfb3f1e29f075665b63bd65c466b0c9a9a51b392b5db286224ec5a18c87a86e51040a47c8efa06c4fb86f27936f9f8a66e435c230130658fe401cad311fc133563a130cd6e198f6afe23b64a7b8d88b0df9ebba049d35e1db42d58082ba68d15fe3428ab9c48f7f4a90af4cfba51d07de285d0d17256981ea9865af1117aab322a983e8ccaee16d909ff67ccb22f771c579ddce636f943fa9a7af508f96ac120dbe2e2a31c8c8e6d77c306ec491b06335a42c4e13a64425ac07674ab5d6ccf0023c8d9bb469d6bc58cbe6e5618daa5fc63b56d3c6700aca52009705a9559550f608f1a8659f5d073c067eeef5f0275627aa09d314ef2f46647ca6a369c678a950b1e546f8f60727b6d73e753a4539c5d5d080d8ff3b86a9f5b87357707013036a23e8b50d2213c95cbc47c5dbc58dcc387a55da75763e7735b6a476d9a8e49067d3b21f2dcb822f277b1b0be31bfc1eec822aba57dd1f112d363ac77500f11e0e60f3580c697c9e6c97d2f16b74088fd77378d4439b95f901b61bf2883c44adb316591c184aa0fe5f9a6e5699beccccdc4310cb24e918db6a3e2dc7f1bb31151a16ddf9e99f3dfc7301cabfcb595acc9ca878b5fb1cd2ab080d063c3d47a70d92af55a43fcb16c897d80f78969528603257be6b528f752a0b842df0c0cf68a12ab76e60b07c8c61cf018ef23339da4132148543eb6e789238e7055704477ab5a2bc139faee5a179c2f5cd7e59a431b141f6c1bc5ab5d9eaf69b82f8d6a2aafadcc5e03478f63c6a551b24438708dc147802495795bd29087829f78b24c4c3df8cb25cb6c47a4d37609164968601f881ec2f44d801de305f57b1ef6ed828290d874fc038f8acbc6732e1856150305626cb6807810e331b9f085046a689ca5eaada836452047e3ab0dfecacfc777f2cd2091ade4b6140e70d741a0e488bfb1445b229055b46bdf8cacba6c24f84642ef42c83926071190673515c93ecd17f40eed670010fdbf095dc0ad6f02ece2064c81859d876f2fe684cb92770c79af05d62214fcc6897fad10f78af8a4cfa379f37df6754f6e6a053fc755e4480cd83e25047c6e262362fa68e628a5b29be09815b88251c4c4073de7028b7c8d37d9a56e448d27366763a2c2049aa928ee38601d5f37c5b42b6229d11af5f4ad7a26b91f373eca359f8b9c25ee7364484ef487a33f55f2625762f0b90354b3795a444446149bf4d6b11c22c3a928e4f18f93942a9dd839a2765b93303ce0b9902d141cd576a1d95b383eb8cd3cc066b94392fb8823cea395e97b46ff1bc6d2ab9d2b8aa75533cfec54ab842ca9e27f40970704eb74e4c92f28821d0e1566744f1f1066bb3f79c8e7588bb7ea8f12a8fdc3d05deed4f91f96a54c6958bd970752b1f6b47c95d4c3d62e5c5d120528daac91949869f9c0aa360b824bd914b39079a06e288cdd4257ce03c889aa6ba85c30d9cf1e788d96d6a299871c8136ddf493fe250bbc37c504d6d959daf5f6c40a5bf879fe03527da9d61c1ec04174cfed7158650529dc7a712fd805d21224d9e082690bb507ab7ef2e783c2fad62bf4197f6b96d3f1ed855299f7def3ca38ea90b63e472b34d7ba3652098b86c5f32dc3f18485e54735c3fe0732d629d882e29b99147ab48250c22de3abf57ca1bf889cdf7382e3a2eba51f489dba804699c2c101e69075e74bb3a949bfe052bd6eb459d3190e2e242c3da39186eaad19570ce087269dbe0cb5644a62051aae99726297a0327af8be36f87c63a89636b61e33ebc156365fe91b76df73959554f7fbeb609decf8a2281f6bc71800a7852bdcefe1b397d2c3182ed9d3b9e3d1f30da53d4eac858b42e9ffcc0ce6f2cc5279309550b234dcbb9cfbec8effc2c6dd539060ee031ab68cfcc7530f15957a1d5a42fb3e4ba3c45777f66615e9e59bac647c93502588e065304b9e248fa38bdd2818562273ed65ec878720528fc76d779c2298ed54b6328822cf578bca0e3bfb5a2f9e4ab57bb2e9d26555ee80151a255f9ada3b8577f26b4295131d85491fb30739a08d3c092d9dfd3eacb998e2d273e2083e026e84a33226e1d37386b0886d9b29e81938f26f75c6a37db072f19cf7ed9b55adae63cfae7a4cf1439fcdfafe77ee406461af7544d8001e77eb57a70294317985f9c434a3f73f12221282793116bc593f50946350da40bcc2162e7f034533d0ed65339b1e22fe5de2a309d22034a2d1c1d747df07ebda0ba834dc827750f125f0e3d93a1693cb84572efee2591d353ba53749c14f82d7801e1439418ec5fa397afd3eef2d656319c3e41242f55c2fa3daf5916eec2f7833028e0e909a6992eef0820279a0e3e081a82a70268fcfbfd37419888db8eb655cd24f29ddaa46c35cd4d70cffaa3c441e5dec663631ad55b1883275963097bba9bfee5fa00e1134c705fb887d2f5696233f3cf67c939bd3ea9af49ca2d8f3c93ad098800a17a1b7a664443549bed9f24381f8c9c3692dffb89be6399b3ca65dab3031e6b1f153444aea26251a082b80231ad7f910b0a19c684caa0649a106705b5e8ec902c3e9ec3efdce06f96c460ce60c758cfc6c2f6945cf295871609c1cffedd40f79e514d0f98fa44fb37c3d555a2e0b953acac08e79d53dc16c5789b1d55cdd99ab264871016eadfae93150d71f430e34dcc31d57b134337c1700c9d7fa14f35ba9c7479834371cc4640e8acf463f7120a950ba3cbc83bed0ae0326a50cbb7c883b455f90b4b4fc009cc0e53b6c47e1d78c419f5acfaadd30ba86c72e19dc7996fc20e6d042d4253797c8f9e76f445834c7ee9d51bd89e2eec07d2e0459c6d269ef56341afeb77275383c09657a38c400a579919e4472fea3e8951783673732c65e28b9eff494b008af88e7040fb3d43312d6cce542a5a8781a8c7d70484be3b3800582705473b9e625e3fb1a458cbb477f421b87bd0d4198c9c85b4c9869778337faf6f466b18617b9fb1010679722abb554f2301fab23d4ddafb3e10ba68d89fa05494da440fb7d5db6b0e1ae0d53932aae885dcf7ebbaaedb22dfbc3e17734b595eadf577cfe2b5e4802f1c831fa73262b9632a10c2a6cb93f248739f777437d4ac7e27d1efd9fa74a1ecafc1c8deea79b4f3423ebd435cbcafface6161a033700a95511196e63cd1e4b41521e4f808cb17dc90b2fb851ede3287166bbc5b608ae868746b48c80d413879f44f9c4b3a26af74368278162d4e0674e5c8f113fcf8d0ceffc70045816dabc9f13853daac89fcfe2cef464ee0a78d2a8b2a1c1f8ae56b4c534378ab025a01fb5a9e697f8815c7a8594a439f12ddd7f92ed7933566cb6d7bf3cdabf7ebb7797c55a162395f125813cd601991831cb0d05b50ced4f553923ccd567ba68df482b2984a6cddda5ba3b4b64cac2d19f0f1381f51148842b911e64d0a4b1bffe2a3a14c91ca335d686af36454137dacedd3d8c4d5686c792b3f0b881d1c470e8c956ed7fa5091c95453e97d9b977279094001bc2cee20a3c338aead77a025514bc2060f6834fb873c32d0d52754df1dbb6bcda95fe0f57a4489149e1de07bb235c0c98903d29f9ff293fa2f4ae1b5169d72f6a615e361f3e94e44c5ccf8950c872f8598a2ca8864fd8d520e7b79c842460980aa5695cec51563ffaa490303f6410dd144de8cf3172f9be4dea0260c635f5607f18c0549da5b18ffd6017cd82776cdeeb67720bc640c4d92b2fba67077630bde10960b82bf2de47daaa162605ef1ee2bf60b3875211f774d45aadd26d78f663f7334d0fdd2e55f65bfdcb8224b449702801ddd876adb2861b2ae36a39e126d72ebaeff027f46fa932a82e34f44ef05772de6eef3dbfe633671b1c6b45c2b2f436c979bbc70d0c5bc80fbaddfc68d5ddd8636098d475a58c8d3ce9daa3bee113023aa7ba53c043399b256bcf389624c421c5416f1c73e66aac0537125d038ed6b0833cf86855687be5fa70abac6de6c92ce86addfc57b990205b225bcbd3b51b9eb9b30781099d5140ec63312e4ddaebb342189a6f1d74e78d9093b4daa5f4b2521e9a5a967182da29192f18ec4bb63aa67d5c57801031c57195e0fa0bfbafb9c2d5bbdb39c5e280123ce161c4b227d679f9aeba19ef9c55d3dfc423fe092ae524d520bfe77a135d7da92751b0d2204e5ed8a592cfdba72a2999df511c0ef4b8330558eada4449835ad291e7b7715289d88f66628b0dfc349f377d60919c688f3a1de7e5cdb61d97d33776753139ec1decaf11bb2e1d9216ff3260528d74fe9dedd0673cc04b0ba63f0eea588cf1c11dbad3063644cd3452bf8e709582e890cc0460130ef13a4f60f23e9c126024be24481f52b3f069af1046c18e2b7e576949cd39822d6b6214b0ea5089d6c191fd4aeaebe6fd95b03a367a5b7bf42b1c2b837df85dd830046b7cc5732f18188cf0444af66be8a16315fa275d73100db1610c40781016d9f3335d7aeab5495f0c1c28918c0af57be1ed1efdd106b3bbe1cf085c05bd3b0d5be77a6a6ab528babacd62b88c05373d9f692d8df31cbe0f543e318a81aaa3205db1281a0354dcf9211877fcda06d33256612ea31b46fd22052e786b58c2b7d8becd59be9b017dc33f75c7d4395270366c66d8af246756af39b0077524a2e47eb9b2e9fb7bebd9018f15c674f74a837bc0faf60a9a1b1a0eadb88389c0f93564ae67b7b52e4f54aea9eb805315fab382ba97d888bec32f457c2d9fa9344f759388f424cbb4deeb37b8e298f162241ea466f6288d53acf2db64f9c11b959db92c3ee2fcfc4813e09db05447d6d9bd650f9d25900e0a15556fb895bf797f63a1f30fd555fd0ffcd829c713bce5aa24c0ed01578d74b77617f545bafac7010f3c7c2f1b06107203c9102e93ac58d78c194724f256f31963b97a5788181e3526c1058d58b2ad9e6085cc134f29d9cf8e16489585da338880b71b20d1cf6c0274e93cf4a1933222f91c98d4bbf747df5ba8745151dac669bca0aa23827ceae6b89b6c7c537a55adb06ce49b832e49d5e6126484290e4cd1408109ff4db36946e8965811525f626f5d9e2302e27a17fe48a96dab86da71c0a54bb56ab37ffe99647605c32bfb6ea15d61ba8323a0f896b0487b2cf63a1136ef65124696ed210d9622773a8344d2b25d8d1e3c78f9f9f1ec99de5e5b8d50250ac3da82dc6331049137cfa548576ba5c9f7af191978db8d9260be308b5dd730b33d4445a8e7045ec266ef65489668511db8149f34ba2fdef390c45f692e35960465efa970913f539a072e16fdd48c374ece51f78f9b42ac6973564ce091c0c89662671a052a60ccaaf1a9045ab3b0d5e2caec7b38298ebfeeee2f65184a9c51edfb8fe1cf5d3a496de0f275dc5cf87c2ce365fcfe3727a4b91261e6b1079c568b7a494d78246b2e9683cfc8078e70f15a11604431b844cbcaf3fde729cf0e4107d6c4da23b83633e17f0c540ea434f03d52e392de13baeb30d3cae0d107cd513c521dd269ee91ef9ef4980b59b3021fa7a07c2542ac8430b16292fe7e4f6aee6ecac3b9d583602547f4eeb73b42c490c177571a82ba1591a48715dfc95dadd6d3b269d93d9ec1ffd522f8af48eb156e3126aefbc27f98432a2a3807e850d1d59bff9b61294e43e6352dd0eb4986c9bffd9cbaa89278b9d402510679af8f9efe1e790221db81e52c5cece04ea8a2f22d260b3d4fb6e960a5cdfdf3025059c29974259d33d4dfb70c55513bc044bd34a8a80bf91dbdead89446df4b1bfa2b7d8cd0f6b86e3fc62d1424c6202f9a582126fca4322f999f44905e5baed57fc434d1591d0eff89fd3585e7f678f2697c223ec0610e777dc5a3998ad6ec9f46ceb9dce902381da9e357f8374cbba9c20b5863b52d551e54cab2addcc851642a6a16d0b69f20fbf25c329004ba9defc5ff978fca18ff246e8cd6516d462b56f9892502e8d4044f658afb8e644f3aed0d224ed42ef2c27a3bc9ee3c1ea91d812938f64ac106d6ce3336057a0b8d6b8d12345d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
