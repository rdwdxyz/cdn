<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf25fbd0c05f3ee387d2acc62c2ee2cb6226a15ec74baea73dbd69ff33c65f3cba7a54838cca65cfeb742bc9944d71fac8849a8a1f9a73fe5c62b90d56a4a8eebe5125404a0eeed1b9857d7d3fa2891839f5a73ef0f66cc85204dacd4e40b16223fd0a6577f3664de684572467d453d5a18e57bd0208563e24faa4720d1b903b255e409eb8aa64afc14ebb6d58eedf21f8e5dc65ffcb3cc98f7ec3cd77f336537258b9d165106f1df0cebdc81892b4e0b1e0e2bd0a14fbfe398771be6dd35e56451768e6ae4c90fcbf902463f7d0dfff2c072ddc237ae4345cd9b06a026cee1b2a74bcde65000f91c3a5c2e384d7dfa1733664f9ce4c270e98a419145b3fa88c2575825ea58ee1f331f30a883b1b08f08f4a3162fff48c58a8587fc1a9052d66a0aa5c535de69662664483714cec67389b3ea2a78e7ac8499bc1cd90db0169740a02e24bbd3644432843e172d9d68aa935b2c5e44a3c3a84699bc22f9b000dc358e68016536eb9c6eac5ef2d5ab1359f9d2d046dc24210e5c5013c0b7c6e091689f922d228a0f20b3aa7d9679e4a1b0d6ddb956886a32b510ec26b26c54c7769a56a85c25206dba5b576f8b5e2b5d13600dfff1e70d6c776e1fd1c0bd5dae05e81cb8bc9d9cbb75b24c0e42111d5521d83fd193bc1dfb8e9ebfa868932a259fabe93eaba15910d76e670a28d8920eeba3bab0deaee7b410f5484f634b4df9b020bf0f76180a24faf27e1549e093b754723e4f8f720114cb073c54dcdf9cbc385bccab846865d3b1d408770dfc0d79dd04c27a29181960f9fd26df5f238c098a0b9942de2a29f3def0e2c4b30318254038a24750d4e32d1138affe2f80f8aad2a62d7c56804f33e02b9e50c4d7d77848232ac73f9c0651ade9e2a36a71a6ae353c29495486154578bdc0ef6bb8b4b6c4cd696768bbb0cb179888dcf551594b6eda58697922643763629e6b7c423e85b2bb8a43f1e72cd87587a96f95885566face9454f773c0b42222cd203de47e09d3c5098e4bc65d48310130902de2a43ca0a38e9ccd360f7adb1036e182dadce8236454d3cb155f50e8c8d3163c9df8e98dbf8d5743e56c98e783d487d69ee9cbc78c073017e1789840de291dd7200edb20f8767899cf7abcaf178b0c8eeef76b3a824f7fc9e9be4cbac10834378610e27a7b90de20fd2595f230ebf4a3b34e4b48701761d8f270a66ecf96b91f19311d3398819a1eb0978cdc6c36aeb488b8ac80a7e9bfb4dd65ad87a3cf3784be3fd1420536c1937a6113a3df09f89ad0097bd425a4110754967138c918adbe197f01b32b2bb192167971fb37ba6a136bd349f6e3f5c103958ac031d0fa1a90355ca83703827ec86977a4dc58afc65a58053fc326f51238c49204ab4cf54156f982ce15cede74fbb92805ee577d5333a612cb94a6895d8613134d8e2de18aa8e3ea8416bf82adbbfe311294baca6a8f2fe1afd27eb90f08802c0e778f891ff2a99ec48e8e72e7c278576f8cdd5f30f3b3e2915235430521ee7385400f27c36468e3fa01c125cc08d447cd28e84b2e274a0938e232543f4607aa590f5fc240f52a6c24bdd67f03eadc2e6386523f466734690d8ea15428a8522377d304df3766e50104e39ad99a4c27a8091d9ee4334bc3e476403e867f29bd4d7eb029784eaaad508642daddf251c87475fc137a1e6ec1baea1633aac51f33db90d59853299b38dc34fcea9ba989a5a66d835f4c798f1220ae8819b6ccfee1524fd6b18e5d50510b79693291630433c8c400f315c6d2e95116ebcbd52d831f84ed9c615893e4da4e3b82a0c5b7de914420ac18eef843a576005994bb92063d6587578babfdfe7dc2d4d58b77e5f90532383fd59504640e4b988a5eaa8a6f55e676e5a2d369e6be36aaf93fdef9650aa0c8b92391b958217a6cf6f79724c8e0ff45d05cbac50a40f2312c2ede467f569d2fb90d293d3a0e9bd3506b3603c78a6158ff079ca4d1ecb0b528b2f9541c4f25a0795836a6325d94ad10bf719e738b58f7617b4dcea8465770467827a51030ac2b3bfa518a0db560ddf1406ca3354befd70ec7f0df80d637bed2eede92a3dbbc7f95bfe50aac04a7b81216c16dff2f2a21395fae85ff4857cf2e755cbc51ed5e342fad8e9c53302f0f32ce292a77198dd11a64d328baaef902d9ecd7949dca23454a4383bc4b828ce99fc9ba997f6b4a1bfc914042fefd5c3398931fb58ef0b6fc35f85dea08c2b502878178046aabd77b025062c6f6cf7cd07dfc584d2afbb16d2ab266f34bebf018fbb1daf61b38e82597ba6fdbf34d0f571523cf8018e7a88a17365e298b1e83ecfe592c8823df7221a850dbf8515a421ee494422bc000c4a58ac5ed195f18901563837c88ca72a7fbe5d28103eea1b28866a113e527e23d3edc93d0903866b51d8446895a91591b5fb9e432e1ee68a1e15d908eb6615fc77bb3834774ff9206e0a3fb40a3bfbf7e143dba0cbc2179f9ccab5d57fe2646bc2610c522e40131db7599b3dfb4bb7f4d424d4b20d36cf8a6e4189f2c8dc51e1261946a1a84ec031b58e3b90d3f4f4254b604a711a93d537f870c26666213fd4b95e6e38ee389b4db65cbceaebc1a9dd3d04a7b9db325a02d4b0544d043fd54dc93d44d837fc64685b35f244340da3bf270716eb9da89add19aadffc4b03624de636c0bf8595d9084222249309c95b23843b8d99934e27dace58902feb9f6b1b04083b3a621ede194738abb54da94e18dd4ffc9869d3f99e00d1c047bf16e459e54406434a4b7e443519822404b174dde4a7574ea671fc2380bef8e438f10009f820cae570135dce72d78e4202666d5b445b6081ee3a2f2b1074852b4f0f08ddc6194eb116a4199f5683db33413c7046b55d6bdfb14ba2c87cc2a8863e463f28aef346ab6caab95d764831126b87532ce3c3654558dd433f90bc9b146dcdb8672904752aa3b9852bc1baa083050f6b2d1719e3a750401f2b1d9f9a8dcfd10ab3a036b5769b79a81a283eda34bdb17e3e4090cf3d10cfb3845aa14485e60c902ec42003480060bc8dc6df921457bbabf0b6984507f92fd58e5722f9593af8f58702689948199f131d3d6befb50d340e495942c56e4087750f58a357cb6532ae569de2d16c3eda221077a96e2165137065977100da14dfcef074811ebadde913da9821d89726b8d267d63c44f5fe8929206f93ee6119258bf05e40f3c7eb3af1cb2dcf6bbc3a7c4fb7a8bdcb60d0b997acc4b0d4c7e2d4780818ba4e342a43593acbfcdda618cb571bc4299bc9eecdf88657d97e32896f5c61a786a406aaf4a6e2b3d962768cf0a356bbe9667b2a264009405b2e40d7e5a5f9a7afde0127845cd9c99f47b7ab721eeb74cc69d86faa8cf9b6de3af8be61d1b031a5eac79f6db25e3478e3e529bde558de93f7b9a6427bfd1b5fb8a3740c93354d0136c373ad25bef594e97461b32b4b9d37ea115edc03b37cbd41cf00748d22193f954e88625e550e1694e182216b83a093e274bffea10d0b00cc86c3d7030e8fa87efe9f7bfb50fa62e6004d983af40aa81578ec57e7afef6291ddf52bd87c0f026bceabb642e56c31da31204844bcc39b3b1a86e81e364be05d06fa5afa750cd5a9a89544dab3c10a4f822f3266d4587a883fdaa937ebf03e62010ee1940896234911c98f0dc2671898881ee1e192ec145224f11bbc0b8730b283a70c49ac6254832fa2a8326ed8d612aa68ac7e505a175d41bc9e135e865af88d8d5595131ee3016bf160a8d0c9f06ac2c4cd6b3affe23bf6dd0256f95d095c783a1e10816cdf31e3908a24c26b158d3ab38f388dee7244fbe13e9590edc8a5f8d326be86552282d5c6340bc9e9594b4fe64a9143730ce4b24d113d4672739e5f5fc5493a2f328c9c82a3efc66e14e4b59155a400dbde0abdc9c1a2b2e956671c7adbf403345399e6bf52cbf1cf7f94ebaf4232607242d9b156dca224ec504baddf9c15497a719dc73a755d4c867fc65b0be4e45e7eab72180b1b07a508b62ae998afdf3a283ac16bb4bfdee272ba94fab3c031128858d86d907c6a08abd65d2bf2aaa4b17f50ce6ab2a5d794117ebc43f602171358d2133daaf5f603cc79124bf51cb589520f2e47dd0bd58cc795697ffc54a60da904057a48efb2f82a251999c29bdfcd12da06b7c2bed2aa789457e2f6addd29351696181390bf0d683a9d66354754e16dc535fa971c18697cbbe2b991b70499c87f960d64dd3e492db292d5f14272ff7c2d01d4558ffe96ee1118ae0d8f9e6dfed36abb9dc6156a0c30ec42443d6c396f694095dbfcf26ae205ca2f9e446c6937950aa5355e61c95d61f430bd1ab91fd440beeb8652017bec0b1267795c427102be77b5a806d30f34903d3d3d6a96d79ada7ddde34034bfa6df9cdf1e3da38b55867ab049cb17e31d0d7d3fe841b3eb9d3618b52fcbae98481e04192c928414bdeb99e2dd1830ef091fd2f9d091016ccaf96507985342e33fe7f18e5733286f908a7efc2e33579ca6dccf9414388bf15a46f7c90a21a6d21e55f0eef6d131f51b386968160767e029f42d6800d023b8f2efdbc17614922b7a634025dec24c30292c62ce506a59f3dd5d27c53f8fab211cf1afdd747ac76175a0a4a10410d39e3188f7711db16a68c5cd6a903dbbe04ad232ff67d11f93df8a215e3e0f2d2fb0ac5812227da2f7dcb23a52536b7639b744bace43663b0139c2717bcaeb32f52420a55011078f0ebc4c83bcbaffbf239dfc9a3460acfead844f2751d64ac5980d214bab8845dcfd343b36d0a2ed4acbe8d14f57e641afe67bb9ba86fd2fcba90800a646a9620f15e3645951b683c1b726cc68aba5bd73898b179d473bd168a9927b3ecb5db9d43d4bdcf7a5931e964bf424dc77fef389ebdce3f857bc83b76e43f212de7801c3362e41298ccad44acbe964d82a183f8561e91314f9a98bcc0760546bdfc8e82cddd928c3d805ca4cd3d6249fe51f9468107f30312e25fb4c67a20680d7b1623429ff5ce337243aeb691f7beef4fc88cbae438fc3738727fd5f31469fc25b980ab077745c4ff83f996c05a6f43e0f93b40d896e319a1d8437ed2ff9f48ddecae5f481c2b5db00a80fdb7640586aa066739b76ac415c334b604159b1669b6320b126fdbafe517f17683de59f6b99f3903a545ac2d7d9a43d3d946c567d93b7b3215a166b910a703c2b9d521e2b8a721f357c793a2a5f0553073856a6a81e5f0d34e8bd2ddb61d2588a57b519ce8b217e4973f8eded294314d5f0f0544dc2daa352ef7b8ba47117c5d9022bf3a0dc6275fb8d1a2965481b1ebc8a96be2fe8861031b32cb79db0e3c86b6ceb9f153b97a06132965e1c8d8ebd6b6e9b367a418d8ff079661578cba191ffb5502df8c487f772c042962b917e7c6bccb9bb2e57091706997b89a866bd392deab707ad6feb3a8d5cce83b8d418a0c7bcd9669258516de7e048e67990ceee49ff2c936fae4d52a81bf3a63035183d504d2c011568b5e69dfe822911cc7db667e0a0b143562934112f38503c8da0e21e9287eb578e80e12dcda44272361481f567ecd7da9441fc7e1a893ffba7a4f962b5a1744ec4703c2da682edc328a8cb05f45d3757fb9a6d7c4bd79c81ac58845771c961405a70bde8cf4e49a45e76ae73266c1302bc848f4e9de295bd05715fc2d526f5cebcfe2a13a19db73285e045fee7e7fa6a8b1702dd8d2aaf636572125dac95160c5993ceac51447e387f71bafdda10eddf997715dfec46c64557bfba1becdf8a036dddc703d8fde2b26a15ac999d5c3635b67c8b7c31924ffcd1a482edd54d35bdd2add329fe59cd3505f9035d3f1d60af93a4915ae79ebf93db312f24053a00d405a18f32e37d939f63d3b61a01edd28835a43a989d5211abd05a8f662a7ee74dada1c96117c98bbd600ae9a128a2606d89876ad41678843b35088ec031691d21205f705d2cea50741283658823fdb32380581c2e189f75aa66a77ba6712b006470cddaed4ff38bc39f24e498da2e40984cd1b14672aaf92c51c1dcbbddc3cfd8c1ac0d40954814e3a2497651ed84f1150160073e3ceded70d5adde7f481717a318ac76de456ef8e73d58d296caba8f4cd9b949c919ed23c955a221434b94ec7569c20f31482539b9c77d249c55f8e5e4e74b0b55bc9e83e9efec4126b9b9e5466c9f0f025437264172bbac1739c53974ae3a3bb049178601f7f9199874e6a0270ea44b06987a6eb2ae8e4872a78f37663f76a3213f98cd5286ba44775f8894fb2aca64f1c13bc87a716628710bd6d90d3a793ed58b17aa80ecd53bb052f0703de4daf9acfc717dfa83f1061cbdb6a51825bc5b2723321dca127b53d7a170ab569a544c24575469835e54c9b216d9057f26d76e919191e6cbb0e20c3dfcb2d957e964b4385f9a18ed12c72de42072118d46ebcd588f74ece8f8c3d42cc456aa90fe778d6e14981b870e8812c04bf9c6eac624efba1531ded79703e7ec06274cd7ee083ebcd5ca9d40bd2fcc2c403a90947c0d453fff659f401c621c43ec4f0bc9cdaf276218933c97b81f0cb04f57330989a0c290fd2659f21f2fd5dc1eab49acdd885e1cecacc70acfb3fe74d1be748a161b0c0c2ab5505899d1288cfb457c0c1e58bacf46912b187060cce09988232395114e0790aef4e8fc9e9b31278b3899212ddc68b4ee142c7573a7d2e5debbbfab7ce65b503113cea7500d3b8f68e523a1194784afcffa59232b77a030c1a0a8d4176bf8cf0ca277b647848b8525981199859b3e574ed9f1c1ab0ac1a4fba1f35305b16e6633163e4f5dad86e70cd27c8e5e97430fd9f219266c51ea15f9a0241900f40ea176c7135d8bb73f2def6157675b9ae147df642547331c094618894390cb62743d1db2e49b92a48cb838b8240bd2d4f83a23fed6524646e711601f11283367c6776252c537baec73d09ec1d9a07ad4b116ce00174301f0e48e35c0c656273cadc1aed8d8593925f120baa6acffc8a17abb17d13e976b37b5888daab19fe1e1592bd702a1188b2c01906ac12ba877e6440e0fa6c0b6611ff184783b4928bd858bcaff22e7f036c316eb13c993ea1716969dc628e7466ecc4de11fb983814a13775ac9da5145e7319504cfda9ebca765b99913c241265b06bb9e7fe2af7a81048ae156fef40a7abf0be323853929bb3e886b7fc0493ae81d2ba13c64cd075f057793c7c8f2a92c96a6f94f1e3e5ab7a4e3c1f9b167bc91f644bf26e203e4f636ba4d8d71010dba6904bce9a23ccddb33d126207cb401e0ed3dc8e800d0d522177d02f61e2c2255997241c13c2c7ce1b799ddb84dd817246c1b4d5baf2a7643bacbc6709f3d8eac2c3a71b7e3adb5c90c9fca1dd4bcb3553ebb71c7b48f1d04d23bbd97ac31a8795da3be361b5f58e30378fa0f7dbb080ef7322902f0555d71cefd0d9be075b21866931eab8dadf57e2a9e65f166aa4adbe2abbf77098c99fb7cc2684fd8702a30b71cf885f00592958c664c0d818a340087ab7f31db4af646f8d4bf89a2faa2fd423306a81588b61bb06e2e26000d066093b192b7e398f425b58e8209ba9bae635fab2057c7d8a037934e78e42329c55ecc74005c04557d7323b4ac76d209cf77c5f00f472e7e17515963361e73d870d4bfad51c2f0d447efa5e0da761e554a3ba0aa84272c64a9fed2d246f23c5c2a76a787aed080b604532f79813a543c0c24235a9d590f0a2eb02597338c6043b811088c143ea0f6c22229520c2d8011e6606fe40031118aa0f5d024151df866e9fd694052a75a8308926f1f474e35afecb2461b3265f9dea34c163dbf531eb469dc6e4d6c78b202a47fbeb21aa397713c0fab1b1600ca954ff0dace7fd7de83e500332b0bf1e080b98f86b940fd08608cb2585f076834cd3e41b8582a09d5518f09a2b99305c387cd5eea7c2944088faf75cf2f0f75148d83147b9dd5a8e03e1ef52928e1eb5ca2197ff2574bec28a7ec60e702fd5ed99337b4088b7d9db6c5d3a8b3f150cd3e5b7b671ea5d4d84b3c5a50f858bd1a11ac2991ce225885b01c3c5032ce04101e132473d2493b95545ee54e53696b1bdd7b9e656394d1f4b367651fd3955ee7be5badf6469b9875666583a1bb387a6b1f8bb79a955b456de965e46b8b06c5be59bb2227e92ca8ab6190efe42646ea3c8892f1f0e13d8436b9e1d24c7f2082f22eb787d86c0c99dfbf577e75c260d9ab9516446a53297fadab638c06ac710245bf46ec40c480944dea0863ae953b489f1ef77db7c46115e1d4dd54f24b7e75a12f26526962803611a0908f692c9180bc3ef603df1b2aa048abc6d0ff4d212b5fecfd3c6a9da2ac58419d96b003be3e22a228769654caf7d8387fc43c23a57aee36c4096644870ce4d57f8ff598066f5bb97dfab02b02a72897b487a70c8dedfadd3033eedb0e417c2f44801fc3af41806130f6e9602bf813c7c906f8cbc87ba0005e032ed5aee1017c1e1ab9c08136df7f1a91f4c441ce79bb902265b099b5eb697c7d5a7fa9b8374f5725cbcba66468a5c5cd683a55b173fdd56671679463180db3dbe1f70ce8f819f94b4d7f50e508a219ee584851069b1dcae5251851ebc9dd660a700bb4566ea21a0625b247365ef0888064482f8c648e565b732510fc7c87f46341e1f76f8b299127d17e3c66209ac1160fb237046be332b7119b00193ab1453e36c44c18df4119dc399c4b6a95c5c0af2820374d07b2aeff19abd722f6fc4142f2936d4a411a01c107e6753bc81ee2e65cc97d6466bbab476c5270bfe0d4177f0c56727968e0b05b91bf5927060f56c8929669429dc38c8e17021f3d2f3252ade7ed85f7bf453bab1880c80360c2f978e0abd3b68fffbaac53820c8b237042af9848a8be24ba813d0e83d056d003fed59c654ac563317b7c714ce187b5c6283e95577ec9b506254242d8f011bc8579605e880d3cfed9e148c31aa2d3cfb0370b73ec7a9a6019a665c316072a38c9dce82c617a76aafbc40f2d95c31c48e81c92ac6ab915678093c91306d9a579363f4ed65806acb3edec3189981fdcf66f43af9e41d540b7643011791eb07291a1661ca98c77d3fb019d78ba61e1ccadcf60a1b77119f91f5502896fcfebfe4130d80ea8e6787b584b6061ee5d3b28baaa8e620f0fbea004eb912c75ac35f04840b723c223cc14a4d85f160ede64031df3177f0006dff0859e5e062666cb6f6450e7009c6db65d5649995dcb7b5c775e67c6732a966939b81b91e6cd35a1611d3606d38fcd117c4a5a9d3e6c98cee3adcf8dfcdd9375b0330eaa10e0719782d675c2e38d22821a4a8f23063bfda91673082645dd62d879e51a5c539bf7c5a0f24818c4939f7ca1f8f8e84585f2d2a2fdfacfc34fc1663311d11874b7ccf3accfbea3cf1641ccf29c418f3f8c537f11163c0720c80b4bed68235cd864209f7fbb451c111396edb90756909024a14cf9d5d0a3b0f87cd3b8e57bfd1373308548f2b2c98513dbc444d69e1eab0aba595aaa0d89c214c53c87e3440574c8d96f92d4df1a14a693f2b8b71ad4eff795b9af13bffb431269faf8021e1ad017996947328f3acefe2bc2ea52598ae9993d3f9e13fcbbdfaaf2594babe95b0b4ee31650e4a28be66b443c9ec03042e5fef009677d641e906687c2aa6293df480fcf16f3806d9d48f0d2e65b8a63f9c451ac163c12ef92e5b43da6177318ebd6d470d524f9e9cb274cbcfc41fdd32c8e32d7af7f12623c0b4fb7268aafb2d9b620a4bd1c603eba664559a06ed66544d49420de801d4cedeb1292f41ff0ccbfb093be58cd1d5574699807a0083be9ea7d667e1121c64e7af78183a720d8d8d6826106844c78f43d20a7e4add1c458917ca7714b209f2cfab3146b1184ad684e99b411735d9f5bfee5ca0a9f7f5282d956ccf8572b1efe1a6b338bb56c08b602325fb75311f371e092ac1bd171e18936b170b83496d2c2c6cec87b285748d84c43fd2eab3dd50ad9a041b0c0a880dc9b6f0a3fbc13fb3faaab5a8927aca38961154b0cbe8da922d4216405a2a76442f4e6aa6855b34d66f7ad3702eb8e5c1b571d35f22ceb073d68105a04a4fe9dbb1456eca5a3fbd5d19ec49f9371b881d3737bc35bcf4e0fa05f909d6e54637458b3ef380f63960728070bfa556f1676536a04790cfe736300519439355a94e05ab58e06cf6095e3098701afd094bc9a0dbe9897ab4f5be790e240252961737522c55e777ca9242aeeeb2627db22ce92c4ec90d1a089e1a44841c43d47a19287d855c9ceaef2ee1d2f50ddc6dcbf2475d5d7ea7480d6d788aa782a754f06de42e984a039366e9ca13c7e5ca19237f90d6b747860c0c800b00fcf9ebbfb93e94158e0a97e02b5ffddc3dc3cf2241fb7af3852fdcaed71586ed88b7bdc7d90b60b61a2bc66e240f813fcdb5a57dcc227498ebbf0971d91d17f801da5a9ef044bf36299612d2554ce0d26b7cbb784bb6c96608ab0e5eb81b07441cf74b93cf11131e7f1345b3e03e1bc0a1eac2429f008ef4e1750a345ffe6f60f02bdd3f6b8d2ede861d57ffc96b441d1e5b8fee816684d11382fc4415e57ef4c3d043cd30b9bbc4a09b5b01ad8463cd2d89659fd68847132b918f44925e039f5f3181fc33c545d1f1d3efb421c5d4dafc93991c09d99bade732b17cedf88cd6de744b1eef5cceb379008644a083dc82de0ef533237440fbc4cf894009b92b957f060288e82d316855d8c018b635dfdc5baefc40ca29172201bdd848ecf260735c49ba3e9c2030664a8dab648713501a76faa33d68879a2759c1b2354391414a3bc4b4e8f73fecd5a1e7445e895f53cdbf74b05cd3beadd3ad2c90c807b82d98f113501a3c0a1fdbbfd66b90612d0d6cab696cf006358ed2f6e64b95d2a6ae84318861a82ea5b97ea5a193204c9c0de8e0fdea7592f24f6c7f23ccc387675178aaa0e87f03918ad24a4553e9edbc509d830ce20b54ba20a8829cc5c4ad1bbf85a92d71065620c56bb9c7a801c51ec06719c44558e0244ee857628fa8e2ccbe9e43485564ba539184e0767dcca84f27b5003c85e6afb7182f83b4064500c5d4fd3dd144654db001cf1536916561cead7724b3b85ea3306c1339cbe9eb588427e4395c98e7ea53f1c863c3c5929201e4f44736fd70cf516bcdc2c9974f54468f2bad0b4008289c037e8b34d3a6459c9cac44ed1753814c8c5e16e25547ebf1ea3cc81eb5cbad862ac12027d44149831bb1ead054dcf246566d39e0e31dc1cf9963c54e09623ea8778deff9b4553d9557756cab9a0419eddb3176a2bfd940414bbc86b9aa6ce82c83a8e7786675cf7ef2853578eb7c4456f3880c46058223918ec1aa72575bc65f8e4245f91b7e91853ff3f998ca509a9d9046c68883884fc039bf23b4a0cda826e6322900397e59c53745624d85fad420a2811972d15e1b044c0d77a4c516a463dc768d210e230560ba2357c1d25256296a350061c0be66873453d65ce7a62aa78e9fa4b51e521ce866331f9291aa35a56b47c1fcd9fb06cdcf3f163fc2aa88ad5caccb0003183a1dcdf97193ced54ba5bb199338b4e89f7ecf2d907aec8c0fe8f70a478ac1916096d1daa57ae8da0e995d0a4363d3aebd005363254dd2ca58db4830a2e876c266e6b25d1d0c747dd03b2ef7a5a8533fc56f7cee0d3f1c3cc9b29e556f34e0ef7ff095eca29f0f06237b2e9045bef6f77e463df35187ad83af7f6fa0a1e7b3264b5faf50479ee23a9dcb43c8b3ebf04196bd053d79cbb222730c7603d997f4e33dbef2cbbff8e31442aea89915ea31283403e44c388fa1eb9e57e352c1ca36cd503bd3ea9ee847b096ae0314d23bdeb10d9d22c6d9266e04a39f3f3de5f633c26f900c9b85029011d5c53869fad29adb1d2ea9b03f654609065a73c32f570387aed2415a612ab96ca852927381c390cf54d45bb9337845206c6af693e4d43df46649c416e984956f2935d8bb45bf664f6c4436dd749d0e8de1539860c1fdb2118a1e85ac9951db71c2297bbef09acb24b2964bb12eff139bcf5d9e08cbe1671f91e45975f19cbc877faa3e464dd5e472066e5c408d8908127a422625efdb9db93710a4a0eb5464207f5d5ee5a2e016478b0bcbd0fc35ec91d4fc3d8e085f48fee10a951c8a801abc4cfa784eabdf03ce03e9437d20a542c445cf9fece1a010aa717783f261c371e6df236f072ea64f22c060320529bbee0c0ada069b06a9032ba77588ded87da0cd4f065b8765e83b245a89012863512f2111fab4ca3f67e44b02b87712c9797d3d802f82ab4a41ae41062c3c8969aef28258c4f22f6aa14bf036f5dc99c29d6afe9a88aa941e46dde97ba2ada95b9df5757ec975cc7eb33a63e455416f254ce79b1b2b143a83b3aeec40f919701722f223c04febf001c110849f20532caab3029fc9598e7aea3c771f1ddbcdee27787a066155c0fda7a704575740ba6aba15de8672e135b36874f20df04d929b4960256ec247c0976f942bb82acc4839eed6411c5c4cc735a2ab61396d3569132ef3bc5c39b609ec577ca48b880a949a889feafb8cca27495109025c2e6d5c417d0d67db614cc013e69de69071e1794be4a8d5acba9393dfe4fba76624272f5689210c6031092f346f9c64b5a32bf86a4a6c6b5fe51e1f897c6c9dcc36cb36674d03d7a57c2de17673e19ad8d6d00721f2b80de33f785c627217ab4b17d4e1525779bda3f49891c2cd606f827f1fedbd32dce6621feb5a128919ec7db6e270287c731a662d8d505e4d7a43b07eae32e96b5d5019eba4a538b3d47c4b81a4803a3c7867b9e8598034d7c01c2c9f4f0725e1def994345905f7705c05b3c247cc1147fe2432b4bde703701d06fa3d6608081e737da31634b17877a3dad816474f8655255b9a69bdf371e035c0687382c5d36bd078c84c04212b0b393c822c6c5184e16b3c25dbea14972488d163512000a7c43ebae14b007f37769d63e1026ab3d9556e158ff4e2928fa72a1bb12fe742588713836e6f30c6f51a3ff89842d354017acb45bda1f26a72b5510180ff2ac15304955d1727dd634e4ea0402f60c60e8fccb825065b6a01080eee5a7293beac4acdee28806feca4697542f56ba418821aa844bd0de60009ef7e470f371b95e982c46c76b6fbd29ea461660ddb44fd0a81bc74e90f10c8ee1bc53abf398c90a45b4a76aa7a857777226e8df19df00a867bd621f3ef0bd761c269761ec63d55b18dd19fbcfb752a82d03c8537bf17b2aad751fd0bdb02f55ccf50c0ac3110ea797904e9e84ffa61f0268941eee86fda6e67ec1645b5a0430778eafcd46c04f58ed61e6a4ec17a0845c79f21865a808d55209bbe86ac6df1a007ed10b99ec5a884d744c47b83103248f39a4d85a94ac20df563838f53c6c7c8a624f28379f11e8748e5c2249e7019449030453ae29256df06367ba067789cdaadf01c569b38ce90eba7e72bef6dcebc53b6bee029c1ca79cfd2b7b8880b8ffd283c914967b9a5941e0deb9dbc6ec834896859ab551d907c6c01f16e61615d57ec3c4d14134765f3063a6bfbe21cb38b99f2b076ee04f371b31656dfc4e93c1fddcba8c79c67e5b4d9a2704e7561d671fa0130e6df6302e55d7ba438c2db247b20aa812d72e220c5be3c703f2ba4c7d222724222fdc9ad54c8f500bc241298ebf52e7502f34252488d55eb337030e3fa876844ba593f364ca7d30eb4195acbcdb0fc2ee7480548589c7c042a736e94290032b979ae057e7034950a3e2691a13a4df00ee3ef5a26bdf416b2fb2c26eaf073790193fe866e2104e4eb8a32b9a93d74e28af3525a8a2f6ab1f2ad356fa052ef5028c1bb2b363c585f15a033c3268cc330d4ffc5e3c8f34307c28eb3fc432ed73fa553843a9488ded449ac73be648ea268bba3d35d5c4a2208ffed3af2264759e0697b1c8e2d5cbda4c9f4eedb112ae96ec5477d8f2d0039553254f8ab99dfc2a53708cfe05788e5a5d861b67b0d27b5abe208549ccb739550a7d10009d7344b808080019acdf9b1cff2c6bf21c251a255420021c5e83267870e3c476d01e6c76d2de987e138cef5257d6ad8abcadb2a2c285f21746a560f71186b4d4ec0e4daf1b5677b7d528dd0e5bb392a6a1217f56fba55bf4fe0d65ed15bfc549ab6b7d0998faa67012c91f3a8e24b85651f3852fdbb58de18041191a2ca4832dd42713e9e4d380bbd6beec974e25c545acbb583dad474261d549714a85edb821ff72cb5f27d81cdae0bc94bed331cbe7d9d223ad6c20953fb405a1cbc32a473319356f80954378642e2699b99613960c0e53205892381f36510d34901e4c1277d8aea0d6d533a188fa82a331e5733b65ced6840f85b537bc228abcd995351cbc88b1fac98c4dae4b678bfbb2311e62f0dc75077f82e616be253e2e1d96dc5c2ccc45bc3e0f927e1a0c68f1b88eba9283aac3fca89ed072685f855e07ce10fc7e6c2fe916e12f33cc1fa521b25e221b762c6e2d6b58f1e6ddb9a00864cbf458148f0850cee738351fe01a913e386038d1e50f26a8f6cb871917fc80feea283dbd1ca2214ef17bd1e883a3997c1d8f9208733beac2b9e2a9cc1ed7a09b21dfa9afffac0191d3b5b78dbc8eab6fc0068326b1f5e4d71066eb87361543758d4ac48d0e0421166248c98dcb543f8b66255f156230885a17c6e08da5ce82adb66321bc94f2026d174c96429ba09472acbe9e9f247b356e00f2f567eed586099b0242477c29040d26f508f253cf606a7cd29392c116805ce12eb3cb297d654124f771ffa4247ef4281ed499dc7711dbf6abb6d185aeeb428d4eabda01a4e34a88d639b073bbfb97b41da9eb57f6629b36601f3102f77f3669aec7eaffc4a8e8b55f0087f8b1e0b8ab2fe7a7d3870a7a82115209badba9fd6e7aaaab8e40d2d4314304812558aed51994a48f589408cba3fc06500faabd5b7694f5067e437c08cab429391361141f69467f6626be89dfc290498867fe0ffeb5ebad557a98b6d77cc9b328a28528124eb06dd4b9bf71617ffcd9a5cfa69463ea4fc57590940e72c3e4870b9932050f52ff9c61f9869ff777b9ca31a6da8ca312c5133423bfaf4d7a3a6817f9e09502e95b71c7387bccf5a47406268dcd0464b5547a0900ad1792963f6f49caaa92d503575b4811d50deaec86203e8bb4291dcfd8db4741cd21256791a18f7f7255f1f53c7b9dfda3d291cf4fc095c4fd80b6e677220e4a7a20275f3221c6d503430917c92c01e23b2754d240c3782db7a1610be3da1301d2e8ceae7e573b8c93b5696e58a0305668cd33f1fcf334ee6153cecd44ee6c45b7775db3b9263eee1caea3de0fdc39f4f5a3a870749672809717697fa2622c53b500633cf8ebf40b1e5e26346fe454b923cbce684e05dd477a4e22bade61e65c86000faa8e87d1cbc34c8333606d45d409ba4ea10ba9a773d3ac3fb645133613435951f60ac5145a6bbe93d9207d2e378064d986b77b0e48849d7039ce4d5764f942977521a63be346ea59877134bee782b9bdcb3869de6c6fb857f9cef24fa0bb7209d108481944bbb978c1d6432f1119b9b1ff29c44104952b888e367adb4e588be55d2db24fb0d77a01ca5e9ac262d8962b728915bf4e4979b0d4b546b5cb2f7acf9c23bbc7ac8d219d01c832f9f482e8397603711ec9afe9b78403ecfe26b4e49f9d7fde1380429339be9d07975b1384aabfadace9312a354a4175cd8b00fa1ffec6bda57d0eb34246563d4828d058747b5bcf185d06f169750c96ad4e4bd708dc2035b5cd84d6af91471708ba28b71a6797ce020ea86e9874604d044f37f322028de601bc092817678d2e6234e63a17f9833b2da4450a9f4be2e516c138fcb610a38fe1dfcd70e8b1db33ac0ac13baecb54dbb50f2e3f9d694b5c3b853176fcfe9bd57c2c665859caf430a85f8bf6029d4308d249ca94bc26558976aa6fcba327ea038ebec4f8c223619866fdfcc1eaf552c84d3053e09e9f9cfa1b203876617dc5c12681b30c128adf177b9b129adf97657ca37a455687c3ebf10cd5d7fe641f7dce3dc486b221bc7f5c27a5cae81e6f03b413a4ff9cb01f483e967b2ffedb1ddd70c0282eea0c5bb8c951e99ff01f5ab72e4fa57c69a74783c93fce938ce85a5ff2870312331c6b80683e53b3f3044fc207e974770fe7ea0b1e644d23e2345c488ed177203d3527e5e5ba71980cb1aeb4f8277541a638c4cd64c6ddaf15d9de6b1b579b0547fd3c843c0fee8aa7fb7b6a0a4ffc4e000de251f01c9927d6377a23defe79073565bfedfb68003d7d5dea4b2ef29ccf74964653ecc433ebe7fcd50b12efeb2c56e25cc1fa67e0080849b282ce7bbcc8fdb73cda59e7b4b19dd300003c8a45236ba55b828a134ef9403184c56cddbbec3457bd44b98e4f3639a6bfb48e8e104bcd313c5c949dc2198371c60039a8e7c14a1c958e99bed6dcb1d3afe71bb17f7f687addeefc965ed860cd942c2f910911306f9b943463714e1550dcb3f287b72657682d982d337de776359d69b6b3a6ef0c5677178b6ae9c1f0d42fbe50684e06992ee8ed22ec81b7dea80d2ee180f82f7fc59b0abd051b2f3232847374f89c23eaf1ee39f86d5a9fe654dff4517dcefebc76e2662d1574a286692c17cadf1ccd07fb1b78db41c8b7273bd240023c7e0550fff9bfb527d576c16268ffb4d833e4f5f909d7760740cfaa063ecd107e8b823b21c0fb53b6fc3b4fc18f099db239c16fd00c428c9ce0c6430994eea69556ddeed7aea045220638209f3b05396f920b49e18d90ec1c43a9783e3ae7cdc50f0a8f51e8dde833534a74ab6ef66a9b5a7888a5f15471aa978416bf58b093527d4c27a926d0fd549dc7ccec1291dfb3a91d48401adc9e2b67809122f7e21be4eb61223393ac07b086d05eee88855bb52c8ca6b90e4eaa1e5d15ca910ad21e4e34c39925096dac33721c0dd7098f6e8e8398a8f5daf0a58346d268d82c322c95887374f535dbbf07725f85a1d0541b3edd2471260d644df9f6c19d609e7763dc61bee93e825f14a7584e5bd462ae40c723d549e648e0e9783f4c214547c42b5bfb5f9e2f802f888c35b27d21266bfee81f88193bfa3f581d0af08196fa322e0a3f747c4abea32e7cdef0dd6de2ce3f9d86aeb027373f90fcda48a44ad38b67a5a088cbdea7f3a8d2e59bc6a3c4c2da8d34ff6c88ae79231a5cd40965b01e432f57af394df853c29c64a8e018e447bf5509c7155910e97d281f0df42cf2c438530468b4ec0c06462e476904215c7af62ce0844f1825f61cd8525ef09a3c48c62d7f986c838c615e57cfcb24b0e2692e6fb39ac9b6e64481a06b889a1d2ac169f1564d58b6e918fbe86dbdb32e5985a6f704e4172881a92be340eb6641a6fc5926b7b24793c0adf988a1930c908743c0fc071838e7384783d5fcb3e5ab03c6b9d0b62014d24679afb4638803b3739c593de545b789f600f0b3c5f548f6c2cd2ae68ef4e8256a6b63c6ca8b813e3a1df42450256635ae2bc8afa89e5d54a4ae044978a2ffe64307fa15456ca37095d1bd79cfe0b440a6a5387b5820f0061b960442f167980d3a8c6038afc233389a79ce9401e3b38f9bb60a495a47b107f246eb8c1e2256d47de6a11d415ffd984bda45d3511584e9b1b33acd8865fbe1967000996e34a4c9f21fb15530db28e158f7f4110b9610fa47bf4c3be67ac26ddd42751e27a2c8d3e6853a270cef9e8d4afedad8744f1ce303b48aef99b80d2d37630f2544be726511df86e0c7d9714ffc34a5655477140f2ef8c77d6babc930bcfba127b17f303bed8c7ef70e6fbc42ebfc32e9494b7451e00b2e9964fbb0c3955065e6878052fcfa39ba7e652c4cf4da4224678c2f5f58ddca1c54a7c556193df5e240aca2f7bc53de103d11e5589ec2313cfef3f4fb971c3170d9d0ae692440a1c5215d9eeef7d55c9781d7b58e020cec974487e0c1a27f163824a06f25dec8dba32aaa744aeed32f6324e53d525baafffb71939807ab067b04ab6133e469f641d72025fc8dce289e4d62a0e6fa9d8a9e34","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
