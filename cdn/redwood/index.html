<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14ee15582bdd96cf51c6520f6e8f585ca40d68d22599c19a21059a52d24e7388727fb075cbc74cf5fe2533746f2df818182e4b24dea9d1338f29296e804218f5d9dd7d661702030c5f63293a4f4053cfb850c485ef59c8448e7d217b5fe48a6a81c8f9ebb8b95c8a62b9eac586c7d36684731765162ecf23927f3381741d851405fa4d2865addc62b8a28a1d11e9976821ebda57ee6ab6cb93c59d32d41e00109bb20b363402687054257e2f9f2c87246a4d1b37239495158a5472b2cb1ed68dca76dd6022fca0fc0d341e832d7056d1bbd859823bfdfdac0c0196effe2113d342a7139aaac8ea0d1d46da33c67e9e8aad68898902fc6bbeb0195650b8ae47d81520462f514879d1eb08089d2b054dcb8afdb588fe0b9cf79828a5d707e7e289caddfa0f61b3df8bae55e7f22eda5b8ba345b0dffb978779afcd424c2262172f516e887555434cedcf5f914cace6d62cc2296905250d16872bd4b8ef1739510d22a9a320546232fff40bc53d63c9f9c4bcb85550a93df6643e4dbb0cfa76ba44d49d4a78977094561c1f70794fbb22229e2aac1297fee47cfae5079b8bff079477dc25c4614392dc2bfea19aee3bc5188f2b1a4a06dfae38b7bd1ecb6ed3eefb5faa0634a4166cb52642bae725ebc3770bc37175b42a0150d3c124003bc3d824860a0d7e9197b4584ad670c9f68eedd4ad540efb59c707c49276464fdf34e4a5dbead8eb8c18b094f3d5d2f441f755f22b7ee4f4480a095c9072781d6ca49acbce2d4b880c152f648640743f9975f416a555dd9885a9995451850b8cbf15b8a439a67f0556a4032a7fba170c1067f000908566ec169df9b982639e5ca0710ca288571372c9d2deb4a463e11e154350e567488be9c55778835532d105a05e4f3785f114c957f057b05528fbb748c212ca80b59dc4e55bbb7a8cf5c2ab08bd073689f24c1d78da2415721735afea44194ef37be3e25a61b05f22a107e6c9fde898fa091da36d8588fcf5e44bbdb36152a4b9ed71da4be2c88e81933217e6ba68fa321f0735d48bcb4cb651c284fd921af742191da05d6ce2eed1308dd58155b29305c798995bae3545ecae3b4960deb0030b89c1aee63cab170c3659fe3cf69e871401f27fc86b713e9f3bd124640e200da44f55399e59c0d70b1a666e78bd5eeade1a1d512aea1f629b883b913b14b7f653d1ce3a5a808b3a0d2d3262aceb4d84da77223c7c4cbfc4df66e77b5291aa7514e26eaa997bf122087c9e6ed63b2b9b73263b5e4d22b19d1a17a95d1255bf754c2d8e27e2671d63c2b84b1b6406b3449dd0e7b04e61d1d4ecece399fe2cee6c3f745b12688c64c56d465558f2473d4aef78a104981be7da33ec976389e0e2346c1aeeab9ea1969a7f6652ac81002dcf9c61e20c0e874f13e4b6a691a8dcea0523ee273d0a77beddf8ef35c4edeb6ddaab78db7433d66927820801f874ebde1055e0ea2b7b1f0372f9598e50439ea780247620771673bf2869e2fb88c19834efbf80eec9ea61089d11af0b8e5da5fd657cf5d0796a512a64b69211cba19f0a5e817b76ffcfc65a9140fbf7472d4385e467d4acd23611381ff93de1ceaefbc78b29f1ef8423c1217ff3c2d8a9d54482543b34aea9d8a7cd13ab762c2a53ae04b2ca1d924db7a3d2196663ffb4deaae76592470fc98385b42a21c16061949dee78c2cf7a81f480520cbfe72db41fe6392f67119c9bf14d94ed1e43890dd6f0bfa055447fc4dc3e19bdeffe4b33fbc629ddb49135c03d1b67335253291c0c7d6123ee7049a6a285b6c7ceb21abdabd6abb990d203c19070389b1ac45fb6b30b0e168c89e4f1fe81b9bcd9cf8cdd92880bf440f0523d9621b3cccc559bf88e922a8e56d53db446249acb84755e2086ac1d85d11acba3140c0c44643d5dc55f49b346bd694c40969a1216cc721f98ba21c504f9eb55c3e0ddacb93defda91eacc237e292d73d5328809eafb13a57df8191a686689edd509c7823a44e736edbaab39d30c6d35e9f66c38f04ae55602cdbfaac5324306470ed88e940f60d794492e0581e64d2e43b86ae263fa615c111be86b1258b506aa6d798016f070cfaff180341514e1c57dd17245e4bd1d397e1d60c7d4546c3601e26564a30dc86f12263d5f5504d8789ba195e2f13421e29e46e5b27fbc2fe7d3493c0ed33bbaa02bc85a157c8d4283cec6f026468ad4503bfe5cb14cd253ace851aa32340c92687993217b20d6f81a9835f2b7a62d0670a7c716729b1344b5119d24db4626731325d80c132be72d34ed3c740d4c5d1d7aef88e7b68aff5c4b07cecf478f366ffbe21e4c97154a16ea927d096251ede33510b8bd79098f21e6574ab21b6f02978e1a99cdd57e486ddeeede018fb8c85a4c5815fddc43f3e37b8fb14b56bb8777724273a2c729d0704b4f01a88e1aca1af9e0e5361256ae7a058f45701c095bb0953f8801beba761bdf23aaf314256c2e4fc82a05c57d816e771a4481b8f77de1ab4dd5026f960874cc12f396af43f95ece8fd2745ad815f9bcf8aa55a6bf4232e20b14245a45dbbf69f0e8d138aea177076d1200543448d086fffb802b0614c7399d997f85831a7c39751cb4d0072643eddea4adf08c83d0ba60a5cd53fd2aa30178050994244a280e2e545f9c07ee1b03e9c7c6ecd83789f4b1790f40b208679675348dc1eb2721f1578cfa0419710c67f39a398705cee81f811a716b7fa455e4612e6ef019dd465ce457b2e6b656825b75f586a1aad4a196b49111124d94859168f582e8eadc61af1237e1758c1b9323b233291b8f7209d7b6b5dc60ac81562e7656e2d17bac3e19fc580fe9d2ba9e3f39e51143ea5bc9ba3b443a57452ce4504fe18ce67697cfda31e2f9a66c36ebb484d176b97cdb61fe399c208ec5a952b0cd393a836f2339f323b6b75097f9e3d6cf151c829a591c1d4b15929a01746e9de2364dcaf016536bf0ba37d2e79f04139e58b96d74a5fb47cfc9e8cc1da2c46e38732b2a145c74b4db439faece67cd72c0396ba72b75c94a540001d853ff1f5083460ab5e6b892b6f333f7cd24f1ecda8c5750b8a22c1a71078dcda5c7e25f4d7eb00434adb1bf12330430ad2227b6493e5ae4707adb19e00fb18c0f798477dbcc0ac6e5d353dd3f5eb4ec287739fb9780083a4cc3cc03d601ed06d665f8d24bc88d8b3328eaa8883321812db582c90637fffb931a7c76a37d36ca4f1228349ea3141e54bda3822136f2cb113e821f75baf2258ff82d4e96283128ce85158933eea06e2ee5aad0843e5be53f94df2099bbff1d5ba0744869ce50d8c1e5b0901ab580d22136e548d688f23e2d398057ac9faf9c5d67562571f0ae5470d0de35228a23ea8e1e50157e507d28026b2adaf7dc4b809008ecf2b64cc888e62e1a4b2b47995fb63994b063b2c17453be6f6ae601af163bd6d04887f08c05ebc284f47abdd22282498ec63c9ddfc2ef6942afe793c0ef22e6c86cf32b9c09407461d745dd769fac8bb8d07a1ed27f73226d7c30eedf5861b2dbca79f0335f17571400b4bf52272511b141e5f7840a76b0e63cbc75d7f133ee3701113b850103357eada9eb80b5d330871658281db7a011add297408a8da62ac9ae6c63a9fd0e3c51e065a705f1ce1a2fd3aa827a4be7c1cf2e37284a3ace652f0856c797e0bb34968e6ab2dc24c2af373113c4cd2c008c92753813f1425223e2ed20dde0c0c949a386bf87a1b290604d984ece3a5593146b7290a1307dff691c0aaebc80fe69a8cc4965f913b18dabc03801a0d48cf01b44a0882f8eea6515bbf8d46f40ca6a2b654ab8a0b96054d31a9e7cdc3e59783d23b8fa4b1be41cc447afcce937552408e1faa790adbd55a4bfb86c13e7d4854079c3cc3685a10aded03357f589884919d8937cd01e41891357db94f0949ee4d085e07d3dce9be2d689ef379bbdb6f0f973bf3d9d37bf46c3d962116f64269b40edca5383a9b5750079a2852f22a36797317558945ef023fb0789d8b9f67e52498670133e74098508486d3c2b00c3c9b43916bcbfc86ad207d83f30d758ee7d97a40dc8ef8e30ac2057c32e209953fc94cb74046fac57b5de9643da41cae2592b3ff33dee39c60e4b3d4b3d995920b941f91d4a3fa5f396c0dd096943963226fe800b6d9f0bdf208d4b5ab2c1d01828a4ae22f75d1fd96660e085c46eeee7c929f3a2be486b9b57874889c0fbc1cbd82a614e4ec863bf6a31bacef56e8da547b1aea379523ae1c8204835d7a8c554203157a49064d5b75e441f537dfe1224e8894777975ad09133ff9cfd02d46de3aa3472accc89f40a0d0c3bfc02cc666f48b0258ed606d990f4299c1ff522d4c49bcf339000f500571acb43409f6a1e9bc8894b39d38ffa75c118b60637580c971054be4b63c417143d289c25d0f82b78ab7025b5e1b212a68bdbf12749021c7449781959c135387ef51a7115982323059df3983c88037afad88ae8dd8feab8a079e771471ef5acd3ebcff228e9aef3fcfee9edef1269622a2a54b2268f3ce2941f0e9a540a63326d0576994c2d5cc8ab7ae71c1a8f485971e3f85acf727d50cae60637b9fba41225ecbea4aa70abaf6c258033068e20887b610fc0c0d8862bbc36ecb81b1f2dd4641be93ec286dd327bfcecfadc68b3a0e9a78e6c94b53a0f4f6978ae25cb0bef4ccb70a521197ab181cc8c10584ac3f7a3ff98969413a4de458a7f111729264fda9485a0d6a45453f6e8bdb0a35bbbabe4a5be2affae25e6ca508f998991a54e159ffdd1fcd77cf27c3d3ebbc199864eb0f3e69f74e96127a874b23055977ac77313faa64cd164e45bd2ad07389cd5b4d23be7c64623a09882acf477962c461d93865094529f7a0085de731b14d15b396edd02aff2dfcee4f3f11f735d9209f80fa3e04cbbba600b7fae325b4e401f217d09286a0fbb17d2821feb304a4fbb1cfe64dbf25b76270be151523b03b583670cbc56e45f2e36798290bb745363e4f6fd188bcb30c86b69a62db315e89934c1a4385b414ae5f5fdef9928fec1b028f7fddb044cc75c85b9212dfaab3710e9f232da1521fba46965077c2828a4cd6c50a19430b069c59cd11cd1c1421e2ed266b799f3bbe2486deaa6e622e9dd5e12c8eaa23f653f60f4d6b262187f2bca4f9014227e7f0742ebe3b289573fccabc23b6f3efc77d0ade4beba0e99c513b2db37fd21533542fb2fb61eafd7ae4fd71e651181633fdabb3671269b3239d2d82d9bb304f5ea192587189d26cca65558f7aee281d38989a322fed04bc7b2ef98f2b933dfa747a077e6c83fed97290e805133240def805232c5d06fb6c9d738f15593b8e63078864b55d4a8d5f337bb47dd644506e0ebb75a7aab44ae3bfb627712aff9c803a3071e30d09702a5dc9e2ae72c438bf4289b854cc794e385b895e2ecc55c35eb583cfba7b5f22a4e16c5aefd14a55dbfe32d4a50fbb589b7f15beb5c87e59567c33ef6a227572068969c4ff53e2f57a02676ea33aaf3931b8afe3be52ee31a46e75b49b7770f2752e46f675702e257c957ad888236edc9c37ab400ccf1efd7ebf85ccc290e6ae58b284ec9334dedb27fa6b1477095eccb5b4844b4dcd213d177b296ec06b5faebe2d64796a31fb8a0dcc602df0e13022be3594cc28404e74ad320134ced56b5a2958254ad78b5dc68d4f157f7cf2c5d67a2faf93f1af255761dc4d04543a4134b1242a62a073c55b0f10872278e8ca04d27d98f4f4ffc7c0044987f65fce0861bdb7b0c5560ae4bc679edcaa290721cf708fa10d7d3e0b92e604f35f16648b6b1683ea5176ae09d75cc5f0d78330f37ddfdb2489eb14ae53676f02059d5ef075084d235bd0bb4ab3fc69912c3552e9a3edbf1f2aa2be31cff769cc9ba8bca8e8edf0917404cafa29295f2e3176a8b1b6906c475d45341f8685649f9a4e33ea96010b7e92ba88afa09700fdbe4d0c0ada6f94dc688d8f700e68eca0bd289d250396f9161ef36d2be046edbc55adf201ebbda11c8dbba984d03f53011698c60bfe2ad35163e867c0ac3d48e4a3606f5ef2d601e2954f07a4ad58d9b2fae5e4c393ebbd41610f826935495794d5f6183dd0f614cb66866fc6792defc974cd0f37a7422350be32bd5169b8b9bb9adb92367d5d1fe239ccd4a0883d6adb6aa1dc221e5a47dc2a746aa3c2c39f52ffc1bcb21c1470acdbbf778993a7f55b93e20aa4b070576ba05e786c13766bcea376cee59b1c2c1da2ea17de44926c2439e0f7eeab6b960b43900e5992f1f2ea642713c4561a24afa5a496a2944b0a85c4ed00dbc76b1c4d2d4a5ee3270ca582160b9899576ffa5c15d1564b358f8f59d310ca47ed01591535ed0c690410efae7e6f8d98e4871085e287a9832f34ba2134984207e2b296e4aa0e4d2efd5031bad6ec2b9450253bfd4c17213609fc50685e975e4ec890cdb916c38a9d6c563911f721eb67490ca25d2d7ed64318f7040c8997fa3411959c54c766d73df2030b534c883ef56e7aec1f7819895ec5c1bd9230d1038a4ecd588fe69332573992590d8a087271996a5cfb383ef8ed58c7a7d469984bf39fd25154e1e60d7b668342136d983598d4fa19bbe0426ebe74fef303bdb41156e05b959c18433d776ecf4e996f7a35b4a7e38f5481760adc40d4709fbec0f1a082bc46a579b67775679daff25912c265a0c30c5e16acf8acd1c9c9f9c45628e62c8013198616e80837f8b0d15b910a77e0ca992ae52cce22bcd095e3a3f684aa47dafbe1d323b07eb93989ba7914f5fcf2b41d50e9015ce0c5658ab39a5d7300f479599a62c7ccc135fc5e44b67fdad7b4e3b533940adc9850251adaae0b89316f057abddb3d26307761332e049e4dee5251d8e981da501ba3d0b92a24eb7711a4fcf316598cebb399a10e5f7e1f78ff30b302e7672156cacdb73125590cadf08d058f37af94fe2cf09d39b6ea8d187aa9f86ca81d078019d6d0dc1e351e6fe75852278778bc2ffebaea1dd771cf13428971fc7154eed2fc0047289459e64728914a35a2cad1f5ce5741f5f7baafccb72d6f1a55bc2e924f531c8ed9dec81382cae9d0e2ba224902b20891daaf0f3706088ee6dd9963b5090e13bdb404184e0ed663528a95b9241b12d1412dec8fe64d050379ffb8ff676523510226d2f8d94e378a97b9a17bb689165f641575653d09215f66f5f14d0a19e261e5b902cd537b8df76b1f7a132751792d78b521955148daa3a84bf17a905b9be84b00714c342a2522d7ed7617664655ef935697c3a6986375e92a77d767e4c5defe6d14c0793fea9c815a716252b0aff020741c034fd2e61412358b98d644f88785f65d7ef4f986324086ed42c7cb2668c7202a4a869a71245b588dcb07a05d2b2335abca65bfbbe5a18a9fbf4e4653abc72bc967d0fb156a8f28e156f7d2d8c4429ec4d365024e7487729bdf9959bd745f3341af81c0df4fdf7b8b2cbfefa5a2b915094b5ba4d50fef39b6f65e007147a5688c88c6df31837aaf3473a605f736f3fc8289f7ea95c701849fc4cfd450db1a6e266f5f65265435510b2425586f49fa1544bac473b529ca8148730697035817de987c7a03ab152602dfb7ca16a23ced1301068847fbf82bf8752e2a40650344b9fd41df3c7eb062458c78e8a857d09ba7d317fb3689afc2ec4a46cf81c83f4f0f0748758e774ffcc442ed8294725b04e23b44179ac8767612887a6d0fbf0b8e400ffb7f4c42651cab9e55cf47e18dd4755f2ba2f1bdcc83ea6f15d2f7b99760996ba38fa8192a9447ae9c705fa27f54087e3596d3ff3febb8a437b4051a03f99f05cc8d061c603636c569cfff10ddef53d5deb464ef60021f88d5007f50acedf944ac076069d01b24e893f2fa14f8dd9ae34b4b1ae4a8ed493e932c0f110a20617d0cba8d8b44bd4490381bac4996724eef98673e4fa51869475c88708162b528c6bdb1223196ce91c0af86ed9d8375127ae74efa3e2fa7c340363b20aad043afedebf52107d23ee4c3a183ab416e8fca9a28bbdb62b2c62c4de9ca55addf58947b6a8648ba122d035b70c9f01d4c88818de008bdcb9f9b9e94ee1c20d6b6d03c433a020ea6a4889da4d450b405e281e71b0d8ba2e0187b7aa359eac31f55b2743195cf290b7717f3a9a40b65cafad2f351546b04cd11d836f8ad179c021574889aeda1db07900f6d3895e46e6f57098a530f08850a39eb690a56273dc0ddaa1aa7ed766601eb215ca9f82dbd736603c83c208219eba824a89e470bab53a38852fea3d205e570db2e2855510b3b093447dd1eca3aa0f64d0d8caf69dc09df61af53224ae666d333727e8ae6fb9b79efcb6f3f33a240d3536ff62afa6ff53ce0288eeef3e371afa5aab5efdba14fa4e3adf503bef5f2b268684174d29a5992cbd405da02477aac08c837ab4b1046f51b413d885c9c47591ed438c98ff34fca542d7a3de8f3d4f6d0eb82b20e00cfec44490f74f286a1101c688f4e027e2c17b0c9630130dad75f7756b6a5b33b99210e4ea1f4111ad7fe99f380073f7223fe0625e1b92ab3926e49ccc9d50c8f88645dbe0b588422c2c9d528d8d87ec443ced3094665124319914da098b6b374b305439d7097501ca8ac7e1a484f417bd37b83a166636e509d4effef6adf1a9308681110b6c1ab5cc2cfec3ac8e62758e2af74feb9ae77e6d1b6e03b8d63e3f6fbad6192f78afe8b5d2e6bfcddf0a2780a86648a6dc8f09e026a556dd36f2bf343e6b8adff66ee95ed45efc11c1b52de8b45cb87cbfb19a2c11ddf03223ab748a8a6166063bbdd17dc475b4d64b7f893f6ca54990154bdc30f0970a17b7bbef745200f36a346c5e2b766d97daf58a00f38d7f1e49ebc99fa1a246aebbcb4f1fa7511fb93a2c87da062ca82af386df58a39b0d5071315f64b28c71160eebd7e0e5b4c1f8b8f73f022a35e3278765308d0464aa2db0b38001d02a355cd48bdb4b23464714e2b56db8a5a7834891ce7ba6d4b8b2be99031f3cb60e09790a9c2f043a6c1d7f3d76c717d1d6029a0cd184f784bdb559a9572c15fd61af56801ae3d2009dd8c0a4f90a0f970c9cdf6676e929bae0e20aeb8eca6e207e3378d20cd5ae0a580d0f311b3b2f09fac3d7dfc167a0ec9f255751c29f78ef43bbb57aada6bf6df8bbbbbea74cb225a0d060d9204aad84495354040da8ee295a69e0923daa7f12d5e417302ce90a667313e059120faf279c80d0d6e420911c1f5fa5dfc2bb37b217972e6c0361402cd0c2bcde868011d1c4f7fdea1bb28f34d9979f666d379c2f27835635626674bef9807e0142d4f5056d48e69ae5bcd9a2083c8efc7f6af79fe36ca243027ec0a302cc1e30605d1ca90cd0dbd1d6eaf92c376e6050a1ea7e004578d559e249827eb4c95983edc31d0e01fe731165354442e35ffb3e67b757ec7cbbddaedd794cac2a71f9d1a983e96ea6be7fc4fb7c006b6b0bc2a3cf82f195f51baa3c739a205f9f63321ed3576c771b7a0bbcb304a13ccf4f76069d29cdc5c587f5144ecf1210251de75d114b1edbefe9fd87aa3c67bbc2f24c16d03a349c6b30b41bdf904d1befe93fc7015e41f04e6d30b7029c6490e57413c44d692c8b45f5ba5004fe86e5bea41b056374174568f2572eda79e823e0413900f7e6aee74d94b67043015b32572e3da116dd43c490acb3bf6d129d2205c582183b75aa802f8ce1553799c1a646654b7bdd7ad202aa63be2ded9197cb93cbb3096d1b0b854d518bbd7d1fdb43f6ec05e30e3e4df1bb7ff3e05776f723a64e0a07d98024d2ad548e3d0c4ac895f5f53dd2b699c6916424a04e4a34aec5dc14614dda2cd9bea4643e266f3552290683d1f68bdf626e8509b28270aaa0889b7ea00584b842ee3c332fbe43ab6116de6c1ba7b41019e1fcbc47998b5218030e453e8706e61f09e3c67666bd1b8c1475049cfdf699459a92f5161f2f9a01cfc997bee2dfeeac687009669b20304fdff9f23944761e46ca488a382aeb557835b43179ac7d38f672afa5ba54cf45d8f56c00665f3a755a7296cb7332260aa79fe63ecdac7c8112be5a1c2f9c4d4466f9910e008decbcf2ff04835452e62b5bd09850f469761285e3a7abb69f02ffdf1af1f6ed92903abd8ee0010cadcfeea35233881b9d4ae4f394538f307a2d041378d452e5137ede91727cf60c9b15a3eab146aca686cdc9055e26d798adec30dd7d1ccd85a92ec6eed41f954ece3628e6902356990be901a84360e1813e5977c4981bbe1a4b73acf90d9a0806bdf0137df2fa602f1978af493603844dce243f3b19bb1ce568d28d9875090401f8618e6d370c02390e97102b862137d8d7134147424381140e46c7ec41c0b639242e3bfc465d4fbd2187276aeaa01ff4815af82e944516cfce311e9221fa3cd4b7c7741b8758caa8982b9c98cbbacf694526489332a08cfc50fd83b34a79fb52884b244e033ef45fd66bfbb11c6dfe10b4e0e14496107bfd168e0ed015e0051b83ef8fb28d0960aa0e6fd5c38180884af5d1cba63aef17adf328081f88e28399362dbb72a24c5bba54b9b6b1db68ce7985938910b3f604ba2eb0d13016cf9b1209d7392665f25f76fbe1919a64fb59a5a5e564a886751ef40b735dd230e3ecd62222ad1b9c889df19c4eac07dd47fe5915906ad3d176596771892251bec54ed75eacf6d730bae7d7a60a31a2ea050b4008414f175d52f6259f2ac863602b4c0a532441ef5cff358428b88798fa9d3a866f018531cc5f3dff0084f48df5ba7d150c8eb199b5f4cf71709c02795c6a07c9aea0bb3be958964a9d2cb12654605dd2aaf97b3000ad1922ca1b1bc2208e74e5590b7c4c1238f8d9d20390819d095f2f555fa0c7d348e5d327e472a2842662b100926745bd33fc6d3e048e0e48f0031199d53c768255ba4d783de14c132fbde8986a9def92c39196708c9f328fda4cee904c9fdab9f70d6b81e4960e0fd4f6d35836cf500182273406221f363315e3969404f27f072ce53f17243e3a03beb24b6a83b541703f20306302a6776f2800cce49269c7d633eaaa92b29172c89e636684aa1955b38fe4674f61d4adaafd67c1a5d46f22d027a6bb2e12c0680f73ff4f50fda455f985646eaf86a2e9eb112d55653e6b148133d84cc5fa73b6b1bacb4cf0fc3f77043cf87d9473cebb7f4976df98deefc4ff46dab05dc1f743ee3298db0c44db4b31e2f348e57908fe03a38ca390799809e2055a8360049e986d0f1fde549a00ec9b3f9728291d9f29f441ebb9380aeea610df1f95d2643fa76505c1e2ee1f05f4063682d828ade3585392474e62059d1e271a397f1d16f0252b2db6134ec1839d1e96a36f7e3a97b11ef7798385c2d4097867e26a4ebddc2bf126ac650dc9090df0f9b9191b86a246ee59c5d0a3b5f8c3f61fbff358d373d719daf6f91b2e9eb720442a39f1a3fd37a4d3f707990b4281de305427e230e2464341567f372cacfe89a93e517ce8089117c762c8cc74656b3bb1d690a1634736550d8b56ba8d11061bd87a5af638f7e710cc8686b4359751fc9ee355d8e71cf66c27194fd8b4c922bcfa9adedb17e80071d726f6fbba68257eadd2f65d8f9322ec3b9f5a0d40f6c762574ed7a41ac6b1c1710bf719aeb58befc61fafb076ff06f9f2b28c41bf19633abfe732265c27175d0322b395614823bf16fccacea5d9c1446589d29e8ccf6cef82a8d615bdf518045693163449b3507f6d23ae5060a6101aa0510a9aec228070f7b1b9780efd6eadd01f2206b6b4c9f56ccdc8dc6c2933e804c1c7d4bf070e5640016f07b0c698250867ff0274cfa17d06a78aa86cd81957c8c2ddea681b58b5fdbd489026bf00771e22bfd87d629f8c78c5428bd35becfa80bb33666073097d4f763f1beb2d642fb8b139fee43880ac8054a154bd82cb19ff02ca21621eefd1cf8d7f000fdd93161c1864a33aeb1d59351cb87fd9a409ed63fadbcfd4ee8ce466a43995237c4fd4c3e9dab85ba3c07fbc8b9553aaf10ba5cf1f769f5349547ba408aeb70c7e2ba6ea3f9369d1ce2afb8d16dcd40f0cb84e89b94f1e4c7cad2f38d702d43564f94a4fdfd7970d381a528e166a730ad41e653c16c56be0e17cb3a5542b1a17c1e11d16fa8a46848ba6ec23f1aeafae074989175a172b8e83ddbf107a2720ac3b4e62c8af74abdf4dbde33556c8a1d6c48dc74f5018413eaaee300b046489f8a56f7e95bd7833c6afcbd839f9409cd783e9250376ede8538a8bd6ca60a6b4b4d461894490b0481f87271c46ab34594dc3557a1b68d412b8efbaf703603665d3b405fdc86469bd8d0204a3ec20441356b511b74091401b28ed9cdd30b6ebf407ac56886f4ee097c872af27e6e97535f67971064120ac3251f3600a1ef10e9c71bb7e6acf24e01b341695af31a2b92744569f5189e8693e93296d9fafadd07d4b0a7639141adcc5daa0b6ab2f7c6056574742f9fbc082f1ebeb1be367cdf67a7763d6a4b3cb96f853e82526fdff1ad675682589b3b71cccf9f7ff916057a558dd7912b558a29596ba70ec73b99a9448a1475078d7e7ec7fdb1be347ee536093398b4fdc7d87b2e467fe1b530bfc1a021f64bdca8452ff96c35634401afb0bf63163732c7d3ca4af507b2ee74415aa97d6c1f6ab8421ad11b3c113af3e7b6b6ad4991e52873852c44b641cb30bf57c91dbb965613d5739eb801061ba67a286d6dec773188ba0daca15506536c35439b1b7a864eb2518e630605d859dda24c133e6781fd02b55a92e64e8a79797c2b3e2b82d684342760b1ee0c517dfe73e49d453dcb8dbeff1b6ca4474170ddef6f78dd5e3b6e78c423f52b6f648b43ed7b978dc863b84f70d5310c9bbd272346d0809403aaefc6473f994cc09b17da99d3a7a971cb31be0d93d83d6ceec17d5d87c62f11f522505379e5f5b99388a5dbae2d7276d5a6f85e86ab64e23937fe2548fd1b638230eddd1cb8401358b81c5427415aabca76b8edd39a9338eaa739eaf0de210674ac7287c1acd1ad356ee52b4bbf59863741517f8f816a63d33f9c89ce83ed743386173f629796b2bcac9e5c9e76445581b167f62e8781ef98a94385584e4a5a0cdb3d3f1bf796af90796dfc555dffd2c50babb296d14ff643165ac59adddb987f1c61c7f7aefc71e15a5b388e0652ee995f26b8ee20692192aebdaa887cc9ce48ac72ded72719866071b1fca7bb6b421a39d246905ff73809615cecd4c3400ad2825d5dae52325a7ddd7e2729de0f0d8d2aaf43d8f40154288eca473679e4d81eb55278c3740b875c1e4c5f0e0607467daa3ead73a9a6833f723a20e0e5e62ab078dba9156dacabb8d6d3a105ea3f9b20519542126f80d89ce892b96d46d0998e0cbddcf3394ab9bb1d4d0b26c9ed2c24c6083f7d4a46b70aa8f9f3c7c318cfb17ef8e53e1b6d7fc0cb0e438bf3e9eb9ccb969565c09427736c1add940d04ab3236a35ab0bbea8af60dd723215f7964292633795b8e05a398813bbdacbde6c1a099aa41afb0d60139a702b44877edf83c0363c8117e16648157b71392e5b7237e0a97e0aa0bdb03111d5449dcb5de149b1ffd3295af70da241d4b6c7d563a5d732743da5437da7252f7a36b950f97ad1334a124beebe56505e703bfceaa06be55ac7909483965c35a0c29bd80bd2ac3361f715b24b309749db0087db50f7603d20b922e59d62b7f10538c29a1f80c7de24ebef384ae3610128dab9c50bc5629849ffc53fe13c56027d1877cc884a0c80b7ae55e250fbb974097a4c8d573cb41d75e0c2a098577f9058ad0edbf9bd8b4d871964349d47353e80c4d06fd2ad26632164772cc75b8eee013f362cec69e5001f07eb3a919afa551ff30f3217b212790aa65ea681b041dcfe8a024ee3e27cbaade177d32066485c8de7fc294d5cf7dfc7265dbd03d51e4ccde170b31c48aadb1166f6ab92e59cdeae2910c917babf5e9ab5c8369c8fa480671f5a07b7841fc3a61427ebff4da43bfe22db76532c4790b6471fd31b54d5c44d91f23215a23432d93a321ffbf9423b5604442656285bbe8c23ac80d3a8f9f74a15d91fa56d114fa08571359ac34a73e30036ba063b2ad8a73441d01ebe096e0ad70f4fb9d5d3ca11a64bcc6443011617155fde69bb373317a39190b11fedb2bf700e56fd7352e9283e7c82a584214cd29777de576d0fb032985d98591dfbb8afce35eea16aa6bc5ede677fcc5aed4ab65f539a41f3cd03a7a7daffff8af03cee4303f439f0801472df8b49d2b2219a88d28ce9b2d899423faeea72c7389126a3f53972a2e1f5845c53322988eb63d16f8119138dce3dbf30ed180445c61f72de25f9a05661fd91f5f2c10fd69f61f9ce8b69ea3635a5259e5fb24c90cb151694913e2e61ced56c8d24e23983d0efd4f34261985ee0df105afafae220e4de14202d25c5f5306d3b76c3cbfe0d302d1588cba370eadddbb782604a0ba012f217aa74b4c5f3ef86fd0bd997a9115009c0538701ded12e15495736e0982b7b20e936fda6dae291d5ca850cd1ee178573f191c377817f4c5df3aa1fff361dbadf6ff884d9a079343060121ce2c64e37d0bbc3d0f20f2b6ad8af04b23acf2bae6ea60d0721531af8d915bb9a24274861e7f7525164521554b1be492df2f2254e4931def9a2a8286d2039276729cd9e85416250d098aec726a3ef0fa3c857515a3f0470817de36b1a18901782feb04c9ff9e9478ab8416c3657c7b29faf6c3f16bad43968744c8ac1944ca214ffcd5f79ca152ac6fd23bd414bf2ad3cdfc130b149770d59c9a1e55bc32c407c48a61d627f2f53466e9f5aa2dcd441861833c0e96befbac720b11e23e5db8f34e5ae03656c87e18475cffdf7e35c6ea054246dcc7483b93a61023e8e65d4d35922a2188aeab9de49c3d23e7c2dfed4718eafec84a8045d31a6ecef186cc924f540efefbbff647cdaf204952c9da8f7c17e72f7676ad7899e35a6fed04c4cc4179b4126f9a6861219908eafed14990e5810fd4170aeb819cfab8f1d96fe1514423a35a94c00c6968e00b0996ff8afa6b3aa030a5ca2a6d0cd6152b774bf550b3edd90acd6ae4545a1d5c846a3baa12d370bda66a643d7b6fdad615a58305af8f05945a783e0720b81fee86ac0ba911cc9dd3e23fca1503cffc1149dc00fde4d841bba2d78eb3f7d9dca6dbbaf40175717cceb590cc6bd977f0a845b3bca767ef2ad7bf1f0ef1798c5e68710e774c51e6e2d2d2819bdd873fa6017a1a42d3eab027e742089711061b1d84374b04e06b51e2d041e43b4afab42f9df36cf5e17f838843b4db032b15d51ca9d9ecd179962fd654559286bf811473560344c3b791e64008708af9903e1a0c1e377fd86275a5f140e98b0d84f756b996c427a8eadf4f68677b33770d2693918a0931a049c1b680ffed496caa5b30b788db999b9d2a4b36d9022727699dc5e33e3603d9a43e0ddb5d0582610c238fd8fa640156a21e9035f079dbcf2936f64f3c24c35bc3c35d96985f92a929dd11ed9a6ed33bb241255611ed2308b327ac59d5018d15b04bbfd8630af2451b171eacd86731299f81470f7b921d1683e1fdaaeb33af11f4ad5d2f1938d6eb8b44451a74f124928f823719ed2002a980d2bcb1a15829a559b45a74c064901531a7f9f4a3b39802eda5abfaf5cee949d50678923e414cdb9855d55397afdbedeae827536780e903ce11d7272c688feef6397e581274918fa9f50988775efd7ecfa6cc3cfcd89750fa8ee12bd8e8b1b805d910b761205a3680014a7ad3f9e9bb2cbcb03f747760f395b2e4a1fb1827fde8553f3f585f8b4ba3136c6cd7880081292c6c0ef96caedba846ab17edfca83cb4e4d80b638199d072092ee3d8f378bd23e4725695e22dd052f9157ac53fb00b052b635aa41cd8118727e768c02f0c526d5eab2a32ea3de3578155e5ffdfbb1291b1d7a751c345dffb25d9e154e9b18886fdf8bc2ff9d13ee6033c336c6def97dc3699e98c352bfcfd8e17bda30ae85a071f961a28bb8bae121f228b1dac247fd3a743df479df56fa4b35e0bf73678f6ba2ff256597e64abb0f946e98a344c57efe26530435ae02f3124cd51c5b966093b92d81fe47c6dcea791afa54eec10ac1c1b542370f76fcaa711fa900073442ec35885e23cbd33b6ab7f5857abd787fb9a532eda73b5d7685db07082fe10302b5fac6f3713494c64201d78da8b036c5d4e5c39d6ba81f1d94b42062b02efb36f99b93bfa54e684340aa9943dab42434fb00fb2f2a0484878ed9408adf43173634c4ef523e54560eb0794c67abcfb8ea7733bee5428aa892bf3d4b87a4bfd0e0bfe9f3a23e7cd652b84dda0f48e10b0050257b435b131ca7f98ecd8e1d1cb400cc35654548f281cf6598dd76b18a20e146447862f242c5a7b35ba76e6c9ff0d9c3d96b8a9f55232ec2f295b5258fa51124afb6ca32e328a8081d389a1f741f74c45b27ce8cfbc7dc2711632d23c05f9b46033dff6a26284a9dda4a9133656c78f82a31a4adaa9b37913d4021017fd3633f9ac9c1efd41cd5e5a84514b17d60a9ae60cfb77164ea7eec50ab62e1f4b9a092e1a356d021f0c77d60cc6014a40d44f6b93e9f10b5f26f05db24945d7d3dc28cb84511a1909523cb42daf762aa5d7b2487e08bca9f3e0dbf0daa67663d5b30b083e459df8514a9dedc3167be64125fc10bec5fe5d75db006393b5fa4d11950e30df3e3e63130f36f9bebe1795fe524506ca3c22ebf8f985b7cac78d69900e91d07ae6c2186812f0a3dc63c29dc74efd6134798673b12cd0112e5752654be7052109d7484140cd59811ea6fc204d7c68b7cc7a956563c11bce2e98806849fa5b6e2c76dbc819e5b4b290497c5a3765bb52fd070f5a2e00f5efd13d051643adaa3c8d0fe6dc82a2614d85634aadb0dac49e891103b650977ab20fa323466e3fc95c99dc724943178c88937955d42b739172b9987d26efd668273d5f07992049802d3de16b9829aa59af512906f333d41ee04613bf0e04db203908389fbd8b980f1e3039d335ddd92962ce34f4bd18b83126f0538dea56d0c0ec0eb4874f08facc96174c72340af42c413f3cfb84f4a026afab7c16db56b43a0f571f188358214e5ca50cfa5de2a1ea586236860e72b35aa6d8c5afeb7076ae8a768491f39eec6cb511af188f9c3caba37da0a6f9dcdae213ee09d948c3eb47cfa72f80ba8711aedb411c309fb62b11d5dc43ce515d71dc2ed9c0bde7a983191f8ffe70b20053892540d3b602c065db4d7c38a6aa9ce64e2a46e5e94db21df3a26a87f3255fe12f4ab1eb35f253c8d493c4af25f626a7d8690eb80d5aaf71fb054fd503403366a34ad0baf19a5dc0d49c37778db725d967459d18f290bc1b2ebb33ac5afcbb33caee1326c2c85c0bcd73caf845207743c6b26382ac6163876c4c5e24721d5de881d85884e31dc28dd53624d99d9fca2e291e20ee01a61f15458fb960e186f0a847516301cab664db478518af6eff27584e48b162752447447a4c4302ce1d2dfd3db8f90ea61dfefc63d50ddb4e044cb0ca7ca3bd9607026099558d2c9119a0a84ae9aedf94e92f36c1d6a4cc63400b1f9151bb0ec5b4e6afa6299f91508c139a39f01016c8bcd6562970c6b6a68d282099918e93698333c5c285d700112b2066d069349c7a16f21d5a80abe529dd38379bd192367e6c4c6682f3494015597ca2accf6d655ff90697f235c07404eeaa1b302c416930b3f52920f22e402a26b9d1708a8961be66bda62d1755a8a9559c88c0b7821d68ba4cb16eac6567deb37e5a9b3aec69335a5c92560676944beaa71bde317da62b5c7ae1af03c21296c731eef248c912e6b0ba7ff79ac79071b1be11c4ad34bdb81f1c413811c9b3921d3edf847ec2385c3db13cf528a585381ddc34859b406aea7687b85cff7adfc5019cfe030684d05d2b09a5795cedc2638f61c9623669430cd54b7f1804a28a8283530e4881b6ddc57ef631f27fca83a899c83b188cc0ed5655442ff362dcc68b704bfc221e7fa5f92208bdd855dad0bbd17","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
