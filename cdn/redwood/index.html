<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b90156534e2a057a4ad180df9be0af37e4aa650cc907181dd113365fd259625ada84492498f65f92327cb0d222af247b7129113d802705702ac59fa224a5bb6b3926b1fba93518ea14eb1a982ec3e7d1c737cbc716227203b3470542d1d6757a3f59fe3af6d18eb914bed027bca9122b3849418570d1af3ae7871f757d52a1b3f47d4a85b2cc8a365b1fd11fa6fe20a8494c12601dd4938d5a0298bc57c83594a4c4c26622536608184a0dd9196e1562fd53d6cb22356f53f164323cb9104efbf7724a700a83e4e4de0f9f7edcd440de3e01029b877150c52cb090babfc2a52a3775ee201c9ec8f030bb6ff1fce667b6c9adcb7efafc7399edf0e736992cc6043951fc2101a08e0af6b885439a9b406e037c3c81f4494be4018c5cf4ab130f9804da33c82b45f0906b82cdc6b18cfef6f3a4845187105863d6f73fad87727e6a3ed31ccb668d0e6ef3e9c0d24c00c808ef4ac0e85a9aceba2b473b5a88d87cd6efc22774e9932bb89fb748a26a02e0bbfca7f0a7c64bae921f9ed162f325859e398604bec8c1b87c2ceecad758ee296c46ae5970be604773eb09e43ecf073198a0312d2f21d6210e5b28a9b3c13f9d38f8a5235f2af3001b4b570586dbb809416cc38ca3003113fc2061adb64f3d80b30c72b3d9732761e60d0aa0e3cfac085c41f09164893eec7f1ac71ca59477511d8ac3acd35d14f39ee9c1896503ea696dd864b975a79444ba3f45c66de884ba04daff9d751e6197daba5edf887587c3cb952cbb9aea1d26e6db5d1494c996f89ccec6a71c19e40bc7198e6b83a9178dc09cdee9a7745b43a334be50d94ef7f85a4707ee3fe1dd7c92a5f3ae5a2ca72503f898fd8181c84790274b5534adc5eb3fdf3b814766e63197f0b5b25f5d24c4b4c3a9db2ef341935a9b472665842141603a7941a0e65150294df3940259d396a3a48b017fa3ad43106e647b94babfcd2176ab0be0cac92c46dee2508c5845aae6763b60d376e55ccd14e589cd2c9ba1028f8a11d7fb30e19ac2c3b09e8dce45ad6cacbb16548122f12ede053a694105cfa532c6698eedc1b42516425081eb9085f828f9629109bc99024c88f19b2ec64790ec6575866542ff54e6bbb41d8d2840c0d32c5ab7d26c40b42f9755a15d0be0773f18f697fe5e7581353ee3d24a1e4760a37f84ac66889a97266593c9648519c997bd12033b306fc6b799ad7ab4a596462deb91f491a09a5aef3682096487140be6eeafabaf7c02a9bb928d93cd1ebfafd6863de33a573e700619b991759a2c0c1614ec118ad793df8b927b8ff10da42f7924d4700f0ecedcfbb5fb089a077b9760704f3219826e571d4d9e808e8607a4191c6d8bce4f61e714d81be30ff42bd537fea34d2d947a4b47df96890a2b04de976155c4214e8a4e1e5dc661f22310497300e86212c2e6d9426f65f096eda0cb66c27a96e494e05fdaea690d9c7801f725b4d8c74c0ff096fe50c4a7cac503e19ebfc655f3289da78d7e76f64385cfa53fb75d502d1aefb2b037d853a2d594b24c9c850a0466b2786f72ad6fc85b26b7c477a4e84f64829495a9d12bea143ed2831948a9eb0782e1d806a2cfa5bc7997643777560bc8674e4674fd1e5379cad3b54d4c453097c3521129c1eed98c5045962b3ebf74f96ab79d2753ce7742a8f4d6d3690e225c077252fcfca24e0103e48cc0d3201366dcc5669b76b379caa1ccc91366ac5be71768a26c6d1c0a207dd37853b54a968bb04b7517cc672f5e663dbde4818e6d6dedee0a59192edf168ad86fe0fa05478ab94c0039a44271fdf324b55e92df80689d767d4cccac817983a7800b052c3cc6d38576320ba3bfa6c27028ba117ccb9850f2c27395b7d34d930767517843b03eb2eb1892731a735e0a2620031b548c44eb28cc9d44796a2c3bea264d1dc2d03fba0cf52cddae6f3be85c447a1f4c7740e543222605e6310f5270aba5f2c91fead0f23a1106b0d6548930a052ea7f984f2ddfda792b5477aa178537002ee6240658657f4a1fdb00ea5635a35564d06d307d0de25b26821c5477d6c7352874e98489240e8918f632825409cf6b01b3d28b1b54a60dff0c8252daddc321ba387af22651528bc84e219ef50b887d6cede4c6cbef249c22d497d1db4a67e2097f815cb517e2332e1828c20a16bdf05dc8b9ed28947a13ed0ea2a81bd93564c28b044bfe72b8a0bb4418c7bbc35b5b5d2457c9277317db87a90ddfa7b68d5c15644e4d486e0a6640c1bd9b0edd68cfc638a60741af9d7e680dd8046731b862f04eeac268e8acb1012e01c90b493904967604116a6852938742ae4b51f9399fbe976277a7d6a3a89023473dc66e2d67001a8d83010523e89f841d92c6a5c71d1772f75fc59bdf40daad50d18c234e55227901801ae577347c42028f2ef7b4794d73b27c50e21f6df72169199382c37441216159bcc10a1c645e3defc1650f0e0415e0bee564b187d99b7507250902e9f6c5861b3a8ddbf773141ed329e1551b03a84fc2938a16d928cc4b6f5384ba3306c8873ee9e9c8c64189bd2d1e6d5e64f61f2d1705885fbd2e0f289e72be85c0790f800354c2047a90a0e2f2891b91851582d892f00e6937fdd49e500a829b6c84c3a377b10f3758900175732d23fd91686b61cb0d5895a78f9c242e6b1630f075cfdb00755971f813c8d772256b477fb5edf5bb88a2dc2e55e198fe3b2c12fb2d23fbd06f867a2103d72dac6b7cfbf835813725e6b339dc67ea18a157874501370323690d1e0e53d635cbee456f80e2d380b351726c282e5bb7620010da5554be49b81cd5b41551c0f0bd2ea57d272fecaef0b8d81f782e3180fc541479d6726f6ebc444deaba9a2c6c6a49d861f2d69549493da5fe7e52640cbbd1db4aaf8098924729a1f9b8ce529ff036dda5571b7eb7ea470253f156148fb1a498d71ddeee660ee75ced9e7edf2f5cfac6135c729ef515144db1a0a92455002c133280e72139f29017e104063db3add3b49972f5621c6c898b31d049fb75424c7a9a75c3693d5f4c8cec3f6517469056ece7f95607087546394733ac8e75719dc7df10c124fb6647086389dee7d91e623044f92ad22cc40d31689b2887640a6563da8f7fb01c245a3da745004df053835be216fd61c853ef8c325b212fad2668e695ec7fcd05724b899ed25d9a00fb418e063fe8bb57fd1c630168a35d2c18f42c0e2bb3e76dbdc9fe6402c46d77138b6ab6941f44bb759fdd14b5ea5013ad7811b323fbaac5517c41848836b6fd0745418fb82bf486bd61ec44e61d5812c2afc3e06a37ede9fda71175dbe082e7700844fedfcfcbf2a143a17b775950bccba13911974e9bbe3d4bcef0a86a61bb57fa11d57291bb3d691d735621249e3d2fbcf54c05d1151e5a38788667bfddc2fe352e40d4822dcf61f5d08838a3ce3761f42bda38351a06f0b01197ad5cfa8a3774c95480ed7999a4558df686774c99001d450aa588cd578443be701d6f5fb3a72a82be203ce432dd3e06109111ac69bb9a9dba401d072b88f4c0ba27e076f41a5ff7511dd679f559f85971ffdbb31fb26db9ab5ed0b38f65807af2ddb7bdd77f0aaa9e33d88c5171f186982a6d2cdcf43ea7abeca3d7a5b3181fa3c7cdf57f804f8e1e01f461ab3a10cd89599375f68dc9309f8a6d8c8be8da0a48a41770c01e39ec16007140db4f74e610085740a53e79717ca1843e0afa35332f452e92bd9a7e1bda06c47ed231d5e8a200f191fd8fa5ad6455c5fbe2025e44928b6d7492df23dc718aaf258442e303df1a24961318a66b4ecf5968fbe4be48d5d8f453d9d93c867308899372943f7dd62cee4f127d750e0bb9c41846d1f9effb77182fe020e773b81e73e89d9cc946e5aeeac0e3d28b6f0e3e6217d35e91318d2a1baa355d019d9952929ad2bac74cbe0a38cf86b0cf67448fd08ae0cdd9002388d8712e5fa92be43f7c60302b4ee97a45ebe0cf445c4a997d072446e45e653d2ca615ae47f7564672409f0208b4fb0b05c06621ecc9b67ae22b92d03a72ecac7fb2e7c976784c606d0f220270fdd15fecbf38f84bce1e400e4076c5f2093747de4637a6486ae9dbfc6ed9a6dfa8998aa052299819929918ca6c22939fd320aa1dacd194766872225c2ecea17fec77d2e5165b2d70ded950bc93def98845ee3083e44327595e47a02dc06257f6f454050d012e48a954429c329812170c643b96c8e946916db2a2fc72a359365f8ef3e2d26051e8d6174f4cb179ca0a5d48baa659e9bbb6ece10b76fb8c5ebdb55e2b6d84099212f14ccb34df477b500d9e77aacaccc5e70920654af50ce012ee554d28d942b2d3a1453418c4683ab62556caa03e9e8cc5fdaa8f91d2204f36eba35677e0bc38944cc7332024e64993f107c564b378103aa93e027c72ebf3dccdfeb0e9aa33cfe521ac0017f9aba6b6f0e4c92f0f1975be77f50cf6cd0b73ee3e385e75f43895190593f8b3ad2b267958a0906ad3033973895143407a439c57f99484d56836d0125c02f36cee246d91716cef79bdbfcf10efa1d532d8b1abc70cb3e8fbf6b1d3c66a042184541bfb28cd45e5cdc962f09c58230a50d6d363f0219f4ffb9e484ff101c565b7b73d8f31da74017bbe5ed5a8cc83e3c3e92ae7e80c6be89c48230bddc925e82beda304b653063e5644249802215f945ecaa7f4bf7e3d06cf3a518e8c95a26cc0dad9342fce7fc73e9e9677e38518ae383c222a7ddd54aa00335bca361110d54a46a579382f5cffc4ade5c01003d1035454c4332dc97a6f82685a8f4a877ecf14269a31239ecf68e7f1c90a874302db535b8e137bb7d759c2607320346476387eee99429487bc4af06f63b0b0bb4d266c44ef1f899add2ce2dc069ab1deebd2067c053fc499fc4d5d5bc3433683003a05e3807880ef8c952646f64743d03b1eebf0068e90f8ae4809f77dc293e9ee169650b865953ad7cf9de80d9ffbb079a5307817d0d1705aef23afaa5d5c03c29051f68004122d8ca971e69f001ecca67413f107a8d494567280d7dd7fe8624f756345bacfae7c3ad938a573ae89d93bee1a2cea620a17b03033eefcabae47a868e0eb9230aab68e27922d3cd5d3d15ddfd63f47deb14772791c09ceca32565e92a0d1984926fbe23fdefc543fd0ef410c6d50cd6ca4fe0590879d6e2b50931d99343d0cb1b1ae7af24283bcd185e869caa35fb68aa0939f01e89e15296d6ba3f3505e0f951df7ef7dbf7997a2f02bd3a9622a60d0083677c5a460938efdf6a14920e1f5ccb4c68f0df998666c6283e1e8c162ff7576c2c1f5e813fca96e29c6ac1ec1adf79af0e99ee394ab9f9e5160b02b7decb7760607c2da1b92cfa95075ee0558b86b5bdd5471019884f5053f8cde2b3ecb612245f50d71184db44cd6ca5ef45ad0c3699117ed104b7a1d1f6f01781c3c0aa9d5b252a4a3789c8f9163f6b5ad32f042d16d771db68e2be2ad2b4e18b093253b11af0d0ca9d54e1abfb251eedc39ca062ad7202b11e8b448295b5d1e5affeaee0d01c51d7d8de868df736c13ef684eb07c30f77584f2d5e9f61e85b77574f663f5d20a7c545981d37505a117a65645d446460a7294fa827963c5012fb279f90bcd10839d5a64d7a5fff65b9674b035b30a6d330e0be252e5980ae20230bc9ec6f2842809ad5b64f51a8f4ddc3eb86de03820ab38e94ebefc995f1867f39073ca9bd91833feaf273917d2dfe6a2c9b176999c939140edce23aa4d6e24df599e9fe197e10e0ce924268abbf6118c145237c61524ba96f88c662841da75a9dd041b5df50ba44a4f8f489e333459e8585301a26cbe43ccbc1a71f2c0e23449807abf4c4c513da3315c07dc932dd814a6a5f06a0b94795eb9cadbe803f3321869cdd2531b4e181cd6b19028e83a6df311547cdf913b9bba0a8cdde53f9e9134b1d80adcd15843922972aedc4f494528811b56d9f80f2ea056c3ead5bf64881b9a31ebdff618cdb0626ce028a1c51a289d00a28385ff90db8a6d5babf3a2a5de091d5e58e5d2ab32de0a8000d8fd71b93a6676d55a1dd505000c64608864c649bc661de75277787dbb91dfeac481471f20857a1dbdf0e8e0c66b4270bb621ea4be3910eaeb2b887a6851f1b7e73e1ba850d50cdece437e87c5f5a29fd46ae5cf0e1c7f2aa9795b751512b456f1084a7c7ea155764ee3c3bacd81362793440486dd3e6d84a5abe67551980bce6ca58e4833414416fdfa9740a3fa6de15e66bbe8ec957e12925dc2a82ed670e0ed74d6a61285d120da656223f4cee642206e9aeeed8de7ca49c527779f6844f6abd4c9f3905d67b96d706d94d942190ba84e8663c4a3bf2b6647ef7ca19c4636eb6486c1626fee79a068488618bb14c09d0cef6b3a8e318719d1f6399ad3fa490912962ab088284a60dc8dca3bc2d13c57abefcd06f622030d72217ab3d05e3492c28b0a57842dfff62ab7c98fa169dfc927b7883e8c11a141376d014ee7fef50ee034c49b1054d0dca2ff16b0d7bbcc47ef9ae5fb4a7ce3e52a270d3218dcd341feaf809ce9687b67304983c8b116a3990867a95e6b1c050b6178d59efa107efe557db8a816f6d72de56c89a41e0ba5c7a7324fe240d2d2de4bc72c0950dc6b27e7146851ce64533baba4181e0622221751e4ea1ca53e426d53c2d606a3816640c804290907441142e742b4acd4b4c936fb3f1485b043500e9ec68d3d7fabf70370950434ac8147ea9cd3bfe200831f71affe2b6645bd7c7501f8bdbe810745d6725677cef5d7cb86dfe936e6c0ac57ce8063831382d0ef0a0ac6158468d3ca6c3ef7e02d86398ad4fb3dc7ae32f4f48ec9f2430a086f66bd1dad86e04ddf7bdb92b1fa48d438d59912578d65ee26f8700b062a00129b680ce86419485c92b6986e5d1ea72043f753f622c9e5db725216ccdb6bc64f8a9db66e24179346f101b402d477cc06aa67b5fa8086367caeeee701b15b2ad567575840b92e428c36b1c5186c598e3ad15466ae550e325e222d37c17b4e0db2b1a810247249aeb07907ef29ef79af00e82892daad5fee51f01afd15d3fccbd501a19a83b3a7919af26b4cd05c5f9b34c3bba0cf1a7e2c62b13db900b26d25d19763c6f0c25bdf9d542ff1a60dec04e366532a70c92a5eadfcdf8e469dd20232929973786b16a16153a342e682071fb3ea35050e74f88a9170a44325379e4a46052edee8c49707acda255b8685ecd3af7f20a288b0d9786bf9e01eda3a34775397a3a3454056053e3ec98633c80b532e3911264311daaa414de1948f70d82f03913dcfd72edef273ffad013a767ca94c8d59d1701a01283c9d42323bba17dddbdf00288567e7af50ff3ee3da53ffcf2c930bd76e8a988994fba3c4700403c5b8c4a0cac65d5a7d3198bc42cc4efb1c1e6b332b0d05ebbf4df07aae6e14037fc7a06ff0458a0172978c5e69d2eef95650f65f2759690f0d32334b5c4d013899e735aeb3f5da0db68c579b13ed58f7d8e4232c9c03530b2b81de331ddff8015f32902ed3b096092f33a39b25588a5601704d7c7b8abd2bc0514449cdc6078c5da338bbe024952ea2ef5b6dc008a20238ffffdb6417dfc6efefdbfd897ae459e7b6b5abe3d4319ff2ede7a8fd61fa3ade6e79194fdf083e9a3a06be607a409221b8a492cc4be490592f14882f4dd3a87686fa16c828098d7b0dd8c9801852faf721cb3fdd875bd32c0f33a4ed24e42391b9fa62d5f4879412fe0eefe73a1646adac8044e533a7b7e214ff1e9af7a8dca4184c006905247d37a51d51293dea76bbb878c434440ae0f650f157976ab6593da071ee885a7d83ac902c7617850506f5e8f6759d9ac6b15cd1d8da8418840671f60b3c299d50696e6237b6f5c6a04959629c7b14e9c7df12de34c32933ab8b1ba63c53b98bdccdf46a0c1f7238162a64965c8dc4b2f9369723d79ad345a043fc4e8a9dedce38ddcda4ad4ca657a9a1f63270e554b90483020359c19ed9404491acc976680d10f676e0b5f4e96664070401db1e446e4a342423aafee4cf7538119144c3a1e1b5181bd217805deed966aed3b29ea67bb522a0a154e6b2a4fc653c72971063c47657bc13084606deb77d16bf1805d581a87c96ef3aba65b820cb6617b03cbe5c83887a4fb9d2eadfd0db48bf81c6a6c9c457b8e146fe9acb27c6076174514da633e06e5e0f0ce5d5ee59bd162f61dbea0158a5de69950248537c109cac13f25c2eb6e1d1291a3835667acce8299dc5f9365505e923056f1c39a4def7fa47c32c1584cec00b7df711e4c03dd0f6064ab6edcbe7bae3befdcc968e35e3bbb08c0cd61ea03bc45ba1ef8d426678025c1ea7a4e7b4fcd16361abec345cc979f1ff28fe9dfc45d6d54b541e64a4896f74c26def33e3908515cb3209ee90534d1cb93738066aeac83024d9374de81c361f8c7b5ff8fd99d0ae640453e799f5b9a062a286b869506ed501c3d553a34424b02270aaad2f91cbeb7709aeb88751ff4b66da284ca866fab0823879f5ce8c132db90a6b6cdb9e8580fd0cca60661551ab3b690b5efdf7cf844c48be8205e04cbd078404245f481c653a48fec0d25ed9980237d609a3bbd755dd29422b1b3cc9cdbc5d1fe0aa787e4dd1e1e0f9a09caedf430c55deea7077ca9c36a235c2868531f51fac7e07493037feb22cc8393654eb1010179b93adf2004c5107327e2286b54a0e2240bd53c21c4312e54fd002f0b65fe569524be32d03056c26e897468481f04a29e8a2e1294139ae4d63c49eafc5a1729b1a05cc651579a5225a0df53a2666eec910de03c60fa9148ef538b0a79eaa03cd31af52d67e6ad81ea12f8c1a1c7b98997dfa220752bb9bed98228af522d8d7d0176c1ebbaf08a46a7385eecc525c1d41a6ab3542087b1cc9f38b62a70219036cc670f4a5c59d0826529d3c5fed6c25eac10e7e1a1809005a4221843e4a47730ab25ececed61614f823ec78b29836ae146fb9a6795fa41a56e62e053bea5cb3c7ca4c1dce4217c82ab91ef69095754fdf02b51fded5ae67144337339afb8be21e5dd2adc4342a99cddc6605fb77d1628b71ed8a98b006347fdc7ea70876885347a56329a278579431c5ed275b8ffc9116c69173d15506926ecdf107678f16bf20fa281614b8ac2f7ea6fbc62f3b101511a03554b535fb5b735366c8e6eb6954f0fa89fba8dfbfc6f4c40182fccdbbd6603255a7d5f1b0719c0b5d3730f7213498b77a6e583989a1134396e85874c063249d6fc51207374d3ab0d8146ae8d7d9ae9320ebb6e5b9e5aeb8f04e481d05de807416ff4a9696bc79b1759ad1372e366234ac6947cfd196a8925f83765a1c568d469809eebf5321e6f60798b3ce638792926f3d4061c0617f8f6265b9c0f2e0ca4c6001004eb913d79e0238f4cd706e0bffa0fb73edddca61e0cff714a3e0882f6ae15f4cbb722c7ab9b7152fec324a136121b9edfb93e92f09690e4f0a781bfc09f8b2b832f09103c2f55336c7f7cda836ddc089cdbb8059ccb25d80dcc74ee8ada3e0a3c0fffac9627f875e73b83167bb11a9851d79e49e4afa25569c4a5eac7b4f3db7b3030f7eee6b85117cb21677185bdba5e3ecad02a0bb3232a491da0bda3c681081e68ab36a4df5c5932340ed9625b551a506ac4ba07e49d42d6db794f369cef5a3e415fbbb00a33ffc94209e5f9b1a88f9bbb1faed762e974c3ba2ae75333a314f88b3d81ace242e97e7440584de368c7d87b854f8fa5a46eccf2338a03b2c2d26127ff71001e41b3c1323400141ba45d2cb9e56c087fe173f10e580610fedbbe689c4059cdca09722f38e3b827340a2b6a51a8ab90216f0c2ec8e2bb2a3e99ace19f0a0ea316c18ecc8e73e417aaff4dfe780c029e682c7e5b8bd5aef680696069e30bbc8a2686061dea61d40483b746b86b20ec198d81b9de4ca52616227533749d1f6aa5d203cff7c1da0a8c6e98967157e6210bfce3d8499b266cc81542936c50333f6e176338b78a7c73633209604d1e4c7d71b024dc7979d7fb20827e966315d30f38973cc7b7223f05cfbe118a0685eaec6c34320909faa8ce2076b8915d8c8eeba7389f02a45709e2372761bf08454f0c715e6cb1d2dc3ececf59a5fee35fb15809edd8e9e3541599a9cc4621e37f3d850c17f3186ae495e19aa5343adfa930bc3377620b0bd8880452f0c7ad70cf1b36a0ff0f96c3716f38540bc79fe79f17d6c9b561daf2b3c15bdb348cd80fe60128d32c9a355e927130dbedb2c9747f704b1619ce140fdbf1eab455f34626db803768f69647f37a0a1b6ea6c8ecac1d94e6fe6ff92f90be8d2bedaedccdf53c34ab80e4713c0ee24bb4c1c1dab1bffc6e4491231cc57b67dd6c748e76dd723e70edd329c89d23d9207f2c9fcec465fcc751a604c682dc76274beb04188d27c5d553ccfca5d7ce4f5e371a23a72a10535644dfe7fd8836406d06d51e1252605d6745ee64cfb0609dec064cd45e2c2071c6d4ac1e3f6db6f840cd6ae8a74f69d58a5517249c54028bc67a17833eb7048bca2a84763df44ffba8520f0d95a57ace06183fbafbb6df02fbb0904d4dcc0b43e9b4d101de0c1186bda702209d8a78e22d63455fb443f5d1287f5c9e15a4353237b9ddce9d6d61cce7830ce598964dc104c91ed1ac449e248ea984a485bf04dbc95b790efb6b1c06e3448e5d822492830eab25d6ac96878437228a393ce5a303816554ead067243d335cc5ff9be5c5d61fd936ade63c24efec59b93e5b8ca8be18e6aed574e0d1a4a81b11b5b25f503b54ac337baafd3b2362ffad6bd194da6effe60cc36e5025469e35dba9c458a802dc6425355d3c0d0598c4cf47ac0d8763f346a506a92b3a01440ed8ad1fa641c131e7663382a978cc401fe5ab1b1b8bf46be3c4021018f74301bdb90f90d94b04e0d538c165f205f5d5df6a452c66f9722bc036b47eaca2452fce2426b86492c24f029f76bb6b0d475b5c9c226509a7097b4e5ca47ec6ce9b88dd8aa51aa565b965840b837297c2020dfc029c47eb8ca262fb5767f2b861c8b871946e346001c4d2e2d5b6bea6540df7626792d8da55c6c41d7fc57800760b2048d5c7b188ed60cf8fd0a5595ddda356edc8f2697c0431b6558d966824b0b7d99b46a14001dda2dd5f1d251f03b7666ce7187678270c37ca8f3a5fddd01979ad052e28dc0d7a64de90a3d68b4dec68d8ff72fb18cbe96b080bfdb16ab625dd4cf41d264361a753e55db5f97f0d71a2c0ba9faf611a466a9d782a341ea1183cf3d5f1abfc14de7d5e258539f16992553016d5fda1731219777c6682fc75c6eea2ab9c6e2f102eb2f35df86bd5c70497a6c0f64819cd4531bbd62f22fecaa9ce747a2562bc7136fd6cdba5c5a8818d68f13d965d274d43bcd59bd6f3c6a3486ed5efe93ead585ee28c4866e74eedca458a91911fa1b4523613d8d9dee2b0371d8e58bd76edc05dfa632da52ed66c53d3d275162ef59679ed83acff6b71c5ac2a468d5365a90a2ec0bbd3557c44f57a7d2977f8691d1ae3af7a57641f65d2b9cc747e20b28c86ecf000a76b0ec36fb5430b3b7a8fbd56a2508e60db0e52f1e56a304b260d20bc0a507ed7313c880beeaa61ec04f15d16189e63e8bf91a0c9c767041c6ed63a96c54c335bd2b07b2fde3fd8be3034555009a13b66a1177d4293a3b30c8e9421630e2c5f31a9d070add871f0ea9a3defdcae4bd162c4028a246b268fcff7ef34f95fdd72ec1b6be863b9d889f46ef3531fdee251052d4bf061f39657469fe6a92e449b17a5afdd7c157daf86842f2864a8e2b03cf715f8213e2e1301890e8a2869541fe11857ad856cb3de25f016b838cf997174ea009603934c4649aa17c4645a11f25fcb591b8aa7fd4b13a40824561302223d764ba9450b418561507d28d71d2ffe26123e9b75905e2df022d5fb03825596f9ffa9f8a6a2610d4529eb3c25cd44d972eb4b6be0a848031096140c019e4e8a91ffebe6cd73df258d06f52ada63196ec96aa90a8bb3c60910355435d3f5482532be97c2626cc8805e6e9cd46546d2e6ae21658003ca3e788dcc9c5ad004164f97072457e0c928160c2ef1071b7babcce88aff81217c9ff3dd6aa19e79684cddbf879d8f433df2b45a4e31d5b8a7989fbe9c35ffda06d9a865bc31065e438a6ad1a0f45dbfd2ffb55e3b7ce855d2e81554972d8c67a609c851e3af927208bc37be939b20197ce01137b80b642da53c7f52a463c387368840fde36250bee431f8a6ef5844e0c08c5bc18a8036504f8170c33802eac705e77d4875160d251ee366ca8bdb6b69f5e0e7d95285dfac7a032341a54a3ec682818e432455bcf81180d85ab2ecac6fc1294d6eb1e24b91e7c8d1adaef6ac68b71dd6abd24e7d1ffb80d84e4b99b255140005cc7b2179a4852ca15dac1a3362be71ae43ed97975b0f5be2927406ba77115c2c7e935a841470c194fe0f9dd32a6a1fe530ae4f90038a708b434d9b56d418ec60ff56fe861f7fbd94b6eaef215149372d96497d65c60261cbbd87979b17d1961d856926e6fc6c1f8185cd9ebc8592fadc9e16f322d6447875a8bb9d78a97683dcdbe29a09a3da0682a22e8bb3e8e682c1e826cde0f77fb19c8b20a53c88b2daefd7a8889aa66d2b3da642561551e3b52ace1bc4d0cef805bd362994e292ddf71b8387ebed360d4b0202d5edf463fd4f356aebec0fb6b2dd99db6024b871dbae4a0c08e145239cb5d1366f01200865fb68731d8377840c592dc3f21244ffe2008ecf1bf2aafee1835abe2e4727748b7359210b8a098ccf1ccb94d00cdcdacb6116d60ba044443b278b395b429ab14181a5b22bfeecd8cfd909df22f968e0b925ac4475b9b35beef6a978d203465d1bedf8bc5d15b85477b861147bc10d805d4e456c58123840bf42061da8c95bbeba6230a991da88191b837a41f0b529560914bc3de8a279b5c29b1a3c75754e1186cfb5f3cccbed6613e8af64c63083e78a3e0033fe5420e3b9d67c0a57e7d932381118273ad9cd31ccd77cb12bd879bf1d28ea9bbdd577eb73a6bed9949defd40f9bdc2cf67cd33f7dc94ea1b1f24344535ebb002c0dd79c4f2cdba2384325fb3d5a5c7efae4cc05d99dd246f59c2f2cb2c52b9c464ae879b72a561d97580ab939c45e383cae0fefd99b39fbbb2224af34557ddd0c7ff5c1cc612d9f87dc541110fe116c3ec2ee180c8f374e255834e4d867208617c2b3ba99af975b32dddae4b1ec15f4c0d417b49f7c38d86acd82e7920a5a4f218d9098a35d915814e14912a57fde148eaef7a55a1eb5d2a39bebe8cd01a670c967a26eb5708bdc60351b1991be40b36e4eab443bb9a21e1081ce1c03f2ef04a77351b5d53e47b61bbcdc6821d1f12c792bf443c9ec477abec747324af9f751edbd3c4538592c8e6006918c95a1a29ebb0f3c017b89e9930e4f98474342738730280042bf6782d38fab95ac6f7c62da32bd089ff12d7178195e40271250d41293d92aaa07b6703fd5cef83575cc626d6a16ab1138f3e0bfe6bb3090557438504a236d3621c0e477aebe0827d47b65306dbe9bb65b5675500bdd26d11f6729b92a75fd8994efff9859d48caf2c44bd7d29d9436ea3155706b3510f3b78f479d5697bebd6ff30137ae67764b6265f3dc6e6ee80f6e086382d61043edac39ab41cff4ee7926f3becbf5c80749bf2d6070f75e8864e932474947dd5678fc5c733e16bdcc4cc6a421857b0596d6da6136eaf52ba1df273f6a60ee8633a83621269c91f49da9e6f1843c63bb42e8d9b4453d79f9cc3d55e73b7553e534d70a1bf43bbd41ad0742aad5364dc1d3c03513f900fa09949f039cba7980759b7f1b1f19b8104a1a394c017026a3efba821d706f60dc95ec015acf8eb74eea91e015877f87b499d91339522f100ac5af8c9d0c10e6e6e83f5793b1a1180071dde745d9128e177ba3f8396bbc49c3e988923ce7329f3a6c1ef73ecddd0312d52b1ab03e171bdaa7c770b5cbbedd98226b7454be1b7cb0e77eebab36350227b7d8558bd93ce539cf0050396aeda765d555883bf473346e6d95b82d18c5906c9793940f024bacffdbc4c0fd54c1371b9ed2511d0f33dd987051451622ec6a52327011e6e12e2f69fa313c38bee14da3887980f81dc97d580f33f48326eb350f38a0a2ec9f89fba99c3868b697995703a23625aa3ff5619e0c9b5a44c3156185ea195464750b045ce71e5a393679f221b3f09bd1f99fd807d67c08b2b9413c7b8051c16259c3379e6854f76ffe4865a331250d825c2f4582d01024ee09e41b4315a438cb8a12791c18a0fc62d4757243c780628a0eb22e8c3359411e29f6edda45c6dd6bb0e0a903f2150cd2c27c81c7f5189249f4c6d929a2dcdb11a7ff2f367148eed0f255b62247ef7a991e88f4a5c736777b6a86a151c27e3a45724ee89461379be90eb99813b1ac440fef50de9ddd15d236ebf6c0839cbf11f2757f1fc657f4b46d1e9f81c09460964243eec5bbba1e032a8065546df2432deb7b43331a6fed5e36eb8ba8055c9af7b1c148241e18af6e230bc89c05889cc260bacb7e38f051c239e5b8b4a096fa39e1c81c9ecf8288d92049972c3fc840926a5150e6343e4e030e6396db398508e3e77f79c9a24e9a3deea4017e2e42cf7e1ad1f8858fdbf34d5d3b52b0f8fc034f407cf370be933c4ddf38fbcf2e470b26db0be3e64d71ad01c133c672a8c66c303acf6c9439b9e9b790338a76cba8741ff952cbcf25cf45c891b2af7b0716d88c1461902dc0f42d69055d6fab969b9a6d13b2c42408ab2b05dc5467c2abd7bc5498f35d46a27fb7f1f315af867a6e2b2d573e26f48d011d3c4cec2a2a42597bceec72b74a549ad84e55b0a2bea1f2012ef3f0739820f5d1008e3e0487ead4f91ecf2d84b76f6e32a81024ab3ede25a078828c2e8781ccd6b83e34a322af955a1a3dc7e70d4c339165ddfca5da68ecbdcd7409a33c577f0f94d8fcf7131b07bd627265786c744e8d46e7cb77a0b22f7e419e50516009e1e9696fe802e1516110a840d7067b394501ef4bcae0d83d09a38937d9bf9a6a6dd42c7ebdb4c372de02446538323c004f8201f30c1f58f33d50ec32dac7b8896d90e81a4502258aff46abc5ed7fa5efd805396ea31b2fec9215f10169bf61c790621f77a543f9efbe3b445336965b8619a7a98a3bfa32091f7b40b27f5d7eda4a825e50cfccfb36a4f63c787f7955fbaced62f70f0f446ca8dc1bc225cb1ade1649b047c4cdbc6917e15020c3264707cccbc5163443820e554bccda01c64405b8e8a6a78723d6659558ebcff3f6bf0e66211b93480f17a01c6eee691493e49f86d49c3f58bf0e8b2e9e48d13ccd05f4e8a3eb608f362d80a31511cce576410ba96933841c0f01554bcfbbc720ec06c979a31975538382b8872427b686d2a4916ec8f7232269503f6a254e5af488ad28ac1467cdbeac15d57cb667aeecdf0d83fb0952933aac37524b044625bcf46ce9357419e69e950b4acab7f69ae73eadbf84feaf2c5c0df33c9af9ff5b10b00075edd1bb2647b5ff883e3ed136c4b1007588968dcfb3f4f9843cae4b32b5e729cfd565512a70ed24743d283e5b4acce33e80cd9b9022e35682651b08c39ba65957c6bd1003817045a654ca3618cd1087efb7c15c720b5b4657d9a56794ec7185d24a6c10b3c6d9e7431c47c403c98d580b6f873c8dd16c2ea006c1daed181db07cf8df7dc44f00ea9b58b399353b741dd29593f654a4cf08b127886893b13f64de0814a2917ec464e0d761db675d30910768377e7a6627f3ab380b4c463e118853263f5f7189f70cb685d06707516b294804be1598089e0b84f1136d88713b1aa4e1b64176ea6dffcafe80c9c7a5ba9f9ca029b6463d0574ba359aced793cd30b62ad6e37e17c350c42619a5197e0f6bd73bb54809af8af2b1802243e29fe8946f1e213f47199b2c53fa13be902c89c7497a7d4a612a20d151e0f031cad0ae0ab34451cdd549ff032666fc5311b8dc0231d45dac0f8d92a941e9abc11169643a25ecca20739534f0f1fd4efc7d46cb46976e8c4ac046cb17941d28f0b32bcbfa5a375591f901100e82124727038628a7568741d29989a8cb9ec72f6fa1bcd8635e678b771b644581f5f43481e352af96af873ba8df3c61da4442e1d81249f2dfba19a7fdf6157b73af936a3ab9732740379f18810fc3361c072d4986094b4e8a05105f2a5c6af594fab8722c1a5ff6aa2164b4504d1f1b02ecf118e63200dc86dcaf1674715cd9aea29cc974fa9b9b9c99e20b316284975e9a60f81b6a8bd27307358783f0c4c9bbffb71d4f161546f041903c30e58292ba5647d6e4443146f0cc4f41a5af770d47376856ae1e1a7a47c9a630b459c0018585aad5eee423da407429c49620b8d094e266d12e0acc7e16f0dd14ae96b75819fb61c098397d347a22d6dd651f4c7417463e6849d80e163dca68538d4824135b845b70066115e6d5e4ef4e112dbf81a1bd2d86ef9a2a14a682dde468c5edfd66843f6c52dc2fcba08b39e08f46ef05f6ec1e35c6e99c09cbfc9e2aea1c0a13ca1786ad6006f568f06ce3cb29ae931382bc91d639514e6685d8945e07b5b690ed5f8ce9916f645f2234571adbd383c4fd23f2f9a6ad7045e77b5cfa82ba9b0230d96cee727198d5faed19516cb75788a6979bbd9bf199dca3a28aa0df9fd269c76c54bdd03102ac5697bf869367263804f261d5e669b0efe1273587b28747a325ba7b97fbcaa2d15511ddc29e9133148f466a3fd15316aa3be027e99e1cc8d95ac42e2465d3256c6135955fb0a8a89f7f393cd7568ede5f9ff3cb817bb6c1d88d2f5ac2967b11cded8ff71e979de203d7b5c71495637f498b995f0446a60b0f984e8446d723137664ab766f89ffc512b5c81a47182005c80244cfe82ca994252af7440f247b85cea647be1fe22e76997c7d5e996859a0fc4d6b92fabfd1e29122a3902dd504663e25e8e596c6d828224bba88741f60708dfa9fe8a6f923f09d7756c3769f42142f0c766e01bf10bdb3ca981fb6118d92cf198459b30daef03d4d70f2ba796d60e94d37daeec3c87283e49d6083efa14b8b5b7121135e54915cddbe573e2ccc9cdb5debc1d48852cda27cb6ccc9c34c72cd30618ba0da02778edb3248632534b3fdf23f43a1aec4a2147d97521350dcc1a4fa82cb17e5850382f1cd99fff461ba474a59ec1210b1392a13a29dafb0c99c23cda92efefac01218efa52a22753bfe4af2a9d37e4793d794a131e7f07ecaf7fba2a972c19c9566e3bb480d35519ff2534160ad8b86e2f9eec1f7f1b9b0db170a3e3a5cce29b5bf8c69d3819818f204c66a3088c4f544268d352ec3130b28cb2f4f26174c7bc42bbaaa1969b6e8434de725786f11095cbc519d6cbb5e4811f22f3071594852d017d3216305a85f8e9c4058a42307ce850a217699750b6812376c6066a755acd1e16994872cbf68f282257ca93126c70f7e6842cc7708cdd6e84d77baee32081e63b44ad51b9ce89e5c0906147bebb6d6756b6e2996b9f2e9bef60ec084482f4023c885ba1485aeb62f95ce64115141b539eef683deb0a87128c6d77be1a0a76882767d6341c1d5a9bedf33632f2a8d870f768ad048f723c461fbf885acd0eacea52d091cf5051e4c53b7fd985be9e56a610ed47f1e9757711a6d2073ad7cb33266ffdf550bd4b9f0c8cc4486233005bb00da7c5c5f0bceeb2f474441be525bc92bb6ec4c7ee31158952da2ba8c2fa37bd1bec082e98da448c812ac2284a9684d11faf8957176f7d9f034e375857d7d3946cff9e65ef3d3dcd059b31a472f0df2f5aa43fea4e74c8085f63a780c7732371ef39f4c05f2fa1b5bc75732f9fadae982c74d2cc3bbe337c4e6e02561595b56d72e3e4f9a43ac20bb8c9caccaecc112c97ccc9691a91fcad518fd8cc0501cccaa3a6c8ef692fbe6c7af3e25eca701cf28b2e45a14f7d256b097b3f92a09f7377a1a0225af03909f7e4b3df5e1ab177ff5c4027b4ad5c9c9728f018","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
