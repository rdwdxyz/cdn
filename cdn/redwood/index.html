<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"04f3119b8fc38d721960ba00e3ff29091a3eb3a310e31fbb7a2a98c46799b1af573f772b0f9492460177a4f15286f4310bb0dcf30f7806f327ef8baf18130d027f477e4bb0b439be03624b35d6080ac9162e4db77a7327bf90c9aac42ab564c805561e8f9639f3ae9fa81efa4c91b7ae8aac2f9dbc3473b5e0ba7f7245b592c975268d69a15c1553eb56a4218e6b34de606d00cb8a3969f80678cafed00a2c1d7c26485fde8ae922cbde80424554a561134dd60948e4ba4fc647adc22eb80da36c790e165411aa6b14af10778386f525f1c4da8be859b367d847b45f52b6ad82c02d07f3f9e6e6d3fff469228fd34466618afa9b303fa784dca129ea3ea09374a19afd3502c4da2172394af281fc6e9dcc675d9c15149488b98b60826dad316ba55aa72e61cbeb9ac6c7e0e089fbae0f5cb7fc42739bc6a90310dc9e77928e1fccf06d311bd93f8d54ce383b1e9f2acc9cee898f526e6d6114563df2aaf3fac3622140ede18ed0f0da61e6b4df513c7eb08fd6260a484441a2f5d2f26c964538650937650b6801d8242846ee0250848c42fb93af179491947f092bd2ce215b702e7bfef49102881460ad5af142a2e20cce24a2a254bcb19589d599a152ff606ca4e0dc438e4b9717c8631041536f68776672a433192595181bc10dd32468c31e9f7ad885ada15dea843c8537de9666c38b1857117222c3e55cb411bcb133c77f5ea99d6d1f420bee7d3bd9a19700c688f18bfa323f15a72118688af28f3e62453877b7b0f949112773c961567423382da0fdcb2537e4e8b400fda3e8820af5fe86399170100dc3368a5f0a06501babf8cc7a9aec71d515cb0bd1d3ebdd1d675d2957826c365ac343681931d29c200a5cc008bab171e0fcb4ca5f17d52df3faeee92dea3c576962958258990b1b5fa6840bb3fdc74faec59a85e8bc86f5a641d0c759a3d038a349a79230c09248bc42041ccd20590908a61501fff00ee1401779aed5aca031991c830cfcd7c2e04a2f38fad16b3120dd47d3d61ec1117e80d02408caacc558d977769aac7ff00f336cc07bbd0b30417775efea19ae043d98e7e54607d2c17769fe44c437983026d74d9f714e67fdabaadbf3622fe5bf5b98d7d2f550fc60a5aefd8a27e73d78ef90fcedd48b6f674e91c1ad660c192ac642623fd15b67a99f0a35decc981f678d128eb41147a0d7c6e4c614fd0eff6b48a095ae285100eefe26c44eae836f9fd5c298befe7cac4ce81bae0262e9f60fa780c9a9daaba8259db207d2264a9221010821475e5cd41fa0d6c7d296922299d44cc5c1c6d652495bf6afc23e609ef36eb032320b260364ed072bf7d12e46c216ce9c947a6cb40329cc635c603ac3b8cdccfab6b53372ffcf6dd5ba5bfb538076b6cc3501b65ee2df06ceec17d14169e0fdd6308e7aed3ccb733a0268ed0bd571fde862b67355a45c7e6adfcd21b5a5b3d67ea432fe7df02d8c13068a81f8b762a5ff30210fb20568e44dc75914aec6a18dc54fbce7a5b5ab4833a6fbb51e8db25d6448cd03ed7647270d47394123d980207282b728002257ab1bc8c9de4e909eeba53728f08f9d5b98f2770c413d2e32193126420d4d1976f734d2feae852bee359da32424aaed620128dc0d677b5b3de6126b5ed5de2716d50dcec8a24d889b24167433fda429d7f8934ec6b8d93bcfd61e2b8b59bd05d2ef6af769e1000fe13bf3d67cee26099b8a1b3ed626620b5301a369ac67feaeedfe8a5afbde83c79d2e7182fa1a0d187a55a879b56733fccf7cc19fe7a9e146fd2b5875c948cb14f470509d7f68f3f96c82ffaa1f204e85bfe6eda6dbafc8f8f64cfaffd3782bda4609370162568fdbb372cf95238319b1f0f3204e7a6f60f537564192f7f42e716981346f202f8bd62f832cbeb97593f1f1e65c783388c69a61266f1c26769fc2ddacd85844eeca6465c96331626187118c9292dfe8bbb82f555e40c8e2a06e58a98ca93077d3a909d00ef1ad64f7807b67f0dee7053a72ed64caf52fa0d9d694847afb9924fb70a64b50b6b65ff9a82a55a1e94277ab707a68965c8c7887daadd92626b9cbef3866984e8fe1afcb20bdd0b73f756946a9ee38b2ba3be2ff13129ee8fdcacbe664ad02e2a44dbd931a4731167efbc7b53bed5e462b4b4ad1390dbf129234bef08ffa3ffc5e09db6adcc181065d622fc62e1b92d261e792bb5f2c5c487379a4656264938076e8f44afdfebbd33baa93cad8891a5df1fea4b857028fc8489609c483e0dd850c64739773ed5b67c9daa5d9867a6ef7dbfcd31118628ad3fedced83aec76cc941e8ce9d96ea78b5130fe43720dd6c3d16f36fefb0d76a1ad1fe1dc89c40d63d192c72ff576929a866aaf78bca8adc2a26dfc0abfbc880fc81e1f64381e8b0591eaf1e9ed0014be16881417c94c218bd546ea62be3359bacaca2f7831764365cb233a52506c7c2e71eba2867378ab297c646a6c7d3c2bd6d72d5c61227ec76bc73e94a4818d1538291e8fea5699365c81f30f848dd1eb9b50123930b2c7604007f0b5881e8355a714408efffcfcbe6e00fe22e7de7df48d06d336c8d37a92198ff13aa5d6ed41566402bb8f95095d23f7573e01fd6124375ce6ec5b04cf063a89afc3b2096479ba23dd2e27f60738109da00d9eb9cf428d11adba44fa775c1c89df6f14bf2a89d4f7a4149ffc41641202a6aabfa74915423bce86dd50f324afb6d26e1f9e2281191c5414a91d41205ab6a382253161e2925010f6da490ae254134297c626fe841b8f81da23762ecaf8928fe76e228ddc429d3a676a749a5728b73ae37c6cd36983844bb554349956986c2fdd8c1eb7af5b3a9374d916ab363934eb02201ecd6b449a9c9231390e434fdb24d6aec87a34cc0f1f5cde95ba9eb50feda271301966ab80434166414f98adaaec6283e5fe080c68440ea295dcf09035b10a4fea5f757c017aee4478c2c3585e3662067f983e6fa0aa9c9e169f7fc981528229ecc2bede2ed9220f1d231f275dc6a3063b43de17923d2140ac1778f6c38d440c282d7fdc68bea8d37b7c731157a1df46a06485dc75be643a74ef5412342d1a12426e33ce7b07d8f6c28bdc0f145906a98e71c86cef8954f945b54fe520a5a55934578f0fc5abdd0637903ae650364f69f37f30a9b7eb0cf0e61e55444c3b97453ab36db9871b2ca8ff66d3ce1a18266bd023a49ec227d0530da13b666460d88abfd0e1c2421436c0fefa40258f4a52c68e73bcdb2badbd76cc396b8f665db63d771c3464341d7225c8bc1e7bfee273ad2773bbee76bf483fd8365c951c0b156b0cf5b9b679a53a7d6efe34b380f0d59bd03f6ecb656743b125aab5a16fb8290f1c249b86446cef7e39ae20a401ae8948d0ed9be2baab4c0427423b8f65404992c012d102b5067f94d79e4b820812d2d7d70100ac1502c2e6e465f65b4fb47e945dee647abd1117563124d466a662536045a1d957f440dd15b6e333c4962c97ff9eaa41bc92e5d10018d6b5cb20048cd1b9c7864ddfd65e4c2e1c8c7b044fc023d1506ceb64e77d035b47a9d517a4b552f66ab3bfda76c33d132a5e40da10fec0f66b84a6b83d7a754ca5a872f738be911a35a2b89a27847570d9b968ad65a3fae2d807caac8060a2eb0d2cb6c83867a444792b2942bfa99afbcd90e725e783c3df05826b9754510e8bb6a9e22d2632bc7ec31396c07731882c43d82c88752b3d168ecbd79cf6a47eafc4d15d76124825dc3dcb1cfefd17529147584f008c1f1202b6b61100558d4353a3b7b4fef7bdeccf9ea1289e4439419fbddeec098c3a4e6204c15ebdadb0b87bf45ea1da2dc6aef415e8fc6865ded9f8327d2c2f713285248ce226b47cf418ed6ad090f1573e39822952de189ea793a26949b07be745aad8f866252ec142700e2675bcf032217b9bddb95d3073d22095c5ea0534aec12a871570db2cb9bc266de6d113b479d3fb52b05afbde7d9980a26702227d70f731e841a8d3a3ae018023853fc33964ae28e4971b216e2406fa3182c62fdc60a080e28652211c098fbe81a4de1d578dac9f318f51d51e7e50741a9dc6d06c3222d45cc275728dc7f2ea1c85b632117732d86e75a0cd7b0f13aa228b198387ce8936e77e8241f059493b8f7a48a82edfca2e5fdb1bae3d66ec0211462e9d67a762eafc2a215e1399e3eefa9636fba5967dbd9b22257fe9b5004c10e68f5b0df866254cc9d8ecc65af2ec4b6c203e2722de2390832f572d56de84c39a6c87ff1f6a2c0534e37226ec4493ccb04ba9765ce5334d8da61b92485fb08bf454476fa13c9cca88bee24d12f84ce16514b2af456f59ec03a933647d0e4819c5f9bcc2d61cafaab87a0c76c06fd8c6a0f727db29bbfe46e93a921dda5ce49ea59b4ff2ce1da93f205aaa8b88ceaeed959f154ff43b01652b4862abe114d4d312318f8feee15ae972079b71e3d9a9657912fd54cf7dc17d8bef9c03a6403d5b504f46270abd25a697f3bb60d9ee5869f05cfbaea0db81b44f1c69b382c869eb2b3f8c6ff7d46ab4996744a82fd436675f32b50a67381631d6edc9961edde338fd23e921c99eb26d8fde1769123ce16a5f78b612dc4441f3b945a105011015c89be5a13454a85fed5702be7636a408bca2eb72a868dd5ef2d24de8ca1edd1162adb4260adba4b395c4bcd600ef32d156786fd600352826328ba443adf6ccd88d03c4d182ff5f5d0565e4ee28c4732f5449ac156c89420b05bb56884c50178d50ba764768d211a366dc147744d850b67445e3dcdd7343c8c372dce13686e47082aa3c4175820be513a309f303dcc45e90422fd9423793cb543ee4ff7a3e6704c292ade4d0f494cf2b8bcb00c3b1fea2e97d675e8d0425ac3b1de15973234d73e5557ecf008a9682ccbd7023c5ef36fc107f6bb9474b29dff00fd4933ec3bb275bf18079cca4a94bcf9bb27d5694aeeb3ec36083b98d9bb60f0af3ca2aa15f4fc0f4c4b21eadd14dccccf13950be0de8fe480451180d0f6100c6645f58c5b30150325e954e244337ccf68e265fd377d04bee43204f57b6be644c78ac7ea64e051750b7e38e43f82f9c1a6a3dd9c1f551c1a3a947a93e0a86b914a0bce89532d29e4062b860f92bfd0e3f17867f74fd004a058d26dbcca9f229b7777de765546c538be2ddfa0bd1fd0f43b90db4b76bbd897a1295cd9438c964407fbcacab1a31a913abc11b46ab256fcffdf279eb6cca40965d41be967857b79e214d03a3355695cd655ebb46fb66de94363f3cb3b537e85771f2eba3b8c6e6998bcba13e9b33659080a05f1c28dd934cb8f480352ee150fb43a93d6e1633d6b44d0c6f9d10f27699769013e3a0721dbdae40cd2b09c500e859accdeeb94575aee2267668c381755ef35cc46e5d6fecffbba8e7eea82ec352393f024825b3a7c40bdb7cb8b6aee4ad4487bfef19850b7e9a76829fbc8d1c6b3f044b509fcdd58333f52a053adaf3c7e49b3d273081773102209933d634cde9dda8226fe50f9e826be65cee4a24ce306d43b8df594f3280a863e25cc8ba1a69211929dd172ba827d31b38618f2aa8389c9706d7601b2a4fea790c001909239c05ed69a301ab3ad3c6a21c5f804f1d2b6ece75fa2bb7a800128551749e51e7b924e18c1a742cb32597d8bf2955a1abc96cc313397a7d8b8529f7983732344cafeb9722fdf3e41df7f1f083a549b53e3709e9e79d4a60810a162e5168d3ff90f8cd998cea183b6cb74f0e617bb8c592c3c1cedaa571a5e35bc8cf1f286ebbd94e795d6965c7f546fc05a23188506387823eb822d94dc11ee5aae18fe418c3101a0f4279a4ecf289bf91cf09332800f3f7587a37779a26a9fed037d57c1e31761fecad5ccd82e6dc6e82d07b12016c93ad3d726da2a3c11745b171205892492d551ebd0038bb8c3057425504315efb171afae06f80c685786d66f7edb3e3ac1bb2a8d08bdd1895ce03335def928ee0453bcdf956b2a6d848c9d627fe7716ad945427603af057fe377b7c5283a554202b426e82d20ea435fb1fc80ed8d5bc196fcec2b3902b9d4111747970aab451dbde1db21f7637fbecb09142306056cdb931493b10464bd2c07e0f5eb86beeb3254dbf4a1a88e19e3fce077c9beb649d1a9fa0903847eacddeb3197ac476918bb66f97bb07545687e2398f6f285be408ed0311060fdf94e3cf2aa75596ac42be5f66f2999cf4eda4f08a6dd081021fa9534518cb6972e5899979c900538516d95bb3b4d4eefe8e15d9b72c9a380e265d4319da3c4ece8ceaad87cec2df731596386760cc9fa4a8d19ebabf37b6a5b8397ca4874ccbb9370150d54f9ada99c4adbde9c8d15f5c7b7cbd81d8ec2fa138513053d246a315f4c89c4b62344e91c9c8eff46cb3f7be39975b4940af9b0fb768ec32a74880a3c48d4e8e6022f9d025acc4f21f060297866c54083b5a4454b55df50f17cbce90ab16426385a306c9aae631d5fcb242b95781abe83a2b9a19ad27c7c06e364ab62d7bbe23ea2d3ef4d3ce835cf1566919c4a3adf59a70f6e4200876f455f0cc4f317913c8cc42494a541c2c3df39703ac642d046b60e61af74016ff5f1da67ee7d5c91cc52a88eee0ec19449cf0fdaaaa629032bdaf3151c2640214cb2617499dd98e6704af239dfffe51697325c90ae76d7a32bad923619d2f2c741cc02e52587cd2677d846c13e7615ca013010831858bcd6b153963432068f261ac42e5eb537e3dcb0567c3704d39e059f8cf3bc1ef0f5fa2166e1c15b3e59f89a0d42819e8b49a965d62154661fde6e36ca13c9995b6fb61cecd8cc27da4e0e14e1e92b4595cce019c2e4e420f5fa4ba3b58b059ab121816c32730abe121d44adeee959a653fd49f2b97e1e455d9183970b562019ceefcf7a0c3971bf1cca9dc1202cc0b918236b49232acfcc0cf922efcc52dfe04f32a873315cfaddcf4b4d8085dd25d2f9d6a45bc85b238ff74016aa7fc3f09ce065d51921d4615c9c5e2729435710a3953397302b5a172aa1bc35f01d84a815f31ffc4b77cd4432691d1254700ec11c5eba878cfe97f3ca84e4df33b38c8471b056f10bca537b9e8800ec31b5989ce3f322134b5a05ba8de868b8b8db139564b53daa4ec0ad9d67dfb3f9771dc65d102a665b17a68b1e6c6dfcc601461cca7b95f974cdfe741f3b6dd1fdec95a23f584d13ddcad6a2e634b4a6a655503817725152ca26e4866c2aa1cbd8867d812daf4795e4332d65206163f7433e5bb7fed1eb6d0709be7f5ee688940718fbc703e96b63146fac6ddc6c929d3b4c17d36ca48991667dc2e4fd6750658c24da46fc538fbc4d52580ec1aa19a81ec5133a8fcc451e5db48cab82f56dcfdace5cb71630e84326b6526669cb2e31da24127d94ee3a9720d960cb92c6940e923a35829a1dbfbb3aeaa781a0c7692616ec6cf35dba724e7958d33d845594cadd6e6ce8760e83eec13405e0d8da4e291b986c96456e6d85db25fa82f859b5a25702b3b4b1ceb6a490d8b53925f7788c5d245c855fd918b8e65f4818347b9a469d4e17aebe10c2bb0b900e54131756210749d8cb2e8c2dd0bcfc8b5e444b2662cf551ca5f9a1ae1df007345514cd8d690c54cc2139408ca7a2b692a0f2cc29859a632bde87f93d89643fb6f5f4de49042e1a198828b467561f40a0d1aaf5c712b8d4d8ff22156ff46062dcae48254ebe89a3c18360d979317dd30634f7b69ea6e163afa4a4e891201c07b0daefa0410b0dc75e007e5fd77e6deafcbfa620b6b5db2299432e218e1236259f6465ca6e96eb5e35fb7bf1b788f1852fd81b4636aaf6bb08ebcd55acfb6ae88aad3d32b28b940c951ed6a18248550e4c5aefc1266074ca97f91e6837128412fffe1781f35c4341a60403fcbcd31a92d10b79cb4c63b6823bddb66bbe60fc6f5b46fde082d3af11010c779fb87c31ee6db3807b8305335791a65fd123346bdfd9924f5bfbd20111fc26da986eecb87fb72423036379ca72660cd042ea3c8871899ab8f10ca00936d34ad4d1947cd3c474d9dbf5bbfabf0a4be358455cb963583b317b87097972a77130ac6c0b3b6d220a542b02a98a32780c1b10853b98edf1b664795646586949c63b5ab83c84c7967011ccde2452fea8e5f411d45740cf25803671cc74a5a68243954b1f5bffe51319606ab602251d295214cb651317c7fd0e7d9e55e8e989e66f5a24b34c75e8bd1417e20c6849889de7bdccbb1530a0817ba7d9d7d2fde159ddf954959778b60a4fcca698aafad82338bdb3560df07ba15d3ea4d71166f4423b0e2342ea88c7b8063d5de759e97c4b2a60a5b7f219c90fb0bb6f0bc9b632771f737174481dafd05fdb99344fa3a5a16c33c8f0a2d53d988540edc49fdd54e04394d8a318554c4cb56e2fb3326c08de763018830d8f8a4a0f456e849cc3753ad6a9d6fbf93fb1207201a7b1aa63b0c6c3cc02d71ad9049edfd96d70d86ad20107b1d5f393b94b62d8b851c48c4357b8e4ca4b3e6883ae32d089f04b5498571d17c02d036bdca0cb3c4219718104b3a9c6389c1ece609e2bd671322bb8ca2cf4436e7bff1b0355e5eff9989f097b2fc9a27a140f4adbea217baa4b38d49d5e20127226528df05a0d7f3d65c7ef3447489bf27aa11a98dd0dd3fb0c83e70608c30c088c36bcd873f9d18d22d4b905a5e0f29da6c6ec48d774d9306bbf665556e1524b0a458434a9115c094ba6bfde626965547259e9195d638bb4c8cad914f7d05f83744163c714e7618cfb9a4e9febd47125475c475989646abae482ae0a1fee49dfdf528401cce3359fbc1934b0cf34d4437667a5c5434c23c06e197e5afa5c8006b9eeff35fedc9dccee9122598d30bf1c73d53cc3a9eab1b85e8d623ba48f88319f61d2e1120ff94a2ab80c8b86e1d37a87a16c041f23766b32c87a950d651a940c8f335de8dc3029dd37c82d52c023045d2c6d9bc32402341d5171bdcba73a27a018154a0932df1c043f1582f3701a70d5a92605522785eb0693b0c00bc8793639f5278811420ef3cd6490297d7a7f9cc5b202c172e3067a3077fb620f9c3237cedf9fe48485c5f96fe6019be8f3f4a6be417b06cc188330a0434940212ba5320a70972e45afb28c0a388e0106097180a80251ee10c493a2ce9da636182ec384a53d90353ddf23df6674a57fe268591a7d80f38a13b48dba851bc1b70daae18e8f32314c49922f7bef16c60e18d5bf681bd9a5df974055157aad7acca5342f634e3d8cae5d691d8e352c63d1c1f083b8db9fd9118d6c203e4fb76ca3d6e9e678e2d5446c53aea74698b9dcb77d34f635013f09bbaaf8758e33299c6aa363fe6a55f6c0f35e0fa84794e90e3c2ba81f7a72f4911037a17304521cdb6dea027f84c2fede4f0e8a771786f76bb7ebfb2695ddd013185915d3c7d204761a4dddaa0867429d80158afad3c51bd56d0654344506b2ae23619b8188ad0fba116f5c53f36652f04fbd98fcbd247c992b7349d5f1ebb7215f02a49b8635eabd9853e8a33fbbfac917e05c42132a88629bed0e821995b2cd7e17c2b4ff7fab1fe9be7002f78e46a92ee93638de18e0de25e590c7bafb10bcf5dd80ad2045f04aa2c79e023b90e95f92fb2ce40621e86c6aff6246c3fe512b8ce6d1d95f6c9acf24cc9d7c11a40a974a1899d05ebe996dc546e2b06e3655939936f0dcf560888507c3185887533fef310a8869de8c33ee45e84ff4c000dc7426ceac7aeae9eadb146e1cb2a23e0232cfcbe6a6d20bb306d14cfa643ca25b33251d5638b1843ef2349c66f523f04b43a8df091472149fd9a5166dbf357fc9b0df0980e7266467a29a933e0100022ef10e8dcd362bc0193feded56ad3f6d45ebff388c57008f7533e6a57199dc6bf2492c78267dc6880c2bd88f53715f3760ec782a3ade6b75fba0c9492150654859bab5f232cbf72b3886854b029b48f6ad667795a99461c9c86d463e6093be14c80ad87049542411251771f3053397988f2a895ad2b7ceab22e4239d3f3bfb06d447a88019f4b41e7bf311df2ed8d49c5a668ef5266e8d5a54fc18089c59d53a113223ea8e18bc690729c85e8ec2c9be62eaa9b006988280f00ac9f8514748d4dddff2aa3db2b0fb2cc4fdb895c9c4a056ec961f11ac8831834aa9dce81a788656195b1c786bd21101183b42fde52b53eaa23872ab3c96cf7a88c5c370bc977459212b74b05f1e1cb4453f9b28c027ae51933ec6f58aa26435c044f38152f9c631a2d38dba3b293c8c21c110f2260b18a338fee990fd20cadded9a18ce330a1ad7859703d1d3fec569bb566eafc1796c271502326ce17ee5caf60d7bc798bc17e3d1b81cbccd71c810ed65ec30135087d111d7d315dc385d28521a1b7501c76fce4181f1c7c947513a2ea29e8ddc4c900e486db800b03d1223dba9fc38b84bb92a8677d619dc94bfba8f8a66586bd9f7fa5abd78fa993b94ed44b2e2ec54ba296d53d9aed4c62735fd279cb0e602115aefe49086bfdd3d976c1b081f5332fb92266436f2f29564665b037072204f2197bbc716749aa342d7e800298dd8236657758e85c6b7c43c30bb9348d936806eb81d8ff833cd07be30ce7cb0cfce9170cdbbe8f7b7550d67770eab634d5d60060a7e54958a9af5d0125418d2d0bc77be742213aacf982a631edbf311d0855d05ee9531855860dba62d33dbb78285200604fbe03eb5f153d779d0bcd30a39ae30974c2777a6f69651cdd8850d22b9a29ffeb6134e133df5b224de86d1bc742b10304c3420b934609a0304a40b632c0004f5c9e29d6a9034cb055e4c893085968a4372dbfb4f8d142a0874149db89f2e9016b4970c05efc6c588f8b3d8c01bf1e2fbb41168142ae0142e2018e40100070cfdb9c4e5b8450d5427a01e2a2f9dac36bd600fe714a99d9406ebe7e290c898723a5aae76977609da7908ffddfbc7499966852949672cb5ee35589c55c77332cd6189393d0b84b8c6a06d50016d8c14f8bd1584745fcb7b7f3f94b182644609ba0c643c4f84695ad39bb5e17413b7646a7f416c39fc4afe77020415401935d7e0a496ad9a32fef7a72c802b5fde26d187f77524dd76f1a3cf03fea7e83c30bea6a4dfef81a934fe2b5cca2c64d2f046be3e1d960f45891407ef8d75aeb979b33b83612c2eef51e04289dc437ba0be4509dedbdc80f4c433e0e8addc84c2394f102ee9c8e88dd1538fb2efdabd2c88e528ef93d2f44b0d3d61d0d875fc90bdeb47f8f24cfb68293dd5368a78c7829370c3e53346eef182ce11e3f4de4bbaf6e0c98f6e04dff7aeed7738fdc7b57e62536389d73030c21422a6ddd6d16d19083f1e12491b597dc43d04750747e13c5723693484cdabdad16308d0f7b90ef74ec1c99c0d2de04143a8ee5860dc321cf6b71cd31a38d835bd1ef04870e015ab7b9ae6535824f5dd36e94fddc6d357b64a4ec3ca4140477a8601c9efdfb1e8e36fcfb66356878b72703e49bb88413448739d377ef36db15d80ec4573da23614303e942f0aca023ab143d09299f3673a191ce1982826a270dd80feeee100ad9081d6719df4aa2f93e200d16aa45d6817356ffdfb9dc9e87307066d0340e0a07d6f4ff28d759642de2fa165bd2b9f9ab1d91f69d959c27382f131c084d8a72cce016872c13bcd935133297077eb53c26e093015b2dad95547c1b6e951dd26e37535d23fd2a55fb96fcdc036770392f3214760dad5ccef9c1526228554c1e82a0a2b1a45ec37371e085382a878a781839e498793a42eeab6b6b4b6019fbaf7e9925c8e8de46698777a75616f60c116de661cec8af1bb17f96f8cd51746dd7e3bb2ec3908fcf24570bf41f6b9c7cd0209348a682385cb7306766a9851869e1cf90b07f7cab5ff6a1745ea055c731b5c3937e7d285a6b77adfbbf88cfca0df16dec633c807bf116b9afdf83b13925355109a61035fc8593faf9d7a3ae98efb96b6930855b0fc1bbcbc10a799e883c0ebe6b0896b8de1b4f84fb71292ffa96768b5be7355cd30e1c8cf77c8e251c881a2f032d152927415c48ed17eb499678aa39b2301eed0127d9aa00fa0603f986ade99c1d4e5bcd5b253628733a6835fc6e553cdab06efd467f53649db6c05809994bfe0a17d9ffa4aa5b8267485e3707b7f48fe1370800c9064adda40a091792908a088795ff9e2a8e8aa813e53bb859f1d53120b2efe469a88d7b5e1522b10288cc5d4899dd7d047da23bb12a053a6b40ae8cfc2d54ad1bb2d0dbaa15abe2c5c760f7d68ce952323e041b0cb2286524ddf854eb5f60f81eeb016e059901d86dc92f536902e54889a743d10309ce8157b57f88de1be5f01867ec6dc8ed6cf1f4b4a2bf447df7117f80d427504bba9071bd0b736f0dd24e9b49e1819a4a3d41133ccfd71d2bd41edef2849220f4beb185b02e81d4597a58f489c6038676b2d1b4876d29b1c2e239785da5d9d4e8b43048755d406711ab1d6f005a54c1844c51b0ae6085b5ae797a3b7bf870e05ea7f385f2e359aef100de38fb048081d769e13e9e58542674972192ce24b99e4f6cb4db42f152c0c284df3237ffa95586e11686eb752f43acd24fafcbd81711bff98f33e9d071003ef8609c2ad4bb59fb8f5e5fd651ab9cff4f72376ddf2f291ab7bc4db067538bda09311676580d498e559bb75a19a42c441baca4197cb83221968778da43da170126cd23210307183ce02bb437fc1c55b8865a04dcd86e58327198182765e1f6fbdc794f35f53b3550615be9db3bbcad51ef7f0c5c06e4b3a5ac95e14c4345f94cd2b8cd4dc465a8f073ff8e7327d03530a23ef2f5c56ed68a7dbce5cf4c5452e0355a06d981e969feef7c5094c496181a0e085e5c927fbef6bddb8febe1e9d08f458a4792ce2027148901c8ba7600c765a5a82c6cbfa0b1e0808566164a2a2ac8fef567053714ba12a6e527a4151011c365c396f509d9c374409c4359c192aa5e32003d0462c55dac1fde4d2f5082cf4fdf1da3052084e56e23e8a6d7d082ad0163f0ae60bfca7fba1916cb655f81234b52a5f634b3c22d4b1a0e21827b02d658b8f4a331d8d7a935877bcb57e55d6b9bd938ecf5845eea89f2123f42b94f80b9806617c601dbab46e9333effbb1771e27aacd059463577df714e7f2775ddc4fff2e80f601d8d497a16c92bee6e3e45b0d0a11752828c106806ffc74c54c0bf76c70ea45424428c175f8c97887339573bb4d87e5f0962ea277692dfb850fbfb65c6c0ac6bc2502ebcfe8f1fbf69250c3cec1710c40b8de44ecdf22ad9816ef537dc7ff847f9da5b05128cbc91442bafb7f1f172bf49f58820992eeca7ec759e509c98d24cbf349cb95aea826ce91872d08633d6d2a1d1499530a350ca832a33331d5b7731aaf4be03fd3519f04387e44bda32f335445c6fa4c61e96632673b55f57ea93841257adaefdbaf91d099b86f118eb9c9fd0efeb0f99e77609652e01e2a6e13c514ff869e736c248d8ae671040d44385c729e20ca6e42bc024a93cf5dec5e8410029f943be0b8411847d984e3bec2994d877bc6664062d19fb78920790234511f3ae02f541852a0aaf20a03d616a7b34c625f0b220d79c71e98ba749e3fd335efbf06110a3f1a542580b4d66ee07c5325ffcefca9316734065b327cb8357be0edd3d0474182595cacfa4a82d03edb4aba8811ea0cb7c0845b2ca185468abd8c429d4675436e2ef36819f64c02f48c2139e5427bf7674d806dd410ec45c0c9d382263af6e9d286195a04109a52430dc3724ce69adca67b2b2dbb8c848b6e07cd4b4daa76799ada054fa65e6b09fb529e329eeb3e8fdeeacdd1afbc281100fbece11aac70062c7cfb513ee9cf6a0e682c72fd959c63ea247413f03bb1f2c00290bbba2c16734a386b246cd90f7fff08ca287be83dbdc2acea81346b0222e5327f197bccf40578a9da6ff12c88f5d15bc905feaafd4eb723af64577c6dff75701615ea7307ddfc2d133a0ae15ca2d5a01dbf7b1ea666dae4dd5dc71e0e28ecc719918016425acff6c70c562ff4c518a79985d4bc9567e8c6debacb03bee523ac3cfe90aeea6270c0287e4b778ac72d5c8b95d9fa350cfd4b68893f0ca7287dcaa340ac1cf1a575bc96812e570d920c868d81874051ffb1e19b3e1ff2fd17421be6fe1a3fb8ccb7d47f6a267a91fb2f3cb80559b91e32439d61397775711378b39522531bdc8e726ec43690623ca9730e87bcee8db71a496937e19c182333bfa1da0f68880a7aebb683071a59a624f3aeb56179e30824533941fd21d7d6446303af71d064c4f77feeb2b7a00393d4964857088d1e26c8d74fd042d9379393b1100aa574e7cf4212aea005662853bb0ce5d1fdd5af88ce53620a8618f7941f094c2a25efd1905a02ef3b6ca3832f1f8546f1e95195aa3c9726badd96d39c4e0a3f8a83b7b36dd7231371bf429300244e8137f340b8323d820f6f005c7154b402b5397d45c0745fb0af105f2fd7447ceadce5700d10d10f08254a47c02a6e44cf50774527a8906c6f55972a7f7b26a4616f6e8426cb0a38c601ce9e29048e6483c1463d3cbb64f37bf7b2a6fd167eef634614f42df2f1cc5cfa2355ee075e189261884e00956950cb8ed44eb6dc54eb771928d481ec921691ab857a98316299fc037fa5a23e99074553a041706cf98de06f1c5c18de34b52c970a9ac3660b93e325660f954af76b78fe20a7a19122e813ba281b139f27c3408c6724e77c96993d4c4e54f4f7a3809bf1806cf560e4efd9ebdc7593bd654b86be5db4214253b8b8b1c11bf7df96ae2d237a946e66130c3d38e1620cd7f197ef00beb3f367d7e6b255f9a75f4237746504a3c714aebba9fd4e75510dec8260eb0ede8581120d41fa7088882beb6317859923f6ec3724a11714096767a80233c3eb4c2f682cd2d29d62a5bf1f7e090a8a9edc715a3d1387effaa93bd346d4425676a1d98133ee0fe1fbb94c2aa05d6499dca568b31e792e0baf3504b90ffe63c379bb9b95092d81bc6a36ac7b1b9dd348e5b19552fbf0fe22315b6f55f8a86ae6d2dcc846abc8170d69fabdd0ed27a45d484912f56440bb83740e9d58a670abf4753c0fb4e6ba5aed59bba35068ae44c6988d24724bbf88160f7fb5c206757f2a0e886a32d06ac59238ace10a04518cc23de1f625f529508e110cf012122f313d825b515b4e7a99ccbb519bcf9fbec6f49cc1ca2f0b329a12d0d5cad84fd4d46f89cdda93dd9132056801822c8b648a9024c081b360c81b0492b23097ba3de5e4afcd29deb0a2c184e0779518743fab7a20f9291234347d5f676ac9e447e5e7a3e4bb7fd1b75166eb955ec2dc442d67ff9cfe8e54c230c33671efc12733c0670d1816d3a5595e7b2a78e58c5495a61164837e9b5e61bb0de8f09541a7ffac4c3572f4a80fa2bf2e329bbc4aa7d56cdeb431b6e465b8b7e1a597f1c53992c6afaca0b74e20faac8b8dc189a147c820ea6b0e8703b97cc1ebc7b50e988c39ff930eebdb9a8780557a4faf1303fa9cf86503951ab93cca7e7f4e06b8364dfbd755f017ed4111a556cb2460fc2b1051f60bcf3676c8bdb9b59720cb6a84e4c14a2bcec3f4619b1c5442d3b7b9665ab96ac17c8bec1b7ae1d45636ef8f9382821d1e6f673753717b6977951ae2d74fe40dbf4bba108178c5fb1a8507f1289a6538bd120693e3aeda98b384b62b5778a5ea64c5807e2d41810e6df0190aee3f117abfa5e31dd1cbad4bb70dcde43fa53356078056584aad61c3df9d1c91b41008cd8c9ec774505b58644d3d06eec63f4357675e4bf7dfd1c1bea27896d1444b2f64efa15a74cab98d3c7163f786169eb679cc09fda4ca4e47802cace0521dac1ac759c0c23a65007d1e1e6ec9bbfe0038bf27ba51f622afc9f56d9c5dd8037ddd9350946907ea685d070eab05f4ebbc9e825ae22f2bf4fbc4396e3cd538484270f841922d25d9cc9db7ab8a167d750483db1afe76b3ff67571350e67b15c0c458b4933f38e5337678181b0e4af8e6f245fd5e8f865c691b77c0d059ad21b21b686223ed6d7bed16863e70f38a3b8a73e67803eb1fde375d23eff80b0062500d99e102bb16ff7f64e218756093cbc3913c615777d7c03a54e86cf97964ae672a1c7c4f515a32833a7fc1b7d7ad29626b981d8faa711ef17b745f4de344b20f71999770a2b227a415926c239e262a74ee6b1958fbe61c8dac8e0c5bc7e99fffa2f250ec7242d41621ea07eb5835a301615dc61d8ab46192f1280ac5ee922f344631898df0e2c3614c131a9a50e4268d49a9f884d2a833ca6ee97d9a603e2fa35a1b31ac0a974e01caed5b44ef86397475b6d4da50e871fba1b28d1c4452c3565fd94a177445ff3b1a452f987029a31f391d0f010ebc0388c3572f752709a1f9db1c8dbe012cfa9c85bebe9e102a57b38baffccbde8246429e6696aeb25745686b7a52d92dcbfedeca684a06ebf723391218a72996e8bae5cf6f543ff4049cd85a6f4a4e5ed66463f26b0dfda7829eedcd28ccd63177fd294debdc39631708234129981342166693c684f7a173eb143a4c9371738cfc613c8df18fc6c52db4705ebf01f73b6cb778a52959ba5e9d79feca3e82b9073fdf4ad9425aee001db203ef118d1e244abe332e3404b0ff6787d69c4266c82a8223448202a49510cb3527e84187ed5f7bd9ef57128f1563e5a54ce20f08236fcaba35515e4a99d7fb3d66224c43d365c1962c1ad75117116c627b6e5d4348a2144dfdcd05a681b14532b3ff93a8c1b365b8c3701487836e8666c27a32e0a95542e3c181b744269477448783c749094b568ea98c674e7fcdbf14a157f79b1e823e62ab483cbd287c04b44889e7ef02de9923d1566fd7cca2ef19140325d87656dccada6b9618ae040fe624218acd322f2d13644cf49ea264dd4a6a24ca28b79b0cb9c2eb7aff345224a35ca67e50c3e4595e79e81878ded18f1be6f6622fd8a700aebb5f6d0418d0732f9417afd0be63ca7814163b3990c000670ce10609b1fb8283da62829c272150922a182e2d425e71e214df5796a1231f0b498bd19ab2b51fecbcadca89108344c6da7f902e049e5052b40d9926c19180bc88f03a0c08b866fc80d050f809fd8e2abf146490e955003ea9925349c23a137ffbcac5df3e525fc14ca35d21bc8f04cb62a5b52f25f86751877a8dbab8eb61771a3f7c8dc2f542ed265098a049006469de27fd6305ae6a4ac12cbe757aeb7e69461fd050ec91e798ebc62f9e9a3e49395128ac9f6e0252e471ba75ae75530785e88c201e86bacca105ad5469d12a9f399cce86e213739d02daa5d0285057a85002eb0c0330664ff874c3a37d535810a9600ae49cc6342fbfbe6b174e04a61bff5344b50f84bc5b9e0fb3d01891879da13b13ed802236a14dfae4fb78f4b100f3d5793607fe11ffa15f04535cd431ade780e08e53fc9cc5e2229f69e51a7fd5fbf356420c7e6baddfc698868cd5f3f09faeab3bb64eedcb60d9abaea074a6fee8d91459e22a4e27b91c1144a889b862f711ee46bf4b9a48b7dfafb390ed6c03057e7518c2df1b4b6df0e2ed697eca2f3b035d2c2a4ccc71ea5f6654a6203cefb8b9ef30bd0ef323429887b556dffeb7c3e7a5f4e445a4429ac2a7c24214e8eb10eb128113ad5dc1f21e5f58c755f35e4ad772a0881f3d30531e23822f43744a3a79047636f376109c0345328122129f938bfecd31317c409cc634de3a063d5bd75c9d6af2f7a3506c6debf59d8b4ddc9dd3a129e2eca19615c5b7157670514ab472d1828a6fd64b19df8d137f576c536114447fc37d4df0f3ee714ff9dd23a2075eded2421d661bf8c62888061dfa1148c72a5cb4728c74922910a3a6a67d38e1fd5de8b66474f9f87c30c05bb6cee70d998e9d6f99aa5a0a25188010fbcc891cf0006d61064d285f849ce5190a7ad707b890a7374f4df925cb93653a6a107717c61593324451a4fd52826e83db961a50c27b07eddd49677173c1cba84c1e67cacbea169e3833e49625d7b43e89bcbd8b9c48e9f7a50bdce8cebea68","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
