<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"43a141f2c19f24a2fb00ae8f31035f61baf6c9b3c5e085107d3de455a4dde4ab56c5a5ba3be253ef0c2d414c9c720b9d7952a45f84bb7416770051fef81c82a7d19390877eac00535f46c62cd07ec217f0e805fefcc95aa1687bd84959945e5bd5d32a5e1bd33f6e52f04c82af8095a59b5395901095e6e63223157e239079d84870e6685db1188c3177b8e3fa9777e478510caeb278f9047cff9ebdd02032245e30418e525d0ac1d6833138aa74889d9ea603cbde628727ef0bd077416fa163f4428a6b00129f6ab7dac706d454b8c89a8fc270acf616472e4dceb573768b4ca2a5d803525f4d692396b6a167d6aaf670d4bb8df73a44851fea6cccc25e0d362209b1014253546f344f612ec00b380e45630711f73bd5e3aa6f5a6da38e1ba84ef18f00f49a25432aec9bb01530b536e0a41e1455dca8bb55714311a91ff67520104d857e6c7fda633e30d4ca48d46b99d74047e89c3724daf913d634e1e866e8ab5354a4be8cd29aa4aece0b588baf57f671ccbad77d1409f168dde60635e652abee82d8f6f7fe0b5b62994dd4033fc48e284becce68124176be7dfc0f3711525466931b42e1a7cfb99c7e12c991d002a48999fbffcf03ab09fbdbefb40717ef99504abdc00c309d57198a34e6db43c2a4c59fcb40b4de8bf6decf1d2b032c9642dfaa9215c2ba42be551b241399250b60814a1b9368b3fe5f3577f99b576539b4aab4aa41b4b8c10913cbff720942f75ff9280677d6d53fec10bbad77af3a08a0e15f2da20e5267b224206a711601883d0f45ddbd565a3fa4765684c67e88cef7e9344ea6e0d6baa3c70821a044f50875d25ee3877955ba1c00a9a55de829e15dae51a36813b2c6930eb1b45b02189750619d1597ec9898f2d105146df804e01933558adfe1f97e9a9d122ec3f60499d12700990d372ac95380f7e9cab453b05f74958a344ee1ce155ad2e31a0a0ad37bdd2708096c0a854e58159aeec54d098853334cf6ffcf6c825df491eebf0d4f7b4d6e25de75b5de996f6880df3c7ac3f8500a320c76e1df15aa4821ba37a8d2311abc4cc187e4f09ba5a79783d8bfc901aae66e8fccb077d034ef099c811e5f9895b602b9f7a65de3887ea2c15baf34fd88cb2b1b35ff460eab929e19d19da040f4a614de6a9c48511ab2356e1c6e5d7096ff19765b9797f25737710968bd5b52b9819f412337e6cb66366271e45b65205ca95e712d09fb2a1d6f7e002525709c42664b6318d58b3063917ab32678ea1f3983259e157f8de05bc2d188c989dc6c328f995cd002a46f3eeb6888f64101d0b124beb04fc0fb91b5b9e52abb8926c603d9b196fba7b0fcff4415ded66dd483e06c78579b830279b5d55021e5b82a4751fd4076db1717c4686f98f0f06b1433449873fb6589ad0a069f16bf1b81d754adcb5c72de2c3110bdfa33174d9b6feb573b45c3c25c1530bedeae1c2e3028c02de492075de8db9b019d383dc82a648cba6ee0a63a398ca16f2ae1a85b6432cb62940243126bc78bf4401bbaaa8b760567ee3099aa643c318bc6155c0dded8ab724a6043fea946dce4fad25cb31d2148bc8241736838d711e3777cb6b27066e1de8fd6e04fbecba353dac76dd0f9b629bfdaac15a06dbe5a844fd4baf69192b7542c79970fd43b8933ae020d606242c5c5143f05f6e29d8aaea8c4cb32d5129d8ffa58021e712768926c7806c9af135ea01602e09b8811ab993d9b4655be0527fe0f9fe0f0ed7ffb472d02b4fe6315ea61541d680cef3a3b81752a331878eec799fad6306cea7b1db752f3cc05123b968bf58ccfc3cb05ff0b68e13ea9e8f689907d615aba916a38c9c67157eea3b67517a9a142890f9905abaedd2a680640dd70827186f042b8869cb067fa787ed15adba8a2d2953f6a69929c2b849d6538ad20c6c4c958df3e3f25ae89ff8e5f2d61f9e04e2dc24a2d671dc2c74ead2f4aea7738962063cdebd7b8af2a2488a25be276645ac31910f94e5e6a512700d7c0faafca92a9e58adbb77e46ba2fa9e38e75850737edc905f94a0d531e6121dc06a0c0b15ee0bda65a6c0a7e71daa06d463dba7dbf84dfa26fdf478ddb5066c2abe21e4d78226e4769ae613474f5ea3ae8f7a4756d2a7c2193b5361ecde48eb3268fc76a26f1221c0a1a1136e82f9b51fac089c81c04262fde511edab8b712de12f2d702064b24c4fe58c65f1daea9c84e4db4a35483d68688b1b2af7a1533c13a52bd274c80cbdadda92e6ccfcc0b8534a0f476b0178dc291ad6de0132b4bb288aee6265b40ddd701b89a26df6906e929a7a5b0fc2d4ec3a4b52bc6a1600278f2c11a341d49ea218f5cdbfb7594b9527fe88b73aed93cc8f165ab6ed58997b94d5ce7f1de2dfebe1e16657bb67e72815ba9b23869d82f2a311812894b099735b5685ed3ff5ae4fab9d9da2b1e61e6e4e7bef40e4154780384b960aead10d275bece265160b6264e8897c8c32f9683f4b2cc18e66bd0dba41797ee072c1befb1837d1c31a4431248715bb944229a7e0643737a39104ec3dcb0f7d3347bb168ca9e6898ed53cb46b6050fe8421400cae40bf6654f49108b52321e05115d021ac3836ac6d6f8e7897ed943febc2cebd32085a510b185ded47cc848195444dfa72313f285f560ea563b7e65d64fdf52851279387f6e877d7802724894db9caa42ffcf672f9a0a0fc45b69ef990c57c9d13f2f6f86c24a85c5297ae5392143cf5a0802a4d3584c0658f587c866ada169e3f616ef50b233476e532d14655285dcb12e0a20343b09e8e572fe048c281d435307a4043da96b0a9cec7f6c1c055ceb713e34c6922d5840446eedb19ff8e93a68724166438dcad7a735f65bf2924b1def20be1c8766b916311b31cd9771767d77de596fbf158db6f8b8334e0c17994c669a2124797309649580d9909b10ad86801d324374085f0599bf6a6a2fe4aad7874ee5760f4e5270aff4d13060b18382ceb8e5c2979db34850c2a9bfdc4e30c532e7adbe412bbeeaa6bf0d8b253b22b214ec6dec14f895d5167e642e63f499aedaf8e2c50c5537020a01cc31c53b273ca680b7055ee991532244718ba7ab280bc61abd422b1f2bce98f1408f0fb8838957da26edabe24c1e3f9077f130cfe87da560d8aba2cc07c5d52ee6e641f2313a55207e3ae7c876f94d05f5d25270320c1f735b5f9d12a5984b7dc086892f6542486128d0f31f6ecc33c87d6e800ad35c5b2a496cb8db8ef6dccf4537ef578f22101063f96c1ee6c5373343a89cb532ac1d7383a598b9780f909c678d4d71e0f15a3e7f40d014336571093f160ebc1dd2ac5df31cbd5e51b12e57f7a8e1281bac30f4da228dc2a7f141dba8867a8ec15040de233ab16db6988ee07428f2c58313985f02bc73a06e09826e77150e121e0b0696bbbe49dda651e048ad2f83e0cc9463be0fdb8357768476a5b2372a24b4a55b22a709c1265fef01e1adea8214a9b6929d4f4fcef74d6d35b771413d7a95446d104bed741c92f1cb18116921a7435c72e4989f3d6696a333bf3989310b7948b792ecf5a7261e82e632b2cda221629b976c46c6599e866268eb1e693853112455dab7e7e04ebfe1dc589af1b841f6ef762e4d9c702d5fe81d0a3022f151d06188bb1befa3d33d4f8be3b505b5e5e2aa7462d544250af0c1bd150b075f3f4c6e6cefdeb4d78144f6c8060bd6b7d0843fc8b18de7e6be4be6e37e8e179b165f87af5f0e1c7dceb5b01c0f1fb5065c8f69d66b74ee9b79436e0e3368c67b324c9afa3e00486c3b1358dfccb5947e9a10441b75e72f742ffcb3c45a9e16b2c9dd17c348612f821b39e0d1e5b5b62a2e12cfd9ac7a9aee25c1e33d111e836be2edd9023b3451376a3121c2fb75a7be5e80518cf83375345ae5691a5ff1f602dd09a611b12aa2ce4bdf88f47b53f96739b68059eafc462659ff494a5397077cd14aa44498121a013d08a795e60d2279efcf48f1519955c58e2bb7b771574d2362db1bba781b069af56f7295a9e1ccb65bb7cff8baf12a2f55f67192c0bd07b6ded3b505459d6ddc2f36ec798031fc9c54f5dc95173b66e9ce50c7d49988ef025977e57a895174de4d37f6c11fadfa51e4b797821c19efc398efad54fa0659ed5e7f210080c6a96f0fd21774544b12d1ad65514d26016dcdeccf8a3d3392250736003ce512b5f4f2e5ccfce4fa18c4960d94a4b161fd4775aa60102a5a335788737b0c6cd5f7514f49cf50e3fda9aaf9d0ad1ca4824cc273ca60d59be7819ccc26fb96a8a547fff14cc5bf83b2b2bfde7f14c767678ae1c6170db687891eb465fc6736492839014adf69d2268ebd6e4a97ad3c5e789be6fbffe8d1dda674b4a15b415a59fded01b7520ad8a8ddb2c17f219400c7901a5c38e7eb26ad6a7f986d0eb4bb4b53fa7642cf7ea35fc5cc1c2c934905c08ed27f029cc7f10268a3d262e6bd36b7cd32fbce8e56df62cb30eb75f57fa540878ad8f137b5f7e4f285f50feef8d95b038dfbcb6b7ef83447b0ec940b932ebe69d433f7558f00636d7b744033861c472243cb11481b5607283d9170d5420cc449cc1d91dbc18e7674724b51f0bdedc8a68f36c3d3f237cd7a521cf12fb83d30ab18f9e8e8eb5f35b3a7748c95db9ecca1e83c05bb9f5418239889b0f42b29bc68964ff63feb4c80b58324668e2772e5cb642b34081484d5fe252fb593d655da116f2a57330bfdd55671031e9bdb6280de70e2680b273178b851dd4fdca52c1e68c8ce1edf5234ca83d2813ce1d0b1c29b502355df437176d01319d2b55496277037463a2176a7c7f09fdf438a9f202624511df15a31a229953c9e75387777f8b051d659f3621ecd52119d29cf12f70ea32a8ac28484f8b2a78461ff0649dbf19a597d6adc1465c3e6ecc337cbbf55e1804f3f6feb4baa85dcdd47c0ce78abe13bdcdd8139762bc75d1a9b4d5eeb159e487308a5a2ba556abd4e7dfee2e0e2270b5a08f1981435f0a2280c21120c61fb3bc11e6d37a4bd10e475c7c02a8b3a1a9ec00e4383f37ae45aa7b9a0b81f651004fc9161b8a6487b47e957a46e14e16804febd4c0aed114bca80209a83a8d84495ce69797add40aa299cff8bfc8ba536bea8bfd84fae7a7e007c066aa77cddf04afcea3c333c6807b21c9bcf58d0238fda8752815a18a437e2e75a2cce4653d79d91bedac5e43139af372afd97ed977f721195efe076f3ad525ea48b57ca0d8f4978f2855ecb047695e723a16677874d360ddb28572019176b7159877f6ef4eeca20339dda9e11b10a8ec74eba479e60564666f0893c7cd85269859b073d35ebd170b94a562487ae45f77188deef74795325fcae05f94b2b0073273e8036fc8a2632908126d9c93e0f11b36e3c1ae5ade45573f0c45ae25151b4123e5873bc1b979480fb6e1805f13ac2d2418509020cbc573bb6dab0ceead15480ace1fd5616eb7fd4addd82b3dc7efb4e3dad3398b5bd5e7df3494aa9a3aa7f87889da68f309129d9b9242a1a6024102605ea674fef425f2574b5f79e28702ca6dcca9367b53a1fbe8b385c69b140c7963487a40886a27eb1e701b9fb775730e47933509b8ec09a621ee219f660aa63bef8f3c266764e96c515b1b70b726eb7b88b9a58a330a660eb57a84b8016bcdbe1b8fbbb839e9be085e5a0326254634214b7a79f93a1d32b22e824d439c3e6765247a064df9c20bd61253af63a7eecc3c4bd066b93c3be17860be6dc851ea777693236d098638765f518c5eaded8913f3ad51356315fb4ef385985633889d0f51058869e43e5f91de17931648e11e2b379a941a192355f7fa81448fce1b2c440d0bd127124f5fdccbf57407cc9b32656356c7671eb0318fb980fae9012317ca6bd28519a6f002c979de6e5c083948761083a3da59c8b74ce416ee30102b7473beeee9a4d7bba2bf8e5af68674f4b24840249ecf9af27ef9c574f80ee3ae20981b2fb159d94cddbd6489cec8d09b745078372f3e8f1b6e22d10d64978a4851527be454602ba7318a1896be8832e2577f5f13e779035e0f1d57e09429aaf4d0e2e5b90c8a7a64fd9cc34b4344d4b4e5df0e0aa37ae3e2bf5d5737de81226cc200aa4acd83492d3ccf56a5e229d0481711e5ac7bc6732dee1ef11b85e8673471eb32ebce8bbf84814bbd7771b8ded597948afacc0d69edda1fedea4ab9337bfee861b139b765aca742fd16cc47ccca517c360d74ed99dfc8dee174b756638e8ef539ef2ccc1c4e91c0d8b8aee83c94bb59e0fd62585a52c2b330e8f88cd4fa495a7b93cf2818c7466dc0e5ef61441a8b0498b2bf9fbe5050257a12791f9c97d32f45725d666dd28f9d2c42bcbad1c55b8888bf19850fd910a964a0ef9e383fdc73a56204d18c993d849eaf38674490de29584e4a6e18b8002a86ddeaf24393bda885a5524fa91d676a7f5b7c7e7a910f23834615561aaef488d04082fa9773f3cac5ad5bade63564194f6b0599c0fe9238fee8421361549ee84e48728b36a549c8abdc976a807e362a0e6fc4b25e7f8775789098bbad939e338ec828fc1bc8a202c6a2a23a53683d19a76734afcb11b47107d5f408dad61efd0522530459d79c8ebea37c3c2dd803b26f860cf586641fd4140e47e913f319725b52bb458aa8ad09bc2b0c4cc986171f017a6c9c1d5899b6442b7eb33f825dc39bf81ed0d981bcc69c4ba6747b42a5cba93baa4464c296f84d1faef9072fa68613827090251c828c7d7300c5f8108f0dd6d9cb0c9f0539e031947ffd01cabbd81ebe0fbac86ea90deb652d609e96b7b6557a037d63bc258b39207a78f38c1bb18f6c9ff673beaf33ca80832f4055f41d47d4c0dfcbea275bbbe3b606d54eb37d90af8000f470fd7aecddaf69f3748527754d10cfd772cb22041d0116b25d0240c241d86205051b91a63942ce03b1a46aab7a5e9d02051e1a96a758b088dbc215c2f83977fa57c2991edb9e9c43d8fdac0111fb6ae963e0331ab02851d1f1e1ba87938a6c5e747981141bf8f55cae82b8a4b27d3edc4bdcfb776043681463cc9b42a80f382092dbeffb8e956f33062baf2816f0567d0fb6baa7f2921167077b2a19950acd1da06b2ab9a280686f472f96ad9bfef29a7715bfb65aa3cb135cf30713705dbc04f56e3f894f0a906a156c3a063de31f26c88d402aa84b5e7a8071db1db0149a1d37f00e880aab56ffe681234adc14005c791b19899663a200fe2ac2dc409528c1f436dae86003d9f6f63f942b5e1184058d1e0d6af035227c034622ad23c21bd5490ecf6b7f1f9651067c4f5da2482cd77a01baf2bdc1216f66018949d1c52c2e8a8071719c23bd642ca9030bcfb35108525e661412b06394c6befe41c1a5ec08b992160467e364e23ac48354925355dab90dda8fba875ffec37c19607e70e1cfc3a3ec088ce4bdab5f38c1cdba5dd6fd0f29fe363cfbe30bb4725d8cb72b8edf6709182e358ee245a8523f0097781af701aff22ef7842fe28d789bd0b880db5d0db39df40ae63258706f756a4a6ef892f783781bba3b6dcf263a964d613d40b466670c4bec3a248bbd57a3016cb36b8e6917c449bce56a91b0fefc95f08df69f182b613892f11a55146232cc190e6abc402ea0d93181a31f539fd997474f510acca305f34d0588f6f1c957550f5aca89ecdd2e80a7708dc6a0c8173e64351cb221cffd13991ddc8deef10d79a9bc83e594fb9089c30b514d1146e6d33bcd020a685b011d992fd02dea6b7aa81c243b8a319bb1f6ef4e5817d1ec95aef203d39a5212d9849b4f30215c97bc3d0a1fb507a27a937fb84c85566171125397ddfea5f72dfbb0e5116e8d7a53c9842045cd7f0f870e9129e769890f83717ca190273616b163a223c2029213a39d20534f3aeba7625171d52ddd0ab72f0e200ef3ad4bfeee0651f4456010219b05bc556e56c0a9dc0f0280d3299891d337c912571faca79305cd8841e71f4fc25dc6cd626201396ceb04954922ffc0ed267dcd831893bf3ff622acbfad6e3f119f9c826c51f950e5f1034b4ab52312d18408795097f1dc39ad0c20bd957e4cfcd1ca9980b7add70d86c6b347cf4e25632f14ce2998154f628b434bfdbfbed06ec8599300c22c564be1bdec5611a42edb15b09e52315a808e9727dc62432f143650979e7158fe163b6c3d4af11407f47c17f7db6aac3e8f68f335704ddb3f2c180a0f41e5ce72deee552e9f59e4a1d5aa7a113cb3a62e95266b9f3e4c2147dea07a5350c2ba8f6e72084d713454cbd96528c8a2efdf5dfe31288c01b63ed25a04d4ec555bccf12de52bd4400be56b7b206bcdeb7bf6a0008757286e2c4e3387fafc71c78c735e1fa7304b0b0238c047b2b8c38f2826989d0e58b1fd073f3b69323a5a39449679731ff8e1cafd0698648f4d4b50ea7657f1953a767c1869f2558c2f6118afcf8be85f4c32b1747ed860c22c87875a895fa144909b95039e3a11ca4d32a878c34ce7eee40b3daab1d7f49fad781ba74f0f0bf56809d4b166a24c3de9b4148aae4c121022dc29830ae0089c667c27a996c34699b66ffb8b7dcd7432d34b127550f6e490fe740fda24921030f67d78cf08d039152b3ced31a345bc4a5b5abf624d20fc4c1ba12f405994c062564cee67e97503db8a38141f6442c5e32f601e7f99302f6fa8eee0ad13e3c841f47cd408d603dc8ccaf0120c0c514cbbd294d208eea27002dbb92e2e5f3f451a245577368aeeea83c0fea792618990a0b12d3fd0a63438826a019bfac343590d0fef3bdfbbbcf8caa8649adab3592dab6c248b0b0ccb82756ff8f6a5e829c503cdb19514f9e62c765a0d253f27862dbfb1ce142d98823235320b162b119805160a12f41a4c1a2d4814992b893df58babb62577f61801cb37c0905d12bc7aad3cda141f6e8b3e17f1f21d5e56c7cf515b5c045929b913bb2d570f20da2b46733d616143bdba8d3cd800f3915d1abbe7dd8af53a5bf26647e257d4575f830fbdb7bbdc16988d25295128afc8b8153f6c422f1a416e5f4af0c2c1d6ca73b96816e305b4d8a66df76344cfa1e3e8eaddab524b6c3e1cd9a93eb6a513542aebc66978fb12b3645cf8d71848c7d82facc89374ff55a1e604a7482d94333658a81e5e4730d88f22a1ecf5acaaacd6a7bbfcff921cf335b8d3140ca9b14f189c655ea785ba6c63759cc718750be2895e5dd7d3d68773a1a14c1a176b897d1307f8c130237f6a736f4baf4c70ecf4feff93960864eb4c369093f6495c45afdf6fd73714b1c8e999efee2c16244c164609276e8180d733aa6521af3e98cdd9c896b1d23d362261b039c31b6b1cd67e050792ccabb758360d45c5180401287285ab835b81f3695b57a1afc252341263e62efc36bfba05b9b3c2122c9ce22d710bcb1801bca2500f809d90c2db9b61833c539da63b1f82e37191d6afad5dcfceb318a5b58370bc2b084d3ec067afd3bb5ae2bff3ee46ce4b908b75965afcd3368a9e9ee731cda07526a3ebaa6f1dd7bc1ce8a2682dd7058c80d1dc8389b4a9915a1e5c0a87095880a98c4a087bbcf1dc7fa284371ece9f3077058c62e9ba0d2c22a0e4ff8b60bd0297911b59c9089e49f60bdcb6891247b9271739de9498b7efbac015bd88d41c05600581b05b2ca61dbdaa63549242d2f2efaf6cee5804712d8f48e00d648ed979086c63a7a3232f94ff57ae07eb14997b43de0b8cbd542d5b0391d8a293f91076f163b63739e49d8c8665419e1c93c86365c9c1345594fa082586b1b7560fc1e09a3cf669187488cdfbff7c66f584281665b6622aea1770556bf9fa62951d97677dc951d865cf461350d1c5ce06bdeb3d4f5d1b644b451d6e2d7f80fd5a58b16e93cf63f854f987e86aaa0034b7d43183c98933a5d7120d26aa4eefd57c7e46f4d08883d886d13d7cb09723077473971bc03147a191a2725a76c2a79b6ef5b48f5e81fc6bd802c0a1b3e384c322e457d91198653e1a78ce589479a7181e9b2d3ed154b1e969f0a8e624d6ca761e42652661b4f5c72d05cf6c85016341e2e8f470d40182c10fbf164d3dd5a3eaf0764032afd0e7c35a5b98a6abbf73a8a2736b43ee0ffa9a13f1fa515262222a50cadc8dcd4f492a3397c1d6c6ae1f9ae78e46b6bc6a2396fc687e7267fabfd32b26330bb666b48cae5aef3e259bf39d03ffe7103b9e07f43fc28ffdc14cd6053eaa50afbb189c7691f559d1a694e485fc9a9da76d7d414543703b4869b4311712f0e70a261bf95248ee11a41bb1a2203fe0f00a29faeada978f30d565ff066b7f05c5855879a1ac5a5cc664ac45feb38a14d0c08a4f00ffb340e5591876103ec1d9acb270b4e67e4325a70b8fdab6e62c41f10dabf04eed487ab2d21ac6bd8ef1b6e9cd5e04de4c8c07d71fc33748cb189fcd6c70eb8494c8f907d6fdc7ae2fcc41dcec36c59ad1f2cc908754156eae55db0300d1201ff0944f1203a343a16af7632aa28030604d22b9aca30f7cf916945bf70895746b7a688513cfa9e50a32122945cdb5dd645757ef72e25895650d4317ff2df16fc18a62026738055c82d87a32cc010813d07543033b79ddf3ffe6ec061db3b3705b1727b24172735a61645993b6bb8b303224766ea4ec1973ff520f49bddd8c3308193e5d155bb229a7b9b258da8e24c97708d4acb44605b24bb58304969121ba127e362504deaccd1b5ec26667c17d8de9ffcee053a95aa8cfd4e5da0f7938e7a3c8d32293abb454220d9042e4c6669a7a814b9e6c532c2e0e74b1edfcdd4d53845db96b5d5a76d1c78f01625a0ced7b5b3980b279e2052be84ec69c9917cdef2a6a5edc9f44460c6855c560b34384d2d5fc34de9260fdbcc5fdff1ddf6f96a47de4031236a198a59458e2e95b195ea81857feea416ca1fa2344febf40832d9d9d48bc0adf11f4dfc7ce1a6ff508ac8b5c057c89268e7983ddaa11fb8a4bfb0b0a7c7beef29b9b6b9f78dd86db3a7d6e7455fec90a6baac3ca2fd01e7dcbcda6a5c3fe84ee4754a525519adedb98cc11421aacaf8f9fa1daf5a0a7f3c30808678b9bf573db1ec5515f357a1900e01273cee823f5ade3cd306338ddc1e4039af8724e0f99e689ce50ecd14914857b8f5d5e7f4f5a115b8aa65ad710fc516ed46deb0736b34e48a2e9867b44c03dd2de027f89e2cb86403d4a9d9fdfa5cf7c5784902602644a170c7cd7504b6f53f3f80d7a1e3d41bf9c9cc7f2cd223ff7417811b909085305048476beb0bef0cbab692ea9590581a84de3f7e2ec23e66ac42e03a418666dd7e8d305ca1bbbd133e15656e6f6b4abf018e1538f7c177962320162b9fc2947c9951bce4145b7adf6ef1492ac854c66697567c9808de23fbdf1d53a17b14f63ec55cd91e7af7bb9502fca68b44c66e17be44440ec14733ef3ee2c57af2c186610ab8115edef2380645688143b330f722c983f90bebeba87cdae2918668582562c23c1538bc515fcf80193ff68bf2fc8190548cdebf62d9e5d44d309e9a1f5e7ed72d81f4d2eeae39b3d5ed96a2c3f402c6f39c5f81f8caa7b044b173ddb06f93c812e41fe75637fa56615467045d3a3e92c2cbd5b1c3287764374b18a5f6c7bb4ccc15c308a5781fe0be0e4e2828eb4208ae7891f70c161ad071a8ed561efac42536923523fe48df2b7fc54603e98b2b201b34248dc16d4e45a90c07accd5d7980a3c3701effaa17511e2bc6fc23a0e92cfb5f719083a5ad2e4f0f7f36178ef08c99040faf5e0d8070cd0a85e5eb8a3a1c878410398f9e51ec517c6fdac306004fdc61acbef5f0f6196b47608909ee95fc2b8dbe26b6324789ccd1b86bca40aff7c1e52c38d7402d4a59c40a3df78ab4d269f9495e2c44b46b5dfe238445be3dc6a1a3f57893cdc275ac52f1f40df5ade2fafd73a5240ffb2f35c25724abe154843adc2072c731d4fde6ef8f5346c9630bf1d79e85ad51a8bfdddd9c78e7752fafca42ccecf1e78e752101a8b3d79794fa9228f137d99e9c266f4762672f4887612ca132f9b0e6d34b69eb52d3a6d7408a5472be0fff652b6277017b7863324d8c9dba940172b9fe867cf707f0cb2e1658f43994e83a64fa6ef70ff7c8a08507f05dc1838084e1ba22666e7eebf284864b8b697431952cd9a6aae0d037ab7946005624070aecdef4f679d6b1574c82c6cf949b34849c5a1893fddc407d621936def2ecbea2fbb81984756828ba7d81ef941bbe746ac1cadb212aca0cdd756f82e5ca6d0cbca3646fe8d83b84a38c9e7b0d773ea44a29b3e83a81337ec60a77d746ff71fa359bb60b32c1ff39dde3a1a65f4a0b4314a44dab740011c95c1c8d9e58668601ef90e80a65fccf35daf5c440c5a7a90a4d7fae2feb14718cf8d8fa3d72d02628114d51bae682b65b99e76bea42eddb093ea15f8081743f2988c226f83faea32db11ae6bd15ecb0a6063d30cf64aac361cc394ea76426f0bd89b6899425462fecd6f3f06ca08a0832c902f783c8ea1e877b0ce9355afee041f59dfec7353998af583a136023bf25dad69d614831ed1cfdce53725cc946bc762b6bd4361e074dc135f718cb76b9eb31964b3e0982f0fc8b4978f246495ee7574bd3f87839c095cd8f399a964ceef1c9fe4ffa062b4c5dd210ea779d08784b4f429e3ecace7cedd91eba3f663acaab32d56717d92504f6899a585084f1ba35dff259e6ebb29e77e5b4df60e35d828157e7545637c534f801229952d231c3396bb33b8b11cde46884f5091e40c92f091eec3114e253e310d78a4a899429e421b940954a5c7c8d5fb0d0f25e3ccd7ac3fd6766a891487398a46dea03eaaf9dbd8bd388c1333ccc14f66920e8641316be95610e2fdb23293309608c0673d0fa00f8869f32d3774f92fa64862d4c76212d3ddc21cb7b45effae71e476c887aa981080f5ae7be92f0fd606639ed10c2a3b464a50c120561ba63a7c8e0de9fd7f32979c826a76801a00cca17d577d3d9fbc7ba44cb378b33a3444ac09fdb5e7b22da56b168b4c0bfe6d1736161df6e920c447ed56daeef68a2a7d8d62a9983548e8e2316410cacdb93cb2ef6eec4fc80e35bc2bef5b87ab4e03a5c267976b4d4b2bbab445c0ebc9e08826f373e7dc83161d5ae883602ceaa4c2bcace55a6fea2301ea0e592f0531e72998be52589271e69119fb684e8b529d3e22f1a78e500cfcb670a2a57182abef1047219cf66213dfa86f210921f957eb80074e0bd2131c6bb24b566a4f9bea58c160f35c05ca3796508cfc4c3da8034384837606282a8d6d22f298e6061a97f88a93cad056b28c8f6c27c2c82a9adb806e380b048735065e0bb39a3e4044dabf2a929011875a2193c691f6f07f870d2b1bd4db77237626ce9d4f21253e78a53955b29b8baa1d17fa69e46f005fdc15759f07beb81f5ba60c70f2d7912bbbd07ac6684fb628fbd3083e1cf4860b1e926d2bcccecb6ff37139bf5e7c759fc2bce1198c6c21b208c35dfc23d57ca5187184657b8921d91885b08140ef69696aa4dc88b672a41441d5b7fa874c45ac846c0b5e1ff317ef7baa01c56bea5a9dd8d4f4ebbe5f9c441c1c8fb8bb7d795819cb9faf616a5b7ab427d7bae3a4d7db52865340dbde57755e2e4b5de5b97ba2aa89ae1bcb58c67e397b74cd445bbf12370b7e0c99f049487a64ba382f586b98033e7026d5771bf35a46b7bf60e8696f055a2782dbd21971549639b9fac0f0677c404e896ed85f1bb78232fa0e4e114328216dbed1833a70f6a1174d4b4038d2301140cfed3ddd353ac8ee19c53b106d0dc816bc2bfc2ae2f701e3a763e941cd1ffa73031e91ee7e7619634d12472d0ccdcda29414b7960c2b6bb846cb122b76e8a35d43be17ce71c940c3c6000758ee178beb3db4e10f7779c7814bf5e5bcf413c69355b8efa98cd2a3cfed0b4bed57feaa2c0181bac7283667b21602ce637dfb061f551357c5bce3d232c6f596d5e0e472705971cd52bd14cc2d647b712b63d4d635a3b2cfe101f87cf19dbd77dc635fa13e71b49bceb3f7bfd93bea501526ac45aa34284717af5a12e7a51683e9811c19d71bfadd5270fa428dc7a960034b072a9f3e8ce2782a6ae59d4cea96e750f273abe7ed2bcfe964cb8b23315d389797cb2653ce3356ed7d96f370799d47c1f81897cd205116c0bd2c9e212df2c83c2a537777f6b338500f06500bee919d61a13c03dc0572208b85b8d80a4dfb06474e18dc8a58b51a52e10b51ab8ca1a12e3e618712e0e46f63a82efa164e2a9786761d063f740b512314d8349dda1d5405056f2bd0fe3a13891bf59c075397147cfd44e52bf28fa9f5b70a618cc204a9e7c623e721390c50a0b53e59f5bcb641bba5054aebbee415e062967d77a1ddbb1fe9e6babc5651ef129e690e58baf0e51ec52108e2bf9410722c37140743537513329591c9d7a8146a1f673edf01d21c08845eeab6a3c6268a87f4d302ffb5ba9b1e7f55e6f0efa367a1f26758a931e6509d2d9a724dd435c16dec816bdc4feb928647512ddb3002d9ae0a345aec86bb870a8ff004dbc8406a19c02cd244764524c81abe953a9c6797dab28c1eea9831ce38e5072a7b3da4119db49de40c8d4ab745a1d877799c9c82a9854600ae1dc88707cc3a263407919310b2f01dc8dbe8fa9bcb1b0c3d0eff82fb5a542548d1829db5917368f118fdc5d627e9b90e7523b397d7a2d963c7d13f56d9e883f140a45b7dd58bfb1e6b0e392538c80f71cc1234a2db2769150714da8bb681db49811eb5665b9047667cf72084287039853764f61d5021f1010f8bf456a008762bd2669d16a2d2fda6c863c45e83673627e6544c31886397a8cf03bec7a0a0330bfc6ec864a1c2407e73335cf778168281a89f4a26e27006f127ee6bd6fbfcb79443f211be79b1254de1f0d7fd391ecaf23ead1477a433281f7c0a181f447e97abd1a6cb13c07794c4d2d7c6403d054a931859ac5630ea440bfe188b0a4f7596ea57846948d01470b08678b93d5d429e7f485d93da1d9b79d97b3620e9865c1a10d915114490d1edf40996cb9b5dd06bf8b50ad89501da5be89d18d50acd9c44c03260285c6b38f432ba33092de8637ccf8ca6c4c36aad14081f849e7afdc45961c5061ca8c2adb99525c35e30bb848208b4e9d700551cddd8deebdbbd356ab533c1055b016fe1dc31ec677fd6f212e070b24c320d91531d831a63c49e333ddf556f9641a413304f8027b3b38cc85e5a0138ba096cb71ce720e8c38647765b210c9e2a97e4c317a1041bad52daefae9ba1e18ce81835549cd473a0805e137113e2f478ca2680604667737017f48de061db1275c97b6c8f76a368d410e1a7c08dfd1881fae41e8b8c812b4e3bcf047be1b365f1da5c9943f142b1b4c3f75123a796d92a8d3c331518be1c0b69f4ab5413d414500705fd7ce0a9fce3cea19506fab569bce13713ec604ad1b0dae074ae03780953e31a3983ec295adf4580c5371b0ca49a3ff9d7f12dcac8442169c62551ee81f958d60bbb48f01445a64a1300879f3282327bdc684171df44c002e7424bb77909e933d9b2279b7bbb74928be000836263961e70eea4e6d45b6d06841057c40dcf1a5905454cda6117766324db450fb064196ce30f4e3308159944ecbc3065b1b033b1fec05289d4c6736b185082305a1ba50c408bae982f69ed4dd402d50f306ad697ef030a47dc0a663d56b8bf874132345d58972d6fa9484c0c7c6a54b502aa72bd0b3a41c34c4235a7118ce6180ef8bf042c08eb962b3c26d952b92d7f79713f9c20b0afef7f254e986f8d7cd38082051f530360f9908abc68498dba47466217028217353c0a449a74377427343b97977b463d065dba669aedb16e3d9159fbe4ba9c663dcf623e25385c0d3e5eadda7b1a451eb2883ceea0276a40530371700d63ed5061a3ef376b0eb0fdd645d6a60dba423319d988cfe3a1c71fd7205348412a603d4ec44b0bfa34a2ec24ed8f0ec3890ce97c0d42156ceee56269b0d172393212fe146ad30afda5cd08f611e0d25fcc531d23563a546dc3c1c503f9c7ec74859a2fa54e2745e46aa789256c4e36cb762c2d1fd695f03780815ae63cf9e35c7dae93fc03cdb49bd1d85dafb5722362e6760ad4a0948864dc560498cb3973b1bb2b0e1004050ec9a007b0f7fedeb7710ac1a8f45d5cd6a5d4ae62b88d43d4be9c21aeb866879a2cfd29c75146e18cac54cda6f72406727d663e5a5fb5a66410714cd00f6d9f925e99b7427c797850c29ba55bb528aa25893dd907fb9a153237b14500b57ad14de47ef36deea4ec441144eddf8a470f4916da73dd1f371a2a02f6e826dedbf209675a9d8077b0edcac2570708871d863ab98daa443fe3a8a26e1c4aa8f1314d92214e9f566abd455a00b8198e3583849e69d3e68b0e0251509906181d48e750edce0d698de1e3995dd02d87b3ebfb04385ff24794bac3bc25222b6980c76eb8a1ba073ba1f2fe0281e7447fd0b4e6c32a2409be8e10daa83c4bfcfb10ff44086cbe27c8d115be867c45ec0779c5397e94aea3a405c5b2f8d40a7eb150d3e2827f1e1fab38840b2e60fcce7cf803eb824ad041aa45579849b7c4a3397b70a7fc1e8c7ded6ca33a5b4cbdf7b5eca1039eb64c7dbb9d482f5eb3c0bec9ecb1328f131c51f6689c546c98bd6f7460e0add1841e5a2c7ea37d5c663d0ad85a86d731f8141f8fb32dd5ea22f56d8be45d8802d7c1496ea4e1b7bcec07891a3a12bd39cb6b5f8a9a489f1c1e294aac1b1484e29381e12fa0e4f3a356668a421fc88facbc4a926f75ac484877676efa91ea43ad830f9def290b2f50bcc7b262a9da542c31723cc03e2bdad3590c222341a1dc6d4cab7d9af84038bffc1ce0a648eab812c78cb5e0bd54ae0c126a1e4479b4c6a86a878b000aa0e4974a61e67cc0e7b2f9942e47ad82c2c16c87e36977167b58cfc63033a5fb59ed1dbd66d863421417aee451405f5209e8b940875f6e28e614ea14b3fd33b57c05d1f31f1192c6b53ee95fa780ed66b26fe3e40f5c4692188cd95a871c3e8c54573056db8b89564dc40a137e595d6e36cb3bbb39e09c1118e46aa80ec5fc64b6717ad948d54d1d1c6fe9e4399d041c72e125097cfeb5883bbeadec89a52d9c185374d78f1e4ac2156ebbf2a52ee2a729ff79834eaa49cc9f019502b347d1441c805d9ee7fd3741ad919972eef6286dfb8b2811daefd3b1e290661d114881051f74b839f6fb0a48b120841e6e3db12c78a31dd53a1c3202400393ecfd5760ca4c11702e16b0ec67263d8fb799e7050c833d8b929155edcdf95be87f1a7f4eac23caf06b21c708c919163dcb98fff1f9bf15423c006130a4b412506432ccb1cd904d55dc288af7f61ec0e0caa9cb913234338e74386c449a66cddf1d8cbf67bea93eb61ebc784cc968e6a9ddc14b2f475523fe271c02a4218a60ea363e070c17013ba536abf425f34f36dfe3d639b019e1134281d79be111c463b011fb509e29d0bee0cc218a289e47f04ef08e36b0f25d27e9aa68f406a31eff923b8821867403254db1081de0dc07ef7dfd589eb6c325dd5fb3125f1ba924c577376a82cdd6d9b95f4a728162ca564fb09855abfb44366ec004b58ae0a4121e92aa8a19451d78379018ecaca839f683c8458bef403fa48b4f94268264e81acc167829c21250d32708c27036209b11596b8584cb9d94ad152e901a01a66cf61997c399459d7efd3d0d093140e03205ebedfaed9cf6b17b5ee0130b25c27ea7cf1e4245089f41bdfa22e42e51ab9c618a2b65a5ba4cc869433046f5c2abbf0a5fbbec903f6736c970c6b2a6d792df88ae51802b8eeb3c0a9810f6ad7b2d7d683c97380861ab0d218154b1974a0b082dd11448e25b8659dbc16ae66d108da64c5f1656d13a5b27f2fce36640179f0407eba9529b4f36f3435cb2974c2022087343a963662aab6240ded76d8d3d1cb39ce59bf389ac04e213b257f3fc34a912e83696cf1c0a66a6f31e95893e4240141bda45b202c60df1d6f607d7b7ef5ef0c42fe281886210b90da0914c222e1c53ec09f2bff9342","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
