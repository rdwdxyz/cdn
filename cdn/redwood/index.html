<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ca9055f6765dafcfefc626b2bc073a43f492362d38805980d7f0b9157dd6634a3f6a316a836daa1ee6e3d35e77855bc499acf8c781e5dabc306bb50cc836b959a78889947ce26c5d9270c45410cb52b596c865ef1a31e799c8f7f3b1af95ac8aac98d115bb94dcdc492c9c4ebc253e783588f047bf11066aaaa2cf7cd4d41a212f5ff226583019fae8423bee1d8864e9c18a4a6fcf876d6b39a85aa218c3890c35523512e82e6710b28ff3364b0d24f06336bcbbee35178cd60a10c0257787bb539748e3b685d729b7db4339772234215195d166ab65bbd9947bc3256cdc3c9b0c67936941ed49e431ae4637800635a31be9de0bb7ae9a724837ff35b78d68375f57e8fd0baded2e5edf778a81c1a64329cecdae792fa29656f789b5ab5b2bba2a32b8b1958a9f6ab2fae08c1e4436a84aeaf927f9ba24b220612da85cdfb7d08110ef9213c33325615ca17e3614854fe984125aece877dcd25dc0b7296b4f3740a4ed512ea6b613d26d69cf3c4b8f9d2c69ea1f2cee2c44a37fb0fc10422eee985ad077d4d69b8b5984d9b11309ea4e32a1db11e1fd119e518f665dfa0376e01f1acdb1e9ce19c7a7acd39ec243bcf54ebb43b74ecdfe5ad5ada74a9bc2772a3ca459871d62944f3b1de6d4245b57dc4be5d2990e4f6f8446b31620b3b02e7b1b4472cbbfd1167c72b0794f68dbd32b65c998d45cdbf24d8f9617bc2387ac2ea823760b96fa01419759e484a615ae84874914193ea0f7e16cbeb29469f7fe4fa630768091bd41d86cafcee9dd67044ecab802b48d87029d2468d9b7fdaa1263f81a1b6d5a6b897c68c797a45d190a8ac3544e4e9411c0d6af473de0d7c6d09b03bef7185dc2fa1179309fed90daca14025962cb88d5ad996555e80de90326794815bb9866f5ba466fd9b3008be2b06ea3f2f2c26b63b20976d63ea5b114718b4f23a161239a6d2b23e6c3b116fab84cbdabce76e282c86826c9a6056d953ec65d96667c12ffda0c86f27e86df8ae53c3d388c14bc102923f81291be185ed164435d75a2989b8322b6e7fe3342071e3e80796d582c499e53fab59574a761dfc087bc9da33be44b98e03852419af0d48f066e08bfdf087a330fe5627de0f6a1bc34b497ddb22ba0c9970f87f542abcc9c53d373c81507650d67bd3c10045307258306627f96143fd00a98d6d6012f449efd645acd468057ac0b4feaedd86456d5fd1b9a1c7565e10a43c95b953b30788bf0d4dd47ca70c1dcc3d4d4c11c592420acf4ed129c6caed56625b29304defa6a02bf3b68d46ffc9eb8d2ab1edca0f471d53f0cf90176da9a3aebc5bbd16f4f3969f76680888a46cd743274786bd78388134605d361b1fdac9eff5e905b4dd770262f03368fb7b44660bd604db55e547093e5e1fca8ce23343018e49fef9b154514dc3451d649f7091320f64d634c3e78d82f993654a7975860c23009f4b88678267a893cc9d8356a3ba52dcd83c09bec865dbcb51d68c977f899a51d91cba9fe39a842463e3a6a6658a20588bdbf0c08ff137c4284b066a64780744008b6d611cc65e96e47b6f0bb8ff10c34efe448d487b58206a18e1f512a4f37872c9099e0f32da6f634d3f259b80ee629634786ea9fb048fc92038f1a69a9bb7fa5a08864e7f32195359776ac3f4dda78d211a2253233258ffd18c828c4145be3ba1501b1e441692d116889d16c9a15af3078f5225aa126366a4daea3a17048fd8871e1f76328325da39441028afd59426b38df9d8e8b786242822f3abbca097d9c7b20b18c990bfcf802a2b0554e970cf12cd25058a589a1e9eb06cee3f348ad6a51708e1dbef45c29b3fcc4a6e0a070230181fcc3cef8e9bee7946294d3abba9784e0d3b58e1aff7627d29bcc0232b6f3c6a209592c48fcf88521703237946182a214ed3399b4bf9b2609e696dd7e4c4b0e64bd3c1b2129b81269c2de4604c21c5f530d0724bd1374dd226487a9dbe86a61df7e89d7464a44363b745eccb6413cb5175e3cab90c3312ea3e363ec9eab6fa90142f76091733a9bddfa241a4d5f2fe704b223e2b7402f4d77f584935e64fb34c571d3ecc76effc290a0541209cd8e35b6b366f89e07c3be1c12caf1008b044095c0283813adcc53580b95facce399dad8b8d2f745e03c5b7be9ffd1153c842443cb260fc1a97c84deffa5025cceabcf9f16d757e5f46a2a6ac5f93d39a00d43ff98470a8286edc14a1b9267b6d88733ad8ecac70de5a3b94a3f946642044747bfd9a50849b4e17c1d5c843dd408d1f27255328a4a8d7e5628e42eec4e4f2183f332ecbac11e418d2315ce4f7bbb8aff24b4cfd48cf425ec49d7e11ce474a126748d5b6155183dea5eb16692563cb3931154d7b7e1d24f0f43afe38b0547541ceec124ea990d110f3238fde7c4f3edcf6b42be4a6d9bed0910fb016ad8b7004b59cb2afef6f698369a6e1ec4efed8a34327ce52b186a5e5cb74ec673d125498054a31f347743faf27ebd91b72b4ed19aeee5592918236ba9090ef90ea1e112469bccd7f7d03c9a0ff27330b0730602a8309fbf151a51ec95e9ef2ab3b5a76ad5f65f20e76af397b3f6985a0ea90e7108865d34b98f6622bde80521c4c0644d4aa788038c8b570f45138a90b436284c207eec66fe5026be246778e32a8104fe2b7c35a5b0febd9190923e6bc7f224bcd6a42d6b9efc08cb5a30ecd4c5435d25badf32ea30acb3146480a557f445602e001d3fa0dafa91be4069bc64b89143d5deda477f0046d3a72b8f5c8319dadc82893c50026dd6b9ba64565f781404b0492b35623d3ca5aab740f908724a751af572953cddb8b369725bfdcdab504b35f86b68dd371155c5d7d3ef79a424cae58bb6df7fe8494802e1d9dd8673e3b0de1bf107da7f5f1ff76bbece64bf37c12ebca6eacdec6afde7b2050949a35a2bf3bfc52fd62d647f963ce6ac0412f87db7075ff5214e6585ae2424a6ec3d5d1a281b00c3bb65c5b8379c9efe33603c89aac7027c66d3c8832d7ddbf05e5553331d79d9d1bcdd4c3fe521a7f943c28f800e0d221259e71389d64c033793769d45476c03e70dc50e344d5cf421a45090466acb284705e2873b30dcac0f3e62c1cda4601bed74b22390040a7ca0b949eaf8aaf9fc2b2d0943cc94638c11fcc4c8d829001ae4e752fcca10b0c4cd17f6c50f582c46b8180ff15bf61fd537b2831a9d98c2d0d2c0da2cb07dadffd440c1b515d2a453420f7a48b2509e0e1248fb9170f89076b5275489c724b5b6c19021406865720bb32de31d1e1fe2f166194c8a713e2f2023233764a2be5025bb0e6f7e4c99563898dfff30787f818b22f9e82f1165a42d180534ee9f3c1c33e35b275a2ba443dc92f0ecab92498ae01509f3692d3d06762eb58cd9a93003ccb673b713e8fde06024421626f9b87482c5a03fa8c19105eac81543146283bc596a07c8a879c4337447e987fc6493f4d7cc50b65c1b220bc5acb84699cb5fd6c552bf8f536e5a611105d7536674e549538545f1b77e0dfe6899e47990e0565ff87c7ac47ead6c255866bbafc59df4ca1dad43934349d62b65b410c5edda030867823d0525a4d1eec1ac72c5aa90f568593a3c106d880ea7e0acf8dd328e2a078d6cf12cbd051cbb3416fb3b1aef85642617159d9ae6758136e0ffc796b83ffb4e46e72ab674d51a182dcfa4b57e6e1d7da3fa841959d3be133df0f82721b3c853d9c09ded5c8a6aa4ac21ac6db20a9b66bd28ed040e96f398568e6a693eaada7f91899bae36e6328b1ce9de0a4c3a47590805e47d350afb53f9b21cfb3b0ee9a849c77b39a14c901f2d7cf762f39b91e3cdc1a5c7f2229d94e0ab9f23743dc35c14d271531ace071b7eff69557d59428b717b75cee1c870fac60f1b343b91becaa68d82e8f06d5ab70bf8c4fcbef3557e5fbe7843608145e90ff134d88b526f99bbe240c63813187747ec5b20f2a91d9d0780280d8715983896e1ce403c6edd2e042e8b21040517054fcb7bb77eab675e4556f5fcd187b7ca1caae97c026dc8a3e417d96b7a80763ab3ac8444743fb379fb032647e72e1318048a2441890968fd7b33b72c88ee3a050a24422eb20976ffac375175bb9886aa05ad2f0d63ea842a8ca6b7c4790cff522bc2b6cd7252e127a9392b68f8c79b1cc29c4a28fd26f209a4f0b2c2aa03a2cca71627f59986e071e96dc1dd5389c16b276e7d40aa7029b8c3f90d16fb670d5b79a536839b1b5de319d24e1f3be19d20814da78257e946803fd171eb2f22be4cad69752e2fea71570e0d6c37294c34c1649fb86dcdb936b6ac8ec99df9ab4ac4d4b1163152abe72133d20f469aaef479f3588d641398f3ab0bd653adcd3ec63018ee49cf1e323c4bde63de270ef8bf12ad900e253024e456686dc129de17b7037cd616d2c4cab0bfe384de46f2531ec2dc5c8f2615f5086cafb12c815ffb8d5f74948c306c879265a8d1c87cd661a34124fec1669d10822b4cafb5d18f50df7fa92cfe9b0cd961a6de19f01395531ec95f2457e42235fc49309d99678a6ad34951cd9b10851761aa3429c194421fbbfbb3b1c3ccb673b636bedf3cdbc52017b588ddd665120ddff9a3ff0e9cf4843d5d0e1a1de91c3a1bfd4de98724db706eaf0a1f8bc299be313aa406a4a7a2c0b8a0e4a60d8e753897ee7e2fd7cf768e3389e2ffb1918c5e6ec9bb2bdffc118a0d4dfeb37e40f9baf0a2efd1c524959103de766756043bf9eefc4373186d38905bd3be3aa496c011ca75318aec76ce505b2963a4f3cab611986ad5fc44395932f01e42c072924ef4d6daa2d182b815aeef4c14cb95283e3d006f9762573be76cf36146f812c1bc78182694b5fd0628458b5ec879946696c932be9475ccaf4ae8f8770e330e6518b25eb1800224ba5bc4441f8fbd09250208b88dece554266b72792eb4731c1747b00546c9dce09433a0d8d3004d0bca515c40a033e73ea9cd01121e84936f91650f4048775f65fe0637486fe6ce1470c3fe8bfc8e21a64fd93e6b6e4022dcc400c597b46d342dfa9702ed9746c846d9bf958e079a62239f209241bf9899525380d27fd9ad5862f2aaa0ddf18df7562346a0c38c959bf25e3a86a0292cd7a5ed408543dae8b7762029f233f895a8ea89934ac8761829b92b276eb43b01b27e45ef597346bae9808ec7a9b880899e9447171caa8dca447b06958fc89e4542edc9f5e90ed1c9dd5323f233635114995422b4bbc331ea8532ae86135eb8fd281ab7e4766e9d72a242df4d80f987cacfd348a387397a9f3185470aff5841971ba8c94af9b1f6d45883c107687e71cd51dd70f83c55028547d6ede98b2b864229a0fb9f2bbccc9f5d77dddeb6cbaeda77d1d8bb9cbe829acfbe7a1b8c73601ffbcf86788b9aecd851382dc355836c601889b95721775b7719a37c7196b9f757b9a741ced330c794bc692064a6f2f3c2f2db7fe6e8a381f5ffcee6f02b87838c2360bc14207807acb19a45e75f0155c4db6adc6f2cf19f6bf9b0d57a2a5f489ba8b2c6285270ac2669fc95cd5f9887ec2af886d310f5664be607dd0276bd29b6c6e7f043e4410130ba39112d31ae413b50b9d6155e1c7fda067d8e78dc463d0a1ec92f4c7996556a347e6a6d1cc98340355517a5f1707b43b6a2ef792f8f5e6a5ca06cbd36e863c3413b6cacdf65e413e6b96e1d24981087fb1395304b91152d660a6164d6035c9c92169f1b84cc1176bea0d3c1f0cecd5a4339ea8df77a76cae88170d1e3de6579ab9a1932d13dfdb54fa4eb0a0fd3db36e47bacbb5fd99f0009e8c3f14ee6686ecdc4e7fafca40cfb3361be31f0d22ab9412e59ab952a3de4a493b33cf7328162363194a316d9003e135246d0c2ead155623cbd1f9686384546369c84e92af7e986a54046df11d2ae2c2169e5da2455bdb8064a834d63740eb9fc70cfe3eb6c9a9136f14a5df07ebec6465c172df34a9a3e9a2bce84b6e7d9fdc68eced3b2ef3229afb107102f2af5b5e69d43d795cabb7876b673c1014d5f2fa200a63a1e7e6ddb798e6cabcd55e75a59ec9813e9a327c75c70cb15403a8bf6f444240b451795358084c071327d503095a5fa6c6219afed0107c49bc3022018c9987e6aa46e2a3b9bf84499d5a2e0ed2db81e96b2133bb1f5b5be28fb355bc7cebe125e7567e71636b6bcf6be8679a4cc1e87427050418803d4351c0dcaf08bbdc22862163051c1b1548cdf4b520a492e51abceca4cf43e9449bdf4b9cc9012a2ddcb315ae353e1f636ce3ce7f26f1945ce9cd14bb2ed83b30ca91035d8909d6b983a5e33344141f5dcc2ed5f7c5966c1f48fa0972cd9f41df534959d635d3221da30b857f1e2178847d93385f29c9b8a2ae7eb0a473d63a75fd32cb52988c925203a969878318c328ac1187b4c98125f2b76b6b548b1d47af5a85be1ce203515135ff11b18dde8b011a8b0d23f212dec6293db0ff0dac2938ca856681e872f6bda85f7dadefc5340b2b210696b2a04aed59ca84b7debe27fcc93aa386b4dcf4edb962c6c29011b7f81a59c2d82fda34215d5a6b474a9d07ee97f3fa267d2d4177b69ee582d795d167b8cb100997e14a944f9adf97c2384476e1f94def06f386ee7a800c01720a4f1437c1262c524d793b843cb237ebc47d49e9b5e75ec196af9cf6fe32f63487e5c8f7d4f08cf0307c9f13a24004704a83515f5ad3c3e0ed54e4cda9b246c0eab6c4506e365520805e90bf8e43b6de7dd58f77741c143b4fd85cd7ce935d8ec530796935d11c7c2d807ce6e625dcfd2a844577e3d8acf675f0780b6dda0e98cf7f00e5307dd58616b2243bf82bc178c77a7433628097cc4c07830720d21005353460010c4115c395093176aa3070e510fe5cf6a80f7510c38bf5b459e11b261021852d989e614b80bb4605b1455e7f854f6e3b5a9bc76aba11b030f681eb7782e00417e9d7d77d4ce849524b3da51acba631484e4e8f4b8060fad1527f95f12c34585e1f4af1a00b5bc47bd348324ef18bd85d8adedd6886035b0fc8ef8743dc860ca4e49baf3f879475bd1c7e51559b7ebd7cb0860f30bb8e210249ab8ee404954bdde7c04d2f11aac5062edd74018c35554b3361d7a09ebf54b7f34b64970f3d7e0ebdfd32c2c36daa9da3060641465b1de168120552629eb91113ce5a71a2851ca4f07b9f69179e6524a3b040da0db8353dbf867607412097d65ff3dde95112ea91d791123d76c9e93047967fd5525e19a12174abf9212232d4e81a8c11c44ee99f5fd5cffeab658f4e83af293004f0dba9967debb84d8086580179866c231f78467a79c330891e7532f299438e24ed64850dc4111fd5427d13f0beb6aca0012fb502c40a185d560cc3a58415c7a3c33a455ca3ee14172e301736c06b70a5b0b3a53cc6aade63198286e7ff0f69121f1cd9bf0d8083c315d693338c8ad2419402c4cf3443029ba5dfd8da26fdcb6d567b98834c290a5a2a382c0f678cc4a0f60804aea2c270693f2d9fee9dc6e766cbe105185fadd79fe119b81f5715817e6a45f2c8951947eb6ea015e797865f970f294fb32161ce1ded56783cb880eb99a787b80ad7d3afa4298891bfd52e0de98e7126a1f8a873d35a34d7c0462be7b8972a2013bca5be0efb56a9b075041f6c00831aeb99fdd74ca0c8d1e51aa11e6641cbe6d9995a4940eba2cb326b4b7570717c7ef26e00f7e42a70c78a727af57946cd75fb2ee2ae810e0605f02bfe72f00300d22cbc0fcf3454858d7ba8a8ccbf89198a6da9becf7e98b05208eb2fdf92b8df38664b712fb85f5002a9df8b8574e677fa5fbb4639389e8f91c30f563e3e950551afee13504c918b1ed12279eb7c8ea77ea4daf1dabf18e666a89b90dcb427059b64bdfe80ae73390b0dd2d0ddc580d34418ec15cc0dc8e71e6486ad20a74e6914520984befd6aacd74ea34a93127c630b1b7dcfc2c460c9960f0b1599bbdd6fa6993e9124e8cffea16c3139475ea81d49bc432d6659eca2f18758e700e8dc7bd2140cde2971ab0bdcde18fab0af30ae17d652818c601b30bc4f8807c63474df9db76ff36b44f6e55fe8c4a8c151893789c747f47992cdecf5eae1a85fae1f35a7572a194cc6302ff03c255b53ce4ed2c984876f051c38d4ebe3d70cf36d79573e2037eca2b6b1de2c206010cdd9e50372fc0cdac4dfa6b5f775c62657639d20deb2db00915347a42c7c1a4b68132d7822fa4eee96880f262493ac0a6b632c4d4488f6d678786c17dc4968b6ed1d6ccf838309ef20903708e11691286f02061cebbc4617caf9e0e2b26854e6b282b3b4e4eb86a708315409e8458e42d38c3a8a23af5836b29291c57688c4a5f8f9f1c73c038253231b76ab9cf0b2e5248d03afc6ea7a1cc2fbad1fc578ecd464f933a4aac4497acccb2c42d19a2308d166364767205d10d9cbae14237f3da52cb49c73499d1c775d083db8acbadd1c0af9ec53a793c6b32ece0b3c7d3c8e05b8cb31c6752ebdc914fa65ca88919fa9b471e81eaec62582a5ed44e55d8af3d95db8854c371f8aef374abcdb5d1409f96097bbe21c921ac7ffc7a33ee3e4fabd2291486b303061f376c6f40855adfa2170f76ced78291866054d675d6f5a66ffd9432af27da2efded94a49ee2ecd86945ba0f6bc15dc18e4f7cef242a22c8eea7a2ac343557e87c1a83b090c69dd229c95534999f576e7f409ca1243e02a0c47bf117012ac30abf1658e952692ebd04aa19ad1f582597961eca710dd35c8369bb395e83ff58b00bac17f3b0b0f80e38c10359ef5ccd6ddabf489adba899d99d292b41dc54c604bbfbef3d9aeec12555b13ba649c48cb2e4c4b3f5f9bb3956d6ddbc8cf6f28632a1ab67d174fc56e69689825e307d3104f18092a93984f5dc09ad1ef1ad161ea028f6f16f5528a829d37cbbd65f19e1f938a986002f38ae2b3f13bb6084a8af0ad11f9d4373f4dc161fab114f9c2c4a7f07b381d139c8125efa21d479f64b4468317df1c31da38d5a795b229435fbe0886e101baafbbc531e9405dc8f951181a33b54fbda6f0d35d3f1c56ddddf6f16d8e421cd7b8de9a49ae99e434f10ba2b41f8e25c67f8c38ae0c941e8df9e11e1c263e4fa4ed6495bfb20c0a30c2c1514703b01c3348dac173b88a70c3b70f4ce63af2f135fe35647a8a33ed335e7cd0984262750ae5476575522801501889b80cde9f59ed095a699d49c7d083836593866f7b71e4df00936b2e84ee1a8d02e35b0b4374b31a54a028f0b26788568f9c099f8ec4fbf267f176b10c5878a5378355a84f87ab1339dea6b62bfeff91c6fc0ee70c45a6280dbdc90570c7371e5d6eca9f679fe4ad846b4764ca096e4d1a7338ca8c5483ebecb7f87d14782aa17a1f20a9d37a744fcb092d7aa2d323083b4e24d653ce5e1b93f5a0c168c95af8431274accfb0eb063768943e52208ce3922e92227c4200f5cae16cbcfcb4957d3f7db84c4491ce32cdbd1678b3308eea1c59e08a33c757aec0d83c7adb2a7349fb8154cf404db8f7a7395d676787e3ea35c0a8c4690f5894fd2ce796d211f03146b7d2cb1005ffe6be728634f37e82bc58b74519ea4eb4a8e3017305c0893d320c737b510f92d884198095b8bdbc66d2815e9ea59cb44f9ccec6f5b443195a7fe2e7ba53f4787869dcf6bb5e5ed65c0af3b688744e355608890a1a5e9d47518859899332d92a36e277c5b15c223c079e7245bbba72555648bb51602dd4d2a574435b10cd659f1a0c4bace682ca8ff97dd537ab85b44091caa040b73256dc2d8650d01227de8f07a99ffd70a8c26d51b1618b5438d1d1d1b3f0863e23bb81cf8dbc9550015bf5d5781f90fdc3b146725772f64c9a021ade471baad068e4aed3f012fe51884ade5608ed09a658dada79ef55cbef086298dccb541f79ebb471b254370f6b6d668d5c3114d4165ee5d7f613750a4b6eb29c43bb26135705d4fa6b1f9997318d175bad4091581ad71299e1d86018090b0613f1de72e1da2112ff58993018fe98834f68c6d7b03c6fbda5629d78de260093a50aba35e2980d3ae6777b28602e6046685ea2e80e376fa5665775e2ec33bd74312b7231b915bd46ac080a909227fbde7a59c6598a7fdd3030ea6a57292a9c9cf656dd0d96d6d024dcdf28f293dab8f0770469ce389a6fc40824f85572c8b75d638b5f0ff25f1177dc75ec56670d32719a54fc37207f52231f19ee971e87cea3d75a0b8deb5ee02d219e691f62cc80640a1cf9428193ca4889ea10352ece37ad8275ec07d779bd8dcc7a5ec1357254b87a652b199eb044de6c06867a2ec14b94b9331c0a40cd94df5c7fcfe2312118ff3de8242616c3815893ed95afcc8ba23592eeb42caa8673b0e841a4778c6f18d9925107f64f8e90b969230354236b6b81f11f28fae9344e851c64095e605a6b2756d188536a527dbf3eb1caecd3bd4fa63ef0dfd1fc0b6ad55ef960dbcbd07bd08286e927e75d8899233baac9b12a98cb6648aab33501ac3ce2dce340bbe6d7e075cb32f2d8bb9bb8f5e92ef98ede61d3600204479ff80c142c0f06c4b8ecfc82bf9a1f6c1db87f6ac2dccaf94df3e2d29ef51b430e6d1ec3308f693be5dc820cf8f4941f19adfdecb4742c4e5fedd87ca5c28e9eae25c2dac74de86ea5f32e21f6391df53ae86a4d6edee6ed2ceef874cdb60e55582dc759099ad0c1e5b3107357d68cd0bf9e708539eeb5a4ea4264229b0dd30f8a08c151d88928925c390059eae8137ed359a004ee5cc54badf7e59021d3785de3e60e8ed58b84c946f8d3cba51e89f4cbf2db0e0e3bb01499a6fb015a6b9bb568acf325fba3d9facbce7be09f50bafdeecbac1a3489b2d2096a2c27ce571443e2bd9b0bff3c235250761c7bda8e058e93b8a729aef7f9db36bac496c3d274d30c09d903ccce1404cc3d2826c9050484359f6bec83ca209d181e5becb348ef56664cfa36e0aab8bddcf3416f2fa5e46acf2815559f08251b1ba9e724cfdd67b0d8ddb738d1df805a073bc25994171c26405a52723804da9464ac1670a337ae28ef5ed37bb8513e3b2b1798835008631ba93581d6980fa29e378281a1075e08cff84a9040bb54ffbcc26a151d33dfa5d6b1ae7e994a7cf98d3a97f7af36063de065aec9ee38c76d704a637df0bc5329c61d76cfbc5ba6dd23cf0dd99d3f63b8bfc43ff13b57e7e34735687470cb1edec4d7fee07a220d03d21ed47bd7b0fb4dc3b4ed9f524e917f688fde2a9579c5460aa5791f7f4d9c386a8006cab2a50ffdd4442af3b756727fe701cbaf41af64000e4af78e6427986ebea2c0f9318a4607663db08093637db9eba827bb435be7e4bbc4398ebb01350b1bc9f310a102a89a7ca2459e7913542f02f13d48026fbcec7e462291d946e19323b9ecc2af9f1f8d7bb0dd80faac681633917b48eaa588b657f27d01cb87b707d3ee1a747f74afb4ba6bf76a2367efd0dc2abec2d8bf14cbf634182c25d5188cc66d438c174f10614c169e2b07f25d5a12b904a82f83270cacd293f74af9b8ecd7f4779575914d9b6cb4030f74f51641793b14d1b7610ad036a3040d1b4d9b53a7c44614dcf9713ca4b758f0a8022006727bf8e1a4ac90a10a05c357775fa6f9ee914dfa67bf99cfdeb82162a24a8a85ce30ccf00bded96e4ae3f3c49cb78756640807fbda126d5e0c275737b9bdf2dc778a9a5a3ac22fdb9dfee1d001f36760eb0c18a070d9b7f85c7079a0e53ead7f3f8b6e03bdc32c7b35312727f36f156cda1fdebd1bea4efd10901b49cc4c83b0a603ead67eff6504f2ee167221b3971e9e5af94ab1fa71faf530df924eac038d1de4c5bac4fb6e534cd3eab8dd11a0da008eb7c685ef6d553f6ea9c99f6433daf629685685e1e9459faf180a2bb4b75be6542f9ce1fb138fd98e1599d82138f7beb53cf4067e04752af481aa099fd572673848d1bd521da1214b7501afb8b8284e2307af0a03c7327ba9cdbe344dcc38c5a346ac65087c77c316cd6358ffb35a049754f51945d4518457a488df607aff324b9d74d99839390a799d9d4ff90ea826e3a27a1f6583699b9c0dd5562a673bfa672bef09a08d9e64040f8f13d0d5d7278193193ee0bbe0f1e49b1529e44d383dd02c7bb611821d35e67ef8b92633c5007a42689f41fe7562fc3241343c4fea3cf654f5a74c6bbabc5fb3edba92a1982e1580225f2a0546e3b8c843447514d4b399f5cead69498870ac6bb667ca4e519ca2c95b2ffa068c64d1f3f43ac779e3d7d5a5f37093bdb13971be505c9726abb8d9e6028e687a49b43aebb8eb355448d9be87fcc16cec5fd9ae7b2fac48aeb5d878a324e6e1b085c6c4586a34b7fc67b43567ffe3b4d77b5dae1a26a12fbdcdce3d0c14c1a454c83980b42281e80979492f71386fc217cbb8b14e630df68da3858d8ea72df99407ef63d3be1750b585b3be8c2f41fc4356417c8945fee2ee5053c9ad3a93ffa91901d872c24980af4d8a73945979902623857a2d394ae4ae99c5b8785b11b7e15c4e08a37bd96fe47f67b9c6085fa9600c331e76f86190946f7330f438f345998e4d8db7858bcc6dec64d974518c5bf2406257f7ba28f7d49a70e0dbc9e8c7c39927362d35966d6ed0e0b0dd235c08a5aacd54d0989022191cab2b245a54b7263be36a6fc808296e2feb24f414c5c115ba2b4b6a8faec4fd3b741bad620f51c766209db4315521a6afd9734838829bcd161e9b5558f1565af8ef94aa42574e7a6de30510b98e5eb7ad588f3fec42df4c041e351d1632bb122dc182e3d19638ce2d67d9ddc1d5cbaeca455e5e58ed51df265fc90d340b90384fff2469b57affbf9e2c538164c8ab5ceaa50aded08a95bda24775b94c7c4c7804e323bd18d38e4224df5a7a1b04cc4e477121cd03892128403de4e4acc3e3c2cab8fa4f79a92941c54647b5c94dd54f0eedb18a6cff5e40b09ec946ac208e70b7ca5fe80fcf1e34ac6a3c824c7615df591e5bc9b120bfe2079d68d11c65a676867c17792c256a6618d84b9b6a6f0efaf3a638d0b7494b813a5ef02166e0307624f5f53f510ff5ba49c3b1250d38b4405af0e2c389b87d6b8d2c5c0cd8dd2dd305ef46cfab2cd5a0401af9cb612cc1cbfbe715fbe9e976a5fa5f8467ba8f1b8b2ed92bc489b51cc097cedf30fcd8559c3b5ccd96e1e46ab90050c5338d0dfaf943396e132983ddc82504007b843b700c0471ca347b962e50983b3395a651e2d2e5ac8cf80925402499adb2e5f1e60cf48ff8d8c7210b7a9948c3a956a6e3708ee20e2ef78d8014353724879122982afa8dd0f0327ab1d7d492df71bc340d57d87957a6e3f2c69b0e15e5720c55de2b700214696a4129ee1a7ce741630d42424ba708547cb5a2b4bc9ad3f4781159b33dbea854a0553a7d2232bb4001e918fd0f37e6c7055d9371a0b7e7e0ae254f332e728e14ac0ee93de8346d0b3916838c3213cb7ac42930c1f20fb532943ef3d83ab3db2b97f154fabb986ec18178da49cae4eca7d27634ecd48ffafe20bcf2d96b8ab2e61f5654c4e7b91f249d4ae33aed6aee78340248f2134e9fab4fa68201ffe137b2e85ed0ad76bd47c3e136e1c0d2865374eb587343e832b4b59097da3d55c4b2620836e591741db48015d046fbc694c2a8dbedbb9836967def21fb2c7be0c76e3d730ee1dbd58aa5090d9210a687eca3c6995c70e1d0da2929fba407b8ad961147e30205c98c473fbe5851185d49a8866afe1e89bf2dd74c055f5f8639d700bfbccd2237b0e43feee43979474346c7a4d0ab53b3d086c282b8a76dc02480c3dc8c935de8ef1c4d3cba91bafce5168541e47996e232ada92099da1c8e960c15cc297ee1c589d5c90ba18de049d693949e09047c23e08fa2c402d4ca1140c17a997707bf3d1f0408a700f2ad7442eb37a4577a708754a5a37c5d8777809c6020f0dbc49ad5756c319b2c3180ec9563f6ea2463ba2a3517e4e257f9fb3c1e5b8e0a7457832aa3329a6c4528a80a4b31ec18261dc49a029ee70b68a551486049212639fce281e4e907526edb96a10d458532851402f694645f60587e6e0126b6b7f1f98452a465ac2c96e6b429f179b4c47ba2601a27dda185f25c7d92519d4c133cdedf2c5a1dd92bfeea5a7874fb9f02d8a9aaf3e7cf10512c244544f30e9e06f3a032766c84683d983c16427e8c8d0cad021f8ee50f6c4bd183317760c54ce20ca1a1d4b8804d7f72e4e012a8d7bfc8c2e9f1549e65d00f6f2d3819b67b82bc50ff415331b9759fdb54fee2c4dd9d90738cee74782e216d84ea481bf5e06226ab29d332f5e64d4b2120f42873f311ced27bc3eea05a955227f02098a34d0ad3edbacf179c4488c0d957885de9a1d9e75e3d9adc130a30e49ba2bdcd8b50bd2335217238ac4b42fe8a91c858e21cead46e50087dc97194c12f099e11f46e2cf8d8707056919ec5d44c9979ecd13cdcebd030819e454c36066016626cd6ab0ef748ef68be2244e6334169ad42e0f98fdf4acae2f3192aac8394e23ac58cd6c78baa840751ff39dcd2bf7633a17c94aa1a1a3b8ff5c27472b3109ee11f775e42b8cbfc6d2ee0e34d586823cfce2ce7926f3120c863c7be53d778fca0cce6d8f9858c5bde2b11cdb924c62f0729eb82f03a188e662555951f9543573f0eb873c9a30d9e79bf17c964e75df16af5e29d881d666cf50d0000d9f9b1378e859b2d8e1b90bde629a7129fe815ef50da36466eaaf1c0635a87b3c0d23cf2119867b337de8817077ac59f4ac30636483f704dc80de623ed2aac6608f92ca9d46eac622d873896a132bf83c922f9c4d04842d9fe8345d2d747232adb399491a66e5f0c5b2e304bf40ab33f932b98fcd80c599dd5a8801798899e4303c0aa644f349e379de99ac1465f37dc623cf992a6cab80d8e91da4ab291d48e2e618c609299db3024ed5630d7dc349a20cc6f2d8d121fe5eeebc37a92e12ffe35610359d4e6b0858f852b625e8fa192de06870ab9e8fbea4fda880c9a6fcbd57f2ba04309aeb8b8e6380d1f358ef3849f471c843f452b064ab047c11a3fc442df55f3117af6736a3be9c64003bc5667adf85b90c560d65fd74cf3b338dbbedff9604e705c6c571c6dafaabbfb2c12653a027d3bc8023a56505c3be065b0c0984bbd6bb6fb9f43a012cef60946464ad240e34b33463232c837c4b429740d247a1f4698fc260caad214c949a56f6d2456b3ad2bd0541056409804688caf8c2927a8f2ea74b244f95fb14f61ac5fba0c2163cbf065f2c571e51ef3834662f75900c5638bfd180c8f3a7f178641a456af3b998312d9ed716bdca118771c517ed65259df9a902d5c15ba16a4c0970439588392f40fcc6fb48268e9336a9da223e4339458fd2c427fc36c515004c7f8b6e9d4104aa2c7a85895f05aef965935ed43516700fdf807549e6cda3adf6f0fa532396b26668d7436aa099f866253251f2af31940a6502721b7dd4aeb025b6ee7333f60560eab18cd5d7c0e1d0146fd11a9e0698ffaf98a532dbf378bce2ebc2be5456dea0ddb1ba8751b7acf98630582617d6f1f4ddae48d5394f985093cc1ae5732525ece698a5a88654218f1cac24d6d2150bde811467eb849a1e1e67de882e6e6458f2304328a0ab3a19599a7bcf8e9e0dcc34fb253de1aea7ebea57b7dd9e985f618767059b92b9a4935bd3d6535b177326617e24b1fdca47034c69a5a7423d3df016c2187ebd8ec0bd92a4ed040fb4a0e9f646e2b7d04341a6fe54a337b1fd95471cee683a38b60c53e7f1a4491246283d0a58f1342186b5b8f111be02a6a0c5492b24e8b7166ef9c71d2b128f018394c30cb7d2c79dd3fe9eb49d92ecb8c1557622bc61db5dcc8f7455d8fa49d139db9fbf4d1b25603ab517a18336947943caa1a5f50754627c99dc0166e2d9273cb6b1b7a3f3003b195569f7ea66adc91677b9667dc6274101e8517d85648fa92b40ef6501864a085b15fb4e2d502472c4a653228126c183d533d72f9c84c79da0ed07c5c70a205e1bcb7a6a0bf601853cb6f3c0ee92897a150b9220ee98ab23d75e1a39eb9b1ce7b601ff8c26ad931ae217b54e6d203211fbfa6676e42c76cd17002f8a14131c4a8293fe4795dec00e898094b7a0c7460ba97badd6faabe29576716bac2058a54b76215e79e94c0e96c8b1d36734591acbb60ea30f77279e898179621a9a84b91778f81f4699b428e9a6a66b058bdbdd80884ce035733d36b7e3fbac4fcead99139c1db43781e95d92dbd5ac8451639099bac529858ad538738538e76a09d3f708aecd2770acb1951af3dbbab82b0004408bd2a6ded330e5832998648e26cd04a67f09485ff9540cfe3b0b3dc0e15dd05c68a64691edfb482d80058396832d4b7d26d1e1866459e30836e3a00f2d660348093f4a70928ff2ed1e1e4b345714079836aec211d78aebe8b56a0e9ec0ffa5d3121c98d9a9b0d8c4cf843f96a8d3ac005a8b81b2869b0e35b3baac0a8b0942a0c5c56825c0ab3f8e3e1734fd41d5e75420bdf06cf5b28a48561a8f0152f37ea3971d29c650d58b370b521a84ce9dddfe3b7424bfca9d94755a67646a55cdc9d3e3180b333c2bbf69b36596f7f4b6c7a1324c0613fdb3cbca8edd760a95fc159fafeb57fa4af9d1c181bd2b8f28678c1698cbdcd5a5f070aefce97ea961f2690b42baca066a78f7ce2745dc8b8c9c90f9de03310931b37915418d80da139bc9bc92bb70d87335457b729b07a03b5844eb6e78a9d38b59fece36499a6689509f57e5e39d6a0406686de30ffd8f44e67456022b8526f20f94c08cc645bfb5953a6633a8de9588cd4a1e87f4eb3a8f6fc90771eb20af12b02cb85117ef53462b755428a996e7fd937c31f8663704b8ccf49146e3bc1013c683b82187e20dd7674733a6409f200a3ca580a438917330fe5b703332411c3fa67175896f9ab3bbe33d23b1dc1a84961ccc1d4dc291da66749bcb4b57ac17e92207397a65d6fb03cebc61e804673bd812d22607ba21ad88ebb91544368bef00efc6f45f94cddf586251e9a62491b52b82f46df61c67bd46383e10ee01ffee79daefe4bc556bb1fa577376c4c18ccc8bc8309d22b13cb29bf12aba3a2a9da784dfe534e814d35e00077ba68169847b6f97766cceae8fb48c9c1cb79f3e03fef9a7c0ded7f8585be5f0a15517a34e834c80871f2213dd9930c6e043055069d45768899c1a31ee0f45bf45a8bb01f3ebabbdf4ec544bfbd865efac21c4af61a45d9e619bf8271ff95e5a6cf41dc85fc34ff291a4bbb4c7d003dc384af47a71f8c7c8a67fc0651695cc6412fd59c446dc4301661b6895cef1408dcacead384c8cf224237a1ce12b070ff10b6839b74f65a8f1b4c8dba2cf09621b1b623aceeef27e9cb5294aecf266de3f74b51b508f4fc174efdf7e43abcbaea05d67a200c61599d5f88e865dd9654d08751225fa9a053a129675860421e73321414566b3005d93c578c8eeede6744b654e8e18694d893199661de697e1864cade14115bedbb9f0f721625771c5ff34f8af772b55fe0a5e62bc85dbd0f2910f49473a2445f26ddbb2649961fb5302f8a34017587d39877dafa81683c0b346b9ab8df96feec9846e4fdd2c5ac95b7c951180f8fc6b1aada79d4ea8040a6ead232f2a2912e8701afc57a74ea49afa8c3dd2c4bccaa811f2cf417fd15724339e4bf616863cb8360490fe3ec6a06756ea1374012318d8556f7cf70d8cbf03990833f7263b8ec4c24ff8c2bc7e0a4d50103bd69616c5bf8b06a4ba41df44c08dfab8ef4fbb9ea87fa5e376ba40445aae57459a88303d66e3d07b6ebb5c4fb8cdb82d10d3f0535ea8a762f6b1ba6baf0282743d1ef6077354db63b3058c14f24d611bffe44074e3c4f24bf49a2534af6a742e5d33f67337292767b7b84510c9922c515fe73b5d556d3c5487900f05cb3c304438e280cba0b4cd577b286a0ea104b1370f461069bf8531ed9f08c90f373bedd03f6784634b67ab0d888c4de289b80119b202a5ea4a6e1912c9dd455e8fd0f039fffa29b795f4a3ad82072369405","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
