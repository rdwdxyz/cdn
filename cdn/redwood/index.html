<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22565310fc68ba377112c709d31445935be0f5519cb36fe8f05fd4a1b05622db396d9ff8cf2dcdad1392f60ab7003117a6a508c28cd268badcccc8dcd97d4fa74b11123168875b9979e73144de585db1280e486d48877bbebe66e4825f08dcfed2876392eb43a19bd922e36dc0a7bde513f01d9f8e8a4f50fa73481cbbc7ad06d5491072db87198a6cdb91271f65243016eee4d4cd0325de6925d45e5bbe9f7151dbbcab3f57abf0bdaa959564c49c4c2fb609f953d4e5bdb18fe9e42a42ddec577d4a3c1a179ec381bafa62fcc9a9aa2f3c98988d53e0f0a631cc213fad81e6aad7da1dee1f5497d87cf04fa6eadb240fdb2f038228c4b7b9f44982f7198f6cd07dea949e777d21daf8de5e982137423bce39d8a37a7bfea40cbf330c1c12bd50cff14ba1cb6cc82824eb3e579c0341cf31ea33986540d46678c66e816afba522f016959a4265122e09586cc19c6fc28370eb9e6df5d5ac8d93bf6d88f2b5713a1d128ce7695688ab7d019f1a283f48e4e5f376767f36e62c988a79e6c024613827b8e569b28a29e1b3843e3a3fc5bada234c09e7f95ecd6837e23634db1d0706765f9769eeb31bcb25b5e0b5210ed3fa16436648cc60c1ec3bab2033e29acb1846833b99d05e390aa1ffe20ab88d3688b444e5528be0081a75875153943877de0d0da4d059f273be07c286b35b794b38f61d8f85da1cfd9571f6789aa2261ec3f89e6c3665a5bb1a4567aa21a6f63d2a9f99491b2dc732f7241eb54d368f6fdc62ed8f4b01486b94c39708676b0285bdd7d0b657b5c87b0a3b943cbcd8ad537384635d8d1794848b62e5adc966a384a51a61cef1dea0ed64d4cd83082f5f877fc0353591964df18ba72c6b3930b6579ac87a1d494903b94c48fabe781b4bb04e0ae1deacea5aad1f72665247d8a8461cc54a0e313a6182f22998b119ddabd1626f9a1700ea002c1bfa783c786a523fc22e8ef136938f401f449ac513b5f560dd4276e07d58c959441510a2275b0b1eaaf44cfef971473c38a0a11878cea80270a769649f1c43ca5ab2f65ef8fac3aa95d19f8f1dea490ccb7358811601a565d83f9de923cfe4b9533e4bfd7f18b274871d7dc63b178d172eb7af77e1bd879de3eae6aab7b570eedc70ddec11c862d0701e7d7aed6f09e109911fa3c25825e167438b9fa8363b71576bb309f97c11aa773c5dbf6a934e003f632d0c864fbf194241a5b757c42b78c06019f284b0ddd0b258e14f0067fcfa827d6b1ade59bfbe0fe8d2b6746d61f5f106d7ebd64a3a6b425f6f654b1d492b7900a13a373c947fc8fff30b359f747aaeda1746fb90cb8f72dd9fffa09d5adc8fd6f19f2ca21a9e1dc248fd90a5c90c4f4f98875866179d9f3f0f9188dff3b4d3fe18496e6f8455cbada4fea81ff578c636057771b7e6b0fdf9a534b2d5caac2c6c32103f0fdccfc7181696bc39e5ba3519ab4e3de7a841a5c592c6597cb245ae8439858f32d3d57787096dfbe5a2afcdad7b4977bfcb673cb2c99401c9b60dedb0eae84d12fefbb5203c826b15d9bdd555cb5bb74b7fc669950cfbd57f843fc308a1b464dfcfd4576a0660b2955050daf09a7d24f741ac04b0efd415e81869f4bf8116259573f3f05d35983241e2a4f81637aa810d649f5db9784c11759b2cfd5a0e57152feb6eccbfbfd0ddf189609363e6db9c23590c8186bb9890423d8bfe048e860fe1f3dbae693ab8547880246fd02d8385f48847db350254add9be84c1c31daead99075c4af7bf59e1fb6b7dca174d3fa23716a109f4a58a8e1e909b093407f769501ef44b8e558d58ecd690996a0f4bb4bdf62466119da5291de3960cd1ab8a29d8824056b7768b26fcb86f97a640f822b44fa95011e349d85e8ab2df6ef114b6241c25c14278126f27b34d489c269c46dbf1ba537aa0a7ec16b2eb16bfc21a6900e56308ccace5dc6053c33d2ee41614222e471bfa0cbd1a272654e5c444eaa26136c51667639160285cd0fda119a2400de1af3d175e766c41db877421048f640449dd1417af3da8a16f765026a3dbabac85f8ad3f8cab0c9f101e3d20b60f8a6be6a44b928cf220cbd96303d693dc4ff0e84aea8b372595f54a605127d3dad41081015ab5e39ea0c40e936f46a8590f04e6de8d4375b502487f9e9a4f7e7b23bb0d530eb9dfde87a93369b702f7c20ec875a75b355b2ea5fe21b06bcb478ff117c07a3c07927f67803dc8886166f0b91acc35cf52849fb70a6ba12f64ee37e8e8f996c67a2f4683f83c38eb3847a79a1d4d6f9ee866006718cb01c8b9455d2aca2323458f532dc4468bef6ac667ed5cfba03ec6514885511b9986e6b872cbc00b04ae5813dbffa5fe4c07d0ca19edaa59a017c94a63619047697ef8137de7e904c25f4d121fac77854d8e4ab1aee0f03154f7d63a28328125b798bf55dce7d6adcc5d3f4faca4ac40febcb2120cfbb3dc7341646fa59365f90222220f421091461ce6d2c0eb1e6d3f702da110fc7ebb0b03035e338f140ffd4f2b6485deff61e36e78ab768090cc739ed36997d84b5439d182a5025cbfc050b21f6434ee9fe40075061164cdb03dfd0355967a2d2ebf09300ed452ab6ccbd1454c28e12da1c66477eefce00c92ddae4bae35ef9273898d1ac6f62a445e0c297a89699aa3a1cbb8219b83ea56a8ef1816d4ad20fe19ece089fd36f7c099aec0616d54b2435818815d03f46f7cbbb00c027ad1327ef7c41172c5ef9f8998175f19cdeebe9c8b9a1867873bb1644914fc8aa1ad14ac3ea3432eb8eca8724e5b9976052621029bed5b6c39beb61238f5ea89cbfa4062aa1528a97b3d49017889f52acb9d546ee7e156cb84e7f71df644c35b055f62b5c7a0633468ec7966bb6d93fa2d85ec8c96d4509f5cf00bc1668a5ee8a200799e46f4062cfddfc00e261cbcdd285b9c2fa33357e577a4874a16533eaa231c0d0fa0c2905c7234c13850f55c88c06f54e139dac2f269d5655b3399ee8e148484db399b8d5c08012fe6966684ed7d4a5c4a89e06546b8a3740076376bbbd6390ff435fe2a1617f2c088c3b7089bafaca782828ad29698bd104630e883fbd1d5df26661674a850ec2335e65572a1c30ab007e8f7120a4f87a49d998cae7de4b7b5427521b6437be8a751224dac7f35f72a7065a57f608dcafd97280e89e21e40e234f9bb2c4e28ba101f502ff78a6936e5b1e63b46a1438bbdb6b05a76baa65b44ad750eddf545439a66ed6f855bf1d543ad418642e48a514277332b8ef7f9a65269b323f1338f860e36db085c2e75bc1c0b77799d703199d375cd0332e11f9467e5f054efcc57a343bd750cf1228f48e38be2f8b122b667026c7543736bb57071199137aa0dd07d9502c9fe3d6fc3078ff32cd417d546714223cdfc2fb407985964006fd7c35696a239c05f66925e88553f84b870e3cddd53988e085ce12002e2ae556ee5e984513e4e60f200acf128996ed6ed9e8e7e3ef88e73186fe71139db6831d7f71a86333299f19fb1f27a9f86f36611fc947e9601d1e8113fbd984ed08d0da9482ad49f73f81063fa5bd33eacda49c33ddf3e077076eeebf748951eb43d4c64d5f3b50bca473df246a6ffbde60e317bd90a8d65706df2c6269e2026e416887f44446968fb720c96dfe418f2edce7a6fb4d49e167109a2b7bac87fde4639813fc3e1c6e7d3edede933556c55a1a907c005e39a7447c4d3c0fe72adc825f4dd46f7bca66a399d4ea507e89621e3abbe032abbdf0a1c90b33c0a3d7e808df64f595c5b491ebf78b05e567ce774581f364e2990c5d31bccfd9042336dd6b3cb40273d68056dca499bef796c68396066fd6efbff0034eeb32701d1c2281d08b1029b40b0c59f68b3a76b438cff36de0213bca46ef3d36e2010f70f275b867638e5e7ea870ad09703e7ca5ff0e365d817e0c0eb632b407928efd6732d1c5f062b9b37a68ebe9482ad2a33ad3bcaca8b18c44929234353cd3dd270a052edf28e4a2a31675dc52f2889c2e4a4672398a14fa492eaded7342d755d9c3e0b8cb87755f62206d6930f02f0bd886841dcd1543a106dea4d5a7d7c82052ff92b1292d59b8752720fdd9f842939fa846bd59f93bed7f2fe9dd1678475c78dd6b23ee859b75412e3f9f12bfd365de00d431bbea78e0fced934b5f1b90e9f9770e9d79be9050c9af422cc2b45ed23e59e7645d8727a91b829dcf769875862ff37512c9d0753e77f83933006f013a5e60bc01e86fd0c3d5d02cdde6370fadc85e457e681a104f4a5710a5be81fe97fddd6fd9ee5bfcba1efa97fa8af14c8731bbeb2f03228ef806a165a6fc2b38fc2722cac83f669565f58ecb9c6bd52a82f19e3e3283f4f264b3b2ae3dc1e405ab703052a78afe0cc3e26475e48d81fd411222e52b748a5e932af27ed3a9ed01e0c9d240fe88c3e239b67c6fed2be6f11707f041cf784bd57901b6e15261221e66a79dd080efed77ae0ce4b9246c4a174cf60bf4a1a6cc2a7b014805be622ee06534fe890aa4e26f2e4fa965db5288a0b680882c29c34063aa9eb0bda0fc2d5aec1730d187fa61299575074702d1aa851f91115c3f9c7b87fe1948985482c963b2025c14eb8c0b0703c89092b3aef493119f0044ae1c240ec06a03bbc268e71ba790a520467010e78845503e50ef764b5398a44ec8efe2e405963092bc2e8c4e5273a85c5ff328510ea59163e5cdbf9feffa96b5932f518faae13f3f525ab698617b7feb971dd31719fd610eefeec4386b4b66f17dd6ed1f3b658d9cf2daeadf183af09f989952c3d3d5de5c2d992c95a93f0e23ae1bc4786d82628df664ff5447a8191af0d9465dcc245224d77f82626f6816581d81236aea40d9aa3846a76034fb84ead4aa2d757185d47283b1210667374973907f5cb788fb7d6d736009769f89117912ae406e882207bf8e68af6f5d12d84b915b83580d5876038875c5fe671a5db117373e2ceb0912e41f3c44f34d118d4e8b5d3ed845b76ebc7727fe6d76c7cc4e51670b1efe13af2ee1f452d7b37246a7a1e9265c1d7e37ef94662ad451cad2d85da26a190a95cd1432714d1b0443302a26d7455ee3321fd602cdbb6b5e564ca67fbad032e96b4ee160bac5610e7caa8406afd6ec7bf9255ff7ff4050793b9b4c66f79e64e45225000097e1e29aea4efb9fc8e4f39e54a76c5178d8880d1caea63bfff3b207ae4d0903482498b6066a362d11c8901d8d4e51157f3495a1a580c90f03934c7c3a3ff31adad79d9cb18340763d68f1ea913f0c9b4b90c8a5bb9b4afb8cd61828570ab978e7ba3dd2c2efda293030a83f4406798084d3789f0953b6410ab3ef05309ab34bf3b6a430af8b011c2ed973b33a71fd562ea30594c24abd2468e42bf4d2a4e397ea00036bd5a5bad8156ec32046b409e8fc1a0411612608f449e736013c66af87e82bd214dab84c1ef4c21143dd5e685661edd0188095018de12b596e1b91bf1113780924c9718226dd2c663c99c1d0080eb1dc37b1c0cf472008db1bf4af41cea5a7206fb86c84f3932faa98c62e9b17aad8daedd66bf5b12c612f475235eb265b01a3cff06f791a935d74f2c67824b2eb5ecbf9de7c6d8ca6d7879cb5d3aaf6d50ea9c04289902439b3c12b44a0f984ac5ac16141a3a9aa9bdedff7bf36c1d1efccce8f54e124d80aa5ee377a7c1808260552368705699683f5ba2d99ad26f8f8a06c014be296c5551ea554be18d840d5ab5ccf0428eeecc22e83de53fd5ef2528ece5688d234e7cc5309de91bfe73df344f8f6dd1216b2a30e7823b68b52aec378736e6c2790a8fdeb8ee9f6f3d5357ca11711b97e40a4415117ccece7d7af918cef3912b86e24d342f7887e3f5ff50ec0ad71df5a411e199665d95f7960517798ad04fe7d914fbf995e2199bf473ed8b7880bc4976ca5dee59ec2600cfc8a2a6409036e9fc8b0b2cdb32d80bc43247d5dc4aa06b52c7a52baaa46514369b03e754a166b5e85359784c4410981931a45bf6364d72b8595212ef2dea3723b7a2ffc48fcfc9a01886fe3668602053e6c8b944f18a689789a021ec62d088d2934850a7677eb5a7904e515cd241f527173ac18033cfb7c919e41567667bcd3d629eb8a7e0e9526fea736e892d283778fb9d27265febb18f4f556a7a4b44c6590c2e6f1a4592584b0b8cc10fcb0c2c5c3401ba21eb5024ad688fbd9ee8a9423377abca74f63880738828ad2e2520322a7d55b9baacb616f239e4de5ec30b0cefc439c883a283a69d7d949b77efc2f21923a8c8dcf4ee77e7f17e30716a4f1c3b25b7891153806acba57e6ec5011cd035abc065154c3743a6f8c265ced06de27cb431d0b36c0d21b378287ee4fb248bfc5287bfdfabc120fc10053a262f0054c0d8da373357ebf5ad4ab2cd2985ac8a20ec2c56736cd680fec4fd7bad9a61fe0a666e89e7bdcdf848ed3df9db4f0ce2ef61bb73c21cd08112d104e2bb881583b423adaf575cbd0c85bfbc2d5a1901178883bbc98e2e780f492e1074385fab07f83c0e22d2a5b56885f8be02ec60c3b8999d8fee14564b5e319b30497c6098b5dc9da8ce254ef1f6dbe0fb54e92d8cda8f9a397b8da14009cf0ff8447c0545e8fe517f4b16c89d221d4159462ce4e8bcfae52d22bb4f392f4c63459c8bd299549224eaeb0a700773738f662714c9744561bb40e19b414655a26b10789d5a8ae180516e4c0545390f823546f11f5cd5e97b0ca62db410b52554f96f9a50e296a09655de304eec7334b27c899527f38e99c2adec3df485ae82d8d1f6d9df3ffd25b42677bd733169ab9291e30a06d3a4f1734edbc77fde2ec7203c5e796064608375d3a84c5e59374f780188c83a3d17d06efd5db314ee8faa6b051faa1c4531cd45362c67a9f81d509bd59fefb9d80335d9545e670f1b739e6b122a758476aabc8644a56c28f5d448f983866ea5b0256ffe672bb80d87cadf95fb89edd2b1f95b9295ee989a106f9e1c448daf9462e1c87c68950aab943003115f82caaa70a7614195e620a501e6927ed2771f6558af4d09000f40599fab6272dad2716c4288c5b28bf39c12f663cea0c8f2e0fae475dbfe36bb05a3f01c0f99cda114ca0cbeb8c61f394c542ce516fcd4152d59650cfbba07b47da7217fad6919ba93b178f0fb298fd9bef593762089a9e079f82852f762a5a42ad873da8c62c402c2c51b0bf6f5e1ca03afbd1ea50242900b90628a219716ed8cc8a644bb62da82c4d6b69fa49703aa61d79808417208a1778604a0b00104a051b6f40357cf9a2a2a850877aae39583978bcf93a72ca70e24bdeba60fb851f0dff080397e684c56d3fdf463e33937adc87d5e5638628345985973909a7d8cbb3978938f0d3b764a159a1b337fa059746266ba4472461a97277735f82c03383b2b8e4301b62eaf4dcba116199ec1e3d6858cafc79ab19924e79f2bb9646595bdf012bbcf4f62f52aea177ba1a58a72d7ecaa713e51e3ec8a31396a92aa2e64bcdaaeae138fc0a2d1e6f4efac7df14459d741c4051189bc472503299131c8545c841f96ead3b913374cdddd7241168bb4c1ab2a6404b157ab45470f3bb6e85b76e9566ba80e4c9af4e4625a8276063dc839f10cbbe591aeeb1fd43f6932e4650fbc65843602b38abc783f499780d908479685b67ce13abdbbd027b60ffb6125f18847c5e2e016f82acd325a45d1ac5b9112c343156f7d0f186e54e6917a3beb5bb1c9bc9fa715138a9f45618559f716b12aedd666a2bf6f2a1f6690d3c2d306250e4b145c5762b105114a59adb575a9591654654081390850602c94501bf453406e2585361840b6a1ebfdc1a61583e6a8661a7ffe35c537dce9270853c8d0824d47e7d6d668aab17131ce7359de2feec532a66361fe69ce3376737fa59c5ab4de9ecd01c026728ef192dd254f8336ffb39617a8c71dc19837c4cf843354a21d0acb51a86d44dc35dfd33ef57e02d435da8d280dca4127e5f0961c24734c252362e3778a58ba16edfa64e2eb821edc72e0e3355bf2c4a71eedc0e02864a916e4cebb21902f35cca3f523ce338a0d9f24863cff33911424457b847cdcb94cad57c6021b1cd102c7ed2807b810b29fe4b8a70478c70a6e2a4eadc4c752d34a66f536195f4742844e0cccf69f982c95af8b94f49f0dc9b99fe057c5824691eff484ff00fd814d0ba03587f00918998ad34fc797518e41cec678be185960ad33d1e6bfa7e9e60993be0cf6c0addb65e2f624ed95bf83c29268e600de5fce3798023a554d690e6447796e6ed87245493ba34415b22dfa7950229c9e9891e890b8b786efe34d902dea670c87d74c8f8a138f9efeb61609dee6457828161b3d75e239a59bfac2f4ff11f3b16a839d3d445e6d34a7152c845d3c4a6bebab4eaa818820d4a6e4fef036cf32d8002ca422215f512445c7c9aed0a5194602ea27af64b246a93d1341f513a24ef1594092833a5a577f45b01d1260a7fdf0fde04d5ff5f609ff2f2507f27aced6c95a57bbd5a83b76283e35fb754f46c39e5cad6aeb24ef3ef428e708ec31a7fa312f50df1945d650387c847af849bca0c1124e5dc485f4d73d9d1ee5ced3b6401ba20bf210d3d81d06a05c9b2e3b3d0e69eed1ce440bbd20e89f84546e9108d370d566dbad0b5eb79f6460955e6f7e0319fb278c645a02320d7572dfa3e2c920900b42b8739b6cf69f2b5cd8e4d30ce7d258e486a66f40a1107d4bab979e05ef35c8e60804fb391c81b33990719b1eaea836b77377b161ab2fdd628b8a347434641b05f91c01cc955627faf249c6cc03eff0cba5b07103c2adcda98aa82f98c26a6388331ca1190e9e86bafc081a65c700429554e0b89106ff558098bcaf64a0a1949f18c89e1a41ebef13252a3e4fd2830edd74d07eae43b4b119f7fc98846a86ff3752f5b350dd38f2bb521eb110895b682c9a76d47ad06ef8067633deb9845c62a94ef880ac21bf8e9c297e2593a4b6c2e95d29be5ab30fe0e3c93c1b4ab9ae46b88d91e9151ff0158f18dde69b9878b02a8828bc60767c15eac61d60a64064183a076ffb8f4d9849be9d2ea9d5f56c9130ad393fa3ee9e519cd94433274585f6682d9c9b2f4cfaadb4312d6e945be5d1633f662add46034ed98dfbf8d0e9d7060a540602ce4e286d0901a84832e75c70fdf1a767d398c105a01995a2e1d33914661558717b48ace1a31b418290a37a2a90d244cddc48cce17ac1f3bc75f356ef030477ac58a0cfacf42e4229a9f304a2dfdf38cc6c9610d379742876cdf3f5d4b58d7dec834d55cbbbd3526063d9ef83c82c3e0b2f21e36ff42e201b2593d9f026f91efbf1e0db6af534a760e6a59c26d7e4dbddecca550803995d69e499e61c414504ad047cf348c9305f0d23cc62ec5508c739b81484a2ed48d702645850fc72b375a00d22cf304fc000ffd6062b06c2be40b5fcdbdd7e12240c19fdad3ace8c51b5e78fca801a5bec20eb289227a367c7e8889705a8a1cdad0d6f22d5fbd9d1e64bcec98fe01a9862df21e65d4ac5181f163eaece4e740a5fba67f3c78d07c0d24d63a83b001cc444a249124e3319ed83816f8a6932d0407da4461ffeca44056578da134730667b871679e0e489f285858fa1fd2e2e98ff63a60893d60c473516af2960559acc054f7fceb6dbdc7ded77f43586bbe40077d18d4b1e9dd1185a8561f44896900ab82fd42eb031e0e3d96948831054d5d3030b1d132881d724c80c0d219d9a3ebb4874abea3c4a4830e2bfc0bda5f8f56db929001f0e1a58fa823e916a8e52e8573601640340f9e85a520f93af3fabef794362f2a9fd0191af1e6e698b59bb9267912ad64f3a7d9c24db98ced383c69b8d4dc6b80add072f337128fd38fdf80d9d130354cca53c8cc2dd5676373b151de585d0e606e5e091ecd643b50f59bffa220a547152db2c3b01191489c057a2f2daca7d97ebbd7b4455f6b37d0eb4b48a389a8d366b2f3afa7d003289527a54b094243173c3b374c012915f9fd14bc29850d168748f44856c8821170d3c7c858d96f26c2d8b287dbcda40fe6b0c55c029b29a9467818801f96b4d93d6563ed4bdc768acdf8ce3a7137defb3e7978a0fd5cec843f5892b7651d4e38823efa14291a8e2e7d74e9a9ff034aa65271624826c53b9bbe0b7884882178444142f998436c4c4b4e8108d8ed267942362f2f46d5f6ec82f96e5ff4ef24af8f9082be333112c3dcb1b985b427d1fe12d81cf8580ecf0cee543fee17a836ee92c3930897251c29a2b42805660072d3e082c1a71d7498551ee37da1361665681be2e1f5fa0b9191d0183d9fe9c1082ff337ca63c3fdf3014e321e8b922cd5a15e14c99b5ed6e02df12bd410332e47ae99c6bc88edc883b464aa85d8cdf6019dbaccbb39a546ee0e39605545114d317c47e28bbe46f20841a9a50cd92414c95e4fc5f7a87747283b588f7ba36dc9e61f89ceea836e1992bf03370e2839f134f5c95063389194757a4bb64b66447031d9315ae45dc84a81ca54113fe5ac84bb7f9541f14f147bf60616d9013b884eb2c30cc87b77a5142be2703257038be270c5a889cb5ab3b047aa374cca4151774d56ab069ad6cae21f66843b5157bd950f277425073dd322768986c7c7075136d726e790d0659dec5025f1e16b941162e3810b1a1b925e9ec8b55bed84a1212e2ecbc1bda5a7a708d92b6c903b11a3035951dc091607731049c8afd590b9cdfd91ab8bfebc18d59c1bae3e692144ce67a6b9e8c6b1f25999fe301e92f70c55d9ccded3b98cb91ec6b2071ac29cb36caefdd2cb45638409ef3064f22894dff2dbb2965055b118e922c8a57b1c73e838f2f7591578879d84ed7dcca17b123f60783d9911490d83aa6dcc87f8e59ae48fa4ff4a7496bb164c5bb64aee8a21990f8bb1e2f3c8e16e6f0493c0ac8eb3a381f3653077c3fc36bd299ce882f9efb0dab7bab2b9a0fea9880d70d1422edb63035e10f053e516025a6e87f74e85ed6436448537ef2975806b0cf7c17e1c0fc2ec39703b4981c25317fe820bf8430fd62e8d516246af87ca2efbc4c5ba830a352388a8d6aae8c76742f58756b3088374297e7bcf93eb2c628f3d72390a8c3aa05799db6f8c5d3692900c64192cd594986b1b1feb2d5ff2c96988f519a473d75c01c0494f42af68ff74dfecc03005c0966c8d2a591d8998af20ccabad6bb9b8d75c3402d90365ede0cab6cc7e70ea6c18c8258e59bde2aeafd397f71a80098ac5b0aa58dc69f81e32cc5b064870b23b20e3d85b809987e86c856ed493e73d78260c619f7e98442feea5eb3a11cff1981bbdf0f19d969c5a0d138a54d6322d889be3e7d1598ed34c1e39477b911974a770cf79522af37683a0254a138de073318342da6c127b5bd1c4a50cec4e34370ad5c1d0a41d18e5cbe5545125b1048914c85d4ed9a61e44f9d66a5abd063e8919025c456f10a1143ccfb9351f2cc64c30bf23ff1d85659656989d87f4743beff4b1a04a82de572d3db3158389bd368d09f2515a846d4f640d8e8f4e1bd02678115f0832ccb118b9d427bb2488adf14a06c608587ed2e55bb1ddaaff3177ff9a82afa5a06ddbb7579aab8372aee361a5efcc6a2326e2b2335ae03c7e5040a3b78b83606cebe86430fa225c037bb109d60a64c9ca3507d85fe90cb82b0dac7e92ccf3f4bb473bf256bb827d02d4fdf616568fb1f503af2a7f8aa42720ce8e1f39760417ade5562af731e8f5e3602173e3198fdec0e5ff50e21a39cf13b9cbc9ab35cbc33f9370846172303c1783aadb5925d8b224699769273339ffc52831a3929700c1fd2f39c4a7873c24810570e327a087fd0c3961cabc5148ded4c9f98404f0fd2de483f0f16f6ddc4af84ff9283eeb03c57f5078dd24a7ce311a09598e58932a3d63bb960a95013d9ae1b2dfe42d8cd67d83e67100b4d2f388a231e77996e640698a6a5be653a4776e09d085c255073b9bca68d0319848983fe935ddc2602df310c731ff98461271ef0561b5e4bf85623a6f1241691d4ab3e85886c668a7a3184c65e096c1dd2262220eb5bdf19f3a51756669e57ce60b33feecaf60333f94998f9de4db107aba9e6b2576b7f86eb361797a7d2c00ca6e1a6b167d19ea0a4b97351176a0053a2020d19f6bfc12930f3fb567ce337a7acfe10e1850b8231de0c230a518eb906e0af4abd6d2483a271f1eaacff2178cb2abfbf78b489ac5e3b500d1806047e62b8860e65be2ef77b1b421a8c439f4054f3a8d07f5b83586526eafb0b25a1fde767ec9cb12960cf13b4162c1164e81450ef402d9993e3c4f15bbe223ff7e5bb14afa3857cd50adf26d0e8773de8735e3f544ae85be1af42a878d0925447fa728b54d4712e8ee909c1b752585a89d1d4183afa7d7fe78abf6cfba83e6071777d93f24460ab98a4c8a302181c1ea4d9b901ec518067762f3f256b37a77f6fda03cbbe3aa95967b570b077f21b9558fac15d6dfd6f856cfb5a7166bdfdee215cffaf93e855c53c23ecd91aed917c74335e51a1115e19f9282203ab197ff98c09bc8fb93f19cd68c0af85c3347ad15b3ab88871af459444913642c29ff4d189284a86b4ea7b02ebc6302bdc2171c5a92931760bfd56e66f2dd236ded3dac8cd8dc23246aa2ec932f8c9407a10b95e56dc1db41d266e9d6b93c801169b03b245f4b5004417a55776ac4f1f897fb80d9ae58694ffbede7e13413f9929647eca881a51640329fb4ddd9339e1b44ca691b41833b2be78af77b282b1b2a91dd86a50f2bc3d33478d2f9520e91eac0c927b329cbd7db34f4148e829f6d2c022d84073d5502d5b6d925700bf9c96da2cbc43da2b8edefba988e0af74d65898835e4654bd50f2a60dccbb06bd670ef7e7e80c80873e0dfc707d66ced66c03fc9eff9230f3eba9f03f1aad20e6864591405fd586c335a41bd5ab21dd02f93b70588f385ff7fee070bf198678a0a8675dae06f09b3ac35270f237e3b100a359028c45523244bcc5000ecf2f4295572b1c4fb641e8b5ed87b6cce04ed0e22d2676ea02480df529db8d372fe9ee7560cb615e6182e68f2c3be41fd0b299a28ff8d4201e3450f72257164d4524ff5a6a79da813ccc5526e0f8875196387454e5f47be42d98c97438557a516c31c19e3226cab75ecccd1bca01c85a830d54787db010669c8459b0475ff9b85a0fd221806494468e3ae38cb4aa770b0710a16fa9579c797b077706ef170a44df1c945c21c0a95c4c69a899c17ba1270c29b9611fd786ff49cc197ef321cdc98b2d360c731af203f16fb74885901fd435e69d50838b8bc3f33c9d5b61c13414f8409c435e04a5f25adaf9a83696863602b3b29652fd6b165f87f15bcf9907f27e6efaff7eba14d5ad4601df9a44a34274180868f494946383756d482f9053ae1ff46f2c80ce2650311664a95a4156fe570097b9095243895192ed37034a5cc26a8fa5191d4c831c365068b05b9d2236c1efa777f0c9ec2efa887d6d13f05f8748db385de3029d5683a491373ed0d23c67aba43760c491ed21504b518267b4eccfb32d0566921da76d6405a5597279882d33cd62f898901dc6710d686b9a5549f668c139e07a89a670c2288f7287cf86018f8e36643a1ec77303ecfb912a31f2a4cf4b0f1d8ecc494a427e0c5f41a178474d78c770001b036e9559c2ac7fa8756f1d1e4b8224f9cc50e5390d876d148e9e347f50d394ab39312be3f7de9a55accd1025a52554729216de47484dd807c445c8aa791c4636d614077e4702242d36f1ef66aec06040c84072410b4d10df8d439019b0f693f3c8c883561f5ed1c416c0ed20c79379b945245233aeff75d70410f3b7a274a4191687d61b1da840a37ffe4e29e39f70e0296a78dcead3e0c2a72f2e105abf8057256ae408076b264b430531a8548961648d50a48a7951ab38b91adb640c4e408dd7ee8facf374fe97351ffc96e82fe208fdcce23aa6cbae6c5031d4760118a3aabe62d448feeaa78af3c0d2125c3e36d26f5db90c647abd63d93a34b656535598091bf9f6ca8248bcb23f29f7edea3432b0c47c26e530a349abfc031399f4ec34ea36e9e4d1f7b6bfee31e18683958e2051203f4d2a8afcdac9f25b789a2d9acbb96719ecd92e62b608d3ec039058f35f50a1fe521a75d348a64d66076a7a6b646adbf80b611fda21d749dbb72920c9b3fd2562e0f870e2fe256e541db338e59fd26c3769a024247d14930ce293e219de49b33ccda3744e8cdc813f35a5a0a576637694f0cd3f258e76ec93cf6047bb56d4a888a0c3bb335c3426dd7f7faaa25c1b7697f7d620a9006f431afd0e063d3872580c1eeffea6615a2ba3b9496ee5941dfd8ea1d957dd56d5915d537c9a7594bfbcea0452be392cd22fccf3302c488c91ecadca38a4739b88a8f212a82be0c0a04e67e4b078ee7179c7688c677746030bff33d346f043905552e2e6b5a9e00061187ec3793e7f9674a838fd88e1af9bcff3bacbbd7585568b59190809b2683ca92202f940003f3149c72200a8214780ea06fca39c9c5c55755fd253e5a78a62006bcf55dcc01adaa1128973f3d802fb0869b1b0e736a513ec3a29404b76575c01a9d564526efdef3a2b0893127a5ee4c8e65535cb8c3a04f57c68ac2e8b6eb36f386c62a9ec142971d2f930588fad8c1bf41a57caa8ed73183b4482e3ff99818007360c9cd0984b0a8e9ef4c6836dea6f9836a6e941b8e19092e2dc5ae3ead741063781a6f2e444fe31cc90db6963a61746d2fef4665a9ee0d3c65d851275b9a07ca423b2b4486c3c47fa8c45d6eb3528303a7fb1616a3190e94061ed15dc60936ff28b3d0840989b7b534545131f40b72d0fb02d564510ee3560326b3380bd9e602e8bec935b7d4d9ea7fb546b1a9a24cf4747e4cbb014bdf5cee5387f9661bfaf5d96b0d7a1452dc6066eab193683fba93bdd8ef6d09301625fe066a0e8888e448f12f8a1dedec2d77a3dfde1395a7a476b6e19beb85ba20c8162fbfe50cd6fb11ca2eee595d8bee88c513c786bb0378e0691617b96fb51479543ce386346b13bda75cf247ad8672315739aff98e876ef617580982badd4651af3cc54836989991b02bf41d2aad30520b004","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
