<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d049826b732c535cdb12ae72bbbcfaa69c10dee88c91b0303a4b1b8c0f4a545c1969d0ef00d8b7d3b804d20b0fbe8f1339c11ec410aa3cd8b596d5ec1d7176b3debbca14d8bd8e7bb015ed12a99e4da7ccb32bd7d815545a2143e99a1e610d9a08b2c75424b235f087350f94027a66f0eb6d3dbde3750a307b1277ed74cc6b78d87b1c0537842cb6fefd900b3ff4be85f3bf15521c14f4b1efa25f99c86d1d1afb4b5d2a9dad144debbe7c92708b3929237a952d5000a67387960e99d56404d6c391a909ae593e4b99944e488e747f05f2e2a7c3661dcee20b96bbf23e854b0c7249a962e689f8ab28af3b6b42bf01a71407b113c9690ef43c85544e487c64388a2b3f346c664d0fbca93c7aeee1326b28eed44f6ba2d7d501696a46cdec310a0f228f047a5f055fb54af90e15b34799d36a82fb034c74753dfec44cdc1cec18b8a9e2bc161c00b931df5b5e2bcca18a7f2c8e17cbb4670c3372e76ac5d5a7e79e9c42210d75a9abbd8d3250df38dca336d60cb1d0c198cf6dfa59db62f17f62cece73ac0fc3cb51f82c406c07b4dfd27ab6c774cd3338d4ea0d86d81cf59dc3f9dd59cc51bc91afd0ed424ea5777bbfa8756b3da5df1cb4b3baa138f3d595f9fbdd8f34814da59edbd928810d1a985b139d82f52adccfe776f9009ce027f56297b5e7aff1411719d9a828833d0c273802664370331826f088fddaf515f91d97fa2e64a8ec75524d998f7015f824a7c46a6e872d322d6fffa2fb3902f9cbea0f9d4e7d1496c3878ad0a0e2378bfa2e662171e19f9fe9aa4fc6fbdd68078797ab404c11ec0bb0c9e1fd59a90e49ebd0acf71390ae494be77890ed0e7e5f96caa7d885c9437b68dbac9da259802dae7b811fdcd53f168f6ef3e086c7365b821a86e0f5fe8d0236aa3e9c5dbf9917f8d53f71af08718e2f704110bca52c547d05efd097cc340c7e70e5e39a22966cc4302460d2eac27dcf01ee0e97fbf30030fa7d3bd5fc68036d2413fe7cfaa3ba38981c857dd3793af877786daba4254cabcfe5dd47d63a067c41ad7f975e1b652504265d2b230ae39b0bb6899777033bb5490b638ff51864a12809023827aebec45517b569a7e3e7f78341442ef54dcaa35b5721d388d709acfdb3ee41580daa60041b06464b1703f7ee9de46f509d37313126d0d1a32aa35f3d6b277aff58dbb7b39f308ca7b185bffc9d8a4dd63ad7e2e10aa772ed89da3b87791d47fbc3ed26b274f0ae03e32e885b0bf7127de59eea5dc7fcf8dad475380f6376eaf474cf32883e08035e17b07e49aadaa594f2e621c8cb54d097e9de540b340113e50dba8c8984505f8aa72634c1859b9982a072cfe8a3f0823639aa4c023069d340756315b75599bb457c96e7627ac5ce0b16ad855688cda19a32a849cf5d9569e909255a3db3dfb813aadd5ab415b960aa51996d4133ff2351d769f04ef666a908c41c93b453428b9d280388de56a1447d52df71cf86cdd8aafa10af13765871721e18cdec6588945734e5c99f35b70ffa75dd66b5fc7e039ca5a3ae0f1b9d958fe90165a86ddbe55dee07ed887181baff1c5bc5c611979e957d7fecc5ce9cf47d928d2a4348b6bc0444d184bd51edc62dafb20860c3e4b5d9f890c99fd21fcbcff448b6597ebb795c6456799ea69393898837b19d96ed5fa1632049e75614f16c6151e20a5c66cdca31dfe0d93773c2a1fae8d47d08eb268d0e6a9032aa349f9990bd048e63389fcbc6272610a25986d97acbb9e567ba8b3ee3ebdc316e61c9f5e9f9842fe023c6ed74f1aa40ee1585f848fde512008577312536d65e349118413678c02d285fcb1e8e9d11900011d54835064fb523e1b2b7296134941f1b11b79c330881de356e18bcf9f97add2266a7d7d03aa64a311d3d37c0f716ae00f4ecbf335d616a67963871ec566c02b62ce85f312462c4527d71b2088c1cd02be05e3fafe65f5195b116a8a2962e461bc5fba050bfbec4b323ed022468d093097f329ab62b129b6512418ba40df5f681adb4a3a4e17e84b65b7d3379f913fb3d606f4818d55b7ff80adbdf9208ec6bee61af5247dba88b20102ef9eadac60f184da38e9c9d761df48e4c258e351b0007d36a7ea1fb2f65c42b894db5ff9a30692c411aaa29aa653010ef1872162f9e23a2e3984fe64aae48c6c4ffd5b21d8426fe8dffc8837d2d6c2467e72d1ac58ebbb1a3f33fd3202a12740092f8e8ed172f551982594958aff9032d786ecffe7ee62b79e724015154e1e8e0c0772bf223349fc144283a7c0a7583e6eeb1b61a5fb8db864c9a23c93436233359e5d15ed66cfc32e09858908f8a630046b83e58eaeac42270b29aef48cefe56c5547bcbe935ff476869f428a650f6d6d981ab948f3d598c844d2d94f5214ed8076067e83effe610705e0864186347cad970a76cc7b9d06e2f9386ae023f7ab29ec43d3726917621af3fef253e1fca4a2e79c8ac3f7ac3b109d770424f91914713476c85f986b25e83dc27f183a7b7d00d9e3562f4ccc8ec881a0c02fd2855e9a8d2ca128b5dfb38d0ef1734282075b7cfb06cb09706000746d4a489dc8e8cc4563724fcdfd3f4856a9be8eb40b1109394120c85611e6bbc9e541959122e2cb49171363110414b53b84dea701138ef261b16614a53c17cc6cae5b2f9cc2267049d61e97eec114fdff1c01db082dfc4ac049c94b2ec4df50b020a18133cd11e2c12960be44eb484a8c16ef157488c1077f932c50d692931dd6e86289a0e79489020f3c295bbee8d5b72d02b40df27913e2524507db6c91dcaa3fbba91f27e69bd455bea81b21ccabdad648cdff66e17d0b1bd1ce3027d1d1798caca9e26fcc663121d5fe0d4e0eab0915bd805a4e4da98472f4d25dac0d8ed67e1d4f797a80d4a40a1b4c19491123418db0c8bdde0fd59275fb0964dfe7ef1f2eefa9af8cf8b8e1d467f1c7184a2d3066d05bbab03495e4f5b55bf304335d080dd85a73f0c590ee2c52278e0ea6289fbab8525887c012ad0d1dc4941612479ef30afd3f0219cc1cf31089c3bec1046fe9ad40068ceffc51a38c837b31c61f1a0dca5dfde2ac48b4e826c89902659536cc5af8f7b6791700a886121339634a3aec23292154c527b4420d8e2f8900e6748cfc040ed4485279955d72d6a25f73a6ae86e2d0a66b8d9bda6fe4db321c5accd30e1dcaeedc93fa539644d35cca63b0c7670457c6e20fae6885271349341ed69e38a6851ecdbfc0c082cb7f5c846be3c7c1efe8c2e93cd26e06a5249d6e4d1632baf3ff077ad65430e9c60c160b6319bcd6c82f6036e38ddd1766f03d4c51301585d3609328d8956454ad9c727a8fd56572437f9f4d2a87f204e6f529ec1bd92678c12907287d944c856e95c4d998cde1f19a0f12c5c738477a75e5344830ae6ccd5e7d6e2fa519710480fb63250a6a025f548575d038659910c2c70f2b425e8516da8bc842fa8851ab6709a3621162f5140d252370382dd3b9555cb57e83f7d33bdd4d864671f500497e4306dad920dddb64af962760c26e2f38c7652b2e6488c8fe7e6080487eb6e0021bddda13cf9e6208950f6fe322a6ba810d4fe5868b09e76a3497952894073756001843d7a4fa35da209c37a71e45e77ca882e4be18612785ef652730f2a5199d8127dd2c65cb574a3c11df742075edce8e7191cca86ead365f40aee748f1e67031ea7447140ac6b195c45622e6e3aed0d38a8da0f26de56685d3e7169f02ca5ee15912117971c5428fde8db25fa6ddac94a1000a5a1841882e7e9c4b009401a473c79d11aa5e86dd753d51828adfe6cf0cd5fb053cb9ca5a668c84748af66de667ecbd18a36967d7f92a88310648a0dde4311b56de10f3affd3466706839003c9f5e057cb7873e1a6dd596a51518896bf22c7fc6f2ad53160bb40750e5a34e0f50ffba46d60528c088e291ab5de12ff4bedb41435a3663d097fe951c51d9d3a89c68ef32514f480ed04d64e80b30d0f19920db4bb5f4da845f193dba74d9da773ce134d908a74c9412fc95f7749d94495427622b515162e61c3e73d0c1b5113792921732f11ca11dd7e58e8af4096643124b00d12898d61cc5ea774f3eae111d613aefae87d93f9282efd72e40dae1a613dccdab604c11d6d3511bbfa783945c354f4b071ef5daf3c2f0407468f38c341dfc78e5f3a373ecfc8a2e99fca21c50ba5639c0f5d16331bc05d2c4223cbecaca4c313dc7cd0c4f6ae9f924690c1e056e6f0880252846c47764b45e7b06e34d1f2f2cff68fbd4d4b031b447980b6cc1077d81cf6a85acbf616a48cf660dea5e050c41c65555dabede3530688b9b5ef1015637d7da30c17b44518c72a5e6f5673545576185cbc03db0394f2cf9547797621749fc9e63a9517bcd84649e3e5a2beb58331f6fbae8d39ebac532d37f85fb671eb0b8aca906f8bafeea55b955c2ef0ca3362d49ef26915b5bf79b39b2749c0bf1b0ac03662f054995d77cf22269049b4b36a2bb73d269416690cdf43d9939c96cce4e62a6b9bc014fae34faba29df6123d8301e3417fa99fdec33b29a114f5a74790e4c11487d573392d93203369280c71874e0e477906d4d9970dfb5672900e0d2a77fc039413920cb02c511356ebf909cc1ca1727dc40abd8758a6a09832091666811414a6d36ba04bb550dbde37967e456600891f7081debc950d8df003fbf4bbe01690fc0f92fa85ab0cea74248cdd7d0ed2f95dd7254d7d18831278de58a863fbdc93f202d84dbb73e9a91bebe31423a072ef9a5a8ac5e5c589b87cf19d6197250e0acd90b00f4716d040ce2c1da7073824bad67170ff98c49b6a3a18acdbc1ec4b2d695bd07b1910412c8540bc78f545e5f496a2578c401a80089669c97c10a634b050890b6e96482371aa2c76786d80a15e2d2358d258304ea7219d9d0c2383916b8e3cb15f820d8cbb8eff2032b70ef45836edca83cecb8aa1e38617dd17bc3782297729cdb89e9efcb2f53e451b6cf23f0d814f7ca0c4fd1844fa342d1f38462893dd5350c3c5599f07f80eb1c615f02540bcc1af971e30392ba1281ff88e7b33f7b8ce3b948535a8dd48e10477194d97a18b2b1b5cdc8eb561973e9c07ad4d273fda49495092fadfec588fcc0b7ad72ef8ac7131ba99aa81545eea6ae679aa311de708d2c6c051605a931d04fa812f0b798326be867beb7db3a1065600154a3f9b3b2f7bbf8f40c604d95297d51e3e550ed2d304cc0e8ffdb8fb20b1a93aaea6fe77c0870bbcb7049673d7ad4774e6eb7af667c3b028e1881980746836f562326d0978383d6cacef3655d48f761ddba62b1cfab3d3344527d3331152b366aa883899d225c9ab29409b7673b944942408e00c84f83a6e1d5b628fe3086dc99bc1144afeae429068133d29c8278e061b3707f87fe25457ef8774490f61e3d135ad9d8c2ae179e6247728a353dcd423306aa37552b328589495bb7c8528b7a63579fa18153f04fd3cdb59d386dabde8621dab468112efe0ddb8fb81e7f8cf213406cca0cc1e033e0116474ef285818471f6aba34125badf8e41326707056c90e15dd11ee7b1884dfad2e88228694d19ea89290fddde5cc57df04a5a14941ecf06a6f5a7ab47115f7dcb778e3ae2bcbd8072db4a5af80ef3ebe14a659d0b1a12f4ec80ff7a98c3af9888b56413a3fd527e52905e249a668b388b6ad723daf3292d5bfff559ba87a36fc5f435dc8231c182676eaa18a25c1206fded91d72387d03a23956c1d890658a8edd5cd37a30a2be31eed992424efa990324a02da360dbd78cf416eda2620520294d7f2964da52f9cef50b34513dd45a76a97bf9f5404fa8968dffac82d64f9695735749c9f16dd069103fb6bc9b229ac9e133bab35c29f83898b985b5a96447eb67d79219876492c7ec46448058a0ac1fe1dd8d5a220b43257fff8d49b9b652145076abee692ed1284be60298a1a62dba33771166996dfaa5fa930a52c4b23e6446447de9c60abbd929f2d986a64a1963294ef8a1ea5304b6d482c841cda3093442f3ea0633ccbec4d880332fa84272bccd6184457f272b4875f1daab05b610f30b2d6e6ffce7958e25acb97898fc4e50508a7f1b988005f96280eab6e8623209501b0925311f7d9ff58ce86dadfc4eb1f26c3b680aa7072ce42a9c5b48e5a781fc89c26d3d41e7c0bd0430021d8d8dd65a4687854ad84a2530d5bf48dc36bd7542ccbe718069cd9bbb3c2bfe200df2f5a6f81d01e063519dbb7eb3bfc2fb64771fa198496c97624fe8afc8845337a5f338576b980ef34b3bc5ac4b7abcc45b9155d7ba5f7f1851380fcbb60142886905bf0c3707c1abe9b5650008c22ae63be50a5c377b886fcec43a1d72ca2aaa601c108e8b9fe8565edfba1d12c9ecee6ca6858db044b0b3af32bda752b6b930c49061e6f318f262079fad0e8b060e5c646a1ce077d8a9d6d49574dee7bc253a635b3506a04bf6693b92a19d2a55abf8cfcd3f8e6cb4f3452222693bdb2c63fe3f5db0ac56f84cc687b7b226a03a54101c92d9e29ee11ab24bf61f6ce55d33c9fb115518feb6cc25b914eba133e62b168f0ef616c4b54264caa6e583c609324fc36b02c7aa875d83e7e8b26477712afd426e3b45585a17db54484201edf0d9a203242bdbda74e0b7ca1459861a0e06a40af225c51f4341510a5149511a49d5ba08e011879603758b426715a3e7fe66226b1f41b6cc0464d8211d1c030c92d0c1284b1b2acc1cad4e221ac6f544a70a6943cab816bfe4987e3b8dd00760b887d96d437b0950241990c33e9271b029aa536652098cf7f66c07f5845076730d598dd349a3ce858f6b648aeced449b68cf755619bad7f2da69f04af2ff492b66ff0cbd0d7e03c04c66e845f75f9bdd8d8e2e8637634e307883ac8430f6704b5fd3d111e768be94fa4abba29f34fc1135f6eef3be28377b3f81d059dbb66ad114c1b1d2703125de7ea465553cdc923e6da4ca03154b39396acbee239b4c8a46ce9919aa099d5efe078cdf81c5d9927da2a43a1e5b1f7adb875c5525e33d5bc1b572ba7d8397041670bcafdc3daef23cf453844530975541fa0ac5894731aec1cfe52fd41e825a6c483fece26c6860c78c44703fa5672b6054f2f0050d74bd8f51922cc4325f63e3f29b2e2ec92a1b5d88b0630fb52d7d50a8c37d9294cb9a7fbf9482d94f39271b0763fd71172a2ee855834c305574c448cdcaebc432ba4ab266002fc40d1420b36acc0296478b25db6a83b819fa90d7c9a690220f32c03ceb2170a0f5cc461f545cf217971ffd1e3475627def436a37d44e1f049ddf1a0a3e6ebb2cc7ae8c2293769fafd29a2f5e38032ed54dcdf739ef8d1d15a7376a0978106bdb54a52952eb43b6049682eace7154eb7a507002b9f50416cdd128c0f4931a34dc4893f950bf2120a721724c674b2ebc39087e705d914f1f8463c76deee4cc6253815753eb018ce2e1e06274c40647d14686ceb8734227560b4ea05a3be56992f41da65b369bb66d6934f5f3f75113056c244641076b747bde685100e8614e0a88a09ee6cef1fcc461dd02fa7fddfcc6c072be1dd1d57817c03338199606bdbb9bd3eef7927e515c328a84c3b9116537eef25ff04eae5c09a9b4a89c7ba884bdb2e8a3ec506cff4b16f064b18b4d00a533a5e7ca12a570c3293e8faf676fb829d7b7367ddddec107760b0f58850ee3fc1753dfd5750b44597a9ecd868352e092cecbe867d0d4c376824c5070700681c5f3c0eead4892a1bb4059287e055792a8e8a7ac24e2baa9778a76aace50fc970253680d27c234ba819bd4a10ef621d6bf85af5047d11b7fc6112a12fb5bc0042c6cc8c0720dced57833dc704f42a6b3deb44ea1d90c980fbcf32ecf8f3f1489dd1b7cd7848b2e31f14319df67df4ccdbac1cb6e953bb759021f3488ab4739db89e6e692bb886de4e8c3cc0cfa798138e47a4f463f9db32fb14da1eb418a8f9e9dab302c3ae8ca550416c784f13687003ea2d7bf1e76b57d80198f880b96496e08cacb13450989730e9dde575d8e4bcb6433bcaa46f5c63cef12601c7ce6d99ff6f04453cc07fce82e54640783dcc65e7d85222349bfcf2c14f7541ebe825c38a5a847d86129c35c539bcf40e338620f3ed62595c916d04f06f9a59e562cc0426c83d4a9085985e7da9feaff4ead4a798a23c43b6408ef5ecad4ea99072b4f892b376ce18c84153e0f3bc7ebf78b4d67ca7ea3468c9e1ffac9048ceefd55e70cf3ae7a6dd9b488b769150b6b18d7ca8fb6782c58492662fd1567f76d238e33c2e176b4609da229dcfc9b2281b45362612c551ae32e48055cc0899660271edbd8de7e26fcb1ef75402a04d8aa6241705e08704230bdfbc8104819cef35ca1ce3bfae4432f10f4bdc6fd603a5986eb12046a52fe170730d02aef347093bb7dc35c71375a7e6f9c8e5a319a15d6e9e376fcd53d0e21f96923e608a76f9b4f35a4ae83dc5deda1129bf5873d555d025389d739a346bc14c6c983555dd3c4fc0f261d1e9c9363918161f7c284b28052dda477a49fc54cee95a9cc093cbdce6d4cdcb067094002096d552aff762a48d2b4f58a0949e2cbb6b4646605f0fee7c64579d95c9c59fc6fce6699906ef08a7b19f606a39822305a657293b0ca7efb98bb9e0f853433d0105ffb2f2c42f702761691b07f0b1a843c5123aa2f62e80277a457b408258b7c364cdd690cb146a80cbe66092b3188fba08b004498fd82039a38db7c98b7faddfacf99392987a77311b49b85efbde1728d14c5efd68377d84dd29db8e8aa7ad8d169c5fbdceb9d30eb56cd2bd3b47b41b07a1f6dd3ae25fc27d485015cebe51ef64e1db83d6a95bbcecdd9a5c39f3bf4b7afa15e214d71c21206a3fbd5a9ee2354124229d9d5ab6ec97d3bfa294cda121ce30b202fe89adb92527b4f4bcdb4bb2fbecd2c86ee119b3ca04b282a99c04a89da018b48efe60671f9c4ce088248d6e758fbc9ec86debb3edbf2cc6ce4bd7ec17127525ac6f6fe807318a190a2401288a5ebcf9421043b66036a1369dba7ed8cdde7471fc31e676eb618e6bf0f3fe304cacd3d522deb7b3d30bc19e9e103599c70473cf43f64b7fcd62a86e996af6541ed228b41c785807e196ab56aceadbcd39277c4dfe23637d9e509813f4bc2e7388051cd7a3a465237121b60d0249f74e25d1e843275d7fd6388e8bc173a336d9a722f9125cf14ca7003dc4572f02a9a045bd8bc4fb730d774fdbc8a35be34fd3ade1f6f0d9bf65952e1652005a5166d73d73d75ee90f1a157aff23391e1a9e0bf6b60e71922cf464b899fc1bf64f1cbbbb5dc9ccc061f4fae3804ceb8b4c6441dffcb3ab7d1b58a7d6c0cc51bf14d09189a21d8756e40df127f94773ae2f3b307f86c1ba7d0b88c6ced27565203c94b2e733a52e63a7cf1709e623095dcf81c63353689d1008d91eff8b1ed6cd78ed867fabd9ef219433d1e065bf8647d7c5438aebe2597cd42a32b2328b1b584ea6414e01a40d38dacf19e34784a1a9ec7242cac8cd19dbbc70fa7f0eaa2cfcc1f45c2a2f301fc7fa53e4ba77909c4a30243633af6ffe1c4c75f9eb7cc8699944a2ab484c50c54634c14da53e179935e2bce9d021bc7dae7d26593fb90687e2276352f6b687829ec00044b1934a886a6a452b16eda324482aa61fed822c7b486fbec449a78ac9b31f4a55960516f62aca201c8f17b13e123b735f00529aa036059a19f0d26dcded3d0bf200839061274af4d908a99aaaf542694078a739f8b3626889803b30025fe4f5ba9185ba15ca799481752bceb4cad72d9be54e258c7f4a82ff7c33a1cbcc21b53a371d66ac69d46de72aea1bd535743799db0bd49aca3956aa9afe6739a142c56679d9ec9632caff89dc991f8d98d0f81179ac636d4b8a4e312b0708c2ef3a218aab3e2095eb463881ee0f76d56ec6690a916573d861ee1a4a460ca356b6851e6cc4d3efa7b0248b31d69965cd17d256b82ef781464a4e426e4a2b4855dce32a2c0d00f72d8143c5e18ff90d6cc2010b5612f89a6f54674b030533dc47dd5cde2d5e5e2ff5e504790ce4d1c3f92a1b59058f18de4e8689d8ef416af768d237f2cb0f237bbd19b843510e31bae1a4c51d4388fdd5504e1f1c34953349ae29d99e80a58d7d857e8810e721d5b33b784642ec5df0d811eae0113ebd10b08b9f6e38a3357ed9df33be0ae610f1318800db856042d4a3beea3f9fa2467ee3b4689f2d95f5ec3a6e4c42900b000080c4f46fbbd1a6376e613d736f61e670af6ddcf8637ceabfcadac8309320ba63873ae823647262738ff3c94a8697141e511b681171bef30d84e9938ea1d467d1a113d41f9a0a3b8bc9db87bd35b3aab63a1313e4740bc148d329148d6327159152cfb4a1d2769632470e8a76886fa9731a085d3841f1247703e9ada6c97919eb4d0005f91e9edb7fbb60544e4fe470ff6f80505778c2d511a1cb9f4fb8a19e87251a70cb499b33abbf437a958a4da11968e5affe0c52852e76caf779a76342c71621e6aa67744172ae72b65e8778dd406d760c45e7100cfc3784fde5c1ca8152f22fe44b250668144b429f008c56d96a01bb59a98758a575cddb4cc03fb83d55c1433bb907399252fdab4948ceeb234fce1a6eeaa4ea94cec278b71ade4e939da01f6cafcae806c8944cc3b5411938b47356331ecd0f1c6fdf6ee9064e29a59d50bd5bcf8238dc6c3d92d080ce19cedabea0b55eb2825b0db82a0767df6415cdf244eb5e3c35f6852665a33734421527ce14b1dd3896919bd8815ec7a450473d1dbac2a549df93490304eb807dd356403292cf1567215b72e68cfcc8b1b30e37ef151a4b0c3b3bbf40a8e47e9f5708bf6c716a8c4618b4ebfc70d7ca85d157be0ef96831f728b4475df36fb24334b60a8d449ad3b0cbdec9af2823ee7fd3891e0c730aae5b470349f940f43f47d0959ef10593aa5ad3fedb93025d14df31c392efad5d2a072b5c99a71b4beb8ae5eae205149eb1902ea0f72c9c767d507b83d424ec270b40b62b1622860663843f54dc60d094137afca55bfafe1f2087cff9688d6669bf194183900f0d02fea0490357c58ef7b564aff0d8a22ffb685a9d5624d331d2d7049b06c7e9e32c937bfc03909d4a6b3d5b265289e522af599f0ac49005cc776e21537e8768c51b48bd79f05acca1f90ef56aa21922fc2f4ebcfca1ef97bf8c39547bba41fa867aaf1816c1e0942588152ab4598c6baccfffc39884630825a56c6856646006111fcc71872081027c726d20909a5199a9495d66778ec21371df0aa042408691bfb7fc3d0c6bd2090dfa506479bc49e45dc7723d7bfeddde9ac54f87dcd8cb0437d772d94fa33ec8e34e5635de7e8944771c904967cfb5a4b60763ffb2c3efc31f9db3f2486f4e599b24017faa926f9ccfbd0e76d9822a425683907a2a98524bcac9990daa43228c8b26d90ac07b5bd9f945799e3184ce67b88d4963e9b2e25313d6f5f9b00b888cb70e12414df153eee2f54dea0bb2ff591d927a4ca8026dddfab150991d4103e3683f9a231ca7bc521854fbd1e4d7c7bb5cb1641db1fd652e19038e5a72cc23a8f8d8a77da4943e0c45b3d4f3a7a676d30d5548664fffc05ba5db66b06f434b0def7d87ef36766ca1b9a252a1086e189aa3270e40e3b23cd263354aa3ef5e91963135e495ae00860df2d6f0841622a325e9e2e27435c381d57b3c1d129b2bad264c3da2f26f413ce4c362647177724107a05c98414f1a7a5beb1b9f3e51a337f1b67af1fef320a3dc797a5414d3dec9eace7ea059860f956d29caad3bee8dd041bdb7495e641c3d8b75ee6b9f1bc40b17e67feec587184288ad397d640f675f000126ae3fb3469312c0d41ab092ee046e1290b1026e79a94e33614c635eda0b65435f42591d6f3a100ca94cb18014f5a2b073f0739381021e8f7484c73f5efcda96059e3d0f173b93bb6d3cac39bf6091e3c4d1430ce26eb1812eeeb9a487cdf1c4cb933a3fe29d7e87875839e09a14d34937ba2cea6f9f2e1311c32e289e7f2d9c250299296720eb75b6034cca9132a54c20044f1562ead615d74423404329239eebf3c7b54347db3d505cf2fd9d214b8cc7cc414fcf0da33c9730617edd8bd7648471691a4a92d1397797e1215b68e461005920a5c7a061837cb2840707a055ad08a6bc12660a4f55bf13404882719e407380bdb8eaf6f98de323cf11890cbbe2f05963de6678f52d415493628186efe4ca8831937d1be44dbfd6246d8ff46cf7db025ba7a06dd48a443c3a66a783c69aaa2a74cbbf5f14ffe21ca24cbdd17261e450b516f05819b3965b12acc46bc3a8a837ec9d8a6a03d4ba3ec098e7839a51f7d2d126b15fedc54b4a188e528c020432ee83519fb421873f9384fa6497ce85c99dbb74c5d8d760e0a78240dc8d6c71bf2e64506f02a98097b1d254281afbd89a053c3ffd4475a1124823da9823a9c98bb3c76fe590f49f1e647a410a5b183d21fca7b2ca852dfd9e32e7a78162eb72fd9604dd56cc4d14fb8574a54b98971d5e4e16aca2f0585978794285711ce69837ecfe54ed00be5756f2e4ee0e1ac8ad2cfa6d62766a89e59ec8022210f9b4b070658505bf9e253976e14a036902e91e9a7d607507614b43f4e3014703fad2286323353eda20566a3f505b5083ae2ac7dcd91da02dd1b0a2bf32658fe6ffcb984e845e229f168e7271d59fbba729ff697c4fd1e8dcdf46a844fda30601278a8ce016b33bc9a9f4d4c835179914ac2ef7ecd118f3560ec845b5a7247ab15f8a1ca76ba60426d5703cfbbaf75b91f30522329fad0dc801dfea048f766a4318fa6e940f3407c56e1ded68b16c8caf442fd54e1ac5a8d41822e94e0ddc9622d3487550fe3dd1b3e55cd55c43e0bf1dea1de1eb24efc3fe786dd01c5a0ae38336152243ed46d78d423a218e53baf026484e6c2f0b937046561864204a1d1b51e4d890a5862eba6b43f5329e05c25a36e345334b45cb92518546abf7a4497bb70e2a81eb20e4c12ba8e8fd20d47432d3b50df84b39e984f59bb0c415ed04e21df1a07585a0f1e481d8dc5399e306f29ca9ba519ab44c8f20bbfbdb5eb712bf76893a37faff0869c8f9b1030a9a0591727804b8b8bf975cfb9c7a2cd291492d28cbf7129aafe49ecd56b709fd20a7ec47bc6d08582741f7933b4b83fb1a89bb01153c9b8861390daf161adba95b5558462d9f761513cfd3694c748ed939f4df5199fff8d33e5fd162f32538a7e9621e5fe0c2d8a046da79dd32c41029e136fddce8a09c2f6e6c9a974f36e022285465a258fb3098cf1ec47691a790d51fc903789b4d1a2b1c2547c4acef79eae35bec5344cdbf146fd53e6f868b2ca53715f856c05920fd0a26a34931a2d2b5072bf5af8136ee94a68cbb85092237a84f5fb1306f2ddf376f75c425c7afec35eeef203586d341f1b2d2bde4b2ce327df3f816246887b86af28319e3f8d797565efec6570a6b30672615251305b94f6d9c6b438f4fa57790449cccbf9ea90ab3c98eec6a076755a0287728369bad134d4a255c2cf21fd203916223959a90923b6c92dc259914e029aff4b9efc203b6ca774189dc9944930d11c394fa14151f00d4f3c9b4246ce2786d077b9fb2f4d9f5f2d25d754c532e2d1591c066d6cb939c8248d8fae8c79db978b06f2a8e982f7e796c6ac6eb1b2c9ef254d0667c51978931c739e211b41c9325ffce4e2a000cd68782531ac791351061e44da3a6498ad9c54284d2b067a66d4ece9bf6253e52889d1a49f53e56c605fe3984a6c1886399f71c5d3bbb9365b1db5456e5aea580e78394fa8f057afec26731967225ab643f656447b5bff1339bbe239ffa71288e565b85f278515e89030aa8d1e142be0ebcdd2cc1181e05b255bba24967e1dd1435e7bb6fb1d3551ef36e3a86f8ce8e0a34352b93bc98813c46d54cc56bdaa18c4786d90ef237daeabf67329dfa0a3683df0b8ab51f8718642dbba3b14f9ab5436d7b1d1f274ce96323529093ccac9dad8a9974407f125ae51c221d8e3e0cf4472191c283b8c781cbca3b111a2fd5b4a60a1921f2d772b6f177f944ff4e1fc142d0ea3c8aa25b8dbf606b583b447232da1d046fb1c6340c7a4f688de382f0ca95e8c2156589005c1c15a194331bf3038d4c8d955be55d1347ac74ad007b63e9785f12c77900c6469f77fb00497b1a71b0815c27738c6fb2732c23179e0b668ae7ff7fb1fae6b3dd6c36276ab090c53d7fb8cac6db36dba59c66e6bc55e1da96fb4cf78fa2fc3833069f93229065e074c41257dabb686544ccc420491e75def97c555ed205712df6348959aab2b937b4f230f9b8586b1b81b1ff6fdf6483c4027a4454d9f410431bcab79ea75979d9f5a4b60e66bd0b73097624fdfd9d7250c1cab89c5a35aa8014425d6614a8abe4cd13bb715788ecb66b7075c2c9f07a89422df2ba67c88a68bbbd8469a734bc630f9fe5164508012ce23f4ae2017b87b2017a71d1e78b7bd92b7ba031d1b9688bf618200d839007f7e6448060f4961bfd57641c25aa62d61bd1d0a351032378837c9acdc2bafd8a9b8d5a53e484c01ee908375c0e61b5e153873e5005bf9480f93484a33dc4527f419d6bd6d91b08d49ebb135010319997078dd166834c209a2e063684c8d1829de24efe66a0d8c711b57e27e028e904f9400d83f3486d1e60108ed559cdb22e3f26441244ac6075f85517d32c39941b3262078500df50645a93f5e69ae160061c2d6ab7021529734f4f1892a13975faed18fd7ef08b12a8e9b03e47cfc383af49f5c1264673367d0b2980004a20ebb034ca6a9a005a192b20101de196db90c8e5b44a012898b096845968b011d442d8bdab96de1caa8074a68eea5a78ec7f5578d7698f6422525cac5f80bede6cf238df04f50840b7501a7753d803fb968aa9449a17be3f0ba62e8367d48ced8c18a93e14e1668389c1ead7b914a895b753702c08eb9497afebfa205246dadb7e64eb452e0c34ca4b3a434980ddd79b005c2cc664110518359bead2e748597674c59cf39649e0ebf357fe2d2d0c911a774f0cf3687a5541dd33f0561e21d0551baa32e2d7bdd86a6847f6c98c452b23f12cb947d69c24d2b5ece1b722b98eac37ff142b0643e993dd3a8fb2952dc48a9e79277cb1755e40e143656abbaabba020ecaca43b0b8b438149313f87b6dc19f5ca4b44cc453b3ff2ee8ac149fa9b05ea33a4dedcead3747a2575bdc95bb0110413aae42d0311856a3dcb4aa32b26515d8c59bf596931544b812a04e81e9ef7dc81e360b3030a40f22c9d212f4f876e41ac0f5f79bee22ef62a51b0c2055dee6a201124005e5fdb6179b037f934b2c523fc6534ae0af90d3fe1303b333c9b9f684125fb82168fcfaf97251351d480ca0aee48be04b1e4985237266c7785e41a5703a643fc9fc7bfe952562bc26ebbaacb4152312ce5994265357361b1d5299ed8f8dad6830c038bade31a57f1da31ead237f380570c00839b54c22943d0c800a66c528f91aeae3909b073aea84608610c2c9210556017f7c89873045d9b78aebd11d7f25531eb66048f6204e20029d9b187ac4a305fba39edaaab158de7f395203444d666edbdc131a7fb6eb0b1e58440b06017524b9bfc28bdf9844d3e10f2141754dd353cd4e4f10114d5bfccc5b3caa7d21a970ed23b5cf7e99a286fedb5e8b8845baad0de5b3657d3a17ae8d6e7e0ac4180add1d11171007b37ca5e2ae5de1d6822bb425980e91fde8a420b2de311980ac0f0eb90675c68466ee56433b5153b87a15367cde574ada0817027ca1843a565b337a8724845a7842c05464abe69b44e92dc862edd89ca009945e408efd1efc29c66df2666ee01986e80ea3e489575cca3d83201a9893811f4852d9a4be4bc82bd920f384a1a71084d683d8b96a88e8563e18f20d81bc38f87055056e53edee846c4e323341ed6e4c9d95e4705f95302896613e7230940db110b0b8b3daa292f2ca1d0e705d1d3e067d7918dafc8d5f2604f221cac63c1fa00eabee17848b19bcd589e8660d4f819d9d652b378e41a544d3cdc841a5244ce5df21eadf87133111edc5d00b3e8f3f774a52bc41e6462930eca7060c62d8719e7266664b551df37a6b96811e95358fc7f7fc1c4f1482ca354e1729b3c9e6e42271ff897ff19f3c764dd85de023909d19b2257ee653847c6808c38fe0a5040aa06b0c4e533aea61763f1e5f26e5e837f6e97b3221284fab3a4c826700521b5d9d487dd977a6dcbecca05778cffc2c530143b9953319abe699b79e32c684fa5759b1dbc20eb1a2432e7eeb6f8db887d3abf613f7f9ee0a674c2dcf0a4c55e2d1061d0da8c350ed10cbc07af0bff323710a6075da5eb54fc6c6e67f5f81eb7623921d6e72680ba358d5e4bcf7dd36bd943884e495b0a3542497d6ea95ffb5dca780a60bc13598b0984cfb52d6c8b20208d55247b897e96600a6c1c0ffbf670567a17138aef3b0c30f93f73907f2013d65c20088887606f75735045ac1a41a5b53b6b53c88d5c785f0544e718337a37e803861b9c85d9945baf0753257a79273c4259cdcb7a4a15cd66ffd1a7ef04636dc4b204bfe9ba62afc737b5ba0c7bfcad66e03b28be1de1157910f5975dffd9999d48ebfaa30e9f455247fc4fd2c714b47d4da3ba01a29703dff2e596b4272ffd180001b3383d6d52244426f3bcd5d222847601ee49edf1d3fe49451d913fb0771ed025123308973e4efcebdb67ec6e2d821eea20f685e12a089c35a5491290e3c9aca8844c649a0f7d9a8f259015bdfe7861b3374bb3642fb602999637d3ecb2dbb5c59271e7f75d4508a0ad8f2093b6dfce3a85630e6695fa89544fd5741a21228351cb20754c1476b390e4c36999c8d570e46ba4ed0b98f35f267f31a17403d1e8f7a399f6e69c1db00c8714eebd1b01bce679fa7e8d89a492e6e58da9c866ae6d625063f0d4c298ec7a182a556eae4747da55807b018297300def42f557d4477ddb3de801edfed07c73e8cc40f9a030415e9ec464a631a3f8e485c3d5599b0b4d17bbecb82a465ebdef503234de9db6ce0df48034f53c118212d95d18da7a9233b716bcd49ed645403a38a94b3b82b9cf334933366324340a5925ced2151a7e8ecf1a34268778119f0b6b97c5df3c0e62a45498d4dca8024f1ed575508eff273b473f824992ecacd89e289e10363511d47e3192dcf4a1404966fc77c8bc23199c3211527ae4673904f00a601f7dd6944b4f458d7f231edfce68450f8368c9164c3f6c67e29c7a428186c58cb2e8971cc7677bcf60ec4cd9978c94faaafef5cdc08f065473c877397aaa70020d2886e09d06a2a5f11766b5a4babd888b061c7e3955086aa08495c468eced1717e9dee920ba94b73f084876ce32966ae60e84051f333916f278bd17eda9885a2ec842c600775cf7b2eb5972a1df17e8fc6e91d0f44c2294465d12ee482e32dce8fb8f28bc212c371829b0dbafb429f1652de0f401ee2a62a05f9a35ad90ebc27a8f5cb8b78cd884a7271db5037a327b15f541321d7bd762c804739aab0170545cc9665b1fc6ea3256420ab180016c2c2528004a12505ed7043861e24f20853c4211597a323aa2742a93a26ea86f279bc03049c377376fab1ca9fb20dbf4cf0f1ec0a2d8f5f2ec1999e915606e7498668f0612899294d9d39ff2bf66d198cd7fb601293cb43f9649c5bd6d1d2c7aa8c8eeb343736111d063f5d47352beff9fc49de41b09b5a6024f846aca1864a5d792df719480ce0887095ef0b1a28dd97d60e65b2417be32adff597721a3a5513a3c7ca24cd539a39233019d8112b2cca206ebf94cf449424e272bebd2b4c7b697ea3837b71c09846637bf204d24ddaf6b9a7ea6acadb626a1fd25fc5a9014ac54e0ab2c011dcf2b57d124983b95f0071a47536452374c65cba3cf42ceb7ad4a4655e24b175b09c401129d3900cebc85e33521fab7227534fd82f82eac8fb983b492388c6fb62eb03b196372865098a034591b262facc885c1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
