<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a2803d52b75818d4801e1399a504202e7ac381e85331db657cead0c73a37dc7c9357d7addc55b60752db0b2a499cc12e72bb72cee09b5d398eb2237cdb256f23421eec69bb810703167fc8a92b6f076b57e7c041e3eb740d5382a8ce1ceeb27cf517700990354091942b7363224d4425050c8827da12e84d176576067c91c9b67767a7e48734899fb34f08e522e45fdf215d59d8e7164566f7db4e733cac00502643c6ccf13d4d1ce58c80ce2eff86470c87794f96721b1b4c3127acb3c509a4b3cc13a4a86463f4f46c53565e54dbe21112e6d800e9e69bf5bbb636d0efe2c1b4e2d78f4baf8075dbb808de03887b20f4ffc29ae7f851d3d22dba261efcd1f3d05a4f626b34649819d8f4b7cc568e1761ecbd7c6effc3e323c1b76d685684e9c7d8dad9134d2b5008522bc7f429d379702f6bc0d65d0fa7a79953eb0fff1d68a0aaef6eb0c162f281f97dfc18e286e44c321096e9a8fbf003610b301687483f2e4f57e848e8ad76eb2a99f9f158e68b165d7c539f89bff666b16fd16c59bb5cab45c9f4150f51cf576e594b9b0681731dc7559330e1b71a78946c7166979abfe043553d99d3f5b5bc87d9272bc0e7d3eeb2f69314a10b31cd4688d5562ddaadd3d6f0deab4312dd59c04e87b0656228c5cffb3f4c9e86688e6bb97ad6d54cdcee7244c3acb97998209eeb79812f293b859ffce0494f5fba06f82a9435565f40389b912b9c4c78c9b59dd02c4fba7283ac627f5fc288316a7b0263ce6e7250b2217ee244050dc6d21ce845d56385034eb9525fa03065b996958ede3fd8c2b6bf1f1d1d0f5b8e07a10a79961fc4208b8befb0f4898f7c0f04fc25db8ff8223701e308455c83dbc23f0a07a68f361b365f5575d37f5c5b55d1b19e32675af793ebf773edbdc70a56b3586fe789679e4beaa0800609b396344a96e4969919d3ee3bd9a931a42f804bcecc583f3fcd15c44c8c283424fd1d4395272805b194e7fbdfb7419e4cbf7e924c1538f19d1cedb2a4e223101fa2ad89c7ec5adef20a408b1ce3b04d47c6d7623fd5678b0770418b66096ea868ee0e4c8f0bc77445be987a870e11fa00cd961e9f34efa6a9bf44247a4041a8ba9fa31e88a368e72637ce5ee3584e58b9457e0c8071742ca4e63ea18928e3dd2f3400debd6fa80d5d7c7f412fbec9d855d5db93e324fc78e0d49c410d081967087ddfd2d93a73d50c419cc0130685c48186e506e5cf8ec6a1a01790e91ae7f8063ca226ff4b2c8fe8fc616515f9c139d1b0dbfc75d7db2179dd11266109b101b1bc4ec1c264f7d123788ecd4e6d30fbb7d4d90b67589c29b586c4274f0337a73b3e48f3a9622175b373670c4141da0a325369dfd65acf28582f60df44c57307784a4eac58772c8f203dafacf60d4189e8ba7f4c90af19aaa6b210ea4e652985ecfac8114459341425196f4a5e9210f477539c13a81e94e1bced2626c52c832e12949b44ef6f2754da3191f4fc826cdfa5d6cd5f409714c76c937dea0510bedc6a91d52991463bde700fd7020783370d1554455dfd74aa254d7d95f34fe7b851bc8e4ba4b79c43beeaac9c71d145117c092bb1bfa5827f140070ca1b5974b1aced7f6835013cc177e89a09daf9dc779c8e88ffb19dea012a47a2de9f0620a6a4527d49e36384951ffdcec27fab7ed01c0f1be4fc60ddf3910c74ce25954b656bdea3d2bb02e2a6e4207f9a81b011bfdfc99ef43d63b9ca497072d3cb926f52452c4d2cada9c5121efd6e2188bf206ef22e80fda02b53e4498d2631b450d67f870d244d357c4988b35e747d6e4ced322ee9aa3f3dc79fd6b425089695ceed66ab192fa204506a1a35d1c354b8d4952cbe84d7bcc4af9dd42ccf183601bc667b8314e9c1199c95501f26b2d29b0974a1d0ffc7f95cc00cfca30cc3abdc51ffbf270b486e354a9a5dc8f19bda3b1ac67fd40151a2479b538551b43c30e6098f9f862ea2b2b067befb7917a0935048260e9e0d2cbbf47042405806f29ab3c9e3731051086f8f019ed1dd582e5a344980d9b984ef4b29c22962e3912bd4b2fd6d0ea2a88e1ba18fb16cf2f9c4f0c5cdd7be1f5cc72d854a73d9ea60fb2ed0db29de52d369857b1aa46c4bd172ffe5eda277fe964026347c8b22a94d719cb0c304e78080695542a6e2aac3146eea2fd45dbb85f94c88316d67cef024f925d576e4c7522bf06fabf58afd434ac65d22d24f48eb09c94c310560aab6af89bd0078b840a73fe15b65f22da9723bae6955e0d858d67b51f2b8b5c696058c7151423c83a3efd7e5a43cced3af4f5eba3ab587a8f2686cc6342569a89e219bb099e91f57e63e9d6d3409326dd0fa8a6c97c337d12205a24622a9c12196ad4ccce31feb99f166450a0031e7df3c57d971267b2d1f70321018c4d7ad2ffee91f352ba3a3615e71abfa9ad5597b95534854d32e5a458943c0f1cb00b9a4ce1abc4f7d84c933f254d1a8071157ee1e533a47b11c821fc223acf566510498ee4719f21f7e54f107beca431af8b13e902b5f50fb16233f52b2bd43dc0111566915e5b3a49bd907d4450fa2346a99de6d3bbc2769bd18617a12985be2bf9b4d0bc22debd0066a163b5bd100a5489a70041e6ecb5d15c50a8aac425bab2d7c4d9a14d0a9348baede6630388e4a8d4d34235f2d4caef7104df7b43605bfca39e9ba45239118864454bb9e448fd8baeaffcb1f2b439a7d8d97c98b413acb55171d174681c5207f586393ac8e716d818f3ff58d9e50b2d17666f16523dbb49a84c2227e9f7314e6f134b837b0a44b643a2d189603c6da356bab7426d8c275c4f8a589c3b9fda40e4711bcb167afd65a204167c86ab7c7a213a5eb5dc4ba568c73bfef9ae2c2a5a202b1a825092ad9443611caa3ce82eb442f65e4fd5c910790395a819b52f909f913342f4c15f36c9ad2ed5b340cf8ac3c76200cb1b05dd01385cd8720ec09e9077122f42bc7157be805067aa9115e477436a61da712af92b96d228986259a9b2282ff52e4b88eff29c68eb15e7b358b23447c61b484cd6bf8574d8a0849a711b163cede7742c04a53a0ec8f71e40be4028fc9bf3352654b03ecd2cd667ff305d128d5e33d47baad8f5152a7da6b9e41c920f317fda8a39db1fed31396986db5cc56beeba63d55ef54c2404b8066d0fb3c76f9d72658ee3bf5976096acbc55d0eecb25792bb42820fd89309ff9f4c3ac47430f98003382c00e6927b199aadc8039a45e695419282caf0f097b33f3943998cd164e0e11d8a74aa85ada11f2b696d640f6f8b143e4706966782c3deb13c9ecf2b9b778aec41687d19b63e5b182832340982ace53744ded4d1e5a0f1d357408aee88d9a73d19ec7ed8d1cd8d357c6bffbe22af904a41d928c5e295aeff132ca4f78604c50ab60905ace4df36ae35945239a317cb998854500a1ababd03294704f8d77e03c4a51f675169ca5fb3f743141862fc0e303ea8ffd6553bdf295341c7899a91ae21f2d58ca7fe663592d4e70cba5b71fcae19ea7a169990253c5771e256613d277750bf2c635d5ac40eff986339954021a1c4cbe643391ccfcd4a4f3ee2f287d0f9b250e31ce4a7399117d2dfd000b55ab0a27cd3d8626a0f88cbdf54e22d05414cebc77915c1ed17c64e2433b06d263fe2df65ff13362d29b8e6ccb615762e124c48426e3b9e38fbd6b28f07903cdd9fe8b09b6b7058643b022d605bc93d3e55ef7a0e8851bce4c432703efcbb0b341e21a792995ddf5a2abbbdba16846360a45df4218373e3e5e6121250dfed50d1f00f7badc4f7ffe7cc1de860ae600f68c8f79dffce89237cc9f8042ba6340b8a04342f682622a03f8a8245dfb1a513c7767c0ddccd2821a7ce270455e46e1629b976e754763ef9f8226e78aa92a3b6a5b2850bb4616f88003a0abaa5da6dafb1b5918c9ba9507f1110ee0d071f801303b169fa291bb2e739bdcd2851f3ed8ec20db68fc948e5b371ab2d57ddf06b827e7483612c65330e0481d6538baa7ce79e193ad4c9691bf13c4c9a3f638b77d1ac41348e33d0f8a92b3ceff6415ff9b5f251fdd394d33baaca57d8c802d29574a3218659a29076d4e96ca9b4ade829da47cd654c4e8f2fa98b118fb6d20610aae3abae40c375410e875180bcaba58d829bded2a8edf648b5e21d183a969ea8ec83be6d7468254ee6ebf8960368d3c70e5389e3ec764f9741e09e843b24773f801993f5e711308dd134660ed35eda41e8ea3177bc3c2a1430446cbcb348391dcb05d0cc45731e660bf68f38bc6a18ddf158a253810656d4dc827afbb6d2a7d29a673e98194ccadec74cd9e35c9f220a3f73017a515ffd0a47b34ac25d21881e05ed9cf361513785082e10d7af2d90cff95426664c3be51e21012336314c200a8bfd0b754079ff3ea4f14b741062def091b6a11391bc39e7e59f01a4ddb406c4a8658ce52f4c566e2259a36f42439fd533ecacabde43ad0cb13730cf8439d62228622255b0a4a759902bd591df962790a0cde2751d92e5e59b2c438d586f4d11ebc30c89d2ec2ff11e9c9df936ed7bad699b273b6ed4a5fa44fa0abf17ef54144c6f3d1f200e05063db0b3eaa0d5ab90b3b52db20732f8184e6926ba97740cdd9eb1990e618934863efe47f45e3459cb80107d8d2c1f35ad1c3cb9d2e456f1c7ea82f722556bcf2b2169110bb88a047b0d405e50fefb1171561123a30793e64259b348182720f20e4445b63a91342c76a00f21896180e7db0320b31ddf3e3a5e3735b31806a7d2b2daeb7c8e5c61bb7771e1e47a628ed420b26671aeaaa3022decfaa6c94b1cb5995da611235e0e9332cbe3fccda7af474ce597ab741f23857b44fdd0f48156d8efd8833a23b2ee45a6bf3565e264dc66ff8878c5b4e07f6f4b9505602247a8902908b8ce0ca9051731ab769263ebf36878d534de2c0b6fb4fbd44feb80e4aa2aa306c4c8bf70cce88b3e44b4a408aed8c9b5f1b4452793860f8aff6498b5763921cef1654ebd8adbc886209050b1ee2345787ad32ffe850ac76edba4504bbd57946928651e40e8829b2e33bdb36f5cad66918d189e5db37a8b8d0ba0eec8c9fc39a38cc5e02573f6be851740b0114febf408e9b87a04876660722a775faff5a7109d2d59c151947487d19b1e6a6b2e89996d3d48555e4647dff9b517d8aa6bc143df4cb4c750c5133e6b3ae07586dd5e15a90ca228e728489822f01cc067735ab42904b088092ce508a2ca7735a0925765bd4b810b4053fa9a6aa1017987218079cb77d183c77aee0cba36041d09a71fe1b999fed059af5bb89ceae3e8323bf710aaaa82423b284f63ef8e5d56aca42b6a90d84ecc7e0df236fec019b424645e1d35a0c4065f511c4b7c0f8cb15d7e164405bf9e2669b4781c8974f6159a1a0f63b03ffd15c377c5553d421ef6aa6b435d6ffbe7b91b595178dfb3a640857e8c54821e22701d6a967a4c93e708a85d5c7151f3096edeee3a4c268d245eb24a2a32a0b78afa6f2517b238499933a10b7636fb98ed943db9aa85a6506413d5a7bfb5e902e3f7cd4909e94a4094c7016c06ab6863d285b33604e34cb8e9208ba1df8a81cce72c1e46146f0a8f26483104129c9fea176e4a919318c6b7c7ee8d13541f218b3c8230fc011c948853caa07eb89218b6d34114de8c46546fa95b455b37595266452f735fc7bd9b6002d257ee278f16239ad6ffdec461ee90f7a3e910992ba6e95bfca1a44d341886a41175017958d3208ef0b03c33c713c9d8c5fb4c11c7b59b6e1b4194bb83fc661b717265dc5562cab5d9f9272bf0d24d37fec905c670abb59c8602a1a3dc37f775925d0caadb9ae64ac320619d83f8b78725fed0a107d94ddfa4a4ef8f6469c274b727eff3b42085c2d1ca626324ff85ba6374482e8a78445692ab76cd25644b886981f23252395401a2c5e8e26c558d5f8132b663bb88c92f8ff87f6b9b76f3688056daaa1840b35adae63be85b946b451793e6ef530051c0bbc1123d2ef3a2000f0b6a5f8c7b0273d405e5cce1532d6a1d07a0d93e77e287b356b0973d659318b7e00f89b43168e4504a29792d5194f8ad64a03027c048a46ef772daa746d25537aaba451ece84de2c0ce728effac7ef12c6cf446127240a334958eedb498b111de3fe503b4104fac54d3d29b6fd6f2a622805fb666b5b732be391dde9fa90d0c01c7a11a71a6eed757b5c0b545cc28efba209b6f7356ba84a39d836246e016fc9942598021d8e11955b5cbc4565426b20d3c706c4fbe916e031f12147407df636d2808511fc0d7c5386365708491b61ead20396bc95b061c1ea450151963e0e477907007ce42446b93ec8b70d7019fe50522dbb36844d41386f3438dff16e8d7ee2864c0902d393e9fd1866866da0b7754c2011e156324104ca9fa07dd3d758b02e9f6cc0524738f4150059b128e30dbe8dc5f72299fdbe2bfd53751fab14e1610527115717a3477d3ad5cec981498775373c79f0b3499a0d68a27d92169843d78b1e6f74bbca298be006e93bc4f332cad1e1ac72c652acfb0904ca04f4c766072113ad0a7a04192a220a7c805f935dcb485379a29d87fc794eb31e8f268cadd556f7149937e831e823b1e68c3d6a3c0588dd31c55ec3a682892ec9df77fbb16a13cbdf1c533653e13d44814bf9f363b1214c7f349881d4f638f9a08afffd926e8922ce07b53d8577d695c635ac54eec141460c16798674a363fbf040f58b43ee9d9dd340cc9a1ade585b116559a51b37e939c39adb957c082d087971c6c8537ef678b5ef60a71ee8cc3464dcdd7d8b36c63ac214704f7e514d378bfa873b75f3aa74246111f00cc99be3b5484bf778696e55d90c2233db08d34328511cdc451e8e2daded779a0b2b33b80d8759cb375563e80e87a43b4c835d2189f16d46a8607539edba34fb10809ce716e1d2f0ca0bd886e2869a4e5f3e6c6934dac569dedb54c4ec210735fac1d9bff898d170282efc70670b713adcc691a88402d35adab96bc61255d53edb5017871e829e3ec97453eeac429810e9e69ea6270392514978e71d6b2d147f3db839dd3550f4f0e8c2f98af1bd687c05597d0e4e4229bb3800f926bec707e05380fe5a8f5821a9c0022225956eb71a4df6de07a5bc3bfc5e45fdda5454ce88025711d33b803fd7b5228f8dc829a07df2fce436e9bc9221d5230fd190a7f53435d8b66fcd1d6974cee7d3362717843641583a01defb850da37453771409fd88955a0d4d6e5ccc117a5460d4d2314214bd204201711f74eda8681d68aa591086a9ddce3fc77bdc36e5ed68625bba31265b99457ae8b7dad462cb9671debe4b5924d88e8712771342a20c86214107229b9d6e8f1905e465846426e7bbb96a210173b874c4dd030ec6390cbe641519ce383f7ef8aa9516aca91896b1210f1642855de31476e05d23b7099414d4ed468be12840c9d576077b795b1e9bfd3f8a9f85a289f980bd6b92189b5a50115abb22affd6c2837866988693ec8a37798ca5995c311924c06a34444683a0bec7ab7df781a5fe8a37bdd81792ee1def28e01cce601ec8c0bbbc3c750e167f3892dbed3a03126cef7c1a1578bddc399fd5a19b5f8c4618fd68cda8ab1fc875df126fc994dfe7900ee1fb89da738c0bfc376847d4a7ed65b6560085da2b5c1788540abd61e4cd4389609d4194312390e6c4c0f8b2a6e49a3682db0084c21e6c05ef7a799d91947b9db72ff60435384370d07b69a6efe9264f504d8f3d0ed3e115128549f0fccf603e708658b36db0ce998099ccb13d276f3c21a93f85d7114366599c9b4164fd9fbc950689ea2c5cea94f5e4e987af2a9a0926209a2bca75abf132034324480e0cd15c8089a0be31f62da7dc5f1ac3cb9f41812e788b7776847dc9c5abc7197c2991a99c6ab349f30e633cb04b913426b4923e9e769119f5a42690177edae9a746ddc77e0cd84be6fa6ac0cfc6285b35af682a11773a7fe1de423ffd535d1cb39e11d9abe529ba555450fcf101a4ea31663ae82c31fa39e3f564b07e5fc1ed6db45682d79734d4776f81ffe4016d5374f11b386eca4b3f2e003db3d9f77acce62121609472e85b88f9b2a5ab891e73dd081faae260ce9f9e56dc2dfd348c31a53f73adf5107adf2c6be14867ab3268ce9dbfa49987d7befd7cfe5b62bce97fefe4c6249bf0c2474d892906092e98d4da1ee0354176a549b4395fc979a20fd774fe5a01797de633566e6ca484194be2cac388becd30a1d0dc84f6acb1ad22400b9fda16187d5e7becf08e18b81171bafe318f79dbd7b02c098eb891b208367fb6407a688bda28f1085771f95595f4042c46e997db29e44f3cd12aff247efdb8a1ce78daaec9dada1be66389a8bab0d9a16989090926d68c92a053ea14473c8008fc2b72747bc35e6c0834b0e95c5bae8c6652d4d3bb13240d910cd61e43c491ae8099bc2261afdf458fee70e161a972221876c8e2e9d554f8e2d047e062bd67a9cf3b1c5a0bb2de568d1f5aef5db05c99412b312f39ae6c6f3566cfce3c7942c5da01807a508e38172592833bcc53807672d1cd6a212b789d1eb3c3f5b2c2ffa04069e855333588dd4124799e4cc32c4ace224e9c495b7eb3c5879f0f3715dba2c99aa8cf9a73165c51566e257a6a30f492a08751296edbef6820ffa3d7f27a88c891ed9b82d06ba8712bb63cdbef022153869eb6f50e67976e6b9d46c87514b14c37c3d8631eadb597e043e6315d6ad0ba7ef6c77969e6b8f1d7d937047e5d584faff067e0a22123938df5e41c281fd1951ab85505c7a59aed7328db1ac2763b28ad3f51fb299ab0d206c50ee27f33419e6f78f44c4d633d3068a29bd5b0ce7cd3cbd00b9bfb4232a84584faf715f08942696c5f55c158c77a6e55823d828b60712162704ef374ecac2cfc722ac9f302f09104f99705fb8983a279257cc89ac6c8e519b4952578e4aa8dfbfadedbd34ce5f43a54a71617c1dd3a5ad043f3178a3284e477e4668067956059d6a9aec867653657d51eb19aa180643430b9b8aa54a682f8501caff6c9c68ea708f8281bb0e8e069922bac710e1a082648638eb1eb99a2144ffa12e30045c78922491f38d1975e353fdf51f0b9d71ecfece3f23556dbf5eff1b32608d76605234cfbd283de04c3ed9626e2c85d0fbb5dfee73e2666859d9aac11e082159a73e7c376f9b537242db3519774da217c5d16c0af2118d44997f7e4fd3533209a94e7edf8a431c02ab6db62b0e77b01e66281f1ef23d34c2590a269245e1db2e98a50e3671fc7d58822bd9561a960edeea78991255d69cbb7af51e0298d00d24e2ef8bb0404132bef6a1925d7d4d7b74a376aa893cf6cc3c9b3800580598f447aaad6c47a2a822296e4f935f5d53811e836a44cae81b679034eec81a3a10df88de6db2954f5c81a007ad409387584d118408eb1b0cd6553fde8dbf0ebcc710f481e140bd45b6fa4ed0698560e7973a1d7c2fde16f4c6eed372926a6898f257adff56aa7c140b053a4f228d8572a35600fde3a63f631a73d90520e3f05a10acc5d274d51b4b81440476c780f026366ea2a8f57863278fa781fe355237b867b0c9d9363f4ed91a8a3ac747552cd6b36fe04145b5a863428b331c289f2475cd65f19520e996e52d02ca4c620718297bd37d8482f71a0e87a4f058af5daadaf9c222e32319bb68b13d063c37fafa510a69740abee6aef94ff4eea4f1f02da4f6bf538bd09c2547712f41dd688d88e9d5204fc62b9da3b9bbcfe144223a12b529edd7922a415f96a548e41d579587bd43b14b6c86167b7da48cd5dff5e671755a4a7ec6a766bd05601b397e16d23a27999dc51810c1e75830a6b9b11d5bc863b8f583bf7431d36b3dd65f12ce852bd7957c963415145fe825098d8708f057c87bfb73090899780eed6ae8cb89892d15d1d916957caebe3277003811ad4f841f86be41337eef770d519dd0c9e31efe5b31a1977dd77948345f7bf3559684bb9ca44b5d600ea844aeb9d586db771dd06797c06a152b1e834e3f3ffcd324f540663a6b57e2fd4ab152d64dd88e3889f3d104b972322006098e7100eedb828761cf1f48ea89a21b23837f61526b2629402e15c8189a5ae5055ea9a8adf4450b8915294f9c2fcdf3058d7ab7e5128701b263d8e005589dd07d669d46781b8088ceea57cde9adad57c0ca9dd844f601952dbdebc59ad12694783de768b1af532beb2d6261dbda0eaac59fa1927c91e58af812d698733abd2fc846ced63d972385788e4f0d230dff8b227fde126e39be8ee729a75afe1713ba6c9c9ad9a89e047909120201f62626e3faf4ad3b3b5d7f17ed419ce52c2699e3f76ad994dab5ed821d9fa9fea0129163bedc24f3e004924a8520123aee29d2b53c6117dcd048910f04c94f3b338da1c7b1bb3f042c7d53a39251b0c83e7a7808197aae079ec8ac0e47de4f17582ba3e2c1bd83e4555d8823393e3393792b137732362db140afb7b5c49d52c2640744f3b5cc5e7cb28149a8a76d6a96dfe8962f3d75a835db76214c1f265f0e4d1b619b745154211941f95ba068069d7b84f7fa3759109bf59c3e33c2ba367abaeb950529f41ba4727a83674ddd9e2322c7eb18ea569cd9a82441685edf3a9dad4cb4ac29c78d680ffe555cfebb9ec098bdcd2d20e7c826895e2f63cd0f1b63088d37ec032ffdaf5e2bcf0c8819815351d50ae497849bf1e95de0685cb3ebea486ef1b0e2cb8808728865c8e1b309d2547f4c4f9b12d5ecc6b0fb4d228fb6195d4d04e337bf88797f9c20bc7e1a4d1795108f619be6caa1e4b14ddfdd65c9e19807708e428001625b968a5fe3706e2db78805e7d5b937cbd4c887435b7ba2c4c9d7e64ece080a8e7bf7ee083eb0c73c3e53b3e0eea1c3987d03dce62fc5315eac044227d35d0e3035b69aecda6619c3f9f0c1717b6371d5185a914711bc3dab2f56c4fe927f037c1de70d49973f511f9e0c80e3af2b97129bf8a4522b64dab787c819d8c3c3eb122899122892e2a64acd2f0b5b090a1e5cf6201664f66869579172656f3f9b27f9ccfdcc99e8f2d741d58740e418d7af877058eda11f63067344322f0e628d1198ec6f360f2e165cd422561361c73a34c1d5a294ee1f99818661a234e7fcf82a980da38e1ec37efbbeb34045846b2752be12d5ed6d8e2ea53b232bdd11ad5bb708ed16bf1e3b1028a96096e35147a67d74d042b5e03f7826208e2aba66ef5a51bb09161699997e5b16452d98911161bd1a19bf99d85b0102ced52d34447f333b5dc740870fdc2f7c0177f5d002a278edc03ec050c30850d57e8ea9a18946900cae42506d1e566e4da24ee68b62413ece3339ea6d727d280978cb5b62e4fa4fa4f8ca4ad0a4be65407a371f2cbe521eecb7c88e0a37306c65a780ac52a5475ea3dfbe4e161686af15bca5f35e1ac33ba5ead5d091731c0c2b6ecb58e797d7321c40f421b0ce14267790d35a428dffa31ea18dd5f20ac5418ff404b4d531b10baa78b4f08af56134cb009a23aade7f06bebf9e2ddac77dae986639f1655015c1ebab97ac9a97b2c1099dc87eb32e4d06018f25ed82cfacb73cfff4f2c9e5d7b4dd8b3c8819e9641f9fed3e75e453e7dbdb0838402ad4cf733e58a22e630a8b138809e78dfac22ee1494e0523725c03c801205ad04b140f185922ef9e938a6989e7ef98746388a042cc71b4becd83e5d63ce731a79f5f4dc3baa487711e1ce595b0f38462d6f5ae43bdb5e6ffd754d8fd3322498b46fd528f4cb5076ea2802ea06a9a5174334c5412153e4a08c8276b01c577254ff8da0554f0a7960ee78d8a2f349f3da8712fa89f6b29734e2d76ef56436a95fa00e7b9765f7681f4ceec871cfb0f79486237576be202ba4fb5f45a1e215ee9bd01a721b9d5122d10786fa00ff36a5625d657bc4d36ba90f746f02422b9760aaf2232c0a6a55a20941190a4f577113726da2890b3f8e29bc579a66b34f43354bfe6f09c9a7e77c774f909d074150b41a5d0e929710aa1d0decdb228cd660448c4f1178d6ad94914c1b57de6b3299564b11ba69945313998137faa83adfa99a75412bca0fe5868d2cb3dcffd7cdda72e03d75cff608bc098b42d3bdb3789c5bf71de051a8c7d32dd879023dfc2ec531b156d3e82761f943f813d8a591dba5d644af8dc64e2d7ae5b698cf85aef67f2fcb9a546ee15c64c8e2e70cd6a59efa199a7d397551c11eb0579ed91b708dfe77bbb2e61d8657bfd59dfe2250e5a1eec4f140e6a1a8705a284a28ea260346500c1b9e62da49a8b06c0b909ab23bd6de7c25cb486fb0cf6e897ff3c2da7562a8ae95ae2dbb215f22b59fe97e42376fb782040dedb92e9824332eee539056a813d6a914cc052a6273ae3a50ac33a9949f6efde73d76f25db52dfe40d28b951c18ac279327b11b851594696e691d1d951b53e4f7d358ba55ddfdd25f3dd098bdbe7bc912cf7798dbba798f97eb07684195e6f1531e2738c703f0ebea8966930b08c00b7791bd1b13fe3786657cf2e3aab728ad2c106f9dbb352ba13e6930b51017573138b4ca9e72e5f3a1204d9443543c7e0270e74b5af26ba3703b3f7c611074a33fbe187d287cf8e5e34f6c9302f625dd3b7cb8cb395bfaea2a3b1451b2dbff5ea304c55b9cccd24749206884e8fa97411f853233876a26daf0e264de9263e48d5b4027c5dd8d738b79b144d8396dd18ed66565d2f011721041325d79a598d968eb40a7a0a095a80e27bfc48632b3892e42c3580d2a06fee6727ce72e98617f86c46cc802839822828a44154bb93b51b5c2ce7020588bbff20088bf1046a2a8fc33a54ec659d8f0a50fe1067c08c90fffc7907e3f3da092c77f5e565965ba764eae76bd96330cd9b91c40eb17dce7d5bcfbd182141038acc99a4b3be45fbbbf50b3b28ff594354ffd46c28d8d95fd2e4af9a4fe049ae72f355f8bed494b4a095f2933cfc46bc83dc720389fea8a3f1ce23681828a7d90d045f65c4f457507e463c8b1e024e515777da25b0b6c36e3e082125d1e58570c503cb4298d29324889eea063753104477b6549e7d4357a5b128a38e95b714d01db669d43d67fda3eda9a05210401371d4d59f512e6db2896d91acfc37421e90feb6f70ac8da126d532c2d1d715f0ec3b43fd8beb37ad74bdea180f01e1f54f62114a91706ff46347a0b9eba5c00c5cd6516adcd4023e2a9b1091af50448759657cbdf53d6af66e266b012793bb8d024f6d4a387eddf735a8456b1ebe8aff92fbdcbb9425773df5840d9308b7d315a659c2aad863fa9abf5a81ae06e9892ad1ed7be95e1d6a26a83643a64ac2fa48fae23763f81622b712adbfd44b055cb5efe2619e3396fadc1b5d4aa58d14345cb789cd0fd3cb4db0ea493c8216cd188511802df1a97c26f9f983c5f4a823e42e4423307737ea2fd2ca668e4b4f47d09281121b59f398329ecae0fd879c68a82d44862d033bba6fe56b0bb5fa3e12900ec10c4a4cbdcaed92a8a44c48410794e3a03359541a87e411d407b58f52ee87ac5b0e7fc53912a02875158450c5d886248a6692d38086b5e7dbab3f13557826c72c87371e55000ac7985125b6bed550df2bed43595db30b94f2fc971a022adb5359baf935c6409c2cb6026920cf3a995d437d1993aa83f2fae175ed7840fea9003a7c7d077778d7445777202281a356d296831b338e8b39dff01bcd029770cc3dc10af7e7299102a887f8272abfe9560a78000b13121734ead236870dd2b1f9ad9b63f30de5eb1896121f8bcf891fe8b1dee6bdbbfc4451fb50d84f5ef7414179ca9a48c5b972b8741aa0c0bea82921332fade5339d71fa76f30cc14e202ee67e217624d20777acbae50719a4e161cbe8a0e75f8bee300a30f31c23823e02d1067630235793ba37dbacac4fd0521720c91cc03dfe5b8a15c8a28e9fa35c15864fb2637a66a1825aa00d5170bedb4d47464e9372e290a0f97f8c69326613de4995e5a08189ec7b8f1b198dd8f4264d5684af6ca379159d1164b8d8b133ed15f443a32f2eef9e0e0236d71ba8990d0e7d512e9a0e39202d5a6843787062584a3d3e96dbe41038ca6c458f635fe2ec2897d067e48033995dd39df4a770d708fbf5d7a6544abc65d50409e7f65a7d20f440ba641b0060076ad0d4e763ede510f0f13452a539e8a990d6e0c1b2d6bcb832a327bba5e68975e2e4cb0dfe5c5d5ec2d764c40baffae7e39dde8404513d030dc870a0145ffc540819a134245112a181752c5c20b9aa75b5895e85063200258d1c146fab38bc77e8925b8cacd40788db05d770f8efbae553e98f735c72832343ba91a89ed987b5deb17861a8be0e48a0790c982ef0dd22277dc0d3c6b8404a672fdf5673cf1fa1a6105c98cf3f8042f1cf27df55373a0e49167f4a1544e24cb51a5b1df2e7dac26f5347bbb179e570a5b653f4d3dfe1ac916bbaaae7bc6e416b4185bd1950f811f05a02d3c2eb1eed40cbea47bf56f89154182a5b3056ca0944517653edf6f395ca2c21a47558acdb744b6f063a63f3a9bf66e5691fb3213d4d313fe1f7d5a45176435b54d3fd56c00595c7c8c17ee1f3439438726def6730e4d7250686cf5c08c98bbe70f2a6a96198dc723004941bc018cf5e4e775b8e769020836854684bbdfb559fa7f07a096bb030a79d196704fd8461c6ad6a0b9f6a1717a60e3949a6c55f191a497fd892196d5e9beeb731416badd3cdbdc4c3af014492d1439b3aaa37c6d336d12737bf30001fb389c8942cdf2b7c0cf139bb639a8e97ce204035fad875859e611ff2d7d537d7e3d945469d001874389b07e09783e3f53346e022c4fa159c400ae1aadc16d024a725748c7f950a95c3472e508fdad564dba84db5490d3a6c99888765efb5c77ce6e4258d814f7637bbe76f21608b78f67d7015401f64963d358c2069a7f123e3b6a1ab87119e1bec53c550d9d20617b3f744c4adf799b09052ccbc2e12556fd151a8a9a71d7ec26c4d357c3bdd606ed554e3e9a72848c7a853e8c9a9be06d85536dc69d601f9389c3cb65243319c68a82100049d62a45d9c7414603bb5261cf28f176a83775b8c9a55045a9cd1b32e3960a7cad3fb89a99d4a08c359a73ec886586084a4988674da7183c11ed6b56b883bd21e28fc4370e981e96c24397abbf6a2c4330c1fa827aa359e9ed0e7d0cde5fb49c6ba269bd7a61b6b94e034c7b3378840672c2c62a898718d9f0ac1efe004ed2fdb54016797b0765614bf50193304ebda197066f2629521be4cf799057c70bdb1d82b35093c1d6eb95eaf37e24a85fffca9e4c93fcefaebec968ecdd4a46e0c85c2ebe4324d0225eff43eb271ac8c9a0db9c081ec3285a99c33a319666fc2d43bc97df802de88d080541658464af76475407e31b573d2054ff048ab06848917ff281fa85bd53491755e9a035c94288f458a95092d03ced19f07e8b4b18163c67af5610d2480f15b92fcbd6a4c5cc2260d2633015d84a10a4dd0415c5a361a3a8825edfa684edde00e5c62ba2fe74dd4c254dbe7ecda3dfe722741a7bee8880225ce88544a93cd3355e59f76bcbe6d618c9e09b1f8d6956310d17b001c582976d4d43ca7a266300cfbcfa6eb4d7393aa9a1023525624b631f437ea26f2383bda4674a2b7b65c91bb276afbfa00784b29f0be2ebcb791ffad08159cccd08b141103b55a3b36b97d05f49785f3a0497e39b74dda9e8b830b58e8285c4893984f7d3ec6f67c7235eb83d62a9127d79f4dc7ba7992027f7a640433540d5e37d840a2d409c28c5867763ecce93b31c557a8d2aa874a028eb3d7c9e4b72dbe1e31600e1bedaa95becc5df0ba1d325c769e87fc5ab5268a0f89e9b148453946bcce258e7db5ac3a8e2ba81a07cef50496d2dd363f25e7d03a8ecf209b20e38220a911787ebe169aecdddfdbfd848d13474d37e3c977be438e318ad09d5990123328ad5b5ceca5d362b685d1e12a39bd418f770969b00701b1361be072a54d43dec3530dcdf9101aeb29ec456d14bbe03554d8a7bc3406e8cf7dba04b13c810f9480abc302ece3d2b76ca788c8fe4009c5b66e67d859705bb4cc16a79ebca52de67a65b8e5b2e16dfeb0374fb18824dfcd4a328ade4c3f3634fe9af16047fbee2bc7b88979131749602305c52315222b020807227df9948c606cf097b62c17b891b3ad4c83f5a54a4f9feab16f03d9d9f53f41aac4484fbd53a0227233e1dfab8a7588307cdb51ec5a08103da32533f09797fe564aa5cadc0172e2a184c0abf16d848222ad5b12d9f7269dc2dd7d23fac3419f3d078ef78899f843002717a87fddab35ab67300a806306a9614de1c01b939e8ec10d2f4251e02a49a68383f43e8136d0e60086101fdae748599a759085736a562aa80556d60123ec675bcb90be2a9e90f7fecf948cc740b90365a86503af04d3f9f9f3b214f55727904b838ef950cc7bf9b05e3099f4f3fcbcbe5c238bbbae95438d243bba3292b11811b7276ee6a0a36ad936c75396e2fce4047da0dac49cae07905f5c66603fc0c5fd31afa9b0978ba9066736c0c61122bb46c231c9b98ed67b032efb4d37713de0026c9f26319c291f4b79e4b23306b57ed4ac81fa822f2c2622e75f3d13649add80b1f47e46f3684f3d1934421505e2bdd4d628b8e4621e594c56d119ea0ab03c48f4820ae0d3f85af1cc5f17cda23de2ebb79b40caa358a48024d69a386db6e00791922b9995542f1cf7241301c9099f4af4c0f3728b50e8de6009b31e2b24f0e31601fdb89b86b72fa62731e77d0d0031d3ea99af3f9892bb92b0653d371ea072870222e74b1dedd23d2e2a40221a506226e17f15938a85c2cf470cb86240f68dc2614ce23be0734747e0df6e32fe2f28d3f7f3502ff159fe08883415ff5891765e053e2569dd29d7cbeb5c4027e6a8530251ca61626f8668d0c41701f18c7cd026d9f5b784e741d54b6a48c3bbde8c90e7dbb41550d761087a819f1c8f3a01a7a84dd786ea926a5f441bb995d79cd692e97174d750aecb8a6e4875c793b73f3d2830d5530e3148c39e4409adcbdf01b9b14abc42e0ba96ece7692b794cef25340ebd005bbeae078931af874de308a8c76938e59397cc47c5a2930c35fce7409df6871c3c3580180dbb903a9dda0404e2a1512ffc9dce3f9eae3e9c73e3e6ecc740ce3f0f1fcb1ab6c6f0ea4c99482f2ec45e664ae247ac84503a37f3f2769e2510966571d81e78a303bac414ea54de1ac1a015723e575a71ba0dc29a1f502d4f499772d2f3326f239c796ecbf36dc8d132ae06e050b0cc689c20de867e2834adc3e664266b24a6ea0db0f5b4ac6e8e33ca7d3414bfedde4a5c3a8538afc0ca3ac78ca029d8d5536f2a81a45e215b714dfad816bb666f9bd3a4f230520434403460e437f2d8bb2303edd65bad5f1b061404ce8a8a7c4687fae7797b882b98be9eae96f10b3a10f32d898ae797235c89fa3633acb5fbf18131d2ff39bf487f21de3858d21d40aec6a9baf4db819ee5354705fef62788ca47185102d1b6d618fea2378be9d4cd1d1e8055200e7feab65b86b7fff2c126482352bb02431a0049634f737d6522fa986d0e52394b947f08acef3f5c439ff9bdc3c3c518b12426fa61bf4cb8ce7dcd11eae47f3dd066badd2f2e19833aa75b3c2c3c250ec825f5714acedb31abe3067536f2a7b931e4759e34f77261246333e3d2694da6c540c2eaeff317805fba03787491e84542b513963132748067a1541eef2f29bb5618f1c4e821a2ae04ca95cde702e8625e5aeb7b1c7260782144325d84b4ffe73c23f0970357f1e643e40c467d617b1e23353ad49d18d5034ca58bf3f0bfbcef96f60579276721cb74094130239ad750ff670751efb8c9854ae09e3f34db29d5df6838b7d3ee26f82b69e49436846eb98bfa278c23bd6457a8a15cae5598072a3343ba717e9accad45b125e0d30f868f6c84373e20b8a5ca122c766f8e45b2057230416105147f00915ddcc22b0eaf3a6e5c668a2f1ce904737151c255a22e83e116612056d9d9202a2bd9702","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
