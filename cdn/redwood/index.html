<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b96d213835ee33e0d863e86edb341b384ee7fa6241c781fa776eabdfd6c4288621144b1b2a8dc5581d58152c71b4519d1b22ee0a66f42752e5ba01f690af6c18838775834994314e6d781877c4f6ed7479face7b0d083f26e97d0f2ee27b60ca199a2e2283d68fd84d098041c4ce2bae0249d8a925a616053415ebb2b20121736597a2d65caee9588f157f6df232b3d022c0906ea02d9d4035825b171d2be226a54d8ebda463af3fcfec277b49faf1bcb2545d50c061482196bb1ee379c45ce1c06e44d7b56abba4fc480a61a4c3d635199c3a0d3049d2c51e8770a7d917d111e8ace83f26feb1b74dad304ac05f0352be3f681324c7b78073e955be2b0382f8220b79895759190fc2c9a0f0c7d9e6e7803f94bae075d599ae238218617a50f75001bfbc25701ae91414feac26480d935760037934797fdc5a4831c5e0cfff63ea0f6021f7be7bc908294ebf29a98e85fc4bcf5991d1f8a61545404740be0a7a5c630e3152da766dd5fa45ca8395a30466b7839f2f6e141dd35d5b5b63d216d33f0258bfdf00a62fec9d713cd8a93fcd9de40087f45dc05ce8b73a5100eaa6df6f4bde397b89e2a5421f81f88fd55e4042ac95e6fa2dc6bbafdbf249966c7ca4697b1248298928cc546f852b7fd5e7223d14626025a4d398942196e690a737920bf1bda5a7edb259ef7c5447df3fc0587d2c3ec0260242947bafe90e64ee7e48a2bb76acdffa8363f035a040b546e8c50853cb279d7c03139a5b46156a9654299c1c944ab1fb39c6e826725a1d3f8f1e2e1932cae6b1d62e88c2d6add775d1f0f322a65b6359b85956e992af2bc873c58eaa9705502082b1833503cbba98c5faf6ede5610984d7a29a1947f05b9e5e501d5ec5bf7125bd0299b7ad2a97fe260761c99c2ccea8c1d54a93bec0a69ccf3bf124a65f747bd68b0127ad8091fe6002a93a813f7ca49db06a432255910de5ba4aa57871aee098da6a5b14db4ba64850f6bd4b4a8073943d618462beafcf0b324f10500502bf3d777c746984e781727e511faa4075f15cdfe1677ee63e22444d8ea8b193709408b2080804b730430ee5c007d3998ffeee87d502069445ac80c8fdee52aecb0be6ad53886acedb86756ce1230b9a9ea041d0327176489f5dd5af7acf07385d0e83ed53c9af5af23b39ae49ce822fad8c0a75ef2cc101140f07c0319238e3ee6101aa19b4564520e35a1a4367dbd997d25a970dc98d1d4691bdb8d0764d4a5385e01bd3345708f335d8b4fa59f68a44157493f40a063dff58dbf7b14135016f96cde1bf8414adaed30328f66e01e9fd2667c6fdf9b4c83768fd6a616264e81b52ab378433223f9067c737c902f81e3380c2d234139b3573a57e220500502f0a5eeaf570808ef5d1930dd70a048b747792ece1a798fb9bd755a2760f01a861c2570f90c06e5a46afe342d3e48441026c8b294910b61edfcb8d995b4fa105f2c8217626964c8fea6811792dddcd9697ba3165b8032b136dcb49e98bc9cc07a9dba3231671bf3eac5011a881af34f325cd3e5309514627351333d87cdbec10141becfc3cb3bd899b33723d0ac629e03eb4607bfaee0b46e5d3248005243549e9fbb690047d37962a5331d2c8d9b116a7b311d0301b5b514acd16dec1fad78e1eb6f4a20e4e8b866e5294f5350531675a4149a1702b75837f5c938c40cb6498e70ddbf05e405e2786ea4b5a4defbf82736aebbe19eed23273c8b7992c85ed3260528d1502afce17fb294d12dc239415ecb5ed7619df6222fe6e110b5d1bc8e86b1d46df6e51181f72f492f79caf59f8e138bc3b0d51c2c2865296af774d2a89b0bdcfdb3f9abbd4307dfbccc6bbb70338708524007b8305ef99c8f10220fbc7cdb2eec3ca1cfa1cbb7fb0487e8151a41b329c08b9c87770f6b37ca6392dd427c222857fda771b87b6260d0311d0b6758c6be770717b712e4231b7c002ed4b7aac8dc85bbe0b6c49f051bc7a45d0e9339988db6ba8f4b4ad8eabcf159388ec38558b9aadea0642674fa3293c4c22cc6716df3834b500c9e0625b81324bb90546eb68c921aa0a0a43c330607aee01233ee822798f7f0204635f9b615a4742b1df0e07609997ee9b37431434fdeb826d8f63b152bc58aa86cc1db2eaeb20c7c009fb1d4ab6b135b329811867b60599d955fd0d68e4742a55dfcb1eb933388f879d0f599c06bc94e542201d6c87314e61295de7506e3bf99fcc33e05673cc9059c8e2974d3e60b0edaa37457580dbf2e53eb0ca1c6cb20989323d263b33c82868fcd0d6dedb4ceb55c0361cdd93693dca3f487da7990fab64f3faf29421372019939c9bdc925d9ca2d2c5a8d07ad8e72dcd4879f79bfcaf30f07fa34177295f0dd9510ffa3c918d81bd3b8e8119d30be47cbe6c9981c11af5aa154b1939c363ebbf75347a46fe1f6cefc9e00b0366addde97a735cb2e01f55b6ae708493a0293350dd82b6cba81614da0cb9cc7c030427299de9cb96fa37eb964ae9e6204ae18414fa88b163fc690da894bc9fa10a3c9b1f7062e015585099d3879d1a8deb8ba7a08f108dcbfba63462fa2eea845740921f8ddca5831a53a53b71fc713832be4c8749dcb3bf44c1766efa1524a2238622b0c1232694b56d281b6939d74c2db61932fb684a0140e2508a9e918e1f7513bb0ed5540a5151ab66811d930acd9aa2969d1eb2857f5f8a935c39f18d0ab71553400b68a3ad897d1560e01983164c9adcef3767e0ce388ba8232718934f93c4c3e53202f330dd25decc9dae3bfede81e86adff3de0052ebd7fedaab99e2ad12b7beff058c16b9d3b6b142973a378b585cf5be7528311e1837a93f90c9c087747e5bca13faa04b9e12547359331f5e1b55bb12c5cd6524367e30b0823d77ef2fda8286325d3f22e00f3ae150f3d08cae676306f0680d16506bd96e2c0a22fc072a998df5ea2f4f68aa349938e0c5be53e42a90d8f475c4034ce433dd70c166810b00e2b8bf17ebc0bb232aaf290df7cdd076a0275cf3a9d88d7fdcbf230abce680d4d8d02cf9eed7363eb5e872e80dae2c08fff113b7628bbe0772c8ad89b605e562704218486d048f2a3fee15650c66ca6c0ef80dfa9ec6b98329d3f78b6a4650effac605cc227697d6140d7658e8e4dcdda2685faf6fd80b40e4b04cf6c8399051ecbd90c4c9f9656a8d7de5a2d49f07d66fec0f368dc05a3d3bb6a72036df3f7b2821c16b00dae2d47512b82f849cc75fb7a1839ace4620ff6b8511baa07a2f3293c0e9127316e06afe95a3f7ed451b116955575f8e641bd4a005794e8d46be7bffb514ac672bd07acd82f989c2326082393ca1d0f49a65a2cd01af606699c2d6905c1a5ea72c36bd71454b8f27909f44dc9ce54dee61c89be4ff77110ddd48130e6cf443ab32f2cf434b4f041f4214b58a7f17bfd85f9717e3a7dba92626c22b9dc545c07ab8aff75d49d77cd523f73034b5b42604c7bc9a418e2e2e7160a8454ea9ca4d736674b1bcd53f87ffad5a788b1967da00f205f3e0a628c89ff7c1d4e07e305a722ae1e5a6f322e4279cb57f1c2c2c5d602e786360316dc2f91c4329788c11e78c44f67daf9004745dc3fa9f94498f2c49a2229726945bbf006a90a29eeb7f6294c68eb5b9701900bc349bb39c4e17e12457bc34197fc8fb8e118b0b01c11b29e6efe5499984fddd2a69ba9bc6facedc808584f8565339b1db33036bae4fbfe3e9854776f0b4b758bf0dc39e2ad866e5181fb7263210540630f914586fe234dee2e61ce972a500ee244ba21b5ba0b1521bd96fa8c758c3f2bcb1258183bd607d54d24e3272343d307800ef3affc536dab092e3699ff06064dae55fa3e16960ce2d61662e09c0049d8774522d80aecf1ee4d434ff8b8a700988a4b975e60ac47718eaf6ea6856ad2a18aef5c0f28c5f924e70f454940b85c6314f1fbd9a3394659e96397d6d4a91bd1393b9bfe5c09fcbb6d51cc84900e9aa654efd71a5dffce2d2e55e5866395c04e07b607b55eed6bbec28ade89b3cb1d6f08e3c64944df7dbacfec5c5c9f73227f2d61df376bbd6703edf9470d2655e12cfb5bc973576f689d6c98caec9fe469cc03fe58a753cb14f3e97c3ecdb3f9bb0b4943f9a7676d93d763796de7e091430ab1c728307648e22d85a87aee1fb97e30d5682023abfa06980b975c3d40493083bc17e3161cd4af3f5d55bbb1638aea8e69f6eee434d5e480a430d3114b524dd727671cf64530ee7e00f2934b185d55b8d512dda25e357f64baeb7baecada612c09c01980a0c4e1712489fb644e8646d92401349326f91faafa0de7a26f6cac81d44ad3adce80ae9ae0a93a577b7c7b44ca4d847c98c3de187757c8ad42aa86e706d46201d8234433bd47d1f2d98c45155ec53476d525d4f52ad69c5871320a9336dae3ca2f58d271dfd358700f1840fcb90416ef2de740c0af3f460fbf581f85f1e5f46df3d287ebee825ed50405c2ed319b00a5dac4a9628ad2033e36bfa112ce40f3dc4108d54dfdbed5568b42a239e6de09ac610fc6ac19f1d0e7dbd8de286b2f714e2b0553af68f80f6b67da9d80f8b8c05246b985632be3041e6145e21946d2d6c9b96a434abb790b59f5ea14d4185719672c30e262620b831be8990ca5b6740db056b3b6d166e4869ea67666e0822767cce0d5d658b46795f993b4bba9787293d3812c674f6ae3a17762caee982ed758c4853bf4f8c4b8eb4c6d2bd6bbffda0b0cb7d9575baefdcb653b224e6166b6f5b034161aeaa88d9064236a7feab5f50e71f272f049436f362c5292156dedf06914a783543af5e5ab5d139dc5a1e651f7c6e74efff1956a704e80d7dfb39d22652fc124eabc111de74b3118a7d2b2484db26bd74239b59a20f24645491dc7aff1a1761357e11e9b029c34b3daea11074e08fb98bc5057c3b4a08a481ece4ac2969ede36cc10bd5da07ecd11a5c9e433ea60f9fb4b76fa6b373328e259724eaa922502af3f181a94bf81b1655e492433d5cf3996f994ab31fe1ea43faa44668ee9cb96600acda25b0f87d2de83a589ad70f87b4589fa5dad933cb7cc720c1ba99515900f3bc5e41e1184cf81550b56563017f5447a01a9b1bb816ea9d5cf99270a0cf8f822324b1bf2a6c012551914c3d8a821ca92dbd13c9d48acba7d089e51502ca756e461203abe524390f645e53e73b772ef27b1e4819bb8c13105dbe35bc145ef52f70b7d1ae2bb6d5e00db3154ac98d02dc65b7ee05dccd08cc7afc6774d0916fa44f43e82e3d37cbb418b9d9b252a3e954b9a3df162cd3a6d4fc72963475a4254785d3bfdba7f71045b679a03addaa8ae9908a8cf30b416700c542b9c981d0c290c1f9ce7af7723b0f3627725c53bc3bab1059dbd2735c83686cd03814b5626686bbaa56de69fd2985869dfb5bcb6cd5879b1c9202e99b89e1f25c7844ff1948e3699b7391b79a7265c2ec6726667aa45f1f636c8a2cb3ca6aa3fcb20ffa412ed78bb1e85cc2972554b0879c401bcc88a5c1fb411f342dc0daa3303e953c4a28f75bbc63838353fb25b3a0e254ce35d78ae5841d5f03bac2a3518174700bb88a95b2dc60423706ebb11901aaebb543d1651787bd2c444d1c1e2b80fd040231f405496516aaf8b6f8b2e798324584c315598af5892aa6a81066dc75ac564ac773aa19023db98542fad711fb26bda0cf3fc8642ac9289144e54ef756a413f5eb0ded1dcd08c31c665b18cdf4166a6b79e4565be6a82767f9eb949ddb4f5bc3ff7bc064be2e36458c87cc21fc952462b8c727cc260f061bb5c6216512d3200ea6d4430b71e08d3eb4c2470b15b4d37e2ae10503dd1d60bb353a13e1ec1f915d57a845daca07a37f16e41dd8ef537d0397af8d161385685a3bd413b22c9206dbff43d237ec2cb7e2db5d0ec86dc8c7d3cba864916ceebb3f68cfee0d43398d5d5ee2565ffe70a2b44bf38b725bd93fa1ff8436466233afca60eced6ce58ef6ee815afb254c5f97cc546470a5c1a111d4e3e4fbfbcd58fca8c2ecaa56808e2d63389179136c4263e26cf1c2b2b476ccecb1164199a88e7b05406b4981a91ffde82a0de3838f5cae3de45527f003b2a93c4cfb6ab39b49369365b47450ea204462402d63f9f60084d190465fce7179d53c85b878ddf5d0caf909fe2302f5903760a160d7f8f95410a9182afa46cec847e8f60085b10e2c2327702bae03e461346107cd590389f320e420720c97580f80fa6b4a27252afff74e6a5e740f40b12cb7b4686fd8378fe20fa3071dcfbe3d0361343bfcea66180ba05b8328cb75bb7f127d660ccde24da9a1b0f326079caadf6d58951208129c3eb5280168b485ea486fb980c043c8c8c91c5749bfa4c46684bf09d897333ebc2cec2050e0af038a2cd32c296e09e262211447be09cb28aeaea6c909f3b526dcba8dd2706485daeb3833776bf69d7dc25adc6cb2fbc7b967bcfc92f45eb2b88b9bb48a32d993fddab2cddbec18eea35c465bbef484aeb4e2bc7e3214884ad01e713d5a665b3ba447716719a9d4d24e86c330c62350c5296ac950602644117f880af272042ab20dc1e32f36d21150ac2027ab849432f56764b796e2064d003c16df03aa3552886c66b904befac6d5023a5a216f3d40169f84fee72582c514edf0417541e837130f8ec5f57cf5b079ab685c0d32b4202b81b1a8392b1613b8b600a70461bbac794c71d84cf9d046434d6e54a896d7ea57d70937912a9ddf134ddb3adaf0f4376db187d1e0f51bb68405cac0426daef371f102e83d5cdafb49ec59b4fce2ef1648bf4b2c4534db947b8afe4bf63fa68ab9d6306b5cee95c62b871acc749dea6aec329215717bf3ebc272e0179b7336a4edef3eea342e7b19b745efdf4184eb55aeeec412aec6c04174580af0f1c5e359bea876b25b5812d3a605d200bc2c9f6b49b53ac257cabecfb8ce689bfd0fe532ea76d862e2e68b26578372fbf450fb01539c83602b66b9c09bc0e554293c57420ee58a88314e9bbfc15b61a7967ed427978d09e72e68ba2921ab66997273b527f5753309e668fc3064352524f617ec13e01d1a9204dd1e477a84ec2c2d0ba8414cc65ea55fdc507ce0df48e584d42a668167a63807ecfbac1ff74c0215afbce4fe9304d907522729f4103b6997def893bdb8c4f7619d529f77ecb762e246a4eca65af887d3d589f24380521b02724f3fce52491b105698a7c092412ffec0c1bf6b854f66ec7ee63b238a0501e6b72f079b64a0f77e1873a02e1aa0450ad0a245b2675e583ebd7335042ebad55015a5869ee8744af4869cdd7b207ee82cda5646135394c9445b19d7353a21ef017cedc25c2f642b5d2ca958808bad703db460d44fcbcaf8930e541e3cb3a7d9bde708e1da0af2727c884c8295d19386f77563ecbd5c9c8021a2f7e6b4f055a0becf7ef4901c279ccb663f2fa727100b54bee68e34c820f0f80143210d153c2a15fe2d991d660af9fa5937254d3df6a1ee7d33188f16336e1e2b12f18268a2956f96d1a1027df864ba6dbec42de3b4687daa3a51dff5f1750b172cd3f5e23edf6a52cf897b8c7a3cb1f9a4ac4e7a86b3857d662470eee058bf5c0da3e151bf66bd634b2c9be6477963c3844d9e064aa7c1ee53e7151983b39cf348d02cdb68443a3c09db0dc5a4982f6904d8b46f1e4c9a3db6ae85a0d11dd447618f39aaaeacf6157885cba5e1738da814aeb8eda663603d372c7019b18d433664baa832fa17718089425b4a65cdf837c50a1f007cbbd05c7bc12c84c2995bad1ee5da73a5423c18bf326bdd6949499f5850c439ba37681c527ee3305f0a135f40933aeebfa30a0019ba8c8ff051bb773cb3eb0b9c446635798d35bd4d6b2663fc328c9340b6af20074e23b31900aa063ceed06d877e3ad6665f1bcf9d02139c0d1d77b384365b72d3369e3137b683324b502c3c3c3be155fe1963ecabd2d32c888973a43bdf8bf3811c02056e6b9544f6c11a7703cbcbd237275083a131626cb87dcafb6d26ee2302094a0110128210b91651ab4d257ec9b25c845d807039011c3a48dcd77c3b7176cad7d76371a50c2cd9295fb9240d9c739262f569743c784797c65e6a52389c1af7173cf6eb43212497d556853421f98de3bd8444c6b4cb6596c018081571f1ec66db5654181a1da99d566454fff428ab7f617792056779737d4a66020ec874637d1e20383a3d4913e1dafce2ac26bbd2c22df719ba576bbc0244a6bcf35bc412a3c730b22a765770b5183422e5de7b69733e07763fd032754b05b0a2ef2fd707cc341fb20b8d36dc8416db6d6a9839a7769aad7d8acde1d183b53aa936fdba345a342ef781f95f748835da93283a749243477da6714c10eb62bc7a74236ce92801f15fc6cd5d99c426db37a2bb3d75c1e74b93f6ef58e82e5e14f42f106f2c37de3f6f9032b84aa8b2f1c9de68888016674dc64c05d14dfee2ae644f5211c97a615e75a13000ed4d02c948b3d4103b361d10063cb2b98194e908575dd2ce66291e132390cc903e7d273212658524c5101e837eb277fcd23fded6eeb6c8d1138e0a84bb32719900d860b62d5cfcdbe76d37b1fdc52d686a300f6fa7a2db0fff78b4e9a10a6dffb462a478af957195efb0c38f1a881b2f82cd4b28c1969402f1d9108bf5f5e25b75c43ece08067cf7c2f439c3fd8905036503b55edc8b7df6c78ec7bbe1aca5bc17b5f0e7f8f936f421efb51e37eb7057e3e25c87f41d8a0357d2514ab48078ccbe705f5eedb7b3a7cd4fd4f2312f177240aa5f4523ee8c302ef4fd249952143e82d543a6ec6f4a6900f75df56bfcde1cd627706a7d562f286cdf8b1385b3b75d8b248e9e8ac4cb89326f14a24252bb139dc28894a0a45c0028d8dc7760fce02d2b5b35c0eb9fe23abe24bf26b16f666abfe184dc87b904074695b23517ae7ef765b410bb1513c0697bf4ca9cdfe4a148b4e90a842a829a5b99b25208fe47e34997388a3c72f44b6107e723a68b43ccd74166390b4a71866ec9690123013be6b02b5d93ef29e792df51bfaf1d8a74c6575f6aeb9bb133c4d2abd30a2bedaaa7ac1c5a94a2a6b2839ee4d32bc8c81d7b6f889ac61e8be14c8b57b8f3224e7814dbcd4dcbb762fba031925fc03fb6f941e3f3e8732ce5a42075306853ec68787025e436569dcdf4c6c5c473fcbbd7aa4ffabe3b76343d011a35950dc0366fb79ecdf7dfd940c5b2691691146086b6d0bd06c03e33f30322548dfbc5fe5c48c4cd5e36297bd8d5085f1bde5e490a89d69de071d706334d6555cfffad39a5e317f93f132373f58b64dec1adc814fdaab7b29500f89b8314c3039440a0a2d4f1cfbd8d5f5826bcfef8ccdf45167922d0623c8e99d86aecf1d3b8b9c6c0f0ec297d2d074e14854c1a9317c5bb783966b6b2fd2b39b1bf6206f0731b3775659606a54c89ca0633dffadb386306ffbe663145140d217f209865f643f760cf845cf3bf7207b8e51f2c2f890ea9e6e3cde0a51b33692b74c2f1c0b87e9250973700f203530be2d0137ac1827409027dbe37e01541a3d10878936ad12a17d17eadb5eb9e55bbcd4e9403e3e51871d2182c323425d961d0a99c5f41140ee5447753cbc5f360d4ec8142c3def6ba8e07b40cd64d45e20f626e7d0c2ab09ad429203b897df3b0fb4271cabe9ec86978262cb9e6292133e368054048f4c5c3b36682486c189ef56c5300bb295d29cb8f0dec59bff0c7dd55daf0f3556d9a3bd54577ee06cd5124c7bf84eeccfc59b8fc63ca2c182563911352a4f8664629509f957d74cdf7df920ca0b370ba19b5c2da1164804960b0ce7ffd4e95476d83b6fc77564b48e8679de6db7e5b07b47938e3a6b509e6eea17419990abf7d7f2e3c990e5c9bae187841094cec3b0661de6e432699d7d87784ff1f3738c384c62690384c423a09113cabba7ef890ef3b8578e61ea9d2a8e96166ba2b9a0b1dcbe92f52d1186191305efac3778b2fba525411486ce601b7c19304be8c95705f0a80cb666cc35abeb62f88aa4aaafad097458e0bcee981871326666dbeb15fd3453b4bb302d3683864e76136cf2a01d5b2e8af5cde8f05ee513d7dbb27c3c8c808514bc36f53058875f348bdbe7eab63ec2117bef801b7dc741b1008e06d41006a2cc1719a446007b6b6e3353a0f621d3ff9de938708382bff23a1edb0fb5a6aebc953723d5e872e30a454e12ef27059dbfbd22cc9f5d242bf0097dd158d0d3e5fe6f1de70e8bee094b7088f9aee15b5764f351ee206293ad89c579ce3793635f8bcbcb80cf8f04da02646898d4fc49dc6f14bb02874110f79be5151bf4f705389171f390b4421984a61276318708621504a7f9d8c8f7f86ab3ce15b35d169155e37c5d3d1aed5b5ec779409f7a4bb3ae40b2634617ec889c7878a46886aa5756430ac048a26887e13eaac318f96c2dfc1d3ee7cb85d6842446e41e6860cb9562f713eb7ed971d3f19da9170d42a78840eeb4abab41e6bfa1db74ceb50245526c3c3bbc44de3cc45644a4e45591c7ee18090b9f2c6207c71f4839bbf8b8acb9815ba4d110d5b42d35c2a8101acb9e45fc9bb1391ebf5683ed35a3cabd114df0319ad238284d4fb42159a5689fbb1be7062658bcb440ecd01a85b7263a7929d33f0655e7479edfee3360a57347696bc817ceb273ff4d3dc02693c2ee2fb7870d5c594967b836493121e6fc42057ea25f46bf8de9affc1a30cfddf0c48e752781d0f43214a2dc35bf493e94dde6dc22ef2d964d38a3bd5b73d50248d545ad3bd6118919fb9b904b3611d82d4882ef183d40c7c023abc7a39af7cb0b91e7d1e65c78dbef97954593f107d36eea2a76388d0dee9fa2b2d76ee6ecd40f264d9fe97639d1773bee1e514362d747b6d89247ac6c38abfcb7774f5a57446010aea093952a2c894add32301dc526697690ab9dd2f54b335bcedb6b3972cb5b36d0f26b309e38d646484f2135ac3440577a29bfb5c668d66059195a781e0bea7f92c394ce45220693fdc534347137477af3fefacd5194fe698ee176ee2a096e0146585c5d774b0b97a2af4d286fa4a0be2ef22e78c71eb8a9d0cdb7223e1547f25283f5d3b6332a398a71a9b474cff8e5d33a37444fb8c9b1eb915b7fe28e3981e0d253cebab043f4000dd1bf598265d7c49f9d7301601378fff0a7ce9d2f27b8cfdc6f06454d09b06ec9dd08b616c945b79e0ea0edaec4362925c255b55ec656839ab2b52b41601f628c4558319f65a979ce668f0fa7e3d62f84778cd8d8961d66054a3db610ebac14fb99e112f8feda0bb8a034968e7dcaf4fc82277a5e11c6c1ee43370290b4a8449dedce01729b8749daa85842cc48106c384bb9b416f6f402df9e9b57acf9769bdc3e3264160ae3bae6cc2e12e930e13dae4f0f429d53a77a038d05a43577cabc595dca8512b8dab8d9955b396231634fc8ceb618a6e08a4ec3f0e34a0900549d6cc314ae389f529685da41357e390e61104c443fc5bba7b70f633c6463b3baf312fcd4c7f2f05390e7d5480b3d8737d60b8c909adeab68888d6717fa64814cb6790d32d1233593b181304e2902b8f8fa371ba8675c33f8482b223a05d9deb3a7a4cac853a16a5750b5bf1791670cd69edeaf4ff29a90191827ac1d9b570bcc6ff7ddc980935f2171e35d1221868d76c635bd5486b348d34a7ba52f9337d6e310dc9513381d649154efb88910e8f71517c233e452ccb221ea93582bd13136014fb32581bf27e35636d096015489afbea6cb651faa9595432a1a68cf67ee3fec1d2097b6d5495c2f2d6c8adceb85368daf9be24d34ad006d0a404515424edefc238c6c8447b5e58e856ae98583fbe85ac67ba2e48832eb116c3a092ea90a221be9898dd7ff2666c43aeb4e053f483071563babe5aed551d7494bb23ff2fff1ec21a446fecbfe5789807ff4d9c2ef223aef79eab5bce40b73e10828e88c8c4351737ea463af1d74aaa20c6c4e08cfdc1776fb2b988d2f709b8560948bb58be5b5b189824464c20c715075521b0a921a166834bdc57d69e9e879c9918924b9404afd26982c4d208bf150c92bfa2aca85847a5ee7c156bf188f47b85763a5caf489dd36ef3a34500eaef9e03d434eabd3f1453409f7f7be4af386c66051fb2f154db649f6cc5c552afc702e1e8ca72df46ac3980c2b91e1d9a62f9680d223120b28148f31c09f348bbfa7ca26111292a6ffab2126a7a55a257071022b6c07500b7a33377aff2c638ae841586bb48560a73a136b821f38c8b951f86cdf858f2d24e8229304737d53dec8001116f27c7538c42ffe97ab0b50a8c5683cc9b689575be8b961b97222cc3eb9e2aebfb204c2e53e9b532f016d7c270ddf486506a648e3d0c1b9b87a57dcef5246c56c7a82f5a67ba2655f0f91973a77b7207f91787aad0988ccb4836854828e385f20164aba0f8e62a42d9faf939e01d62493be7da49450b1a75493da05d6cb15efdace2adb97546e7f2af7b950e410237632a10c00242d5c7a97c9e9ff2e30c3e480556954f6c58357c928a2556702d8fcbb86ed6f012432d839e792ade2c11127d3d86da4ee08a5007aec058224dc09cce17e9af99b4e3fd30619aa1e035e530fcae05bb692b4457caf4f540fbc66afd61aece5358823e11c6897b679ab5415c5474156cc93c023d642d8498be552cea644e1f579d9ea080148e7bc8297096cd4139aea97037c8a21af024fa008c3ca50a8096a10b4def7b33784e54251e5866f13d571b1eb14a5dfb3e087c75caea086bc2a098e7c8a5584d6ff9cef82ba93648fd77fc347e135da0686aba76778136253e0cb41e1dc4764720d386b1cfc11ec3b336e93a060ade1adf7df71b940289f236513282e7fcc317b7a31b4309707daa4f49094b81fcaa9a2dd96665a99ec00510616330f6c765307b4373c1ba2caa9feeabb6005130dfb4761aca67b8bd4212eb0fbad3f087eb15c913f205659e4e21e45665de690b0d37987df7a359081c16ab707aaad76bf9785cef1c59974df9251b610e3e73d8dac6d0ab5c21b3206d981a297d36a6949c768b9859e4cb3d72b6dc492979d2092031553c00e74e857d24ba0dc19cc4f73e301530417c51cb4cbb4aadb7716417951aa57660c6e15e64d1493d061d08e6008ae2b0602fa4869eea6f297cd45c510b19cb59bfdfcf86dfd3b98539e05ede7cbe50141808c2bf3462ca7efe14185e6264a36dc72d53af6b7f1d4a854de6db8a88c32af4f52fefe3491f323c234625abf4e936cacedf5af5ea0a8b14c28d438f871b3ac589bf1640b2f468297fe3a6553ee14e8579c5849be2ccd68a311b1d9ba092cf53ee42335642908a87ac6efcd923725b7e69da4b94fbe14d6c7159dd8d06ff0d331edaae9724599a9a4e8eebd5d7075ac54b2ea3d3ab75b8408b39909d195fa36b7360aa3cb9676ac557b37e713ec2e0a235539a776b2a0e929395bb40189e7083ae3da62a547dbf71527fcee41b980266993d6ff6e72b554cb40986998cc92bb41e04b68d83d1b07c5651095ceb88cb63de8d6f070c6b3c9b835c85ec690c72851ac321d515b7e5501b718645ed1aac8dad532d6125c30c1037f6e4c007e1faeae618db17776c4a8c664d80146835b32e7b72f8372c812df745a747491c78f46e41d9a7917817b7f980d155b930d4449344c1f896d7abb90f737fb67701c40f84b026f0a8419d766b4ca16ad62f3876897067350debec8939df7ddcd36bfe68de15cc471b5aedf745c4bd4f9d03dfa436bf203d3f0d8eb5ec20fbe8bd0248670366c754365d527ba4d70c62969b7332ed2eda4c25b6f7cec48fb765e4d2cfc3869b8c0424dc6c0af51191b67485c311fd26af25e77aee86cb8eb7eb50394942d2de6681f2cab46f39667181c6694a4f7b756c62aa74bfc6e14c09687b50ce03c3d1565f3f64ffdd84ed40ce3ac1505cb567f63ef286d89770f80882cfda568079063cf7c9ebbf315af187fe760b42e587a78db4d7d19a5293750aa0e8a035111fe3922d2d86e820f986aaddf22d830ed0b3a2de7577f220a4728a4c7c2990f13bd06c2bdc338923f93ece732391f6c9ce2430d240cb2bb76b5b34b864558f8a1a62b033a5a263d3169d939f5890d5c803fc274cca4b57c3ea42c82a7f4c6991893be41d6d6a1bf1eb25a8fd44b6fdad798b2a9837ca616f450b3232bf0b8a54b49a9be0d2844a67e8e9f001eda97f532104c50d182ac73533a5c36234e5d4b4addf3752d9a72745803311e67ddcd6281710e4e9fb25e4d6b9c26e3af96e3ef5e9e7239bf7fec24346fac561bd64a1f995d4ce6e9f8ea0b9cf00662527afab5dcfb0889a128c0ac03edf979164080ed2c97d885778b0f83ed49f0bc22792d7f96205934e252f0c56be07f7051e7256a188d402680d2c4e4f5a45cf33fc62e2973a06e2198765d1e1e28335d47504e8db0cecdf9b6e4bdb354ada7a43ee5f6e2fb1a9590183e9187e301e298bf6b9209f7bf408faf0ad793322d459669c5926279f1f1e662125c98d9c2846c3ba00869812eecc3db6aa4ac99a9fb1196fa1646c4af62f85de76501364be260132cc50f8e0dd8677c6838cc05c9a705b7ef9addc4aca020a1cfd3379d6abcb0f61fb33d021c86b48f28640bac66bfa67646258a9123e8000df404131a71f93223a2e87eaafa9b0fbeb6e60d43dffe217af48e223e64377d85a870f2e9b290e6bc582b5a62d8462ee24585a86550401b7c00cade0a2cf68ebaa47bb43284a4e34bc704dea0717c33717bf68725e870b7fcaf67418e43ffe4529a8a255e9f5597104c69a17e274aafc29fc32c1a59f7731f4e81c8102c1382077cd90deda40a55c5aa92d2f796eae3727071e06c3fdf30781dc3fec782c38cfa5f472a03ab66a9fbad39b2a3c8e7d12d309c3987d9e837611f6bb3e736f4549b2d3dc1cc7664165c4b2be3f957ae1f1f7238ba33bb5a90cfb8916a93df34d528d612573717787a14d9f53ab7c3643c48f1b7de264d5af746b4af78231501f1a31a24154f1d0e7346eba687e9436792f77c46ea17a5f8b2586155d212ba3aaa15baa599ab8b3114a1bd59397f55c765ee0330ceeaf2da998f858ac1f60ee063afcf7ff3632addbdec04d15e2dfa7a8141788537f9eae3c62f33d5a47bec79a3d0acbfdd9c52a89a91646b34838463910e03a34a4dc9fca11ac18a815a6eb262c8585b115aeb11076babebeb44a4e8acc9f9f9d252366b3c2441be2b38c0b6daa26fdd22b2f990639e989d02c5121df98a5b042bbda3ee7218108687ba9e067d59a09c7cbc84186da709bf477574841b46d23aec5a3af462fed3b5172c1625987a86253dd273609e6d86273d9e2730917ccccbef2da3b76d95b80f6b96cfab663a0f8fc452d4d94cccabbdb64135c6ecb9208da2229df84bccf7d1ab4580ffafaf547f2b03ab315384caa597c5bc8e7e3f3134c1e8c26c367f22aad8b094909c28f585f7a88f0ec31971a4c8d26ce2a3d7858bad9ee8f5972363827aeff654d835be0378f59979fad8678e318fb1717191249e92bf9fe303bef98604c486a9dd5fd9960c8a3ba3cc2b209379dace49542ea9215aaa168c48081701ceda1f6d22acb6ed94e5f0c38e499431de8431aff66ce6734de14f9ca1962678bf8fec8b4bc819346de0196af56327b9731250bf7b6f91b87613e26d2544aabac4f62ef102b274dcd1277ec06ba76beed8ed452632050b2d08f18e3ff03cf397ef88cb62db90329f03c5b58cb52348269f867cafe861a822d1e289fd16caabf87db3cd0f5bb1fe03f95ce213f95aa1a96a56adbdd2cc8e0e9dee474d99e4b8d9bb15e4a122cf5e02b5fa3d799025cb636253880a40be99fae3623c70ace88de3ae824ec7830bfdf466a3672ff0b25596beb180e28c6ab6f4c11747b46b2df6a59acce067623580a35244ea6e0c23b24a2be9996bd3f178db6729ad0876a91e7ca1afd73a86653fde7b4efb945337963e05a5240f22f58c231533faba893da0f9b091417868051fdba3543adf461aad422849a6e124f46b48eef2cedb1f0de121d8b7c88d718ccf036e1a568a74900889f8457e9ea309e5bc45691fa44be9d0e1e65212b28e99314b2deebd989ba28b887c072968d439fd924f3c68dc36365d0b1d35bc9538433e31ccf1ef5c11874414681d06c30019866ca55b3c46cb4c8384fd0e5ef4028bd6d0af0b9d723e2d4f401a109a93d0dbec25855c83f95b054898b0bb5b2c5d256aca3010e00a030aad61091629af3af09547dce8b773c77c5981087273900afb154fd042e47f7457eea2c7f0e2b0b21a5002612ef6062b63f6465fad07048eaad0e78e9dc71ceb2dd6eac5f7f4fbc2b0c6d9e4b7033cea96d281f08b0851ba26dac29dbedc2fc638106f7dc62de92730f3d7f2120e619699fa783a30a39d59c98efeaf6bfe992fe0126552b5bf9bc88cfb8b86affa1594a2e8527573ad389fcea02f84fc67f84f3a1682bb5e0a25c43d044ebbf08b3c98f62dad70945d63b3055c0f25032d8e4d5f479c2ca583b23c2c980c4429ccc3deab71246181a2605d5ea2109f62dc67a81040a085477adf181d7920f8e9d6124cb31b5d13a5d3a8c061e29b28d53d90d83c6fbf951e564ff29b75a24e4b9ef84ed4ce6e953ed8f27ed3810d37953f399192412668bef0eb02ae05595744af45d4b4edefa5060a825c78bd0138a6f7946ee8a4a17fb7d96c8e2a4bf8cf0fafab751d9f0fbaea2b3dbca4a7aa0e30af4a7ac8334c50fc4597427cfca6356ce8b6354435ae3f14f0e4a490467488fb392842ad09851ccbde083d0bb8c5b75c166dbb2e6a9e03f2dbb540ae0f5545974293c9f081deb213deea7fb16da46850df29545aa7c312e0b3a22da45e699ed2bdc5145a360b08eb7d045459856b0d57d395ec2c0a69bc0820884d7d688c29ee23961941fd8895fb4464539bc4104efc14cdc10d3da0e5849f0e9e20cfb7400a3fbd0c8dbde01c746796b954375bbc73a37f459e47392f576af4d2f3a13ae6a28d8e673aa95ff07d3ea0cf412761925ce3ee39a0f22d58f361c7b28a356635314b9ee5d1ff30c047bb81cb81321db66feb2eb4c232d23d5fdf182bf4f7d2bafb1b11b3f1ae8a55f24ef061ae8b1aed976b674f235241448bf73da394c4e2cae6c15ce9ff7680928eed6987e8077ac57836198792ecfa651c00a26d96489567f015762c5e8bd33fb04e360624a5beb36f1d30777951c7dc7c7680723c6e2e9e859fcb418ec1ba83fa92b9fa1bc6a0719a3b0d2a46dd73758f726c86e7f00fe91d45ae0c7f6786b20f044fb3b043babf03f9e2bc133a8a3bec0157f8eaf019466b6811d085ac1d0a097fd47be988b4860f6dac2623d4e742b5514e7c59dba63483e1e926d5f7ca17b9844f3100af3dc34586adfef8cd49da9e192f95e036498c2b7be4596d2cee1e90c4abaf90f38c4bf622860dd2d0453cc6ecce970b6bd0321e2554372986ffea65a4e05765d823748b2a09e6940c0cb2e62d9121d8e8ed8081d8d6087b8174c2b04ee97374b64fb727cd5dfda28c903f0ba4e8573ef8eef6c226057f113dc5c1081a70073f3d4ce83e153dc819cbcf73eb7e8b5e55cc24a0915d42280d31d0df9a6d76d7f898adf99c810a037a27603c6534edcebcb45cd2d7d78592483a1b9f093fcbb6d88450d317496fc0291082d54f0113f463a327e34ba1ec3ed188afb49cb95a5cf927a12dae0828c2ab419095e605eeb2f51b3063d5ff6f6836051eacf1d68585ce0a0750e0a24120e4ef86bab9dd34467ec817f361d794131ead669b8d097958176989fd0fec7613e564d66f5f5ce2bc7aee27eed4d5d3061ee40a851c301c80c161d1f4b0f78a81cdb0f48a11d6edbc6784fd570f4e38f650dc881debba107a8deca5941d41fbf58287a07496f1cec5305a44bd9a9c3336ef2fa906187135d7ba5e5c1d363828aa6ba9bbc638e9a57af4df9accd6483ff209f8d06bb3f3cb042fcdaa610401089edc5bddd6c813becd479f1d08811c1fe91562f16a74af4c32b405920d6fa683be6c8f18283bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
