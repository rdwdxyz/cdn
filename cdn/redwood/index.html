<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd90ad79d35d7917a5a496c3757abbfb872e61316ca2043f3471857803ac0ca77c31930bbe559baad8764e5cf503b7f458e30a38d59a07ea149a8ccdb0950e9d9b1833bbd7148be4f4c814ed89a35401d755da3043fd4c7e17ee379e55f6e8e43cc22c72a3aad1ada4b5db5bd32d54d3151835cf4e96b93c3519d99a7b7592536a4dfb1f7f9099d07a2cbd4c2ea01ede7993a781acc5f5b182d7f75731e87340deebeae201898e9bee3cb4749f9e52d8e389955ac803e62a5236bcae4e1181df056513b50b9fa8b42b3482bc75afea70cfc08350494fd9eb19ed645bda290edd284fc4eee25a1e34ff7fc9d21848f205ef771e47761c7a8f0eaec627217ce421de0b01c4ad469f41ceb17c26690c4c8b2eb66c24708e549baf141322d7ea31c9d664131a2be4598b8cb9abdea2e6f5a02ea392fa9cb3cf564d6bff4ded2811609f48ca333cde3a9af5588e80365bc0ae0405f1614ad8e0159d41cc67f8cac13e0a8c6dd75f6475ee6390a6ae0faa29363d808b171c938b1697997beac030705cf2376aee56655aa440d098a67e9e61261f76368534f7b3164ed273f62b63abca3084b1a34c95f9bae851c0adac6ecaa4881502667135b426baeb328b796bb2fbd782a4971f2fe3193c884cfabd42d1ffb6f71045415ed76d016dc13baa106137ee4c08c1f48a1918071400e842051b707c9431c409969a1593f3536b54255bdcc0d3a67da389a23d30ef2a411d5cd37e6abdf9275f93732dc2e8725bbd9337822e99cbc29955990184482565777e32208ff2e76678fb0c390034cd6509b03ad1e9bf88bdda6a1547b088f5127e33828841e0ed0af1105396780c6bc4c4ec7b4ee2f2145b58f89b38d0cd60a0bc6d81015e6be31215af5ab131cf3012f053744243fed5d41051f487e80ce85d7e361e497712f4c0003cd7c22d80d1abe047771032e9664ac8bdbf3e3c70966a87fcdaec0a60529088f495ee1422a2a3a4a900381d37a09ce010b9e6b1d235822fb1542d98cd156bf18cf0dcf93836bf2b9f499e8580104b1afdfaa0c902eaed4249cdfd0710fae1b794afff80a9b12b3ae055075b5551aeaec66029d8f18d6aa34ffdf23aa4b4d215cb6a7490aa1401e57a9dd04b6771f30aa0ba4d5a4c57427c8a76f24c92a6b37900463c54992d2c5b8e911762983a001f5edeb79e90e0f0366bf3edabf8acd2a1269a0ab51d842039189a3875f83ba633955dfc645b23b92e1517a5d0663070840924237314a281f4b3cdfc64045f07a16a969e3b98b37c83ef089ba0fd4dccb7a89a5ee5b419ebcc7c34fd6af7bb11eb9439a16d7cdd8ce922738c34a53efbb2b488f743ce259a78af29a31b14c1d044651fa39cf7280d424a90ac6c07116c2d8d33248f1d1681723de324b008aac970f30babd63aae4340bc0737dfb756859d549dab69429e831b1f4998384adf4c5208ea3f6915e64e256c196db41c8c7520e98ca4d11a6ee516ca77784d585ab2fadebf552c8dde93ea3c41ff61fdb163edcc39581d44fc30246d2a1b58d06a8b53dbff35dfd02387b8dde130f2e9b5f93223e191cb461118b2039c35f9774ac341156f95d02d3df5b93b15491295d166c60e36bebd3d205f2b305f5c5f484f607f8ae61dcc394ed7d58950019249e39aa158f74d750eafac77abcb4a5287a16d6648210d466bc6811080b796bd4cfdd086d84d4fb170cdff229bf79f89179afc261f7803001795529350089de006e832011bfe8e6aba10e6b69b4cdf8d475fc31d71adee8dd30b861f0b328c0e0ac0ba5f83e2cb1f8607b654febee92fda990bce4f4789b26cfc35f932921a430accf08b42a9452c3a41643c4aecaf64b76ae3cc5db75a8acef074eebab22c95ff56862c8439eb0982fc4b3587f0a0619d8fe37cbca640f37f2a11f9132d234233a55caa8996e7cefa56868cdcd3a0f3fda182304a488d4ce19d54ff283b9b18df6a6d62fb566c3e95afea57daf60360212f751c49d1e2d12a7b5a971fa94a7fd89f21cd0c0d48f0a573ddc3c63dc1fe6562476d9b42efac4efd0ed6364ff4b80849862475926af9ce577583423f8af886b13a30904521bf95fbfbff50330fc017293c1b0479bb244c7f1c9a025eb5e2daf88bf0442b84cb0d9b53c8b6273cba596a2ce07eb3db7f64aeda5b853656ef7c4a804a91a7e4ce601c2ed5da2297d9ba60b1bf833c9fb041086183063ee741f5789f71118b6433df1b554119b2098dcb339ac77227ab51f1994d143c6f2004577e24c68201143c3c554d72b15682989fc16d784a3fbaf13aac4f00eaf40d77a72159ddeb5a32b126ee36d05ba05e57d6b2fb3cbf6ff253d4d8267365ff25e9dfa0ca0c846fb39800619767131feab7eea49be26aa22b4a712b706aad1ed6d9d88e2711923c2b6669434374c63c8815c61679c0d0e15cd701bf226c17769430cd1d3272d1cef752d1390c2916cda739861becf3b668b543a2492c9f0a5658684f132f1ca69acad46f08e71d47944a0ca4f27d6cc0485452a6c0b1d8543e4a03dd98a6e5d5bd8b54c3aff9a9b35062ebd1cf42ab6d627bc8aeffb5179c79e1a76f0f9b3d6a5627418a5100bfbf33c3fd32947734ef6f87b9afb8d71be9bf857e5d18a8a051e4c2369d787815540836dc9402ec9ee1f674ebbdeaf5800bac19f99d78dde2974a4a24e3720bf8a3f280f35d854a09b53195f0a2f438783bbee297f574467c352b0b7462ae7f8ebc1415a5cadd2ceb047fb259f2383e1a67f4220a2319033e3d71435f56306824470d675b5a6835ed75baf32316e9f741cb9b734ded58622cddde665f6216ee5a710cd30c579e9409b76ee8dc01c5cf888c1d3532cb4946672a5f5561b38b64dcc4809a73d53a671716f235b38d704cc26118f118387265509408c7644be8e3e4a84f6e45440b3c460dc49be5171aaafa5081b7217d522c4760beb0632cb72df9e92848b896ef0d410115c2c8cc90e99b12c3a26f999ed9dde6b508cc7a425d7c555fe7b813ae3a8ed232f1ac11a172cde4cf12b8c05a139a5e6157bc50d72bae8be0c6e688ad49e8d1d50f61040f1a44491f77b6df8ea82b23e48ba9d556e48d75049873e7de1ed16ba9d0232a613a19815c7a3bfec8ecdbdc76fcaafbaab89a0aaa2239a99556dd68f76b6864bc33a7831a682a40677a63112e90419a098e63cb4aa2d54e5b33afc064793a00dcc7623b17df356e3335d3dc761371b8f254018e0fa78ff715106f9418d439725b551f990580a73d54d4c9c1dd54c82f3c376189c2cdb42e4278d1ff6d1cea599f2f9aa5fd9fb0351d9c9a30f044fdcefa8f72082de111fb9d90d8776be567ab12a76a2a6b7b8a7e9ed55b2b9d81e61d2fd74bb268cffde9a321a4f6ab3c89b4456fc26126e09890558825d77aa162c048227042284e163260f34b652d69d4ed24ebe8c2a8ad59368592d5dac47c4e9d32b62edb7ea45d6ef9d0eefe4abeaf27549bc0dfcb55cf604dadbd38878271d9d3363cd8237a8b06bcf4b24755475e6e432930db06c341fd7763f236bda9acdf68e62c6cc4330c42983759a7c6587a7bcdde99eed913a9414d6cbccf8402c9790bdc9784676cf3d7305f1567b3d106660d6605c9a08aef4c55e09a1d2bdfb9805f61f931e6d4c3295e60bd7762e5d7b577637e7617bf03184d7cf9179c9ec002eb484a4b1862f9ab32571fa744d6ae226e814fcbe7fa32dd92d106e652b72497e1857098bc4efda5bc18bac899fc8776ad9986c7c002df10e2646889ca67bdd5bf8bee84d00a37ad00ec3723402f7bc0792b2d6eb8d47c362793b14f7e7720ce51449a5ce53646ab3f2369977bab63eec617dbc4e6e07df38c9b9c524f83b06d4725a15dd91851a83de4e5e9dfa042a10b1f90757937c3ae3d1c71bbda1951d0274d8d756ad7fbba67026e567cf7ec89b51e1cd691a73e6e6211bab3de6d49ca884d5fa5ea577287d851d6c0a1be53f4e0627b14abf0cf9399c91328c5df340ccb7fb1780b2f5f3893dd48990b17364e6f152881780b5eb70a8ba7f3da48518d5b77e4b9f862a4f4cfbd00fb834693ad7f95e2b54af49d5a8087b7ee99dfe04d01e9bd5ff6597e7318b93dd7fd2a7cffc28a5bb1def3fc893c58256ba993ab7aa4119d3b3965db0efaa81642b299843a2854298a48c166767cd4088f79778a6406c8e85606aada0c48bddeb47eaa65be4404b1e02dce4eedc65b5fcd02e0d8059df57061d690aed22edd97960d1489883b9e2d7e530b72e8f54497d79ee245d02071707b83c892f5faaf892d1d52aa6e4c87919153ed35717861ee9535482ab0d42681cbc15df285d855bc90fdea31b702a22788fdd0ad420266703ae927d6b02ba1d36e344d3bef75f5b2fa2cc8f87ea2e469de3803322dfa4109a5a20dfade4e3ba3dbde28f8bba56d00291880ad9edfbc9d97291d6c2b5b4e4ed9206bbcce7a863e5b947f041c6aa710d06690959f5f96cc52579b37685e1f52d96700d5f0fe694117679f326c9ea92f31c8c15e50318f92ada81124f17c1d2e946065cd86b39db00544815d35fc75700e2b68e46a7f7d8dba829be92ef949ed34deaeeeec2eadf4e6a5af41dc6b059d1cb96cabb54417799042394d5d9eeeb1510e96e9c9f8cf66845a74955b892ae7e56a3e0152832317736ba80adcfed7673f8b7024f008d91f4f26360320269e635bed439e68cfe17aaaa1deaba614591a461ccd3b85ed1c250cd872f0971dfda3e5e8a3fc4dbf8fa592dd16dc48870d075ad02eac490dd6b33ad63c2c68dd8d9b626ac61f56da2b5cb8cbe6271081b4ac6ad29b1ee99abf676703c73bb48d05846ef3c730f74e33e03b45adcf4a6cd40c71241f130129a6d8dc6001cc6e6015318b8b25c4c1a225b496a880565ffd526179e5a5c5c6aaaec44d839ac3004bfd81bf95a79b6323369da41879179d9a0526ad12e266007106b67a196791a7b8fff1ccec236f509b28d439fb2e9e442990bbe6c20acf48857d4fe59b62600596fa1ff0a4209463f964ab1853ccd5bc086e1219e33aa6912bf1365cde238c02d83afc844107a1761a935919ae2f2c1ad040067617d7700714f6fe7dfa94bdaeb8087d061951233d68f29511deeca0bb8f843651040047fdf556c6b6dc3f58c524d7134ab07845c42c67616679b131c3f3f5d7ae241b351245286efb44b25e86dac63a8b6dce663393b7a50780220d46d12e184c4e6d189b182973b2fe0150bb0f9b597ebf0754343fc27b6ecb0180a4e7e53deac81ed7ef1d30d9ebc580c5a45d6ebec8792e88634c57c9ab973a07f391f77e2b4e43868f6ac5b21732dbf290222fb4608407e095c8a4c7534367bc7b257d2dfcf06e289ed0f630570692889a43c6df99fa43c55752c8dd34f2e52f7088c35ae27444e3b14e6e04e8377855bc6c2169a04d3bcf8e9f833a6fb321a0ebcd4a3773ea52673fc6443105b7f9aa11d73a2f1088251e96aff9d2af908bce02f07eee9b12afa21a4b4afa5e561f7ca88bb2c2747f1f1937aabcf10e746cc467c1291651840d8f5368a388885eb4d3466a82fdbacc7ba7614d59040c853389b25a212f39604c9ac4e6657223ff0f2514e73ffac36e3e6d74edd36a32304999b177ba8f8cf39c7b9c07c7c29967521b8a1867a853253621dc0dbdbf5a90235b7855dedee77c89dfa32a7c969a5123e5f28263614cf3149c30d27a98ef7a024e90736404b32613471673f9bca7199794186f4e876ea8acbd177116fd3a47f3ce8ef266e118030cdf6fd8a587e092b50165f4974709867ea151e7dce2e2c14a6b08bf487472ec4666256a76728b68773920c8af5d6d6c3079e458446767f47972e2f709e2af41ff047c28401ed1d425ae193e88a9f6febd786cd64762a89961d89fe35efd820760d1db0b80035c24bf69c303143d36f6bf59d8c400e36fad3644e86ba44e9735c13618e98c76b0ddb59ea1372dfc8d7ed53c09fca340b0c2e3ccc8ec20fb18e2bb890a0cddb8a658bc1aa071e0c41f2f0b469168eb0b38bc8a36baa0d387c402f870db8ae08018d3c5c005f5566670d771f7a9f85d999bc9e02131d7f2ea85d243f0a9833bd2515f30dac7cd4bc6229abe41b2b120f07c5ee6dacc0625bbae6ca253082649dbd0d7be599eac382d943e5934dd072d3f4f8f6c29246db76420bd2e3432face998aca4482862ebe3d897b57e5c0d3bcbf55535e673e3cb12e8baf791dc029ed968776bc659a41b2e4e0d40fdf8a5e092ecc83d8e41dae65c6dfa8425c53a942b5dcea949ad086c424b512e86c75a2fb0124de4d6bbd588a1fa0ccf06242a52a7b12cdfccc1c5bcd79e2f7f370cb23aa6b5dea5bbd06fd6471dc7a0087c2200a2a5ad3c361d366015a04c8c742c4c6eb67c568af1e928131c861bc8775a78d3d3d8b01ca7c1cadcb8085a1beea765fcc45f4ce51103b0326e03e1d5a8e750e327028b8dff582bec4d67f47272d9fe602104b1545b6b6630a6ace20730c9d97de9dfdcd961df9c39be89d9ee0064dce29f1d7525098dec006b9abd9d5df050eb7b884fed09fce439b2cbaab633ddbd25197921c68e0fa5f6c3d23292c73c1755f05fd9ce0a56708ae3f012ec204ec341c766f4d752135f7cba1dd8b15311a3e19d7b2013f8187235a3a96ec3af2f8e2aef91b6c1b75d57c7674ffadc0a55409e04d8c2c31d7f53209966897f1a9a84383c3952de44bebfab2fba2a2749895839132c5c00eefdbafc82ff13fb13622def73ccdc4950ae36f1bbe04b937d1953faa667d5a1a9a8f790dc2111fedac885fd927b36638cdb3c18ab89a47982ea24fbe288e16fc7e711c5996044638930ec1560014e91c94206a18c272a7343a7cb3774b8be124912b6e9bf724ef8df035084510e6824f58c00cace43877a34a72f1ad551617f8a3f2a221221ff99ca7be5969dee0279981a5ee662611ac5e88c34ddba648c1aaa0196995ac4ac667e2fd341d3dec27f45f80f1650803e18b45cd4378382fbd5215e1d3edb018049d3663f5383e09142de79965349459852faa6886aa6200e48eeadb45c38d3288c642d0db7af70976521febf2a5f09ecb50b9b203eafd37cd73ca246fd0807c29f8b06de035526ad41214d4866f322ac76e2aaad64c495ded5bc6f8f7876e5d30b82d8c8f5fbff8228fbd6428b30831f404c9da380304666f35973a13e286e2815002aa38990efdc73f761aa6d9adcfc5a27ccf46dec0a92ac96334a0d3979395db01864e305c285295f13287e916e7c3e2b15ce88ea8ea5e3317a3f2505318245ab41551370bba491a611646a5ae6ddc2fcbc0870e74982d36d1e68e43005f997e2dd302f364339fc260c567d9b1a98ed54399d3f6a35816138d178bd003d08ee24ce4281e442d2b4caad6a1f0b21a0df77b81813b34a165bf2f3ba1a072174b39e4bb99984bbb84a1d3f76b2fded3d3e0bfbd42887250e6c98413258fd0ad816b5d10692a9c03bc6410e1b410565945a0be960f9601769693948bc6b51d676cda07896cb6818645a40eb287d4c22caf4b65c0da9d9d6a2d026cae8135be17b102fd37113094ae548fedb68e6eda5b517ba14f33b5b828713d3d0eaec195e553a78962dabb64f1ae1a3a2afb726a9ceb5ccc1223c541ce1ac265890adcfe3bbd3a77434fef91ef9cf64f8f37188b43954880462e4f41f52ec4f660b50367d35e95053095c79daf1106c6ac1ac43ab23f236541b5ca7dbe2b1e41b0d0769fd29e39ad033ea9355d5d014fc509fad204c64bf9f491d0f5d09d1c55e4266dbead545affd8be3e72f7159a9b18c932fcd81f8beae8757c6a7bb6e43becd38a0533c679553a72f269a0188f5bfd4365fb1b1ef9b1ab3de6af142a0d14c51982cf6121099898d4fe2c3acfeb2f1e27d543ab5db449046d81d12b13f2fac6ecff9e5077a54b1993d9a990fa75336a38f1e02079b3424856ce05b0f0bf1a5d0b219a162e41ff8eacca1974eccaf05a93cfbef22419e84df042b8ec0f6c0f7856e1a6b71b65c10a9d41a81a08fa7007317df1de6d16ecdfaa5a2acd289acff88827d621512757a7c720a5fbd7a91c235c3e273d61fff250ba3591fa6fa28a814c555aa9d85854a9f09317d9825463817cea3155f55224fe92957e8e291fdfb6ad2f67e9fb31c3dbb53d809bee20ddee67309faf367c7b6e703f458f9166d63028f878e101b6f2417eebc2dd3beea21ce4338f66d584ad48dd56631fdbe49ed19df314aed441b7ab4de89efd45458b507f5c68d685efafd19079a529e0c5b9e820b180ef66656af38511e133688fb8f89f43cedfa948bec6cdd0e9003ff46295d35a11d22e55735c9e4e466564805f200f68633f99d697a9db155244ba2bc22d52a65dc72e8b624f6a5b112fb27f43b0f84299a6d3c89d5811cb5d38eaa52e187c5bf7f8a980a6cef0e7b022a92cb46088650e5d0f4342f95e11c2fb9e607c571f3b29d45b79722dca89c49670909e0e43069aaf24993543ceed880a8b41d3541d8eb8320cc31dc216dd2cf0a4b80e8025db29d6eedc241a91d185ffe1ca3deaa7e1acf1711e7a745e222b07d686d252389e7d584995792a38358eaee0325ba7113016704a19b9641484b78ac6f95f8dc6be921979d2948520ad8ac053c96e7781af0631f60234af2e7f8d34cc87aac14d9d1ea8bed9ead3dd07f50b3cbed271b65a0ba034d6c76ee7135b6a13d37d9937ebaca08d0cb2ba04641a716d60c14af8936df605ad48785a19908fb1346c9661f981f504d9970b924791c8461ced348617265e1bb8bd8e28ca19820d704b0d7e3bae4897ee5d3b1bbd03e08ebe18b4f8242ca1e219198e08309db022377176a7d07a76ac8fd55cea92ae3babc9130ce3bc6e7ca7a0bc90516b32c69b2af7f44d68398a7bed660ef6959d0f6fbf81f2c253cfb2c04c952432512947e8170d53666af8ca93c7327aebc82cecc293238e514e10219ee76fecc998c72aa39dff9b76d2e68a2310f35c0a33a0396e8a21981cca6108d7bf182fa61949b712c89b1a921bf1003db8b0c54536d9cac6ecd07ade37d26c3b923131e6d43127498db6a2a7c0926c386f92b0930d9b753b305bbd879c4200256c094f8c7407214eb21492a3942443520611af9f5ad609873fd0af1fbdcc197fa31646b3816d89fb1822afc5d409471e6afbe23b4b169c37b339dc1f9c342c417209006f82563115260e094db5730f1354c930e87e06e19d105016d940671eaf626851af5060b40d1765f7d777a6560d28fc3157e926a8d256b428caccb73e9d7f6f86ba9caa5ea8e120c0ce924d6d6ecc970e16b4023a126923e82c60af34b2c611b1151e5b4b53a163cb1828f40c7082a62543bbe3d2db0019456942810ce9bbddbdbf844037a6cbeb1ea43ff22b6fb2b37868729a0ec80aaba98a3f816a1a2b249f9c0bb7b3ad4fe1a0a4e6e90fa957af0195f19ec324f56fff79e11928f747cd7749e288dd5d5f3c9b1dd29e8d1a5146931a6089e7fad0e35881a03209b477b4aad25d2692bdaea9fd18b549c4bc53f27e074a250d1aab6879c582d980b11c905e486b282a9ecef7d63911309da5c494ca231c5cbaabd4eb92e2f4363fd41e900cbad263cb599c7cb886effeb0c0624532cd0f9a855917c98148159072c1f8aa0b23687e6ad6280803bee67a08d89e0bb7524464b9edfe1217e4fbdd126ebc0b52b0842598422a98b02086b00e7c30acac37afa7496e5c59548bedd6a65abf2cabbe6933983c53723ebc23750a389e9dbe60cf1f2ba4883587e7e0dc723a3463cfc253f25f1330c444e9c41fdace1759d8ec36a7f72d37e4b9473e139beffca8138c3e17a356c990cfb6f1766b6e5bc7003ad94b7eef5782fe5fb5a7193c287c1b95ddf99295c050d86e0bb70ad146b4ae5f175c1f52eaff44ac71bfdf1b01f8eabaa412168ab87c2f655edb60dc45d8e452cfe9c5948d264a810796be3cb3cd267c241ebda1acd2838df8ec569de789263ed621d0a8289ac2f6a3bb2ce6cb72fa146370e7f30f69338952c0dbbae09e05efe5f965d51c367cdb194dd890e276448d68360b94a251bcb7ef34fd12b3330c95c4eca8e8148ac77285dddc2c8d24610d80e313c9198d5552c9e5c33e6620c43b6084b84b10a786ba35c4790a38e7a1ebac1069e4eeb40058cb6739b9e7514a35b41bcc9062f94304f44edbed6cbe8c757c8a4530f8316b28f5adaba47b45731dc9be60d67d5a0cd8f97df117cf527f2493bd58984620794ea513f111a979fb2309da346f757b7978d27b5d19337909cc2a12a3dfbe3f06800fae80112f621455c40d02ce9d65d5007638690309d75d9fbbca8c19476e43f86afc28b07fd0e68fa029c901d91b795f6fe8398b8501c3de91b03de1ca5e5ba8320483ef5d64dd8468959014c4b51732f6b39a62bb99f295c691ee3e449e398849ff5e02738ae8a958804dba32eb767ae0ae1a51d5db1b57b6b1fd76e4ab2de04d8f2c68c3b0757ee7dd02ac33b1af156390517950572c2bab3ac1348b13f3721306b671b05866bfe013975a5f9fa87786b7d20e97fa9484959c174f42111543b6a92b80260050e5a4c3a3bdc7a5cc323de0be4618206cd63851fc100b28dabca4f98a24d3d2c48da6bce619d4a2493553b5052591a41b31c099bf0af25526ab2020065bd193dded827474b86fff4585cd2d3e8aae9689d9ab910f5259ba30d3b2e1b9f3512b05a39b717e8cced5272935dda9e7ff1ce53d4533fabdc1db5fea666819bd831e943091d6fcfef70770d836508eca184afe6f5fb188b135727cbbbd91e8238e196d3cdc645264cf1dfbe0205ed0f0c65f29c8a16e48f6d68b85522b08f79b2711cc4d411524f522bbe993dcb857488319e4e92fd5d3863fa65a7783a8af6b8430222637af96d50ae538bb85b97f4e567caab241c9374ee909ab6f1dea23cb6e8228e9063056f56031c6dddb1ea3a54310608116729de0b7824f2660779203e7c3c2699d9a0e7f03fbb57983b47a436d31d6d2b8c834ffd1cfba4199f41af811c571a4a6e43d1685d1f9c68fa42439e8ce6da617cb26f32b934a1d1876d740c1640bdb9b996a1f3929cbebf8c40c65f6d7bc1f6be7ecd90f597a581e5350abb0fda462553d743e0c68f5198a99f6a35db5bc5c2d0d9892b4054d5025d55b0b5eacd90238d04b3a2341b7f7dbc33c85c8b0130a9b587052bd528bcbe04ad97be3a1bf9934524417349b2267bc50f7b75d8f063acbca4701664b509a4949e406067e2b55941659b7c41cd177194aac117eb361e1d823d630630b5da833a26567b1e0b34db549953c221ccea528026739919400c459affb3f72da3ebf7445773542d0dffd81d49ea156c79ce7eb167bbe6a7339514655b5463fb65dae53ead14417ed711575fa079821cfa5718ca267b88f73eb280ed44bb6398dfede492e506506a356bbbcb78a0e9a6c1d7a6cb55f4bbd73b934e65c94e8be3ff8c6ac7fbb817b6090caa7b056908e542729fa8ceaa803939fa7778888c9a51ccfe285fddbfefca3da31cb284f1f4ef95969a76eaa628fca9d895c98d042ff2829242dcd37589374c903641a634cb686e6116f9dc7413d3c622250ebb5cb673233a1c15b0c74cfebb8caa3c6238e72255bca6c7496f59c8cd361980d9bd7be6a84df5b224f7e1f269da7d60e989cc365751260e052888c85c3585b3976f782add50c16380dcc12dd0d8663736aa66d67062aa08b3cd5fa0a0941ca70570e49e0afadfb0198a02b0621b74d16a0d6423dc4cafe8fb4c86e2e16cc4056ba06f4df7ee93f4bb2d82c7bc5ad6057358538152e34914644484b2cf788c7ca126aebe206c775a2a808901a19eaad6faf7ec66837651f302eb8963ff749493691874bc92d035a45db25969f023a717369f59fb11ebb2e3e5d0b499d6532164d1f341eed945a370050ef59688682289515fcc5730cbea37607cd3550da0ace874ab08b5948a1724d077442b7432a5d108829a30117dcb80e5bf2fd287c33be8accd1080be1a8d0853a783269d77e62c6f673b068ea30e1c464a43723cfd83f9e678cdae5a3c90bc80b94b302f824baeca06cddb53badc6ec5ab07a097347026274175bb828058ac554f65fcc11001230c4068fe57c7ccd9c763698f0341e7e3496d8ed8df12d2049f929f084ae86ab803f1a158c9f8572bb3fff11ae60120d439a626ced4bbd1966e19886488c13cb26654493af6788f5993f31aa33a550953313bcaa48cec64aa1995182ba4e450ce54238015378b8e4b48af25e325a371f2791836a6a1bba7469b11b7c0d1a9a8066d93f716bf6ae68be90d230fb538ebb5606a5de15579e20a04c9ddce88fe6f3ba17563a3b7e690662fee0093b1967c3c6aed289734e8e483fc4cd36ea68eff904bd8ef1661348028dac1d6e73fa99cbc422a8d36b934b0bd9fa22bed307ed2b8a80db56aabee760032d9c56ec0079991f17ef2d20c3a5a822ee71319063db8102c556ba81a49da1bd79954f7aa916f8ba6f7c07e26e930d735ca932b7bffd3f5690923b6e0c71e0378047567a21343a7369653a2d2ddde224ee876ddbf71e11d94a6208f216d07044c555c0dccae987dc8127fc0d786313b036da8139dca8d9ed932fc91d4cf2ad38db8d51c13742b965657b8e320bec468f6b78e735d537a97b8b3b36ab2fd2652937fa66baaeaec21b3f7141c7c45d911d6d8017afd844e1ec8593684ce3eaff27d1010e88aeb33212865925e0ba178e80c968ca22ce8d74cf2b4b5cd8475ff7623033791c40dc4a7a8b650b571e57ed1814857e3b80847c479a97c6a0b413ad58a5354ad0325b8b87d71dfd24c4d998b942df7add1f4bc5266db1a8935afeeb320b16cfb22d6db0a45bcb70bb47a898819ba94191af8eb41aff8bec423fc3b0437083f9986683ef9bad004d3c902d1049f379c7ef1682f0d9289c01825a5f333c4da85a5a0e8c11eb741b3dd9276467afb07b264546846b340c923d4baf63ffdadb76add23f70a6dd3feab646cb240f2a43a356e6af781c9ea4ab54eac43106428506cc00230d163c9dba96b9854682f424bce5fe25c6f9c2f03e9e8e7df74e99eedb257fa47a0a952bb3805bfcc912f63c7c04818ad34036c07804edc9545eedae25258d84b3be11e8c520100fa21667fb08ac670c2bd8bbf51ab355a931e1729e86c39fb85dd3be00eedd9d2c21eb079d26e086c119abf63ea4dfb7a7388fa2306fec781ad317461088fc473e26dd2433f02095575201cef91697ac154714d78f37a987c1d5d02a4bddef99e332cba0db36394432e5a1ddc8610725ebde0e36300bff3a1e11f6460f3d9b694ca557c88bad61e1137a7d0f70dd9394467a75ecb53aaa2218c1ed63431b8fbf9a803cabefc504d079ece6d41cf1eb73b013da52fc99d039befecfb7ce239356f2d519ecc41740ce0bad3979e69c651d540fa0558f090e52948ae1c6fd6ff2d60b3d2ee11e741ebb557ab7d219314c9d9bcdd0fc78e394f7da45825fe6453e5b5280c8504fda899578c19c223c1174f163d98d589bb354c7ddd20818996dd85d3fe71054b7cd22e270ae5fd7919f37e2486ace98c394da3db60e41c50c513b6c8d249bc3d8074bf52749680d4a2c07ae5a858cb15e46658f1653e7b80c82503372326c51fb96a3b96c43574a5197cd16f7c801835d4b712d46bf02b627ed3605656daba8653f75f95bb93d9e53a9685d967b3a9d1a2853a164d3126a2c014b60d02319fb926f56839fb597e15712a992d2bd95c9fd2a0d552c194e6bf4de32388e8019314ffd82c622550f7edc5d249bcc2a2826323f8a89983d6d0930cbc7fbd7d27580f73e2b559be3370e8936c48e67492fb0a313ac33db3558bdd4980833b3f386cc74d973dcafd36ae398d7eb1d35348c7c1835d59b62037e3ec346c93798d4d4a7621a13f8b9734475eab574a62f529b01b942fee1c6752a975a45046e43cc9af1799ed6389fe59b55f04954022ebd364f5c27004615baa6ff205938f9991909548c5dee9fda732876dacdba362b0774b3c313bca772e321b87974bb76c34c721ae5628802fd3f25b2806be587795ca8c589fe67f1426e20ff1bea1472be12b0abd3cb764e26888da0cab3467f6cbde4c2b383cef3a33b67405cd7a16fc9accfd09772acf4469b3596fc040d607427771c95245f2e230a871f5311324c6e3eb43cb42a8863afc729f503d401043620db843ba234fabbe6012573f0bae8888ef889429bef48f0aabf16615bbfdc29991d6138ad1e7550e65c911e12ef48ad5e8ef30e7ed1c7c8ceda0fe26b7a3d98bda80d206b0046c76d26e79e5443bd2840a03f17aacc13db197a5c58d7892e249bcbe321cbb9b1d77c3007f68c5b662676974d6ba686fb4eb0bcb38b9ffe3507a2cb6ec326b76574018d0cadbe102831bbffe20b00f784c9d3a909144bdbd10df97aab6ba59331169e250da1f42e2e15240a804f204badc3b9df76a662f33116d549096b085e508b4048738397924492dd98ddf56a3a9af7499cbe878469adcad5f5e149e43acff42b9fbb12d7c04731c815344b4e96a76dd8d8c78aba75beaf23c549f4eb1bb7a3c67b5ac585772e5f5f3daa0e366f7f38b9796d6a8cd14bb8c0aff59d8366f5e4667122d3aea2981643509aea03daeea80fed28f519cf0ce359b0f77f1880c6894205ac1531483314d4ab3f13d8b85e567e3e436fdd8d1027d1eff3adc3cd9094f5bea3bf03726f77e3739eb046c9f7666a7ab31f4381262d720fbbcdb59e2126bdca49eaa816da16851c0ddf9afae924897e2700612413662972623c7be2f4118f34daaffc27c10533ae488f9bd95fb80d9bd83798d49efbaa4cbb48ee4a7653a53113d83f34f7ee0748383a6c813c25da84faac775f11035e1340d331b8a5a716c3b7deb781da65680de519d758c798ee324fd3b471661b319ac7dd15a246662c56a607e0076e0f1329a9f68b9d90a592fe322c9456194cac24925158668672315091f1d5876fed2b74fe7e2d79da6e43f1dba997540483cc27d70effbe4d3cea48033b588297dae3b80ca080eab1a6ba6932f37f238501d120b465e7cc510b0692228186afa88a0bc6c534b297bf83281a8b9dc2f4db2b9870756c2b9afbc10dcf7d85937505c338f4f3b86b8ecb5e43bfdb0ffd2c823e9299f61991ac5d36f454c34b5e8480491af7245a2de65238fae4503768dd82f7f2e19a89377725db8d8e0ab7ac3cbcd6683cd760b96c8ca003a1b03d9e09cb4033997637a7b43d92b96dce54d5bb26a55ad862382165b9e6c122643551b73426c943e371ded1bd5db6840d6b55d190b0015e0464e4b20d78923ae4474040faf550e8b0ea6625c1609463177955aeca8c545d778bd0e9d6d0bbe7e32eafe0a362d922459ff7592ccc74a4b00019bee669087c4cca7077c8818dd9f96f998d9e9c43eaab8f61e30a89b0adb6489990fc9454b57fd60b6c7dd00eda3325fd5bc3a54f58c31bea8b4ffbe28c55991dc0ba6a10afd9e19d3be0442c7edde0c1951bface37c1183e01e5a6bc87893ee55f1d6b6e9010d74d6a90898310f2c6f78e396bbf4e7f6736b192f66c6fcda54880a91d8b2f82f1fcf72a8d99ed420922281ca9657e70c245a2fe082824efb459c147d782f3192b97ee6bf5a27025d476ab05e5a5156b127b26f02a624629d29c76a2e89279fabb0b2e0f4324b27f5683cce66a41ce9995cbf527439e74741c9c5f68cf295a274c4816b8c3d7ba5eb9b8e76908fe2b77afd31206f5c1fb05eda6b8fa08524854e7533d25bfe0b20195b740ee1c94f71a5273a66116583bdbb2457294a4f5891137844e98312e4c000963dd1b37715e3a245482bee9795486dce2e087e055633318260937c62a38baf9359f158c4d1fa615810fbb4954736aa037ed26745d7ca05017b6b5890c1047699c0a2daf09b57e710416b5a9deed920a3993cdb321dc060a3dec7706c887c70d9cdc15ff9f2ddabf4dda0a40beb9fe6d2be80454232f73af7b733430032eaa0c295e7c7cb8d8115d93816ff84a4f22a78ef033d704bee855bea93ba55630c3712f6f68b2346a9fc066036d9e8d47266573ea3688cd473ef988084714a6c1bfc3170c9d7d91a4adb410018114173163dfa94c99dff5dcb0fb73bd2481deb58c8c40d74b99d5cc61f140c2ef829e061a50ba419c17a31757de1f5bc05ffb0593260add0418ca2b7ac8cb112cedad05913a4033e89b7f22725b3fa4d7123c339c00c941774a27af11dec72165063c9b5120ba36da586e58329d3d530d9b0632e131958df02d980daddbed0d71a40abb742dcf487c30ceb85c76e5c5f207c4a7adef27270636fa05564689f409740e6aa6076667e7f2228b75706a637b38499279cc5ccaa941c6225fb0bad8c8afce600c9890d2813b09ccc4d4fe7e28a94b66f2215d8ad0d5e5e27e8aad27ef2adc9d5c88b803bebfe9e687ae412b1d60cbacebc4eb00c1c2bab10a0f7066dbae932c35e31c26007c97afe111cae76831ea83aacacd71b42846c8be94aef10af8b73f974c140874c5f84d2ca568d7c559dd123ed3cd5caccab6ebadd73ff18ab752a42b8bb27c5b8c09c23f6d1d626e161fc646726c61746f9f001500a2c42c6678f220adf75fc19f11be8d48e0f5d58fb3adf90998907c41dc93541373c48e8be66d6fc4dcc0d95da383cef0f08b28189a9526f4ebd453d76e2dd908d0b4df7f46a1afd4f9da695e2313db32bac21c4eebb86f2cf0957c87abeb155bc320477540fc61cfc0f3dbac3c6f9f02e0c592557f256265448b8e3c3ab7666a25b184432df3ea7f833705c8a8a6befb6abf109657a826822ff797f7e72fd0dc63967ce60012e23518a6c446d1803d1dd0412fadf2551d495c377757021e6d33f3fd5685130fb59e57d54edd6c2f883e02e233e4c1d90279ad24b4bd853bf80e6c0ce451d8c825cf268ceb2e891f03f47c78a67f0450f4bd7f2e8b1d42e9502ffb7e65b0c089ee14d2c26016c5ecbe58fea35b2a16a5d8a380d6b9cbb17f8f23588289873b222e7591429b02e5e6034a689b4a13519396a0ff130a27e10df7e6e60d15c4911dcd1733072eb20448420aa443ad676fa4aba45ebe39ffbd13846b46cfaf2e2ee7850821ba79509f81fd4a76aed4aa8e00f820040d2f966d038737f24d6e2f58842d66e79897e7fa19e96ebb6f331601dfcc8b64f94aacd1e44f88d68316a340ba407389f12ec43e5819fb8aebaa3de6bd096f29678a58bf4aacf7ad7f1e1240a81fe1f68d17c79647f3087b8a6ac456d484390717058d50d73cda46c4e2a1e4ebd23605031590936fc9303a639b566d95a03a3c49f90a52bf0b72838ab10c5800bb6a5bb9407f12580676c0fd4bb87f866ef62b7feba940268b2c04f54b3d1e86d4295c137672c37f670b773ef4f4b9047a4c2acc166fe43c7078e23940633844f7c51c11a5748b08391599310bcb8caa6eabdc205e61cb6b04dd7936367ba23cb78195b0d6072a79e69783664f976e62e2c4db11eb4df63ae2feceea94b9b7ea918f8dc2b985276cd9368943d6cbef7fdb906476af900e079f34cfd7cb771c0e112e91d3c9211a0e466af9c8e6006e9be46d43a7a1b1058005b4aca41fbaa7e36afb7a5d390637824af4b912d914ca559dd9e8f2c0252a35dd9ae3e40525fcf548110f3c2171d15bb0c2ec068253e1427fca45486dafc85aa1f887d2f8dcd3521bd88a9ce84ee00e85b4e07cf39ba0819a9d3523014f0ae9f7369fd29769d0809f2cf1ab6f4064d7edd8e077620528146fa32f87f63e46c5ce15f2ffdba308f66f854491a62fc66131b072c153b88589f6321dafed6957cb54ae879c1c0e050239794445b6fb113b5c223f0f05ceca962517daab15a7a352ca437ae2e29a85fdc6162dfcf0f45e18cb56afb866c233d5f78d4274db97830c4493ab580f22a3b7dc69c08c1d9afd33cdbd012f2878881ed874b02cba7de72a7a3f171d885f87a4e0c467ad5cebd92f4a207dac13ce8f0bea5eef8b3266755c06fe30c7c7588628817ae196","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
