<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9aae830144cd591326d35a7e661536525ae479808ee0c0b160007eaf770dbb4bb82cb93dcd007059e05fc10c24c77ef6fb82ecc65956d9a8d0e04675ba4b729109db4b618d87326dbd70c8a7ff3b599c0e542429dc7dc853fd5c11c376d1d6e3db83644cc58cc2b79104b3824977ece318d5456b82a5159193984c871ed9bc0a807e7c59ff915789c24f1ac6a90d4bc0760455ad09f479541b538b996b21f1b52a055e79b7b9fb3cc09c53b2f731884fe69989272508cdc2b8ae5442c82fed7f79e6e0ab092976ff48c0156f6326bf290af8d51ef9e7bc8d82ad7f77b8f3ac554081bdc01e1219362dca4266fdbb1a2e75f8a2c09c41376e7ac654f5dfb6b541069297281fa7ffbe1246c735b09670cf02d4ede7075ea7f9fe3446b3a9b7cf937cfdfb8f2ed54c41bc36e3556d27e20d88b725a38960a77544eb730c2beafbf22a4e120b1848d0cdd430d07615761b945d62fef19b03295ee9ef8a1360761fb26ed037434349efaaff0d063116e9f57add907c6001768950258e610a23d3f220a247e1b2f6079918c6bad274666b2c5fc3cc4b079176b8a8215c8cc5d18046df4dfa1e844b629022c26d1e7bd5782d6db04c4389a95cd4f6a9a5ceccb2d2d17aa58bf1174e4dc46359db0cd4092553e39ddbcc944aa9c69f320b81a5dabfc132bcbdbeefd49260c2514209ead4b775bc7f6775b1b5c51285b6419653b91b13e726c7ebe4eff14135b6bf9eaf9ef2f27071837d541d54f109c8e042b5af243079486f6d00c4541f873fb5d0fda37e80c32f3b045d295ac8ee1dd57d2963263e41c29cb237b97eb9d6f64c320b4e0777340dc6f7af9b7aed6a92a2ed377aca39dbedcca7e0e8cbb2ba6435c5ba5ff7578846b0c9d258355e15fd0c04645ac8de634dbe4af4faf437ea6005bed5ea5d5a4b96203880909efb1de321a400056b475f66b0799ccaed406c2380edf6a75489808914f734d459d3761f14a91800e6af65f5f43207033a7a351dd6d4600ef9c414c061813408599a7fe49c00c902a5e3582e050a949acece47d8bb3fc93bf4fd6e67ab797761aa137b618596c6be901da239c75a8dc18f21577ff2c9f6de4d1eba176985c76e67ee97202e58b05eb67ceda26b2ee1b8d5f0e0afae63381ad547fb50ee385069406c3a6fa984eeb2e7d1bd92ea687e57b336350c29cd150419da83b49c2a5aa2515e632da9094850a7f6f85b28c059b5657bc5619f9c4caca125a1b9315794b9e34a10bed7397fcea3dba9dd7ebf585678825c883b035d2455c1d77d3d5feb8c60d35c3c9c5f1b04d1752a0b5967710210641c04c824312c21610ff0fbb7c456568776b0093c09999212a900b8ea572db9dd9a8eeb94f25aa1220c63e17f1695316df7db7eae92b32f82e8e4b36c7deadb07328b646fc1a1f114e3ea3f9afbb43e58c79bf1c85b537872982a15a3a10a9fd4f304a70d6ab7b33ef8c930939d2ceee3787a88fae66fcb357d13feccf35c08da2ca819eaba86583ecd8fa3cd54fb02ca311e57e8cd893c22a7fa3d2c272cf0286224f00c8d5e3cf381dc0da090652ae21e1c7b68ec096338c6a8dc5a64b658e5ca08afd6a7b817f3372c10d25e52a395bd6688df5ede97e85721922a3ff6056182f1e0abfddc1f59f633db98897c44d5105609bab4ad3ee42968e06839275326130608be11799eac3e52c6cda1aa6897b2ea3ca2231d46409bdf278a0dfedf32519a54654f7eaaac5e17416043262bf8887a5421410dfe3e6f3d65ff772c0493c836c2fb47572b2b3b8df9eeffd9526e37e78b218dce6c82347603f277d6e86338fdfc0cf9ccf6d70696064978ae4e9f38298f8c0a493766b5f62a561dac83df31ba4c33f888af8755fee4feb7c19a59f4347cce6f92198d54f1ecf91acc12271fdf2b10fda05610d1b1541747f0849213c5562a857cd2c12182ab4a7f284942455f50043dc27a6c079a77b6a30da2c4620f07f666d0c097fbdfd8707c408319a3ef799f9ec69dc06e8737994cfa48ba1c5cd53d0350119651a229b550a4bc30675cc6397791631ab8f6c95b61f56f0e3d5d7f5fd254ed5c5f55b193cb1df3ee89a67857bbbb94fd1c3d3f6121a3b2a77ca426a268b8abf423373c2ced72583388d537063b79800c6269e426adf279e61fe856c3d4cf3b28dbf9136577bbfddb349e74c690cf3ae7f9ec1ddcb18de7f5e034d3d58dbc35b94a8de20761cc70f272314ce4bf99cc7f06b9100db6de8a690ea0764ff20252112112e3f9c4a9fc7f44b06152c48c17386318d0def918f388836e9973cc3126ee24d98911cb1d463b08311b2f4ba3d4a520821ea0a81324aad8586bfc1fdb36e1a019b5b275c04736e57af5a42c505386159db8525918f1a0b2e868352a9e591d9e8479dee0d7b98056144584572cba6101f1184511368eb8d019e41609b241f398bd969451f250c56c7bc44b6af34a6abe02feda13e1c6bc207303e81bb8282e221d1fd376bd715f3dc56099665362abdb3ae9b9e0ef097b040e3583c05594abde64521657baa8507e5393fd038097c1f4294a68e6ee4bd2a2882ecdb68dbf6bc5be8a0eb231b9b6e3af0b902aae650d88b894dfe59be322818c91ab2655336b6b9af11f71fd1e99977d3bb09aa15b14c0fa9f3e4ef4274fef264111e2fa2ec68db613693fe63eee53e6841a42965919b2c846780b84bbdf37039e49955ecf3f7d9bd05dc10bd12a7e95aa329750c2ee3bbc94d2dda281fae1330c13a25a5a3bf1cbc80d4db77593bc63fa233918716b61c494c86d92ff303b79ee355c3f1bca4e912a768dbb253fff55628a9d72b1eaaa89cf17a4feb3d35a4f46bb87a60888a4b42c3f8c32b6a91447306c224c4cd960f6d8b6ca20c6cb6af2e8cbdfeb18dd5b459498cd9f21ad35c6ed481a30fa147985d5c47b3e76b52730a195e1012ff9c8167bce222e646b13a3d9a63e8d62ae8a8623b41f7371385724db7428c879ffab9762ed46bfb14ae0a1f464a6e037843f108b2238ba3c1ffee77c3f26e3db849d55f8e9723017b90c4fdcaea07381f4fb8689889e034c00675aa6b11762cce89480ca2561e3f788d6907d2ffe554eb857642fbd1d462b1d0c789d34d25e9eae72f4df18f403005c19e5b610167891ed751f29eb2d910cfea9b31ed54f5c0bad619e46dc356a88b7fc384981fb592b5201d8a3ee876493b2a2542d9ebfe4d8fc442db1a82d9aef05cfa65ecaf2ef6bc5482adf9d140af91f9863b8063b9b12361980076c42227d696df5c9199adbdac01584338f034504c61a29bf6aa4882bc3f363d15c7afa79f3e17678af869f11a5c840f9d4fb737e4792868a74e3be33ef8cb56681fdc7135ed5b57969849bae725cb993e141ca52335325a5a9bca313d72ad2c3a2bd0cf713ce975d4fe76c13e48959211c7c4b4df091c7ac09a505c5bbcd1af1ba09aeba87b89ba7c2046f6c2997b79960c667cf1c05f442ec11d47ddf8dea04ffea1f2fcf9f91a11003885d4aea1ee974be20a04ba10bbef76c6fe42253e7cc23a91681cf3a810277251ea110f1d2fac6bb3b6f5667155f62e0bf26dc68a5c228640caa7ab2f791d0e236ba92c39fde50a223d97290312d858bc78d9163b86f3eea341aab8aebea4a6285f8568f729d62ea2cbc61288dd33295c3add4c4ac21ca0392f5d785332ef819461e28782efcc84d3afac6c9282578f7d005782f4513b897b3fa47303e6abd4a0c9b4c221061040feddf26c233132bb504723d9e8c448f2e744c55c1e8b4954ce5ee08a6e8784010bd0955da6b8cff86cbbbc6b93deacf8cf229313001e0553eb24374c860e087e0ad71661325829e5abf433737a0611a4dc3a63b9789b480d8d002744ca01382112212e33cc2987932153ca96e9ed7877efb5a75f5106ab568d1609f27ede3df5b02920b1267f7c3c27ccb72a17d6a79a99beabb9422d09fbc9b396d93506fc1856726ded1faea7fe4f9ef260c5e8d42a0e73f335bca4e36bb57f609c6aa69b9191f9aeee25480643b6e5706d8d00af28217756bc0749232d3550ccf45c20ba518c2e5d155028032fc519481a246b76ac55af3618ecb71731efcaf9a5adfd44a8d724a2cfbfba6e825061cc6ccb1258ecb138ce59e51f228b3db2e5c39604a6c7e194ed60cdad2df6dae95c346454ac1fc12bf8aa4649397a4964c45d257642cf69ed9dfae07d1d5ca157bae53aa2bddd218c4f4a0fc24d51fec66cb093165044970b9dbc06a565477940b05361494950946bb7e3276530ac1c604c7ca9b0a0fe6e5fadd3f5ba64bf8bf972dd8993960f3a2fa9e6520792024ae2a0da08c1513832e39a3b85ab795706f60f3d9ff6fd0b48ee06655a882017e5f128add23a2176ba43eaff707d34d377e9c9366279b9e33ea54f1039cd76acce20cde135d8277d1a8643ea8036a0ea0343678292ecb006390ce3a228866222e64e78c81de15b52ed1e43aab783b143e91884e52abf71a7496c2bad851a4f1a9cb532e1063f39c688338d237fa7935e3e675a685991fa239f3a1219bfee4efebd732d07b9ca925192c8a9d8e4f0554e8b6e1677d3e7c185178590fad7bf631d2abe7a6627efff65c41778afc3ead47183b069be5cdcdc628fcbce09b0867a4281993091ba325a4b05d9df2b9beffb6cea32ae6968039cf3263e7539ad766240c09dc352e8802435224800ddbf524f95b77c76ac010e29578c5e3f443388f26899e045ffb064bacacf918a824e1458f57a727784c2c93a91fe51a546974c6754f9a1b04d1d5bd5a552a8a94447e4454069b8b7a8c90a2176f007945c6caa18aaf15167e1b31a6f15968449d87e09265a2ac961ff8b7684981eda8e2654a8812a153231133042d34223fc12273f8aa3733adb09cdf13fb1293f87bcad3c028474cd303f10c654e41e978715050a53f57758c4c92bd2fa41178fe686410f91125040aa870fc2f8728f38f88c0e46bdc4d3317378978546b5d9fd1e76630499eda360271d63dfdce53d304bf35e11c95784a3c33c334ecdd5cfd83df99842d3aeea81ed6c8cee736e9e903061a5658e86884d4940f8dde16b8e5425c028faadf2b225307165719069bcb4b0596ffc21644cf29611c340b3a3edb2dbc3bc70b21e671a7f731cea5e24cc2c6c72e27c416e18a4345161c1f5ccb6791cdc16d3844fb9ac422f2d42ddb5927c07eb932d0b07ab4f2aeac330feb1807f80af8e159ee4c0eacea83f3bbe105fa3022ca421d9d0968d8302e529af0bb41ec07adef45f3a8fad83ac494c9b889e12fe25e3e644c95a7b3fc1c8887d7440fa55a8385aa2a70dee20d32336eec4f3fc7bb6b0f0a9df506547b51797b1d421d110a1dd90920b0d5a6f422e74108d4c2f3bad20c7c9c8fec734e320d79689d6475a86903d4ffca9bc88b461fa8f01fd0f19852c4cf4a41bb2646505f10c7cba7d420dd203a0a22f278f4dc50c0976794e6454bc712735eb7d4964c9892da6eb616dad54c6b2dcf5aaaa111c53482c0790e0d9ce207eefe28052cc1e675e8e1649828c50fde8410d46f7f1d89a9fc354a71010ec388bcf5a62866a6b9d05361fe79692267614016d82d48f15db1bd5c73651542c133e566e7771bc50ca36a906465d7f5174ec4053b2e90cbe2877772bf56168284fbc2246f01d334ca82d58321753b2dfd7e949d629a47b9345a7e8595c5c888f1d5d377c451944679c799a5dd7f9a0470973079e43dd3a547dc9fca551c3808c61f8636aa3652a8bb9374410e89d75178f35b195d7f61decc8afa42cbb6424310ddbd30d9a1fc8d5a95ea80593c3354165d7e5106f8c9971d0c2da3763e053d2c6009c7abb63d87a3f0b6ee92850d947498ff8a628f5e533979acfc12c0c48dec61f71de3e0ffa5c3e1469a588329e149bed61acee14edeb32682d6aa05f3432a0229bab7ddfa4989448f85b9fbc14cb55262629dc9d9b3ae9f5454fd0f6d83701b84317aa769ca9b6e4c921a3e97ff31a6ea2acee61ce06e93259430835879491bfb6f29f8ae42300784063f3281267b35766b15264b06b656fa93667fe1c5872700c3f36433bb76a4d64a292e60ccc763daa53f571d40d862f79d4b04564edbccec4bfb432a2ba90b4ad25e548f138f63f292691a1707671fed33e2811496af9b16a4557af599667fdda63ec56e72112799a18170c89742db2ba03d020000767b5d3826bc9adfccfbb7e3e5ef944b004402f766e41e4a8d68b22ff49b714d5cfbb8b7111ded9ea62bc39b6083db3ffa157dbd176f7fbebab49a21b4930119185717da97c181c1171ec0bfd5b731935826e9a2b571d8c5f94a0b77863bab462176c5d0c5383d5ffb341fca1a18c96f459dff8a1cebf434d6941c56cb42afb2aa2999752526a91467db4a762ddd8dc3f1429e80347550937fee3b06ce21b2df7a16206be19b6104bfdb419e7c15ff58187977e117401d84fa3a4eee5cad78638de2df0c34d9d6e001cb0663dd8a70a73dcd566e97b60eb22af6f8e5907e402e31ba760c955f0c7b4c12acd36d6eaa86db85cf87b9fd4f709ca3f2fe008100460c1974f5ace11478313287919f632dfa863ba2f11e6bedab5592c1737308ce86c429428856d80ac4529134854fcc96082f8d0e4fe8b1eba5816b15f2aa323271178d48cd783a49a391c3198306962e88dd56e16cf2beb6fc90c4ae312280a5792079ffe2fe31cc4e3ee5081a21bcfa39cc321bcc73f81933e31e2f999dd316d9e5b173d405950a822809cc623734843b6d73d03e016d7dde393f936e0d0f732acabec6780dabf3e05b0d93eedb2a343e2e13b50ce3d066424889f3faf68df229da995840aad0b825803bde6a56f723b800176f433bf1e20ffabb67a8377561621d16b08ea7bd17ca396649c03497398d22b7b14959317b6c18ca5b72ab418056ff20f021060ae28352343123e5228e8075a2aa15ed23c601e1551addbf83f380cb2cb788c019113f0542f683cc95870f484cde4cdd5e4cd0bd9e6a08bb72aa020fbe95df164e4d1892c638717fd927bd828cc2827d67bef1b4085b73ce4d4ca8cd9937bc2bb767a9adafefa82be6d2e516592b43ad31eb81e30f486e2ab1d139ad9498129bcbcca650e75bdfaff33ba7a0095a4963b9f88bcb6642c8dfe30258942bc0d9556ba9820caea7bb3b3f777207fde2036cc14cb83f1f64a1db8fc54e6f60f8c13719cd137af02c63f5262ae9ad7f4e3b8689c5aae71afdfb45ba2a28786a7cf4d8c89279cfa3bceb8e22326ab22b34d0f86ebe8be8069df79731953205adcdfaf674dd03773b3cfeb630cc942d25d3e96945470d505bbf1a3802131fcd36cf78e03fa48dfd4fc6e21943c392691b3aa4401030c6380583f87c15f322c94e202cc41d75c5830639e6cafcddda068cda3958bf50bfea490f45192127dcaec8805d62bf328cd26c1260f70523d677dce9278bd77d525d7191bba1a6f25b132b980dcd03a4c038a146e9fdd3b2bca29ddcc11f27e446330a651f7925d6de857c92e479b3f1e01d6fdc034f08f4168435e0aebb331b856907bbaf81a523fa90d528999ce496d2a5c6e635a7a82979039c6ab7137687658ff15a3463bc2e87d9e3a0e23f9a4df1235f9e22a327a0e462fc692057c71e2b2e5b1950afff7663f9cf2f9c6a034af71c9c277c222979b0e0c7957065e60cbf7dd2b4d9abaf13d31c74260f587c5c9a1335cbd443afc8ac2254579315a54f20c223e23bbda2e74a1bf41e05cbd55c82222595f0626e0dbf85ce0a8593854086b990b61fc2dda6481f5ab4b8430a413a2f0bf748c2ef24ec666400d9d558bd95a6caa291cae8a59030a5c4886b0b4f7b38a18fd5b640415a520751c123547a382e1828e2210de0650442a6b1adb06614c9d05adc1c88666cf41d210a93fc102fe8ab6dcfa8f596ea9e0289b4d0eaef200d9416eb422e1c2a1c41e3bafba6087e6e9f44e774f3873eef332c8579b9b47ca31d1555a362c5f2aa83047ebb34104ce4ec63242099647b1492b40250db536066592a2ff3cb6688a1531d8ad6ccd41a0ad4a2aa2472b08b43dda0e1dea1b8fcb3a46a78ea79c28086bc15abcd2a3d955e82098665b6c711a8c0359697f270a71df9aa37f9e6404715fc8d8e41c0364a6f9309c2a0af8e7c0e715d839f58764f2091648ae4d2bb5b146c59573b9c9a79b77f747208182b61cb01935f978523037b2a40f980f4e26176309bd0430447be4740f530f5926a9a074165b607de6252754f730f8458caae3b2834381049d3a9c3f7f23795b371d054511f2898b5823d76e85eb8b1aa674e9dbe5f31ba1316a651d0b18f673891504a87bcc4ca875969790aa96a19ad3e0b2068a577d72a9746a3a11c15c86eaa5a463c7c22ca12cdea0341829c6a7a2ac8e30c13e361f4eb097e71faf074af3cea7cdaa8d3ae6092f04c5729f5965e4154e32a7819ca236ea1dc2b43d743f0f887520a9517fe5cf0a0633d2216ce2198b9a194552f04d2d4be7e9f8ec8876685821a8f3491c5ab11290d70f35f135dbc6d9673d28d40e0cd1a4462460b6970ec04ea2af741ce2c50c60ff2906586648c18db7ee083f72b05be18969945c550537d3cc318ee77ade91458f2540192285f2ee269bc73223e45ec5d25d308c95a20d21f7089483ef20f8ef92e09a4b36e5a3caf1579f85d7dfefde90a0c09c571fffc9b8d5db1157fa86e1838b6c5987de3da9f9fcf96e606e9edf4abaa338a09cdabc0d755de492636804cd7e339401e38e6fa3956de3773d83e75f6bb9a4422b188d423f4c58fe6d8fa4b0f34d2080f2f2efbf5b528a91c68f87afbb7030849c16c81935fd11293e4efa49c8ba02c467ff5ddc3f5155f45c827e17e24abd6360c811f3cd7081faadc3e7b980ac24f4ce93ca63f06b22079f83b60c046a97e1861425b320bb8ab3ee8e2f5470eb5a03afb1195d0f1ea879e473757365e888b2c13f3f114c3b5fe37246bc7155c8a127319c203dd9b7d81054332fd02d0cbbcbc48002624bf9c5d042ce8335d0922cec249bfc0aaba5ea9066b3b14345152ffb6fe6226349c493bb48acb3c39381bb43040314fc2b0075fd66ee760129f3e05cf642838ce36af1747c7273928170ff0983d23aeb7aced5b0bbcc8e661d6c69a6963bb56e83a348e5824f459939389578820d29e74bbe3b242299a81e620a19386cc931b7ac583574a8db9b9977880fc5fa0ab8383993424f12b7d094597b506c87e7950688cea24dc1c03850f1cfc76f04d8ba1bdc18a05ae12884b65d5b032c6f1e99fae81f9b1b1915b31e8832bb7b256a090b940d8fe2dcea491e3f7bd5d4dd3b366e5bed11b047382185c3d23bd0dc41b9d3ae0cf156c7f4b9320a93c8e7833f8a62a72faf15b01af6c8287170e3b6b6e99501cd6a589e4531a5a81bb60fe62d24ea2564e4b62741e4db3eff4f9e553a0142c1578c2a9f38bd536ef0a77266bc3b0b0f58dde96d911ab707dddbdf1cb3fae51884000a41852a0300d58535a9a953302b5d4deb93c00fd1a7ae3f24ff1db7b3ecff831749c8825258bcd40fc06028e3c6511e0ce771d8031a63c3482bad9e2950d3208c76ea4387faa8aca91043866ab33091de5baf0317e5aada2509540fa6ae3a1c574edec55c049a797614c8f3e26509a00d1921859164f3fb8ee6ed72b40d4d8fa7901216f84a8e8adf6bfb79a6b66b039a2cf868eb76ca93bd8505d049da65731485b4af70314a3e58957d8f0d75cc4126cd28f0da98e247872cdb4b61bc9f0cf811ff43fa4787fdf323829f0e288ffbdfd1406f56d1be81722938d2d95bac14ab6ed6d1303a9c339834d431d88be86b427ff4a2f69e5812ec2f69dac2e68f149ac466cc8bbc1bea2d3b65663b62e56e454bd40147bb440529a9423611cef187a64dba87f096d17b5cea312203842917bc98fadca0d7dfd60eca72dcf727cfa24e222a3e244a7ca4a501f43f125d9692ed99ffd76adce83b701a67a6998f1658858517311cc894f211934f6f8b90790079b843b32a279fa76f646c52f181fdcc9546fa449dcc41ef85fa27d5a62198b8e798290d88e18d99023dee09ddcaf6593007834f53f4e5653832e64c1c5bbfbc7f222df19a975eae8757ca4e84c25f93ebadc55ed9da47cda0c7da4e9aba9137393c1effcfc616f15918cd2ef9c362c6ed7dde1378373b2fca14e9fc93a31f590b2752621476d0592546e174b4e34a82acaf78414fe71ad82a317845ab75a31f03644223f65656b885d71a83637175d34004114e55a6deeed1bc87c8dd7df20339cc67113996bc76460092959f72d133fa145db323e0175f4a3173e54f3674c7dafb940e95b8d1f1c25731ae9b9d613227d5a002623dd6aa668243831631ee503ca518518cc15d13b3da569a4d18158f1f503d08813c3c201d763a72fb06a37911d67718cd15b774e33fde1fdce76a0ab641065fc3f16da64a2ba967c2759474e53ee802a1409fc56931dc6d56696f7c941c94041f50a6254b917f410bcce655685acc2ea3328c9051b4db1566bf405152b12ded1a29355ed384ad437509968a60f7e4ccb3fd7af450dbb55a65a750d803000480023853ec31dcabc8eb1286a1fee9cf85d46495eb3f296c738036549cfa3fa1254a1c6c95e0661eeecab14e5d8764644b424631e4e63a912b25892f7d19578a3ce59c60a3b23050ec7ee51ce2407bc1b69f48b34b8f3f15b05ac7d79f0cd38254906de9177875581c66bfa974199eb0f7afcd96eddb5dfe411ed15bcb1d2f2fc6f9472032d77658dedd6e83591551a0f2536b079b4bb0e0f703580e1afc4a750e8fc4bc2c0a32b493ed8188950b8b1b5a776a634ad760ad468fe56e2c3c49c66140851730b9289a46fcade73eb87a2b0a870b3337b92a843b927e01160b6f7bcd9ece8c8f0525c976e8a9fa6a6f241814bdaa0083778c220792ece9990d4e15b2dd478681361caadbf0e99ad2a996ce7eb292d325cbe6d50f6714032fa0232156deeddc1c20422bac97d7e874c4b2861d5e0bc03ca515e7aad1c69d48c2dd8269e15698637618328ee2f96ab35f46c4483d019e382bd46bfe6b6a581bff63209ceb0fc0b8309db49014933a93f2726dda08cf77aacdbd7fd3f47d96d0577d72fbdb808b2c2a92f621362c87dd9f748bf1a8dab9a4a3da97c7e519f60388bb73bcab730c762cee88857ea270c70994f39b0be759b3b1eb0235fb246dc0ee63e792c8e7ac7747b6038a1b1b7c16b108a1f931717cc657c4dafec49eb9bdb58d643bfc95371e8f2a7e9dc62e2d1d4c864740535f0e0fcdab04262cc2e1f34b4d8bfa5937adc2015b7a5c9665f3f795e36ec64a685034702188506b2b64a00a3cabc736fee5a1de35c873d0fef6de66070bc416c441952d13c1f764127656ea16df56526d894856ab6a455fa4bbbe81a58b5e657e9d305012441a6be0e649c2834823565386159d5ba2d996780fa24f37da813633cd106207710b266f48ea27071166655f7ec43a89abcb2c062ecdd3bb60e937b04f8e63feaab41c215d88570e1cc0d66dacf58b905c3dc11cb07d5a49ceb5d32cd4decdf76ee1715a71c69e722cd7596c00316ebacdf194e06bde79c6e08e531ae044caadf05e509e20ab79cd8297a822a4632ccd8cc786beed2195759eab3a37bfd675b9f033ebd5af6cb99cb8c43b0de9d65781f491e9fee5bc17480ef53b30d9e455511a7a033c9e6cb3ff52a3504f609eb2fca8f9fbc7d357f16175b9bcc75cdcbc4f47b9c777c5fd2b1a98c530858642bc45530969208e39a8d47d54506958293cbb8c195a0026035ebf085c21c96fd2320d31b082eecf2339cf763b58c11139a3fcf9c30cbec46e20c995500146184873db0e189e3f78294e8a362581f7da6eac0dc66f497712b67c748c2f497568bdf647bf84c780cc5f6d6cd0c583951e5f83bbb1b13d4d10b6b5973f9d218d13b7e5169adaaab56562c9f662ab739f713a3c120d7d9b588f5ebb6b0243aec94eac40c21249a751a6aa9c854ce631b4a7f18f4c1ea8a699c4aeae07e99bf4b0219bd0935cc602075a7588757d8f90996f30f0dca0837533ff352af3e20cac85b551651cdc05bdf286859c5f50c403918056b79326380e40344053031ed4a94786b25c0b15b2198f28680173747a567a677cc3a381f6b8fbc14cb9face81ef1717e4b86bb01fa778c75e1a495fc18cd23c757311f542d095b6ac1a6de05dd38545d7ae1a0f41d06f568c0eb504d5f0ec07f27238bbcb84d1ad2c4bce902a36fe54dcf27240ae1a0aa7c7c4a43de3f396280dc3a21b58a885c10aacbe8ef7e13b5e381396bd854fd65b6d8ae8ddd82058f328caa8c15761ab64a992ce9b57da5d0dbe2bbc5cb90f6985e7d8071bb6502989def99a5d318349c2158aad686527d4b86e0cd36a4a9359918e3945c989bb75fe91da8b48a66972d8fa13e8a3eac28df59480fa80ea34562281c26edafe9b97498ad546822be8eeac9e63be48c73e5cb4f2c14c351e005fbae5d88ff652427fb735e5662dff26fce7de9109fe540459baf0a844c6ce151dea65f89b33d22bf78c2773e093e00a057ee37a2481033bd2748b14886d07b7fb183633760845e275bd3319d28295b47460fb9f1c0164b3d3624d56431cf09abe52a197b78724c7a7c0972eba8687324de9fe317d5219f079727f455a072f88819749cb1e746d14211b1cfbdacb25ec345f8401c684dd5c97fb27a39e1215f5f04dd6f911cc5a1255e130f50af6e1d16440f2e7a9edc2588a8ee47c40a5a6d3bcf063e2a52892fb17e79c169397c72078c19dfab2b9bdaae23d0c27f0c510db18cc596e865b9376fa205faa2e0d516897a0d6c8260dd0b491d0cababc076166c2d6720787cd42a97ab7da39d00db76bfef013858004091acd580636993c29d825d5a91d9d0c687e670a94cd6c0a021daa6c61de812247c12e3c18a1edcc9c0b197b68ea5a0c2331ad906766da1c87d858b61afc2a5821642346a1de6e27bebc16517239cee47d57e160490ac50b6450905172c8c21a1129fa63bfa33891bab5815e69b3620f98256953ed0212815a0643e3afc102afa71ea565517ff733ee790038dbdfa724b731ab0aa926b1a527ec660a4841d41bbf0daa17f98354e59bba80e153458b39f35cdd9e5900408d3fe4b2a547f1422ccf2b7a37b43fb21585f228895262479ed2e61bb402374680e195b0dc8ce388c1b3101a58d8b7f5f9d74445dd667d942c940d5dd782edac1af66966db33d7a473f1c6b21e416254261f264bca093125ef9e8eb8daf2ad79dc5a67c76c175e9d5840c850d8e897ec1b5f8dfd03e5a9a77aaae156f895ce26654d69c23a0cfa121d7bf58809c1d05b58a8b4342cf2ec526a2163076c3ec626ae54c449690849aa91b2edb05559eb40c7bd78aa1c04d78f500bd336c3ac48a7434cf70511127021cc5f4a059810177cb74ef61c0dab8aeb9ac0a5442f1862d5ded7032b20da005cb73c1bcac99da31efec1c0a2dfac51f2d1a8f5bd4a8ccc8bd996164eee1fc8c12938af9ff96aa59a353375a1c59926c3ea47dafb0a61f74641626ca89bda17445b85d30c8ed8560d2509719ee1f4752478f09f5cd3fa4c43669a2c18bef462b595aef83dd83bd01e6bd8c3e057dfdd92177b600040e85927e2e3f4092fa70db5ef40b2695ba9fb511bf436bc947ac08b9a4ed045eeede60c9721d93c4dc24a60bdbdf2f5fe832f94c8e1ad0cb0bffa10f7faf90e5f487487f2a1c56793540b813deefb3c04dfd5ee6de9ee83273c0593ccbd5787e466f0bb4b26ebd4695838b783252ec063eeca1972813861cd646de99a35282b7047dc099965df60bd9e1cc995f326fa6c11b39e87f9f0dd0083b8d7156e6172fbc10564ea2a1a66817098ce088053cf3cca0cacde3a4589f1f94b85caaa30ba20bd0524f3ba50f56029504384e1a0100f59a391afd1397c1124a0082d4ed479971c0413ddec2e31c3eb1ef942f5d2c5711777790e75b1387ff99c1573e35d5047e6db8aa4e220bb70d465a51dbde59aee1f43277318bdfd5d062e5d098cb79f84185c9014c7fe6f5ad8244b78d97854cdf74972385c79d5af26d7431853fb76dd129b87409070015eb821d025f770f37aa4c3e37b61b8bacf8bd5a7033ed5e9ac5f294626e59d4a519160813d4d165e0173b8a95977478d971261ec2a83eb4ed95039359c70c3604dd5af5e527f33a925026479120026c55f85f8cc48b256e06369def6411df36734653f0d0640c6440856796b68e949916cbc2d4ad8fd1abb2ec5bdfb3624657c511c00fb36cb030ec89506ad84213f33aa0fc32a29cd7567e62d14c568454fbec6567764f42c2c3504c02504fa4a52d0bb781bbd50b8d4a8eba52e0e3fd96c96e68410693818cc2b1af3de47fcf980f787f2c89d35c5aea05f403b428ba11c1450addc9e59cc4c6526a828d1e63bd97d484850b4ba5e4353e7c159af449b167e792acd89b530a465589e6a4edfce63642a1be2d814fc6b9ca7329ea9f9fe11e6c0565aca068fa9cb95ecd6d1d0b6dcdb266163a2bf7732cc6e44b87405891a6d7574131746c148e769e7fe48830ee12bb55050983894fa53996febd253c22bc3173f8e1cb5d247c3229282d9dab6aaaef599c63458448786cf76b1f0840443a978164adfab8d1470eef91088ae03de00abf6258109f35a54ae82ddebe7bdfc92bf5bffd6212b5d81e29c56af015a1bde313e43d4b7d05f8b3ec00ac8cb3b00d6d176fe8095ea4269faaae22b756d1dcb0227bde624586ed3fe427308e150cf37eed50f5c77b5220f3df271305b1f8cbf98338c24e570c56fe888edfad8166ad4fe33066ba6283f538f62d615b62c79eb517c6dc5c2a133e1eee5599d60d6c7e32cc6f5d7cf7320d651cc22e3c6649b5ff9f42c766be677a77fefd0a3f8481deff2f9a655aa302b71baa093efd0057981a704a7bddbfb3916478123669b7ad9897eacfcdb868e7aaa741e056b68f94625e14e2dbbe4d240e3c7b3e9ea62d12496fd27d83eb98b0dc4907c99748e66be0c8b4ca162304a87cd877276b0f0460e36b32f5f0a925bceaf51155aeedec05860cf50e1e190dd5d58151fb586c22224a4613975612cbea9ab713c17e3b163ed0bb9960163781fcba8d4b8dbb237286aae4d56460e63330f00b6b77e746a775b4a95dce5541d1ca795db7ccc42e9325323a27dfb5651c49b75424d69e6d8bf864993570683e4caa67f2232fc25c99276aea1f5eefddee8346a680042dc484d823876e43db45f9d5e46781b6e8d11b8f371591f7c549a397ca8770a8461f3b26d11a36e45d78d0fefd524d321f09a1d852325a58b3fc442a2b5321c0b9b945774e9782d5b31d47c4d8e5c80966adc17e02e74d48408dd77c3be2c9ccb3c55c95c72fb36f385809a7e7e15f2be6dbe7ec930d0e066b44e6c105b89c43fae5c2e1b7e62353a301cce095af7e1061f9b27990a8aa90ac472259583c8c2876cae2523f11f9008850b5c8a00f582ba1eeb55c089602c4d59bb2d543992fd4538467abe48f4cd599c8f70d9f68ee6d04af915051feb6cd80e9e9d1d65e1ba9314dada7c88e60f6b1fa41a7aa62a9f238eaef96d2fd08e0d29a602cb8ab1102a86ac78486ea88aa2ba84e7ae13479d5342b1227c5fce638882ff6cb34914da4192757ec12bf65271078c7e316453ae669bb439b31c88ea0eaf157965d6a7dbe671eb7727ec6d44cf90ab5643d425566e095ba109db03083e5c41e998472adcad2521198c2d019b18ea5c6c23529c6ac41b19d8bc58e0fa63849d618a32ad5f3e44156e487e63917379557bdbcbe679f992219fc291092ab316a06964c42626ff4816df2841f8e1cff2ab1ef1c5714c00b5e4468cde7956d51f4c3ad10e59305f5c725ce59b77c2bc2328113fb69e65b696cb79b4281df1bf7680c30ba10cdd16412f3b40cbfcbe3cf18a5cde2d6e8ba9ef5bf3dfca4f2564b335a6e9e3e396763eff8f391a43e7dbb13a8d6ea8d5e764445a62d682f1ab472373dbaf300a1711f416c1d2bd60190b8517bb5f769341cdbf8c3956d313f108619086e3ad845388ea00033264be5899dbd58bd5f33bafd1af96c4a4e9d1b156fa62a34d8adb3858f09202eaa7c228e42d3461f01e07328f757c1a67dc0257ac31673f629235ec71a4a7140a55d81928b1ed84b5fe2d16f21708bc9f44e36e7d09b34ed47da4a0b259c4515a682859275070700a52d6c67fe5ff65bcc1252ed055ab83a8f677c469119cad2548b716f23a08b6479b1a462581a158a32639a7a62601c4aafbb58c29c3fb8a5b971287c273bed58babee8129324dca7c14e9fc482fccaf9184881ccbb16f268db639f7f1c6de7ab173ffff43182d0449791a2d9a2035692c31fde21fd9bcce700358a049c35982de1457a829f947510f4be002ebb0daf23ef789f599b215c10e5026919ed84eca6924b9b1e746e58ea135412185f7cc6feabeba107bceab5777092a8237366218a0ecaa0e7a342fec0823dbea08e93cfddf542e325aa014473f78c017902cb3cbce33d94f550bc308d616770e7cfb18afdb17049f2453d8b876e7d88486df6bdf0aa790b1094d82bf7f572414de876df83b08f5f9956edc50c1b7a5e13264a1986a7e37f04999464752eaabc56ad353fe4429ae2efed4ec2081f268fb13f6a1c26b5bc47a86431a3cd0d6f31687bb51e77c49f2ec76180863203d7da677bc4c04054fe443eb83696693ee9ccf6845bd328d3a85438d1a9e22055dd236ddb32ad12ea089d7da0442541cac3bd748483aef6e8b05cdea043d4efb14d22046abfd1e1875d2ac9861c8d6ba91ccc1c402501ed6a5dfe0b4e29c10611a48e5cb5fa4809afa11929b3196a938688481cac56397ce83b6aaff3122eaa9f3e99c5e66b4eff445c4b167fac783c1ac765ad9677566841b2de56a2269b0f6cda9ebb1b23a3adae42b4756d5c0d3fca381839700222c79cc15d64edc6d3619f8c8372956cdd30888f3b448237e81ab81573f9f54c928bd8dbd4f89023d40a69c6906d8a365fda8ec370a74204ea67a40e464d5beb7278081243abe1ded311e4a9c850f1cb89c4171411d6d292584456e0936cf0ca943d207593ddd83221d941632f50a9e204791f09155d91eae9bc7c740bc947780dc95aeb3c47b8cc9dfeed0cda3773b711f0f4b5b222a412600fb9fe76f2ac74cf240b3d981144c2bfa21efe7a592cd8df9afb27fc230ff068877328099e8df58290759cedefb8727a57f4f88c65ffa857a8f0916f85f346159f61b7670d683c7e15a783bda9c2ab7252c5c2e89b97023677e2dc46e87b2969a0b4c574b3461c502544c8a354003b7836a90e53884c7a3f8b54c0e9bd25a33b7d544d5a192e5eb32d7f60fadaf7f2bc43a2cd8425f4bebda164b96c009cd29d1dc94117c4ee6bff0a17bc0d571e9809b3c3c69e6561583da019e7b32e64575d0de2f2346348a5b700a7b2ba29448251768125639df22c77b2c08904fdb002b5918ea648b532a66c955edcbadcd145b3922e30800c0715c40d9c7482d0372e7682d8b57f7349b95f75f9c247a3a26e7d7caac566d7d721d0865d12a0a3b4bfbfbaf1aead7f332149978875ac8a84f81aabaa2b388824d7a5c1e7210c5682a7732a0693a83f53bbf1d6ef917ff5a642693a929543728073124610ff43768765a58f1cbc5e172fe2a5d508f517bc632a2c74e281587238bda1d1eaf5969ad5758af5425de937c554e8f2aea191b10d3389d1a50b118cd0446cf18b39b69cf5b4fc53407e088115bbe23cd70cb8abe7af9183c1608f145cfc5d080fc52962a04d5b6032208ed5ff46de43d5805950efc0f9d05ee0bdc1383c4239bd32e61f244f9e8276f3a0d5cf95ce52c68d1010bae016c67c17b1f91c0acdf8aacf835f999e473ebc25843228e47ba300657ba88b04cb10cdbbad031fe68ba3ab7237bc89e7f2048fac7cc356d5ba9220276442b8fa21eb3e49a02a5ef7b06a19d69a4051a217184575cfdb517974de3ab5c43b01fd41276d1b688d99625e71","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
