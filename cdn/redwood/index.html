<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2ce416f5b13f5047efe4ec5e73c8b22ccf469c4267cbc8c3c5ed32693bdeda4408a626722c5793a6722c7e5bc1da4dac13df5ba986d4641f2eca1576917f4afa2842550d18b81d7254818f9fd79985e8515721d1d039df8a9336775c27e32fede6d302548d7acebae63c5a2e0aba801bed8673407da21bb7301947dd0acc2348c5300b0bbbc3c9d52445032b263d10667e50f7995a4159a14b4022e8a60727707c3517928051807487175a9a51c3ae7b71bedfc783b5b373e47b0232ae4dc5b1336e4e4a506b06e4c7c1a326e410454cc3754d08b88a1f8f804b2592ff6bbf3776acb4b4e4e3f02cd369a97602fc9939710173653ae124d983e5fde8b1a897ca7bace4036e4417ec219fb18f215b395e8176a4475bc99efc5890713a7806ee01e8955e0f55a6d0ec63cfa48c6bb77453cd837e2e4419040c30eca6bf59ede1953f429870df25512d4f7363a730a64be8170fccecb9721a04dfd6a6705a08fe958b1edf961520c0fb3e8e9d3af9c59d750f2d1ad9e9bb51fd8a759e6e8fc5db6936f9250bcf2bb3cf7a79726b15d9dc7d1d7cde01475dd48bb821aed66a4cfd3148aa1ced7a028eb317d3ae4a652eeba9db2e1d8ff48071d62e761f67d6ada6fa9b8c7f3b48470d11475981070441be1489f6fa9f77422eb87c05f042b9a99ce72ce5e9a80fe4ce8b66d6d85b3ecfeceb273a286cb896263765b4e357afbe33ea44270dc479f3b562a064057942fe65c073c47749a0fcacb87a7bc4ef1be8927159795bdd7b361d13df73d98625d4c9c8f16f74f747ad90afca9a53da19a6d4964de0ceae93e307940a61386407785b1e23665a6938202b173887015dc016e8ba9dd01f49fa32f10195ceffdfb70ab86361e73530a9286db06cf8c58cb819394abdd704d6c4ea6a69b06300f9628a1de51a5c68fd049e77fdb6c24f7ba0624388ad6f7daade0fe8f0b9f04e52f14402f831d70bc519ac086514858f783f89a665ebfe402aaa302e70ee2951ccb9462e8ad98e257db2aa4cfdb70836719a8acb846d50ebe2e991def39ecb901a6a3b9000b71714b1856376acd30fe0e17b1fe927fd7c74bc551fc3cc6c3a49fd8597ee533298ced5c1372cf5eeee0a8e744c1390c8730a8f9c8830b94e424ef161119ef95209aac080169e021a075a75032a3cfafcac31482ea9a27b1304655276d4731ea9eb2d3a06a670b42b133c08bb92baea01a29d559464f3890c94979331c277e5468fadc810f40a07103d6dc9e0164c1a6eae96a1ceeac93ed7f45747e745ae876227616caaef1a8a561a2e921e86f437707846257b10a2c0a6f98dd34f9a6cb8ffc77e9163af95b0648b441b4bf15dce2b51ffeb82271401f236c7d4fde6c89e144f5b8cfd39b69797addbb864ad1d2b4a3736264ee125f834fe00ff1fd6ea65e167455083b18ad79c722b908256abe1a32ea631e7e62e11ebfdb13bcaf75d053c3dd363c103b606c0364c167386a92ac9eca6adb2f1327230f92cc015a856a4e3dc4f3344b12efc063fa9ff1f015dc32cb9a900b5f1b84ec6a797a1888387ea5aa4dc8e0952805862b14b66b1a803a5ec7e4773c72160911902b7a64768d1e15c719547b88436d868a6221a56fd14587d84b6b1ba9142aa14935f8edb03c560fe4175b689ce8cb1627e625e1f4733ac42b7e67f2730ad5edb4e25f18febfd92dccfd7abb804c4ffb400e0ea6aa5e304f84533ac4b0a7fc2df8938a6c9c5299e4f3721b91712e77a487b5cbaa95c2ebd64b5945327e88df1fcc5b288ef762d96f36bfe5bb0f8ea52bf3998673a9ed3ad739a0185d8d22585d4651eeb981263a922d29883d145890123ebb7adc51bb6ed6fa40ade1b280763f518673ce566b18b5ff105f826cdad995f495b137be56651ca7aac74633bc377d33344c84b0006556162d65978af704b59d73d05f33a1871a9c70dc5f13a6b14af97c66d27c8ecc07d4d508137b95d621aa47784cf71cd0e488e0331d47922b6ebb955997cf7c67fbf5ebd3c8b2db6db7a1803fa4b9df2b0053743e4f271d3cf0740d831e7c23183d607ab462cdeb46df5db7ea15f32039cf1904ca7b3e651c4792280ea0d651dae4b2f6e7bcaffd726f3b19bd829bc77be073ba9740133e5ad9b603eef4d15a7d0b0726d55a9b2299f84211cd48c6ea8639e1dbca2da638f912d242a9840328d820a9641669a27db8659671ee775ae8c9e544c0830089cb1c6190b1c40ae503ced19d695aa05cce006fda545b593d2554657550077465ac1716f0730ceb5564f063d8ce0fb665f4d42df74e40f3d2344a1d54395c6a69822bba9f330d41e41cd9402ad151e47de07a06670a10a64cb15e6346cfd04bd6f7cbeb58cdb5d3b8af286f4fa2d0fa1ff47f4c9eed0f202eebf1ea7142e3df3a1f38b17964c35162d716eb3b2978bc813bf10936c1ce197ab3a305d86dbb93756b2e4fbf4fc1dbc60444af42c58d60a7c40614ccf07cbf4f1b2db119ec192aca2955c037184201d2929249f0edd567804bcc454c433fe3b06c8e53339bd8ad3cb930568c0d5804bfdcefd88832607ea7954ab0b9faae9c80319b6a84721d605fc7f919039f13ab44fba993533a823ddc57282420b8c920dcedaf553f0a983d81a65ea592ccbea0b1de1e6d6b6f0e4da8cc3d868c52000adca529440517b7c638d1c4e6a11db94b381202a5e8eef229d5330707c4d3c492d87e631d0738eb8316b39e775e7400b9b78616256be3cc2bee9ad4a3c275bcdf38afcef53a218a1bfd266150dd6c1d41e5b0183baa625eff6c9d0e8e1889c602279735b1d98e2bbc802ef1f083a461e5b36a5deece193dec70abf025988f18a67426d917d7cb90511f6bc3093f50dddb3ca5b6eaeb9e7925960359d5ac804580000fc2e5c13b5002e6660b3b62e74dd88e2b493a706f5ee869745e89a1938dabc356ff0ce6e357cdee831fe71e6511f5b4defbd604926bb2ec07446e7d7975379096970f25ea4ff886b25646a1b907f5ac2a04c2a0929f4336e2bfb1378e3eb465197124cf2ec76c9d8cd1335bca2075e59138e4bbed6d0655fd9fee7a52ee254d0b778cdb35cc75e744581090fd9d95d1015c807f4aabe058f7c6cc2be8235c8bc5ce670a1fdc7eef9844aff6d16ad15f03bed95a8070a0bf955726089407aedcb349934354810640a074ee8198a70e024873e0316f2fae98aa669343aa11f58afddc2f0b6b855d432fc9a3d6f3c00ef3120b3b6e174addfe659ba69f06f86dc021973258d0cb32a934abc03c09cf457f4000ce6f189d28d06e39e9f8a3a197cc43267c178ce705b1a3942310c27eca98f7c799a46781e641dcb67f2d505e5f54abbaf274f316b0bd48144e9fc7041d6ea9448ba8aed62c3b573f817b921c6126d78fc4f9fd6c7dfef23c9fe7805fd20a7f37bc33657e70f2c52a82d6336add91f3844ca3caa5eb8d5695ed5e9377aa083c376a509210cb391192892f76e98c18b8b026837982910ce3849e4268bbb44aab2b005275756ef90053f28cfe3ad03d189b3e1c7a7e1143b9f403385543c298f1a059595d55a58e959e1a4c254574c3b40f4ba2331a18c10c1ea32862b31e0d322a3c527f5c94548d5c6f8674fae34d5f7b8b0b3afd4bdf5d912a8553b77c95057e1c1aa726ee01b2d0bac1be6c3dc9f100930d2cfd35ff1a9f0e052d9352b5379d887ec47d0a6fef2257bb0f1bffb217c8a541f02b0cd07c9da4b3697361a89c66e9262b2e2eea30b3fa126c5248bc6855d0dda18a4776851a5d1cea9aba6831f6b9dfccc0bf183e50fb92e5e7838453b61a80610724a30a9e604e9396c2b8b54d9e1d6cafa0eaf4e75e1bdff52f098a1125565bbb3cb685755823709eabef98f591c760c374fc8a454a8f8264c014c5ebc0627a5475266f0976eaaeccbcbb812412861bccc461fa129e0de3b23408f5134d71a0170fac7c96dab222872abac23ce524dfea8a74dee1d3f9e52590bf2026559e8e8715ebdf1a6e5fff4f62da7afce438f7994a2762da20941d612017d3011b6fa15be7da7b2ae370ffb238ee7ea2564944d097b126844b7b36bedf7cc4bdcdff95eca0820fa59ee02d768d027688c89fe75751ee67e9da3173e3b2127c72f1733b87ca5f0706bab4785c4d76c0e1dca084965a10a2040a6af8de1bd021ce46d9d4c05319b67eb2179275af952d2dc35f4f4c6209eca263cf95c2af8bb87a120d5d1287763d9e8f2b35fd9dd432d829562a4bd3f09ced86147986e20c679ec6c45c93d3cebc56c53defe6f96d7dca731f037aed8fed9a5082a8e8ec63b794d08f3bbe2c3a34abea115355c06076e1739a231a45fa616d1dc4fff52900c01e6dfcf1b355477c870d888426a81b8347715d8a913aa0899e73d0491a7e17368aedac62c4ddaa394452727fb94314e050dc71d393aa4ab670acce90a9fa68a923d3a570c564377a16a2f782ba471b734fe98b129d8c3904bc832d0e5f5f6427a8bc87cb3a32abef1a78fa3227825fc4f0d3533f4a9ccbd05df3409b43d143c2dd479d6b663e8c0bd5787fe05e529db3cad25b6cd428dfecd6e8195e83063933e43017d9f33daf7a82154fdc0788817f7444081b7d7580818b8aa7fa7e35d54db76dd935a17d6f33743a6e49916efada630f852a62ce160c11cf4260b4c924e0c7ca1103c5e8ee4eb7b9899a16b79ef99f95a1c937b47a1db848b862079e7df4396f741333669b7a5da6b12ad1fcf3f015fcc3d6de8f2bc437cc727359ba8af2b72c6461fffeb5b8bd06903a65174b92f305df572e4e89a102cb93917d138fd04df1c50406324b588ae2f5c28b803cd7462e882e3d45458d0663a1c4b59e59289f6a480a0480f4b4b0e53f71639d66d03ad153e08e21844af0d0648fb09d64cdde86f8e7aa596694ad3542eed4e76af131d5e6ad4c439a3f8bd40f25b6d359539649a25024bfef412b0842fa216a358bf023162f9d23f10ce57a6da158428e58db3dbad7c6c2fbeec22e0a01e58a5f320b52874f261b9a0512c9433cf0c4de2289990e9378a251d81f658bdaeec61dd41b4ad1d3503f89de306e6b35a9aff7b929d9b677edc24445b9359fe49716bf9079c2a65e23e4da68a45b19eb9a2dbd82fad537413af2365ebf0081c1a60587de1c4af31eb124cf3543f42d81ce8a6f84df0586e3293724903d225bd40bd6135505281ca2417c2fd8906af06b35bda0d2aff8957c8c7332f2434f7ec1c8cce36bf0bb085d8156c52a44233df32c660ea3475d1ebe7c9ed23e0a549784fe12251c1a96fb3b22a4678ae85b8ea93c9e13e61e3acda7bfa2ffe800dcb874e4653cddda48a84109ebadabd974e25fd084211ba1473f6de53d706bd608b99289f04489af5d16d8b73b7c33b6dfd8234feddfee4aaf7d66a9088e87ae9315c2a16ccee9f6ff57d86394832752f334f283a1a90c447299bcb411cd1af44dac8769f3514e985aa793f224defd9a86d3b6c8666b1f5317969d78a3f56d79e0a8ec1155b2f2a07b44610500b063aeb8c57b4f67338aedb25603fa53aba2f1bca4201c985be36c5458e29391162992916ae4bfe02c50a401b97cd398c8dea79bd87025cce17fb14fe5cb58977a91ae008b6a4dba51ddd3253920d66e1ac49c4e1b23e746f93e3024200564cd6b21ba87a42b3b5d6585ab971f1306a0a86f93a0b68db64c9901aa37f4436115a45b3bb12143eebe4e2530bd82e0a1e5b03f3f09f99ca331bb3bf4a011248bf30dee8666aa93ab55d79090d19db85a36956c4b0427e63e040a74283e0e0bf743f1afa0a3b47edccd692cf37813251f02e3374322cdf2b26a5356327a18a3278970cbe9c3207bffacb8ffefb0e9db2061706f23bb9a732426875b27b851767443079705627719f57bef2f41605ac1bf735c26f5067305eb775fa41189bc166c0a32c5e2675e5e40ef3d8c0d5b7069ab691d29265ce0151fa41ed7f900625111af34a0752d90a285c219081984580d0105aebd573150921877374d7b7230a62aaf6fde1f62c2070403d24ae89d099e61f452465fa333caea632b97dba6730c88379d11b8756d7d9fe4fbfc1da5803b0cb891a56568f0a81dfc60586807af33554a1ab101f75da08c29a524b196a7c3f47538507b324a50a7fc4b658a04ce5910ffb76b33083ec66ba1e782672821576abeadcbe939f89977102a5d22503b628fcbbbe467e705a90f872b933f483cd1a56cbd20b45a1fb8f9ffa3b6d5636fef85bfb93ea0f99192fd9c00696ee402989365828782ccbd21fb366fa3c7295e0ff265c0a6e3aab45ffd8f350199270cfe388b823f8780644bd86060b2ec7772e48d4b47a6bb678f2f1a002b93772ac6a35ed068a518de4e96e5af64f06f3de3e6048af8352339a5894deaf133a8c52557274ce4e4c3c52222b99c9507f97394b16b7911e678146017fddbab452667e2c46074c4869765c5000e50192973cd11b294d6d5ad7678b175de01b237f258c97ff5021bb36506c372f23330d653757e2afd5cead902bdfcfdd3ee4f9be3bb2cfd831ea7217af4424363d4f03c481fb0e2e6049165a792c7dfbd1cfb409abf79fc7f34e67a476c3329a57833bf780f8f9953f740c3fdc346b1c42474f64f385476e2b77e9072cf306448afbc6f793c34dce88873bd2187cecbd058f4ec7b9ec2cbd18c6841d3eb4383b8c4526b0fc90fc05752b4b724c5d7b9868836085a38b62d006a91ec4a552a7d0a421c6007b01bead06d3595fdef7f0a00addb11442d46aa0faa13e62d2a26152a7fc8a9e2ab9d772fe00c26e7da5d90cf17d505011f2b4c33f79ab378cd6373aa1d7ac1c919b39fd18f4ad20db80714520c541de300b238b34efbc15a7e13ae04ad8454ead710cac666cf778c0b0130c990bfb23f4e56647e08e648182efdfed09129f69dd8b6c1f7274b0bff8b575cf14be3362013c57a442fd5077af0dd7b29c1d3e8ab96b7ad333ce2a082e7e6314417851d5e2953c9ba771f53000278bdb5492fc7602bbf42956da045ce411a680324cbf7bf5553168d79274087c74b261fdfd050f4b496cef1e61ab529c032846c1829756d2901e1ecbedafa49598578f2eaf75d511e02468725eb0b974925b84a590b8565f5a3cf8644021b56b528cb66bd7a1266597d356d03499c97052706d4ffce47b3cff5bcacbdd21c5c7534165de27d90b67c0c3af19f20323ad91b1f55f003d5957fe2bc4cd00424f685a0b02f9dd4c50a82536390c6ee4205c74546923d4dc8ea230070720f8a46472034f47cb5e593e22122b38cb518db6c2769fa97a49454f91920e13c5e78e1907773d0d241a8441964380c81870620f823a025495a95b50ba4298fb0d3b36540da2e8207c65b5eafce384b462d4bf4dc579e6e01b9c61fb46f2ec249ba5b66206baa16922ac3c1f071823b9b535416fc32fd0cd3fcde315b1ad7819c0cee95f714e096fd12bf4e7d2ac9b58d1a223715a72dba03128bfe149913949643bf5926f20b0fd81716e6bffa1a8359443e83ca67d4e800bc5a6aae0d11aa6412423aaaa3c40b4c4ca9fc6c2f2ef5ef39bf7debf116be493a923b230c0a4207f4d35ac6e4011179c8649d6293a185fcf3c1c32e3365e20c0ba341ed77eb0c54defb68453539c4bc8f87b7821da30da18906e2271387a9bd55c8d4d5e8a0c2e0ae4dd8d4601318d0ecdac97823ffbf3821c0259c68f2ed5541c15206560efa6bc41928c6965efd5e6f918b8a3d74e1feaec8ffe3ec12a8f2caf883a732549b8006a74d47f832f83cf65bb3b348881c05f59ca839f6f967a0734b0d2731a7972cc666039d23b80e587b8bca308fa29205d9357789f7c8a38a45ad4da7acb86f52997abd47f5800aed8bbeda02f0b9c6dc80ada08be2e6eb95629804656b30da26b3534772c8628c3a627dfbb754009c8e8f88bec5768d64e34bef5a186503d2369193ea033aadd20a20976c3dd4ad711b422d2c736b243ce1de1462775ee263cabcdae1ecf283b81a7e76c726105b50ecd7b7ced2a3fdd32e679151b88a417139320a693963fcb93fa63bea31268cf1e249b8bf457511a0caf0b3fc6639ae59b8b60cdf2d021cf47f8ab4061a105639a03243833d63f7291bbd85a900a3d699444dee27d29e731d764954911ddaab894e9eccf7e723fc627c893cce3e2e5dde76a55e2bd746263a2370504d42030600d46da5253cbe595de64c2b1fb16e980b8e2dd0a3c8d826db046e020eea8198cab26c2ce59beaad8ff5f6e327d89835f84fd9043c47da8bdff4a251472f2aad92b371a57741f8751b99afdd4a67d65fce464bcc66492cca6084e5e28e3c5271b47b0ee39a6ac865ceea9dbe2b4b3048f00d25950eaf4e2b767f08eca731069b2ce2fd7663ab2495bd955a034b85fd3cc7dc7e1fb984faa0856c2846b631e92ca189820674e2f18c1753860bc11891055f5e8312391c4b2a8a8a3e3696b8300ae005b02e64ebc853b3ddfb6cfb1a06aaad58aedd487e69ab9b683899d2af6b05fbf67b554f3efff93ed74d5b0dbd28607250443db7d277830e6a6e6b91a8905b6c2d29016a8b98655c7e1c0acb3459cc9617831be2878d0a1b81810a17fbe86e127cc888e76372c8414503c75b0310e1dbf916b234231366af5dc58bae1de346be634042a07563d32ddb80285915d48cc76c15a6c00b9cc4504583d14199fe0b9f5b3267a9392f68e89826d74519bc52ac109dfe671b0ea2bf39d910cd6f5fef8785d2d36fb73c032fc86dc215f86a6e25f72322c2e14bd2d3cab98db6b26cd96fc29d1965b952844951aae3545acfaa17348be1092c9139ba93ed4ee25018242bbf8a642b431ac96e52b171e94c6e1314b2a9b5ae4b72c3a6d7e6092513db7f2874b3772441ce6bb42a69a80deb1a3939ecf1e43c3f639a82d18fa1e8647355fa2c1939711eca12499c0481509036a4a9e72e76d7be319f1eb225ad4a4563fcd3bca3e2c91f3993042470500a2f59cb673d9101f3769b8d6453f05eb3c2e113b808c19523307618a28ddd0153f893b002647dd15742172378a7b941797bb0d6c7d160363bf85e3ca03cabdbf314a172b6c63c4c8fed6c6237d5b0e26b86e72b761c22a0844f363f3ac7b4941bca3d1b5fbdf5e82b36904dc5ac0dc74b9854a57ba5fbaa4785eeb202fd4f26ac3c265cb7c2095f5fcc162a82716d681bffe55446012f693f9778d75b800f1951e5e8f3ab0a3d4bab519a43ed594877c3c78b1b4619c506e5d8a711357089f488716c0ba8d7262806bcae366bc68a68406e5bb2b666b8aa2d212a8dcc744816ffa6f8c98c6863ba39e8d575fe2b87fa540859d2973e9124fecff9a1457df6997360ed116e226e6641a5d5c04a693f2e299b5391acd6652bb45cdc686d8b2cc7ebed2581f1252b750453bb3de3bf23d5c26547d676ab89f48bbabad60bf92764eee37f672cee6336d295e17745015d1cec762340aed49aca9664814976206f61fa5fa34666ef5a7da0f920397937dcb61fe0e5798e9b567dba47f751dbe49b29533ed15bdb2daec943c2501f118c61233693a69fb91a8b88d7b6bda19f8477ddf430344c89715f185ed635ddbffd80e5fd2b1cb5ac8b6b7094cd76a4e5774e04bd8f6845e095873649ebe9b8813654bf821aee8e3bb867d9df69612a3be643fba59a5b65a402f579bb478d102fd7d68718b91c9aef0560cb257a2d8be93419d840f7d34f8a32d105cb5d22555423b3ff977531665632080ce474cf274768c46d1f36910be088e9865fd03ceea6838f0168629f3bb67dd517ec64aa111f1d5c31430b572671d6d23a53716ec8e8649c5d103981e7f4c586028a96984dcd1cb816787521f61793f313f005777802a2e347924e7f8bfbc992d6339f07a70d31a82e15669d86bcd7cf3e1d218907420db6ca1e8cbefb20b6fa527c7d9cb75700a6ffc3089b058d55c00f440c489892ecd176426fa450d95878f2e7c0e0d471ee85a162e3e9e2e97c5c5e39719ecdbaadac406d1c4d56a4d2d4a8ac5cd2489d556e38bf725acd1c53820e3895592ca4b2e269659ebbb3484f55c4dc35eac26829cea6abaa057f23117ddc59ebb271bcb02c7f5e87da2a1626034b5e0f5fd181e272ea79d3221ec395cd8cbd2cdfd9e749d7abd9e30e8e8576256fdb777c6fe2d01002546aa1fdb5070d49f1c9649ea20343e3dafb289d7db4082f4a5998581bee1ac2d3a33d678ad5d71f9e0966a663a30b4dbc431e03d473a1a70e2c02b30dd6fb87a48c11a22a74c4179b2cca770e39dadaceeb4ac4c809a3ffc1f420975d31c8d98ec5f7b786461f526b36ca390d702f904e7a90434bb93e842e088b1a7d787398b743de9a122f684ad32f9c8e68ac3064d709e2c020bf871df2d8da518a0fca651b04120bb5abeff18ae70f774e1eb481698f7895c87f4996bb525d6acad889ae534fc5241a23bfdae763c376698474387d24d459239bd2ae14fc18139021ba712ffe769c6f6a52ddabcc22dd926add690cfeeeed32669876153bebffcd7bca0fe653b59de6c775f4968469ac47255382ed409c3fe9cfabe5b95ff2a6a28658eeced97db57c74426112426fd78bb9891262e154753c54d2609b51db68aeff439ff311abf93640318bbeaa9ab78789667254f341f714df82169f622827db1da8474e149148cb7bf9aded6700d8578a7ca665146100780eb3861b562040f38a7c10e4b12e42a0e57d71ad7127c198f0b80594961efa0d5b3772703538c5513b50f0fde98d0a6afbee19aca4ec7b7276a899e5b6ba5beb9cd800fb4ce09ff17a956019fb777f200adad74784b8e979d86692d310d17c9735f302984690f1f4be9d73fe7c9ee670ce7d450731c9eb6e9fb63b4fb02773b1bd3758a83a66bd2e862814ad063c83fc7fe49e915b76034ef49903b5a6b34d38a37e0e4c5116fcfb2f90b9998fa55dd1f86b3b610fcabed61579c7638cbdebe378e45dd611abe0f229eb0304b2c1ea81b301171696d4366aa10f216789fc6586bb161a1af7a46491c96898b7224c1b6b902e8dbe1badbb9e173ed499c067ffc94d4b038e4eaf8da695f7523478ee55429c7e75e588a372d41b0b52ba4fcc8ab891e2d6bad585852be0d26a15f26a6512a40fa99eb250f7d2c8dc5ccdf5319997f91762172f26b3401d1d7ae517c006edff4238618ca42e1f47c51d0dd806d295bc2dd4c6e2fcb21dd1375e9c0645dbd40086b07483801405c9a047f2957194597489bdb7466d8950f09b0d7e45f12e0aac2065b4332f94abc77496a018d93e076fb2a34adc8cd5ecdc746b90a3e1b10c0fd1a45826fb975bf47d0b0f3ae365350210f55d602a020a227667c8472168187a9e83e49ca033880be3485bebbcd6dfaf8ca4aa7dcc931fae970c5a69a949aed165896c14e4a10cb5db8f15edbff328c1cbd10f671b8ab2073c6e95b2c3e11977d40bfa81db60e449811ef9f51c6001b9809557854c3f4168e8f80414feeb54a5b1603cda011e02f33d560d6166b6a0e142a5ce090c374f619de78e00dca3dbcc9c91fc6f7303f31342c26c96aa50aaef56cef81bd9bce3431d6789190519f71f9711709c52e5e6c5650f98e306ad9c8140c357116534f507518b95c23b2b57be7da748f8cad3099c98b27c6acb4143afe7d71a922c23449381ba7ca76a6ee351b66cbf7df0564001e2a31673c4ca0ecd5205ab644f7b21fb6038b485e19e3510b72b2f4216ea1be953a8f3389ac0d15c779413e95328527d28c4464bcdc99d2ce870dd749f7a1d2b71cb600498eb579fb0f910db1208ec81ed142c0617a8ce53eef89ed39fb8ee1cd67f4ecd4893008e53802dfc5dc821d9a9a006ebc6cf1708dd5e2aad5d118cd014ef6f410356529c6eb76a795625cfe277446ef48d1e468cd41e37574b67beb7cd2f595bc4b3bce6f5cb952bd5596c26c201ca54c6c292edb6cfffbacddeeb9fbbb83492f064eae7ff92e15532d2c50907d5b1214447cda5e7538f53d857944a9ef3e0734f1374cb20dae10bc7f4ee69d78f9685bf134e824cb61a9af9fec3df2b562b2b1613d6e6b48e507be3137422bab13d2d8ced90fce8f54c6fe3e6fb3c038813dcbdfa9354d5606dc199dfc509b4d45b715d37a439b9ac6e768f4983fff4b38748757097fe2b2b1ea78db09fea97d43c26fcd80515e7e5867765751125a06550d7201cfce2d991e598519f3bdbf4b0bd53b1a167cd26946589e9e9b99a508afad19379432b9cc0b227d1855c25eb55bb0e3a5d2a83bfad8ece7cc4a3c1cff5f0e9c75075e07c1dae2c765226c3dfde753af40c2772d9776596b81048eac77506e4a30408df2dfb72404ec9c894710d39c56131726e8f93eee8c87e9048bff0d80fc8ca31ad2afc068203708e65031ae28362cb6362a22109006bf2ba7180433f06e88037c792cffb44995a0da5d35f9e2d9df212ece6aafa773150201ca6bd4e5fae479ad862adea9fda42700fb740c987d320b46aa62891f7d868a55fce3799d629c57c74ecfb9cbe9814a9ba0aa8e59b163e1b0d8809f87cdea7e48abe7c0483b3a5da03fa09ea30acdbbfe99c81f158ef446c3d78e3de21ce77440226f8f48393e871341331ee5dbb45d4ab8d8b174028ff1a3525f64c9112bc18cf2128c4c95eed7e4f59c2d1995125313a77b50af26206b6da44054cfb3dbef12a319e4f63d7900d8f3b71ac071484b38b5d26ddc69c1365088aa0191055a6c8042708cd260369a8483baa084c2e5a6cec6b495ed175e879d9c7aba9e80b32322bf1cb866232c1a3edb1b092e3468a266946d89b9262b123d41b55cd9f1276f7751b8341cae1330d37134518266f25cdf7fd8d37549c0360ed621ca7060e1701b764163fc7e84874baca98b7746147b4350852136c0586cb1735c028f5681c35ae457e4a560158465c0cb27d69b01041b8a7d0e1dcce19f5ba87579f8c0f30a8fb99a51c57cc3d53fe1b81791f4fc6cc115a78fd93ec647b1d4dd0a4fdebf09dce8674627682f5227a0851c871873d098616af726a5ffd7778cfea89b49628145e8d3a3fd3138f69672c9a455985293e69919e1051f251d56b06d27cf808c07b23aa6d281a562d3f2d045a2f901386afef21c7b7d1947ba6d183b7c79e626ebf60f9be99969a9b444d711c4dd62b07ffb4a88137c1eecd4f06e61c72012e39ba15b1791464292cfa019aa3301af060a0682997e84baa0291845df36bc9ee8599dd9d083f547c3dc48e1d5c28a2732c1765a7b02f40e160475e78098b09cf97b29e7c0ab0d5deb55db70882db12b7a624690dbeae094cd54b4efb4da2ac63c94db475c52b9fccb65494a8ca71586b67f1a6bd5fd7685cfc0dd7b730c7c8fda46750c4494be4bdac06e6c76219fef4cc1cebbfc4f3339698f085e034fc299ee37694c18d76b4dcfc4b481d0bbc611aa27265de5587e12a684b83bb7be1c374aff8347bbb044a0d6c1fbfc0ca2b5c39df65b70f39ecd5bc058e9ca1cd30933095ede8d8b1d8ab78173c65ad17a054fd94fc5655d4951fdbf51002b63efcb9204757c82db34c137b6b88e80e0f912a95fbca4760b5d90deb0a29bd1a3171e9c077281e8af3a59cd4d24368273eee4c317fcaa30d80b62fd585f5515e873c09a2043ef268220f561a63015b9004c6371cb75fbe6a2f28688e75c7c8647c41d0572894374e0f8b8b83a12be7b925d18604e16846b40cf8362a70de298f8e6f3f423ae335436f45c17d854e0cb0e431b9925525567ff17549ac8d72e37935bcf93c4d76711937ef886e9723359baa27681751bf5108a5c7b9a222bdcca208109c3a9898d7fba45f546fc45976f5f921b9033c241329aa488e1b88a3e9c72b8fd1e9c0256720d1d016dacbd33eba7ec036d036ca1f44102841f803d3a40ce8974de514cd771a31e3e8c8e13f07aff7169064c9e80cc55c60963c0ce0e30ce03ff0c89cf67579dde37e47e9e6fccb0dbf799a2066f9daec4d2f7539b19e4d1d22a6ccc612ad9dfcc4ded5d2a8496cc275174e81247efa819e98de1eec58916b7d07ddd93bde855d0262ea20b901608921dcbfd350a069c362ca54ded175acafd078b6ca8be69f8157d4bb0dd6e2be92ff0732a5416b4d097b5b4e7e1423d8643d6dc44ff867b37c5c78fcd80bc07c78e1e7ea900ec2f42a17de850bb4b53664f287d5b4e44a465ca41929110bfa3fe3b5381976958ec2e6d5f219983cceef900a1f7cedb8b285f25cd2495f0920cd71bd4796086affd34aec90a5a118ab0e2da8480d57fbd36997015986efbcfb1a4d81115307935963d26c237c1e49418ee72819373790aecb5be45d9438e216d6ae40cccaa7bc05fa9247154cba1b1146143573def0bd57591782e6635e213fe31b9f602098a6277c5bc322a4d84a3fc7157c814ac5b9da010e9070e47e519c24a9d0126b6f747fe116b58eeebefc90630e9defe2ef26a17790d4729d891932a0213dd2139b83e52984fb02bbbcb8016816d5d73a324f9c48159f2992360b23dfe563d590963ed535c6f54c92adbaabb512d84e4a988d6bd9a502cc88bd7473dd71e6208f09179b2f701b63dec3672b06ddf14b1553f7d7b4202d543293ca4f42aee1c21ae5879cb6214bc736dafe1eccd6b6cbb7fface00d219c9902230851a7843f8d6145c509724b88bd4ce055930fd284556c05440b3c253f9e57a5f22442fd6eedddaf43052d4c2d2ad80e9928e11b93513124cd3c62aee064664c59e1f167d0349089d92e2ed171a4264e69cbcd27def4db45c0407c3f31fda7ec82758c1908c54e9feb4104e52c2aba5409d0605a27e815d6e1f495d89369a31011cbcf10f041bf0ee323a644feac28271fc8d7b4f6f87fc47d5d6b591239b186795f8ab956f72c24f1eaa4d10eb9a25d483b9bef9109ee3d8c4b52f290aa4c6bdca73bf572a2cbf826e4bb97fdb27b310186bd0bf5f0beb1c7fdef095b6c89bf4001faf9898ada727a51a040789ebe6c580644e3a68c5ec783990b97c1d97ca8c985b809cc821b50fcdcb526b8cfd9384b972e7043755c8376a33978d401d34b7fc2e26b70bb409eb09c8d4687287d8edaf82ec184477810ed34d3792014dd97855f0c03cf0d32c46e7847ef2e248a78012eafea594a99efa88dbfc5d9032ecb2c1b5443b555bd5d37ba139826f9aecff400ced053723d6d97a89b09cd12231496f6c0e852c2f308898cc503db98963f759b8b97265c12fa0e5c28de93148a549bbfbfbd9eb118e9152ed522a92f6c1b9e02ccb819582f0b105af7baf3de1d6f6b99e0a33cd12b74cebff00abc641621df9d49eb87a6f1f82f257da93f7c277f570caa1631dbe6d5abd321e892b81e8d32bd379fa0dbee849918a2c4667a823de9f2442cb8410443499dc0474d15d72f3ccb2f57204e668035fe683dafb20445f452a2f8be1a1caacb5fe54088a09214218a5a09c3c2c0de0e1a525f565b40f3db9e396846a62fdcd99393fec60231c93531bff07b02691e1a864352b7cf213df8ba2ac723dd94f5114ac0bfa2a91c91975967852664f10346386fece7cc648e495097c7ff70cc80f2aed7e0b898d35a9c602048b16593f87ce023193740022d822fc726aacab966ff87df7d5e098aa97f4debc1b39cda2a204a2ee4ffc91dc525aa89267533af3ef4d88193c50a113335be56251fce34ea8361e7b67bf6ae65d38c3527be1cffe294a56f5d18dd8bd1132cd37dee870db861db290d114f5b0e460174d3a124487a837c2efc3872f06e01a32059add305aa99811df12c293f32456c612d8cd492f7a3d7e9d9e59918f5b8b8a0927324c226fb1ef28db67632993490dc0f895e255008de2ab5ce18c24ae9bc2cd85f6d2a3aa97c692bc9b29616c79cdafa06fea7242a21091643bfb2c4afa038d54f6bd46ef1281d45633aa8b384b4b0049aec7b4fdbfa7d0143d42072bca70ac946c1c7f9bd451a7dc83047d5b8554187a2ede0dd581ef81dccb2f89a901349a007471d2f9e1b0e3305712495cfc9075bc72d22bc0e2139d48dec6fa30c2d0c9a58d48e6103e13902599b54d39a2ecd04676396c8634f922ecefe02c606527783e897ecdb2eca1f8310a91de6a8fc5f0bcb49ded27978b6254622c66e2a713ca42dd5343b0ebf0c4504dd6b99fa6e1107fb28c9ea8d66d1f57db530902f3d1668c2e2a870fa8186cc725598c2f95023089be8864ddcc39f72c998f68376a23f580000698819947062dce9194da7f443bc64587df9ea9456219cd334a7944798f3aba3457a8c9790e58dac55ba83442fa2f09caf66b7fe053516406bd5d08148731c8a0b1e7737f29ca02a97eec7b97e0dd5169900bb3aea139374104f4738bb54b286939f5ed2b656db5512bf01850b4b82701dae2d198eae0f8593e855e903cce0a82165b3e2e50629ac6c3ddd46a0611968ccde4538df03acf705b1cc3f8f2a2ec47cc120ddd53758f2b28a49ab581563d3b448a165c3470e813c2dbc71d5b5846a0852826aa6787a4597d93d958497e59f2566acf31cd2ba293886a63e98fbcf4d561f0cc732196a84e51657302c7bb3a08ac703318dc27149f40f27dd5e5665bd2e394bcb3eb1be2131b3bd7ef38395980247568ebee3ee1ac6833d8cde41871ff8927dbb5f926ac4016dcab0442f23588a0107233db5052535af6fb32457c43098fc8df808ac7e0b6c98171e8a24e193036d2ca5c32cae8d8057ffe4f09a145746a57597263fa32e323ad09a67c5efe202ba55812bbe6385b62961e76b6a8a340b91e42eb6cda9c6d8c6c21ebb4f195c706039079a326859ad8b116a128aadb27169a87926cc10c6015de3658cfb1b7d3cd2c234ff337ee507928adc127c31a9db8830309adc43ea71b6040597eca8c503438c0475aa9ecfb151fab641d7b4569c7fd8f96e29026dd624325ac043c0714b846a6e83d39514b5ce9e2409744d291afd8f7da7657c2b06c324546c1e173657346eee34a5bd56daf19470f89d4eade1dea7b72c074a72dc973c50a9973ca1e041cdacb3ac29530ea19ba8119e8909c5871591286d24ef97e1f493301c8710e90f7f4b5f3a5437a6aa98bf8124e80b93c9d1b92a3084b45979a0aef7b8d75a122be4467d12b4f67ab8358f33072d6d6f3054b35cb404788b74400f230231a73832a75ba2a889b5b41e998cb1e76c1a51f20f76346ed8ebceff792667d1aa57c9b7663795e1cd91734c7570f4567e8e895d89d264c0250cc4efe273d1ab36bea2907bff734b9e3d937d69781dee5846200b19a8fa929fccfc304992234631d7627657e86910b61a688e254bbee3cfa0612490ce39346c91deeea0ae82095613f07d34b7355e8dd4df25fbe6b9756629c39a022253d92e1e1b06259165a930a2218519959ed440d703a95f23b58ac45fb06d690079b53ae359f38ebc30785deac904a5937a87c0f57b3ea1fdf73a5c36a881016566cedef44d6766a727643f98a3156b524a261246c2a51ef6d7b4b0dd21b0922d2c8dfc376fdfbe569ef7d81c9dd7aefb0b903228fd04500b79530961e4df4d4d13d80ca1def69c31d7d395d3bd46ad41f6a90cbd8f8e7b9fbb1a1e0ef8c7b0daa7a345fc6e7c8f0c9187cb4325e0bbdb3832bbb68065b26548233631664c6abc5579598d0b349cb3df139881a6194f213f67110027fecbd6b88b91f9db93d26fd090d22197dd84b524688f83f77f96e560438917e036d49d00f8fca9b4d0e26b765429172c8b73264a645bfcddfffab0e26b6f2a293c192e9200e83ef86a5b352954481a68fc725711656aa51503cfa1144ff62ca72dc512f83e852fee2407841f9e332c29d36c0957bc13c2ea343c76d79f7e81263488f58024316efc69d8a14c3b3dfe9ed6b8cfc534887ac7af3db857224c02364de8ba252d0953f2c21654b6bfe73c5b53d90a8b6662b1f0154c450fb308b916726012493bc9ec13c68dc4e5fe021f255a97d5fcf03d2778b1476c41d668ec33ca87c96ae3c6631d5a79cb137fc54c8e7f8d4b3ea20eb27cf7479a271dccfce35dd30a7e6500f20a45ef8c4e3f44e69436387b014b8de03342384c969f74d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
