<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aafb326e948b595e518481899cb91f142af593d3f696c8ee3442b5b887c973aa478a43a71ec7638a95517e4fb405588cee8acbf02df09270e45347a0bcd777f002cdcd087ad9b63a5274dda6d3f07fcb1f3e6e559fa3fbf7fb35141009f2a144747c4ee84fc10b96f7b0948635ed96b946ebb1564b66d6b7720758290cc1a6424cd5f9a929e8c9b4caf8e59c09dbddfff3612b12c21e57f7950138d9401e32aa6baa9d8924db0c7f85572e535930c335c8c5c743a20d9d22109bf71c3b10945969923927b9d4725fb1d1894083151a6b3464cc5a2209a5b78c6d99c56f98c0d6e102b8fc3503a812bef7dfa873adfc0564b11bddd811dc1c600efef447e2d91cfbe4fcad535fe2f518a8539e86b4449abe8a886b9cc7bbaa2fba10bc4ad2daca8de581f62ab4c460db9a4039353596ed13960a4fbd00a2e6fa84e332075e0a0609f6b44440607a38fb9b11f22e7966b492002b07d274c4b25e4e80089c240d2a9553fba46c66458beab4c033e1af3ceac9c914df9fe1d8ef0e0ca6dc2c974374e8db04f01b82273701ad55c11be95103a0b7ccdd4e9780eff4b6f666b789041f6a713ff151e2ee9e1e2c2198a373c8c10f942b8ac078d0ac7b8d0228ecb8864d541974b58c3e2d25f278970f3b846f49a77f814e8f928cf8e698d355554bea05ddec919810799f62f9dd0caa74b6a93d9ffcab7a5a1834c5f0d073d1aa5c8aace267219ca603dca7293e04f2a8a83772f56b2fd9e9eb94e9db6cab7cc00e00b4c8a0609e21d1a7665a66c283413c44a6791d457768b9917372daabcd203c317ab37577dfd5c9bf3c0bbe19e0e76ba71f588c69623baf89b42457009eda943f2b4d1d8355fcd9f143f6dfcb907e1b703364eee7225edaba2981ef4e71483164580f74ff4b83efb146c4bacac525c5f35b7de0b86aa89b9bbc1aa29a97597cc60416f339ce4b34a38000312cb09bf3167bdc46fa1133b77e4571c789ef7fe747ce2c0a7735f438130e81ea2dc832427f1c931d9efa31216430315564c39fa55dfc99fdfed02b53d25eb388795f30d1a32394ae5ff1cd78283f3e1defb0bff03a4ad4a4777f3098a055087844e7579747a708135ec576dca807d366cbe10f17a5f5910f130b8566ec4415f70e458f0bf6675bbdf914725aa47d23dd043ed8898264d64b03b168ba340226ccbea2df28888e2f48b2ebf0e9c289f87d73ce69c9f2a7e04fd11d0a0df827726632667687af676a6f8a6d3e8cd026e2e0b47ef7dfb258a43434c1fe5582156d9859f573d95e7b052494f3835a261c6ce570e5e3f2483dc9ebc0b47589da9ebebfd9c3127160e6a9d7e955852fcc92faa30001a2f5dbb0d50d0dc81b4d07007ca0a0a0ca0b25ce8a7e6904d5cb4c9e8ef43b0c67f67bafa3003495c6a64b35e9723ded16bf3d7ef609dea03fd1715df78a733d47d88e3a18bfe9fa7fefc2e27b0ff2c7584556d6daca80544d0ef3f3255feab886b2c174d10b7ea7910dbbc7a8b9582488e3bfe562f6f9c2b2b414c82b9d4e3eabe9c183b6fa8447d2b1392e9144d3bc9cddc74980788b0341b640647c0c1027b3e660f47c1c4d84c54442f881915de0ddab9f112f12720fdcf705d2c33e7d58691991125259f12adb8e4c12861fcccfb04b63f8b80181aa64b63d14e6edf42d17cd7c3ff26de9267c4e408386016fdb1574a5688afe3bc6cfc927a7f5335029061bcb7a1ff509ae6cd7916470e3778733569ffe6ad1941ae961b50d5ba16ed887951a7b84f723a379f9678a48d9934f53418daa9ebefa25e41387749c28701429951d2c4880adfb175961921eb156f1d1da5d2c8c9921b99406a6da87dec43257d85c87289a3d083a893a6d9b46d5104f71be636f71161c553841844be0b0c9aebc264f6526a258ce9429e8106571a1a96a8f4990b8e57ea4a9482f78e1d10f8e120b60ad8173ddd0d3d813d98e0d7962d84b7d849b7cc92be7514dcfec8c1e92b3d3891bebd30fb5533386593f65161bfee4fa60c9b3c42a21a78884a889f560ed2f3845532d24d0c4caa7fe632345461b7b121f1c3b7fd9de9a2e219969e6a61ec1113e32da7d4a5cb0b514bfe3c91ca35f9ff82b9f043ea9ee18df595ba4e34528882560a6e122ca317b85d695099960bfc22bcbc45014aef1646e28dd79629918676381c6d6336ee57c678aec8d66da15c738046c201bc2233967de2e0f3466c3015681299b3f62a6480b951c436394867b4842afbc83cf4d608b53608391420bb3789660aea3ef9300e8fb3283ea19c2ed21674efa3d3bf1473807030e723818a3ded61a891ecc3422da11ed8dda183844a20792d211b74074143ee173404fb2f6235b49cd0ecb5d52a3da335a6231e1a2c25996b0904d2fd512e27a57d3b6cc9ba2b5281e063618a6208ffbd76e4a882c47467231585db9e74c05e401b4371db1cab1944793e8e4b7067d83a037f4b961b2132e43a5fad21110444d653c54bccd7c46198960cae2143f138eb239fcbd750770f50e79195d1610795ab215ead7f62441c2e6694a3346e7f163e1379a4d0417717c8d0f2c1743f3b968a2428f40e287f48fe76e4fc502569ae52905db3e04087b415557cf3138f269d8f669b27b934ee4693b458c172ec212d421cdfc4e7bc171376519071416b23379d255062ec8dd938559ae54f86f7bc1043d9d0df32f98b773e813933ffa8d4e3952758ef0b67016789cd840ae176156f70b98fbf788c397d4833fcb81d9a98ab262d1b58b2b3dd585e6a229a145dc715f45cd9214bb07f84bdbd689ffc8d439ee3ac80c01606fdfd636bb26dbbaf14ec45f7f9f8161452dfbc8dfb77aa968d7ef474ab40c4f93ca1c21b03a1b5453a5d117fa9437cf43d0da08e129b2ee1cee78e4c7478721600feea78b43d484bac1a9c8ba876f9e6fd0d6f6f6e9479f063380cf77dc66d97e9b10958230678364334262cdb0260321f181b5725e2434948b4c942331e964dfd21f90b06172fd6f5b089932a177acbec914a883b2d2ec6e9e48938901330b526a67b404b8a33168a8c4f0ff5a2aa0f84adc946434b4eb059e1cdd2b3431f247312d2f168c0b40f0d03dedcf6cd262f62d55c71584ef00d14c42341143faaa8b78e50c3860c894712e84b975b6a8b57de49eb26d7327e7a0ebcf9d2acafd392cd95d4130314b15a3c043fc3f1f713515be51b3fb7b059923bcc53ac2d997072efa38744bedb7b81da086165b8dab4f522b729e478b5302884b29917ac315cf12dc262e339ea7aac6ab6dbcbaeef55e2ba3b3f1ff02e5cddfa9c20175b6f72cd898ace712097ca435a75a8ac8853cdd343ec3f87400f589bd6bc2c0c4f08a49b5872a35ef00c2a8067745073b7ca958b083469fdbec222e312fc3eb21693f7a5fc186a5f6854c2542ac52040602e0d936462508be8b84d0a8674316b55e25da68c730a8e97053924f6373e2e493e0a1245bdbb3544bceb4fd43d28f10b5ae3c4c907d10bcaeb514501e43b263b7c629ce0180c463661403dd11cc83c63b0ada130329cead5dedd8a16dc813942189cea77799d0a735cb39d50740ab7144512cf7865134c828d505c7acff49c3ce9e3674665e68e79dcbae099bf68f0bb136f74d75675a1d5f5316772a7b876ed7003f76cf91f0d81a99e779d357ee726ab16e7e6a1319cf8d5fbb4c886446f7fe590144a540996688359ae95d645b711a13f86b08a79a8496dd1ba0cb62418909276f3916233212401a86a387a30d2eec22409affbb902e78f967a9458e832ea851e30d32efecc3eb98b665f934745129b8fc6c3a1a58f7b26b3bf2df173ca9938c329aac68d6a72ea5af511f17eb2edb3097767989ca1533346becb1e8772e7f537f5e0eb0fcccea201eb280db062df5b90c2dd70dfa5d0bd1dde917600aa8767e22ee7cd3728e9e6b1495d2380d5771ef49171869645561d6114ed03368cd4ce8a6b1b98ff959a684579d0e11860e5f7561c546ae311d5efa98d5f52a34eec34e116eb38172a3c9ad9eb6f541862f233c0d51e92ed3a6d6b4058f97586de02bf1ef65815e68a2244e45e5a7e0054c92ec96698f138c3ef19acf39be9fb6f0a29fc3290e5c43ec026a3b23930c942984d4dfdaac1f679e805e5222fc9ea71df21213bf7f1aaaa178a78fb15e79702a98246f91a6e709ccea675b55abfd3091279f1095a20a440a542c4da83dbbc8b3532de134cef6cf82943b08022ace7b29303b3199aa7d803594e98021ca108f1c9540cabc5178b02ba7923b9d316f567d74c83264b975d7a0a630bd9f86b0f22d5949ae2e549b3ab5d3892e65373e4be93bcf7e3782f6a79bd8a57aff6ee298ee4b1ac910dfef9e364f683c7cffe377d6d283b814c762ed902ced02fdf1d6558dd8039c7e18968910b880355b1cda53a40e1d577a45a02dbe5fa5d25437171e7587cb233bca828e5dee1100bb0e6986afd85d71c463c5f953d1c0129b47882c163035625193ee83451e85f1622001dc33b2246280d225f594f93b22267a0320ecbebc1ca461909ac8361ae6e6f086a3068b376bfdae2186d3da73b7e0c01eaad72939c4440b9a5fa8930a3acbb2cc160fd8f902d23e2e6b3d1014a9b71e709ef5c377ef04173658c72f34696a54eb0b41c255b84a28954b481ef6309236fcd6f0c1364fc33f5881bc3892c72af6715b1fd410350b612ec0e0361e0da5cf8d5bf8e80921e0a628d7366e8beb6e2ada2102487dd1f4ddc2ff579bec7c38c45c82b49bcc4471e9e237f138da935443621b1edaf47ae2f669cc3529161144c4e7ed51c939686ea5f20c3b7ce8f3e7a77768e266e61a9ba440c8633efd71ab58a1a79590c953194ccfd56e41eb0f20fc9cd5816d5cf61ee9384cf3c4417260098b8c273456b5e54e029686b8282fc5e09c9beb2b695f3cd3b03a0a6ceccbc2dfa276ca5018923ff90862cadd5f27f172ca99c6dcc6a5be4b9a8f32d94a32c4654ca6b22f55b1c61f056271dfdd66f7fc92791175628181c5e90add18a21c4e046ab0e98f8fde5686364653b2674764075b29ca69d834e67a3f42dbbbc3e72961f9ab1209deee9e8c008c0fb57aff773d28bfc2312d9b722cf44a5b66cfecb95d266855ce4fa3f253899daac50b8fe3b219ed573ed3c3b76efa300b6906420ff78e813ca1a6f8bf443bad9ed213b072d80f36a66e67388237334e89a20dc03ac7faef3d8429840948cb6aafc83e7ab8a764143a9ec6feca6855c9a0a4a857a08109e95dffa0db82c75d81c50d33c782a0a1c51d31e13c2f1e0d59d86c6f3bf60735a3e77c568371f786ab873a8eb64d834e5c5b220a957571d90dd9561defc94fd86438d6cee2a1e8fdc81bc0c44d04b37ac8512b57ebc6876c63cacd6cdf3d0a7676c75aff9864e21801a59c6409becad227f5e4851298dbe52ca641bb713c9893c4d9ee57ce3e757640d96521022c89cc2d3ccec1c627c0fca6a5ebefe441d142c33b0348312bf6b80e104a80fd72f8bdc8e62afd6278d0ad77b41e6fa11de4ece738f3ea88c4967f3f88582e1d279cc7110ca8249b739b35adc4e6c9f10ae16a3a92f4cf55faef99dd874e5e01e494d677be7ca9901028c307730a57210b5a54f2bc9346c5e1414ea9a9258671728113c734a615f70b21eb671cd877f4d1e2467670fb9540249357410326e39374ec090eb5fe7179531c5d4d7998bc93498adf427e55c2de938424985521212834ca90e7f61da71c8b54e14abbb4893b5ee79422f255ba5f6f4d8fa778bb73335f122a693a696bdae97637d5d2a3ff8de46e802f4d0a72e8aa5b8db1adba3edcd1b1c945eff24ead7e4e71b6ff80f875244a9ede151f86148ac679386b9a720bd0291410c4b727098faea338e2a2792cfd2d464e13622ce94b2cd00ebf84c2dddf82886b6f004545dd4b96c3be8a8d4dcb1595098b7a2b4648e9c93e89faa0c3d82680b79b89491596139f9582fdc2e0170cb38d171090db95494c574f953b6ffd3ac81444957f81dd9de509419291a6aa90ea23d097b7d7d0e7cab25c645f3cc205caca5cf1720cf9f4ff7455490c8bd557112b2f0b1f64e19fd42fe1f1dbb3519452043c7b9a0635c9ddd69736d561dd0beca3f7ca6df6e824f86fc602d6c3f81b8bc16c839b2c836f0dcee48a4d6b9c0f23dfda860288aa527755deb3605c4443cfb525ea0627271634056972ccade2668b54180f52f975f76970669b5b7c08abfb235b600e1558d5c9309eb3169ad54dd600a65c5a814172c5caeb65511a5a498e7444a1c9d9c52474b8b77ecae05edeb34026d052c3ab9c7963e438867cc89ab9a3ff1ec90fd0499744589280a35760084eebb038ce333375114f3d3b85a979696af4c261151a99a9bcb7609cef84be9b2cd2d15ead3c46c8721da628a13c0aef6278c4c53e141f5827e930c078ac2d834fd784b2d97857838bbb248c0bfdf67b24bce134f0b170c0d1852bf39dcd42478e52160b0ed6f0231af8a68f01e19db3eda2c4c8a4538c6d901695bbdc8934dbba6ddc0abad330465fd01ff05887078e51f0e30e0287266bca0bd4dc07554c9d7b83cd79923aa377dd131d23aec3aee0f7149d683ca30572deac2bb2f20cd5bf7ee88b640f2bc18f990dc85933cb377f66eeae6768c94d23439fa92b20890b2b851bb24bc9f8afba014d50517bc2858dda0ec818a956933e7f648e2e58d67d9a660a73b09a74a864d1dc9a90836bbe0d02eb72170bf093077f4f4c834352430cfbc841a3224ef4b5d9b9d3707db81f8493e1efdf836044b94f6853871a9ab52b1bd94bd35f61bc126c426f875ff835db9e33e653e3755366caa402a0936e98363870462c6a3a16f1d37b1e4334484d514ffac04e1024ca538bb5471d89e7207f60e9efbbd057008b1350e5d1c1ad3503af74c01e1d5c77b9b97389bfe4d20194fcdd35c902aba06d84e7685d7fa362b25a5aac921082121a2539f13526ed3ad5910fd5c7428a2985f4ad18cdfb8310764fdee8d45f2ec14bf2e84491ceb3c318fe899d800327abe0b7100616cb2ab99c4dc9acdf3a556443094fdd97c96a1054aa1efcf79ffec154e4e10452e19033c323df6724277cfb2f1fccd3832592ddf91c314f1d1f6cd7665756098beb5695329c30636eca2b3649e6201fc69a048ef92a2bc861d99d2a6e10a05b9dd780a1576a7a627504090294ec4f8839ed7e0e98120a2136eff6de1637f05316e20464e741dc2744140900ed619bf461f537f55886a966a4ade48e1eaadcced50c6f70dcfea80bf1c282430f2bec92e5249eb210bf7b23123cb5cb7e68d2c9e0a616709e7e483cf8d515e3273f9c41255de532eb8f59829bb0c118245f557ba5952050b8976b0365acf3db52bd654107dce7e063315c00b247300f674dd63b7e33fcf3e13bb492bfd879362f1d9912654623348a30452ed4b52a09ac3544fc39a55d38713f350e171ccd8217ce732f58a9d2f23e5d72e0b0257840999aaeb7f5a78f7767bafcbccef8aaaa7c30a64d7db1f9d9e5a8b94cdb81da4363581282949e784d455d8ca57d88f9469817a5231b30418033ee91b30897e9ba44a0b4c997bb614fc1fe9befa65400b2673b68645c15c6db2fe34e6af54be29c81f2d48bdd8157c47f1183caefbdf4745b100f1ed8afc98659307f1c9ab8c3d40c73266d4aeb31641916d00f00575b6d690f8adb07828157279cb43423efdbc47796f0e49191c52a610a305d9219baa0c86bdd259d03c0ced6707e229a56268812e301351ef85a4d60b9ec3aa0b83bf742d5fd8ef5e10eb44cf137d214201d050f116a010940a67d926a937eded1511df34bfc7ef34ca583e504ec309b683b239b0e1545727974c8e08a6034cafabd42c1b2c59a5530b6b7c7d7b8fb1d089b3790c7a4e8ab768f8c68daa5c452576539ecc264d6e93d2059bb3dff25277536df08480f050a77fe03f2815b672b1f102f88fb496723062627c07798d81db2cac1de08e93fd700963b9be924b7f035549b6f8be2468b88f99428a6037291c90b287d91774ac5a486b4291aaf43ceab6a569781c642adcef02c79692fbec8faa2fd8779d547f9d453fbf3f8903f1bc9f4e992419acb177fa6a53b16927bdfb6a2d2bc60e0132e64142e3de411b68359b5b151196702b206bd1f2fdabc20a4e0bcdacfa251c8f4fd574e70cc2dc8b6b8068f988993a921dfa3556a43ffcb208f2c229ae1b5a124b17a361f62da2f53ad9a148ba7efc42811453b298d71503758ff208e040f556867bd6eca67ce897e363db8dbb65d0e49d2ee284fc05855e1bf25092f5f55dd62c662387aef9a9937f50c9c01f83c399c979b6d4e8cd76291f18b51c00fc84ca25b5714d8616ccd2a691711306aba4e3a37b31fba210d4f3eef87b72c520d804391e647dfc937723f2d41f1b4dafd2b4494b12d6322c05d4a8da9e1273eae978f9422adc4bd25d270c3c10c09e1f29fd577f0f658993153ebe5af5a4c4f2746a2053c981b031b65bdd1f04f59407ad976f5778aa21de61d7a2017b5de6c31202bd95132506c5d4bb2eb1c0878391ebbab07403ecf4ca609495ee4e6c695fa12f8147caff815afa96be9169b4301b9978cb4e32b15bdc333003043b88dab1584a3fa5641276a934080a42c6773567fc638420c4864f99727b8bc62588a709e669d32944d8134aaeb13cd565c902e73c2cd60e87ede185af2cbac7d1e08c487744be17b763024c2b345762f2af54513647e793388166c9734d841843e2b78e39abbc8290d77bde977d0cbbcd0e2a5489252f678667bf3f909c33b028fcebd5e9973abd1ff0e7506e6a772d1ba65f075a74655c9685a656090b23dd5f9a912977c0f757fd554967601b41c1390d8609db5ad9d3fee4b95911b3ea485209e69288109d8c682817fbfcb160bc05ac56385de46556e821dc0c2309dbfb38516b05451975920ee0b9db8af1ae70ff1a7c3fbcde5410c20996ddb2aa14e20695e7d883d17d0fe77de25183d08434d7d3f2641208b1543fa5a5da9a597f3ea2783c1f6ee3fc647746d2e48b323df45af74c928baca95966f96dec19bf1c005cc8b6013479247ddeea5c98d40fcb9ef0a2d1839ee38f099678a31fbe271869c330711d73fcd1568abe2d2da2b419c0ecc442a28fabbd9cab79ab01b8c421dcc24608cb899fc1d38caa0ddc22fe7d8a73bae1e4e586b75660126cebfd0f01188407451b94bcb8da9ff910f405e91247e1e04498a2abd22463d474cb9d480e03affad97f299f2e3d0d8e7bb6e2135633c1a4fa05d76da827c044309ff0d14d46f448d8a699655586b853f0463546e4a97f2eab4f9c0d3a1e91dab915460fa8447a9237740a57fb5df0c996964fda850073458fe1fda30d4470f6c29042d7ba7214d30eedb23396bd576846d0b43336bc7c387f693d3b115838728dff4f6dd03a130775630aee68158a0779a7f4705b60377716e210acdea68e18b4cff4070fe75cde513ca3a4b314aab5f10ae68b23fb73eaa1ac538cbae8060f3f0a1702d2914355705eaf5df1d876b22f13156cccc6664877497265579ac84dc6d50c0bf0ebf8fda0cab143478043ec44bf6ddf1bb2440746c3b25a1a244fbec9c5c718067e0bb8792083182f21fa961b77455f208bc202b04ae7af0bfd67e99d8215a2477b9169ef99032feb4d7e8669107554b957be517a128254482f3531c85d4812d50a12d665c1eb933732c3c7c3decb69deb38066c9857335509ad351cfacc8f86cb60191f64798d7c96288910e9b31379512b2277f10da54ffe6072867e32b407c5de02be08742aa953982134417f8ba31fae96089fc772cf8a1560c3bd86976e8a7235ff19186e5a15e4bddd6021569d4b8ca5052e3099f1f49d9d738e443b670d2ae10e4e7f742548b76ad646e1418a8fae9a85d688a0131ab9a775d85153c0e8b44b6fcaad3dec16c8d0af3266b7167de0e7f878da9b5311b43c256c2aba06c7197a0019579a2c4998629ece8504b4a557ff14b4a1093ef50bda85b897c2a6b1f836cb3f349ff31d5f47c1dd0940eb2e16a9b646e55350acdb30c7ad21dadcf6873258efcd4f102b6111e2f90fd5e6ab8b1e04cb4f49de217d5dc07d5c8659f07102a609dca96875e656d45f5d0c3fa8e999ab5f3909a477d411f5a277a9da4e8e0952308456cf5f9e497f4b05457ab530e2f5dfdd991ec7138ccc68a86ace836ba9204f1cabab9a63ece6c24836c2ea0640c5c139b2732a1a84cc423c18079fa2a3d8930ee1bdc020d8d616f480ca3ef847bbe0a54603ca7274d2af398bdc81fa1732aaa6a12361c7acd7bcafc1146bdafb539c91b3250a7bf80279a046f7d1d30dde4bad842dffa6c18e87cab1d7eb0fc21eeb0acba2df2bc1d04fb14e08cb639c49531f17e986ba7ce4cbfa22eaaa3cfe0a2067f99174bedd9b37571b12125de1c06cb4d328efdc973a557ed178d69f5bcec75ae59e1ff3e6900777fd2a9e825ccfeda4fc2df3d41e0d14a1e3e47b185b466143c2fb7d40add61e7a344c4051c6547cea7605f61a37a5d37dd2aa2946ef643c6bd4bfd199b9ba5e9385f5ec3da34f00a24b80174d0c80e3945ecb83a74a0c43f006f5e1c83620114ff298b24bacf7d255400b72d3c75a1aac694486aba20173491cc72643d3749e9cef10e96c9e42508a9388a6c20e77f62efbd5ea542985071da291812fed6d2d18cbb8717f7357cfb43d6b4110217c9a706cd5ac433df92b2101b1f2714e5ff8930a6d53704dfc6ec7c0b8e64e9638f4a54f5ca67017bcbe0978925a229fadbb7da6a59213c13f120530a38be6555ac06cd5c3e3cb1dc57f3be811ec99a1d72a5c08d53180193e2ebc4be795d935e6fd6562b6610d8a347854e927d4720229dcb535f95401b5fbdee05a43d5654766b086f8294c2a1c56f316a79ec761585498a52f84432faf2d05ae984daa8913f04d4b2ac9dea317ec668b8516606a9c794d520a92327cd5178d55d0376168acda16eeffa729dfb411162aef6a1473bab52d7f1ada308362f75898445e21de1d9a26589acad74da0ced509631a25191f395f3e923ff0389c61c291ddbe3ed93c9013e2fd2296bb211a422c1789dbd339f10022aaf4e75d3b434492d5f6488842ef531b5ee9a2b644cd48eac5bf1ac4614ca477771c7bf20b650bb62175b607ce6a84bc3948381f069f1e7ea261517a4e3fdae4c2872b455819d38e598cbee5713e26c6b400ffcd3fdbdbac28dff01361392b1552f171f53d71c4b9264492d642a84dd8b5d00236ae2b071338e8a22b5268ef62cea2399ae221d0b1c364166ecdbd2b4a469d51a63c3faccba8ccbb05c5d2d2e0148fd1e8d7bf9ef9b7abb912ed3ea21db46e6fc6cc9e5f382d38c56babf798c79d7a23172493a3bc0a960d00ca255a5d2065d02e025f85a76f6b73b38c8942230516f0eb6ba784517d591b17d3c265a6c40bf8c4e5686d63e156c9c1b3c58d26f423769954f6698aab053b766f38d63653cc16eaace0bb28c24a0309cc65e7e1a60da8994c5da5a8c7fdd18b069fe973977f70bd3cf10ff06a003490f9921f353d1873c68004a396b5bfb8bcdb12c1ecfa5e475d4bf756e2bda4ca4980b2d9cb306ebb16be46fd1140aaadaf85cfc07eccc6841d7b4dd195515c9dfc16087e3b252d452b141de777020f5d77a2df6ddbc59d3220920061f131c585d4d6a2582fc22f36421a469050431478fe6b699f3ba28961f23e0244547eb4f526a887228f5bc50555eca95cbc99243bc0aaf74dd642b49050b216fc864d8b1c1ab1c572c3f056e24b764f00146d8066b87d8a49aa8072a3fe942df6bbb54b0f7829c7aa9adaa10613381aaee4857f5e8d7a79cf44470639a5f5028e8ffcdbf368b93860a6f020d89ee5896e3b92636801f3a7e0c2ef905b4a81a6a30706110282dd636e29282a6c5e6d4aa8d421c46994cf307c56b4acae79b675eb7c317d4011d3215aae7a76e6f9d01c02cb0d498abc99b0d733376a579ab8bf83ccbfd2f476fc13e902fd7500b9fb3641f4e61030dd709cd5d2a41b9f1f11b3b942b4fb96ded8c06102d5df48b5fe905e565c6316feeadd4e50b4fa8d53a60bacae2883d21750307363da91ba869e2e3197358d778686db4a86e4e18a97542bc4fdcdabff7ed747dccca7891efb1f85e75d11d93fa38e15b011011e21e2f1dd2e0491dbb29a3c13f8fa023d404612681fab39961c3e2e71fd2e461838bf508abdbb489dc34e37606d3cd2b4457e36281b2934275e8c8e0c99c7b0188853ffd50bca19d37bd19c094edd9f8110215abf53f1ec2fc40cad9c885b2f8991ad45390497686469e6ced4ed091fc1ea1955b81cbe17fb65ef7caa10192e127d16cb81cd34c805aa72ee997858bb51e2c9c65cea44fe57c3d9d8871b49e2c92c7d11d610675a36dc3b70a13a946abc7572519366c6abd36aab2390a774fdc179e1897272abc49155f3bb977078b9b3189ff2234b723c3129a42e90b09efcdf19cd738ffec164e32131b4dd8b6b052d360deca0971449a44677b8b14af4e0eb548b943c590c1999ebffc4ce9959ed986b73f3b69e049f25ed96c3281bc37c305aa9bc9bdde1120a9077e2d245a55b0b96c2983d7e2975a99362484b9df558214d4e3f6783831e9e244b36f7b61e2f7e238a17c088fc3b4e540daaa01805d389a2854856ae4fce48ca99688b1841ff62f7b6e3e9866c3b2c3d0e710c2a3bfd01a93d7d8ce255efed9a205524fe3e4a21ca04474a7ad5ce4b2d66827ab9355cafa757440687c3de0408a89d695340b79205f35f1d3662fa5a47093b51564cf8be5af6a406f79fee1d002ae259a77b0b1406fbe8c791dafafbe3f0069e78d5fe955064990e70201cd97de6b12fda2c32ecb7fff298416c74a5e16aa0288f5c6435900fc4b1259b8de56b524ba2ab477fb344c01e7e14bb5956d3d8b0443247ca822bf9648ce46139d82464b4104dceafd49eba294910ded2835038c41d58ca72e9af74d48222109e3f973008c55c765195d37849fd4684cc2fd9c8a67ab2789805070df71d25a17530bd1f3209296caeb5e8b8fe58a17565330aaac3bd1517f91960c7d31dd691716ee8ed541aac794cc0c966800b7281a5ecb31578b36c062c51f0c3cd4acbd882df389fc58817e39e8ec70d6bc608e5798c4da8157f5c64e3b7ee9bc92ac7efbb4352a34d02223531d5d446cfb594e4e34315c2ba85f3e07d9c50afc662f8451917f926b65a69b24716764f2aeebda33b02ea634e378e632bc70643b4adaf1749ff04c710df679f97409542fbda927dd258d2bb7bec9b1b7552a94e803431c73502eea3f25e2008f8cd0098fb1ab9d1c4a8510963f56c52a109669bac1063de47d56a053ada59c5b3e08ee0ea99f22cb17d3354bf9b3e45ec32007c647a189fba24060b19f5c8fe9fa7820d9cdc54d7952f9677e6b7184903d0d753547035d2ee4c52a8d6a5764a482faf81a7e0d5f2236ceb8f5e47a5c9cbc1161d756ee9cb1e42bb239a7abbf8674d01cb1f7ec6defa4e98e0294359c4505e9bfa306e95ee5864785da95f71311d6767fb2f698463bbf3fc29ad6e5dbe92d8bd083efee9dad3b0048aea22af2211547e8d9bdc62fbe8f8f7814034ad93a8b02db03233032e1b1a9e67d5de1c0f8b381088a220c8c6295b3864c7b9f5928a9ccad10a69a1e864c377b76bc8cf6b389810ff1823377250c1af2030601b83ce8b1511a37d60bb78ed7fd2f86c645daa71cad50a7ae1437e2d616b0e448bcac70b578ad452282be25ae55be0ce09e524d56edbd099d7c2988bd13d127147000711f327ce515c0989e90957101f426afc5b759c53883146639acd1317e43b635e34eb1070ce0f3faeb2b3685604856f22a2bf554d3054817f43d06ef7a2f531eeb96cc92df1346bf36d463ecc9baf13460b06a6d586df2ff407259827d4da34472cd12db6da50b5593242b14c266e15fed78b10ea544f83753d087e64715940ef1e2e78dc37a23622c111e7414b8b8159975bdd7f6d9090e595210d4d3b78160f5d2cc32e3e3636a55ece6514576b9ae0f1a501b0555cc000fed293460ed5afb97f3c7ac8f659ca00c5114ca6199575d695ff8e3285d00f63ea5fc054931bcaf56044f15ca26060b5140d44061af633ca856b90abe62bf6f724efcf89c0b521f097ceda4b54deab6cb9afc5b4af028ef0ee6d3068c6ad39c6e7b906c5245cd89b7d4a871096b9be8aa48dd9569a8b8462ca9b93471856fa93901affcb048de8519b71fa562611b52057ccaee545504b427e848319b9095849b8c9d654b6c60b96e562c31d8bf9931a87fdb5ddfb6521a5191950961c1da3f1ea3f5691fa52aeab95ff87659eae16c32e916677f3e735c2f0a3ab2c2070fca2be28173a3ba95bcbddd41505a7e361e64464e0004a81f63dfae95b4e7fa43d010fa9eece06b90de3d438592694cb5cc57f2d5e0b37ca12c834889a90b13fc5609b3ff9248b2ebf06bb75ccedce63ba1c4dab54adec4362b25f0fe678a17e799c3501837b636461d49243b6fafcec630c4ee6717a8fce5453caa4d3eb6d1ca7c98f9d5c855fd835c29455aa5189ad98435ab15a912391bd431a957e4f9f6cfa81061af2a8f414b36941b3db162ebc168ee6f2864232b48142744970fd423eb19e3b0c381ba54fe7b17c950fd39a0098f68b176f8198c22ff99b226b3b6c3edaefd5f0a4b5095afe6ea2370f5ff0355a6b240e9ee3e5d29b95d9df2a9ea0c3460246a7cb15a4032eadd65ffd5e2b56ba63ef39f46629a6c4308f4007b2fad3af701373847a737076b5598ea5f2f6b568c5bafe83124739ad6252a7c836634fc416c990c58fc654ce69dd6bfedf2977473eedc20f1555d414d892820713a8a03fa0f5272fd8d9b8af0da0630ec80f3da594c7134f0dd9ce5047a17012bb667d3a84c4a045561d7faa3ef176fdf0e59452f1e87b4ad4789ff291b2befff348a779f88f4d9be66bad2e3bfb198f4d199413bcd2970db50fb395426869accd844a173d623417f9899b37ad63e38bfb63450a9d625e209e1511eb48cc90b59034c1b93ece80401616164cbeaddd413192a73ec3023be00827be3ca6b5fe4f48821b19e242eec097e4373e9170ad610057771e456c7f4072163beafa00f19546cb6e54cfd1adc61c4a989418810178caf7e66fe5c49be05abbab88610c89d755ff3f945891ae4e632c51a562175a511cefce7e5f7f2c603a20e23f45b84bae59f126472bc3b92a861407bc1b02d87d50f3f7d67a4c4595b223d386f5a7c9bf02707b4bab705c6d7f9a35c979860dcaa189160a52d6454becfb2708dc8dc7469f7fea779132832f311d2b402997c993ffb3d5d11a7f101be109b65bc442f832bbbfacbe1b857fcb7ffe0182939b5516fc736c6c6c75d3488a5f593958d6d43dc16d8de63a9b170dc7b18e69db3d5c97c39efa1c7f329c59aa854e5aebb80042d3fe1777e2288936d4b5f725e0ce75c74366f5b1754ad7dd7d7b26e22c9c82c131a0aaac70c583bf7b18f37b4504690b8ce2cdfe8c43f47054a113c5b392afc32c58a6f13d7baa951bb52a6ee5588974feb3fd3524b88d1fe46d6d3d0c4cf759c3b2f0456d2f4b4d999ddf9bf2ce6faad53bfb09bbfa4512ffa5a72dee572a08fb1d81cb30a74b315dcc2cfcff92a1c981a4c78cc51cdb75c356d786f48abb082091570bd4d2b687a280aaefc087e1159a06452e7336e8dc752dde7b93fb71e62af3590a02a9e135fd50bb9cf27e6709d9851e7137100b95823d99975c00507e5694a2d4dced13abb76967e3c326c3b1e3766937042f35474a3efd6257d1925424c5bea5c58d7a4816eec88452a73a276cc2ddf38f3438dd227ac1f06aadbbb5c80ed0bc7f99d567c3d23d1a55acf83350a399728d7fe8c715c26e84228d45cccd415b0f6d50f673171db14cfac73fc37c95741fbcb7000e4e7dc92dc91d6697fdd451cde39fef2b0f48efb92179781edf694133f4dace2e0f651648c863bb7eefafe0b6ac81eacf8a0dacc2f78d5f9dbe058f348765573fdd467be5d788be53dd2bd491d0b3785030167ff776d82d9b96413ebd72d796e65053eb43539f397f1eae046033d4f5f32004e1a3c36c710ef059205642b46bd33147013123bdd874445e468447c3f6f1aba4ff5fc54770f25cf88fd10770fc628cbcc0c58bdbdccbee76e670b7be94f97cf6fa53b22cee49fa61bb276bdc4c28ed82ed4fc0791d11f8b5f182f77bad9814d8ecfe5fca33356b8a00575b3598bb4079f3760d041d52acc5ef6915131fa0efcd8cc81683c321e0cd253056cebde1f2754d0513d2dbd414ffbdb24437919037a9ac1e0991bfafaa2772e00e7a3ce96fb18c07c677ae70956d52705e12caa75aeb46a3b040df3fbf002b7005a7694f84833e580f59c2eb3509b3761cb0db220962a495707d467089720cc285cb0eae2b6e365d0843fd2b9fc97e69e2dc5870d38ecf14118737f2998161bcdd186700387ce4d4ba52aae0f78c28061600f5ac1da78da4f3974f866656977ea2b5314da380b22ca30c97daebadd4f0e68282402969f3b3958d337bcff424baf0c0db3286bc62d14c1a82995943b5080366d8556f08fe0fd0d4761fd5fab72c80fb9d891935b53da1c063200d91340e570e19c2e38beec448289e0607b2d58bbebc900b130fc21caebf95313ec498c26ccc91a3c37699632fdc7a3332408f2364d31ae65f44a1de7d5e96f229bd12bcc5cd34e78774b8e2f87bc81e2353c04ea70f19518c2209ecd9898d868ee72807e93cfd81590536de7fedfdc71a335b8356ede055c6b52442c0b7cb23b8945fb1297e77fa9b5b7edd4b85a68bfb0bee6c7d8ce3770edab042a9fc81616a83b65099f870e6429ba9da9eeba0f537212a74444f1664702ff2fb9ae9d8b49f71bd20c081c0bfbaba0816e4bc0a2a1c38af5f2acd91ee37a71f3912b899c542f55f1972413b0183ade50cced12382693e51e75119aa77bb5bf9d30032338050bcadea6e70ae78d4ac359bf446ede76a227f05d9bfb7ec28956828173be445464685c7635cd1bb4c3831067ef7bbf435e552c564a4748938af1fb2b5f07779c4d19b4bfc129246a6f867912742c76522edfa5785c928fc4237e7c56cf4d9c8c587262dc2cb93dca846c56f78a66db190fd555e15a19ed578b774ea7c5775ae81a0822d2d1e509b9be2745445a4cd21c395135443ea56c3dab83fa665d20a3896182707380ff5a9451ec20dd6831113f543c379fb0a5a1b001961207213030e460da4ac50e12324a70e1a765fc978db0b6c5af9197063da5976d761bef10bc509d686b50ca7ee1134e7370ab8037574dc323e47b2350bd59c34608c741731ff03deeb836e00059f71220aeec0cec7a21db34630714d6c7981c89d939685c9720a184fc011370f6983b7694d9f56b1d496bbd55b73fb023fa96913ded73a93cbc6fbe384b60e7f4ed40a0ba75a0b346778d495383419aec0edb687eac875dd23cd0725cba226c3ea037afc56f14f69771ccc1ef612032d4339a295ebf3ce10c06bef13b9312e6b1621a1fa17f5836f37b7b3fe45d117e09ca75ee8269581db1c422e37153c87afb434d60bbc53a705af2648d2ba5cfd1401cf666ccdf284b4474117bf2c284e7169df8b27a0a1eebd80c106250067380740c552ed1a15b94e8bf284feaccb106331003dd6bfd7c0931397517c62556d9556b03b2197ab841a93e91b1140ef0c9d974d30247bee028d754c76d4a87a046b90d6d179584d416b36e6e15519089f849e084fea9a1a7cc4a0c78661499b61691375b5b3436f7d2daf6511c24039f086ab8a02612c7222eeca8e75783aab5cfa669a0e1c9e55a4c52c69459463a2145cfc48f8e4c8bf6e76339da801feb8deccd6f2e68b69c7b5a46111e901cec9db22fd2ad23aec95586c66faebdb6825f28bb08d4c2c4d681bc9121671eca55d23b130844abc341589935a179b93a32b743a4f3408f00890e4848aeaab39b9350723a41cab45886675e44d948dbb97b84dcfcff90f41f90ca9b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
