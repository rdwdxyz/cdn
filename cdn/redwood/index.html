<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"63cbbe1bc57f8792d253fdf2844baf7161e953f5d847af128617d8cb9950d91c24da94dbd22d8b9f5aafa61598cdb48c194874dd5ab8a6ab337dbee52560667b63a19a5b18f856d6d565f0f57188cbeb4719af654d09736c0a1210bb7a7af2cc896e4913db97bbef0565a742d931ac44781da78d32af9df8d78dcbb89241b65dab204d2554a4f2b371886bc4aeddcdb49c43d65448f982f83b16b94a399181492dea2f46e9d21a45986e02f6c6991c75f231c967ede2781cc0f4448359b5119604518c0927d26011e57bb304ec76692de92b88e89bb0189a0ab5fcdbba55529fad3dcf81f7ef2ef264c8c90320f4f490ee2747eaa5c55e59640a73832b280fc7ae95183a0de201afb06f592ac40c46d703b8e0f381c81dae4b0ec268b1e0215c7addec3736372205a3dfc908d64e1c1e00ee4cb2012699d15312451f679374df4a32e130e448971b211c17353285c3172ca263af8b676c0ed73e725c0e84d65f2fa7db7a5bcd304873a2329551aeb70b65d7d78ecd1ff58c6ca2eff1f224187546a0a8e036779bc65f7aff1a5899717e6e2c03b9c84382a08141fc599b73f052338072e03d6c73139c8d03ce627d712ffcf415db82d126ff087f854eec89bb60bf5b04d8e05051560b8af37841cf3da7b0b8cf67c2c7ed7a268f37b9e4810484bc883afe89c49a8f4f6fbbd52f9215c0d3bf72f03e9076d50b3fbb2d45769933aed9da7cbdbfd05df435347b3482aca514205ca053463a40ec9c140389627d0fe6eb75c52a941b64d1f771e2771f7f5602688a460481d05436afe83e3b9bfbe3a1420e750bf5a885c445bbdef61ae911aa850c3c09aa23a1eb65a2fb7304283ee1a85d041be68bc8729ccb6ad2504fa9de05949eaeb33c1155b4688a976b9521bc51635eb6bc72959a7b9e165de01fa3be6e5fee3202dc4dbb333a6fbe843143918bf9ad65e399fc6fdfce65f3dcffeebc84ebfe69fe36290cb462b7680711bd1fc19ab7688b881c694e63b71bf0cca44ae6ac18e02c4b102154fcd4888f7bca5f010b876dda27eb2b99197e2338ef97a58b41ab855c6387db6b4f852520b2b2f9d0a698cec5092b043e76b4527ac809ed1abe5afa5be709aa27bf2a77e029d127e72981914455143a39e463777786aac44da8bfad8c747c31b77a023760bf7d5c86ec409fd339eb50eda290c9184a07b2f1a8663aa8137498357dd89020d78ba2dce3963472d5136cec9ea208a2c8d85f92654a95a9a9844a77cba991d58e1badb087bbf6f655297fbaabf3fd9c2873137dd3f4d1101981c18fcf1421455d4d6000dfa7157f4de52aa400dbdc7eb2c3e8517284f2f2a87e79b60e212de8bdd6f8b4f903292c9f3b1e2a7d8381e1c9b0afc5983231e57d28fe841d71a8da91bb48627e8b7a946ad33eccccd9ec54ffccc7c1466dc405f129d2547be073a375513a0729f7981436056a6a4c0f6e5b805f28b90b6e94ba7465488ef5c85b3af210d1d18cb733020d8805f733eac5f1c5836e8e6294693fc99e9162df9091aac217812ccdad716019790c980bbf175c230c1b7cb3047873b54407a24751073e1d5f2a8f662e5f5a4878f87e1b9190f655cea051869d9d07caf4dc82b91da8ced59c69faa2ca0fb91353968b9541bd8a2568f92b5d79333780bd238842f6bca536d785a7bf94c8501017bfd87e312d7bee72405af4948a522aef70ecef5541c23cb916eb3c94670eed05686ff9c5eb636a01651882e18e2f3a5bc3f24e84b83fa3f45741ad16b552a13592a68f3f55bbcc24e022557cd41597264d3e1a4db7bfd584061dade69ccb77c3a46adce8d03fe65eed9993318279014bfd8523c9c4a016d9db7013389b8f5661b1ebf79b17c65aa2750fb70b279afb763e485a60c5af293e7d523183ca9c2a37f7d515f80a88bae76320fb1de64897fbd09138e0f1c81c04c2f29d3c93a59b3ec8ba82da53114940ec0ee45deb0d993d308348ddcf6a0e815d22e1aa852632577caf923f057f290e141d753a145a1f8a0aa94d8bc3ed93adaf10df7365f33672c14f9dff56916e5e2fdd6befafe96d7fa07cd96305c5248a88e65a61b159e8af9bdb65f912269e0bcf74b537523c6bbbfa26cc695357be2b3aa0e5f20025946ac29328957548306f805f1035764f601a4ddddf749c61ddd208271c3adc215136e06cf3d0c9184c77a7375ab33f8f57da1cf580c0a7b07bba5faf6722729f5f45e8467f406ad295af6ee019867e590ac4d8df506121e2834c426fc176037acc5899421ad32d666fe0f2c1fd73f0f49d960e1d70629ad5e162dbd8f9d935873ba5dc1156bf64eb2b65d87d70f954b063d7d4d2d746776015e41e1eac4977097c9f84041b67db6ad1aa9122b5550df822cacd5128ebbb1fca23d4a446a063692fa00ec4fb449a52b3bdad59a782fe4a746292ebfe4a50f10e194363fc5b3c8930ed4d138ea98ac867352e559db997bbd9d749d81c15dea3db29f381dc39ad3359258efde43f2a602e5033341916da7a5ee17fb8ffc2276e311330e4ffad53e85d268261628b91e0458c73ba3913588c7728a56f1edab8bc5487492e34113bfa5ba5433684cb885fc272c994c9adebbdcc3ead2f3d1e4938c5d202ba30a3227a8974cf6514739cc3e7e25449c3cdedb5fac617c551b3aac0785a9dbb9f4e12da7e2fae9ab0d97d82961d5edc0d42000e811a9a75ded5b4dd80ea51ec98b12fccd4b8fa40fdfc53575d2f65983bd7adbf8eb9acef8bcc1162565b2e902322a9d8da6b03230328589258668dbd83653c435818f144b159030f77fead0a5e2fda8180d785b1bd95eccc864a76fdcd6950d94a7c2a699fd2edaeaf8703475c8a9025d17f113bc70cfc58bf806b766984be2eecde942ad768ef3cafa826f90ab0841cd7fbd08af5e488ae00c742d2b30ccd293d4db7a1eb45de921f476c01c4850930015b3a12e4f98593ca847d70f6bd42dd8d33267bd87b3865ef9441914f93d12f77a4951dd2292738a4f315b626818dbc61bd7a2cae236db8b2159fcb9cda9f09c949e10a5dfd83e8c795f8b9487e08e275d6f8243c27c37e77c1646251b926ef59f37c84602bc4cdcaf962869808c8d92e12e4121879d89a1df8ca01d48965fa3e99020c003c0d0a72fb4317213ec04e881441a35e54bff5c9d90e4161c6bc030e1d6679ba0de56944e0ca904b6a7f79a8c6062d9aef7a25d0bd1efa2707db03c950826d2e73f4622cb102501bc414cb13bcec288d857eb480ce75d3f18f2453090f6351f0899977f1144560d4d99ec143f114fc53d8fb18efaef0e6bf37f144b3c9cc5acad2fbadfbd15d6c39cd655d3e10c55aa253712585ab6d60d33a3c34b3c5bca1370a6b12918a599c779b77062248bc2d0d36b19f30cdf2f54b56ed4ee5857dce5ab463c1ea7e414f5db447c89ad5ad6d928aaed304bd4c677052428e30ce827fac70088d598f0af2940838afd2d3ae938fcf427a74db64a7d9be432953d5a510beafe74c894cc6d3df13f05055991561940801781c380e5ef43ae31f8b99bee019ed873480edf2b837609482e9d3059a0c69d46b760f08c5a813b193640f232d1583401248b2173bccb04c27f04e14709409f51f18260df6853845c55725c10808187f379b91b840ce3556d75aa44d2e725873b527b022ebec7ae49bd96d7b3b704e3459d5ebfd31e286b698f99c243ae957c99c540ea9c0845bd27057e00062d2872e300716f105e9084d3320fff75afaa271a39a2a11a335165ee16f226d91e24d40369033c57bffa4f24a401410ed64ee61a3993c783e36b1dc8ee23e92ebab2632562def4ef6ae2b3f0a8c5b9998e452022ead9acedef71f76f9b08ef2777b8f58be937d0de4e5e96cb972fb68e541ffbf97ae819bb97d428c8d507cb6fb1bc802ed9e0e364f4e35f3c6086079cc8f5c880c90cc4f92479d1881f744d5ab33a31ea113692a6d6017fb30e1ae842e1b40c2ff06449ca768fc779106c35960f37273e36bf90c66939a5ff7f11746789506b9e10b11a5455e3220b26049a6ac712f4d08c306fcf14e1383124530eca85226aa6188ba61c80e0344b740422d2cb6a5661160bea9a9b7b13a51253299cbdf2bec5ae1c7eb569656cea1cceba8cc587ef3b6c172434c45d74739a2dc019d82570e295695dc8f6a2a5cfca72b2b7a9b183722e64885ded532e814d761c5a0023703b520ac9581d7d64c7db8e6e0411254da6a0ca3447681300defbf28dc7ab7ac89568ce1b4689a63fcabbc2c3ef9fa3256b497f12ad723b815a397266183d4ea5e88f97219c17585c433a2d3d2c5279fed19c70e40442d24c7fc2724575e8a9bf9a6148807cbc1d2ba5c6577b419cd4d5c832e9eda23a0f6be3a4056b1392b2e2bd918f3113510ee27281723016fc83fc72fdcaec2b71edd4248578a4e220ec66598847af4446932ad13edadb4a43e460e76b8eabde363646aa166d2315313d693edcd3b357b34e6933e0388e861caf9f1841e18c2ce70f05173318fadb003271288852ed3b8230f4de63d413d5b381d124fd1d6bf908816fae6a72d797aaf4e3d54e324d1095a0d50c507eb9606009be12bd3ea7bb2922820a98ac56224fd734a07d01ca6a8fcb384baa847d178edcc583d5682405ac29413152e0015964e983f8cb8fe8404ba98bf02afcfb9121c7576ecbe9cebc545c723abbf4fb779abea614c28118a2781e2727e674819a18ed6fa4df5c8dd2cdb4c78cb097ca2aaeb65f7f30b036b5c89aa13c382a77e004556e8aabefeedd0b3038648fdd63001499dcee6a8d718b7e756b03ff7cc6d1902cf0e3347f84642d6217c91245407792cd4cf8e40bbc6524842e4dc827f9f168ed38bdde2dee5958f1d02656586661a7d3a0061070b5db1d410fb35c8a0922262508c144cf2af990775c5e5be35b94bf916d0de9068d5962e64cd177872eac426ca8ab595ef777bc977c82465123835df144573560b4ab61f7628c75ac5c95e08999a1da0674773e48674b01b859911fb0894f1aa9a5122020a6e54119b44a038fbc718a2c2272b690e329c449e03ac2069e99c6a330465604b8f24cccfed8b27a2e07895e5fcebccf53966c07ebc49cfa308ab814c6fdd802c9eca4fb1f50128b11b8ea3b3662f7b589f745e6f8c8a93f65869727df776cebe5999a155866d780de08054c5faa683732fc191871f7710141daff34529d9d35f589bc130fbe8d20ae12fac3f419e59912382d5bf5d495e533b63cdd0b402c67b953e95c1359101bb43918fd80e2aacf9132c77801a93ac4e6f4b79f0e217bb52787b51f0398b6f3285ddb7b27b08febe59c96e52af559e577daeae4f1708a4b2617a775ca2d4fb6f383362c2532b000779af16605512763fb7c93d5955ba1942e839f37df3e7070a8d375d8d94c9ee80bd73010dd7a28298198b5853c893571bf325219a5a31a8940a724d4bc3da5ae3cc7839bf7a5921cdb668fcad3a3b7dfcff2528ecb273634604d75dfccddc832160d8528fe547ff808352798cbebf99936ded37f0188eadc2a15ed5ae9e95b59da7fda7d9db7e477cd3a1e10d68c7501b8dda0a2f74e520209ea033c29377acb45339565aea8dc57bfac27b408766f2e737ba1ab568612476ce20e2135c035d54778b68d2732f24d7be355afc9925e3b3891c9717b0fd6dbc38f166816d6e3a48f89bea90604d7a00c808a2e3c8ace921b611386298867d9cdbebde9c9f344a8355969add391db83997594e9f741a858de639e72a09e7021f761a6630c20d5165ca58118a0eca8804ad7e2869756b4c93186cd85ddafd29dcad1b5a34c129564bb503f828ffdeab0936f81645ec98e20c03c9e93059b3aa0c06c50a3ad63b3583e91b2d6d9c97df6449b2e10d8a774f2ac76ed73f90784f7c9abf3847746fde28ebb29fd9d6d6af61cbf0827b1f3a230507f633507e2b944d315ee52ef0f28162430b551dbdff3fd716c2c63547b1bc775b3c10c9928fbd7084873ea33c28f8ecb31f94c74141bab8d86186c6b8f22b80dd4bddd5106bbd0159bb60533647f82a33bd4cc8ebc50a451d610867e4ff11f11ab40bf5e95d08d98feab2d0ad25a2e9168c4f0349a6f95f6eec142aa94fda6f5367cc60e34373aee640617c9cbd1cd2f7dd911f5a1c4848860392582eee0702823e44b9d9e0c530e73d36610548ace651b296473775074b9bde53f628ef5e0cbdc48bbd68914fe57fcb45c524957e951a57c9396d13d93f39f077be2148d24aa7fac1e032dfac8a06bc06ba5acc3f716be515224babd52c32ddaf17923128bd24fc71d8b86a050bbe7737d3c6f443243440ca493dcb20735203a858c29cc8fa4fe4728eb313a2f3a983ec00d0c401a401eec349aef7f99b75a37fed74474b82e2ea0625cd18c8d966d3d3f15e4f832dac0f74023a25cb9af2834299fa008ae3a207f834baae62c128f906249cfb76c2adfa493930c03e4d05488a70d0dc5812f777928391e139109d1038f974ee32060ffe12c3fe00c5d2a710bde948de4511b28ba6d7e2b54724e2a76fd98a2e4ad2d851f0a29e894804f8132192da9725f26cd6f187ce68897ccdd692553782ffd9fa1d0705e201be7acb69278318b1fdeca32cd1cd2f03c1ddcc3dfa9a00820215d5f96d7e09bf5e593928cdd5d03c507d0cbdb3f912fcef666c6ffd5b6b51538ea1012cf5c327eb87243bf6b34e2fd6abb5a3cb5c1800aa16b4c65dccf344cf6b9c31d6a6bedc8ad997e0cdb82b937c8971678a75c75cefa8a21036aa827ec6f595103fcc979e4478b7409cd20a4ca6ee3ea1bdadb1419b72a2de0298a4d283212c1e17b93ef70a8053d36a1db6ddc9cde4902ba78a6dff874dd14c75549b6414ba72fb1a28e2bce1958091a54fa8847676ca95d937670ac8835f88256a5e0458b9264d56b5afc6d5bffa5d0cb1ca1c8550bf7ee66f2829fbfc16bf68d9b6e44e9b60546ea607d21bd0758d65dd7a4a8d766ad14ffcd5b695086526e6cd2f9e34e0bf56e08a3c27be37480d3ed776336a9907d9e3731f8c71f80e67c76c4244b4d2eb015f9ae0d91cdc5bc05cafff1f5c578060994ed19b30c7444fe1ac4848c7554a796d7ff7471d7f57167be770324430e5f48fe156e42ffa304ea0e5e911500288c78334188b8acb82bfbe2b60c97ee253bcef5b537d0ebb7c0dd21bf3e0448f09f2b4c8877d41efd6a2d6621e4cb99aaf56065988a7807c67692e97c9992428f97ff28906fd95e44de0ba346acf1b141595530339adc65c1852021355ba3fc272fa5fad8beb998e632555f4b951e1f8205a8760dc5719949544c52637e3cd9d627fec327c4d9c5acf782abbc1d4b854a4ecddd3d20b445a3bc05f25054a2e5113226ca90e9e9c519c135d56590bacbe1810b0b93016f71dba39317e5e7145f814bfc483b8dfab441c0f4a6b523046e62fc41d0786c27b809c8de01e34a99b25713d155748d4ed1a606a919650959a84bfb631197070998518939eec0b72ec5eeaa9c67305c8b85d9da3912395072fbfe62719658fdbbf1794831632644eeb068e051e6f22146531de00ae5c2fc4b589f6b0b4e455352904a8a59d40a0876dcd3709c77487ae6cb55313b3aa2e3e9642e50f3155d2cdd8f6c373b0b4c2fa74fff18aac138bdb3c7f95959ed0418643867c9748b9b859c451a636b10b40b82c8100ae8e5dd824c72a6c5a22bd4fbc5de8fd83e8edf3683e94d2081f2382b0a44be4f0be9f600b7cd93abda56ee2200a4a199f88841322fad216ac861bfd0014619e2924067d56c98c8a440e15cb1d0cf466d9f7cf25711d3f977fc2fb2e6d28ea22824e39891cce82dca6a0134ca258ec5f5b9cdb7be69dec8811eab4168e2571c5a6cddd1e454c85069add327a8aa91dc5c9c091343d48357adf7262483cacb6738cccea4267996d5595229263b06cd198c6f3bc61b29496357f03f22381bdf5b62f22fd2b9700001768ac52ee9a556baf8b98200d1f74b3da9730d48ffdc0f51985fcb5d0ef5b159ba47706e6a2d004e6db232cccfc48ac729d6e694b6553617332c537257a2402e9a691273db2a49d80eb1c107ebd6d5f902752985b7d9f9e8aad6516cb1a9e955017a82141ff1dfccd1ea307358a5d66ae017488b6a1889f0641f0918f7c769c2eeda36d692814d3c10fc35e2df4277df80af1ea76bea8fbf7a9b367fd7fadfdea37693c95a6b880674afb342aadfed947f3194c08a5371789a2e41ba6bbe4833d62042a4234742c599f741522fd0c57d9b9c6e20d2597cc8f6f2b7ec9e47a06574513eca51676b0d03ccd0dde455083c60edff845c819881c23d5977056366c0a78883698b4936e6103233e9a02b01da7a902d5ab8f8488d3141327b65664b0987ac40e68c3ddf4b6cc7511038a0730c07b34e6ce70da26dfe95795cac4cc1236e91a5d787da7342505d4cbdcecb48838b82b6ca8fcbcda5a26be61ffb5a5a24e9f599a0fc3a9fcdcaca72daae60650196ac10b5adc1e614efa0a9a02df81b68d4fc46466147be0e064792f8759f6518bcb1a844df1a880dbb9f3e30e272efe5496103bf8a84212ff7c026b32cdb697b1fbcf3cbda207ad6c81fbba87c16eecd6f67085cd9917c2534439a1378811a1fc425c95ebc6e61be33fabddedc07c81fd22a4474da746cb418beac5da69e702d46fb73a41fe43c3927dd1c5962caa3b0a42fcaa330a85ae15fb6dc816ea8bf75ede42991ed5a62f26ca79a09cc28b3ecc76b1fbce8d201b71343ae88ca9c2d437a151b7879f796de21803cd8eec159583389630f70c5ee2426be12d006d637ffde559e5b83040518f489e53091c3f560b0a41a03c019b3635ceb0b32a33686ce32cd36bceaaf941811faaf1e5c11d8b921a975fa6b291f58d0e3b326178fd2deb799210bb7f223a164fa70346af96a9d30e1d6e5cbfae51f6349e1fae2f326ac752e203a9e3d825bd8eb831b83570786bbc3f44b7e3bd691d8752dc2aa201c49721f8465198d6eb9e573a68c47dc4e81553c70cb40b5f9bf6c47fedacbed1798ee45d7ce2cb225797ceecc5aeebf29ed577338de9a9192c07a63926f81da00ab47df55eb633cfe764fbcf9c0cdcc41dffc955761c60b99eb1ee347d7bcce8ae10cdab4bbba84b13c959ef5350bc35a9b77a1708c99b39a072c231d0f6ca97ea7088eb7d149b88235e2a336efb1ac81aef32e1aab0c4959e4958427f8ef4c50d9043661aeadaf00e43ebf2feaf9494588ad598c007ef8501dfedbd5785c9d31df625fbde2de988b593761e114407c083770ec1b3842b40d421e1870a0a956da9eeac5801b2e5c9744b08390db7b25c40aba3a744475f8204f69e3d789443c4226752b2ae1c0dcc9231642c426abe333fadb8b39f79df8d2739af9acec2d5cb29fb81f8793e15c08f97b7759b7fcdfe48077ea33b60775969a8891df3a1786abb18b680ba3d1e37a27580635b13a1b6337fae0cc4b86ab84c2a95cc2a1b9e6bcc1b1554426f78f561b8b32588015da0ac8a2710e64092db8004d10ebeea522a05d598d592e059788cc02c8b8f98ba3129a2da64ea598766d77accad772f5e14311cc3e03895e3c875e2bd0c2fe97b9e8dda26177fbbe2fc0fbed79c3f0e484ee18d3dfde0ea3e3875efcc67e06bfef47c3efa75ea2edddc6808935b1c0ac9b7c38153b7f58023e61d93e20a3b6891a7f44796b7e10fc4684dbd51ae866de2fde5e0939d76a837fea0e982302bcf85f45596e02d2f259e875bc105f1c4f633fa2dbd328eec4f62cdb36cdcb3cfed16f0a4ae76ffdbc1933bf223cdf461cda7030028f71d29c44e3046ee9579cded0a60d573c46494f9e263004fd8cea48679832dd686c6fa6b2a2ce0ca9b8310af9f54886788ab7bfb3918402636973ca0a8db5e07c98a1569451e575d294e45419886e6aa5eaf4f9c6f4cf8dc45519f8ccaecf949a0675b8f7e8416b3143ca280c6c11c2cf58c22429674390c61c41a43359b93033a61296fcd2ada8ce0af2f8a1e52d44eafd46f855038f937acbbd33885b56c3a47dcfe531d025977647fde3928f98aaee871a99979fd2f73a85bd1917c7b299f35a69c4af047ec8c5db4e7ac8ef18bbdbf589d00f5a2f97f8fd9b9ba92cd01c097458ffb33d8cd59a50f56f712c2b024a656920f3b43d452143705aa55bf5ecbfbb1a7c0ba842516d467994ee825e77b84893e522d69c6f0d1e8fc45eaddd1990a7c3dd1033093059caece2be7088a60748c416a738158c4d3a2dec791ee3691e966fb240ecfd4c0bdacbcbd2a2c3c46340b267eec355edf63b9927719c72576fd14f3e2d94dc3cbee34c7d2620213798a6f61cd0420d537dcbfe3d9bbb6899312c774a244470739d53d8137fa68b0fbe71ded3a804ea77a82d3c5d78ee1a02e50432961ad8967b218ef82dd95ae6cc8d4366617147bd689f64c9ed1e688b9d87cfcd1160b5a3669aa29e939635dce49a51b8f91754cad37ce25b8dc8f057ec652a9f39374fbe1f217d9682d2250acf1471ad393957ced1c44f40fe7536440885b3431c442e400ce2b8cdf3cb32d864974b8b6b0517e0220c7768453ab7c9248f83a1c27cad2a864d231199851d79fa8031d3c8b592e2bac80b695d6f18ee0f59ae711afcbc8b214f16251d9f29859f8619b25192f920571e06ca042a909105f20d6143015167a12ec2db9e65139d75583c331139f17260a2c2fad002083221b1996652bd931f09064ec6422f96a85d881805d57698e50a50c09ca5607fca5842d856828afba98d73fac0cf7e924a1f30784bd3d886a23b48abc6f2a0ca0bc4e0ef395c2f7cd11784e059b5178d9a352137a7bb610bc78ed04826a30e04f6c417b3c12faa7d538cb6e050564ed19a5a8e378a3501b53676f30545dca7b6e83ea65315288c045c1920fd98b2a3f8e8c1b4a030ff035397a6bc73f17aaca9c978c376a1a7496819cb1a2197d5fc63f0aa3184e45ddfa175db43b71d39f87631ae6f826ac696f4894949498f2b2f3f4fc3bedc42dfbccfbeb7e516681458e8b4cf1d50ea368ddc4f90e444cceeaf3e2fe5b6c1bc545b3a047ab69446c7cd2fe1011577aa6164c1dd74bd5cd7d8ecea19030af4fdbc27fd7d58a01aff449e13fe0e42943dd57fa9282ce03abe0c6257f9470b257dd43e8f86bd201294ef9f7ff731c0f991bb9860f47ac0d99a803d87fe4919412daab65cdf510cf74cb6b30217cbf95fa5a438d99416c53b9dce4967eaa91c2d7f16e90ced12f9d77fab7b228089d3feec482df869b97b96756f2c4bedc2dabab10f6b6b6ce64099b6688b20b4dd7af0fbb1a2ef67c368d063e6b971a26afdada623feede33bc97c17a5984eb4a0fc5c2a1b495ec6fd9dfaa575aa350669aba631edb235ea3c34cf311f76e65575adfb3bee028ba28de1ac223acdbc95a28dd16ea13c6f97e012ea1c6a34c690c7b41dd2fa0992b26f54e783743f327e10453e821b4bb41283acd2de74f3760dc9c1df813c82c0b42f09d635cbd91f3a57b8909a23296392c953e5578537ae148e7185cd18f8df1c99ec9d8995e42dd023da5c22c1b0840eaaa283f55b66345b5edfe9f44f0a4e2d042752b7e86810c14956a0dac834e4cb27e8dcbd571660931b999b1b84ea0426f578fb970b18467823cd0722ea81ba6b79431ea0d0681b179ceaeeadd89a8a2a040c0724a55b4948010405a087ef4da99c95dc1a9a0e78ef0f3f1c96b55825d8636a8e2e48467b3189e45486864d8998cca2e918175003afd710de7706b8bf305e92ead1ff7cc90e4d1bda57a341cae527d96b128d5f933fc3567d88b23e1ce3acc7ae6345afb0895ae7c1cc9a370ab31bf186f86adc2a8f3886e96eed407f8ada470b2419cc21e0ae257fd21fc35990736ba640dbc61cf356b2ee78886462432b08d6c3959626d5ae313c6e88e2f84d3732a17d0daf2b2178544aaa868dedeb2124233646983c5b7b0886e4807970f747f2130cc5a51d92b5baf6dad099428e406bb43068df0bb8d2f1bcaaa4c1231da8dd2c3d8092ae4903d08bd9f3adae5802a91435da4b2ab751e95368b86a6247605bad87496ae9d5a82d337ff1e1b2db049090df329f63b6dc0db4ee6cc7c0a9c8de5410d2b675b6bfb3e344f9ba035eb7be478251ae983326cd53a01aef558720671d7b2c06c6b082b8aec3552ea27b0440a8e0645123d99388538e8f473e5b08e7651c5ce728b7825b3e1f4c71ff9a4c964ad0eee8aae7e5a7af069147dd3568e64e61d22f5b35cfa01ecf3f71bbbad2e05b7f08785c0275dd86ef5e648dac0479ace6b6db2f215caf4ffc3426401cf1e01e68e4521f6475dc0048dcdffcbaf32e6fa4b79ad5ff5f2b21863a88cd0baaaf23f2b1c1896de0c4d761a19baadfbf72b612ded827dd88991522c8f16fe15011228160eeafc8d637a505a325b7572a58e4a803a8d2aba06bcbb602c8da782b6c46925e9b4839b78ca13fa9fd8632e2ef8dc01b9c8ab3f462e46979f3176920e30238e7da60a84e849ae259dd10d3194bdde04c3a9963782d36842c8411843da1e0d90330dea5ef42f44187c01838d421e2a28ec4e2e1e12ad1feca08adf51cd1a3198dae8ef0b35b8772fbda02aaec6ff80cabf566baa02ef900d3d77cc55849a2101ea1f37a904729c1d90d186a5f332118dc03ef32d384ed486d81d7db691f03d46993b0860c14c21c072f5a6e52b2e39a8404aa147507adcaa659f223d123b3cd45427c337d926a51f986f9e4d5d818f40e63f1342fd5f3327adea42774c138c8a1b792825be93d551769fa114815aa608a98681fea112b0787dbbbc417284786a2edd83b9d5e879006d0fb5ba8e57c9a4ec07daf0882e36061985cafc07d69bec09a601387260c6a5c766dc674c419403888e1a8a110ab5a49fbcdfa5ad23a5828721ba2a1c20ad39b8cc0f91a228d9c9b5cbe9aa9e9964e21b1b869de505cb2bed64d6d9840690da8ab38780311999eab1471e59a262ac80c2e72d35984d16ecb20a3dc11e2f005837889435f845a491ab96984120b707d793b1a84a6f213a2e4293e530640cd025f4fe4360a04c59d3d21194108c24b55682a0ca1c50aa9ec835abde4115a40942552cf04cad3c325f4ac9bc4743ab4366d3b8cb3cb0eff4813d5924b7dce9d90f956ef4cc71065658b622d08dffb53fb9640e06d1da3849f00dd93f4dba73563876211e6ff094931f94a7e1bc0eb1123d4c25969e8d80546c41f3b879028971270f519910ed86454c69c273a2c43e316e2e5b7929f4f7d923e019886f6f9daa863f130363fcd53f34291ca19036c64758a961c39e5239e4d93c317f78e02966fe8e0f0c3f8601c8d79fe54ee043ce0d9de4c102958dff1f50ca01a91b9301b4a993367adb24126dc058c2eb4e7160678312c83acc61438452aead63b42daad85000c91bf17e4b0a965d9d7ab5d77b43b121785e6aa9f33bac853313f0223c05aec4a6f40a036e4d05c3a724846ec43eceb3a0fe3acb4c148529f81727d03a780f092f23deee81dc5f38b427ffe247d900e73d231eb1f77a49562870b64792b4c0b983df8d564d749451381789e0736af59670c6e565b94545a2bc09979a406704e13e2ef954e84135e738bc31d5834fba8788fa52182fffb6788a17f997ff26a7cd77a723d9a166dec8ac82c7d56bf8dfe17e620cf183050730d39e7162a35cb87d658f46d2469fed166af115548599bc583d66c2b41e882302169b61fb2f33a9bae26fa683b776781406a5a26d90a66ecba34e48d155388ea003ac163a3880f89a603c211b21b1c544ccf9bbd8ff6ed94e18fad7074a9eaabc46b2033ccda6390fa7e0ac8909744021147b28a48205faf058a3c10f6bf858b9dcbfee6e811f8e95ed1390e598353cd2b4e47b28df918fd061ed8c67d58ee402aa1814063c77590405bb7becbc186d52241a84511a633503cedfe3be77acdd42caf4316690cfedcd572740cf70654d4bed49defeb96eb9aead5ca0f420d2b43ac82115386368bbf72e9226278802ec5d02a23d8392a49ab548082476ddf4a30e1881d40eacc6e79fe9368c5a89a294f670fecb9feb77e1e9880d43be90a4785f65c16886f934b59d715a827718a6653c5203dea0a7e93e595adace9a5a127861285b77c643dd71b064123b508d9879551bee202ae66d5c625b0a8468f726c0a6ce74bdf812488f2fb1b3062e6e42cf128691dc2ce54f7be5f2ae04d146a004d7d76b5cfb0d4c4bf1017332eb922045e2bd62d78fdbdc109bd74dd41a2603c961cc0a7dcc8bc6805851ca4150ff8ad93d33f0c11451758d00cd89e8fa1374945e046841e7a2f6f6c15e51e212542a631a0b0981c6ddd06523c2df2669aa5da88081236af9d9d5ebef90aa8f839b07f68b75c163b8aa8797074125c50d8d8cd287345fa44efee4a428a1ab941711e6804a8bf8dd7ac93af243c6ee241e0caad37ec335102f58d8425ffdc8a9d7cbc455b1a703baf0cab90ee668f55e838203d7e8863ab4cdfa55c2bb1331b602adc07bb5d598c435cdba45b58883310600ef6219dc75015f4a60fe60c9f643ead32e3532d86a27d45e6b5aa14c951d55478a73ac08538c95bd63932d9591a3d9d7f5005b23faf89784c273bf77df3ede2a724685754092ab2662293eb360a0b21d99140d65bfff7911bcc573847893c157f6ce403e002bf7c3d4e20afbc266d9f61ead0dfd7c04377b283b0b8c133b1f742b98d535b5837e60c6e1cf0a3b89af38aedfd0391cbf1acdb69a8d5a280a363ae247f2a2ba7b6713ee9762d4e806e2204388bba1c62d6c2d866dbea1f7f617f61989903b38412def9848c5047658bbaf4d25b164e24368c683fee826e3ccb448738e7f3402918fa051a56c92b3e1befb674342c1b379a30c7edde934fe8fce5314f8f9debe3d05a15403a53c152babfae5726e031ef2774e0bed92d1e09a2a9be6705672cbe4190ec72c8349af6c3a9d777a24ce8ccfe4dee087f5911d686bd0547259300fe74cfc251ee2f94d6a62512aed3e19da351c18e39a5ed4d7de80ba2621d55692600ffc8c7259c8279600ca73a9397e53649c7af2d6cf72bdc9954cf7e786d5209a7d7b0b35aab53eb300ca29598d3ac2925278b4c4dc80f04d51ab25d1715cff8892ce279bd390a99515bb9727dee9234a5e2e78c84660600ec504a0dac761c27fe62a04583b59c7ff42e4c7c6cf8e77158db3e964c338d156d2625f9d0be82161c37067f6bfe44429049c7e0dc8632a581caf93b97471cf211f38c61b0e97c43d4d5e723d1ad9bb9647835f828a06e749f01b79fc200671f037fc2820bb28fd3b401d88ab52c40f4a0d9c53a8b499d0cb708d848a2d0e16316027772d4eb60b418d85f938da9eea3ef4bd6aa0c6e0b73beae84939eb7b9a81a18a16ccbd7056074b0844f14cee3579d953bc6e72dc02b29d5eb2dbe764fa8fa5db71f7471cc44372f9d25c4192c01ece3e7701bec94bf9e1b6b9462aee0255d172292b3034de3a00cd33d81190e4ab3344085e53be38e76c627123b770e0dd4497a9a2499da40698bf1a64f2a9b0cfd58007102d5e5bcdca05e81a83fb02ccd6c9773a62572f992ca75ee3191a9e7291fc96ab5919b155bf77c065739036a989c1590c56c652833b6ff213bc6c9aeca05747a1b047a7d109feaccc494dec2fc9e15907644b11c873805db99a06af8dfb07714106ea600e5e8fc1c10dd50da3eaff82bfeac850acb09fd1e14882a2f47b017dc6e30e5a940b41ee99a0bbe6155de462842b8c775c03c7044e141e9cb4ea47a4002c449671f1d37a750ce04abd55d12e0c2fa2b60adeb05efd99d0eb1a80e2e2b69793db9034fad5f3c19cc78eb974d9e2e10d960ed22aa85044b02eaf28451900ec886f218fffed309885f0ec22a3373690e5c6e17751e95b2f05f8dc3d2673851c476b074e54c2f403eef31f8db983b0610f78a297459de82f2983e07d430640dc005fe3c51c215ecd906e833ee30394e07c6df6668960ae968a28e15274a297950d5b3c23352431bf57bac2f8eaf0075d353c95e570566a55a24f47972f0c1b0112eb19a301b0b19b87eb43ef64c285519cb859d93f4739c68b4f15367b5e774cb50c91d22d2396aa29155c0c022e2ce8c20bdd72fe427a65cfeb22c6e2440b133f6951ae7185b3a21114c9c4f3fc58c0b5ecbbd3c16806ad49cd3ca4fc60910365fdfc732073936b3de2bf08948ded9fa4eb7147d61fb23976c4cfbbf3f917357aa063dd1c2293b08d4a59d6624af65c8b81aa37c38ce8de94a300efe9bc32522be250880890ac6ab9ebc3dafbfb1d4c044dd191aa60590c5a0ba886b478f1366523a363f592e86d6cd32793fa54d6c9c7424027df861c36aeb63e4a497cc6cd1b23501c06e7c6da7081a8436806c01fb8062903dd34ba96c637d40471a84697fad61361d469db27861cbfbf620ad4f1d0e46ffb8e88612b0e110133a32ccd31b5f191ad29a0fb8dfa1e887a524d055cf50f10219ad9ce074f3cda7f5a0a70d66c8e4ed4fe85f08e7618df37afb1341aeb9e11da286e29c8512435c235e9e422940c8bf1bfd6dafe38d8aa8747ee9570c55239ac3f2f77abc5af960a339f99725120a956a45d64cdd79158be8ac77a6ec9929ca25073f5c7d08bf31eb3b8579302ad4baf9c44daa9427344fae60dbe992c13d3220b11545426088e02a1138e68527c32ebe6257c95fa561deeb56c6522df61f0726c6a9c97bcd635d9a31f3e3a9248f43fe51856a8ee562607071c146a32c33d452dcfd2f6a017bde620c039af422dd97daf7c05c3847599cce58ea0eaa42e73ded17245894fc6a16e057b9fdfe0af25fb6f658191d86b9c9950b28f68db8b97ae975e87b04d635a91f49c4a5e8991e40b935308219e55da92d18354369b51ccb3fb77b6436dde599d086d071a3f6b45f7cbff92a423666bdef160a7ba556ede4afb171b0f1f143d67c49215196354ed2b3980dbaf491b930dbae769236934f9a83ec995ea7a1bdbcf80067e75ed886efd350d68eb5e59b531cfaf34d94bcd90b82ad96079278f95d563944c0e61edddd5c67347dd7955acade8ae05f28baec802782f75a339f78cc169e36557b1fc1cf1e1e285f04c4b67f309f1962ce17e3f889a931904ad979320bb8a4c193abb111dc941721c4b3ccabb5fb22aedbf2be7923e8ef18efdb25e2e84ec2864f42026eda25936ab24b2157091f86788c96dd512c84d8ccb2cd224160838abb03bc0a1b01bac0147e10b9489764491da87793fe9af38901b120d9cc9a38a3f310a59fc7bd63d65de6efdbfa0be4ac4fdaf06cd6314eccb128f618ebc8fc392fb9675adcc0b08c3f55fa8fbb90ce3df5d3692a46e652c5770e97d265cad274ab9c2160a5ae70f87d488303d3088d2d289b9d14dfd87adaa1f9548a893832eb685f32f5f1bbccf66fddef3f8910498e28830a5b473c39938141284b7539dca1ec28fc8f23cd3eeb881fa7a4c6c4d259acf36288ccb61a748bb057a8078b6e6b578b9867f9df2878fc0e2afe9d045521be6643556793242202c3e5d3d6e0a3499d652d78317596f64c5f1ed1fd9649538cb78448d338ed32fe23e45b96391b0e462dcfcb5f3fb29b9a05840b9026f1d013af945859126f32de4d6d56dfcc2a33ef66e888e22535d5f2c97c049f6889365f50331046b14ea15b8882e1dc4dce325ecbc758400cc451f1bfbbef8979295ffc22786d4df813d11a5b9412fd6734dd8eec39cbab04c47b136e8aad7e92792d8fa7b8f044cf79f312e5a7b5ddbcab686974e511418476685ce25b8d7198be28fbc3ee1926fc55415b7e660cceffa2e14a7608322f748762b6a343d492463ef6e29037891bffbea9c83fe914e3a1c9b1cab403b31408527f62daada3b9667f406c0e1065e150983a4e98295b79b140a0d9e507ad0ced0ffa1924492a0fdf35951bf9f25cf7adb96404b69842f29d4768982325670d4236b09215bc130da12cf2f8c46bef80addd87da7c443b1086e512af4933dde97403668a4970a93a98ef47b7940207ba73ad2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
