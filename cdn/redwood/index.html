<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aee5886843ae3f2de9294e23a6d43cf4900da8da5b2a1fcaa6cd89012dec99f5cc5b9f929449f715776dc679d0f6ecade01843a3ef1fe0fabb06252ec7fb4055371573f38b37350512f80decf52762beec99e08a3e59d1a1a27b7dec42975b7cc6a62d44c130d862e4a7ad64fa975e65168b852c2e6233a2834fca7589a055279d5b093c4aa41ff6423ecc604d0172b0f6c8bdd4133417a8ff6565e4964e2763d57ea81a6159be98ddd33d4b80499f712f8d488234bffdaeb33f3fc61cb0a3ab3161f4109b62c952623c07a09bd019c88543538cafd09e6cabb535adc26ed7f495d69f466d5c6db92b10236c41eb60e7283b3386784369983ff08b5a49009d61c90ce2c32391b7cf6187e81e1bc8596b3c795b8951d1aea2eb179d7ac529bcff3732e312fc95aa590ad468d5f501872bc118c83b0bbd30fdf884cf691c1dd91d5c67d73fbed2a52232dfc1d8c73cd0c4b05ba8e4b076bcb152fa59884255cae63b256e59d3aa7c73830e2648bd5dda1f145b08f4d060103ab499acad294cd0d1a0f32d22b1ebde420a77114cbc342840a057e745445bfd424ced5f5a4ba92c707e8d207e52f6345ba32b10cdf7ac33ebde7844d43aeb43bd46c82683889775f73399b1625e21878316bf45f7fddf2244fc5e914602926ed2c4c1906772b03953064165e13a6eee0900f40d373e8902079e2003014e0db63fcaeb661d808f2f06aba4c9f2e04fbe08e4d8ff9df4737bf3003dd6397d35ea7bc22b260507822a54be63013d2551dc64848b24f15f0c91267cafa7b66e140aadbfe9007c91fe16f08163f17db2cbe3a5710d4d431c1e1e10c59763c5bb8260ac3c7bc5af31bf468a0d05b83d7c298e5bbc716f272aeb352ff6c248d1ef01692df542f351bbdaeed72e68cca89aa00071f759219318913d3d2fa8cb1acabfa55de6ed5fc2dc5fdd788fcb26d6d8890900df87ee5bd13c812786396ff989d14ccbe1c9be04606c7f5a983d64f76fd59a959b1668d946d639053da4c1224e88f6ada907f510238fb2c1ecbc6cf4bdd3a36e20c9fda81301f7c7bd802ba29c0e353ba709694d86fc5a4876c5264290602a7fea6bfdae4acad2b94e53fa397e6a2973cf8c5b1b099c24e64ffc736feef8e20585cf5293df982c49656f13e23440ca27a05696e045f6a5380ac1e2f2b431137f8293c262ebb91b4c21085b10f740078ec94849352dcdc738aa0ef8c2821ef6e426936a03780a0948ca137dc6105b2b7f1cf7c2e74190520c6b8f7800d11df32c6aea700ce76a8e0cf2e2cfa6f41b987fccda802f4b817018a8718caa240c688ef6c0f9ecf278f2c103493e12987f0493c5052ed32d95431ccbac8d9a0d3a5cc067576f7672400759f3adae6db48ccd23676a99c8a1a8799558fcaa41ef5571b3ac7f590820d9a7d9b21810f427a3d4a8dbb49febde5b817903aa7b0c7d6baf808302d8483f04e36871fb4ac12fb4185f47b77edab3530c875583b6f0e2dce9b44597aa2c3b2847efc333266d4023924f90e56402c0deb87df0a30182fa032275b831746a0b815461bb6c0c0c512e28e05a05bfa73761f27b6800ea363298c4b11a655fab06d1510f1dc0a89b2543f39d6179f953d23f7d756387cd8f8a8abe681a338e3c8d3d21a9f679a1aba4f4a695f2051944fd578454c555cceb7d83e2540ea4164368b988ae911fac38e38480b944f085be28d08b89fa0ad7ea45bd1fad2a78c5f84dd2ad10b5462f39f9ce2ee613cb04c484f7f66d0873ea362fbf303525075fa59d2769f7f9689199e2a5661e8de1bc214d9c1025eeccd4c9ffe84bf72b60086d7ae6c4bd1ecfd6ddfc70db8a2b9c3d4a78ce8c8379ebb87ddd71305e38f345335f4297926b7af1d84a13569a0e09194037d63b4ec2fc5a1b366bd2af93c432ec68be59586d1ba5bfd420c9b6a95fbf233a1e2fa7726c35d2cdf0dc7b84f2d980f367db301d7a65aa2f4c199b3360ef6569b45d0724012261eb5a75d60e24293aba56c69f43266eb2a7fe6a614ba1972702e87b9812671b69c29395869d19d373f70891fd2ffe3d510de30a53f64b61ae2e089d397f7851be48f4cd6c04c72e40146f123d5672e71cb4cfa338f2b2ce7d5a1f1674701ed57ebc8c208f9625c83314dcf98b99cef93e5fd0fce33d96c524eaf1e1b1a56b407c7835461ddd40dd8ef78007e9de6ec9f24949e3b9daf351de7f27d6d1031ad9ea5b1d3b19cf06444990ae76a76d9f41c50a483249b2daa0d05b77602733d7a23976a3817d7239a3e631c69891aee22d2664a56ecbf6b489f8174620427777feb812f4d55a28047f562ae551e2013322eb5b9ce2229fa3fc97c6e75cba3388fa769abea7a2461c78ec5aa0d75035f75c3f648aedcc177e28a533e5f382b5273ff5e283bcffdf5426ca33ac65503e172a0f47dc9b5384a1c1760c85e8ab133c5f12ddf48daf2836f955729c773cb953bcd883533309d95833576f647ec7993a5a1e69e2abd736db8c811a092aae86ddf2fefe8ff3b4d0fe61f6b82e6495fee07f163316133518cf3f5f6d5ac806fe9bc35ae647f19031f39536d68c0c0c18171d409c1745d377b4964b35c63a4b1bff9f26c2f9fb97de252f684a95d4a8df3a5d3318c427b07d13102593343093e0a9455851de63113dde04f3a7c7f30ab9da7057c5baa92223ef59171d13d1fd8e10154e1ac849dc0dccd03b99e449a1e62f184b295a2e517fc9cc0ca346dfb8c7833cfef3db47f1a7797698fced60516ca9f8e7509a3288fd1be9de8f37446288c181aa6504e54b37397ef92156bfba04f82630f61d81b9d856dea1f37f7095c94ca617cad4721370e7b45f8e4ffc376cd022843d962fbeb439ea187c163f1c945d9357aa6b9c1234994d44191b556ef16de957273521b936edabd3a9e9d0c9b82531fdf65fb446787d7460e341e7c28aabb541678e67762ed5106b01dbb6b746a9ac65b44d3d0181d890e04c741476f9bc936570af6dcae04b06734c5bbb02331d6759d2bea40f5490a79f34b2a8330ace78598a56fbd59f0fd6025fa9b894cd1538320d2bc9373953eb495c70f1c7782e415610a5776c69f41f8298c2c914902c4b6cf16b0c9a982379143f6eed0f5c69399014f9f8c623a7d1b2d1480238fdd377f9b0168e81cce3a08d5b23260dcb852df1013f9269adbf4030dce1ffb8ec1be45d43462ab236e6f8e718a6a9719633f965d9c9881942798297012f939479dd1f8b053dce728ec82f27d7e0a68cee16815cfe458e5f1757f0b9412370ff7ce43696813be112eddf5bf7a29d8f4fb6b0be5b03e5aec408fc3c374d9d41bb2358be6eb757c5011eb0a95c57ded09cdc6e1154f0aa2058fbc3e60fee462c5a374348eab781232ecb47a48fb56ebf146836ca7f7c8cc9be57c4bcb52e10912c52c3aca50ff5ad42a06a131fade01e186ca8bf185daf02cc5dc1ac832dcc709583c12acb6d227bfd17cb328da4244460095e17391d552c77ef1c370e194d2ddda96a14867facff1644b84febf40db3f428b145642c1e3e1d2dd13507ffa2d28b5f8b67708970b73a22379488b3f19a3158335129fe20cbcb7bd3f15fefd4eba99f2ddad6b0ec295ab7d71e0bf2441a6b4b5b32e721bdcfe21f5a98c70bf450b4e8c2b69de5d69549efdf8a6a4d048c7e0f211f316fda4dbf5072df34f5a70b0591fecd375d0e39b025c5ee53f9d0ff6f2de28804a52e76f4d45668a916869095b7e2a1e5b9c6fdf4b78b076abf975c9e11eb4465ada8cfec15639ecb6cf9b36d59a49819c93e3c07bc036b468b3ce931ebbc9553e6eb48380ecad865d5c26e987cea7e953234160949aab7ed215c8a018970cf36e242cc42273e522d2d22880485df46c20e259376919bcd5e01b32c872761c4930ced50daf5e9fd364dc1fff0eed24d46faa6f8aa5e13eee1daecc7a83c245391150624431d3922a57c323a6ebd76e03517c42c30af4f8dbc577edcce6602335974e0489d5d709e4850267b640dcc3a7cdd623950e902092b7568c67a83888205bea386e085299fcb5d635330ec2ad5d7ebe3b9a426de607c184285bcf5aa9025ffb93e7cbe16c0ec05418de42296da7b0f96f84eb61fc70724023fac0f2edb02eb522ff8e9c10e95e977a32a5735bd1fb11ed054a2425962077d2ef42bf61240015122a1ff6542005e03b580654020c8b19cb3a78369c8b1bb9f243061e3679446eec3050f729a181afb791eddcf50439e02c4b505234baeb96e09b780f32dabdadc43cb20f449002a766259458b28c241e39f4bd5c99099ce1ac33087c4eeedaa1c9a70fe27b9d7a74079d775862087cc495263cbb44d3e9135576022c88b3fc0b460651a1d8f6d94e15bb575acd83df0d798ae3470d64dcbd1fcd432c0054fcb2265ba7cbad6fb79b14b00493fedbc68528fcd775f8d186a441e18ba1e0f9a8ffd36a23c2c3025f0f09200bc6024e843a173305d32c204268a05f5ad5f9b9cadbd9faae47b6fe2a0dfee2927251a3ec36831a25e7333917b9458203ebbb237a9a1a2d14bf78d7eb6a3d789d7a0b479b0e68280a9a4abb1df8a126a8b5f526edbaaf421f9d295b92b7214685245d1d243dc633b3599e746677b9051c59abb28e3909e8a3f480e30d0ac33f06df1f42a70bc0410eec2102b796311ce465ab0a40e5333b1226c8db35148cf543b765180eeebc0d495c4e5990d6e727b215645c2939083745692a31e8cd0c556202c57ce026b3aa9f32dac0aa5c6eeb2dfa879ca5fee58a141762e2d6a962b0a28593bfeefe7173b4acddf63a50d3cb16719c01e9b87cb1fd8350033de158404df74e1396c0f6dafdcb62bd689f657ff757eceb13cb714a6de0d1e317c77ba269f117dd51e92149b47b4206297d35836a4e8900e1baec3655dc536b3a280b4df68d7957939f6211bca0f0071eb501d5d06dd38cedc25c9b1f26390e604dd99de551d8b13ccf9fca450031f6204be7c765fc6421f74cb54e7435b584324df5d1cd18fdbbe7b9c8735fab4dfa2d52c08e80ea47d22781ade91a5024e3895c829d206e52d52eba376045dd84bb9bb1cdd175b0aaa2f2f9705d7b8a2a32b131d5c0f67dd3d5fd5b9a3a394b7fad0262a6d6accd5dc07db7351ab0de1f1a5d6c865b23ea7006e7d8f387f4da8bbdd0bbd37629e953a9a3bd20ea29ae8b206348e16b20a366a84ba9c2a3301cf47a9c9b0ee524cfaa3334930181b52c04176f2ba4b57b95d3f74feb030a6cae38cdc4b6b2c29f595a2e4eb28ccd9760468e9f5506ec8d49b8e47b5204c636590fc5aac66236f868f473031ad0e6125f4f89ea14531a0a24287f819d5fd4da89d17624520402476a4f2869106aefbfc88657d5ec1de9f202e9437b19b34f24cda8b759010b7b12e332448cca680186653dbb4448fdafdbf4f1f8c54a47afcac6989446b7b1943def6d3bd0273300abdbc47a7b0b2d48e60fbc82760d205cf077b1484881c3a945fde8fa6ca6b77ebdc8380865865708a08fb1d2f68da60dc19305ce2dde890e3af4c3cc25d7c7052e81c59e8ac87ad56a36f0a8fd183477f308cfdbeb1a6108aa0ca35240d7965018836aac34effbc1e9689df463e17ff270d257691b04d42ee3084e80368b3f5e8fa45c9abb67cd080d9e2d86fdde0fd6ebc73462848140df8eb4c5c8743b6010205f4928935093fd3c3433074724e6661af284fe6e4a4a3f8c7a36643021a243697f8cf7b9335899d5db5efbb51596ebb850ac7ea7866e9a5197c85d1e4a503833d5e281bf2e16255c04d447f7ea5655badf2bae35a4e6d2c89498066131745c606008862b563ca2d7cbf826a66c7f641a754a39a3703c09c6a2a9a349d501db8eaeda6d2b23242aada330bf8b82c87bf253c5c2341afd6251f64b4de2a7a2001c79c31cb0a6927fac00885a91b95432e66f16689acd3ea1fd72345b01225eb37ac73e80a47bd63fbcad91326e54e9f43630d40b13204caa6e2f6c7bd618644c84e706b64185504f4ecf681ac5ed0d46e63c08481fe27ba6cfa2661fdbf792516a5e7cba8b346572972f11f9737e7793f410c6cba23017412e0ac877e2126bc432b2acb8dc23554017e3f99d7c1f6b6361c7a46ce9fe3d9e9623b9e668d360ac7f2af6618b505e7d8df7fda8d0cbe93512864b89e3abe7d98c82288ce2b6933af84f1ee4bdae463ce9831438e3bf392279e15d2e5226d8a793517c6b6ec3ed495d37ac42fda0efa56e3de1de093300b9b2393186237c67e25a24e06133b4793b9e5959d30bcc518ac0eb6e3adbb69f412e7071b92c5f87d077ea5f46ae5323dc177a179c4fbf1c353f20a8767cf00c5298152bc7c7888596868d857b5fa9c13522ab08fc099e754afd28f27ea5deee5e48bb9e465d7b8e0a498a0b0fadebe62233dffc8e739e57caf3f699ae14c2f220bbba56031e87982e4bbb01d378c96ddea56fdeb321e479b5a6003c834bb5ef33835ac47463b4075ee582ede5cbac16f644ad29f96183ed6e1b7ccf57f467b65141ddfff1f448b2ee1c994656b11778e9e8d8db24014e4ff4ec07013c4c8770f21fecf808fe9f84eda4111c860d9413930cd30123aca41e68d2deda850d89c2522647fecb65010afc27ead4a74991c00f9fcd8681e589211e15fbb3d369a88a3aa4ee3c1a1e7ff867de9ed34cea0a8d1958d2ca7d2d736adf637a5c13e8a4851a6923d81cc6d4f09827d1b4f333a73ff90af6d7bf6288ce3e40ebf43a7f8317fc4a5fa98e2a095a600e31d9ed83e62aabf92ccc8dc55bf62d46d76888b5fd10c81fa619c09a673e4d4f56f1df2134d6d1681f273d66807f7fd1dd3d17cb14dec1e811aef9a2258fb85a6ee6781ac08b31af312bd3e9f465adedaf2762b61dde65bd38d8823595807d04fb1b745a7edb74b78d29da0c4a4482b3c3a58084c63d0481100d7c12b849eabd5292c6e415de11869042c36654adac0a3040217ce880260ec2208e415eea99be91b0b6bdd1e865cbf5863d52b78a95489106e430dc7c5ebf330a47bbc2937fe0c60204eca3c88550c57cc0ea9f7e84f2ea52f547a262c63621885b1eaf88d8a5f4f405f3425e61ec431e05e12bba03a2a50c39c2c51cced85174226bacc2274d0a6f9dc9e006577ba35f701761d42767e0c1b49cc14e64048b304862a7cee9fefd8d76c5a97fd991de12f9d590365d89dd3d4895302c3360efdff105fef57dfb9d68889f226346b9f80b9273be1cd89926b5ba1eb20618e6ace0e341f0b7070c404eebf225e261d3556cae04c0289b0c8813f63a3e9d521519426b32976bbe4d62464c99a02dc99313ec7ab072573e64b6160bc20ba038e0dd0d118bf34484fe93484915d97e34bc135363345e517a495413ff63e1f34aa745ffaa2059db2c38eeb48fbddd149c060817a99a7dba7c7f82e78f656132b931c9a4ba9a237617d8776677b8225461e818b158ba4c416ae5a7cf29e2b0e0dec21f66ce9683af58f7fcc902b836c681c9b7ecd0fddc0cda8ca5d616b3fe585a8c9ec23f4ad3c0f45bda3e187b13123349958f08a1e14b9ba71260f56b6dc912870aeb9bf069a1fc27fb488364a455f57b4860b8616eb6d795d24b07ca233f9434777f8c537e4adeab1875a78f208f0e0da8b923b0041ef1729b038d2f1ee8388b6b304a764b881ab660ec9a44518577ef6cf1c90c7112e179b2f40ec1fb272e3c0dd28978ead88158080b71490f05755ba30ec816602aa80fbb4b8f016205becfa939359a61e66d483ea0a4f341bdcd5e3b9b1e5fc4738ffeae1391c46fabbce88880767e360ca6891370f21205539f2d6f0ae04d44eead276da70e3fbfec7fb300adf95e28e36722b3e7717b590220bbe7d834a7849157252161427db2e3a587a7198a69625e24f3eee0618e9dc5e08b7867cef874846d31555aadde1bb00c8f78ec6d8886bb28e13d72a35c9301449aedfefe883f540b39bb5a42262fe436bb580f715887c93843795c2d46b8431f519f2da0542af5675b5dfd7f6728649b2e79b68daec9c951147ee15f88784f0fa30c39152444bb59463812227b391a357f0c118a5219aec775493c41f0af1dc7247e8afb3c8fb9b002bbca8b80648507e9b42a2b1ac3f7eb2a2d0024be6303288e1fc48480260feaf8e371e7f5eb39051e2b2ad87b15a860b0dea6e137fd62c872fa6566b3a89c1a7ae9e1981158b02c3c485a4c4359468aa7852fea7dd25fe73a0ea91c967f70dab1d9904d263b8142d2005da7fd0a9da93e3c5fc6204bd7168b17cf97af16d9f3519913ced1a4784ff189f703981da8e41b84b1b22b34d2126350bbb207583cb1d0a1a9e8c827731c756b2c146e553b6f36d4b5e52d069c0641ad2577094945adea8a8f0915574faf07f94f23e4d128977da1074e6dcd0db0aa4dba98eac0f0180151419c0c76041ff7dfdc925c5fe280b1da503285dc94a69bad0f06cef37c44ba9fb3221a4a97f1828d614cfab355a2993117ec9f8933bc290669e396dfdef84d04a4f36138d0d8fad60ad9654a59d6f0ce661a3df2d005d1349850b4e5f88e777ee2b3fe3382f7db85b15e93c32921b3ca196cf8356003a2b4c6e445eac51e5eb8d19ee375a1a6135c4f3ef0b9233a499eff67f4113cdb2209cd1f764e715e743aebaa34ecf6abbfa9d30b719110f80b0b4241ef1086df20854d80cf23a9f08473398c16bdcaedb31079783ed2e2c9e2d2bd4315755d389628e7de042df684ee43b0cf2271e9f3b678de9fa5887fae673ae03d7f25959f4a261c52922036a5dd6889e9bfeaf94a37e4e5318e62e9fd92e01c5f47422e71629daa5b2b12fe27026f317138b2c27d77aa914b6109475cc414593aa0558d7e2601d453f5f9ddea6f342ef4ae2e9185aef6e203862834657cb470185bec6c191362773f862d4e703eb1afbb5d3c69c1215ce20d47364631cb60514f8057c461280d3cb2ca6a576590cc87fa585f30f47ac6c58f64b4ddffa2c1106093f684f751254d301f16ebd8c7f22f87e3ea78e536ddf14bea8244af736e8e33a11dc32d23d8baa815a39e107581fc1531bad2923904d5a3a2abfbeb18dd2c20db1486f832bdc5dbac5d9b9b5a83693d31445969aa3023081ced3c5363aaa3647449da80071955e8ce56ea96da48c244d5a10a87143a81db015de0b07ee7f6e08af6c1d58c1c4d46e384f5d81775830efc6796222acccbccabec5781f9c5229fe59e04f0070d83d4745d679b169f0747ee8779477dbbf4a3242243c18dfd04297f54a133ea71e18e971280ad3d1f8b6fd07a612097c37f8d4c90ed5ae5e34d4a6cdae219d303ce0f58c7f8046e865ac5fd629f5b6ab9056959cfdb3975a5cc599becce6317584abd327047add7d2057dae2276e200ced872c26f4e5b3849734732824779f7d71ff0e445cfefe2c70248c025665ecb8127f847185d81b0374c483ebee521e60efa113353bfb06ae78b9e9e94cbcb10cd4715b5b02b395e0bc48aa07411a690768f4682cadbe6ebd6bbe2bbf3a00c6d67e0f80b543f60b5530d903ab128d97dd2a2ad336692993dfbba106ab390822df4860df7842abb34ca1033c8b53118586e1439d1a6cc11eb182ec9435595b85031fa8616498951a1ee86201d9f6538be20b7f5cb9344248c7376c8fe8b87bbaa5044ded4019dc7a7671afacdbf19e9e8170eca8d279bb11114f0bf73c253f5da216df00e11a39ab837f154b7ccf4d821b55bca0ed50f0c73e22ffc912a9db9640296e85a6d51d1dd5bb4a0efa685862de7786381a459210073092e8e7a1ca5380d57e8b7fcdbe43111d418f07265911d6459f35bce3e6fe9933c8744b21e2cea3fcb2c7f5f820fae8d2263c676ce111091e5c244e94856c042b29f39f4df34eafe31cbe974f96804b29ef53556f6f726276e75ee72462a50d47e03402642571184ac11884cad2d6b36330f30c3fca5af69aca24d7bfb1f4287bdc582699ab3ed6921c0041f2390b5b44774728cbb617586df4b2b95abd34023b086a8ce5ab2fed1c234baab2b2505555cba426b0689789453ef76b45f36e402ffe4f403425fdee31add6b6527c0590c4fe8b17687915a57dd811589675c972b4acf956881a0b2c4c96d17f061a2738ae13e1d3ef697bc1c5c3471864b4da0f25af0283ef93cea75a95ad9d620fd229b76c20ca38d7aa7001728d362a44cf8771b14d2ae7fa3df78d6642779728b9f9f15ffb0bdbaa5ae3ce74ee644aa865f0d3ef3e677835bd73d783a248ceef27e922d66df059b11f4d266162d1ba215f2e0e3f205fbf9fde131abdfaf353988031b284c5094f6095903f50f2295057f3374042b6948fda4c44a7932013be580a1dc96a9ec0eec27e740afa28e7230f019ea06e92dee81f93127ac4567391c75709d58b2e5f7dc5fd3e63ade46dacaad8ffc4135c3f542efe684beb98c10809af22325a4879bbbfc1ed61d519fa8665c5719175a2f07eb2fafa95f9b111e0531b671ad085fde063d0899873c99518ed7b1560e5dd5b0f525a77550598376590f0dcc801bee6a4f0a7b34496677fedfa19b7c8788a9b9303a1cee4af391a276dca96a432a5a7e0d2c2d99a515d5d6f882e3007bbf84ccbda7cc824a40d05f1a54648451d0465635ed639facbaf9e8e8d81e378324936814b5f2d6bad4b10a948e1f0acc0303608dbc6f1eba0d2f41e81df283eb44183c762784a5a0894cb4ee395654b6c3b3346974eaeed4da9f406420e5281704f495a89911438dbdb0943c31c767040117635128bb1c4c998204b4c93a2477dbd03cab617c69649c0ac018d0f0b5fc3e06de574a7d376d58c1017de2c1e074b04a959d5c1061fd24769ef8ecffbc15a0f2209a5fbb6a9617de63b7d272943bd83feaa3af7d0df2d5e635c4d0ce3cf79e79b5b1219733e0d8630dd0a6e8ec0a9adef8c4a226da16b4c5735260834a78b86a4f96c34c084410a7422065874b1e4eb1c8e710def30114f3b34642540fa0b23063718be167fe220fbb19e417235728bdb0da1e24d83c8b60524c1e8b711ac7a40573b6e727981b899f6d7860210d2ec8e0a9826dee4a577f728c5b028db867385d3d65585c581c3393b8200ef4df14d24b79d36d2b65b26a235b9cca91f0ceb3d257cb73c0a190cbba046a1b2814c517a8511ce3c0ea5721ca693d6c6f483f8b55abcbe8b1a942d2d5b99f93cdf6fc31b8ffcd36760a0186ea0bc560b7f2b12a8b01a2db6d736900a2a9ab6b690bc3e5e54e5967ebc3c56e952fae71473b3c5dc6edece0e65a049ce6672809170fcefde2a99d953f1a2b84a4567c0b1ba56a25f8668cb5b5d272612c63f7733accc91eb789604c8da6ed7bd62618ac99f2546357cdeb544b64bc1a74626f8641d0075507f3588a0948babe783421bd7d3abac7405519fce84994d748c4c220a82ae50901ece2c548f3e0e11c217ab356314fc423b99e32b044def3ac7281dcbf997ec2384a16fa0ba807560636ba268072c9a5a46e54105200d248023bc55ab473d2b949d299f004ba26725b0c0b622b99fcefda32af5a185eaf972d77eaf91da728c978ca912d29f6a91b30ccf2be4723b9f61d260480ff5cc4c715e11092b40ca1554c7059cbc851160b53afaaba4137ad2a43a7302400db46c621586f3cbb87e3e1414ea32170c322e6afbaa94cac39688bc61b4773932d22b00ed330c3873be20e1b290fb095363b28ea0f113f97ce6d292c41de611059cdf2abf0c9a68fd7fa5a5987c631b5a1eaf9a770f13afcff43c4ffef314c6b1deeeed8c13a6e53939aa3e553e57e44a841899bb00f00dabd59648c0ed0c8211c337f68dfee0cc3519eec20f8ae0be886e26c9c0b6e31762c1f1267686dcdce7c8a5b424dc2bf5cd4f3a76aa7afb620e46aa6e14477c39b8408bae22108afd96cbd55736d81f30a30d195b86d75969975240a85b358ea4b4692179546ab6540f4f043dc171ac099f376a7231abce41687a932ae27945a6402a881666b2369fb8ca7b757c2cfe20a5e97adf59b0fec25a84a9f7a911966424c7e048c99caee626813545742fddea0c67ec5e93225723a2fd3904e08c1f6194c6cc72f288a63d3e911ccf0d5b225e4e79a6efe4caa03434e2fe69c92aa1d7da239c474544348a8a1f739e982b3da54fbea632bf980a6884302e3cd325d0a0d9336783a93db206dab54468f17e2d388656c105dfed1e3b7e7e73472a248adf72e70f37ae48c3b52a8ead80aaac05c3c83c6cc6308b55ef9621530b632f98a3eea39442c4835deba1d9b322e8a4dd72dd9eacca6270b3a8478c1a3a71353bc3479d3cd4f32e2c2e6834aaa726f719b195de3c455b35f3d6c9edff40893ae041ef21a24944174bf0bf9e56cd5d9c6a79e54e545b274d097b0e2b4268c3d2e5883700939c59a4827d35b756648c132e8a641be2fab74ef1a2ce1a19a266b9f01d486e80aebbeb103dcd0f6ab35790dcf0d53431c177b393de5d3da87cd311e44640096666988a6010bef30e72f9165e7f5f05be353c1dcbf50aa9d6b64f7f6850f01df138c37216bca8c558062870bb15cead2d97bf901c1f9fa962867436e1ef3c09abffda38f91e0c0f36f25bd66ea24ede875ca68116500fae0f809e3980db2ad48afd61e8eed3c0534d98b63c59b3bd474dbec27200d86ee0aae30fd63c17237c32c8f624b2db8c736bd183d7d0d6c94cc14a465b9630a1249723e5daad82cf03b1e32424a44187842f681187cfe25a37bced24ba0700db6d92d8a1c7af14add82756fecce4a4da0b5bd8aaa6a2e49d4ff563afa110f0f82043fe0aa43a1f69a874fbd8367e246d5f1e9c8232a4a12fecc1e6c8d73b94ea7f7366c8f2ec3664c14b22aa48c68a34a5723b1985cd58e2b827b598ea63b445db39ae88995f57ddbdb4e140b9383c9eb3c611c545267d102c735c3b43c01c0782e0907d62a1f26789d5b959fe48ca4fe5e7d870556d65b98616f4461eb1332a9c9724bdf6bc0559a5fdf0e545e3fb8fcc50b7d1d400532321982815412c6782852c0fdd8d9223e91d6a8431a3e76bbe200031c67027cce72969be1ffaf726890a55085ec323a6e1b54f7e683dcf2fb6057263dc49c22fb66bf3e8b08800a48c409a96847b887c8c704d1f22b70605367f5f50655bb36abc63ee6accf40d0cd79ed196c3749f189b90081cc54a06d238c62c0976d4e98b0910420709cff024f6092498b4d91903fe4a696e745b9f7c62e54c09715abea31270ce48657ed68672052b2c6ea8eb08369255f5067518e5a1e32565c46751304bb1de638cdf86ae037730e8e91769c4af0d0420e756d48b2f1d28374a6fcd65dda6a5358bb9adf427141cffea41641607477af637f17c09fc3f85c00b80817729a83597394c7857cbb952325c13fd961892397c9655c37cd0111e664de5bb1e63d6028d2907bb9d19b498a7cc65337c9800a34f96bf1a2f3f1fefded6e6a859772ea7bd616a409a4954e4a17b0fa3a2919671222cdef23fc5eb073d7317ab3f79e9fff660ecc98bc29160e6b0a1ff9f13ee24c14fdc80c39d0767348d796452c303c1e108e2c144c6b9310afcfc7f22a422704fd1f2ab2876ce75d8b2513e8b1fe85520e5a879bb754487d86c33cfe7eed3ceeafe58f8d50936d0ff9b779044bf447e175f0817148d8ac59fa3afe96941728237de5806f6099fe2892e2745074599202dfe7e8b2544174a928508c4f4bfd2e5367a012585dc32b2851f1962699f51f7bf6bc2e14376d9b13ff74ceb899f03b875a6c9270cd68b4e9c96459ba5e18ba9e43047e6e219b5b0c93057316df0d16f45820fd51568188de858d73fc69082f5b2a0175909992d49a45f20508a8f6a5571ea946af89646d2edc64100b7b5ada1abbc2e148f87b335739666b3eb8be9ebde997ef0467108e5e7ec3cb763a266946a08ada4f4be094591241acc90d049fbd0adca49748d9ca12ea417cccd4b5c24fc4138d32802762c1a1c947c035dce89dbcda130cd910157f35c435b21bb6149f8d068745d6559bb9564343900561938c00e387ce62ab0c737048c7970f6f50e832933e031d8803f77010bf0f551e0b642330e82d4800f139b011a6d8c18afb3637f86d7c1acc40a848cd852f0208b3d26f63fde37b2c6eca0ca1cfeed899aff1251d693a55c8652a717f0af2756d2d761b617ddb2f34a6d4f7134d4b2fc4723b33df5c5243ab1f67e2d96a01d602d49b96763ff7fc8c91e2388e02410d74774fbec8943209f6804465f0caab33003289d16e5c891cda390ced9d4f82cf71bffe19d2835b37150faa85d780f8b73c05436bad9fdb7655c9f209c75ea9239e1050f54f599cfe88033b391ace22cb6d2e562de43df2768491d971334913961da38eee87aa509ec881244b4c360f5b0c4275dd1b6e1105f04867cfa1f57b8c5bc5c0e1a196774acacf70e586b8ae1350711e86dfdb3afcd32f44d681a2787941a7e2f0bca39a5a4cd34516d5e9dc39be18ad23053d14bcae82c96f1ebbd5b863d63ed58e86036cbc95233be13955bf683c692a73a1ec3443e39577e4a94b06e7df67eea1a374d7d82b17588690b5e5976c4a482d05d18a1395bc7beddd593eb989adf44c5d8c25b084043cf4684ebff83ee77f91dd98c9d2baee771aeeb2a2904f5313b0b5c691a2ebc8f1dcddd2e7b631fe277bafd5cabecacc91ccfe485943db99b3e6c13406b75cc0ad8410d2fb5671d64d2534598b646c20855e7571e6ab5412e32406c3d1feb484d3768bca7780ff17816d3cd1214b67882db066d10ab06d94afadedbfbbb7b25c357fd247dcb27d58abc9b68c0a03307c4721dc63c09c2b7eef6de5658435e6d383727eb198a3fd8be5492150f227574f6b5450ef6306afa08338fb9698109aa60d63a8c784b4ad4fb766145285af46801c5d000655e82d97cdb8cb88380cf24e637389c474ac93143b62ae895c06b5c111039972a79532bdda98f862b677b2a035c1467c807eb44337996cccba060d2ab6a093c13d66e2b10f1012d6052d492f4a175811bd349786c15a6e096c5b5ab540119f12da17fc445aeef1767bd1e7121309419f4a64316f92667cc6639b8b3855f2baf3f84489c2c834a169f2d1e3c2ea03d2e264ab7fc0c0edea7347d5666ca1d6d7b049374b01dfa9356845b3165505f48bbaf83ee4ed97b7ea2c06f7bfd2bdeb7f4bc669e88ca111fe3b33a575fdd5c1f6b42f27f8d6f254165d8ad5c935c517c3c8ebc7ef18cd7e30141050985602f307329ee35d5b22607e94ee2fec11e149bce2ba215c6020267b8bc2f04c594ca8a4cb16746109bc009659fe795133296892572651d645c4c45193c47370bc58bd8bdb14746b387b9b988e7f3bf33eea5daa42d0f9bd9813a1b742fabc35e683f8bb34f8657b2007eecc194c26bdd8264c468d8e86d09339ed5409d2b41981e7d635742dba68a6d4c23bdabdbbdd1dd484d6d00b94b56f3a1db7cb72988ed3fbc73df492f36cc678e8dd222987145b206c80e7c576af8e5e20214bf4c6a7ecfad5b85830e4b644ae3d04932b7d44aeb7c41fdf51eae5c5ad4fbe47906a8a0e5064d131c91676f539ab2489aa667fc025eb622ac1d111e1099a4d1f4e6d0a5c2bf9f390151418fe92856e55f3094beea6a4446c363fa866380c1aa2b98c8aab931a82dfc71709ef4e7c4c3a68248bbdff1225aaef8c3ebd6532476ca65c5c5e008b78a4d0d22b4f17116644e8679dc3efc1f0dcf96fa3c4c8bccc35a6c51021c5453df66c05eae4e246446b88cb3600212ab222ef9635404fc9b2a8da178fbef05f664d405cb0d33d02d4d2c06058c648841a60f2279814eaf85f01c24ca3caacc3955050a669b0f3400dd6e37616a53f489c5541edd37af2bc2bf6cae394b73dd6a3b4ad11d8dc4b137365cbbe9307437487f8b0b837fcd835bf09694761e4db93cd843490da64d3c209e955cfcdcd73b840d9a1200ab8e8341b54983d37154fa07351c3a1e4d74e594774a34c04a54b997957bff0a6caf7bc20c1aa7c2de0ac49b28bb1b93fd219e2e1ad58a5844250bfdd32c4fc1d9b34e534b6b52fd86210d946bef320c8a820cbbb2ceec107788a348e885c239e4541bdd98c9d4629374e474526722f494d1ac9a634be19d27fad01569b45b9c60b50448691daa7bf8b3edf3f83f1806da3d18003d39ed81ccb6c68aabd8b522c82ff5c1adc6a102ae10e6ca05971582e39866910a772746c87cd5fef302764507e6a51508459126901a2311138f5bfe4518ee7b8fc6b0b8b9f43ee32d4fcc7c774369dcb178713f9ebb408508e7f76e9ef2b02cc122f79cea4e4871fa9c9ed13e2e44d5d75269fa961572d99cf8855d24f9fa59ff9b3c5ba15ce98f527b3d0dd74eec97549d1d2a1dff137e13c476ce6c9cd750bbf1d71644fff4d6f2190f7265ad2c7cfe472f03387b543d2aaa5e556c10bcb5556ff6085edd27e971ab8d02d92aff443293e73ada8fef22846d2f5a68240699be610505034ec0539c017a4a54d16283acd065d999962b888550854091116cbd022eb525ec1861e50edb026340af68448f9732705bb03ff9b7f35fb9296c4f698aa6c32df86d738dbb44c2ec8eb3b848da90794762433fb8a8ff2b34ac5dcfe553898cccc5140d784b5a25be5eff7e962faba25cfb15a9294d5074027e43a847a07cacd899d0e4cbc0085fca154513fbee8da5c69fb6ce56b4d7c5ea393f50c468659a7e82354bff83b02ba88913061f9d9abce1d3c4091badb2a54320a87f4f2d71dc6e9f21cde7ce82a7b40920e84fd92d3aba20f960acb06216ff13695fc3846d7c96f84a6b219818273a5bb976a1db7039ff79ade180951df296932f0e00a96bbdce737fb999352f5d5cfe9b215976551fab534e9ac80c962c773aea5c63c8512c9309523108c836ab8ac3e282c244dd112532c795976033d5af01ced845b9df580711ec823cb244b962f3fd153d82b6266fa11f11d6a6c27f9d53949dfaff09a1aec48a980eb99d081d575937172ba8a875df1212817cf1b429d475868a7166333fd7646dd4da723d1158e269360e0d5b170f44bb2f97d1572ac7411d9e167080d872efbe39cf05024db3de81845f3126246d0b33fe3d3bdc8d0cd370a3bcca37627fb96897eb745f56495ef95b1c56e499b8f165cdc0b4c4f3435020605dea2af1ca4e6371198cb118af3bc6ffeaece9ef54c036bbb04ebca5046b439ca85edeece7ced1261d1ef7402487a449a07df6204203d3869e9d39d02d5eddc9f6a66b891297767769a4096da8045d1ffd18cec93cbe86787494f9b756f5e3c9f738d9a7ebacad6ffa4a5cc215166d80a779a1f365c87c0777512f2411641abae765687e6668fba0da5470d63070600450ec9bfda34275d6f66ed90c6afa8bdb7003f7dc3a18149502fa096d96745d0d1aad52007da516e32ee6b5a38a310bd422b1f53a51d8cfef900c8cd5b722858aa57504b79d5274db7058920e4c1e971059bcde08640bb7090722ccd29f5b573295660d69cd254c936a7fed38521eff01f601fcf9fd547491c2abcacd6ab8d8ceaf9544b7f44d66b0c4dc63b9b3e05dfa6c649094681faee617b40764ec7f6f24ed88a30e78601358a8226f640911550a9938501fe3da050f8eab8e07c9867f523ece285e66cfa96971604f45d1074f4d4a2f1be9ae0cb46af05c4aa05f917f202e9d002cb8930e75e792c2bb70cf60b732883bed7e3b08eab5e0265f48ce17db51f6609a78dbf8a9df88f59ee2ed25c53517f5d2659a3e74ac1d2f85254f91958c17bb81df2b5593e0448db60b0e02044055dbb3b634a6b176b4137b97d70da08408ccc21694e9857b8de064d7d3e2ca10443e3f5595e1535342195a6dce0f3ead20e1ce3a8daafe97ee2f9b9d3b817771e8b3beab6f095b0be3bb32642f5e6c5d72f4aac3c0f93a2fa8c1100ddd39e6f55768c09507f5ee79c92675442263adffef8dd5ef1621758472b33972b018537064ad3e8505b8d86c9b0b243af7bd63d23a9d369826f5ebe8ffdd37320d7f7bed28203513fdb07ddc3d67ccdd5382c534565717a6f5512fed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
