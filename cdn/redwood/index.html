<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b652314ffc30574418a57c1865151b8e9a375c963f6d0cae527625415add3fb8734e9b799d864e18c7f9b4e782bd771a9066d97ffdd23d83043b5f47c868a9211a636e1de204a2a537e78e686dca1c81112c1c709f4fef048d9fa956930f69d0ae840aa2856774e64e5a191ed3650d46d6f398f44d45e412341ba09a8a92bb4169a6e6446334b41e942e13c8259892ae7542e27d4f21365a9a768285d8ee3b4c1bceb5296b67cd5b21270247ac3fe41ebf5f89922fb46b8415e9e10f27907ea1f3a9a9c2126a113e081134df2268d5e695793d662c31e5bfdd8b7577d5371f0bc041af9ba1f6a2b0578c4f697c0db74abeb707e18bc37ecd01c6cab35fe88cfb2c303ff9c7342fac03a52b5f32ad3946288f16935dd94dc99c783120c19d001eb6c931c62d65b83985ddab4289cd4ad8d8ff4a44b4f1a4df245d6aab6bab6fea88851b9a85c20a84c4ab8934bf43ce362c573a91f18a26c2e7760237e56ffda44dad82438bea40ec3ecce7c72d370dc5ea495b74a588cda43f252d899cd04f30c9d6c92ecc2ed546d321a4d872dae3d455875f0a5a848a449790a6f125781f3dcf9a64fdac42ddb6472afa699c223f5a98ce8f4bec28c0a84b21c6dd16bc742d5cdce0809233bb7f0a906997d7284bfa9d2eea4ac8317e9cf24b6f0e0f01b2b05ab9a48a8146d2ab9809c73f3915cd914adc006a53df1b947f1310760e0cb374289a3be75431cb68e4c2242dd66dc4c66262dbbb2b916a2cfe1f23ec11cdba73c7c31ba5bc043fb46b49d276b517eb34d024a7e393363a707df5dc1d090b27f2663797301dbf23181dc2a7d42b5afdd75bb3610d1095b6bcb85bfa49b3f7d12712aec7d2715e3aa00cc38d5e6a404796e04447a5d6d3f1a8207e4067c22767d7ef76e699e33766fcb504104f1157816f428aaeb5c16919e3cbafb272b051ef5608ef4ceaa31d116e786dfeafbc32511d2e873ed61317d4a78af032cb2bbba7d5722a6c55c8ed6d07c1ae8997d0c97eb5575640e2e46eafbc8bef7c8521fede546cd1d96087ed698a3d678593f3ef4260709041f9f6ebcbcd6475177f67685e2562d1fa1d844f04651bad25c8b3d85af5e019f5e96f39747f44a44d7f8871c5f3ecc48eccd4bdd09b32cfe4d0a61d846205597b2495820dc85e4a267dd86e4227daa84442e8b3f4ecb281925c165747ca0167a72028c9c00b778088687fc4c9b90bbed7c059afd031a9a37c033650caeccf20df066f8cd5ec80d63dfbe6a7d3b070a8bd110ba0725fccfe7ef0da5afeaed26ecb5e064d68d10f9bf83acc11c87d6dc05de16ea94163eb1ac9ec7565965fd916216a8f306c220c27fbf7de901dea35f40bebb739ded94e2c1afb2340447d39f094251ebda48974e7efcc8203c53dac5997ab49c28bf3e10837d0f9b7d1169830233efeddd148b1c1c63562c08c2d3ab4ee300e4554c9cb13a8811d46d60b2af2daf1fb242c553df00a7033e14bc5b30897a51cfc2ea9849012ac830fe4e45105d1042d19844d0ed2a66db3faaf52a178f38f553614bed5832026fe46ebe1bf4dcd202b95bab113fb68c544520cf2ad3cb828300dbc1da20bd1f3850212fe7db6122b681c0a9a63e9f7cc4d869c3c78704d0159e421c4ec503797bf57d97a1e6a131642a016a693cf803f7a5560a426edb1b35130f82b0c4da2eabab724cd88d17f1e151ba34c29be8e9358807119b1df141dc67ca594385d1ce533011417ea69523d850af244b1455289877f251b766adc24e8c16c421b7c2426c991f264e2b27a2f0b831f5f94baaa0d5c6ee25cec2da4f6103060100c064a7d7ea64d5bd6508dd7793213d64a0da6d2bb51cd85486b6c76a0469a49bce07d49b4b5fd49fe645518984abff78fd74136d164c97903378eaa43f8d10c8b115f3394e1c106b6be9a55d5e4b03041b8c3ee640b39e47ae937d6d1fd9d7ceccaebeb54b9b8c530f859c65e46c7011fd19c3ae5aea43a2909b0546758dff4d0c4487f09ffdc21fd57cb621000af1c4497f1baf1d85eb6e30601e6470df041e428b92066654a1f86bca31e76065b8668ff76bdcb98f0ab8e5cd3318f33a46612fef708ba842119620274e61bdc40ac251889b0c68472752e6b26651d69da6d1065da186e51eed3834e106dc8e6169a349a4ee1221759517b7f2f8fab8f67c98bb49f33e07f2aeca4d0ba61746516640be32cede6b0e455ab45b98ff72590ddde64d2284d5938bea9b362fd1e2ce13d1431926382b5ef5795123cbd96d42309d8ca949502f6ca772ebcf855b4c0422925df47197d91e67c7c91ce5153fdc17a0c90acedad9a300bda834ea8fb9cf3b715e8c13776ab34732b5ad1d69a8165a7d64edcd0c877d2df206b7962fba83c8e68ce47635ab28f3c8eadb1c7830081730319276ce2b0945ed51bcf84761bd061558dc1cc317f34dec451992e632dc1b782291b5df4218990b2b493c45733795b128c5100e719aaf602e6b5825c2c8816db872a95eddd471823b72ecc51e070a664f668625e89f2898ee6512f550942ff9e48ebcff765f19e7c5962cc808813c824a0a1a47dfbf722b27eb4806c7a0b1be377bf7a46dfc02e1ffc93d90c9c414155ca2102f7f963a5fe62e319d92e06c05f663bf584f923f62b738f6b084cc735d6296ca38100dc6dbd8771f57eefceb5280bd337b71df5afe202b173b80e260ef68d6659633112246d27a89170bdfd8213231c7e8ca2a88a25e91fb62f3c01ef245a2f5131aef1f19969660872ce45688a6f70d674796d92a42c40fd634071efa8eaa2eb1c087d1fcfcc861763c5bea194866adfa6052a2967aa29eb5b4149fcc00c701ad5261a36a1119f267d58bccc927480c740a3cc81f5a45e8bbd633cd01c75ddab26feefd53f6629c9d6ded86768329dbbde38d4deb42ac65d6961285a98fccf13e52d69e922e4bbae661dc6827fe92ef882a087f7de4b9488a34535b6fcdb10334102d6b51eb2d0ae1915db44a3aaee81933befef2b7690f539b0f05481274fc88716ec739200b4fd42f0abd31dc32883f336cdbb6ed9defbc407bcb11bf84f2b118e3a184c6d208130243234d68dc008f8d066a688ed0874cd9931f557870f8120de105c35ad0ba8880678623ba040e5d9bafd814a758f44691af91a4dce14c28fbef0e92d276f263c67b94ec1544f669e56ec2b17bb188cbf6074b037b9f8c8d3f8b2c77f11a727ae1b0bf51b388927a74144298db37b1e14dd13fd9d878839fccb3d973a3b20d52595f026f3ce9c01fabcad96b36bff10e55a38280372023d43c34e61f0e38c24761214e2dcbb3fca45f73d4b00224428188ca9e80444908a8a44e862441601644c93c4f56279a9654f1edb2c617ad3e9682259319efbf40a0e9c776e835f4a5802e1129c68c3e5e83bc3400ee77be5ee59d573dd4dcb4d49806f2b948b5dae9773575a57f7742817c18bd9819d494764025e16772addbe0edaeda4b0602e3530ff0e3597fb5c5693d8982a7b80380099ca75ec9c042a6715b3c88d054558fefc5cf74536ebe632935983ae031f08492ac2598eb7d86e55d412d5d044116a51863f673caeaf22e1eccee9e0905f3be637278dfb48d30a0755707511e095539f69d573902b8e2c4b5a4e53c9fd3b1c0a89df08752c527ae73a1a2f0f611d1555ae91c09e7662c5591ef48fc3f462f213112f974fbad52dbe584eec66138af92efab347afddf8c34418fd3d8f556c8592d12c5cbb1733f5ac4f226e5fcd81e594579101dd7a5329b24e26994c10f51d93d95ee1143177fd5d115852bc8996f1c19d400cff41ed51c662e83b46eefa29aed2c4bc94e7dffd2412e17736fb1d4b14baa832cd0aa60e658e328b8aab6f35b58610a1ace85ed2863f7b1b6956b37b5b00fc675bc4feb5b9832268f213ace3593e9e24187f9ba0216bebf784586c856fba0dd9d7129577dd5751c7e0c397e8db78eca5892b9896d9263d297554552bed54cd80b17dadeb3f237811c6e64407d0bf201ee8db801f3eb8c52d2b1f1cefcb6cf02abe8c72102e60a79937a7dc90d4655904098afd01cdd62cc1817d380a22ee590be165f1d0c164b9bf4f43603ef7b5ace06b5ed568157ab49a22ced05b7147b10a2f73de50085216ab9761b360e282ce3006833b8b988b321426c996dbc5620dd9253ced1d333fbf44d5fe42a4a423f7ad75b23db5bd318fb2f4854df71965589df1ac706a9008b742aefb4e89490be73c21570941d87c80612a9c2713b4a8b631dfdf8eef6239eaef18113a22792b39d15299eb3b8c8da1bb9385e4ebbbfe130f38a10eef9ac50c6200470d8f7c2d419cdfbd99d601dd6ac7c74ac87d58543eb3e95377b0ed9a5e5c44a9d99bffe2777e4694805f10a157264e0d38c9a81928dbaf114a1b20fdee6506962565319925b12786ff3ddfc1955687dd9be54648fa1cd92b70a5ebd58feacc70515bd85bd4e9cc54dbdaa27dcefb4fb1a08ba0d9b8cd660f2f863e197e77d00ea6bd04f6a8037904a20f09c78c7f567bfe0ccf880a142247c5dbb9965fa60b4a1d843ac4951bfd301fc22ea5db64ec41339eee71b4bf7c647f2ebe9fb9860538bd943db2c7181b3b92c12b48ca1d81224056b10b3cc74ac6e4448089b7ef680ecccb5315345bfae9313358e2e6bd062e6d5c1981dffbbd145d2f7c98a7b46e56f1b8976018c6ccbd62a2577cad1e74362886ee6facc1df79623b435bb95e5ba732cad3492a5696e773bfafc6aca8d12ded1e57e5c6f81d5f7b2574a68db8a4a01221258643fd5c204bd3c4f5d7d3d8834f33be33843e2c60dd006dfef33acc0656ee2a1a7abd9a68ac75dfc27c5b74caa0198a100fce1e81868013becc944e6573c9a11782efa4d8363fd1176212204b27b2d7ba484d6264413cb32948aaf3f2cfc2d1cde83f9451571be3768a12397d20be09a198da7994f860c9f77b032be05d191432128d68af6394a571090c8424db3edc63bf5f1fa609bec51a24294058dd610a99f8475d823ec49e2c5c0c7d9f1ea4f3187921544a0fc4f45df6a43b91becde50c3f0c07b939e0d9fcd86d8c7350cdfbf920b5f4083aff745f4317c3482906f9e8442771cd9b444752f618cfe26a30f2529a3fb61b3e52f455660a348828ecf845d5d738bf1b14975134fc60005b6135b6f72f932de5f0ba299776204c5bb69d6b66a709ab8ed4fece3556f836808af56f7291939b7314176542b51d3cb8bb31e4ee2767612c185c58cb048e2ac87f3e8ed9aa57721513a7bac069967b432a8a54f4916190fed833221b862722869163458b1c589f985352310a6d28af13826a637152aaed4c9bdb5e9efd4c848a0863a10e659ec7eb7d828c6f28db5e68310727d30ec8a1af670fd2ed362cbc3827b1e0cf672b41e6420ecd8534067b0e060dd598208d8e92a418c6319065a763cc78aebaeafa1ca57fed7b6fd4443fd6afbc7df058aaa3130caa37197ef42a8ffc85d447123a6e871f8d4b1545e9a826b3e296f2f89708a497b8bac9e3e01474108bda552702a7133d748e54ef862d14481f1a4da13d68ce1914e7669d0e7e433552857229c7a08ba0e0008b7ec69ef4e01704050fd9df3ec3cf623beb4cb8cf0f4431cf65f59bf8115d4fc0ff7b37004a6aba9f6bcb2d545e879a314829da7f110d16a86cd72fe07ce8da8dcb217f029bf27f34c214ee629843008430fe48264a9be48309bd2a6124707b2f39d4d8520ba5e8e2579b7e38ecb76f993368428c6005eb8f6fcb58109fe544d3fffdd57c9e04c113ffe7abe5d8da9a13ad2a14d82efda391bab920f46a2e762d74a169e73fc9f582b2000373bb1391a2f8254bba18507f9afcd30bf1a479a45fbbf045515d6ffdf39a01afcc9e9f0d03d5742dd6195ad1334a8d68bd2ab407618165fc285564b88ba188fc78b595ccea195dd4922e94b3671c79955de1f8798677e735da942efb1ca3e70114236584387a5db68fa88438ddb55e68cadd6aea6be5fc3bfd99276f6f9a778776c1e991d5208fd0c9d44d4751ddaad9b0e344348b5ae1987ab40661384e97ab7c5f5516fe3f50b0836983bd0e5750d40e0de93e50fce80f625f16abd86c2c142ad50c2d877a85f29a98fd3f75612ad9ad3f5eceee3b260d8fba90950e550b9a70e2bb5eaf5024f99d5305d66321a4f60cbaa301b7b1e3cc7e9a31c748b494c86704147d3a4ef2a8d5a4e1c0101512c847b1b89dca8333f6e7a2c0742722389280f550dd46a1089a0cf6f2b0b70a5672decce5ca7a9d596c5f38c087ac6934465731c2b6c92e486b8238fe60f81d38efa878820f3c512799bb609098d48e7db29c98dc71045081318ae043d62decfa78c741eef0379bec8950209cee5442c6e896518b9072fbe4ab72ccbd35b8a3ede3cbb3f85f045c9918db2ef7ce675feab241fb33b7e8a66def351af8a337ee444e574896c16f615f259fd51b025aa369ca7c8fc709f262a7647465437acfe2e14c2e963fc0a2b6b6b4a71cbbf38bcdec82fe81d37ef176b3a371f95fc25412791cd463ead2a24326171acd489db65dea424444e87b3f7bb2903e9901120e9d98e1dd89f964456299decd0a7456854800c0634408b3a82a9f249f50378c218e912519c0e1ff62332f13968a84c1097ed33d8dc1ee5aafcbf67612f409aafa6ee8cb05c1ea384510b2e3496b93c2ed8116bcaf7cab37c742dc6f76f9e7c4f34b73acb7456e10b0ca235ce68fcd62dbaee9b0313d2b829a2a81816eac998559ec40e2081b79bcf3b45467e14d8765725016c99ee4090bc7504c3036c8d0ea248d1faac120437f1aff034775b9b4c380d65e0419f1c6fbbb3b423b340852e93a06d2e7fdb2bfc3908a6de90b82e77fa2f22cfa274a235baf97cb919c0390b9e42d6b0b5180728e00512af2a6659e538e9d3374d9f598a94b84f7ca5ee2b873f4849f01028c1b66afb3d82d5dd223b6c3ec0832010e8bd11987f2fb8bd641ac452278d2a60aa7900720a36deba0be8bb75091fc8874c8e4c4611ff65c69755ad3aa095d03c42dac76ae1ab833a41fde7fbb3baed86cb85581c1a922d8d8ae10107441bc2b7990599e93c42142a6d447863f124013195a18abba10559de0efc87ed4b30353099a787a5f2a1588b2e49244cd778938f25e8df27d2596e483eff3b7d3c0c3e29e791c1f29435ec70962fbc94642923fcb27383a89ed2bc1c89e4b3f7f4f7f3d0798f647ab5efa2ebfb129c40601387c222d424f8de4263d5bd1fe17d7100431070fa94f53610c72cd919a1f7ab419588daf612f63cce8afeb08e933b33fa0d7d01bbebb259ebeb213abf46ee6aaf31e3c49491d63f25f57622f88556d39f5eb7a54648ec5e0d7e1cddf6abae770871e95b9ca9dd0ca42af74540dc5935a7e07a0195f740ed3f04ca910cb6c1fd33846974da4ca2b1c2f098dccc76bd75f100c53dfd6e8a1b80db6895c8726f7e8d2a581f2451ce123ea9a523ba6df574bd313cdba809f87ce894b498cfe0ed8a279ce72d8ffee59997dcf7ebe688e6a52a8de8e5014b33a643ef930766d15ab13f9d16313eb2f32410196d9e5d5648c38d6801fe4356933a1b7bee1297f0e4a14e63df755e91393827132640f488a3736fccb331d3d9864f88f980e00bc3cb97fe06efed0ed252e616bbb79b3c2f86ca2d75df36647dd18c75cf08b693bf4f6e86bb0eb8549b26f1d7a2210b750741ebe8391fab468199183c28ccd72487ac43128d3c0cff545644a0cc20902cd973b42324799bb61a2f677aa6cab302712eaa28ad1b0e48d851a9fe3f6ff01f03fda556808cdff51d4a4e07260d5df73640f8550c99a79596b7dcf480f9c390e64d62877d47d1e9a4e6af65d411c16c01f06245a0f90f37ed2f24730e8b26833d161f44a6544e7f3047871b3219c422a7f31f6d55b93d9fa9ad015f2471487b03103cb8b23b3d331c0245ea30149e6f69f401cc6e5b5e4e83dea0ab94127cea500e78e8e501faace40fae30b9e4ce248639a2c7d7a2388e1d4e804c762c0eca59fc06dbcbb5c638a180fe278ca348911fe32e450ecdca84dbc0166d6e0878edd1f62d177f7f52fb50c49dc34a427e4841109956674f78eddd82d40c67c4ee766b5416c04384f7a591580eccfa46bd220860276c14c8ae0ea3390ebf925fe4b928d4d9bbc27b96cdc40ed46df2280d24226ec8d1efea5cbf28568b6c249431099e208cb117a5426bf213625115e727ce922c1f820d5f116721519eaffcb27d81a8a456b3f96dfcb45ff09ca0c26cc50531c4d7271d5cfb6935f26bc88e4a19ae1e5bd8801668c2626f582c0dc0d173c6f2d4517956f8b85abe8bb223dd3f7bd8b8a50ba33cb90e1d0c4d251e935855f0eef3d726f5a44bbf9002e1f1937c1f976f2610677f84640842758b5fd6890c9b894a6e251a6d2c4d8c6ef3eba9bd8c45c608834602c850f4e15bfa0edb6febb3c7c7aeb4ecad5643bbcd583b4d0eba6498921ce679bcebf310a86e976f02bdfb635450a402f125ab3bb503acf812a1fd948fe0a9157ce162b73da171a0abaf7542740f4d49b16142e988ce3d964eee5b30c88273c37158a041cdf086f3be5cf278ce6779d7c84b54edd3714d313ae378306389b689e29bf24020be73b3974654dbe1f5f5415b6460f1e4319cd6de571ca49083f65a8cd2f30d11463aed2a9131a661bcc50b7c3b34f926acb8d42ed6e8cb110b040a1a6c9d218b11fffb4944973aa96f958d99d847dc83b935ec1d43bc05efb789ffca9ce2ee906ae3b0106d6bb35fe62825070ca873c65161b928c7cd123fe6b187636036fc97d7ed3a11527d73f33fb65e09526701bbf2e0a320fe5ac69861f82e320772df63625c5007d948401c438d0e250eefb16ed4ba73ede42941d328d0c873c00bda417393563cc712a6ee85e1b3e43cf44af23bd98f11266d389dbe8bc63ab2f7b4e6debb809ef38278a387a9280fff5d48d35a112fa852abf24280a9d8d7ebb499c439547fc0609a46ab64e57358c9ef375ec7fe5b0185c42359bc34346ea16ef50374487d064b12e499b85f14af10867d1f87cb37ce1ea88cdfb4b7578af3454387b6ff7b641ec836a36ac6ed1efd12a2d28901ea9159cce5620d05c9235c175b293119835f0eb249de269ff61654a935d781dfafe2ab54e2fda4845bb2a145380a8f9ad1ff2368476f03dcf7e80c330142f429541e0c4feb1a56f1cd5a647b803ebe4e7c16c7b73df9de32675eb698dfc85768bfbdde94fd01830ecf824536c8241472cea4e0d5c02694fa5898749b4b294173992dd593fcf8a6c18c00805559c6d1a6ee2f2f775af7ddc1f7f25830fbe1ddca9bc50983eacc9588c8f3337c388a4950726f2eaa8f80a1d73e067abf19d91027ef6ce087b4dd012b68a38b05af7d986db53cfe5c9b6a5a89f438d656888d85e4fcc096e03622d0f80a2f84b86eb44fbd335341339f735843a1889fc338d05f5c80e5d2c2fba6a59aefbe2a39d8011c6bfe460f688e4f58fc5009a97ac9d48efa4ca9da4821e91913f4bd1649ea4a2166675f63dec91c57b673e8234fc1baee59136fc8f494a83f08255ff72e68a2cccbd2da119e58a29a274673feae8640c710d1895ff6e12714b5c527ce82a7b9abe0055066c5b769e27daa1e2c5b9b9b497b38d0835ef1dea1765ee2eb9e40012181fd1009b7dfe673c71a8fd298feb249e88a232666db37c181a5fe3fe51a754844b02e9674dd20e096d8ae83b158f7f82bde1fc56814ecce7ffd7d705e7902b56dc529b96d4f63acbc8e78022d6ff93f4fc4ac81391edf79f469c77df80b240c3d0e5894c3a995cddabe5819b0123ab6c37148ab109212e3e8b8d49aee200b11d6796913ccca2417069211f41c3f931146aa92dcf3816d8fab171857522801138f751e231185cbddf698af4088db35df9e0675c56f6773f88fa6bb95a368a0e2f640161bca64eacd989113d1c62051f0afef78af6cb6e39bd38fcfd4fd12b640ad545fa8dba4c03baa99b92be5b1f43dd2a94697febec42cfc44d4f6f53c045ce87474701b892e829d5479bbce3b7c2ad1bdb088818f75a4251f512229f483a6a68bd6093142860c2932f266e01bf5c4c44e3f1acc9144869d7042c8d1697d78979ca45545dded4d6cf58676cbe8108c65431e1c2a0484c3ea519d8828fc3d130644b2ac47b7b347021ff437cd0db26fe9948353b5af8152d5feaf5d932cbe5cd699d256e98e14f4725011e40b42e9cc6974896342619f4c5c50cee627b454433664b92ab5873780f84bb049706fcb4976e8abe7ef5ef45847895f6d63c9ae08f0345b95cec1340db1346de0d33688bce0d3a64a0b0c85a12526fca947470e54f77167d5bd14339e949e3a529b97197c699a7d2cbb9f5235eb4007757de36a6e86b4db7ab35b767d6a61aa77021e82d78f42980e99b26f014d190b2f2d258fcd748dcd791dc7dbe7b9b6ea8700d131159d22087761ceed263963f37a00c0eb1fa108ff742756b5274767139e08f7bac8cd86f6860107800bad64c9433af8ac3fabdce89112145d71e43d0866e94f0e7b50ea45c7967abf9533083cc403c985c35d1824338b096c6296bc6d19384d922c7b8f1cdb875456d1a4b3fe6a0282b2e183033b6ed2004cd5353e8e7e476fa82e3080ed34fbd0cad656d03365aea8f6f580f948f3a86a5c515b27ab004e20445075544299d2619e4fce47a08cc742546d093ee5e1427a183c74118f18b9bbaf99af66865aac13b6e57d3135f4dce3e0c44ae07d70d6b80b60dde3865e1302216ae9056a5d6c8aeb628ec4a2782da27aec5f9fb3d042f5837636b294a8b8d1b328ed22b9d1ed5f81014c6e5d7bcd056de98fd01af834581e1ddd5bce547eb4fc7afb1e833e71bfe73a205c99b0439ddcde4cdcbb45585f508531c3bdf6962d0642a38a106ad0c948347786593d5dc7aa3fdd576f8322f44c785d8a422ee6cfca8bb846b320fc8eab27c6f5778fa5c7d9758d060eb53e9b83e822b2e390998458abf4b9f0009bc4880e968ea419956598c403532e96c6f4131dca8e9cc5d9c2966661bda9bb8adfdf1c25e74be440d79d1021f9124a1fcf4364645366fcf5b60c3d48edf93183eb27d8bef438a4813e07650050b51b354f7a05f3df8d178c3441446c5ea7e1204f525ff4a30ef739ecf49db61f87d6328bcc48710c54187c213ab73711176bb6bbec4faa217f8a043e7a47c81d48a3f00244b37185ed22d532de1ca3660fe8167052789287dff6be3edcf027cfb859d0d97bda968d0ed6b24d991f950eb14fa5deec3c79f96299452b3bafcf316752f343918b6444f5553e8b8524a1850f8735c8bab03ed6cadadf418618a3e35a3970d6a1032cb55749ad095079ad96c52b218765638ce9b2f50cfe7d50818f788b014080c831ed45dc52882866f7e5bb9eeb7fb50bd0dd0156e551dd309c86391ed8979e6555a529312c1d3d41bca594b568362dc51c2195cea5c2952da831c62f2fbf3d26b3d772f5237e8b39da8e3020dc5f28f18655227b92ce5d234e03dcdf06529ef6e8fdc90aecb78ff0ff1bf7d80d50ab7dcf47dd6303f9830e59464e0b1eeca9b65268e0db0bbfe4260a1e0d2d2b524c26f67fe541fd5a44a22d5c2b62fa51928e487ca192876dfe06d3dd7720ae49e07016658cff528251626c386ea6734023134158f9cdcd2ca9e11b1d6fd1555bf44c21fe2e2254c058df30af7f44f731a0ff785fb2cd37615a57f12828dd5f9ad9c723a7b2d2ad9e245e591acc4b28dd2c7862db4169720ba8b60ed0f6c10cc00a6f0c4a3c474ddf04473f6ba56cd2977b6266ec5462b9079063a95f05e12688bb692dfa0dbbb2345deb2888de5d0d7314ab63369f156683c83d18ba888846c83d79dcb4e8858fc612b8981cff76f0beaf29ab839499ab368ae65f026d314640a427e98828fd445c7ad1118a102e3e3f90ef8a33778f091a27abf9bcaf87d1cbae398f3303aeca5ae35d1b15520f15681c7966a86213943b46c5ab0a1f678f47c1e05ccb6e9e958d815b416c619227551d07bdff75d596a9ac284e67827b2954376c9b832b6320bbc2854622a4840e17baa2e94885170b9992af506ab49c803ef93c9461d55d5114ef25b55cc4267df5355a423a3273618d10154b0c0bdc8952ae259538a633ade465591898816c1c70996ac3df05fcb386c422c747c8e683e5219d9c4de130d75fabd0707967c89074f385a04ba70b2ed0820a2a53d908a587c6d73221b7878816a10fc57dc7e41817ab13475549ba1c44f7f4f987bb8e8ca2c3e700a37f75f70f617e0d3797beb56c9daecdde767a7e292cdf0a6ec5450058f5e85d515e5a418dd3ef38aa4dca6b59dc3ad2266033125f6eda1ee0b35abd988ed5f03a99aea2424186ca4222420ff33122a3ae38105a53b8c2165268057fbdf85fcc0ae0eb673338e053e3020c6791c0450db649ce801c8b4ae9db456435ee48fd83979a97471b4872268dbe3ef9c99b9e1b495f32df5a85639591503c1c08b9f7f156345973071a0c122d298696ca37a1fe19bb172ae439a172030fe3ccb9312b1b62e338538d47adefdbaf5abe9104303da9b9519fba6cb4a35514b810611e1b1b4b66764c5041e916e77f9dc0c8965a3173a3234596ec1b672b4429d41843d92f46a3d5f60905959b645da7233788a1cd483db5c138312bf2e7e3cf4efbe5071b2a603b8eb3b645120eab58d644ff264f5e34415d42020c68e3d11130d6294c5d61730cee70daa62a8a5c31e860591dfafc1d3b5f2acf077e3987dbfe29f4165eebd0b50964a433047751b06f1b8b0a0d870b358fd66152f483948f66f102be6e1e9fa1f3250621c59e507f6bd6789a4deb08add7b9a80eb32624ac47a821b18759de2d4b0cde8f5bc90e7be5fd7155e1d1e6f9dba64e411568e7fec17dd1f6d163214750c9606e4e76021405baf3245b61352742cf417a1cfd64d0a5efc24366e8698220edc63634519af3cfb44b6c3de80dff26a97bb16665f7e239e46e6a07aa223bff7a4cb7cfa3d43066180a7e4e77d4fd07182f9eb5bd57d89972e86dd46893df8ff3576447f6e9412fad762b2e3eb9d472912e3b8dd90ebe5267e9f1edc77dc4e319965011a3ee26c49a51c53ad81de8ccb765a3d355e49ab19b080d8ab1d14a43a5a901fc02b011333d1fbb445b443c4a9c46205a18f1ef193dc42c3a5eb75eef0647c0303dd48523ba8433fe53a64eabb4f7a83b8fd055cb44ef73e33d2276b0c778d28981791af24e95f7ace7edf9921cd437e8471cda969ba2d890d5b972b8bd114fbcc2eb8ab0c36bc12a032a24f507c6f2e9ec94f325df97fe7a6e0e98b5cb179cca8def2e024717dfd09d21be0d8dfb4d217bdc9e5b01226eb7ca7580923540a88097870ea80b036c062e4596ac026ba4a88683968a6a432ea4696be36bb6fbbd902d2c6d9f7868d61af27d2da14a9ae0f8b36afe29efc35918557ee62100503cd15f4a3fee7f025ab34f02ff035d480909dd32e4046042cdc87ab1be28cdb3c4155b8022c37a7776f2594aaaca4c8f939c32dfe6dc6051a08d1b79467087cb08f4ff91ddbf2c75677e651974ea760a359db47459bf0cec4c94df2e6a0f392a38298391cfa031630f2cc586ac36663ac49b886f2db206b9ac2aa164cac0bbe4221ef0eaebc4a7bf656f28adc01e88be01bd9e72c934550f0855d29b8a4cd37b1fb272d9b3c8a77c2e1f46d45805066b3fe6dd1614c75dad6f3d43f837ca04fbc5a5b7f1c8643e29a5e572615c3bcf0497d6cfd461997a1879c1358f6700e5e9894dd9704e8c4d84171c67bf2ca3e403543243452935a9d2da64831fdc4b08c73034367d34874324b9a39502a131b79e3ff46bd700929e1a678c0866e2e190e72d5e3afdf21035d88209d8db4c4226e1f90fddd3f67f8390b30d316dd0c578f8b4dd192d5a03218f9ea14ae7e3fbf87133eb48978ae69fecfbc58d48a666c0ea90f3300e37fff1c674df5b24eaf96a9ce5de47d52c1ba340d64e8e7b4e09db28465a8ed58241b4a996d532e125a1d9500592be37cf494d1a112de30036d3a8f727ec34c7b4abeaa0fa59a838aa8708b2d694cd204e4ae2e0670bd17e99f65766c75e0951c0538922bf0d2e7d6f7c60e20cbd30096ce8414902d5855161262fb8b3216f63611a0a2fa67a7be8f81727a3fc82103745cbc7b0e833f7c53ba182b2c8f640f4271cd2eb9afecfada336c6c5d3877fd5e52dfac1969085f0d6dce96602c65fc3047f494b80a50c03819bb557c5d13a835b402321e726a1924850f40372384f1d0c692894ee217a878c934b1a7edd8bed1a5a058d53f60421021a1fd9042da4b951e179ef28c87129f3e9e25587bc36f2e2565e204d91c0431d1b08145b0d0b03776ff8f6b168f7cb413e31ff3281005c37fe7a61c463a8b44935cd60bc387f46382b4befc817756d2ba6c9be91d86d87f844085463462c342d9220d84e6c5052240033611986c24aba052819dd44f8416786300b39614bd0b5b71aaafee5f2238ba8b8bcf9bd73ad81c30eed574b025a561487d1f2b1ce5b64afc81a9f2113f2fb2904ba70b138a78be7ecf9d6d6509c73bc92e189faa0f420b1538e803fd524eaa2b882dea3544a06860fb8daf858f39de5cc0ac0848579e55fec70750b9872db51857887f34faad558372cba5c80b6222b150d626b292f60f20b4652294d3377d375142dd07fd344ba4567047ffd322d15ad81b33cc556e48d93aa23040fcf5abe431be085d7db9c7db0721475c8ad83506a150012adb085c0af8bbcbec59c83d1a46dedfaf03e8b0490f06b446050f64fb6f77f137c0e9f7d1dfbba97dcfbd53f19b4e6babb8cc854ee65e358eecb4d3a47944be09b973b49a093aa0aa6266804e51e3d1bbf8cdc6e4b5e874db9575f6b33c687fb83b9a82b7e7dcd0775188e61cb3ca4baeea1c1091c298b755bae130bd75a88598ccd2d3235ac19e62c93c97d9c9c2bc91c87266bc8bd2f1970cf628ba6a8baeea35b7b8bdf8229b60ab3acc25e792e8c93482f9a1212a5f5c0d49cc763cd89ee1f1888727679b1a6fb103ce3ee44e7ae2ec0005beada1516bcaa4f75e0ebf801a7a59ffdbfc023142","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
