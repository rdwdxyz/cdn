<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0eca63acb4cb89c0baf2933d99e1f55b8401335610785be7b75b6503dd94dc61c323ae34e9299ac0c6c26b1ade3d3124cc3062adb9e0f8b8e30a53b76ab55472473ef5001a1a7f9cb1f7daed31e959efce414581338db4cb281883c19cb939e602afe6dd8b01cdbb5d0192ebdd502dabc7b10b376950099ab0511f5669d310a46010fe82705e83e3499b6c24b5a36409169df06b7ff263a8ff07996328a7ae18bf21cdda5795e81419dfd3b47d4161c8b048b1ce64bd4b9ed9fd60de4a244f78ecd6220daebe944cc49c9786904c98a0098f56e1481d338bf98a70c3189ac9bf8e4d2f2009aed69a46a898a8e16e595899809882f6abf47971a6e7135d0af01cecc0b0755a317cffa8b0923fe8053c0aed524d7874e01f3fedd9e1ceecd251cc6fecd98a399cd99c8395f7a3ba6bd76d582f15fa4d5bf017b8e09acaab72ae861983994f2d335e15698e4747a10e666f783de638bb081701a454928cbd58820e5787fb41721a235f2546522726c108ca49211181e7df6db8b8d0c27cd249b3986ab0aad5cc4f1d51d00029c7a41eb9e01d4cf9e9b7d625b3e799bdc6a78e94f94155907873476b15e33a9b6a7dea35aae8127a83a9fe10c4a5c55b9e7de3531711ee840e3799361952bb05698c5762b0fd4376d5bdb0726214dedf3ecc477f49efaf4fe1b687817fdeca23ebf816032e684272311945b91eabfbe57045cae4110ffd5e2c66abcb836b65967848a1aff8684cdbb5a00ca0186378bb5172b93989d617aba6b1a21938f4dc0d6892803bc24f66a412a1a07703112d05629297dcb2ddf4d944f2474527f33f219fdf3e0e417b166e32baecad54b74f371dfad40071e3615ae81319a3437e69aa235bf7f9d48a627e99e935354c1b948592ac1e7efd5ae8fe855635ba1d2a14d04ebca589656ec84e7ddef390ff305f5a3cbb6244b2021de80668d54abc90d8322e88e4fd8580f5569470d76e6c92f9639dc47693ee7be9d3d4ac0aeb485afc579bc1309f05871e7742de6b3949a3773a0f37b7ad7ba41c68175b08474ac0d6b2c94cd4fc80eb1d8083d05ca5211a91a0d7d23ebd995b9d2166e6f42543fe26d4639bdcb7755a8fed8be1cfb70ff237ff889294b890b85a6ea61190a9fab611bf5a7019fa117b18b74122fb31d5b80e51dfaf15335472706b2ea3e8ca00ddf1754db2501724c75e50d9bad79d34effb30d81231394ada5921b1b37e611bdd1f8632a5508d69ac14842162fd0f7c2e6040c44eff19e5a1386c33d0c2d7ab9b054a1f702414d3bf428cc14567ef2dd9a76e70bfca99cfa1d86433465f43533c55ed6f8e3641f421ea18a04841e7c625d4d5b91ed79ad0781bb4cb1a906e56333334194bdbbb8599070bbf101d610608dd3d941b80f5ec43eeeed495eb9768650c10add0da4e5ff5edceedc3a49cc002c018684fe48a0d795ac78672c8caac61f075ad17c1e387b626051c435f4f14675cefb73bcea39bdba3596c47cef3de599d19338418934f89dc92cfc71643a827dbe5b956f0a0c65544deb67f17b5766c576de75ca48446fe25e1a2ecf2f3526b1a21a50ffdb10868530dcd872ac30975a5186820e9e85bec82279f6dbdef8f6b02fdba40d989c153abef4ff0f889a9d9ee57032f1ac941dab826382d9605ec6304bdc072edb478576330e6830c6dc21fbb01a66327c80fccd37f8c6dc0ff5467d42fff972757ab474376459b3bc0c8307c508953b512b6e6376d280b2b8e55bdc11c7402d6f4aae109cfc5ee0a6eefabe9e09273a2838d9144ad8711e43547e69b7072880f4f7f647238b3a81e47c3b9d3c4df42384887efb77e5e9b8042b99674930f539ed87d399a2e753f9e5f67281a340e835209582d24b103dcb10e1f1a1bc75462190401accfb6debcd4061d57afdfb053e298bbc996ee7dbaf8cbfafda8b1b3c908e5fd5eea83289567c5ffc84d1ff921d399df51959b9888f9fb3baaa6d3dc4ea074772cb0e2c38ddd1b795cde0bf4efc7f31b89240bf716267b2fec07a085215b70e1f1acd63fe3d03bef972b207e490964cd737ed70a76d3d4e0fd87826144408726bb325613018f8d8f878c68ba76a6cdd48556356f839a6bf1af8ae3f78ccc32d2678a95cf7b5ebd4c86aab984ff5f73641f88a136303184efd5fd269c3b95472dc1d2071fa988f5195e92367142b90aa3469a83121b8908d75ab8a5bc888eaeef16662cad8f0ec17b67a04058fbe47745f5fa7c9fc2c4d786aa3d4fd8f2084cfb74428fe0228a112c0671b656db7c7119b0104769f884c5e5717a2f838bbbd2c510df8635979384ee17b0ee9669cc270c73a76b5f2b5cfcd0e7840d72d37df80304bb6db9091350c72653f5ef30e67e87644c6839641eb847b91d7d22d1aa82f95b859c744ed6f16a7d7e7c1005c902f8d33d1d43217d03a7ebf293b7fbaefdc4da180d7c634a10fb8c9b388216cfe7952b893c694fb7310de4d8c89719c5cc4ed1885d6dac4f196f03e717c0619d1f390f8507975baa5fd6d7cd24aadd7481866c3958ac2cc6bd2dbaf7cf074a399f081441deda3fc2542470536a325d3081ab9bdf85afde995c614680d17cb83081fb1ff1fcc0bb62d68d6f1749394c50819370f789fc7ae7bfecb582b46b8b4520c9641f324fd5414f8b86b8fa21ecc5a49b78ac42b3b85fc828b66084ac0617eca2e9b76e5e0031bd26aca73fb8ed0499e5f3aa60249099d9ec4f6713ddbc49e3f120155b00101aaa05de7343c53ed72b0f1da55fb97637fc0931aad00254921057980651022b60011fd643ad6b055b0c30cab5b653c4187ba943e7dc0e2eb80a1d950297f5b46f6c74108398c89b9a7896adf1b078bcc8abc105788fa22ab597098b98a670fbfc55c22de34acd8556f178ee5c7db2eb572c4c00a9f1229f81bf3886af5f3e5b276970766f21508a2375ff15d63731cc2b22dced9ff036d0254edd40f1943ec6e051425b032b0839c92182efa98ed5c41e6381c721e96638fd545b2f0f4b33c9d0bb55585104c66529b2074b7211de7428ff2debedf8092b7b3851307a53951c10b16c656aedb5be79cf23bbec7491ec175e81caeff41dc3c33fe8b5619223953b644e026277a4607d60a404146a5568226227b8ce9c0f7a3d9134e7d21affc7179f165dd4b61fe388d731763434af6f4a388faa2315d1bd79bdaa9763f35da2c04e0fd0da12d972df509d7bb2989333789f1098d8ff9d90260b3ba62db20f1cb4dde7b667d377ce856374bdbd324bde47478532b2fe9c16ad16891a690cddab9ae2b7df221df6688f252f7900a13894c7c2d51b2068babc7b5245f13e32e2688a28a04a20a0d068f5a73d2a53327a50877a080bf9417c5ca47649046a5684b64cc724e9cac17b1518af2bacecee2dba0ab39facca9e549fc9275016f805366762bda66ab6a0d155d8f64b4aa3fc5d0ab0e4d8e2480784b05dc0080df4f2aeca083202c093c2a5391c5add91ab09f9e5cb8fb6ea701c7e208cd496d0c560c0702a6f7ba3d3e8a91097976af53c82c4e14f2865b8ac22cb4238cb04d36e3a01691fef8741c1c706c215c489929918d25c38f1a7cce91a138cfa1b57dab4d6a458c932ea950a23b22de5e94426df1a1bfd8b20fe4e27c20bd781913c98346e50d9fa79d7a8ab744dce331c508e081c71a02ece01fe6a1a6e505df0de8c48413164cb156d7a1594ecde8baad37be69476c2dd00af4389247c97ddec92c7d879924c46ecab074e53d35429f9ed3e96f9dd996f2235290c930dd6c91948e9d2be7d8d12e792f29a7722d948af381c4b886608560cd6518abd05b980cad43c8d6e829d8d6ae49f8b446aab976ea5c64f6480313aa3c2731627a519b4a20e0bb047efbb24c89f9f68ba8962dbe0280bfea8e04d8079dfec2490884864d939bf421808be4882ed7bf140be899756b8e6e94ac6e86e2ea85f5ea86373eeb7e8d5c6e25e52316d4f0517ce7d0dabd8731d2c85aadbd5b9eb832e9324590258e9a8a9af25e35525e21e7fb3227393fcc8085a4875b60f5207aa3e8060cc56e7dd867175db82ded30f42719ceff2645cb09eef17467ac3c0256199683e4ae795e6c93153fdea03326fb34695919686397b14b01eeb4274a9cabf595c49fc3c7b99930a84c9309d277d32e4780063ac258fefa85ac04ad8cef35b994f5eb804d355a2d17457093d1f090dc5492618a25343b7d4fcfadfd9d50d929f6841c7baca7e9520cf6bf201f560de03e9b8b8b1ebb7931e235904e2e3ec48518e488436d8c252c375869f28191d5f316591cdfa3ad529943825169708b0c6d535f1f373f337de7bf972e37741bb86c25f58eb9f51f9a6b45b123b8327624a32f8adedb32da1d95532883341ef6eda4fddf69e9a8e0dc150f25aff2c2e86944625cd67c9ee0d7b1c5e3b65368798dd65f86a7a953f459416e1ed757659f630eb8c327e5d9fc8485dd8aee5257fbdd894473bac3fa00d4558911be263e2813102f8fb1842bb836c4ffd3a4d6804fb11bbccfeee3d52bf62d6068cf779584b1c0db2323716a26b564be97389eb7fc5deb7ef7cebe093d2defe51d61f625b9bf0e537e90fdbc4898fcbc7bac69867a68047544e094fa492e18bc2b6f370d95211b28ee1c1ef0a5729312df3b8c35490daac380bbadfeb133bf8e44387a8e7352c6484a3a9d3386594974751b6c2a6e6e47e2b865eb29c883c3175a029df69af8b799dce351b73f93e057ef94084a184c70f69f1fc2f8a1e91ba2326aded20880c8ad4c44a6cc824631c3adc26eba208c137245704b2af80a53a02d19ea9a24b0ba3c39f8862ce8d0ef1810432caa269cf13fb4f5068808c836fa5888287febb388e2ef46082476fd55cf9115c58475e406a8a108e213a2b2cae0456ba274b9ef8564fe9ec77c671dbc386ae0bacf9a0b53a732ac738d516ceadb6d0e1b81686d68052b7f60a7acecdfc061c1979844873abfcfef51fdae4ea334173fb655828669c8c2af3cdb171ec5ba51a11516c1a380ad5c97efc7913f03875b9fd83c3b0fd71e66766b3da71a08424a0e3f49d8bce093115d8e8d553c2295cc46b2cc9a999390a1b9b635dd04e8dd06e7f9b79d0ee30ebbec533d5c9580e5e7c8b1a3e364ee9cbee0d8da2968003beb680893892310152969bf313b26df67338bac917299f68f8eede80d409cc32a4f55c9f83790b9b8767f059d176aadda990bc325fa6033908979c438ed026e038f8b892e7575bbbbaa76fcacc9658bcc0e1037b8155c54abc5ae515cd75e5137fe787c7f2d4ed8edeb7978ea76701aa8ff6decd0dd1e16c09db2600bf4b7f7c597b6d9ded267612834e61e4d645d269746ef32a79c9f89c66860d29d099ac93b175eecfa7e71c5b3773012679a8dafc62aba92cfddcd1cb4b8a5225791abf8fa3f097fff3417f3734c42f469fca987f224ee2820d8e27a0b4c513e17daa9e19b0ea40c99e15ec6e21867b838dbf1b2e20f327332de02b459c81c4d626f65d92337c8fc8a25f29ca1dd815c19fe67ba0639956cbec72da9eb6d7a821522664cf80ebb349a7e5bed62d180650ee13d3f8630a2502deb16d028fd29d6733b39bcd17d4874398fab7722e366e5a9e8b3fd398ebd0534d64ba93823e535c7c2c844f93b74162a42ad5a0fcb145d7ba729e3b8fba3b9a19d846d637695204a63fa1ffb88a323175f15121a48dc6a943b2e4a5fdecfb17ff522acd5427e415356d5b58d4badeab8d85cd417607a74dee81e6116c41f4433f1c5ed2f2ce643d10d76309b8fdb04e5f2faf7d707968268634281788cd1656087b786cabcc09622858662da269fa9076f05fc1686060aa6f79beff8cf11c23c086208c02192c19c33b013499d465cf304f23042a84fd8a739ede4a84a66b3683763a567948ad4f47e54ddd0f0a5e0ae5b7dcbca8627f7466a925550fb1f5e547a9623d1e0db7fa85b7401609dbf0aefddcbe87b7fa3e6aef4512444489b8689dd88d0e62c8f9fd4599bdb96931b3951e443937793b3a0a2aa327cb793279b9a9286f739662a4b6870a1cb526d54d7093b67bce7a3f77224bdec297f3604e67bec9fbd3faeb04105e14d3ab72c6247fe6b5fcac062a17cfa236e475481d8a3a331b06e791a7a33d87bb024d67d4db36787d9b578ce5a34e132a532b7d88facafbfdcd6428e3abc62dd436d841ffff5d3ec18c2f694b836d1aa31a435f9b54130d60eaeb4fcc035d9cec727c6918b704e5e90430e3e8d3d90ec0f16ac5e5320343d7c57d94a818e38d5542115f60defb1b5d75ed6a93f986c3c64881f8d6400588a13aae79551b636e7a39a68cb873ac5f0691e07bac9230f8f49ea4b7f7ab39d6a246183f4510e1d8b73e59ae1d5419dbdc9dbce57364c9d8d2a571767892512f1d8b462e9a83cec1e8e524b143a666577f71caead3afbf536b254c911a547c01ba701c38ae126baa543886466ed1891a07093918242e2cdbd9d407b28de4fc74323fb2095f963a8bf3985529fa2d805bb67e86ed31e271aee42ae6f9ef9fb0f64430bfba6ac404de9ef0be7a31fc49f18347fb0a5602a700b76bbed8452151e2666bb214bcc8a479aca958311fb27efafc9e7bf71e17995c5b6c77b81720841360b520d1d8e05e9650a8b167686756f9e98b0bb172c3233a6b3f5854d2611bbb2a7035a421cb0331baff09094b748ef567ef321021b3cae13a994d185faaaf759859803801296051269238a12958c549a31ec72b1a310258c47a8e024fd66489750ea58b7884f5acbad9451f0b262548ee1974e1962f3e1e1159b06f46517ad785b834f677ae27c1299842b8b7b10fa68f7c4b09b236b3a6bcd8e0096c34a75eb35010630e4f8153c6107ad67640ca3aede050e6d7758ae807f171a4031db0b8b5756b965d688f954dbf3c183dd0c44053adafe4f6bd786f13fcca2cb032229d7938a202700c5423d59182bd48af5283aeec1cbd644e0ac986ecae758e124cb798edbff3a9e8056e832a3eec9cf9725a25ab0e0aa9f4bd73af07ee76d138fbd39b78147c566a0949e34a3b8611bfeb4b939c97ad36fcd56615197d523960fae94e7092e82661267a6877862f811b5ac6b5ccdcc738460bc97df7c6b14c74e1607e52d20d92fb03db6cefaa6e1284138c79eecb2acb92ef07e9a2e24c4ac0ddb770f150b67e11f31104234b05d2d4cf2f3891db90df23553e4dcea93db74fe017875785350fcae12d21cfcd38b295c1f61bc076b4e65879d6305c2da20799d25a32a8b03bf62d5c29eab9c8bad75bc4f0d92daaaaea26dc72bbb18286ecffadcea02b9d3e242a6f9ef47cf30b83dac70b5a8648a7f5d7e93d64e3d7a41189daf3baa2598e945293b4960e58af88116158c409defd30c0589641e03febe8bddf6031849fd180b2dd745af3d884ed619970720afdf3571882493742615837da849debcaacd9487406a704b631ec5b08691165b93e9808ba7a4fdef1cd8bba8c3195ed66cd74170be3075e462ac32e40018b6ffda941440140556d71e479f60ab760b4ac11ced26a8a344a0557f00c90996d629679cb042e701772a1a691fe0ceaad07a2fc7275bb5d21d338d28fce7fe2ebe32fbcf5117eaac5ab91c97c777e1b65597cc712edabb7b3f14892dd525d718cefe1a41c9d2b5ee7b8e08889845608e2868d0afc72560c1eff955268eef2a6139d1776502aa51c8d814eb64e458f31f35c75490de0704e6deced4534e0652506da87c333960dac5a96d9f549cda1bd8736c2090cd94c4fdd7105948ab07c45d7379d3e1d4cbc72ab400548f31536b244b1b56c112091f12f2033d758f2647db588dfdfc4880df60086f36b93c3ae1706a8e68b52c2bb437d0a16fbcc80f127e77071bae56fe9a07987a2ed9e80fcfef658d61cfbec3d7d7736862dfc9b90d812226d0cc244bfd503691482a99f9ae2a1b5c0be089d08e7a4b8b0f00592add79fbd60889c5280a9dec147b07ab2ae2f41517e1623c8065f25942018448f6a00840883c694e0245f4a4dde0d65d8b51232fd1c85081d2d817c53d041911635450a58d71966b5bea8df931491d7db95df445b5e3e3244f7f12692b503109224c32ebaa46a4f7cc4c32c1e06cf8c25ad54bd7b0479abad37f6c985ffed26fdb6e83ba247ad555351aed99dcfec6732e066b10fd272e9e7bbfa33b94842ad2cf12150232a2f3f003c393e0a2205046a299e379ef0f835dbc5f58a447d83fcc89b2c7ba63d45a7285b2160422754a63bf415499326861ae47dd6e56c21bcc20e301f5d2b2952546871e7e27440598a2e898c447aea8b4a50c1ee13a9047068a4d183a402a32539b452a97479b6048df19daa7a0a03fddff3a14921055d326c03829781ca94c46f7ebd6272557e5ffd96ce9abd47ac143b67f3e2cbdec1f9a4fb3185ca859f9c3b48fdeed64d93607ba831a1ee0b56caa982322a16db583c18a0e91ac7c62a8cc4ff05b6382e62fa9e510d785ca81908afc3afecc5c2194ced0c4356ccb9b7f1df3d4509c712e52e25a25ecb4c666272b3b21b5938098d07c670214ded5e87314645cc712a9d9e0fa08d7c469fc24a24b7576d7c769985d5f666e05a8313ffa1fa3d2159e8239e585fe590815547a0f9e1958773045fe152ad7aeadab24cc8d79ef2527660bc75abe123e58e0e88178a6bfb7de6c3b1a9b84efe36ee797670eb393f9a48e1892a22b57778928a0b2caad30986a9b761427e67a3b2d48edc7d33748cd98291934423a5c1351895cff2ddaef3af457d26148cf2feb3fc6c70ac3249806aa9ce1dba72c6f7f63d7a94cd186c9538d3cd39041697c729f173d1106af9ecf99eb2693788eb85bd7760b6bfd40369a16afc6fcb7bd2bb059683f379a3909948daadef0c50102ac7bf2c44746edcb1903786f27416e427bef00c0f4fcc95dc8aeb73ec8665bec6eda37879408e340086ab42ccb741135fad7797f3bbcdb1a7dae9c548b5ae0164338452f3e00ecf75ae2c6f6f6bc6f74f7394e277a5f2e007b9aa6eea0f7fa0ee1ec987821de5b3bb94c465a673f04f63fae785667c7af50f442a084728fee7565455c83bdf3cfdfcc5db9571e822e2a510c52b500b30f3eebd581b44cd01377ea77809f7c8d40f0c228d36c2f19aae0529f134515cce774f2d5864082cdf3eee0124004a961e4174e4926ca5491e6e22f11854f661b2022bc1e4a785536df6a22ab6d159ab1701fb6cab9de4c2c46d9ac8942b21bd6209d4a22153dba5112405169edb6ed4fcffbdf88b3f3f5d9414213ba66a7fd1b7a95e3607e5cb9e7c35daacbbb78376ed105949a6bc3ac13241f92aa8e56c8c44b55111665776d3be188f3c02fed5af3a8d64c2d9adb3521e0e6e18076a00d763842ab18a0d9fddd641bc37062f68fef15584983ac32d6d94bd8ec68a5864efc0d46520ea9c6884060c4025b45ac6bc1aeeb8a122945774c229e760528cc73e6f9e725b524c0c6e9496098199cc106a37b87c1eafb1445e9e245e04f5e8b2a30ead8f5ad6017d8ca61c864f988123ef0e5da2372e7c4d40030c8ef1c6bcb8383961ef4982ccfd8a8b7743d6d8bb9b804df6539ec59629fd807b9fa06d5bd689ede4982bc8e4c932195dccd35ad713b85becc1eefe22e54eec24a4b96463b4ef015e14b58966a30f4b590c6bbb583d101fcfa0983c1238ca7dbb9ba45b0e1a7da65f826f2634c3531cc8c7fee726daee62597a49ec95b37e3b2181565505fd6eed7b93b84bc03dc080c1a2bfce0abbe1a0be568ead85b76ef8920cf7ea91ae4f2146f3aaa340f39bb8b855ea29cb536591d39fdc3c68dde56279b4bba0d35f1497f1fea0a274f63780eec68ce663fe62da8ffed65f887b5abd859662c448915d4cc5a856e93ef2ee972193c78824b40ff91e326756ab792032dd81d1e37171aa78fddf32fd4e4144d9a36d9b46b1539b89f92b8078fd36441642d07ce7153c8275b06253e8b2ad69b02d5cec93c483732a8eca834fb74a4e50c8b62d2a8fde319391d3e4104fe6d07a02b99b6330aa570a1e07fe8572c0e1fa2792584fa18153e184ff1200df0968354ce3ca7023948e7297bc152e682bacb6a5bd5a1e9bb70d950d309bad4d8ec0dc491a7c9f1d365d91aa3e0bfd30ea92fbe476114b6aaaa26bc1ea50fe766cc36f1e1d035d1370f87df6f5d2a6d55a3239aff5a04b263d2f39ceba5623ff76ec69ae0dab7b0060f40e178c18e8c0e5870eba4d5dae533323d28781137f38894f62eb3db8bce31f2a85135948f3d4a5d48d738180d19c0420150f87bd6bbc53677c5beaa5b8338a9fc1bf6d2d4a42b8a22f0870bcf9236129372fdd5dd9b40167fc3c5a51fbe7386b03d95e91927c3640e3da3c7364ee32d0831e4a81f166fdb2c2877d8ba741a5af184efd6702dbb648a943af37f2526e3e53beb41d3eaa8a69c39576a1e6ecba53d53098e0146376e00d620067c4bbfb8a2375d9a79a8ed3f53b8531bd0bd75e5fe65abf4dac0e27ab7cf63d8af28a0fab7c9529215ef5c869a392da638719840e5cd66c58bb1e238d77de66c94fca8bd95a605341caed467f092ead10b157972b014193de9d608c93bc5402692da4235d7f3a397e1c5f51b3899891554f44a68d5c7f134a727d7b6f44d0ce45865287515cb8e2e7a22d03514578e7d265038325bef66850b1c85ed1da340db3e810ec2505a40fe23ea798a1edf333a4b2e5ff8a67bc3af1bb89cbe50988a8437e5bbdf37a51b65f54b81bdf118c078fcd2e94209d9d0b3fb80406b51f063cde905807d232154ca60a68cef8322b0bc327c89f4f0e9990a49569c1bb93fafd332fadbe6af5867d6d271067c7d57558e44ebc0f3d12ae5c7660278fd44f5cf9b01644711d746384cd0bf200948ce79e4a2e2a57168646f6191c91a479b0cc8362ace1879168832f90bef902cb573a2f81a699d7e6ee6454fff2ff21e356fafdda6ca3800da3dad579ba5f8f2bea3f4fc793603f8dabd589cc57e91f092baf8cdfbead8fb2660e92450fe1a2ce6a5b4c7889309108cbd5b325b39255c6e8c9dfe0ff6fa7f22f533ee9519140c2042b567c2106c7aa47ebf6fe2b4c8200e40bee0e3a367837538cd1565620d133a377602a72770d984cc7bf618d99c25592c3758e15f4a11fb575dd8c861cae9dd19d914825b017c1c63a6426720e4b12b9fe43bb1dd1d4206540467bf87c64e40dd49f633ef97107f1a288084320d1e018541f977319489b02d38937301d88db05d8cec11a9eb4f95506f4ebf5aa4344ea14c2a2c134bdba134e98e0977a97d4c0395d722fc16c40850d8d9a226bdc365ea34f6f078267aa4c477962676f839e55be0c419066450ff3f19e00c2f6a5ee07b886962a90621b726b09dd1f92db540f1f32ec042d2ede4e9a1ca5656efa20311a496585cf980df5db68890cfbb0f65b3079b505e82974876bba2bed6d8e88425f0a0ca8144f5771ad0afb4cb50b13ffdef41d531653679a75c25811785f9183410718d3ebafc80ea0b902b9cd9e170226292c5b519fd8ec361f9132e9d6cb68f39d70f017e056b037520b317dbc1588be854e8e05df356f55e82ecc4ecefd1f6a4acc3dbf84c04c019f3f397ea6578e90e31cd9f9e57b7882b66c06e73e5670c87c6ae345e0bed5075163b049d40484cc17d63c491abba19697efeb113de2d77549fbbb9cb4d78c1bb1370123cb1503f95dd23594b2e415116b59bb367a0e139f23a3d926a1d51114c8a1033e6d40b1340e38bc83ab146d85af395b56fd4c3bf8d3faeff890e545a6b422193daea41de248dd69c1da85fd12fec546054d90de9df88f706f8401e520b2471f3adb05d36ef7bff8a1828231f719241a4e1a88121bb7a9a2426ada6ef567e95d490a2ed6d540d0771c5d9641ddb4ae85b1082e71e8cc0934e10088a77a25c0855f4196c47a78f8091e0796427f977eb2df711adc5f996f302f134175e91af48bf15e60c1d73b3fa547d9dfd7b24cd858ca55d4fc3a27d63b7f3f0193d9f7c43388cb4e7388faebcbed458259ee403ae7b07b2cfc2c07c11bf3d975c6fc7ec51c65ad63d2f71e60f8f64ec2d125a142b4e96f556d81536d7139ef0897f111f475c2ed2bc45a775a3b2a37b337865f3d7b74e484676fbaa9435e236f6e2cd88a12da40a8c295b117bea2a38c3bfb4eb49ea2c12b9daee89759c1b8667be68d75dba6df257ae30eabac2d10c675ad921effc04c0dbf37e0c511c5acd5e6115bcdbca37fc89be6af39aa3037dfeb5bdaeddf81d54adab6f75294d7d5f78b9f9ed2e7075020ff591a0064f760d779c93891837f3732f744f34cfd48ac7facc5568371cc566ba48ed0e4f17e5f4ef768993875fe79dfbd58989e0f97f085aca185468901ebf5e707c7a27a96080159eb9e46ff4028d2c0f8492021f2caae709b6b2036fd8121e640912300e9449bd5b6940617f3caa4e46f0fd2d86521b39c314e2f4fb16f6c5ba22b856c61a0f40003f90e0884c2d88a8c6e732088bd9c2be145a2451c857eb227c3316d983c9bf78e35d1380fc4b54d96d1f61fe2f95858094b53e6250b415872eb841381b70282c9838524b0e17e829339ea059fe0106e52ac9e1f08770fd22b7b8175317bff95058ef1e9a6107ac5d9304e133d73de6ef4c8a7ad5657e7d4112ec39a6b700b0987aec9099088247feb8beadd54eebf95918c7a0904eb436e38ddf432738bd88033904853edd312f2e1813fbcfebb61b7c94b095c05be5b446739273acd0d32343b90dcaaf93ca812af026201a4f5a12ac61e607e47e199578697f6a3e3b2fac52fb84b27773a9f7a9fca3a181f2b51ae8f84e8faf50e04066f54eb682250613b2f689f6dfc851152f21f5d297fe31b817a8fb83ac9d4645fa2311eb86c6789ce18b0b04483d1aaa6ece0cd61ad9da02b533edfd283281ee3a5709be27254111bf510e76abe01f1b38864d5921f7ece57e5a277f26019d7d1c2f4ea0328b4287ffa9d9379cc84eaee7011caca3c7981ef84bbb53ce065dfb9460b28e68b9d4a2ad7fe755441e348c9610552248db96f7c15cd56c4cab85d1cdf84c0f3556278d7340ce8bb737d92e5d884752c5e56d2f975815662e53bc16866be1d7335342fa2f151bc71c7771dbf9e162358b92471c8b62b3813c205a5e11dc0af56a8c59b18554bfc1de122346de4a0ecb9dce9517b9e8bfb2b51cb0870b06ec048cf340c37fb72ed6644991c7d2a43b9273716dfec750f4f85eef1b1ed3d11c5b9b34624f746c45b9d6f7a533a32bf50245966aee111e16d58b5501ebaca342f008691dfeee826f612a8911b7b7444bf31138c96bfe8bdd9543bbc7c4ffeb5b3ebc31b44a86c03fbd0e5030904f7269da290e80acdebfecb0535e8b430ab4c6b5bdc688bee805c7e8a92db1d177ae491d3c04f67f12a2c65e67f3a0f9b9626e1f1fe02a3a9f060bfb8fb09703f992777c7b84a91229527bf64fa2f80623a9b2b48cf21215ce67d46d14f95636bd595ffaa2bbb85d5dfec575f6ec9f2662f8883f8dd9854c406431b2149af0e83833688d7d1326d851b2e25a02d1867d203f0f9e75d8198995e0d4a95ebbae9d80fd0a8f51d3650c7111516f6d1e2348866bc2c51d8a0f621ecc2125e9ea4a7030492378cc957b5ca6e676edc1a0f01e16d1ef14b2176fd650c6eda0fb2bcae4f93042b60abf3bede70ab1f97f18ad86b3d2ef28bff1e57f1988248150158e032222f7334d5a938e33ce91677236ede67733776e0a95b1349f48a5e0824d4100e35db5b6227b9b95b79e2347dbbfc67a677ab7061782a02479b502b788182c5ad9813f4aa40c30d7f0f2819be9ab28339318727a24b425b25e3b9500b0c7781cc87cf740d1ee2f5dac6e14d2e97cc6b3241e25f71d6b4df94b73b0078fa4dda3e3add3a51d8e7b5978d9de1e2f1a114ce11cf9ba420bce7a2e3dad65b432daa7d4bb28739b3e0bfed1587865a3ab4809482ecb6b123f976c5b97014e5155eafa867f7f188343a428734d0bad08ff502e1ae68bfa2b8382a4db3963eec4f7fb0f26e643f0962c5b0ba12873bc9e088b66b9085567559df4b406b0912d99d391e02b7e65f3edbeb14da14bd3c00766554cb5c351d2aba7fb1563a2adb3336faad537fb9c85aa20bae4ac853ce47739728ff4fafc3ee00626a8ef817aff4932130237a7c142a071b5e1f8e505977529a92571087082b191020570526649457eaacc83a99e91530b560f87f361f495922e97d69f7ae5be5b540e447b17c18d74db607212dfdbd64c348cdeb039577fd1ad9a829759b018ad96e856cc9fdae071d66cf19b5cc828c6259580330411f9cae612f44c3f5701db809b718f1e1b447325582a233e3f1593c3003c003ddb6dc4732862672dd67699cdef3f8343e11a6d2f37a39bad2c5f5d41428cf99ee546093bccd35b4fb9e0356a5e840a71574627365d9dd3e2ba78beec015ac773908afd43f378c48489c6004f20d263b98393357ee71c27f307c266a5ba41fb2880bb3dd472422948e0ffd6243c1e45dd815f253a26e3af0109f700d51c6a32d2a352183fc9366a6d69ac3b0e585c8b803e9d82dc915fac84ed1496888df9e76f525cca9abf888273461c07c8bedb14794f5daabf64d7b6fc61490ead75582bcaa680ac289ef7221028e23177a90e988af767bbf274ad1f33064e9771ce4dff3c22111e4c769e484ab2784371e1e9197f1c5d996b23917d53eb69338473450fac827e802fc4eebb7debc46aa5d51b276fdaa519d77a22964aab717b5297f1381e7f94ed7a9d854765c197617ab4e8538ab57674d7f32ef07b7db216a18a5f02a00f3a10dfdf74231398eaaed6964c01445ff560797629506b8a3320a703f3bffb53f71f6e508e2f7088a18bd7c4f1173642c27f06ff732b50d41fda557f7ba1aa630eac0bcf29762ea16b3f615a6207a0a2b40017323f20818975e7899beafa434beded8a4374a694d97405c42436925b35a8942c692220faa2ad6883b111778ef72863087bf4596cc8f7316ef51e68c748942640a58cc1e665174e1ff3ea069a800300b844cd343bff4bb6f70eff9680a165de3d6865335bb1f8d73bb7cc8a66d83b814f93f841d01faa476ebab450f89ffd3a499937e490b28aa667a69ea628ab8967efb34236d6e629e9fda33f0a2d4e699d204bb5828f70209b565e381d6854794b6f3bd821dc5d1546758813ba5cb4d8a177f70486e4b2fef2eb285233d07060a92ad7df8ff37157073b413ac38c5fe58ddfd3cdd46a126e2357e29ac83d38f0f428816f7a3e3ecf9e8a2e347b6484b2ed854055439bce861892c4a21409ba34ef073fecfd9ef46ac6090f34b6389f5cc9413a829c466b7020e16a5f9ab8caa11ddab0a2e8342453cad115fd849e2509acc321253c44c81f9f18dc49c6fe08792a0755733a07c0477b379a093281d27aa31fd6c82b8bc03c80f62da7999bf86c35bccd36f12cee8b717449696f8c5a3112dd93a2b37d5743da3df87552d06ed4d70b25a88652e3be278a5d279ed9f9b1d9011955d696db87d21665e6b566c1dc61d7b509098e2af4515f85d806fdbc9516b81dfb44c8671032452d4b0e4f2bb22d4347750b73192655f7b2c58907e90490dd485f51081e11487a8ec0776aca249b90157d4b9f18552bd4618679eecce5dcfcd754f608a2a4a54cad5c72afa823249c6aa3f584d10dc933517211bcc6c8ea1074f3258f6f640ed422e7f9e0bbc447ae2d16d105491479fe00494bb446a812d093837d7fea980104f2538c81223dcfd4106787e35021f29441dc5e3b28276a21a4de7b6a1b231a9a046520389dad9357f7393a311069361233d149aa6818cca55d2e20307c382ef6f3db8db50d711642ad538f40914ce62febee8d6ceea27655ca7b007c085d0f48d670bce327c2befdfde8697607b79f3fea1029e5327d0e07b5e06fd520ed0dcc1efc4f8e1e1e2d12d754b03508457641e1a7ac0019ca0c21a458693337449fd784e9b5d2a07ac47eacbefb822aca96cf52d326b379a6c9c37f15e8f9c12e59facf14c0754d0faa8c03f22125b34743fbe8fa97455092c9d39696ba531482e824ab44f9aea9f885cf3f799a7ae9b9189215ed4069a1b4359fac7dc35418553692428025d2c57badc782235812d5ca44e9388b8d8966b0841b845918945043f2cc0fa25e3f6b9d3da506ff401f9a7c38eb4f4f3c5db19c189bebe5e8c4a463d2a2054640009951f942faec0260f2642faf30ebdeb0cf7ca71ac22da6ed2488c24702b0232c2fc8a8738189876ba8cbcb1b6665066ca6cc8ae18f300a54826ab04d654ab92ac4d1854ed692251de38af1b8f71c823f699fa8739976493465c0b8b987f35492de3100d445381559749696a94a71b749f463b21e96713579a13330716672e47769143bff8da8f76e34e66945c8d3b53b8472494630dbea4e817fae1a9299cf95ca858e207caabdac06afd7c0e93aed0f19999c978b8635d9963c10561f3ae09628e021b65b4da9e36801487bc18df1c017b8703aaac922b066cb6de8a58c1268d195cf891a277eda1a20f17b8ad613c4c4020fa22e6291ef9b25e3dbd08d0a660087afad6f95259a229ad96c73b5c6e83c011df81c7902063c78739d1086236827d7058df714ca2bb4a65d673bfe9b90dd4e4f64a536bfcd64312cff635d6771264b1a73d4eda431f93484510662ace906585040508c56a135882c9600fa13ab29b25cc8b60f227899e16a840fb3414b130f12bc330642915df5760f9a8a34d66e3870d65396bc11f5f464baeab3f346f5c9504d886d1dbf44ed056c462bcb40115fdf4bbad145c956d9f575c9d11cb030e645f59ba919c0ce67b84bb7d75ff5f30ab461b25aa671ae2a126b22236a90f535f96c574b9e2b4e591a3adddebb079aa0417796395997311c9538badf0e5a7a9d0766c11ac32a36b3b997742e47e7a824530e0a97d60262ef0a2c99da423cdd3e09bc778b7ebafcc0241a58ee39f230737e47336c2df4055ffaeba6f6e854b1dbe344a84fbd15e87232b73a1a74c897b09a2fc26e9204348b5d8d2017d8a7fd90590b5be0dd83bcce8a1f6fb5e60e98ab093631fa03de7e5dd2aef5afb419c7d3ead33ef80d9d828261e445cae0d4059319f63e687c11f209d2a82cf94a6128ee53913522e9c96b8eb30ba4f860d0f7e4447f98e5291e845137a94a9c04403b2d03bf1dea0d78b2b65988e300ee7c58ca90a0445fe62942871e433f4c8dbd417880cf77042c26e396af1bfbc478b48b2dbaaecd16f9b20ed9c4b91f62b27d64b5b718484457f0da4aaa7a78a18813baa2e7bb49790013940832f1f62e70c8697c0fe27d3db47b397f6084b0d5b3ff95df80825141936a7c4008ef22c63bca6546ba2e27579623de4da9261b721ff8967be5d8a365e27510c279263d91e21042dd4a9b2c22e4349b1145a1a8eaa060139124d81a0b4cef30cc17602fb852001880062a62a8794d5173821b29f43d8f9bfe418805dc478be22b18c6f798a1dbd0bc72ddaf77298a3c67b0e346f01556aa62de1f83fa17906adf11a3e7730c62b30adf0e60325e040d40279033b0e91ac9c82e5675dd203f5868a3ec9a84ab4009b811aeabb4a32a6eb7b867d3b6d1e9c7d5da47b89b47debae0cea3ae350b9e4ac02c20eca24647a713a6ea033dd9a560c145e547216718e7730def0a944387aea9ac30256eb216626b0a7b16c3e026b67f2b95b444c4b87004cf36cc8e2fa7fa63a1594f957849e51600968771bb69272220f5ced71918d4f687014e0de7f423c8a5e035c438947877c2cfc98def76ebdf243b4b415cc556af9d16a224d975d151d8af831974937109d5a9e6263710e354c70a2a4b828bfa663f6100378c37b4e65db79e1e555c46f805d009f82a77313b7a6642c229a8d451780fe23580b20e040b2f11bd3062e6517a6c46406d675e63c3dec23d6d8c176f8e269495f9600edd66c9f9d9bed0378cee0e3d024e4abeeec0d25b61de32a00893f36ef927ec99a06413a733ec78a36b69c7edf2da95676ea3b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
