<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"97064b551655f330311fc504eafc15917020dc0e9fa6ee7d2bb48df8b4c8286182851fb55402965e14356f1090504e394dfadbc354fda742524614945c832e439a3814e1c52322712538a5ebf40bf186923f8bf6fb4d77ad848d750f470976377d5db0bc26b94f7846ccd7ebac610bf00bf0081361f7c2d18ae6de16ab13d366ddbc70cf8c113706f93c9cd5702f8e030d6cc5798a95e031f79568ea0ec4ce85b16c9b72fe78fd4056a4be207f6a327dc746e03a9f1d62da46f2765039fd254ae23007bdd5fd8ca43e810fe6ee976d7c8292e914897ab8736c85856d3f127c7b60311a940353108d97b11afb832438fcdc6e7198146d03e4683d5033025ae481725c3b7ec1d78cb19b6e6d49ef096d824e5ece237fd32d9b5dc4ed87617735a5c4d98696e55658b6c380ebfafa0ff3fa9d401667c487091df49badf8b2d8025bdad822f4acbf1a41e13d7b5548f2cb39f1bcffd968606d745f708e9b194f67e6da6c061c285b0d3948d713cd940f3c6a2daee767e5b6f93f3c04d8c0dcf948e86262b380404eb2d33707f9743702307561963495d677ff349f1552196e50c9800987e7e0197957bbd2cfb0ee82944d5e006b76c165a97d02ab04d1a20930cb0f473348e1be853ad7281082793fe2090933f1d60413c00b72085f77f998fce823145143317e3db6a460b5e8e65472fb836150b393513227be1caaf8799e58cc8d2f33ba798df8d0c0f7333b1950d6080a0958c044606e82d41fd439295d7a3acaa4e0b82d1c09b004b41dc6faa000da6e89216f77181a4563f9420385e5353b87504a2628e7739fbac1000b0c133b48c1d3be26397f85174e0638a6960941c92fbf403b915d89deec1eb772d064e31236eec2d8aba4763b1b33557273c389c760f83645e5f5f2ec687baf8569e60447d75bcefd8e2e0e16941975d3a4e9238b51ff2da4f141bee568b6b922b869030ab5ff8e96b03d923257965f61a8d1538a06f825b52cac7da370cf3aad294d570767634954294ede7d5a15753908497c3761ab26c63f6df6c40c7f5c93166583cfd24e63330980698fb70c922c4751095a049e48d77dd96abdf575ad72ec3a0d7153a9a2957f328da9dbcfbb9857f70987974dbde001d57debc3caa3bc2dd195cde3abbf18573305d946f7b84fd780f1a55ffb5b3221bac1df1c02a08ebbc1da15187aef6667c44bb7f9ac7cec8aad278e2a89cf2a6a531601f7bd5bf4e3614caa214ed071ab3d2fa77d9977e0a9cfe769504a9ee1a187fcc5737c1ce6539162ed4f7bffdfc3176e4d4b1dde0a615eab622b1993f5a543d83d7987ed211d1252889efcd16d4ccb17230e4047b1bf58bdaf8ebcfdf87ab001a6e389d27ad86fd16502599a81bc8e9ab75c2e1c5e40b485d16fb02c32d6f58f08a635a3c743b6310f5ee3f61ee5e804d5df587d609ebdc454bf4e46f44baa86fd6c5157b578d67bf673870e53b8855018b92623e03e384a0e1258f4ab25b0b80c613020e26447b3a129de980148dda6e97341befad2315a6eca4c4e88a2e86db7f14a12d030c4e377bef4a3317d2c1418bc09f6e9254f38870745e177bd7200fb2b916c6b62f55d484e63951ccbcbc9ac5dbae02dbbe486925631aac41788d4bca612a973df6f80685a516d2796ab8ed2fb36ba31c6b1118304a210e4326290408eebefee6966c97da09038bce686b1decdef4b6ac077b1aac27a9a91248acd82be466cd287ba3c657127d1ab828c748029c1fc72e599f897a83f2340a60a7958842c08dc5bff4de065fe9b9021c8a74d38ced2fb4b8a16063d98e3616d4fcb6d435a9940cd4ff7db1dfe258d93ee892b099aeb4e3812c35d4acc45296234241742c99871feb35be6a42655db7347141c74c8d1a70aa65e422c8202dd31c348d2cbbeaa9788277369e7df7fd24ccf392487d9f97eb65cfb40d667bc758f7272b2843181abafb74b673d36a763301c94dd25629a191254091da288411dbefc0f42614ccb93db209bf0c92f339a46f2fca589f62803d27d917a1ca25dd7a5d255f17753822bb0aef25c2cb208490e0146586096054b54fb5769fe7e243eebac4ea3e824940eee6b94d5c428ed317ff58dd266b584fa3cf03206217e00cc43d1f17051ebc0231ab71706c2b3fba94f30ba6103b1d95facbe4cff0289deb213463e8cee870afda78c0bb8535bc85722f2c6f5814b4839c56f1c3fc4a49e154b7d7092913ff9542fb0b31fe7025fbbc34e361c78c4b0d2e6921b4b12befee0a85f4efadab0d03e2964319898a3094acfa1c218ee9448c4872d01c04855d9d164ab57d94a1af278ad7c9396d7b67f07a7d9af0a48a45838d8489743fd3820e6f522fb7a8b94d1791f024f4a3a5c8bc4ff3d64bb9dd94e24e7b49f5542ce785652bfd15390be40e34d3cf1e9a198acf68b7a80bc1a7ff91089ff7b2b853c8fd862ea6567141b694d9d385ab90cd9295b27edd1a94fab2b49ec82ebd196212ddba9c21aa26f7774cab903203531b9dcc1e54399d1dbc8bf97b4f198ea09798ba68f934b4d5534e7c566fabb8b31b4e246ef8801b347df3fbc2ffad4d3b5287177369279d1339720b25dec0138cb34e3f455b0d6c961d688aae6eaad4601cb49445535a093bc274b66d22f6b2e661446ccfc88e418f0f801153abf168196c9072db53706cfd49c6baf3cea660fc609cbde70fe12a8a45b6d6bdb83c180b7b2a1ef70f0a58fb145bcc79eb012f375a1fa3687ab03aaf4aa579fa5c32d133e250e02f3ec684e882e156350020af45a4a54963827ac636a363bcc9234adefd6c5bd9ec6ab72cee4359750f8fbc4d94eebd707839e620c455cd841b9a64e94887177374f2602a04914b4f13ac09b3ed770b9ebd925309c0c955931d97ad1fe0f4820d718358f38453e075755f49219bb8064265659e30023171aff23776f197dc8fc8a1df283541d6b35ecb02ed0f2dea8e376fb27ebfa79180db72a758fa138ade83e71dee39e266701e20b37b0445f5eb539a9222412e8ecb82507195a7725393b71b806cee7944019dcc7cde3fe1c1e011b8dc64aadaa7800d43fa57ff7abf4585266f01025db25945c197129c734d5f8055128e4dd0c4c09a42f848e79128a217f5e3262814a0428e863a20034a7bdbeb228cce4f5fc1c192b192a8c92381cafadcdce37c408a448ca98de92de06b22a6b3b55665d949431eb16c681eb4f8e6eeebcae88a049120727eea7fbe3989a1633db3eae9e1dc24bf3db72bb3010b0a309600e81e1b0d75e319cdf1f47b76f2e773b6c7c29bf8a3f9c0c08510b289022e65912082f822269888fed45202921bd9a2385e7a737f001158bd68163764b79d221a7a96fb979fa1f5b51c0ae1cbaeccbfce35ac3dac9302df3ad8d07a0bd885322d8429df1a91f5baf5d2c5ae4f855d0c7a1843b14fdcbfdf5e06b922d8a687de0d46357cca0492f620df0b0baafebc535fffe76b441c7917297b74646658d7ad12b01a012ac7987891486f6db1371a0b1f322dc56d4cce3aa13cc7f6e6101cf4b1bd7610db011b669de342b3d4df6235cc2d0d7c603f3898c8e8cfcbe70e716ea37a93932cb0a906235a3d6b9120aabc7d43b4b22958408419928beda920c9a4f2087e25a32816691f2dacfeaec4065f698c4cdc00552e164627031ded054744773b5acd00fbe3b5f17c3f8613e8f5e3616c627c1ec51b6e8a8a5abca3e37518a77c81e2a3bb163ab19bbfd18713f37aeb69e065458a9b171ba29212d1e6eea3af772cdf6a345aa2c54df356935e73b8909c2d522fe584c4409431b50386be27ed72be490a6af4fb277a2bdd3ba2289564feaa3d2e71f7016d00b7722ab8c5274adf12cfc210d0c997a70194a21b01fefbf5aa076fb645f54aa337e977f799630cb56757a00aebfc26df295697a0206492ef7257567a9e839289316eb54c87efea9078f2c4a76e08c15e49c82ef4c1ae5ef7c23ff29b6b758ec4e579e82049b837853b152748a7ee154263198a9de5b0a1009ec039072d1b6a8a68fb7ba89601f27f6835c27087685f4bf17abed1dec5c328157b367f72f4385c98fafbaedf1209c74868ab0ab21cda0ca1c7bf5e304f4cdfb82f01b136397e2606b2d1fdb558af1bff90c5153ef965a5a3443830227c562b890e2f9a30044adf87dc14e549f75f4124a096e67e24090f479701799a5328fc9f01adfcbb2f130b11a38535d5945064956870570c9cf8cee73a216c649e609054e4ba8ed474a8d6ca94c36f3646dfbc52582a5131592457281991fd6743a7834a6c62458c41b65b89b9c72721e80cb10fdf6dded64f030ca5993ddc9da578058a21e7b9f7306866ed766a932b6e9916359786d10ce1b1dd6c6ccebe7d8707ea2ce865a9f4ad06b417a10fcc9b0f7014bc42169a720f29a038f5c9c091cbd5552428fab477e515269f986f5e908853e286a662269f70824cca2bf7d20f5580b8eb19b17da13d02c0b44b0eb9f54305f4e7e026d2550996ab29c1f05e4a83eddbcdf900eb59d2f89e3ad56cbd46c1c1ffe0d5052d0890b9aaba7232363219f4d024068f161b5c445b3c2669c37a803eb6f0649a78773c35d45920852ce3bd692fb2a85a49d384394ed1900ea21413a52b3d6c53511a4d97c83fb7abfbfc20b503b093b5909047ed7d84a37af44ac830716435f233e6e025e483d35c27e855971dd21c94e7c4f78f1cf266830759902e3d8eba9e79a331c784ca348a0e05d934f98e910baf02cbaacd6b8fa86cbd0b746cd89ec928de4e5206ddfac744908a2ca13b1c1252e69e902668d0176dca81b40d54c6259164338f89b247fb855783ee798177416ddc53b9591431f4cdb431cab9868299eae35cf21a0fedf8cc314826aa29d771e18f46c207c6ab1f6e64bb8d5793869286b95236515b485c3ae0bedb25bfae744a7e5b54c2fac5cc3dba0b787f8950edff8b8693c28500720c49e4cb58647a7c51b77ea09937e25690ffa09378983dcd84455e8a98400587e9b01c5235e0bc2a88978e47ab3ad6cc5740c8c86c5a88121626cf19f8bd3deb6ea04b89cbaec77e5840353bef1b71f32946794e74876a839379226c82e0dbc75f308761d5203e7bb88ccdc29bcca4d6c04ed197a6fa869c2d394822540419ff9183ef9621dd4fc93faca7a6ba16b1d85e22481cd263698e57bb23a0e1a6ff3c79927452b45b18b83f566d43a3973c2f46568b8012964ca4ec36739686fae20120747d025b3ac0ac88c289bd457dffb703ba20d3fd20d41a567cd4175aea3ea41e56d62cddf0fda13c7b4a2d5a4bddbbf2f0437ff876db5be8cf09d86bc16c62d67001751ce79dee318e42b564d9dea217156c2b47e8c69a957438829ee484cdc0a59e301c4bd05a713fa5bce2dcd64d77fe20a7cd243f3cb3bcdef1afde8f47f70b3209b1ad2426e3bc7c476062ff88586fffbc98b8277e783b9ab08122d4405bc81202e11caa6f61edcf2e9abe8ee31203c824a821e5d7f59a65d0e633fcc47c0b8d2ab5e395c4cee6c178282c07f1a71da556754679ca3b27eb2f96160224967a83970ae4d731d848ddbf1a1c0ce26f75dfa3dde52c8992af757be88b1b51090f2bdb0ddb39b8481edb0ad8e7df17d0b4640b4d163e0399fe7dc401cddddc51f5062ee1210fa042c895c50cfa57c75bfbbfb3e2aa817926ef41c04ac4d40d07b988d6cddd42f5186b0b5a783637673da0f0f8446c9597e8d2365f4122311cd49a9cd331380128d1ec4791ba279534160c06636920d59e133bea0cb4fbc1fa0d8a8b49b73f81a2c865e5df9168490900cf6bfe605edc80c1c0d935eeb8ffbf9e22bad13681f2e200db95b21aba8e00928bae71e4f191059837b88dcf17a0f263674b45c902e86499ac40e5f37ed7da5e2c7fb1da0681ea484dca8c043429d52f8b0dfc4b1276c6ed34516fef00c3cf221d408a3bcbf8befad4f46a511644ee41388541c980c6c8007dbfa11b9149bba7eb1ea151ab4ad3a20b7b8bcb4f2bd6117eafc252aae29ac52011bca0b5f909b43fdf94b455e019e35af62d14f909a2080ff439a5c847dd298f216c960defed09f9aa0ed803100cd9261c11a82c0facdbbe35f6edb646ccdc0cfc43251b4b3979ab770241462d918ee7e5a9a1ecf26aa68737fb05c36765389b408fa7aa952a25ab25cd65aee51c266bfc4f4b6ee11852a6db479bbfdab4bed19e2034fee8302aab1e4173c937ecd6b398f2b12a2d61d906cc52424c2b17c6ee96c8475f53b9790c599e7f5e97dde136adc7815a0fd9accf2ac60d4372831ad55305b12127f3eed5d8d14cebdad7f2f3110838e6162e1bc05e8dc6fe499724a810f138b2b6c6ba73c4839c1e0fa23ba531efe0c2d309fdc7a1bc2d68a73e6a97dce5dc66244710fbbe2dc83fdc34b781d227aa4e3ae89af8acc49fda93960528985a85b797ae5d2aca54c05666197311ea39588f6ee9883025d6abcd2d466b65d6bfbf65ffe2a62ddcf5fdd59eff5e4ff823889daae6f75df5f1f23a513617aa31e6724135d2cc61c625eb7e8412f89b4bf72f32bfb23b11a8f728f8c40af746ec3ff5495c030fd04f055a7938e39a461b7fe1fe798e51ffa15c02bce0af07ea8540c1643dafad01da122c314c7535ae86d33762699698c259af97e004bba97233221237f0d95b0e0638ec51d64c484c0dcd71f2fc7d47a3beb80d3e5e63e9b58b0ce75b889ac611d596713e959a3aea416f969fc7af84d9605c6bcb856126ea60402a4304ffdf7b796ae1575757010c55d12f78c423ba9ea6180550771428c2030aeca0d88373b37dfe5bbc798eab2dbb891bf0ed7b6648cc6ce735c8611e665e6dfaff310753477790b658bf68f5d18bea254de9ce1208cfc2791fa768bb81a28de5199a527a2f9dad6565ed2628b1313a36cc5c94c369ed15e7449b2e0f048d39d496ccfbfbe87388623ad069201298c2daeee9ff98f34f95030d150aaa520c114475f003d2c99886de3e0cfeee35ca22253d7bfe757938cf9fc17580aa1f699ff6b6808544545fe7bb61e8466baf2bf971e11cb7c7c2ccea2ff6c44a9f0a94895cce13416ffcfa312e8382cf48370a9a3697fe0e7dc899dcb14ff94cf1f15158770d5cf2479761b592a7c8185a25857d36f4e5a6bc447bab10499467fec0d3908bb1c43a6026f6fd748ae91dd6522155812810d49caaae29b618e26304cdd169c6e9d4764f76e1d02894eea8f5dc7843476cc58bc6a12bc2e3884437149affd2635a08ae303f357863e260e98ed117e4da09887a65eae09734c1f742939be8e02da1a33a2e84e579582a281f033d5a213dffba0676eb3a961b8bace266d68836455c50ff1cc8caff0797ec2bb7d0208bbc777d17e18a37ca243c46b9e9a5fa9688a06d6974643904f15de8ba265cbbf2028858b8d64a37121f2c2007dae2b266e4d4d04b02bdd254421cedaf82f752a697c9e468046102753a42f8cb5854d872e7dac333be1cbbfec6e5f50e56169ba9fe37b1ed5a9c9b61d196233cdef24428c1c4e6f740d2d178b1caaf89f42cdad5a049e5dacad4161dd2995688eeabcb3139deb798292cdc79241ca0a3974f3bb6b760a96c40b21a8e27b4464a7cd2479cf174de9992a9b845141591e3ceed83e6ec0fdad3d7a12c45da86303c5c6eddb324de551bac9cfcf9afd3f5cdbdb814feefe80e6f352da5c60bbfbfe193b4fb355033238c531b249a56a78f4ad06569b8390dad92c5106bf72abaea3bdc63527b9d8f95a8cc58cde0d9b154874e1a37298b9c9bc62906680d12a091376f98616e8c27e7e70f7cea38bba331ac36b13b0d213a005c71d81f9b46533f5e352cc8dfa3a046717a6cfa6474ce0d8edc64e344d3ed6e0caac3c25b9b7d2b070b375fbc253c2377671af4e8c37073d7be09e9bd1e4fc649e871f67cf3721b2809d27b9ae15d635a16114194f1528ef95deb9d9574872e2f20edc7ad0e85bad3c4d67004f7776b977025a6cb612b4071ba9c453dbfaf9b716d31238944a0732a64f3c4372d0b6dd47e3546a3af5daee5cd9d25a48256dc4b073adfdb920b907d24d1955ea2bd4fc6cb7e2e054959ff73078fd8436c136f3a1df7e10ab3f869716f11191a9684f47364d0da15985f67ed1e698c919e4deef618788ab2a1836d4758c94f91f7e1293b7241c4b51c40031684387fe1852309a08081bfb5e40b3494440ff9bcc551df77c1dadefd6823748a74e097a756101a14cbcb074b573d578dd660c2c795e85bb721c7d86b3388c232dab06391c0ca589bb31abd4b60e97388b10534173959f0d6831fa2048378dcae0e2584f5b281a1d10c3bafd42177c0545b689c2816bbde6871dbab241aa9879999e19980810e4a80eac44c7785517975b7e24c4d9219a04c69d9572e05f53295a530ca76000c47b14e37583de985147e1c4294ba788e0fc4321eeca67e6380b5461eb8bb17c1664b8324065d4ffda71ba3a1142858c9c52a7c88df3cf8dffb72ab8a7aa53ca5e791be098a8872911f994354b0d07a1a859b69017c4c012d4f8b396ef6ca8ddb2fcd720fe97f90f6bdfed91997d561cf7875593958360d28f64c0cc0ae6bcfeb7b37a4b70f406a8907ca82383729767be05adb5e331bb649d54f60f52a0ad3c398c9de77d3699900b3e3cf7e6807c2340390fa0a98d9277f0fe22236b8a466f6336189e5322fc9566f67beb7654fb2e8293a9f7d2452f7026fcf98e2529981cee70550ad1b6baa0be53284efbe880f779368c7386c3a1516fe93368ece6b208110caa4f14f3f798b2480315db78c9c8aacfc97de2b07008264f682cfb6542c9117b2db8865af81e80ec3b41d92f8cb60c233eea73dd86d96d3e59d7e010a517146e7e2e86e0090b463c2ee570259df016e70e4d1ebf5202858823047d8bddde337aa3ef28970a80f97c8c2688b335e4e3b91e3903ed3ee2eaf77b1864bc30e9fe76c12316ad9e18387a53f96b60cf579baba95e96ae1ce1d758eafa2da49505538a6dea4e0e5bce523c029dcef719a776c885676b39ead137180a3442debf98ddf2b953c33ce9cdbc54603607d0311218cf625184ecaf11d095c1aa826a3e04ade50fb27116f48107c805f69b5980ae03ea1d59b5046152f6c242517bb3cfa86d4b8f4a3492cc07674d1d930f2e35cc4df1033f2feabdd81d0809e2f06bd6dc47c81f09c1fb3264ec320b3130c1acc9b418fd051d52eb9acdaf8859a8de54c2d458e7db6ee9400c3ac8d6da461a4d2858f987d12fa88df22cecb683446ea28ce1b095cfdad92be794205c74822a4db452e36412e4e2afbb385bc1f49837163087dec6e1e7790ca1ad921664910b27b53e493b1a6cbee571e5481e2cb56636d08bd62e78d3d2bd9457fd48734abb81f0fea278fce7c21e94d11f459961c55a2dafe008abce5fd1e31cfc0d661d16fa2d8cd6087d01ae8aecb2f09e1592072678673b7a47c5600b3f17ae4ecfa4a9d3e0e454d502d75e880deec473b0d437ec5d6756d5860d5385eba6680312a7915fc904d01ee44466454e3273f18cfd427adbb2742be107928376a6c5052b40b9ef7d1af0483a7016083691dffb46c0fff35cc03b8b48d021744cd214525c4a7ecd912cf2ab66e913d3a9f23d8346a881f05966510a71afc162e6d351336d11f7f2a62c2a0bcbf78042decbf29b9c6984f932188bc74b91aef820830207fe8664aec8167d0f4e446668d2da5d83bba43f153d0f2f459924338c5fcefb6c5d34c7e3b1a0d3e9d95180a35d6a8b41e8532132ffba00cb419f1d15d9df959efceb5bb9d1d2caa86109a478c2e1f7e9a980d4272b23366af1bb823765f8f9abfb6ae4a88a36c9b4892d1cfd8e6fa430e17218b9c085566cdf6a2e16e52a63fcc384df183dbac0af8c16aa6ff4f56eca5b566487ceb4bf7ed487c9c3799de676a75c487cce920de95f9fa0b2b344194f7d128801738069c7f8f93d7dc30bb5250b461094f3e543dd1e0c96647a05e5bce97bb4df2d39747b1d6a56a86fca5ebe6654fbcfbce9366556134f06631b3bc365dc071b9b8401c04c452310adb340c87e4cea0d9c3054a745be905b7fc8e2dfbefed90cc4df02fccc665dccf4f54a3346caa01d3cf78fcefee76f10e1e018fb97c367111226a9b87bcafe1e7e043b3c66779561722d9a0df3768c67063105af9e7df6fdef38f4b007b8f7ba1b877d20ae845d63addef59f154a4f1c5d7f3156f1004ff878ac9b0579f40e516d8a1ee790491cc811956d6d440428ef40fa18953f8bea451f77956ee5d719e5168c3051136e496c5ff60818b284b5c80731212f0b887b191b81729816c0ec70c51cf27171dddd6c2643e79f090a76808d36c4fb3238969c0949919bf55fb631123f12ef08a2549c7d0785633b90abd1fae22bdc5ecaad64e0b7991c8b2ba16fb81fbf95d01e0ce5867ed179bb50900ca22c2837cb2382f0f3abdbfaf05375578a62ff1edc2582c6e3ac3516840d05d4c4e5b94717e99ef194f1f0005b6b9eda0da0b1c15a52cb03b409b14c70d9319d43ee1adf591e5a29b572ae736a989618f0f5ff7c9434cca74e48610d73c350121e2318be47e2e2d093cc603ba99dc1c3cb251a23c114efd25c291c61691e3d3a36d28c3773699a1aeedf7fba0a60eee917c974763509f6af9bdd8b53f6bc5c66454179d7ef9d29ef18f866c984afb70f7a6d0df255c7761b966ff3440a18c40a4a15cfb9f96dce0a161f3a846c8da2f5f3a899fe9dae6b6c63c5ea113ea4944485341c9a1eb448c29e66e50cfce4c7fe2ef4aa8ff49242a1e0254f2b37b9dafd422bb8634bf5f268cc9fa2eb51907ace8a1e3d331fb45306b0cad4885ebeeeea5696b106f2007e99b94b74cce9d3b902d1aba27bc2dd53214976be6bf1ba865ffffcad0ccdf478373693af288bd339e0056636d329a117df0ed40ad5c913d08ee74910919aeed99dbd9bb8059e2ee21f031adbbc2177a056ac2dbbd853e6de4aa5b62a7cacf9d743a0602e3ce88373f23da35f54858502e84028dd9c9f6db38d3a558a717c7add491b1cb38473bb56e47a876b114c45cb714c962610678aefb115bcb57bb1afcc459948fd4d780eed72b7f5502fab5b5fccd4393ae74e0a46250a998f23a51736bd6ec7ac6637dc943a83f5119c3c52299c522a7d9dd8d6b7618e81c0bee691051e9951f75d8ca37ba1020f58058243d6f4fa4f3e71abacc665aceffad2e50123dcc0e846864cde766969cc016440746ea627c055ae73d9792a78287e94f905fe9b6d052c8f537aa76517845babe5fc06bf27b960583354897518152c1cd3d2123ade1c641cad43c694f68c3b989c728f4d692213285fa0707d8ecfdfedbacbbb4fb2f47ff4e2e89853bf644f843f0054d0169b7da2be47d70ca12e62cb33e03a3d60ee3c4771e4c7ed5b15eb40e4718a4aa48db993d0d3031083219d9a4401e93984028750e341db361eb56ddce82a9ccd5514d14e83b4d1e7fbe6ab49617b6833afe7bd3e8b59e14c6d23ecb651998bc401e56c13c2a17d348c7235162073d01b6573b4c9c1ead787109a041ad454fea439c32adf4b0c4e284cedac1a3bbb0a13687f72ee8970d015b387379e6f7e6fcb4f062fe797636d9ac82c758141aaea91d3f2adf7dfaefbe4de543ceb6905a0eccc274ffd11e29fa39c1b41594c95cfe7844a37d39328635e36062cb8326c7cd54a4ec649e8337ce8b68cdf92152143045e0817a0fb3880cfd3f01b55c99195d6e108d2720919b193322e952bb855b0d201be6bab99fc901283f1bad3a0a34818c4c147e826a3020b1e939682173e08ade453376194d76b3106eedcaa4da93cd190be7ee199a4b2cc2c31f4ed2ec2a5e36c3a55570181a5f90297a752397460ef5eb9c5cd9cd0b9c1d75d20bcdcb4b4fc90b0e69bafda666c91bfe08dfcbe8077b39a40a74a6ee1c5dc524f590273e6196192227fc13738f76469ff54b52a4db14c03dc4cb8902f07c5045ba9f4afc837cb77caf43615df2bbd33dcb69af9fb33b85fd1258e099a2e2d174d99c8c6735355329ce282d03f1743fea513b7acb884cb0222232be46892649b190d908cd944a2e750169f1aa3e248f9c493368d78bd9bf008745ec9ff8be01b335a6d14702a41f2ca5fe56e068fbe33fd679676e8b49f048bc179c179c1b540227a2cb6d7edea54c0418a9fd024e185c4e69bc152c0b64812308328793d689dc53e790b54b18b961a1d0acee616ce4784ea5c216c849225f3e9565b49a6d79c729ab6cfd98d8c7a6e0deb0e77702de01572374e43496f9be681fcf70c2599aecc16b3a3b16efb529e654adfd26f7a4ae0a2c2fc676bc69220581d6310132f88198fe5d47f30d1e481c4f6917c9a9020a05af65b0b849f4e88736569d26a900579fb0105e51fdfdedd1c0e765606be1a60c9f539eb065a8d3f3947b09f5ea1a3966a5b6cf14156cb1f47ba820e005e1eabf42a268b37f7e1d574c568cbd507d613a686b16f9010abfca0231b23ff7b2fb579f467103ce426d73391ce9fe4184a20f9812bde8dd0e1caba0007c8503aea69f8665d61371ac1e8594670398b7d19b905c29015a9e35f13c38d9ef5cf6cb49e03f44a836966fc63b05fa5b81887da01cb47f7cc1c51aaa60136b6b07c01801b56db6734b4a5e35ab4877f719b681f71fe5fb6e176309eecc8e09377e84d31c913f2412135fbd49e163737f23d2d57da5bebbe775f6bd7e8734717192bb024314159d4d99e7980957d9e7ff27e4080610e48c0e72c21b25a87d1546a8d7de7990262f251d3f92a91e2014170dd802e44298aad6aefaa61503345f8ff2d080113e650442010a832ccf6833b96b16725db0ab2d56905bbf1665730aa108c3c8c011f54ee024e1a8232c89f47bac3516835a69cddd1f6966e8c8287c8016f84c99074b7dfb4cfcf39821e37c64a46160fa324f2df843be8f73a114a183cc63dd2b78509f977b29b06e1af48ee72acc99c7fd8465f9ac943244a394c239835d8b34cfa84b8f6a214f20d9398b309ea5ae923227769ca686de36713eca3964ce4ab032967ba65a93642525e9fb8ed086d64303739bf123811bdae0f31001a696257852fa943d748528cde6eade7ab6653d64c4bea3084a0d9bf95a5723c84a1505d81eed2d6f2ecdd6a81b928be6697ac57868b14fe56ea14e79576e584677d2554338a806bd27b95cdc20662e2b4e3dd73206a391767c952a4c4e2a43671d195f468330223cdf3eecfa24f6d4388a75d3aae384dc08b12c95861c3c177dc5434f0cb0323f271f9f3bc3ade6ddef8e0814baef2097f998f3042d129da0075762b5c11e5b01272c84128c5a1a05f7753e3d9ca3e733a10507d316a84771ea256bdba34e85f37ad9216f45bf71b46f2a95f76dbfe15f99916eef5cf55fc646a40c16d25e50b378c599cb5ae8557ccd76c846c4f5bb8a9ede2f9ec1463c6e5b4fcfcb010201558c8443bee255ffc59b0d321696c46fd06d8ddb24fdf2967c5b835555df8652b2a25b2a990d4af88d2c4240c2746e24a455881032bfe98b2577cd0b0500878c4fae93e1fc88efcd6395d9129abe637d103021c7556e2671f41b5b67b90468f0d7ffccf1e95c75505cf254425bb0b30e060a0e2b269b262190278972e5f5a23d830f05d77a3d7d00c4c38a812ef1dac8270bb26c5aa24756f5ecf9bdd837313c52a8d72a652a28585ffcbebc901a21e44c46cbd9064291d3979de71e2f03b0ecaaa408e159e33087d6f49e3a98434c56ead440cb8767335be7f3ef41d5dc42f526cb40e9bc9525e92dd990ddcf7d5ddf53a2e37ee891effb9d8424c82369023bbbc6b4773b4a47e0d1df3478ec072af1ae218a555bd524de2837a23d14de08d12313975e67dafc248ed0dbb30a9cd5a642b9341004b73de00ff01d89a06f7071bf52eb86e62a1c32e4c50c4d0503a5ef012cf93311b432629961e066a51816fc1fe1c66da47b547e75779819f84aa455e3d5a4c0be5d62d3ec8e4d910014e38fa953392523f143b6cdd674d6955445ec6c3ca3e17736fc2840335e7a7310cc29b14fe63eda4ccfe59744a042cbf8c293e27b3d420627918a93dcc649e2e0f08f3eb75ba67ee10bb1af9c9479cf49d6d948e2640fe25172e88bf03baecdd4d577e675baccf7e36cc20d664352c224a8ef4c6899bf52e57bb9a1cfa417c804558506dbaf56cce91d43a5e01e1333a496d1760d32cfab9d1081b412da1178e43f64c9e3e566df5764c5b233db02368e825df399eb3bf14a5bfc2609706db23c847c651d3da02490f528c2399838b22bda76b87b8f570d659b1b1704f591b0ab93a88242337033e1e80f968d5b01dd587ad54b77a3cbabf32ff886ed7b69256bcd2c8d524c17cd4b763059ae467a065c7403cffeb59690012cd65b855a8068d9357168554c8b270d20c186a23925e643a3ac0d4699f3edfd38c442c98f73e67aa09a1cc90b6c4947536cfeae351636e8f4700db97db8cc41148f2339de633750cbc0bd89889ea3ac4c9d125a26f47c2342e5e12e6883d72a56908d40d4645d9f0ae4139ea17773e15d01d9f5c4f55d08b034e96289ff41e48baa3994bdffb7779573f709938d763584fe5d1fb3e244d8b42139380cdc2140e233676fb92c4925ef3d5bc24f9a123c840f0852d3309c18506365342157edff993ad524e7dee3170fcf2e70c7fa87aa808d5a9e7b13aa03da40935d44b20c136d9b38c079a9e66d5b4e669959981269e68f7f3b077f43e5abddf8bce2bbf5f79b72ae2197f1cd8d2d9b2d6db286cb53b42edaf367c00e32423a084e7aa815a81314797bb74f463237345662864b9447181d3dfa1c533399662067e701b1fb92789a5e4f40bfa12567d346a6cb777503a9b6082f1fc459f13cf2902b45c559a0f5d497c86158b4f4d63829d9915793f5cca45245582001d723c549ff50be44904bc330fb2425edc0678b2c5de468133313f62385104dbd861490b545011cbd6ed3e57caacbeb52757289fd9e210b8714d69c6acb407b2389525bb895684e597061232d30e6a183d4fa71df467ad0de99256a417f0e8b2366984f8e8b01baad703fce650b66f27d16af5b2ea243de9fe5db44de7ab086026be78bf4ddd7e907d847baf09380f172ccea50c97b6ac7cf1025fa2da6c7c2f09bce04c26ae26e5c29544992cf2c195423c68491602f3d88d014d3da130d03af7ab0fdbaa4d3d1489a728eef808044cc387b54370ef59555210295191a1174b9eca4167dc01318054bf285790411e4077024381f4e2246d90f36c2bd06379f9a3a3124f5af3e21b6eceb9db819610662f310ddd22a57832213ecd74c28056590c37800249c05edc14862e148a1413c3b77ccf11df37c20c401c86c96f7ca8af1f204edebf2c70ac2fd5fb97a0bf9b2311d5a677362c784c48d87a8ea8173722744d45e38c58cc56d183f009225977e612295eec0b69db592e081c365ecf1cf11de79a1dcf5405bd50b66456870b822cb10fd749c4a38216e298ea6a2a6c7dff084223c31c5ac3dcdeebdd4c2b817333f0b2002d24ce6845f5be01c02c690048e27c174e049640d13293eb4c101684d14676540e30cf16a4a2beee7742ded96e2a796b215b2516d5e06c1ff87fa2981cc6ab25dd142a521aadbb53629f78890561601e8438123222007d50500ec7e9e47eaa6c29d3c1d8080f65fb0f7e1438c6aa49879667c135f0b60415f31c36f2b8cfc2553aa4a9ff4110309d859856c86d9fbcb55390d7e37fb711801072ea77c4579e106ae6a0f4cc39fa5b737b18868bd342ec69d037c07f2849a9efb8ec95734dcef3c41d62fe5dda481495fc0e6cd57124daad24219741ba9aa7aff6f3ef601cc96d32779c1bf77884aea56f90e91cd88965716132b6eb898204070845e095228e041fcfa7f28064bd35d3d2278b332c4d0b1631aa9df026cc0c27bf2063df530de1b288c0bfd6874e841681087ddf98430065d1267f82258495d6f0b01b192be08aa03644d6aa6886bdd59bb27cd5d2806f0023c9619db3675e59adadf68d9428dddff36746d07667153fe123df0a2da3b27b272cec9d22b20e74759dc8fcc0e0d7959203b13699c8abea7c137f894459cc698e53b6d07626b39632d06d1c0b1b032314b5a5b7663f9de19fdab396f1991b09337fd1a92e00025a7194a45c684b48dd4ad5cd9d785cb5d129ed03ef76d6cd77f4471f12c47a63043fa45c67cbcdd3fcb612a6067926f77d3b6077eba70498019bc0d30749c13c6b0766f985dff3c48064ced1c41828b2f656ced80906d23b87bdb4cca214ab61150a4680fcdccedf8d4e1249c6dee5104d778c0af52cdd7f874029ebe94f5799eee7ba4b503b4c97c121a443a9ad244b7e61010259e49c13518833d00f9157de9b0887c98daf0109b823dcb1836177fb927cd43c152d99870ab68d938688f1b4580f0a9723c529801075e2388eb68772351debbe5c5fe6297ce4ee6e7d218d4fcf1f446572345a2e04383fdb6d9dc1de40edefcc0d5e131b54cd78e2ba4664f0ff294102417396ecf7280eac36998ff4ba271f3480f998ebb81be0fa926be7ced6c6b143445a2313e176e6fa61664efacbeb0da56db8ec4c60a76c18cccda929536b14e736610a2d1de9f9c950728f074773dc0675816dcbb5a9313126f7ca329dd15f54f2d8e4c4006ada7041e2803d13e4c6206e8c7ffa36fec49757d1370f4e6adf2f05581eaa8448915b4d3b42d464143c3a3b7ba5406bef5f9c7cd6099178b91c76c52c19c2676cc3ec420acee26a8ecf005fca8cd6d911c5343745280a0b3559f1cfae4c916463908667b85e1852e29d8545bda36ce63cd6c5dc0509915d1ac48a982557ea245740d0a6f5d056561f9f719040d182d112b794024d5693989cf04cbbeb102b522b0c2c731836fc2c9b340654451ef4ddd3029b33b7eddbd816c79858264792eb387be0e60a568dcc34dbe6e2d3dcc378c06d7179ce89872fec1d857a877f09249be761502ea761b1f1c02ba9aefc87e995ce97fa03e4a66c4f48f6986a80cce904994145955b0ccd51e36882380e6814d6a48769416f6d6cacff6c8906be34f6521b209e7793acceaaca47b38295c43c02312fcce8f57e4c28dac062ec6ebca9a34ccda1518c5ae80b9c5fa8adf73ed0498457dfc7f2e8e054df98a0270c48b733030f1763af41d24030499e8412bdbf27c9066252507ac0f7c0974002dd0b5c7bb32f1917fee28eef917dc57c703514f98c1d65e3c18435c2b47a3761e270f4ce5737323464bc1f5931decd764678a3e959a6faab2cfacc9d1b6f7228fd8925848a18826090cd976574fc5e6f702cd9377c8e9c40a6c42f26e341f7b504034ac2a82c32fe21048d8a93b1ecb32483befb0d121b0998c86292315c653a566c6fdd93f40b6bbf6dc6e502a738622c7643943d6a09eb4b197556b3e0124621dd4f2f31bd22d1f2e510e490fbee91568f6d81e8caa1c4d61fe8306c859f560d5a20d6a918f4211eb2494f62d35a783c0f5007e6d45901db268c122be7790e73c0c5b06aa7b100dfec9cfe32ed796bd2c0c0323d680f51aa1c3cf31bce062495cbed0c2fc0e84346cbf7b817fdf5689aab9fe9620a1b0dd77ea8b357ef51a5155d5d125076d0a62b06e0cb2d90fa74f32b49d04975f7680e398b0f58ec735a6a69d5e315c9eefe0b2534d9e925a774d5be0526a6f4d538cf98296ce3c6d996042a7f48c858974707b19991789971b389836d5ded32f657d8209e7a2537752a397d7e7f5c21766d5dc4a0cd203ec4d63eeedf31eff44f7fb0a52ca3fdc6b6c93f7bee89a773a47a34d5f2a7ca7ffdf9156deeb7e29eb2df257f01fad8a050f79185cdcce55c7e6e97fa7cd7747fbc11522d8faeb40bee0c6933c4e03e2e48dbec303f90a4962fe8996c46ce5944649a1f86d37eb27eaee18bd5eea755e9ca47d94763d1dbefc7c87bf9998d929b795ae59327e314173146665e423832e02f363290ef63af5cab8b7b9eff7ed7c2b4c7bfbad5fa9fa634d8802f1910c5f310ce86c6fc4f93763d1163","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
