<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f779e46575efb9f75d395a433968fbe4eff805ef5707db137d3353560f98ce3b7c3fece348278b776fc26fe852ad0464304aed716858b8c6fc03d550d162f012faf45dc9bc23d1ea3f55412582f2da72cb05c5b526fdac6b8e948ada234ae20b77fde17015649aff359944bbb927d40b45923d2900b11da482d2f47d2ddb9bf4e4a94e3415addeff9c7698f9f318725cd22c5ccf488add358436e23642f128a5c58466f86e850ce1b8d1271b0d052fb414919740670cbaca8c987a8e0980edeb0959ba00510b3427f2e78e5ba77c14f8d6d5c118a2525a99501557f9b2bd36a79963229ac1310a69d290569b7b0ef9bfa38922c3bd6014fe6614fc688a76fc705689b5e4cc4d8ff67eec7615c4f235876c33ae581ced398a802d8438209813a31071d9a92a64fa0ca0f856c4a8c84a5befb386f27305e68e383e6fbe85f889b0df7181da815f58ffb63f15b4353507b29481d01bf694c80efe028b43ed4a6f10732ae69c0d95c05ad6034e87cf78b59768526d56b46000bbf0f407074adbe0c30f4afbaf8fc443cf872a4cb488ab2e5e5c02e3364f1c55f6a0fcd05e2ad5a9b82ab9cad45126b3cf75da9f21dd860778bbd5c7e72eee1fa8f6eb1a05a7d4c49b5ea3da19f34ded1023e32e17051568717486eac5814e79786c148e38188ae018884d75b30457e3f904a404c00a5cbce2ad3e471a30d963ba6b86827dcf43060fca1f441b2d74cfa58852531007a97f480968d5c7000fc583de068a6ad020f4e3408b7caa024112df3b6b62dc4b623818de590544e0eb54bee937e232a17ff02849f46adfbc73f31be5de08e30e6db72807d976ce0d6f3deeed1ab80791dc7fd5731e160504d52425bf1b22477f3966fbca7bfc9df0cb8011b980e697c3ddc3a84168f4cce5cfae4432ccf17c42011210ff9a9489f30f8f0100638a35af9efb78645502e69e0c92ce7a5d75979aed4ea462a68e83daffec49c59efd732e277b1a7fa3a567ff3e9e37c01fc42b95ae379bd62340fdec132a5f217f5ead26376576828b99c56b248d2fe0540b04c1046a7f68d75a7613d1fd8087b23e417e568d8937bb1706b67e88fc578bb4c24da039073be76f41501fecf52aa7270daad9935285179c728df6ddcacd22e0ed2e84673f82cb59c0806346a83ef966d0a656196d3896d65de11f9e662601a2f62a016ce420af603238445572b8dd66f8b52610283a60a89f15ca4d0e0f6420e9ab8e9fbecb20fbd271f3fadd261892ce71915aa95b1d3b25b7044f770f26ac4520b3dd4215598bbb2184c282f41a69e8e37e588aa82e28b0d936886901f894467d25c3ba56849c66065d5b2306834cf34bb6aa0a574b28fa5de0f1336746abb183c45ea430c371ffe28ae38c26e68a107e6aea9bf56d9837b73ca7516534d983edfef0dbfbadfbaab9601ce59b4dbc836000544c9e9bb7a317c1160fd51c3a080f928b10f7b8d7fcdae714f56aec012c61b6e0c47660449a081d6b735b39b71d7168cb33e40ce343e22b9382e3b10b35bc54bf8f0d273c567091c00f10da341534396c774dd3349022390329c47c4cc3bcd43ec5f6ab4ba762425acf8557369564b72fa1ad59dfa1d113210bb507493076e19382237b5de9b3739588838345c6731116d4788538247d5d6520717d26d6983aab6eddbbefb0f1fc959400949729e969b98c3e57e67bbb0276452b5557cdf9fe29126e1ee028534245213492a688f2abfe8ab6aab0040a726a60e9f195329e3bcf3e4d41e5c09a9b99ec7f8bbb251d5bf78d3c3e5fcd2d800f447f6f00f416bd9589ad3d7202a00614e0a42b7866ed12a0e10bd40084cf28ae89bdae25801bf899ed4cc35923dad65d43766c3186e409e1446e73a29a5ba036ead4a28eb9def8cd9d0656add0d1551174ea96e0305db56acee8b15d12e55221d56200b38320845a61fd272cffd81b56c58f614f43f90d70c768204eb54bb91f95b0e9deb8b9d40d92ede215b22315dba54685ba4e92baffc3e33f6240ac7b7e0c8fb365f4a18ad513554344836d5946c87f6680c289f6e907a7c95858549aded7b5ba851d2b13dfe67ef41de1ff1c4e7fe7e2189effbb42eaa2d793856425a15a80f5e58ff1311831a3cecd20c4f88a191a532b846ff2c0d3bbab3251811ce10c317201a663378ad5b71adadc3d679ada389b378e592a367088c6dafce0ea1153e47b33c9c58e9b795c8cbb62fe79c8ce28a2e4f8ff1ef3a9242fbd3cd95ec1cb62849b299455ff4d63f779f5725fb6103b62cc3a23da50bfab04c96f4d6b4eb41c3d7577dd46c1999ac227bac59c61e179b661b3e3daed5262c46ea90c8f9ee09cf830121116607800edf3b8db81ad883a6220c310ec2881160a52b5f7c5a8483a666ec7461315d7043e0ae0bec5b8950f47ba5f9295f10926156773c41a573f3294522b94c8f4d3faffecc0a99aaa2d982398ea6ed6854c1a574b8f3e85679d35a365e781657fe6af77dcbc9e3410d67748449dc87f585bfec27202e9039513541a5a4837477e51beddafb4f2f26d930be826fef6072301103d92a22aadf26750d61fe97151c8eee0007382a38be76551a065b2fe24a7743252cdbac074b66bacb5c161e4967c163ae711ba41fa32b06b042fdeb38f8b6e432b466ad873ce41687500bef5bd6801c3afb749f6070b32c670e4e59d28fdff588adc2a288b387bc40b00deda27024d461efa291054b48ff460241f44f0ba5077f3d4604c058289a896719fdd0a48f69df7a60b3025676dca6de1e4e9ec8aecd4d108ebcba7199506eab4f9119bccd19e276249a3a7afd24103d87b9ca70d5d2bdec6d8b670e68fab2e6a7ed3ff83a41e0117f6ff010b277573e7b9eb400b38b1283c954614bc7e34a2239af135ccd5a26da6c472d10284f51c1a91bde426cb33c10b35a9f07c03dc194f27ed7f9fb0db567a47047730d529c350a50a90ff3cba8df25f5c79bdb6bfdd4479b476e9e6dbae09c47b4edb0381450a46e9e60e25c96e7141798cf1657db3d554e2b0c9749b9fce739c9350d1f47821ed0839016aa9109619735d625f3b1291448b6c9bcd7ae856b2b93900d9ad0c578919dad1d806b52f81a2194a5745e273d42aa5fe6c6caa007fe448d5d277ff2f75cf0ff72509aa8b5f0af05555f708e178d592cb69eb61853c1a4699cbacf12e3dc1427bec965f838d6d0ff6596ad966a9c0d9bcb2e89b8bc773a86aef9233557512c1e65f4bc80ff9190a930dc9a05cdde24ff632f49d2c68cab6bedac40585b54986c31fc52c3b4f91db30519f6b84795fa650b5e6fe1698bae4b744a516e85c831f9aad9baea00325ea6542d132831499686b46546eccf731d6b59411f7903f1a11b615c95ebd40b75db0c881a8655f6c61fca9ddb2194c3b6e89565ce132368d4f2ccf06f2fca294f5fc7834980b4a77fb66fe8948e9dabb76ac9bf205e306bf92797142bf39c71771ac01e7514f2ad544d3ae9065e6e564ce1a3fc4513628f16ea608bf11d81820138f40257f608998419b8fdffa27c5fe36f269277b25400bf83a0c304cc2bfbd0ce2ad2e34a29d942bbf8ab79d32b2383cdb6c6709303985b2f979ebb66a1500091bf03301948fe7790dc2ae79c2c83989aecb76c0978b5721dace2f94097f32e9845b91372540a7f2a3ab7b1b66352ca5c2fa0a2b8226af46864116907c3c04846885310de90e31f73ed9e356669a73962756885f5e07a7afc84d3abeafb9557aa142a6c2c30661828746dd982e2e7e63c7e7162fec8bb1c20612e8f1911fbba1999f95be4d9302b983c09316133a49c3a4ea4b67f57866473eb3de11a3e95d5f8a3eab02e2ce969fcac86428c3b5e305ecacf003553e6010d493d0300a7bf486c0385361d0b0158104c47ef6e58008f3599748cda0b7d4134d7774f16041f90758aff8e7c1448e4305144400a51b16281f033dc8f1e1dc04645434e60f2d8d2cc20a2781eec28cb809d0cef3527b650ab1ada70790e093276286dc47b1a0a6f280ae0ab121d196e45c687dec137b480893313aedf48c3bbc06f49bd86d42f33adc1fa71ffaf680485b46250bc948a48c06158a1b909cb846494d79709ed7d1f720f6ff55d4bafd37a28c2e65975d7cc758405584f5644f197d7715152de14a1d4efa8cb9f3211405cc9130f5c9e7e0ff4dcc68a566739ddb59cf13fc58b5e851c70b4873c729c802e369f42b96926bd775adfde2482e3f05021b3e96ab82c3146812c2a90e3207da3bfb57095182703bf8493671b03388b838e1b05e4ff4d5f6bc69b0a28416aca334a4b1c71b08f47e9ca4da3c31f26439697a837a66f2903521f39b38911cc169d43e1a95a16884bad370729cffcafef2ed155603e0dc1a5be3b0fe150c965bfd6c20a458ee56bf07fb9f3644671554f33b615df9e79af0dc8f03e0f17713bd47e37cd0b347b7c6a97272553ce4b8b9086ff94a11ca0e7b333d25aa78b3d9cb6eb961c9cf547c232f5d6a01f1b45b4dbfdf7e80d21b306761cda30a2ee36f9cf3efcbb1a84438966d2f26f1ccb3f57a35b6ee148f86a3dde0349eee1aa5ca2b50d4144fc31a2b7bf4b65dd652b47568f378c0ea83301cc6147b61e912f1c80bd404745dd52ec4ddc61e47b36284935fa1067bb825586de5f9ec1975c5aa1e17a8ea376c75d6aa2ed1b53bca1cfba10ce2707f320598073d1c4c243b2dc5d710d8b22ede576d77ad89212e3acd872ff03d08e743ccd4ac6a172635147ae689a504c33dda87c2553c39d0b69dc2a088331a1e80eb1220263b6244bb08ca21f0916ad2cba261e995c3bc711dd4f6dd4636ab63fe826856134fe4a7616af5dc92e4147d2499dc112fda4dc23ca35b48b65ca37a54c2625bf812cf4f3c0d839883e51b44fc43c0d3fb616348088932c538ad332322ad177c81bb9f13a66669298a7748b7e1a46b4a24b208fd3e4a8bb2084ac02dea51d4981b2919e6b7c26c38a60ebf7a8cc165874d5018cf2c5794221adc44a8b4b8073d79b44c080709bf69259d2d6ec53d5441a20e92d7ec37447dd4b7567d200348bc9192bbb482c3f0d0b64c7181abcbcc309775dde895fee6ffe7035c340255054ca5eca27052d2b516cac4e07d4ad1836556cf4ada478dadcbd16d1a890ae4d80e99325e765110a8b8348534e8ea5fe05ce14d8e65ef9438888eae3e3f2724ed9d78d384df19eaa772ee4c042d8c8218f2b4b457e0e96c3debdffd6e82ece2519f7ab9ef044680dd7602e0ff3c55e89ebab583502c2058b5c2d8cd8c7945fa2d51af60360f15f0223a7c1277f41de356c6d51088695a87cfa0c7be4460cba9783745e844bbdb906901a3a075d3465c19165ef8e9f0936c35ea4490b229e3b5b6fceefa1d494c80c2b763fdac3551b94b649cad22789c34539d1ca155838fccacb5f1211025935a2e60c74fae1225f84bf55b1b29f13c87bd0128536c55980eb87b28c57fa0a2a0261541e599af0415f25dbd5fa64d9cba68ddf93910c301d6ae5e8024781505a4c45c616ebdeb45c95a1af1b197dce339494817c691f623fe58206da41f6c840c9509b01cbce8f7b205522d553f14874771324c8fc4a7d4e3c46ce27272f02909e64f5ff8d38ab19bc732efc3ca90925ab3f2ee056a7c1a3ac018f2f4de0538cbcfd1e81eb8afac2f4f391641111748c0b1858eefffc20fb02ee7e12904623de2b37d15fa8237f8cf3745aceca45f7bbdd1ab09c89eeee9532043a3ef578a165b2ca793b4b8449c82474579e29e3a600bd2425c04ad6552c05e45ed12cfdb3923c1440641053068a9f43cdc1d9b93bd317dabc4b7f5efd37eff095d24c48d994f9e5ddb1b6ae8cb979105c5be946cfd238bc5f9224f22e4bb5d7471cdb3266a26ccd705b5c1bfede777792d20a1b1aa2adb2f19eda20504b90ecc628dccbdbe324dbdba2fc44533ebb8366b06bf426b89dc69fdea2ab7e3f62936b599054b969642b057f2950037f67d311f1f1e2745cf811a36df57321e62b5fec0cbd5c41615117f666a6400dc0b56d4d18c036197cadffad5c9cd01232d3205e9c3a7a7fedc581b8ce2a9a6160341a8364e9ba40de99fac840b7ce1f4619224232b3cb5b276818dde72568bfd3832712c3acedfd32cdbfbdac6ef9840613c6321227064f1a2d79142d63a26d84eadca76d9008d079f84d364f9f225ba28bd155710b4457c00b8ac6e73abebb826d5b0cf1785850fdfcc0c8ab4896dd0faff0e4dc35fa3f710c4b1750110b6e6d40e390529e6a53c320fdd83009a19f5f5e616b808cbe8d3e950abc8af1beda7d086cca486d2614aa8301a1af078ee87ff775e2a0744f2548c9d365666d06617f998ac9a948110510446c9a8f22b9919741be0991bc43090d08208e26e183093acaa2afeaa1969806c3046486c6915d38f26b0fdd48747faa240b71032ef158c24f87efdabe9a90f904577d240b343d0cea541643baa536bef3b92b00c6ef78639f047e393bf8d07b0ec07ca599490a1ac660a6034b5a53dab56a8830b48f67dcbf39e404e53d4f644b8cb2379eade4c002601f1a5b964cb8b45882880fe49dd4541ccc5a85c734bf462b0ce306897b883b731543a4071a81410ac35b4419837d88f351c1eb5a99f70f84a339c0c0a9131d9cd3ca6071dc79c6be5c472516472ac4b93c3e7e4bc7cd62d936d867f91481be66be72d58ae3faf6c0881bd3029be4c19f70b6a5e04004058e8087fc19b3b7b5121c92048d6ec945b6ff3dad277b76c294f1e98893da16be3e6d7fc297f5a3084c7611a47afd4ad2dca3e16eba24ef7c6aea5eb2e8499004a048945c7d89c71d7961e9b19449be4c2dbf39c19a7a1c51bbdac0f2691b3f13a840155890928a82acce07026045f82075c6533ecb7ff47ec6e82188915468fb89c52f38d4e1186589b2b21a46ad142a4a40456bcaaf4bd328c51b7961d2c297dd7dab96f3ed497631376fe6c8273e61396c7913ae5d07a1a89c30562dfd004d0eeb7e778fe1bef38cb030496b3d27609644160a228a45ab62209928555e1e2d85a33e51cafe1eab9473aa774e682582934b55c47962a8fd2cd648836df95bcf2c1b0777645cf097177bf930744bbb598b9abdcd6e32f0c29175bb0052121401b11c316c5ba79df7399e6a965c84aa4bc9a7cf1b7a40f14f2fe36bcdb412a6a87679de1cde68163fe6fe90005464e7302d2a2d372a5131a284f921f2935fa234822857823b6bc998318ade785a7af42870c01d8051689049891897e8e338e9ac257494d104c72a56fb3e5d9205a5a521254b72111c5d0ae0fdfb7eb3cf5677f3af420b935d07b32da68eecea6ed5b19e37ce182792bd12113fb266849c32492e59b9917fd6d175607d046ca268537731cb97359d2f4555edcabbd8687a179a329db6866e6a96b2386971752949a820010a883bf655bfed6e0393e4985c90ca12251c38186d02fb2ab4ad0278e6c0ff5339bb10212c8d8464dbb534e321255d841d5a7aa0b3a215c3b5351397b7dabb08d53e3382b5ff37f7316debec6215c4334e3133ea59b53a21d5e24f34980b94a7ced81924797b5351e08f03b3a59870e99edf9cce4accfd4ad09512213f66bc242956d18176cb0f1af2d1f3dbcc206c18a61c7541cc0132b47918a8b5cba160b03b001ff31af55a109ca00bf044e61161d971a7803b960a5319e39d0cc1578817ef544138336443793e045e2cddcc43bd002af9cb8e61b9e3c9f4bf0d6fab343e6b09adf13f6a0ebe44d68329e4d27c9e3f3017329062f422c391969afb2efef1f1ff26669227ea86fe74c1a9237b262092ad955ba6f553bf5d8a1453293ccd8fec56b16d42036b52e6c242c305f4462c20ca7e2f5b2c66e057f821977d14fae8283756cc4d51889298b6a0ef43f07f06db6bf4e6184295be2d6ce7313f0ee867011c4c9797cbc7f786fbf60f2d8cfeca946bae4eaf54909d01b21b7b20adb55a84b5da73b14f5959f8ca3d35bd827cf222ae0a2d6512c4886868d06553c2440ed23a9b00e63477b776a8dc24692587ee74e5fd80ed432b21f64976bfc51ce58a556add3a4fb7f853d10713ed3f689187b294dcfa462224329a58d94701f24888655bed47b00903724aa044a648b22cff097ea32b73ce68b6307c80475ad97c743dd041d60bdb36820f0779757220a5b94867584562c58ceaf47d72e2f42279117919f133acb565743959908fd26ce6abf8b9e17a30e6851772f67d2701ba4e95f70b3b4536cacec065701ae873dca44d0781d6a8a0efcad60e447db1ce46d4764210c1b909737ae6f83b7a065efbb6509f3e1bfea132b46a1892102dab7d74f044ef92bfb4be246d4952a4ca5460ad55b83ece923f5c9b2ada0323a54c65c6e2c4fa32ecacbab7a461dc85b479d39a9c605c07143b678297bfbe9cfe4966b96a2b780d7975efc3a8133eb647edca70e647b5b8b1014cd716485f2640d420f9c079158c7a7d52ef15264916de0536013e95adadfad0919ab0ecbb6dd26924ec1050eb313047ed4f9e23587cdd043bd975c49d236d2ba008d70439e9f0f9e772240526faff4c178a751d777600d20069e51a89b1f72d08b673f71d55b2b9c6a6be34535591d080d90a74718d10b44e71c2a2850411131f4314676cd0998c148ab45d90087e3247ab063a5b898f768b9dbf8429a6e5d1a9ba37ea7c29462f4acecc91cfa11f2b6ee638ad251878e214e49ddbe31221e8d9315f704d5c27e7d5fe432c3eca00af73d2affc36f65fee8227b75d2c34e8c7ffb5a2a48933bafbc82bb953c882b7e8bca17f123925d9444833cef624043de5714b3affe8b33a04284fea0959e96fbc88747227144102c90055f77dcacd7f78f4178f90965d51b27ede125310e01b788e5e7512352f312c48c964a7a3b467636da0a9581a742b0d64b126c99e13c4b43ced3a79723354e5993c362a28571afce77a1526400910241c3a32ba42d3e439457ca0128b0ea68cce4a0d616089cf47489e0d78c547d62b2e98eeb3ee0a5c98440a7eb5a50b91d21edafad8d17db4ccd6aec238b3abdb68a324273ca7765f96522ea5b9252e1fafa0abebf0a58bf1912e993ade1575422150437026ca74155aaa090645b7a10b895b218bde3e77fe90e7a535e2a5473665d5f652e0c346274030d8364f46f50bd30c7049851aa10fbcc8b9fc09e13f86f02e6c41a5cbceb5d84f9c4fca5285a406e5adbde3faf3aa215901cc038405594f1a549294ec6b8dfe0d9aec76e4d4892f21efae0204463ff54b049c8c0601a2d717385712067da4b488fcb897d32441de8473c2a9bcee3bae5bdce86d643fa321ef3c2aae6964fe3419e28722cbd99096971f878d2ca88e8999773eb2d2f902f6e340d4c545c5f0194652345cbd48f425215c7b2c3a7a0f0de5afc0810cf75201e717abae41fbaf7d7e35b53bf8121c35233a178cf8293011f738c04b645ebdeb7612f0d235cb838763fcb41c9a40cad0b573ff2309c98fe0e5176c114fcaea92005a1b941b841bfe147d5d61077c06dd34c3a8e6294cf59bd2bda8a4b75c321cce381a64cde84a2765bde8cf9e5f35b7a2d7e8d70554b658b328f91e3c86a0aa77ab692e54b59aaf19ac00900a9f65b5f6eb8f842bb3e426165ec63e627dc9415733a5a588b9a553caabbe72e4356b4bfa9b6b998241240bcf0b46665db3bb737e90a5cf1f76eb3e87ce23f0bc1ff482bef741e8732ed674423194f205c324c04c2a960e15ee789b67dffb87b417ee83b12c36c3a927caf76160523839395dc8152ce05a8a5d736830ec86d6679291049c97bf08255ee106360d4b760de7cf04b68b704aab8563ae77f126885ae3022b5df0fe9d28650e96b2e625da637b36b265cc96c8227c0afbcecc7a121de43117b269f595cc099bb47a3be3073f3c09ba8a532f512d5cbe6cf463a5b939a13bc59fc35c389356615f09fb8019d8dd6965f17c1c4bf2872834ee3e817b424d93865da4616b560778b3bf706ecfb2aa1cca7d47edfc6fb6d35440e4b05e04bb82102cd2586ae8a5b73534536ce59876a63f8342fa07ec1b21b7dcf0c62c34202374f387a6a2caca1855e9392ae720ebce5a8408d9bbd7424d0bb6a52a45ed7879b82376e1fdd3b7b49a1d5559028fc265b6eacb40eb76bd89cab7079d0420ddc0700586795e64ffef0f1101b79308012691a6b20de36c503ad047f3da3b745e9689054b821aff8bbe794d603b53f4ad0408c66689ca92be60ef69b29a742cfafbac43386ccb41a944c945e9df7dd61c263ed7e0c1bdddc11b2994807346a9e79cf887448db2f195db600a28f4ba829bf76fd391e58a54ccc25e111c7c913817f6d69c23bb0098291306eb3186313254d8cb3bdbdf62daa0d2b8e6bd024a4f18c2c9b1ab65e4e4177f050c28b651feac9e07fb26083bc5917b42f345bb8df50dd2572a480a767dd541d5455ae97d69d2ac6189120b057af3ed87c1ceb51bfda5c3af5e85f84b7cda24802779fb3d268c19eacc8bb93f58517503fa05b7836170fe14630cb692eca0bd003cb349c9ca6daaea1d83e9e509f14d5afb95178aad92d2a3785fe2c819391e370ee658de73c458bf1b3e4a091c78e621e01eaaffdf4d3c97f8cdc7ea171cc2f884a2d86f69557afcc169830f2edcbebdd24d1f62f9cc562a89a89cf9cd1741f492bdd4053270a2e7f4b6aa676ad25ef6e0b4ff113473d1cf0b593153d7aa2703e09013e1200d45ab611689e6204b610831c8bbd739e96ac6e1cd879aad324d5108ad4332fa82afec19fe5205d6000fc98c153aa255f5daca6727cc0fa03e39253162862befaec9ca546a3d34b744cffe54b9a86189a89984cffaf7306a719fce1ea20ab34aee01598bf96bd36905205dd8c2d99007b42af0125ac784c9d0fed4b4d75ec34cbfc35799681fef75f7eaab5db3303fa99491b9527c90b46b5a77273c6d39488cc2afcceb6a082c550860f14b784f2d3f246ab4ea242d81b1beca64abec5d4a82fb4799e1020a3ade0f2e84c127eadbfba24c9e231a910bf54963b5e0bd28bc123f5497f828feaf300eeb28cdb720fcc83478ebd7b6ca82be16531a3c9f08b204a1f9a83b9dfa35420f5b06de9c1878b857bd0184a1e3d13237a553af2a962f1fc29bcfaa7904e724c8c6a42c1d54639556364be152667b130ddf344adcf294b5b7aa41c9954c868e4f3f08893449a5afd6af3df404bce74f05c8f4fddd7683efab899509a7ef8eb558a5b10220f9ded9c60217bbf783465884a11ad77beea5ef81ec83f0585c1c6e95e7ccd1f86a09b406c09a0b6dd845c54eed72da63ce78695dc71efce0a4d202b2a1a955305a581482e4a882b33f6ee0ab022ef654fa5a53c5b033a395899f94d609bb6f4405edcd57f30d42fc1f3973b50fbf443b7a4a89c9abb9fe492d8d39f5217e41eab50e200ae6689d8f687e399080a22ec9b3594d46184a0214cda121769ef8a007c948783bb8eaeab1e0557e624bcd7fa4420a9dabc6f9d78aa0be4ef3069287d5598ba53f460ececd7d108f955e0fe02d68da6d49a49ff9b6578a9cbd86e874939493385cdf584e906d92f8a4de28c2ba4a8ed3fd579250cfff4f76a7def4b9481336e93a7211b9faa887901c26c7f3010711fc815ab11e9ec93fe3f82b954acc9b3912e79adc07923e60e8281dc01e48f7e1593e1595b3233af3991fac83b8fd0d783fb82a2a9dc8f38d889d59081eddc90ee3af9448c34ea8bcd0235c45a35d5a073c56dcaca5b2bb0ce3ff4ef33143a6327583dc8209191a01e04a7ee4e505b66cbf6c92482abb543f7555195091ade14106ca46342481dcf1da7b681a9a448d0dca9754bdecefcf1702b2577b38488fd11f25bddbcd6c37f92f8a87a285483e24999f30ce131b2f6afc35f9d63edeac881c0bbb50cc24bdbd1841a781a3ae211294b2e7e25510ab74aedbf4676ab521c5f1c9f53a6e3d5e73175b3f88a51f70732402b40546a1211fa42cc94ec28d98c105a066193399e4c5f0c70b2d27d38d685d521c3631dcf882d6fd48c66ae6d0ce841ebca07a7a3314c20efc3a28aff5143f0532449d6deee60dcf8eedd5adcfde470cff6660e1e9231bbcc5c696943a2ea624369bac189ea7572a1e866cb46ebf155a6c7206f52d6fa6a4411db2e68f50d0acfa02bff304efa8d90345c2d3427279c1a6de8b23a745187867fc96f7d98bbf6599c630f347f9487903034298390e400b841577afd34b5c71900e42662e7565376a5c77b6dcfaaafc54da714482af5646f73a5d3b4a757a11d38180d3c2835da0c6f8d05ef198b7454c74c35c6d147dcf82fc9410d22bbb43f4b680c9660958b6d69969274173606ed40c93b664a01e8f3c8370314c92e72e306d58378ee8af6659bc0cd0c7f4a4c9ae2c0075e66965aafd57f99da8585353c45dee789221665227862b2b50a8149c2040cc9608edd30b22830f190787768609485f3db4f246c473b80ef663deb630e3fe35952a616e2038e87223aa2bbeee5669a1bcfa07c90e44d6883731576ce952bcf565eb8f83b43f857d3db1272e9e95a721aef2711b1044dad73578ee8887c3e0d21184ea524bd9139f08c62120494a1752ed9a85714201084455d966cd73aee9e5c8b6276b2e4dc754f3a34e7724557fe5b21b65da66a34adf14a5d9f2e734ca9c6fe58dcbfc2e96f26043408062995cae41658414e15db37a6b4354cb60e19dd4b28e1e8da6ac5466b32a8ae535ea1c60d58365b92765d081c0d93d83aee4dc0015d6b96631987820e5dc484b805dfc14069e8972953f0cb0412333abf03b7938931a4cddb758e6cd61b0a9de5cf37fb6ff695fd8aebba8cdab531f02db406529c793b9b4b82154a060e43b0a5e0473ebef6d94fed0224ca8a39b7544493297c2184ac9fb9fa05e2fdf1f963567b106328fafd93b4e4f43bc438316108199ba5ec8f38c4fff216341aa9364672d8ebabd6912d01825c47b0bb5ee0eafe2388345fe29080070372b27e410c11bd211af98daa90ef438314e6cac95e4da8448280206f46138f1019c98e07766f098134560c8a1e54648ebb71956033972135e6fccd54fff375b6f3521b86d41bce52311770e92f9cca3047ee0031e2c63ddb8563e8cf6b63b060d8da63b249c9f267f299ab7ee2a3796da7a4cd61f415edb782da9a7277cab0827e033b9a0501b56aee979c8c3b25dd783d0b12e8a660154c3b984ee7d980ec92568b1ff44113a3c3c41ffe3c4e9fdcb9306e2b7084927c78c0a6f3f42ccf32e4a41943e21da0e3c632d0a8f5dd07b20e9572540c1993d7b1650aa3b7a1216053f781be7f2c3ad5e5995eb40d174e3e908e446ff50f7dbc2b6e413de8675ce3b34d409fdad5f42545a1533eca853ad5c7edd4fdd904280e2ba922f20d2b3ffa4e3dcfcee3ac37911cb2867b4d6c1d5ec54a284fafe7d4714a4ad7771c10eac79766f99e7cb1cb894169bc6d533f817edcad46d55a74b21e44a28616d4243813cb8dd1b3cd4e22bac1ee4ac7bb14be4314f8c8709017cfc7f6c080428a7d68b4b065ecfdf159f3b3558a95a903ea7aa4b4f29309531df535f66d1b12b278914be914a0188892c735170cbc82df9bbd8eff433b4dbc8f6ae1946e4e20ccdb2734d6d50a4f2797dcfed6d0ea57091a3fc1d5460acd68563dc39b2b68a600eb6634944c130822824f293ca138c6586722f088adc0254636a7eac98ac5c82a8bff862718706bf35bf78b9a133ac6f59355f0158fb46b63dab67db8d32b03e2859ef65368cc6d937540f218092046dab9e0ef5c264f216483f9401f8caf7e0668231eacc60724b487b09ee72f7bd7943f2f8bbbe83ef993544b0ebdc8e97f3b1cf0544bbafaade930791c245ec28286633eb2e256f83e894e538330eb9b30bfb5af11d542173a38a1e0b8641fec65512e57ed241dd83a92e004cddc21820c65d8649935cf3a5770a1263ae8d5eea8951d63a5797645631de9734cbb97bb8f5b55ae2f8d530f7a6e04e9de907d0729afa2c096493db8df0f6b1d3f3442f9332cd41c5e20293d4e1978fad8c11ee575b81950c63206f6f7dba0298f691d4d41fa85ed966a77d1e217db6439fdcac8bb27105aeaa6efd8db28b6aaf554ccfbc68be9013b893d4797f36ae42099394a30be8e92a96dfb45d4b11418c6a165ca1b8c84b8669b2d4e735a179ccac46edeb0a884c3269f9889471b2371902b75f27f65566ebfe1bb25c9cd4de2784bff81112fa68581b9967d19cbe9ab3125275fa0047f69109c8fdd76945531c9bee86a6e673df55e2abb4328db16d4d6247b797fa71e5cb840602b0679d705b6f8196a17cc03f9e7e16aced81801e1d2980d2879ee18406b470371b6a390e7de2af87a60dbc402a42165e2202698e1a192ecae5801019e9516e8fa2fe5b5c45cc1636f903f67d5a4d4b31e1fd0cc9c3cde2a51cb8757fda06c3eb56b9f42505874df1eb9653f928a346ca7da66e8e0a325c46ab018035c5f02b6145166b04b935825983784f9b6c6cf1d2ce7bc009aac7c07f16692d70b86d04691643ef9abff901f004f026db6b72d18deff65611ffb0ef9e27a4adcdaf691915404e8c49b1db53fd3ad4629700e0fc7788c929c0968b49ae937bfc0ff24566ecb7b196c5620d627a0f64dbdbacc658c05427d34718e42db88b04cca660e81c13ed3fc3b55830f27499bc391301bd7026795838040d6d0d98ac7708cde1e430798b6278966c96fe65e9d7c63247ba79bc53b9b6fec762a08f81072a80f75e1f1a307fa65d64c34f83fee63152d06c248eb5eefe6a3122f7b68d9ca1cedf56ec241f4f196b8ebb2259c9ba1b9b2974a99f823748b3fab5efffffbd011bcce6da46cbdc845788f6324916e1e4f2b14bffcfa75173f209c31acaae007038a9db1acb2b36b6413e596a514af4497560833a84fed6965b8cca27fedccf744b242ab85c016a0abc996a67ae976308c60ae6b548780b7b3905b975e1e80f12174501016cf7d483a48b0e843e31aa01926199f1edeab38fc02020449eb34af4374e98857818955e88102839e461af214cf8e2f75c9211b3533b831a631c7c15ff6b561fbf4b8bc9d4f89499fd31caacc697600d6ff64904cef6720effda6e0f4fb691cf0af6a1bfee4207beb95dce13886004617740243bd39eb27061c27b97aac831e3d6e26748b09706736ff48a15fa2be563b27df646a26e1f7792b42d8632a0382daa882f9dd9d7f3aac4be4521dde59db63da21a7f8b55d60ce6177e2ce43be234a5e3b289edf66b9f3a7e290dea77813a742ccd4414696915447a4db375cd4ca29a2e9199a7ef62a957fdf953646e097527ddcd510a3c0de5314f3f71123bab1641c8ab839b67a2af72f68e9f3e247ba395125441bb5d04ff00cf503d25de07840662dd8530ac98d21d586a779a858c01be2f8c5c23c623b3d9448f5458228cc71513c997f75545c550341b5c195776d8aa5cb362a369b11636405e92f3a25cfc4ea6699035473af467b3618e0b52517a37c0c94a29f145bdcdbccc32f711353daae7cc2b45aa026ba62794948e1b9cd1953bdd28e0b549dd96b6b2b2104e94b5094598a8a8e36d3ee9c23f71cef75b6ac41975501731df06e63e3258361601e088561cb6185c5a800b70efa7ab60ff639267d2c6ab3ffe85da1fa6ac984a41cdfced737bd7502bce0953b9e91e62165c4e002d7c054e56206af4bed910e6df42cdd8fc0aaf3bbd189510ccfa7fce94371511b17ad89e748fbd778d93c3f36d757d5cd05227617f6b591b2ae0645e802b578effec98793315dcea40cb27983738dafaca0ec6c765d2741a6113dedcffe25da3506ec083c79e889277adb8c548c37ad6fdec0a514857328098bd7d7351f28c0da8eb89354582354f436f93bd3daca26b20925b4f900cdaf9d496fc0bfd07a160620bc6c201d0550b5e6020fc820378f7c37714075e217ff58166c1d1e4ab3ca4d0c0314ce02ad75023037012e39fa1d52ed3e52eca38cd253d7e3b8be21f8e83bb377cef0df595f7235f372dad02cb46ce2c9bb60de96bc1792cf807292f6aefc7774c7ea5942f957f01ce411f7002d691b5d29ed128dc3857ca900e45b19365ff428ed081f82a4e422d5b92f89f043666ecb2715b50a5f46261bb3b2e9450b07f380528317529bd4e5e99b7ee024ece73589fe9c113e64473d07042382cd78607c6b6b2d358b09c61ab6986aba492c67084e1cc2f88cc4415cf38a733eb9fa8495abb5faa969da80d18df1f79217cf93fb95ee19c2a5068f29210574ee22e932ff7a9f507bc91da474959b402a585a3dad3109049d9e28a3347835314c42358096ebb187906d0834cdf4a237a08379973ae6e67d39eb76bf180358a5a04ffa2d1b24c824c599ad2355aae4a0e3647da8d68901cfab26cb69bbbf70b4577da4e7b3cadc5f5ab0dfb0e8c05095c7887051f6b8d568a029f8da98a3e0f5f72cdfcd0eda3de2b122bd27d4a3e8725185ec7e9a393ea52dd9d5595808800d01be9a9324adcf998fb8f8982c2616c345df3a8569a68833dd8bbf12bf77feb50a7029b01e917e4585e161c2c4d57bfe74b5200c62932a4a104dc65d1c7efe3fd24067fcff8e0035fb69c45d11ed3eba87701634887260f70e9115e6c89dec27d5ba3e757c8b336e0c40392b3366a0950cd8c72a0738e83a7e70e32bb06a7fdc20ebaba2352c8734f318f1b8c866c73a6b0a878c64727fac45b98a4cf8d188127cdcf812b04743d6c0b6ee57fcc851ad5509f7729381784df53211873590c68e512213c425d27170c5891e1cb8e950bd167b67c5a7eb5f9e5193e386978b2056a3909da73d9ae3dae8c6f394854688ed74b980a0a6e0709e2144a9174cc7933ae7eba00b795293fbcd545d8e1a220f848f5fa9c6f058a5962f253a647fc2c0938e41c517b0b1c41ae7b7f90b2369afce55b64ed8b26289d64793f04effd87219f8e07819347766fb3055dfcd3cbc7543fce4f8cdc3d7cb3684add86a48e1046887fb8115b58584d6580fad2bb0395f9dd0b0c284063237ff265b3b57a698e4a2c8522fa3a3c58c945131eccee3dc089094299b71746ef573e3fd47443238b12598526f78897c721330283e62625f0ea716a889584c9db59c783c25555df1dce28c425ee581016d81a9cdb54d187859a30ae307b920a558f6d228e3f03a5b5ad19e5000d1faaf6a0d9d9d4bd498a0b7db093a3e3ea1043399fc0a15bb1b19241d4a9b9c534b1165f6e077fc6607a3f50c43ee29a698bf5c77923d0a090562e02c85ec6cd97803e34dceabf8d3e86353d3e875814b8c77ce2f57749ccd7c55fa8365e488a5d1b14afe3077a3c9ee3793bbb1c437356c934b2c112c2743359fd31d8f334aa85772ee8401090926ed611273c3da05ae57f8b041d0618a928cca67cc16b620b28611a118dee4c72316a739139d46f2ed482970cf1ce5f4660ed73904f2f14605f527e1b1cbc098b1b2f43e409410c40bbea8d4d91c13ddf95b517dfe2f139c25b928150199d5031909b015d9d975fef9aaa24a6dbc455d45fca9b4ebb7b47a3c6543e7548708d9fd3ac3d4143203612b817f1408052b36050c655dfb1eb48a55857c7a54e3d97d972f206224afb74e9acb710c20899cd0d9f34cc3d4fa51a3347a852810bd30c895a3691f4323e1a76d794de08614228273d74fed1646667edf3a10ff71ac31662a5a52ef5ce26e330457ed99ed26a0f94ba14a412afc578a799456811f177d9d642c7a90231959d2f324bf948521a376c9bf304bd3f59330a965c458ff17f6dc7ba7625f86ced607b3f95e607178b8444df71697ed8f6dd9d807977881bc05d0c26579718abbcbeee26927cc8ccaa15439d0c5b8f818fbed660c98876f00d96fbca7daa4fea87cade97d3873c8c416f5ec6612181a47113cd998aea920d75daa418ff31f7a8b15f86d5dfbddcc9115609f14a827c76c2b639f975be4c8f97d862b15891c8da02a56c35b6fedd783bc276b489ee45e14f5b6888c608a95bab14d2b1d3bb3e338159b5a6012b8c161c0addf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
