<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4542f0026a9ec4e665c1d3f6659e00b9b923e7d1f9fc2d9bcb1ef571f05b0a0858de66c16aaf169712fe9afefaccbf4203134ae523860f36b059e97479b0cf6776aa755fbeb59920daa2d85003dd97131391df05fc4c8aea3debabeb0676d07fd188ea4b32ee2a5d7c332a6a830ab587d8b533e7b1aedf87dfc3a8e29951640c38de64781a3d2c104a16725aab46c3b4029c760298968d0fac953a5f678dcafb59ed42be0d879a9c437bc4076d9da8bd3cb8af6c5871050b9c917e64d11aba28eeb92aa4d2cdb9763dc35a53a0720197698bc8568880c43a9fb9a4dd44e9d04d3a4c5abd5ba309ef5ab090a118bbfc2d940e5bca0251cb845a6c1fba3496f060e1d55751d6990db305064fe6a0b40b6863f9dcc68b5c448544f2ceedd3920037ce36e4a457bde5d452598690aa4100560c245a1fcaf2ea6bc5467ffbb8b48179a3ae2d7739cb755725919be39cf3f3ebdd2f0f0a4d7fed7a0fb0595ad6dbcd0971ee73428b752cf570a40a631c3a10e2ee98f4a2fa352692b2aab7cd23cfcef5c9f5cb78938ee4ea53ce3ae2c7db8a9f1ba08a8eac7345419c5c4d14dad7da2f55e990374ba6de757eecd1b0521cdee874e0d3fc4d168a67a5896afcbaf45d0ee3aa07784597c2271c9982acb3717dc43cb26431d425d767761569b07cee129a79a3330408c20e52f6ea63869bd9d3ccc3129832e5b8f9246e721efdb656ad1128bccbc13a103af830ee47f8174c7bf56d8dd4312ced14d8707080a024af60ce6a52f85c0ae996dbe596a7d800408838f36bd2ac1f4de7070104de111dedfe3c0f5d419674cb5bd5737e294aaeb5fc1d2d33c493da5ed19abccb7f38c9cc3b1525f30cee123d1b36b3234ab53752065c1c34604dd5473fd9293c9c02da504064af5188ef16c7cab29d7e33b4fffde968119a20cdcec1439414b9fa9c86d60b11e5a13643ae8c48a80dbbf4f28a9bf68bb39fe844a514717b6b029ce7bad889774ec7cb8f068715355b62853f67adb1a742c81369976c0df19f3878814ffb2cff37a742795743d2333ee9ef24c3517656b986374b7bff680385c8f04b3eba5a68dd4235a2895a4459bd187fff48fbe8cbe8fff7ad44fdc14e24bc99930653cc91cc00efdcbe0d787292ce99074b5dddc88637f3cee137a4f1b7460f9bf35d9205ced024ebd9ca2559d9009712357f9fae143e4040c95f177a0bd0e75794c3d2906bcd76abb22a1f036317ba7385235616b40850862878825314f6199d017525908c77e4edb1ca50801fbe55ae13cfa23ca092b3d36b49e55bc835f9086afafc4fba409cb79e9c952b5d8cc2da7ef6868fe596fdd079061f9eead36a418286d87d97a9944f837a3fb4769ee07eb143a13ea179794a1fe07a5d607288ca9c0a3d9cbc4bd0f78b72fdfee34365b77dd7ffc33ad4c19164bee93d7ff82d345229d89853c01f0ab2f689ccb329310b8c780a606ea44382fa373df6e423652b6805142a569fa4722965d797aa9beb2a6422c89d6a65ce02e0d1523e5457a2b2c5159440ed101d9345fea941b56696d798a08b886c31b89f0bd18905647b03e5c9034a1d458b18ae3c6ec30c060a8c48cdd792a83b27fb636b6f89b85632a05aa7143711ccc8d4c6d440ab270e598b95236a79f2daa38a5f3416c894b2970a95274b336be9018b99c71e3edbdbf61916df388ff51188a5dbde24ded9050456f500c1624379c7b4f573c24e91a1b64b5249309d52a497f6680c49852b54079895cdf6ecdf781054397d019000d02fdf3caa6d3c38af2b56604e19b38aefc2f81f83af4354670b4ebc135828364e9b782e156ac0325a61d018d5987c4e897b9bbdd317545274cc868d4bf8582a9cc1f77097424063e41f33b0e2b13b5c580dfefb39f8e54bc7c41fbb0401e32385514b3631c89e7dbd279ac0b879e1136a6975e59267297d700826b36af60c8db935f248cdebfcf81d0a1abdd45f3935e183d18c0250fa6f2f6f98b7538b7e416e9dc6d853400d56c9c68d60e9264c635b6f95420828de2038c5b7ef3723dce225ea45234089f3f31aa1f49c9aa3c103838ad68c7571e7185eb6984e96f29db119e0ce23da8566cdec4864c81597d7059fc4f7c11cca949a7660ba1fbbe24236dbfab5325f1edf9b824999c1876b965ec9fc92e407e842119830229525c62e3784bb3e2b6161af241318b05dc419112c0cbdb58ec85d58420a054558e9f4951189aaceddce8bac3186d23be0b3fa5817188419295550dccb28c6865c70730602221353aff885de6c6acc0c118fc2339c45cb7a548bd53f0a6a64ad3d620331a4145d420141b04594ce0e7876e19fb329065e43e8b83ef41164402ae8f98998e241bb6f32fc522ce62a148785d932da7e1cab519fd64645d3d27e7b3ed3eaaaaaf6822246044ca45c0645e600608351f9e4cc6ab86959896a77321da11b2d2365828cbbce47d16a7debe8f219ed774bc32608a98d30d19898ef1a93e910ef5d7b1cb468d294fda147747076e4e3ecc18aed9b93ae0b0fdb57ebd7881eabbc94b31b2a9fd64032c21dbff344766d5027134c1b3a5fa6d68747208eaf2f976340d97a744ea6058785b3bb6571a9f15cf9cba1e15a020b044e0af8d7940330572a0ebd86c006cf399b047db7e21e5190f944792c4226eb47d631233a3d87d883dd7786068bc4548f1aaf4b13727b08fd06dc51a920fe3572cbfed9cfb887e64cb1802a639d58b35918e1daa4cb0e871eeb090706ef72dc5cbb48341e593d36d7e5d879b5ea1b7f7057f25de9802b1e074823b86d94d546dc1d80d1d0c5c681353b051bfad782064621509ba235fb2a337cb98293cf22f6598800ce1d6c55fd58da09865394523c3e3f83b544c12897dd13db45ba76e8817496b99da769679cd9f61cc704f1e84e7d2784a2f37650bd8b4c0fb0a85b1c4dd4aa443f4b47bfcb8bbbd92ce540c3a719be8da6d9ac7fe5f91107271eda0e20808f9dee8e063db6cf5978aaaf807eedd201790d405eb27d4b7e542cd211fec3736f7c7dc6f97bf00254d5b0da4cc3b435886140241ba4500b0514e48846063f42f7329432970b00b2ad0b600c8823cc4ae71d7dd2fca831dff4c5cf5b8f1a600c82e40df3e5cfc9973f26a728dc24fff5473b4a2e51753391260ee5a55bc4c0144e1e7e37bb4f3f3af5b69686427d885da82f3b5503d2a140dfce1d6d15f1b9125af8f7d32cd9413ec5eac3d999bbc4fcdd4c9bd43c259169ef22aea1df58875e5f6f969e645eb8ba11d86609982c56e5eac7c8caf0c7297dcb5a7e0c17eca38f374da2ad5521fa090cf324c7bfd20e245dd590f934983b9122155833ffc93b88eff30c50e045622c607be6d89aa5175d2320890405a8941778129ac425ca44e08d05241a5bb53945f1dba7acfb0ea55646bb5734fe6128242e918c5d3f9572427dfac5df9df150d8a9ad0f2c80c28217167598dab73537f6005c6e528cae3e797a64a4f45d84170ed4c5f31d11cb00a5d916825ec34b94e0902f603d33689b062160caac30f699284ba46ea65bd07217f0cca3e3149e1b06a35602bc07c2cad1951d5dda1fe565dfe64cb4241734339088e24b394339d0bb3839601b575cec75d2cbebc01f126183c2033af95e87a50a337476af82171a4c2373d131944b7c5fb9494fb04d4d0177eb32e99a749fafe548793e913430232d16a3e5d9f643732867f5f9bb0ca149b2a349dfaea8a59c48471b99bec3a79547a0ae0113e07085209acbfbea91fe55a4044d90098d2bccd6af47c085a0a4b4c95336bf4ccb437d43faf79ae004d889b508cf4521bf3842a5873d34d43dca1da34ddaf434a17f63baebcb366e192114d420668b73827f56b95c551b62af1e461dfdf3282e06921814665bd81cdec0b18de4e60724ea532a78f4e1d5e86bfa9146f070b0fbd22aeafc15fb8a6ab337dba06f90c07f6bebf82f0b9829224f0bca76d96abc96e1dbf58f3e489cb4951051d66a3757cc9f01a60812591f780fad0259cde53d49550353a37faf9c5354ba23af0122c4d6b7d0cd9f3c1f905abd60c5561fe9b17b87239a4a6b270dec67134c5c04a297e722840530375f046acf52cc17b631c98e05641f38243797534c2555554965f467913a9a7f2c35d5382dd9d0b7b1537af5ee322c62d06289de0d157e654654ea78b1725a10481ca94085df705853459a79b013b728ed7895e13836fd1f7e352e036f62df9c8a8fddf51f4a6cad0cd30b2854631752ac4d039c02eeffbe2f87b2749f8893169529721363954e18731205303c6b50c07ba2eb54e9b640a6d973433962a9cd04f02ff6e9aa84a10e12b58e9974f72ac8065d971b31f16ba188b9a978546ad57ccb9f3c5a81a385c8b7fe39b5ceadfa6bec6af286919df8058665fd3f16ff67953544f4e1231ecf04a0420b916dfec01e839a15fef106ef2821062b5909ac7935805516e5a48f59ed3b35505e65fac39ee35e70b35de451f028ce25d4808b98ddee0af417373a9ae807d62cc1df85f12fe7edbbb7d4e3ffe6a75ad2269d36b1b1e2dd266801e5da38de97c6d91302eb92550bb64e88d169acf3a42573757d22f3d152908f950fac8fdff833ae169d553ec279e682125ab660b12dc0cbcf53566e9d12cc27b9bcf0c6d99fe62bb1ee439fb1a04d0fbdfad8eead8ea87e320e6bad4d3db4c05bf4ff45a79045576546e135f2754a328421cc2c57c156fb75e95a267e19d812f001dc2ac6b998781b478a7557a5a8c47e359a1802a4abcd7de68ae350c1492cd3a3772f3a26e9b750024e3fda10790260f65cb7f812dd9adacb73c97357933b7a889b4d96685f879548d80b6996783204d192657eff435bcd4d4e61187fc341d9d9558a3b6a11000e96d31b6ef2727711f711588ec4b3053d14b897faeeae7e02a9664b17a8df07c14809ae2c54bac34c68ae2ccf0ee40962c3fcb41a3d31b0f474377c7eeafb8fba7954e1b543c047aba112f2d5abefc0989688f742af0cab4dd3d540df3853c15d3fb0dca37c4796dc0c753e7e028e0cdd2684097032b42d2607314d3638e096f0193f433a03cf59e79b1301b770642dec33f359b5c13608cd9189fd86b91af0c62c92bf6c040617c2475f0481b3cec21e37b64ce19e0dbb27be1766ae655ac232195f2e3ebfed57789244507661e9f6eadf7c4ee98ea3b5d511165f5affbb9749cb7ad5483ab88281779f77af520636556ee45645fe2370466a4ec0d5ea988470c41ad8d7e9d68c727c5dc34ba15f1ebd9e315b1cb07901954fd236d40884984c6ba0bea0944547dd1474a3a44c6caeb02c60fc2d37b21d71df1969d5c0397c6c26204cca2fec78a52dab0877883ede01bd17d71745a40fa7ae099cf1665ca1c23a117220d34f0666468c90a1c728d4bbfc9f6e1df9821b22e7c28ec13198a6112d6ae3897988de9b6005da207df85d668881cfc8cd54fae5f750c9e0030463a067e4b3678b72e4cfb000afc3ac221686943aeaf86e8385e34aefc8210929ed51da622d67ec8555422b5d74dfc0c6c2ea63d45f17996af4a640f62c5cc1baea8999919560ae2d4281c50d393b363f5dddbaaa440abfb50bee227c0b9e3186930f8c931f5fed8ce6cd1b96a968345079cbcb4e6437502fa29b5b5a92beb0e61173e762c3670015ea9c26cb079d3a81696e13d7ab1fc4eefa0bb80bf426e3f0b525f2eb64a058cd238d1af0dba9332f81948beb777d3bef9c19d5c6cf53eeb35349e5d122f054624df8e7370b69fd64956b6e98724d1693a60668f3cd91bee1edfa89e41a8482bcbbe8d78223d99012fc1cd1f0120dea050530f518da79a8a1fc578d3e645deb6f5d270a3d465ab5f6cbf3541e82c10164c2ea32c085be27f954953a8522d683a6342cff4caeaa1f1d77f3afadce047d8c6ac2bea2f77ff253aac11cb4ac513af6945d7fe9ad35e363ac5d020c659557cf70dd2b58529a7a8e3591890c7fec4c983984669ff2c034e55532dc0e1076b0e65f35c777725c5296f23722ec1c2c4893450ca039a248695764a95b279cbeefb9a46ab0ed9b288d68b928016815fbd139a645bba9851a60bedbc06a409b2fd7dbab8e3c414da6b51b019b54b361d28710d65d50c05c4cf59189ca730acabb19a43994f50463d81ec2ca7fa4df77af5be40c25b8480bc125a89efec9efbcadd9534fa4381796d2363b04cf66791cec2e9b82cd789c5b8d33b8f1df27be87a43d7246489ab0b7a2de1f61e2ca42e18dafe7c8b5d6d570fb42b88f88d9aa8d4e64c055b1c263264021a36b8a88ffffe826ae11c791dcec3bf6d8201a39d910c2161c611d9da8d550eba4d011029ebc5ccd1b35ecaa557276cbcc42dfdb4c017b8eda6c3854811ca40d8ae9f3472b84f657daf57434ce811629c873d131478d6f11355e3270322b2e131884a508b67416768037e78c79a185c502689f4d067dca00c8c04c08603be7a8dc1fde99bab2b103d46a8c9962e1b30f5211136a4ba6becb5757fc605003ccc56c316170cfaeae46eb5565d5aeca93fc4c6b6ac7f36596952b2b821ddb722a04b81a95107421b21b5b5c07e811406f00d75133a667760417b51144ad2d9687254af061f23808748936d96fd79989daecb9e59861d8524c8abc0953dca93fd3a7c222df58a199518b756dbe4d069ede6232d3a1525005bdae7328bc8fc887cfd30dd3bd1c436c12526645159becf72c2ad3b34753b646aa933b5255a028be058e50f096b7f9bf616770822d6d0cf4f909c1a5f96f4e39b258d2e4d7934f90ebddd7be41faebe03bffd00a54251dc8e89f49d714763289f0494eb309408f204cd0f86af626492dc9398d2b1b2685e03a7091f69c3dbb1f2f9a176929aa3d90e71c7218cc53be14aa7931151322ea12d0c0d497740965bc91ca4266985402a7024675bab2743a0e4b449b3fb0fd32b78b383a195db9f129fbc05bdb19017a80879fe4195dba0561ffdbcfe5714f5c4b574e2a12846282c68043b41e6f9d3e3015fc8a4d99c4b67fcc1c93c3f5815b08d315819e952307e2f11706564ef9b8c2a2335c032c24d701741065cc1febdcd60656a051f67ae2a23d72c2fdb8b1234b4adb190512c31a69ec510b29dcbce82b2dba06cd3b69942d3e3ab52aa22927d6beec312182ce8b729af8da3579d314a6a1ac02655652881cf9ef2559d2aaa9756d2933e56ee1aba259b45b08bbd5c5c1b3c9a0a2ee5ba91e689124d461ab66157b5d3e0805f8fb6158a6a28a544b7c8e28ae982f2326adec5b068132aa83ea6e473faa01205bfddfde554bab0ed33de6ee2dd5fadbbf48b232dd4e95baf2864131d03a1dadc3af27636f16698d69d0cadd78f17a30aae0a001531c44aecff28b9eb94e93ef4d7c5efdb14c5996f9779715fab3881448e3ef1d7e7094f690c0b35d5c67a6b70610d0f9632e1045eafb109352472144a8561284ad9ccd5d97ffedf19d12cd56326e326c100a935fe24d3f071c5caea5892a23f51c47003c1267d9fd30cd98dd0cdc2dc8c5af86f51d930e0e4195ca19176014d2029a5ee1a8afa811edf80c2efd2d9249f3fb14df42ad3bc860c36d63d19d417550d32ca7b3b69c7ddc27e0e81eece349de2faba8b5dfdf984522ec83b365c10d11d39a8041b642aa4395e07123642b1033781e7ad244d51c2a7de777edbbb6c0c1b837df1ae3c789714a24f6493d4b7578f493097618e49dff4ddde5586ad52fddadab41f806a473b4f67256e013afe525589b9acc05d2bf653dd32393d8981b3f1b55a974742446f7ef82db7056c61df092f460b62dc43c52d1962378d470835394dc19f007f14eef166403f7c0be742e8c79afc2ef954eb3bc44414dc2038ae37e2ac77cdeddceeffc4292a68b480f7dc641f6c2655d87423044d9b3168a37d41d3dad77bfce34d55a55b1b88f5b93d1ca3b1a008ac28cfc07de2a44e76bbe9cade2b5360310193dba5eda4c125bd845bac0b9826e7b4570f4dcd481e3e19f75b933a2c83041676a683d055e6342e0ddfdb02fe7ac2a864722113c63eb7ca3e6273dead9a7f5de51172d8eed87c6902828944c75bc94d5c9944cb5a73fef2a9c330acc619f6ab041b5e4283e3d4d29a4828b5e7d1bc021c373290d96dcc0320ec2a9c6040e5f06cf348a88261a527a0a43cc5a8b374af79e1969276f091654f0ffe086047238629a78b7d851fbf7b508179464a9d7c68ddd07b23b88289efec625134db710e609175bb0727430819915971578580453bebd5f952117ee58e59f5f0c5e83cc74ddbfce5a0c74d40e2fd3b9d8ac769af7411422d929f4255e6fbeec85a31cab9d68401f6d5082fad4b0615ad9594d0b9db7c32901db5b6a44158933ad936cd5a6827e65b2f6e5d89c973bb953af70741067344f4591a03743c2c73ac4c0ae734efc8061e62b7610fa2e13a5646dd160a1bda0a5158fbff34094b21ea703c8de9d95626f6a7dce8556ae2965ea8f4d13cbc71713725d6027ed966867d046e2db38dee89035792963c1df1a14f1052eeb43300888cea4d602b5ecfc2706b24537cdfee0dd07082097a8a98d19fca0f7bd0951730030b9ca46138b63088ab6192137041882c136ff6a47d50f4ef8e50ba86aef2a23a307210347ebd7bec520e1d1278c50e09192e8b80eaa1ed7b215ed253c3cad7be9957d0edce789f7bbab8ee1be7180ea7ce7a7a8f510f2d5e5c4838471bc4dcd008fac093dd0abb028e8aadb6fe8be308842c82fc5c37cf38992ffc46eaafa8978c8d44d7f370238a68bf270b9d76323e5cefd56ba0ac1e5c90c417010baccbe37e07b1cbd3ba7b0d097a2a5459ae48d20afa6a2bc0c5edba94d463ffa930dd72084dccf7728887d1adfbcfda0a03794072fda6a943045a3a36bd4479aff9c4eca3c9380196f1b395bb39d42c3ddb42b5a816308c081c64b12f7a8ed9ebaaafebfb9c1abadfc6367c4d082d1f4ce0392913c0a5ff04ef02926def5ed5a04ae1f6dba9262cf3ecc933395d653b3ddd0d4f3f71b5a11daf101f32a58ef97b27b02a03dbfe71191bbbaff80f8cc83afcc471f5431f2bc6d0c9199fe5e04d61813f158266296ac5ae9956ea4897ed080886ba5df3dd58e35fac5c3357b5304ff93a70687d9cc12c15618a72f95221c6791022b4f8bd159bc4eb41ee61b59d6e8f96f24532eea885a83ef74b9bc29cac4baf31d7b4319ccb86e5378c43ac2133a903232ffce6134d5f87eeea880658d8c43d35274eb882a0fa169b83e3dff2ff202510016990d6ca1033ffe8bc353c59517cb03221fb5e34e618853f6d164e11a4353520ca46d95c4978fe8c4f6d8e94964799341b5b7cd01286c95e789433c1d08cc2c3b68b19c791c4d509c7ce1a3051b1e6cc3e73fb683e110bf71fd81f1a306665c9906bb7422cef9c37c10241e1dcc64bda78715b2b19a851ac97dadab369fc567cfb5bf4b1ce8e9ac707a712577f3d3e08207d35a100a9d4e5e6489cb4ccdf9dd79ceeac9b8b076afe7272531be9fa07bd428fb28a85592687c250a6c89b13419c5a8b7c836f1fac14f11fb44b5d256104972f797ff0b3ee129f2dd15c13bfe58c5ca52d09fd68271adf11d20ee08728c5521800457d29d0f82354207d6809e2bb78cbc858319d394f1e93bc820b69d9cb44cc9ebf2c829a72d168201e30927a84059877f9859f7d64cd4273757919da69e4605826e779e675354fa3f4bf7795d7810d4f075b48d80d8faea90c4317a96db72be73d8e8cf6a6f25e718e03bd977f87ac4a587fc368c8d9ae82601a6467cd7d1e06830d27a93d54d255b6b16c7cd717e73c4de30ba0ddb24d095ae137975cebe2692ca313dd68695f070a21ef21d2ca7137b8e2e3486a8a7e4c27bfd003430f06d7781a07cbde5090e0d2b8e29eb854e9a1b1788177cae874dc91f10dcf0852b2f6d2e24ebfcfa95b543aff9a6b8eae99bb08731a14bf64c1e7f596ecb8b002e61040bef58d2ef3714c2e1cae0b19c433d41f127f6c68566a57dbf618d4ad9b089f3d33765f4f562dbd0c0b6ec213de9b7befe8ae523821f74d0d57d64f74116670c56ffc34c58ede97d8fc8e381536fa31227efb15444d87a9821f5d31b6b23094b8566c7948dc9bd22c9a953b57ab191009259867412392732e12bbc86a045b7afaed71e90cba3864957758f30b3ec5c70f9144c1e11dddd310a33c748941b30f65ad656fda8bcc841ee21e99588f23f63df3b190b2581ee4c49e0a79df8b403798eed0d32df817f0257db52b3415743981a43d1e1b1ff4cb3db142fb7863bdf100bb1de0237383b73de6f33c9c8151ce8e8adb6293865967e827dfd327b21032f62e1db3d5307ca2c5b51916539dec4ad5372ab95fa30ea9880053ce090997a923e3258a3ab9cf0255853e498a8c3411f2ff97a6f0e835b9729d0c8ebf1480bd79f5de98f76fbaa9853c53ef68de059eb07e854e81f422a96718517fb4fb520721ea995934093161a7567ba2abac96ebbc23b6d6098726e8dc6d11e425d2765d463d4a6d2191a2f4157ce3f7eb912284ef970bc57319918cd2d37470acdd9bd87e95253ea9b88943454b9923da41ba12a4cf0ea825c438596bf7c8a95f82aa23795b7ec085571f6aaa5435c2f7c6cd97bad784379fc0274171754d56084b64190a9a8bac3f6b77ebd90e48793bfbfb1a0af2f49808ab0b2d391395b533583a6d6472923f469bf2103b6159e945aca823a6953ede81c3a1180e08d367a9829c55bd5e84b0c5db1e145bed2536cf87b3b37e0f1c1335fcf5fef6ecbe3f7c60826240625f349048f454120eb35a99ecb0ac9d09bf0a05888a1a4b8c8f32bc2363e51ab8e422d7f6e28d6fd8e5ea8584ecfa92f4443be83916a40b4ce0d4c4b4f87df9cacb798708507d175e2c78c34e5994b793e85dc6d63231c70482ab24703bf235c08be2e38bec3c8f39240dfc17442888ab93efec0ea92d4aa74e3950f50297735e2fe846afaa4e9907ac0c6f258cdb8cbc846dd240e86394731ab827702d9ef73e34cf4b3d3bd7ea6d89aa108ee20ca6ecdcb6f5638c8855d3100275757ccf7ff67ca1c3ca3e0aebbc6615761e1b4c87a69a4ea9d3c129713ae650937a69a08a9733eaa2bc752cf32cb13e542c7379c503ba872e1bce07789168ad0b69e42050b4b511fa653fb5cce1babc1e3e47f435d00e97086f71696071a3aa8e6c4eb08c9e85574f3a47e197e59757afbba71db49aeeb41ee12cef4468ef4522e16935b99365876026ff03247c4598dcbb7ef088bf325b31cb84a5be82b9825cb99fca33291ee01e7faf60e43e54e09426df50256d1ce53046f1def89414edff51f78ad6ee090915ce37ff3fd0da5d8c3bdcefe4cf77831cd2a8d98eaaa0e71ac3a4e1993adb3b917604fae0a66c1f53846a993c99f4efb9b7461ec1e56fd2268e2270b67759f48cc04d0eaed34961c5198513bae162316d063907898b690ee19972511f42d37827a91f041a92596f05b08ba5c735dd401fb582a5349c25cb15fca02e43ed745d823a561de659801ab921ff345b855406e2a3a507ca1e6701d5bd72fd237020a933033cc69ec8bf5966b25f6d36d4a39aee262f585a23e8d17a42922c108879959e0363bcf7956bc7018f6c610c05f8e70d2fde85e82b8ad283d0ce5d001a80cb50440730e90d00b60f0d0d0038f9c5b7a8424730c05d3afb758d2f781c89e5b61bf519ae3da6f347ee9a8f6ece8672a4f91245527749718ceab44b00a3efc00a7406d84183abe9f5965bdae2508b2ebd26d45ddaea0b77b89e854a0c0f3bd2db27ab23d5673c229d7de2439a102d4542a6e9be161bbba5c582f20bb1205460f6940f3398e83cb36f9545c9d4bb7723fc69320f55f19985300a1eb4084db272c18082cf2d87f8c3ae917880fc956324a5aac701a6de67051530e0974e33908b3c37c1d552de8a291f73d30b1bc8704fc05d288c4c29a2a07e138f1da5ef12459c8e975114b461b2bb39075e94c3285fc96f27866c4c9192a35ea546d50a39439e78a235bf2c1702e7c139780096cf975bc2186f2420c5f19f91903f9ccdbc0fea5a306746cbaa646b12a225de4cb4d2a23e6d2e63b6874cb686e3225bccf7b16421e290779ae6f5c5b332d6703448eb592d90732ae1737cd7b8b777f4311c11888d78d2c101c59fdcb1cb3edec78c21d3f3a367e7875f9c6943c502d9b7b9433cb5e14de35bc7d9ca241786bf4f1018defa7fdb88310054e50facccab7660e1a5a973a97765f957e46d9cdc05b04701f23a81ebf11df15e1f1ba744506aa51765ab0d62e6a852635dec47cf7f31f4f736c37c44855f9f3843982e6b7bed7b83a8c45cc5c049ce6a4905fac928d32640a5f0fc45869c9ad288fd9bfeee37a529381be53c1bc26b4bac53e24d3a9e3c3ec79c1c12f03c5f8aa5198b2c84647e8ea72b981c3161367cdae6b2574ac53838598736e34526bcac994880c03c3da6db5b102282770a47deee688cef5780c986c3f9fdde46fbeffefa446d771f0fafc5337cb05268e092460ea389673e2fc431f47b198bb1f9218e00437a5807067858c139e79f375df423aa2838844532ac779c5cef91b420126932747a9d6ee5e7e230d0f3cd2288b2cfd20bac2c4f3dfae812a7720c377b9c27d2bb1bb3c0d53e05d7fd9ce248bda970c4c2658666746c131000e06a08102c5eb3620f66f07f26c79f5a39262beec4d4cadc7caa66ba45e1cd372af0b2b5a183ad90c8e55d2323fbf00e25b80c2b14a9b75b608a3d63938376906c4c74c84c2a130dcd90ba5f66ec78848e4aaee486af4343df0307cedcfffd3971c5e7c8010258fbe52302ad09f58a826ed763b040d3d6e577b76fd7d0c01a5409246330e41865921cb557205be8f046a05caa5c12b4369da7c862feb94ade3901884ab5f8b00e60c5848702ecdf366d060f7649be0918283278a6b5d1394ecf1a585171f9436c922f9432cdbac3b7acf23f43207071757b08a051e597dcd54a24660147fa60af75a0ce1ec8e8efe6d0d073a4cacef1110367d50937bfd64f2773995aa5a3fff4d4dc34d2950c590a55c98c71b824b6958c14a6eeeb69143cca60aa9cb23a8cfc9272e3bfa3ea766ad158b698a6222afcb3c66a5ff3a62f7edd4b1b4619ed3b9cd0cba980a6233df8ad2550619d332f9845bb4de53353cd84e65e9bcec99583293618d320f676beea0a046c25e9913b41e24f456f2118139282d07279e6cc8d59ae454465b2d2accb8a369cc3db3cf3a39e994e2d9b227fc9012a78873cd0f2bb4cb119c24e169cecafbdb2ce11e4cf8037de85beccee687566d61d167be0f03cb39f937f0c445080693b57616b803240a9fe8083539ecf4ebf65ac0c90b4a32b6a62b59744e410ed61afe3d460b99dc77b0f65f4c50671b35ceaf0f26ca4b42ef6f207d3eabde4d9f269e4869bd7350096b2387d058f0d128af0b12e879b0f4167965c1c4d4f6fab69393c33d62f74f37095581c7f2cbc4ba10ac0c8cf4274d2df64e45f56c20a50a0cbf28a21d148902b6fd65084e00c7a69b439fc1c22c3cc33c883dfa9c8e726f0d5436f2b4d89f29f313a140b167be799b4f8134240975f8cabd38455fc1f97d6c94c82ab4b057019ada9aee3835b955ff1b710cd299bb4723b5fde54a04c23112c37bfacefd171ddc1a75b33158e65913fb3c98ef9bc53eaece2edfce640c953f1fc88d9ff050da34f45f60c686ee818b770a03d44beb4f1a0f5c0f31d802dd8ddbae2ccd53ce8a7ac21cef0037af9934ff2604a9959650b1c93c7427215cf8eca8d725691a9ebeebf764d3d3e957ea9409000217d242ef882ac253d42e76eca3f9b2f9933dfd397e95ed270b31173a67e7cdcf6b4769be92f2a7d37c390f4e66f1523451cfdf498403a9dd2bf3e45261c3a64f3edca5f3fe01d80e14985b68c756d92dd61bfee96a82851e4596a6c1f74d86e53d87f13da2656119aaf77f20a8727826d0b56619301cc92c05bc830c7279387f929e2a25b711ca3e95fc4c3f046c6ea4f7827e454fc10b9db8043b97207558a82b75fa35e75f8e24b61b5f012c22c96355a538459ee15ff85de5c586ef776eab1a415ef9057db08be2487201ded2f240c081090f02b45afcae1ba45143523e6b2a185635362d6f7638e7c4af9d7af6fc4ead0c17a01fc937c3f452e122768a427e6ec370e31af5a1418daa95dc6ede9d362b0b19e1ba20f26865fdac921b370389543876391c66cfb2d35870c5ee7faf1bb8867d930aa301628e49abae8fafa97cc3ef9dbd7f47fe55f187a3256d46e69d57a1bef9621f996e5e2472a182ef5d626e1413bcdad287e27868450723b631dad62f7cab2db3f2bf8507cf9274d16e1cc6830ab94b5383a411e86e18dab75c4aaa41c114234179e32c952b60beefac26282f77d8bee1b7d24f3b0bcabc841def0083d79b333eaf4c88a497db4c28c05062773b0e88d988d57b5fc439b0eeccc60d0436a60bceb25e6ae8745c92e2a292021cbd18aeddc22e025cfa2e5bfedc45ab28f132a5ee0554ef3b435a86d00448f1473f7c5dc309a891f13637051424f8dd31ad8a9c921ad9e0e1fa17a43af4b115926877ba29fe41874c6330e10f5c32e5e328961f44b14725d7c941854df827d566ebb7fc1a89fcc576290601c53ee1b902cdec87ed80ea8fbcb316b3a66e4a1307794f25bb3785ad75c1cf46577c6fbf7e7d63af781d07c8fafe3e5949086d3e579aecf31513ac6a0af8a93b0d3255fdaf3977c1d207e8a3b13ab2bcc4ae0f37f84715c15250594db7d9ed17803e8bef1ca5613c57fd01bd7c7fdc19e5a1d81254b455ecb25bf33b59c476bc291c9412bad5f276663e577ea9ace7ec965cc2e774a230da623a980b48fd9c308a3ad02019ed9bf80c558b12ed25277cf0edd6895daf8f1d349ff446668582e5da55f435e1254d80536832cc60d9eac35648b796a769ca450a81faff379f93b2bab3b8531c6ccb64962922f08abd3fd1e7b37c95849d4e6e8473ddd3f8acec6846ba52652fbc2febd74c4254e2481735002af60b2ee48b7aad76f5264877ca06b801f9eaedeb8508565eb7c66dcb1b2215e2024b422d3842200899e2348283d9b5b68a6511c2e0774622805a527ca48f594f04f051524862a281272387d2c4393f367eb25d8fc3dcd1676f25d9d51a92a280331ad4857efcefddc4d0e2c229dba4633ac94d5f8e8efd0d108985737884bd23f53df914b3fdb0ca13f417753a5c283cbcd175787dad8b420727e6923a3c0aff933e29034411dbc001754d61bc0f4fd116cc83af66d7429a6b1d3a2ef7c9d25bda55747eaf240c47b8312dbca3724bfff5a5734cd3669014fb48dcf7f895120e97639960ce40126eed0327b5e40f38a5afa6c201723aae6159aade79ba8526a3b0a2140517099e5b23a6881a052ac52d25f8bbb581bc388aaf38e4a9d6b4789e17072b87649b7bedb9d89b82f6dcda88025a8477cfe062d9ba40a752cea439f1482d3614a5bbe1568d23c9a59c0cd20848d23927da0bc6a9f0adce1624f1d2037c93094d7fab5207eafda242cb0d1f89aae7df82f31c57422eb39dd66a8b60cd5f50551abbae69ca1f2d36becf30f8dfe5e0c1c9d5af4ea026e2f0e3488e12f043f93a4961bdfd95670c2f523438a22f6ce0f7e55c0df3a7e2e379288ab61957f085b7ee16437eaecfe5437bd8b7e0b560a5d04abeaea5b35bf7b8a9fc9d86d72dfb52338a397d9d6717cd01b878f553f3b12b3c74cbfa399a20a120314da5cc80644a5098bfbe3975fa6c61da09330058ea5590efa5313a1d3683d6919e47b5c596b5c5648b6ac3732675f0f4b2934abe9d82c915e5dc9ba9249b891caf923b719d878648a30399aaf05a815aa7f28565be6d69bf8c3965fef0cd44e08f400df718d7efa3804fe6d5e58288bdb9d36b4cd50f6e0a99aeff88c91ef48ce7bc34695bdd2affc14a5bffb5217ea653cda58f2286e4f2f9dd3f15ccc443ff55539685a3fb9bc3ba409a3111439d2d406a73da38dbb9dd0c47b2f243f87c00c25da76d1fd453e7504176a6ab66f38422790d63b0773f8cde6d39c5bed8e5d77255e2335f5f830ed3f6cd7f5b6f26b1ac4f384372dece81b1ed3960c2f38019f8f9d76ca8b143d949beac633afd31a52e6b63f5f56763a168e7cc1739b89819a62460a6664223170d1ff997bb62289fef731a7d1225f000b8a336b68b8f9db9a40098e796cfde2cc2592e0a9fb9f426f0ff8bb7e345f75ef722b71cc4680ef9b486987de1b915127c5a20aa9954210a96a7c85b501538c0108305f48d2edfd72de635e09f2743a3fee9a0e59694c5d0e659a115c5a46d85157a9746081c76503d05412b2983a03fd0943c3d19929ba4b1d7f6b2e10450854668fd088b3490a9a92833bd31fba451ed9e9fb1532e7836f078bf81d1362f29b5e0ca10e268f722eba8e9c874036d998056b5c343ba4cce14b48f3a2279d6a0c48f9703a4a4b775a8284d15ecbfc1f2a052f0016dc3382870f3d98f8e663ddb232fc18ae6fcb4688d3279eeed094c7e64b0635a9bd44ea4175e0db25c92045e476b2e22878fd486f844b1188a9dbbaef1a069562e684f170d1ae633493f1280f6888c307596c59a9ad7991491a87bd9952bca0e220165d7f919652c5868a8acfd2271d4ff253c7919713050594f4ccf8e3fe9bc445e16fc352bf93c89845e298dacbd56bba014fc2f2a07f8a765551acc0c52cff30680c9d5542794cc6eb90e8e86c62ce9ce35c3f488bc6253cb8a176854d99eae0cdb59b636a89e1a97a42ad77ebcb8384df9bdf49430bb930b0aa534b6cbb6952e8fb53443fadb6720362c3c10a219d66c1c163f89bc2f2331ec5e090f1fc91fd95995e94e320bda44220da1994bc7a849012cc2ae870d229fdfdd7d72fd38ce18c3e286dd08a28b4fe85f0466945af3dfe407fe877e461fd33cead07bffbf6595553173981b510e6ec24c83d0ed592b80815d4c5ea38e03e034e12bbab098b35c4fc85e478c9446b00a57cf111274dafa1159bc71743bcdfc5ca817f0917bc3235c381a74c85ed71ce6c62dae01bd8b0bf87c55a4d6a7373b7022eb37ad9cf55d463a8ac738e30a25d69a0b69a71810ba180bb9ccfa73d0a0e4a816505323db619a28732f3ab27db8755c48ee7310649861092af0c860e14dc4e9dffa5b1d736e2d87eff7f682c6b9733244389a642a888c740ae2501e213400dfadfb2f78a38e6460cdf49acd7bf2d68035a018119d45c58785f163c71a3b76b1983eff1e475ef4fb0dac456c2b594585fa687a41e62762f995ef65249eaefe0dbf76202fab66d1d2915a76514027e1f277dc1657184d15e54b82701a0d1e12c8ecade9ff624543394b23870e20c6f6654ee82a1fee0626ec27d83b1a9a75bee50953c1fa247bc82952490289a78d50e6343f3514f668be0a5dc1810c9562e6d6c8d7e07169c4e3dcb3695f05ba5bddde6d79ea6e3a2c7aaf8d9005526499bc99822607b27cba4f120c36b570b4306945700a85f301e528120036660613c1e2ddca482109095b4c9e45461a648d2b77de6d52ce81d2bb7f98e56d30ad06728b4704be2c93dff21f4d38565dd8f88f98ae9c59d39aa751ca223b354a4605813269fced54f30e7285f1663cd95aaa44e62c5dd420f0c41fd8b455f9eb0c4107a2c8cef8d6e9de6cee6ba77bafd1e98032995af068cf47e0c302a5f8df1cbccf6063a66b7ec63dbe6b2c3ccc1c8aadebc4df88af22318cec0372463b6697ef8fa5ab72bc112674ec9334d8385dd64872e0823ae357eec312f05aae00bdc2f97961e4ff897fdd4e20bca05caf5cb613b02e0ae3bbcaf21e6c2255f6110eda4a0f83f9bd5a8c3a8d76789ffb6597677c525192c191d72808e801354c57a2b6d98a09097ce13166e4ad8511c310c0d5360743a8b036f3ea1d16332b019571cc7f6442f6437a71de6a3c62c2940c72c6cd9a41c3b9969d64879541cafe3ac14f46aad499700ffefb84d6607c46542079d1f16d9ec4d68da9a37c2cc7e59ec4e26efba3d9c38c090ed1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
