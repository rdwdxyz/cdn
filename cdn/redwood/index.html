<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88d32962b5d5ac4425a519d31428575abad3eef443d2351e9d5fd08e9b0fa3a1c852f008226d522f8ebdd5673c4175fa86952baef54162004d0db144a376e3c539296a8530c60ecb81eb60201dcb06e824c43c5e3e86eeb19e11dd4a30fc714481854bd0cb7919c6a2665fb387cc7d347c5d6ad8651b7ee17ba14a68fbe5954fdd922737b250525fcb30a3ef6a407df572793883fc235f618f3e6bc5d1f1090335d4c4c24f4095a2e9e3b429041226b66c23ef1362d4adffa7ecb1455ab9182fc55756bab7b7edfa418b1864760396dab0748a39077d4905a7698539a64eb4cfcbb5c3b3986d6bb588f825566d5ab300013b7a0303fc1858c7418de86833f4dcf92ec4d1c732154e9c6e00ed351c05d3356cadfe053a73ca30eab3138052db941050e7e201e91c3a5b991935bd7d5f7bf4b7dac70c6689adbb6e28c5193c7d45b07e9ca0f45a461c684fb0bf7ed5463b94ac74619bdc1651819e24f1cddb21f184252f6736b9e2ae06a2e5a3b7e731a07dd2c54cb4a2c18559af4d01d41f3fd2d438fa32c9d0151495394ea6a272f13693d12763704abf00b1eea4b5d7eb9cea0d1198b9ceed1d18a33871b882ca0517d3d13a2a1c5602d9f4b779ab732a5f00219e818afeb06ef36f63b6b476ad32fea1b7b850e214f1769e242622891961ba07f4633f321645470850f80817251dea41341fe720c078a35149f2344161419c0b2681a0c36ae01a10ef90be4e4791866dedbe2341477174d9e21bc27faf40c532cb78ac16ee66d409414f8cdfc4e6425436bfbcde0e11f1a3ac35e26f47fc2de67a2f6f846e3348dd7fbfc0000b66fa976e210e16a7124478803bb21298e1e94f0c8d333119383868b4c397e9b3cdaec83da5f676248e3fbd61803176bb65053b350fe51e0efa0b5194e29e1fada41b5c2d44deed68959bad7668914388646d46a794b57d7265173c682056de917646bfa79f61d6099ffe88be48c3cbe9b9d708a34ce12a28c270d981cdd17563647f1565df14ffb022879906230b080bbe6f6b9cc187bffb402e412d1879723b5cbcd9c4d973c84e01e4ac7c8f5fc3a0bada8f6a5348a32849884ae9afa8652e81df4f2a4d9375adbcb6420a9c6283a1082ecff2cad6671afbb996ba772b07590a2a54773bc7c7f37712d0ce49a32a45be1462a7daca9e3b3f77d803c667bd73a399e0167e5cc07c24952cb856e5cdc1bcbf8ed05e79ae361a01ab264c93a333e3e36dddcab7b4514b6abafa16b20bcaa85706c6d87d0c2354da69caa94d8cfb1d6904b5555bb032a58be7561be2f39ba65d7bdef1fda3b7540a4d6af286b54a96d19d0b7d2f00a7ce0f7251aeaf26381ef2458da4f604b738bc0bdfd4d6ea08b6251a7b7a352fd05414584581edba1fcf73208b78acea37997676d11198fdbc85586b50163c4c6bc19ed00032fe405535c5a7e90aa41656ef0c08b458a421ef14ac8ca47376267718316425613a7faa2507f3f5bcf6d6a6a7ffd52f9ca35df14c8a789fe51076a2933dfde92f9e8be03c7b94e61aa01269a30e02df986dbc770b94ad0dfbef103abbf70d3f4df68d681c734593889c9caadfa9ca4c9862723a7f4a361eff1878a69ff00dc9c9f1085c118ffadfb271cc8d79d58b95624075aacaf8f2e85aec1b9f457c711fb16cc13197b90bd7c1e0fbbc833f11fbe8f3b4ec8651622e4ff00c47d48e17cd661bd4bb6e95d7c0a832ee546807e91a2b7ae24dfd881b065cbc46ce6bffa4d2884d3100fd3f705b0c4e4be590bec048ba4f7dd69096df98acce8863e51587124e340ecf595f06a792dcbb92ea8c10eca8cd46bc6c19586d9d33eab8a8261fa1f4490ea33609c0c6eeb8b51f91a100a6645ec0dd0cc892ac89009acee4b102afbc66f543c80b04654ce35f525cbe5d7d60cb8b09a9690ca59d1a146fb3b4e497dee6bcec097a9d63c5b4fefcd748be2eb33dd8b89c8b72bcda6ba9ce9fbca48e19af79484ef48f3600b226aeb530f542a5a190548bbd71a3b68c82c839477e081134243fd497429eafdcb120f7baae4f1a38a8236875f4a1e3e66f10048d211fb7c043fe3c04c536a157d45da5fe0c729f0674a299823cee2034005b9d8e287ea09527d5e3dd15e42b3c211e93bb08ff1e83348232d5132862b81a8f2931769bd4128f74848cdecca4c432b69071edd4df259c9194e07dcdb3a771c7c49c8cc661608025f2e9e139dca030b2b3de430aec85d9cdbbbc68867983121b22eb09b80ee78327231b4cd295944a818bd64ec9931026851f0c2f1a0ed2f7608a5a28e781f6e0ab80a56d58a812797062a393ede4e376b52b9766b781bd8fccad4bcb2a5d3a9edff107f76c4b3b19f0f327506fd5e5523b181055e1eb5bde4e375d49790ec60f5d9e9b39a58ce4b4aa3d043ce6ee3d11c65d2c5edccba8dc0a4bac12404b115be232384be1eafadffb6df320db9b8329f760ea892053b4554ab0160c3ff0119255d8885581fe3e94cc8a0933ba93861bf967680c0e7e82f969c0f62ecf816ba937e852cc3bb28eb6917adf8625e47795859cdf0dd6c0cbdf5e64c48f063aac77ec4d486611e87ad06670f5cc0c75fe4069027e1a3ee7a616c03513cce8ffd0a8e88abbc7a5f0a9f9cfc779ac6001c5a519ce3930f46150b92b23cfc42946d2e37486b58fbc1579abda07a09e6b6fb1d2dd6b1fb79d25767c7f136f2ab3d0e2258e33129af50de13dbbf1a82aaeb0f0042baefcd61443e9c4bae1767cc71fa94f896cce065984da9e21f4c9497c1e68765dc8894e2b3021c2fabd258ee8e15fcdc5f4a020146dd345137bce1fc52d05cbf2beee6998c2c85c94dc6ae8c2d17c74089caa7fb0304f9b6480fcda7dda61fbf3b685890ffa479c4f28a3908ae4d908d5c3324eedd83016eb91744801fd191c637af7359ea9378c8595c5561b7e5d2e1acedfe9b185fc6ea507111ac8d0027f7e6091678571adb134c8642d664b49d7f52ac13c37ecc4b3b39d2bbd880892b3ea74e4dbe0bd45b70496508ed44f129833fc17ceed0d096a824845a7b8ede4dfff52ad7de3c16d3d543468705febd72431831645e09c3efda36b85b07fa484f9842fef53e1ae3ad2597efc12e306f597e899883b084db19e9568ad894e9b99acb7ad7d1d81b65559479b3046f4c3fdd8f5d810a9fcf710fdcdc036ebf4bce275232db58f96b9b5e3cbcd77c04a0705b82618647d88a9cfa2ac4e3c512033e5f583c97af4794ec2420c6edf16336c1696335862d2557c88a2c219440bb4fb837174face9d28f1aea0beca22725e0cc536c95c3c3a2437315e8cb95a2745b9b0838c32f99096fe85ac86057279083e0c7ac97a9f28f933c5b6f5a14e1cceca7fd6f2b8887beabd7e1b074ac5eeac4073e26d4bca1b503320fc479c9458c77c8ad7538d8058e8493175501e8a9e6cb0e370a422600dae487671573ca976d146deeeb1da394342bb83fa71827d362023a7c8f3a4ad943f1e8fc0a7f6fa48bd313759cb6b53afd86d69a4a844f37ef2ed78371a407761df3d8da22ce45f69ead96b9ef484a3b76759610293d63b1a80199068d5e9ef9810efa8282ce3dd207bd3172fc9924a53b9e6229726bf81c02a584b7fc081050a76fff7ccd79541bbdda74af0f27d062a25719b153aeed2937e0d2257a7c0e6eef105fcf6ef88e98019e73ebeb46124f5d0b0f5c54ae1d76929eab5fc22ac2f053a43d7473b1ac363480cf2b9f6ade31506827c6422c453311f62cbf788765a49add17ad352e8ea28fac6c3380895629e6ac209530d7ac58d8b2afa5b6fb6045f7503a4f37262cedb52db1728c5e55155fd72b09dacfa15285e0bb515eecf0ccb3583d22fcdaf7ac7677a81802c7bd9fbf6d0812782a924729725d3d007bfccdd4aad1030518b6a4d70d8ea0da07dd93c108aad1dae5562cb6da030950ddc4d5ca00011e05d834a5029229ce8bab57ea9dbb7908d58a6c79b8c8b847c752f9152c79977a9169caceb6eca95db0c4066db2faeb8c7ee8e1c8fcddd2d43b8864271f0d246f8c0fe93bdbecb2f64a92a3e4842dc23dec185e7f81e0b1c1f7ca07bacab713cb7ab8035f6f48f4800ab2cac6365aa7dd1827f55ef3ea541fd329ccd5c6b1d9e6a58154954689af0b7f3aa1a10f80ea4ec744647ff76e87e313594ccd32d1203d5ff617a311c529ef52b6b349d6e681db55ac917ce27c1cdcb25263d1be49b728ed2d370a8a26a4a493772b0e07da03b3413cf9c4838349516e8c123bfce2191965838d51f37be7df4ff45cc376e1c382f0f645c7da143bc65c37219ba297727671d95f169162e57e0c176ce5e200b37fcc535b824536621c4b4b13f9cd2996b87536a69ff45902cc8b860a013fc55038fc35c5f62af3da299acef872b11694a4b1faabb0b67b65ea420335823df10f84be0f12072af0d9f4a3ebba2a7b6254183176ea5af1e17a4734f5691c2852dc3f8ae412ad2281a775c0a85da19cc3a129f4d5c8ac785837b9bf68a54029953b05bcb1b18942587c3d41754ec3ccebb7d8fdc0b6b5df816b467a303beb341eb8e2a84b807e520f3170a0340a62768bbc9e2bd0c0d10a6faaa1656c2bfa2a5c785ad751fd902a151bcd633d597bb30f35eadcfc95dbaa980a2d1c8797f98cb4d7a4233deedebe2c4aca2729e2af7ee9746a86bb3efb5f575e8a49abc2b429b85c8e12412befc64970939196ecf235d62ba53710a7fbce7b3882379e4bc31281fe042d5d6db05aa8704ba91f3e6e98afe7d5471a05af8feb2ba74611cfb6ad0b6b0db7bd3071dd43163849416ed3cb97a667e8171fcd8421d23d430d5283553d834e868202b83234629b77f0136edaa5cf9c58cacaaf4d376c86fdb329a1c340d8e067ed4167d2b1a06f0d93f851e50952fb8b8c790bb1f2e314df3400cc0a00c71697c4662b816570ed347fb3b012d677fc97cfa536a2ea21477dcf8381732ad19c690ce192b313aa501a146f430291e99bb6685cb946f7238eb04366d19479c1fd165039e4d2cea76191644e1b59dd1e03c88d2690e5774de0724fadfa8e036575a8b11d8402025a352bd4904b8d0ca6f593cceb988f4aaa472ab2a3eb2ab7f34463c7cfd86efa5d0612d36be466bc51a4380c1fabdb7fce9252d2b4168c22df662ed71e7d05e7ab08b8392202386974624b77cc1bbaf8f6a4fe312f3bb70abddc889dbe90639079ecd01a7c52ec27c70c035c36fe39894cd22f1a19725e033a5c388627630a2de453f766b6d1d7f370ec9a3572f8e9461e979e62514121e31871e20933e96cfa424ec4a06c48b1f98fa1ee89bd7db01e6209a33be49e892e77e390eceac2a4f0e6bbbf40fbda0ed0748d007a0fa023b0b5a44cfaf626d0446e9a34da38d4fea2ca9972af03d6997c071d2494482008b86b9c5cb9f4f5cc2fdb2e69c7ed2d9521a090836bdafa81f915e0d7e710df16c9985502991e5f7487102fe6cd406e6f29c2b51d8bed5ff950ce663d1a162ac78956eb24b059f625757e0182152a6854f9baccb8dc0b488546ae2b1e94778b51d6b47a8728f9ce6a1b0f17a2cc057a6ed81b1c604db706817ceb1701d4de145b4f97a67c9ae35d55d28e7e3a21b3f58c216c9beb282287ef1956bcabc1a5b767505eca3468c4c104cb5038305ec92e9c68d61a0ea60a4b5e5379f2fc5cc75c3507347fa2b3775d167d17c928f689c564baef38403561747ec7262fd5707b7d136b8a3a9c7953bdb98da75a2ffed1f3519a3f655f24ab45c526a76bb57bf0824b37c23fe1ea0b0aec04d242892b2a99f08d974d2f5a49e892206ff25e189691fa5a2e0b2c530ab367cf01792396529674799d86291c80cb33e7fc60d7947b4a3d8ffc45d548e60008e2a25776a5701bf7fe587f0b7defb18439b3cd84be0e006c367077e0c552068c63d8472d5263b883577bb4a99b972a6249e57227772fbd8df0da46bd00acc5ab2091db5bf84f9b2d7040582d401bfbf6d8912128b73974092b1eac6cf297b8d7d33253c148882e2536bc90fd0f3f0c9dd933450c7757a40241133f000eef6262cec5eb9ec4eac4a7a89cf23abd13ec4ec86367061a2bcb4667e5ef91e34faab2c46f02c0744541f7083d725bfddc3392e091487fb6d19944791a4941ca4e3fd5f4d85bc23cf6115bd97613774cb71809ebfda1a121fe9be43275b3a97dbaf3badaa41667bc7d8e774eb53e6d03c4b8366dd7908fc2a1e82615a23ca2e7f1fc587be5be7df137604f123d6f4e0b40501daa8c9772192f428d5cec813ef6d9b2c6270c09c046d62dd153ee8a54982bb61c5c12145340d4fbee61b300b788ca09dc06a927536f47bc86f23e341a56053d3e8d3360788766e1b30e799680e5945ccfcca9fd375ceec41c52cf336bc32ea7b787b3c975d65931c1114f73f16dde8bd972fd77cf16a4ff45e21db036c68938a49d7e4a8e27e646ac3856d016f2ffd8ae34ae77de77e178ba1d09b0e7dc28a291dd430e39df7b22a8f4fe5a85a3f036806a019e40294557e1e9adeafe0870e4ecc271f80da252924e59b4151644cd62f963f9305b9627315eafe7ffadfaa0da3578ed53291c26fe37679f4c3023fca479908256ce0cdd09f37b9c345086cd22430cb04e3d9e3c37b1c0f0ae6be94b98d5404d8a3a9889d34aa37d9bc921c868551cb1d9da1409c40d23f4e006c7da1f25fd08fa02c6be3693e0404d726d19dad366cfae75c27fa88bd21db02707a375b59c2f9f1c5bc12d9459a139708642b3290a03af0232bbf98f61117d9a365bbcda43869a1c08ebd3c76699038c7abc8ef3289cd5a4a9d16026b9cd5edb6ba33f838e032717b960831306867349960fb93d8376cfbbc63b7d0605fec6d9d79b18a3c75cfeb2f5f1f528e0b62ab151771adcc58dd121a54c676f1521986a170f6d851e963e745eba63c207238bfcadbb4d79c7367f205c202565dbe2920f9b61b9e94cc7a512efc12b8ce07692f3590f022620ce96f887b7816664da91967836d0f83728ba1ad5edfd5bc2ae17766c1a42dec351cedba37d50ed6218311bd021ed6610bd4c1798c963686c9981e00bab0449426b57367d7359b73492d09889e3d0317c39e9c74ad65358c8c252664f682d29ed6d101f97091d7e82b4e92b7ea855ffa63b1069bf4a0f513f0c1fd102bfa87970a724f850dbcf0f931e0c2e37b54bd2d5e0b3ef72f923033406f44546ed0264816d49f3b4b75d36c82819f2750964bf2f38c3cf2c30051803cf11cc0bbfc84630f03935a8ac32b2bd7e1f2f4e25db14ec31cf2977e42b13ee9444a27326753d68d9a5ec26b224d4233765ca9fb08589ca20c8513ad554d96c5432f23c0e457542dfff28bf7b11e545afc6c05a55882e5b2aee0cea9514f967860ad9c27d64016d604bdedf7a88b421a62eefed0cd434bce8d570cb4754879a0fd9929b1ef421cb54e5d2c4776b86e3fc10097918c65ebbdf1095719a7abf7a8c7d6b3811b3cd62af37985ff0319f0001f0969f0300eb26c08a335d6b86dac0d1a6bd109d41a774a9412db90c6a2003adde2026f91487fbed77a64a0be41237fb515405750075a370556e419031acab4611567d87878a596913edd505ec51a46d6ed0bd507397cc89ba18de97c9296c025c1a6382e2840d423f31751b07b38a78cb692b192f129ab0a3fdec100e86ee8c34faba1d5bcfc3534deb1d57d240aee724faae87b6328c4ab0031b74b4a95d5afe9b38cd07f6788fa1f9ab4aadf68336dc6ae654ea3b10039f979f37521195d5117e5968428aedf8ed7d2f929ee006fe6b2c05a07fc9181e58dd5b862ce45b66d45af66444466610a616eb74aa38f4daa4622e539ce38925ab40dc2f17b29bc335bdc96c6544d6cacd539cbe9dbd3de8b1cd46d84595a71e26c2cc1e544acb58a45e2dd82096c28fd79c386c81eb6a0bb2ba321eec6971ad584c197cef12b900fa69dd9c7a38e6371f33b8eb04598d492c68a4da17d7e842c14f3266202a781f316bb2d9d1092cd1224085f9f5204d0116f732e9a225e79eb5c64806173688280a24e34ed559f279b1b830b2b4eca3b01f22e6050cec2955796b164500962b641edd19ea6e9f9f405ed829af579f10a42a99d66d720bf54ebd8b1004df9b97600066eead8af1aacde264954bf8471ad759a95254e0d60f0c0e59ea218b1725e0e6ff0c2446c97b2fb6b803d6cb6b6092b9de6868dbcae64119e13d7f75efb0ed71db5ce923db265e206723d9395cb57ac9f990eb2fa4003ebbe236b6505dc8456cc120040ad75b4449ab506cb902112d994d168586b2a3d4cbdd3607387528614b75370bf8bac56ba220c6c6aad4464ba966a22572ceedfdf6a3e9cb95aa050a89bbefd689088875c354c77b8706844333541a31750c02712257affecb55e18c00c28ca7f5428a0f15ba4dc4b67d35a3e4bf973efd352c0edf255f91412bcf867b37b7d9f4971d9653caccc814f83799cddc98ee435b516c819ff8cb97f0ade9a68ac8e96ab914f8f60cd113fbc31c94a4e301b584c818b0a09edc019cd9e5789f5ce79b17172c034634368229cad8b0f1e1c11d731e4a82730bf70cc5cf04308a2bbe7055edf951443fb5c0c5db5d62f021a321c8c2df2db70f2735ee4493d26cbe22f6e3727f8834e61781bcd68009da64b3337d1bd2a4c1e84f1f9b9477ebfc1b1ebcce48e75cd0141c2475c02baa6400e3d98a6f1738423bb0b57f572cb5987eb662b94321553f35b55411396ba1b7db0e62e318329f95b6efc4ea813a63124ded4a92f17823d6fbea89227bffeaba26c35a42138e6c8261299a7b2f864599e3d30c3c1e3946d529a8733d1d98d46590fe03b5af30970a86631df445638208201c8b5d044120ef1759ef219fcd62c7ee9192fda43d0e0c954859782f0568eae35ab21d7357ce52ed015fb183312e416e58df0b084ea26f5aabf37cb61b18cb9a992315cca4f56c34d67f2a2cefd2c5cada56834a46e7cd1f840d0f44f3885686cd52d0fb6e513d64c473f9c0ab2c157da505ca27cef4d95e9726679b1ed42ec9c07a89d67d68d85941e687c3dec8157afcfb1bee68f8f7898dda6657ead146a3af7a414d13f37a8c4fd0dbec80ddea124aa67afea842eea67e075f0585aa173b36de33dfc50c8882b1f03b2d322c98990071215049eaa62bc41d92d40aac9a70f2cd631e4468350444835f68a39ec7caa44ea05bc3dd6a0faf39a876a56124e10f6a0be49526af62da92aa4501a36be2ff29b4ad18f241eeba854bd65dca6e4649027be318f1a793a8c26e961e6055cfd362dda75ae2474afe2171516f453eba4f6c07339d58a0b73d7e71080212730b2f623bf91a8dd525e92f4ceadea7789a171b5f8b1c70e2e30f68ff33aac4838791e0e2201f182927bef5350976074aa0d0c95a279d171506096e6e1ec6554fc07fa5125c0c795854455192c493b17a7e22da5930a108c8b14cd0200b97d05814618b6c39e04cf4200dc958656cc4b3e70a67e952ed9c49dc4e409584d987b0c849446a3c7d81a978340486423a4eb5102f3a352e647c584f8a2926f424430e2cd179d632db3a769390c7aa4e65f2875d5adb231db4e6cbc3107b2fe150f6502458cfd47aedf341ecf24b4924f287764f6379d133fb8c2e96870f779f1d707a3253ae34c9d378b321eab99f45af3430db7b20a018e85a589369c0994d5097f9dfab5913dfa6192399f251d445a913eaa62a6f748d520efc3ebc7ed3e536f6c5e1f388579e60251a3886e3442948d8797fd23a62b62c8ce84a1e6b126706ab74079653302ba031bbd5e140775ab67a9bdd73b815a28bc1b2974d9cb13b7a92df11e834741d9eb22c0e9836b2383d5306ce1cea2ab5ba94bf53792702d91bf18356de9a9a79bcecce013b66bed7cc9e432913b90036639cd6a8b40930f427e2d6066e18bef98f53b3c312883bfd59c1a0960a5c3659a6538ab8dadba81c4ae77dccff9fc33eb0ec08ba0652a415a8c00ab0a4ea1635070145ff56f4bbe2e076f427c8f6099b97b9e27a8a05febc92c4c05211515216bd8d338442ea34703f1811616a52a8966db8395310c1faa7a5946a841b08defb5c7148f7d709233af49ec68809bfa34de5491a11009eb31a3af4028bce0c04042ac24f405e716b9b24c4bd292496bc0f71a2895ad0e136e1665df1b081bf065bfb029336fc299a6ebc6cae00fe3a0334dc3fb3d70f10cb4d2ae0ae2acf76471a1c54068242da0d5e78c4fc48e1d10edb11d02c2d0667dbbbfa8b25db53ecaf93f707a5d73afbdbd49c0a1e1b535d456d9cecf6e9a26f81d54daa5d82c6c5a7ca601942ad295187aee1577eb702752535f00d3a3ffe6584b32ac150d6300bcf423aa1e105b54a5d861e510317fd766e9c9acf29842ec58fd6b3733a26072b4ab67f31ffa4288ab687efc5b0fd43a357a8e4776e82a92165fda675ac6576f3f258306fd5ddb00964fc2e55f2fc7d08488dfe210f934a07163a0c1cbef49558160bf1b9081d11f3a9bc68073a72675ec8d47f59cc6c7e899ccac2bc63159b41282feabfe5cff03d6b0661270d47e493cc95d54d31bef449ff0393529b1754560237de9ef1ff1685d23593b8680e9c5476a459342d32e2c8ebc4d667424b21c5c0676306f2745c319fb76a9ece033ba2f4b4ff5d344ea00a91db3706bd80e56a4327c3ea01b9c568c97274513e8b6874b465c012386c36c0d11663bfc270739a557cc10682992dbb2d8850b694f4be675cf2b5d779867391cbcaf787001673ee719e512c9d3ab14dd867786ac8ad67972399a04642f21a52803a30dafdd5bb3e1eaad83e961962998f2ef02fdfe758d33e2168e16a12fc6627594ba836c1b2f7b24828ef223ac0cb992ac15a174cca48cebd4acefea6e1cc57e6e4fd2e7871954bd285b08203b96b47da9d6db244c2e0ee9825cafd34c2eac28d92dd0ae41c6a3e6bd59435c2fac43d34712812a321f21eb6aa6a3c4782833eac01209669545856ba3d6351edaa691286515fee5daa94c8470081a39786320f47895e38553cc4695185487c40808f1c5138d98a5e4b80cbf3c56ee55cd8ad824d8be8e78b5cd3fe1215c73c8dc04bdce8c11201ed9156a90c7f7094eff1a3c892c2bd1f6d7ec09b145fcc7a39b98308b78a7e67e080d9aefa7188e9f49551a85f9a14854c64e399ad2efb6faef11d6c30d983e08802abc0519acf33b7cdb5de9e6aa290dc30e3250053662f8d5e23a76ad94defa2a5fdf36c7509f4263943d0dcfaab8e2b50676eb616d572bd946f502106773ff9ef77537773d17cb49a9654bfea57aa180622f1af085e395fbb1ceb6e71fa5f0f883f54581596527c93bcce01d827f6e2027b1b13f236c3d65126b4eeb9aaeaa2453b94ca74fa4789f068ca2d682c0f16522049a415021745bfb2ab984f71c556548c9f9c1c8ac2e97b0009592d78860f51f11468eafb38c65f53559ecd66062205cc50aea5ac931142ddf5fb3be7b138ab76cce878162db3186afcee3d0dc5910ad55c765f183402b4e66fbaf5a267655da8b91e89f3424e65bda77e74eb00478f9bfef14fbd3496018766f9e62d9ce035947a05b7a68ff096038ed6fbb190b3382fff272b7be41a98522abec382c6bfb5068d8079ac2555c04a5b2f1d0d03b025660423f567d41c142b44253058a1f43391a88dbc0a233e3048f020e8c6cb3e38509d66e35e2b3f590bf27163544c1c5ad813cf6c207e8948ccccf5eeef9a9573e6a22c57299d9b930d4b734899caa1b1ef0f097fcdab4b13d17a89cf76d9ce4b78a247a61aa24a6c6f9e33df95e4cf21c27f842656d6562979465a166b3b11a142c49b34088adf18234ec7d83c23802ed2212a6c93b8ba1259d18e02cafd006a8d170368d1668d7f6ecc61c5f60a6c504d77c4a4b858c7a05691103a601cb085063e3b8aace9565e5ff24a5535ebb55481bb490304c14d7ed824167f2857a8b8d6145cc73f5171a46192d4dee966e0fd01a87110cf1dc3838286f5f39a2841febe99fafe23520ac4e89c8714456e8c73b14793edb06b39abdae3cb7f6abc5b5156030f23670ba399020aacf2ea4272d5041e947839764a7acbc327eafb935629a84d5d199a8a2a7cef2b98f87cd7563785166f84442a9c5fe4080aff48644bef2579a3bf9387d2148938975c7524a09f16aa8ff03f4c286096f16ca4fb9a47f3ab99e4a720c49eb1ee0bfd11c86a2658f65389f28409b972331938b95668431e5367ef17e30b7911d2524037e6e4d8d63a79196f24ce36bf851a2aa5f5a4dda980dae9287a365c2da98de168553b67b2ee35f85906fbbfd6fa14118c29bf35e567a2b194ca614ed13f8ae0f663e6ab341c173efa8bde403430746ab926fb9372f688bf8f0efa8d370cd9b3f46765abc3aa05b9d7e59fe545832d7d4dba259d5eed03853ba5b11a102c0de0ec4405b65353bfc1d862114a5d0d8415ec7d43a66f869fc2af52386332d09e1cba0fa7936f1b7e994b9e6654ebfbd6ca6c07b089b33d0412aa3cafd70ce8458d6a5c7cb875ecad90734a3141fd60b01836604b861fa6cbc021140a959e397062bcef789cbd889d464e647e1efaaa1d09bc45a52e602956e5521b321e57cf7c92cabfa83c27e46303dc958dfdef5313d0edf89638a18ed74986b956325c21226c5fe9cb8d1c20d2f5eec52ffd5044d5c683211d1c4b10a6fdac8cb7a2a925c7017cb0350e430abe8108b92f3c655eff993a73fc33f15a6afed00f7bee984835bd2b24ed9192df38d507f5e6d90c54a0326ca5c2eff753808409101f67a080f0d5b528557169d19d68480b36f078c802823a768161f3f100452a752aeae95c7f82e2c99a31af0f34c0f5837a5ef01596f6f13df7aba23c070e685cdbfe0987fc66015c7d7f47231ce10f373cbb773204aba8c7d2705ceb82968baa3e4b27db607522c6c6166f42009ca91d2deffacd01eca8da5804cac3bb2e36f21372c42fbceb5ea3d4c3e948a913696112d3c77935f4986b52e1d524169b0bddee6794eeb3c2450dee6c7106596a3525d803cd4563c07903944a46523e689a8b65a5bea4f39721dfd64a8b8a6fa376a2655f82061769fea81d89cb03bfe142094f0619e3a9b7389f88c1e36db44d47bfbaba714660d59f5c0a6139b58603dbb4457354644a6848e52d027c1f035a15d7fd6d84f6bb35fca65bbd0f91b9a56b2a6a8189742451fe635b124450323fc9c36c0470c4e2c9b5c1c9457c4713a6b71d7e280dcc02a8bc54df0bf60218ca38319ef2410d25b70854ecd672374234400edcdb3df4ca4b60ada0f87cfc06c5924ae3af71da61a538f54e6e6597be2189b7c856d04ea8928e544820324f01551e557451d641dfbe8969ab97d23373afbafc0977f59ace880cd199b0b2551c060053f500ed2984a594e31a22d187fe4107c5f31851315d2ceaebf2aa414263ca21ebd35ad35e5ae18f720a43906d4c30cb21aa998e2d530b9a10cd616f81eaf8fa34118700d6b4a8019c36abd77962124b56a7d49419a77eb3f581c7a8a57cc959ee289c19089166d0f12dbdcac03799114d86ebe0eb2aceae6bd5d710fff605256845ca7cabc457e59cd4a0c1c44d6f497818a81aaff78be59dd0d616a434bb20c53ce45f362f710b79db27f411205dc253344dbef291cf1a7b16e9e38c601c1cdf6d7d064a9e3148e0d0b14557017d5d96b0566b5df393d939ce216ab3a1c48f7316669607d5db5cbe66c8f6e7c17b763aff4d94feafdff1549795bdf661eec1431af0c0fe576f81c9d88ebf202becd8cc7871946c0a5cebd14aac19cdc8fbb97ab3d395b1dc8aa950282eba4efdd33237acb252a2eca486993430cda128e45b5dd18ae063d128ac3ac41f5a1b6220749ebcdba77e2f63bd9ee9ea14201dbb4191cb67c1366a01c64ec6d84850055acbfbcb30ac212f57ae779a748f03edca6b3d654b2d5850fde50996070a0f9dbcc0b65add9f4194843cf2cf948433e0e115de01a7cfdb5ca065376bebbafccdb58825b1a569b30f81c321a7f300bd3ac61ea88f0600f9e408c754b04a72c71c4fa34baf733cd6cdfd82f9fada03850a90a0c83dd98d1d0ca812d6adef940e12354a449f53a538ae87c3ccd57f82089cc1b942f3881ea3cc53528c73c49c09ed4cec2fd6616afbb54870e412bee5c7a13ef3457e2d4ddd8bf8ba97eab2ca2d407c7eae3cc0ed2eb7c0e3ffe07f036b1850f9d88a722cbccc6b7cd22618425764a2a1ea2483cc2b5db624332736bec7841a0cfc9533139d08722db1dbb574db65b3eaaf2ef8e0be794be93598bbe9607e168531d8096e59e749249d024a4b66b71e1eed320e3ae388703a0c51698e5b0e9a7c5c94d211e55dc1c0e67ee3981e9fd67377fb0935ba07c1128505becb1b55f9a5951df1d8230180403b7c88ad481f16aa890e83b9472a92a602cc147b7014b3886943bb26f1f6c17f241f509aaa3387c623515361d5d29c0e67b18d54d7cbab33371ecdeadd27f98be64d34f2281dff0263c8597370ce55bab61da0221cda1242a2f91184273f6ff99459e4fedac47f98637fecfd75b5b6766261680ba798c625baff86942f1e4a7b206f6cfdd9a997ed50f42c30555c2d0b9daeccb68f541c53bb393b64e8e8858ee3aa18857e94f8c90b79e12505dbe05acc926feca49459aa4c9bde4b937f6cace74169732fac4e01bb2eeafc47f0105ffd84d2878b8246b5b52c7e9aec561d6b804cbe70f819188f2eac5be2b136a79249f625ce293882d62e825263f57349c471c64e54128598cecb68586c4cdfdf8a0174b2a648df5f0d3681d042876f0fc72623d503a254983338e43d75c3f47c12567af1c481f965962a15f4b1498ae20b032d6958a23a97b411ef001d6c1c309076e14e8664c75807952a5ddea27d67db09827e4fd90d4130fe956d27ca3730bd0eb19fe9faaa527956ba52e3dcf791b16b7bec6b319c42e297f12e2b9d6c714c2c60e4484e8f12ef86ea15205213dfe725ce9be7d51ec577271b6254478ef3ae7b608709e4f6de24da01d983f214e4b4c57c430bcbc56e0254e92b91fa8d39d39dcb22322c5c3693c5c6623026cb042c7c0c25921a5715ae4d411c3173772b8b21b83a3c2ba0bd82a8089f7c41f09b2e6286a4242765ef72c9d47dbb3d2dd0ff355b39e9090c3fea621b604e04ffb6ca143d731c9c8aa53bb03f1bd4cd928b4035838ed387c134facd227e34f4ed308f377bd7f4a72181e7dddb253034331d345dd36634dfb46fc58b586f09869b95cf71750586f8030139bcf822e9fa9d1dd6639cdf8dc1ea3a4bf25f42301ea6788e64d3f95f3c819fb25117abf87bd425a85200515931a5d4c4b823584e63a61dc8e5cb029a04144f9d8ce7f47188e1c06029146e9d7188afeed4cd7f79780d2bbc9731651e30cfc4569ffcf06fc3c9e842de024e7f8636c0815265d0507fef56aad41e2156eab595bd384cf6ff770dc16384e41162313ef11957d5ec3ef7ed689bc41e615a7d379d8ac5c2aeb537578e4162eecdda55d1959deaed1a4aee75b7b6cf37156bcd9edacf2f77bffed1d2f674c89d370dc235d739203b1922919ba6c3c411373e2065d7acd2d5bcfe3dc78a0799b05f9dd521e275c1f760eb03ce689075325f5079e24d6d935e470a689d86cd39dfc6786e6a71109afe763e2a30dca7ccb3bef6a76cc3799f199c52ed74d1ef58dd9ddcc1d59aa7762490c712f8d92d4428491b75042d540022e1c490b2f9f5f2bc347c58ce9a8526bc8da64125c04d43879a34647405ef13394022ff1b6bbc1262765eb1d9a641082de9b1ca612f3a5868df96ae90615602e7b8c952daf7865d348750882c84c6ada29415abe04e56a6422665b3c7cfcd831000a3f167c54a9ff1825d3f91f87f634d850edf74a8d49fe60cd80fe8a59bb352e10970d8b90f94f36e89f0d983630a60068a921adee65e3afe376f7f08928c338e1bd8ceade1cda5f5c9670309f69109939ebf68fa16eeba63c989147acb6868a3d73678f89fba2b9a4c97c05b0922b5be724cc773fa7b32bcc1cdf7788a0c6f2b409c5353dd9568fae24e7b1be76444fcf519731173148741e22d8454166a7c336d2833e7349cd9036eb65bc85ccefd48327c84fda6299b420b21adb0586f48e9c62e34986760c2a5b73b6ac90a5fc188a2080b6cd74173f85ea41297a0add597d642efe0c683e15599982e26b1eca53238b3c850a1d548bb5b760a0da46a9d6632b23edabf5499ab89b6196861cca7df240ffc7d76b02153525b037c87e381486f1f2ca0b00316a0b1fdbc15d3891437810fceade495ff6add688c9a12f47735efde5aa6e83f957a1d0026db4fded5ca1afeb77867aca212b0568de2da20c63d845ab367fd9b823fedb255faa5798893b102c319aa1b6833bc71795b059c6b1c4ad58fd350e9c92a1f5fb950716582bc0c314b258677bfd89bb40383c03c1ec3070b29acfdbf68a889236e95337753f72c916f5235d848f1f1b08f7e5034dbffbc86fae2c5b5c8214afe40a6a21181d5319dbac0d9ab49505e58363fadc5db4de77cdbc6353c66cc54b41465bf5629fe5c398e7e25701faf5eb8e650c3c1de5da3ed1e12a52a80feea7a79cb48a65a9012049fffd29f37cef61c08a887b5edd2b1c293f1fcc2de0cfd3c991eac45d98d489b5ed9ecc5aaa0d79fdb31b80553d9c9ad006b08655a2f62473eda8f3dac018139ad78acfe2f586489186114c6944d9fe45e58e7be3c8e378a22f221d061bda6ae389dd944bc7550192649f857e8b69c0d704f5baee5e0a2eeb740a31858791fd37d085574a2b0e063ceb6d3bfde70868401df2b96eeb62cf04c1a55d54d37ee768c62f06ddab06c87f779cbe5c75d5ca0201e08a5a089ce81dd67855e0d49262444938e8db6c5976f0eed3f38d33a13cc738907e5c9f427720e6dc4ef0a54a65a3d119448c96c1a27430124bdbe83d5f5207757ad61cb88a6dbe0a657217ddb57df76aac4b4e73bf874827701c9562e132858f7b8ac39cbeeddb6b44db512efff925754eb15ea77de9b78a546abf9c71485c42f93f5f24a99c0c6379ac075a95a8f7cd6e1050e67c0235ceef80df5b4e3ee603519a2c6f0d5f312a0cdf4adadfc80c238d5d3d1b7e5d92bfb0f5754c33d47bb4e4d65ab70fb531e625571a9b850889470ad8ad963a207492bcac52cb70cd90ab4e1ffccfd299c35264e42d96f4333044397d50a79688bb314923f8b461b621f6846cfb33540fe3a3567629787dc6ee9d24b6c78140d1c31ca8ef549e90e3c12fb00158328b80c7ff8962a462c1eeadd3043a4e93a6515414c1cedf84385b06aaba2406435acd3c13b863ffe3591b10d09020a6760c1a2cee0c3b8c583bc85f9d63e0388e37c09507102f7a79cbe6137deb2bf892cd14bd227c6e549a328ba18961d0186b6d89dbdf6f7dc9ceb0e083edfe13e6f1d3089fe331186df5a4cca3821ffdf3cef922e6867a5014f3c0e87ab423b1b1cf25491095bbd611caac15d7ee923d787584fa2b3e56e78b6d26d9f52470b6c6371f66a78a953c1852ce7c89584ceed2053887b104b1757f696209f6571b4b14b4b693c50130b019eb869e755846bffe41af581377a78aaa1bf968cb569dee7ecaa2d85e404433f0aefc84b240f3996ee755aab316e4e99f726ee374b7b431649e992a63e1f0f790f9dce48f3cde9bab41e5c6d9a48beeb602409bed6934b09e53cb7a2b0cf484ee8c79ee8fb2e9128f2bcb027781e9947ebaf734f75f716df6da78b8f5de383fa2fe14d01a934607709c89eff4a212eda25c79dc39e20975eafd9f85872ab47df7276ee6770e0295f2095e8da66e5882bc64a29ef12b4033e23960a58021c01bdf3315b66db2a6416c41104f4df89b4ba8ddd887e345122e8dfb7510f234eb5e2986983debd9bdf3c5a639df595ac60724256705dddbd56b1814e2622dbda76fcb6eda47ac313ed0e635d13882e563f3c787d3bb90e317377277333a64234223039ce86fa3ef846a3f957cab9005c72fa0cd67ae6704831063fc8108","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
