<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b7591b4611207296d6dad244971b33320a2e6adf002cc6a8566e83d37bd9baee826c1cdc178d719f36bcb8738adbd9d84e09d3f3e5ede0d4275ecad62bea798c306361833df6b8da2b5c5bddb41b2707b336f1ad8da6e98db60790ddd0981a2971c5280819f62314eac4b5cb7f199b8e05a083c448653f88e9c8a7d96fa9df2171f9dca47ab7b81f9827f01fe8ec5bdb95ee49ff9858573d0b5b1c5eec61fb51cdf4a1c96a293321482535b4be848d92d6f668f65211072d30b6e48acb97363f5f235658b91b468d53d4a1c0c2f43309921a96210237484eb925665ad007997681177957069965ee33b7d507be6166c45ae6f67f41f7f020518a91077fff487dda047e8a6a07ee3d901eb0f0b3f0de61ad5a7e7d4777f1aae488eb32478e26d1aded8807ca7cf733ae77433a5cee8feafb7c1b08e09281243041318ccb3c945e29f2bf7b014295ebb53751405f23054ba7950f477f98a7e28076f95048c41c205dba0dafd31563f03f03141a5b0016d090fd4a1c37c6ac04ed0182e0825630104484fa5248a45dec2caab4a471576855e906c07527f1c35fdfd7f64aa053312cdb5ac9263e86b7ef92316c901087d5646fffef0239430b6f40cfa3c4860395dcaa98357c538b91dc828c29e5482a64dc8646e0537af1bb062b731af3718a50493ad4415c672557df7be309b5034db2ab5c25cf4933cf51be2dac4ee0e87f883a38190fb3c651e6950d26e2adb184161b07dca5e706cd83e18ccb2075b4f367c9064e7acb8758b6190240006ee7d03869e1177ee0a31c1a27b5e9042bf6f3d831aafddbf799f3e1a1d2093e762c6cd6d98559b332e767d7df2e2a31a7daa70fdaf5581953ea0850725f27b7d38603945f0ea35510734dd7b9e7ac0ff8f1e6ebf01350758d1b5b951da61f12940463864462fcc26e2143df6e29c2c6818572d7f00f081b6cb0edccee52bb0bd141e7c975334cfb6989e06f006ad98a576a3140862268321a63b8cf1d062bfd25178c2c096eb50c680a2bf926da15edae924e4543427b7eb4559de852c241035e534a618a4c558ee8014987b86602a9db66fa6e87aebde3130e724cbdda49f31890d99c3b880c52d27e9b2d9fa0353d4788bc4c6ee527a36ceb503e5b470a93feeff96eaacb6be16ae270e878b78632ea5d67f7159ce60d84c2be38006d899ee17354b90e45acb98fb3c2447b3f463940dd0bcaf2c6e705f7ab16dba41637dc0a15c26919bd921a484adb2d368027bc83826424dfb8e4db527933a09c95e8e34ff32f5deecff098ab75d60178d8da7186e526fbeea826da0ca4a978934f5dfb3ca2371e78e997659616294c396f623b8f1bf2d91a24808cb197ef9465da8c2a8c942675a88c6b232cb8525a3781abfb08b590a7fe824c7065eec670a26cac81426059090afb02383666b5283fa06f350751cdd29de535c38504f9d9a2ebc2e34bd2fa6dd61ae3ba497edd8af4483d005881cb491c4fc1e88bfbb1fafc91a736a1d3e2d5ecfdc4d628f6f5417ca82a492c6294b1b58a211d01f680d4f55edc6b86deeaf879c877f0320297c8630030f26d13625bf7e4bc26794390677f54625ac5812e45494d1d2a57ac616b7de218e22ac12d16ebcd09dfb54516d21df745a0bed1a922cc0417701bebc53ccb93f829d3946a0b28e0afac9592712c62dbb86747e12cd114a11e5f64423d4937787aa70769714a08ac4ad8c28b4a4a648aef4558a455dd7e567eb823d9822ecda26fb06b141a30af994776b98cfd9abd6c56f8011d1ec28e2a3b589bf96d5a8bafdf0aa9453f977a1d4f40691369b9140f609898f55c44a8bdda2c02529c37ba1cd1de031582014f0f56c2333a5defbb118747646c5854e477e47b19c3cd9ab51fddac0899562df0c0ae3defbd93af4594a99532de01de9b04272130eb31636aa83a34ba6c1cb9edc39bf688c54d75a5ca35cd7a3de14403bf63acfa1db37d50620deddeeb8b504256ae4c9500e46ef8e1a6bc2d55b5a670a054b395d2babe6c5376c279cc263d10646b7e30a1556b7f3bc120b96ab6d4cc706609084ab4943bbe4f9c9d979124c0b6cb1e6f91add30036f13a5ac1b228ff852ed7614d95db1a9753b659a933fe4e20f4de9d92408691ec08d4387c21bbe366d6e91123562a6bd89cf1ff6dbd0fdbc0f2a186f9d80d0d9707ff7e7912234a7227c9271958a8aae1fdedc8b2ebf688725313fdd1f4eed5b63af999fbc34c8593852fa59290bc7379452c2b566b3af8683a726869a5046237f2072701da8e08e069be2337ff5a13e941d7a65b51bc19c511a7e784a58006de333ad1cc537a1358d66a91dcf1c409bb52bfe131c5cc9d1324b53539663636d94884138873a15f7470d3921725a1931f4f6c2062c5750fce4bbaed9111aaacb7b1840cc4946775a235d97cc7a7edf3183cbf8a63c4a45407ed19792de0e83d84fe34f00ade96bafe7819bc5b059be459c06476b807765a368bdc0ac968e86a8418dfad9a8d6f8d2fe8b10bd917807da74a36d743a5d22f3673e9580dd5d46fcd4adfb6273c51d6304630da2cf0272f7ec0e8bf4f7754a2fca67c25eca08f0f9a634f96f162473cfd3a3a396576ae237fd69654ff178b92a6c6532440a80c47e86f1f8251b89d9fdeee0bcf258517a3229d7415727d0626ae49a7f817f96de4f4bf428e459b23cc4210b4fd5df0bc794e4006418385f5106c0088f0eb4b52a9b5cbd431a7782b535dd95b93d7724add5d701bb6ce5cd31af7296445f7916dba4dc336ebf7382d3fccfe3e498e10b20a1f72a9d15af47cb2a580d754b6ac364eb08518ce3881cba92079dfef9dd46d5b1ffed633fb5e0c508542cb196eb486be2d4c48bfefe52033a596ce6cb042f2bd0f1f33c1e9d1dffd9a93604737805a5ae989c30c0cf24609a37fef46409621f6a3741a4114dd760461b9882af07e2984cd3f388b9ff06ee970031f28c4fe84b00210635e711b4479fc5a54d670c838f9c067d89f24d47230536cedd90bed98f17dcaaab7883ed5dd727af43478b8a74d7e84a1c10d522008c0ad923d9e2360e041b450a9f96d23358a9029d0fabefa9a3e992327f4053eea676bedad92966266b3c3f1bb6a2129b99c4121eb41936a105fc60bf3729098b872745211e38e4357c1a63bfe169b1fa062061b4dce4d775c1fc6aa10d44e72d303509ddb94d09d391cbd0e94bf7df30f49b3cec5ac6f388118a82b2d608004d1fffde4e99f30ae0aec13a8ac2d1365fefc7b35bf80a45b8022b9a24de2fdca9a8cb65c6405895262a14e0c1794c9b613d1c08ed50de0257a1a6ff09a9e6a722cfb61290e574ad2b2b64d9f6d7e8561e3bd8e93c4a2030e0e7c96933769952dc57592ad9531bdd2b93ef96898c034848f65d9122635ff34d8a535aa88272c3ef94f0bfd21b759df084d237bab84f17694850dcc8abe31c324c9cda2964ee031b34afab9dfbdf872555e0b79d68b31793bda1299ec8d4409b24066ca8eda236535a81697801ead0692fa15b777c7661fa6d85ff432496be5f04a160022c2e11ed61333a1be23d87b90b70e7684674c9550a5c2a4b5163deb4f3f91aefa7891f7a2ea5341bdc23f007a629b9098437303841f34653e76e2bd28b256d67d5530cae548cfe1715663a96a313d7f44961bce541cd3486468eb5b1aeed7776827da58e32e696b3d3aea6621cd477784605ffefdc91b1863332d9d3dbee5a2deb60767fd31d38fe88507574d472b4ba8dfc7da7b3edca343bcaedf6c52e463e96f64f848d9e43bdfb2f7e454a1c1c66864ae2fcb10485a7bd11b758570c90bb17a1a47ce6c77fbdf134c12cf6b030112418cb04a90fc089144dd567544ab83fb6107836f463189d4995f2658b74623a3953a300ef3fb85ed8ef3072a6b04bf012ce27c86ea1ea00273bc0c924666b14212b475ad9e6935a7e86f1ed140140e01b712e1c9148b3b0c7e606d59ebe9487a31914dbe21fa15e63712e8b0e130712c91f58675aa351563949d7d0e1970e6bc92b125caf2b74ca77d4f66e0cc1cfa0647efa1d9075ba8d43f74d7587b727509b733203dcc22d50bcbacd9b10f4d38088619bb68b127ddbded1ceac302208f3dc196db1cc280c437574cf95c825733731fe3650eb3428665b9c44c2a458324d44e632dc762db2100e083fc7d12fe2bf0676f569f96addbee450849c23728c6089e21918ffd55a2850414014da02b505c25ec3f16f81ea2a0ac34d26bbc031cdf010b06c57b7784be1e330bcb1a2335881c5f0289c113ee2b2b74f352d1976bafef3a6ec37b8a6031a4c16433314ab1c5ba3a84f3a82c48dd9765b176109d7acf50265403c043a349bec907e17a753563b8519748db298dc47379d5eb9f09398cc6931e1a5715485b560d0af0809e108daf72daa05c2b2df84f65766677f281e9317c52ec0a16e8f848ddb2312e6cefb794ef92cf2fc7f0904f3885064eb1ba58827821a36b2fb1339acc449a63556e0d4d88b68a186a9a2227f953dfc38acbda58a1a82faa446db77ae2f015178881886e6e50c258c60b48918995197d795873d15b780facc98c11e57d8d13357419b1e67d7016a3731dade7c08ca322a39ecd9dcc150ad7746f4db41cdc3e74f793135b74d79a80b245b22de8c2dcc9a4646265bc309d5a3c82395ed45bdce82fadfbeeee1b08918fd2bf05368fb21fe81a56e24584386762cb79d02d4b96f545f74b79fa15d1037a8d84bc3d50145f299650b03a0bc090cf3c85d20b4660b712d29681a29155cba3229bb4299abb3f0920505ec0437757447f0821ce6ed649856a14703d0341c43accd46cc4fa5d733b4ae41e8a54b587dbfe023bb9cd5b9443c53f93e0e8cad93f3eb29e463f44e4635cd25042527cac47f7637e198eab07a98976ba5a9c22f51cc2c91ed0e1e3215fdaa95a5cb9bddd8e9a4df57cb51f4bd12dd4c56969b6ec46401e49a946cf7775ed915798f103d25a4c81797d1d2ac3fd89b2c1c173cdb2cc47756afbb081dc92b8b8174f0568141f9d241448a7f420e4e523e06d30500a50070c42e9b56849221bc661112a99febc67b13325374ae9d52bb12b5ae37775a4ee24cc73e7cbeced2e9f45c520246a1af895bbd00debc80c645568f85c96015030cdc274ccdd43be8cdbd70bd4ef6c11021c817f97afa1ccc0d4bc63aa4ec88b2b49e8277134c2865b6f73095f0cc4d768f4909b42f5b04c676d09f0fb2b5f7d483078f5c5a9d24a01b9440e546fddaffd88ba1d49cacbf555e24fc0e2a91d6938d5b183a4f13e1fa676387ceeef1b840f7090f1b79f212b86fbc81a52ae6e86e38f9953b07728767c9002705d6de1fee3738f875f6b1e28b42b2b9c04e528e83430ebcaf2ffbf11a69cb0439548e78ec0c1cc121fcf83ec652808cb00c34bd8aed3d28a7b447effe8f790d49aaf68caccbdf2662a44f29152a13584b245b928922f30f78bf49a86258f91b52b89b5a9537e3215ab0f66dd7768414d1811f74051c4d5679d932c13685de76e6cf15c906822b963fee4a4eec39bc4ff5175bdda198cddec02d8e78392c43d99367f5fdc1034231fda134230b34146f2e17e49b9113bf134ae435e6c4c855b288b746eadc2d104403974e810377367891938ebe226d1fccaf41bb52727a0cac3d5036402e591dcdd24c579e46d3a36885ec7615c11fa37b42d29c6d88bfbec6a7ec99fd17e52703985633418dc688cfeb2e86445b023bbf5ef2b06da916f7c40ba86d8eaa4122839a3db51e77176952d54171e0fd4803dd64bc3287ac94e363de27d2ddbca07b9d9cdc0017840f2fdcf1f38e4d98a7800a9be2f9d947a40b3411eecc984610c53e0e86fca04098b6cfd4b4dac7d741358a57649115980d3453154fe94c409077d41239e205b828f04d08a899cd176c2e26b4001b8e1ad396050fcfdb6aeb4426373f396603573630d39ebe6913011ca315ad88ab0e3a43df1f885bcc9d49ec7b69dc50e72779de7660d968cdcdc391183646356c279909f5223a48f72acd2fe4e0d3a2480828de97aee95f114c6f46797b7316be1815b470a20c570fed0e00b5402f35bbd318eaa81cf2104ae58a44a2a666332eeebaf83e2be8932764954d64d2fe775f18d2f68e96b9063370463f5fb05848bceee76a8e9d64be5524d1f1f6047862e89401d6eb27abb761dbd47b9b33bce7b13308bfd8d70672a26c822bbc99f5708950aecad0059eabf1ec54265664132d08b779ee23f94a25adb98c42388db5eac054500780c442b3c3078be59da34364ef89ecf7cc408f2cce796b4f2405459d8fcd1a0e45fb306d53e049bb5de72f16c58d99ded97a49c75bd48dd6b98998f62de23c78ce41c2091207d1116c793075105fc11907b05724ca19b94e39310df3f82b4a1476c7b7e52bedc4a7b97522727b16d052a0461460f6aa08a5e923216225d7440855329d422ae819d2b9e6be2b1d2a3886183ec0da3508a3c74d0263d282cc9be5cd10050269d6c20c7133b6f34d0f19cffee75f2e4decfb70dc9fb77c5326c5014c4a5344732293ef19a293a9209395751c2450a563ba4bc1f00d0aec0084ac26aa5c8a35f7c4504ed870ad5d51e58a23bba7b0b35265733a139c807814d792dc338a88f0ec916842d708e108f4e2ac61663361fdb75f35edfd7ae647dad0a612c0195dfc018d75171c33d09eb4e02550502a2f7dc2110ae43e76c4192e56b061281f20f8266afadfda70d9e43a8202b7c49d5c4b4e35e12336d538b8f2c1f4c14d3bff8a92f0f0fe8733b86c7fc3db30026ad0188fd87133f7e6668aad27955c2b38ec5fcae67d8cbe3a3aafc744274da5dbe564a960388b6ff3b41f569ffec2b54ebdd7c43196fcc51d627edc6507208963e87920bee84dea6363dd8886babbc8a40178d5fff9f225e90a47d887bf3e6216b27f8d069aef34f5075fe79d81b2850744f8fe7b0dd4b95ca6d4f9b4395d4c8ba121f275a36de504aac244710579be6dac5b545343289ca7ac493b0e6b8d905f1751708ac173b2572cb5717bffc8e1fb7068f18584664110470c8f2c97ea228b643c370f3d8106d2c22f1dda973c923bb5abc3e59a687a1ffc471eb6ff840b3a6971d2ff5a5b090e4897c022c53ff305c1425c3bc4e58e12a770e3da78d5b1cb8f2fe139963f1b2f4e9708173cdd124ccf284740ad425a13e8a30d6e491197111d4a1e18db1dc74c5c933ea915f5a56826e5c1be4574bf3391e864cfd593d3d93421b334befcaa72d809b2ab055f48cf52c4850e1fb0bf207eaab7ccc2857c318df7944d5a0d94aa57989b94169e11c1c6406683a372a7a53f687454781156dbf8016bd78f2151b3e05c31c8e899213c0d434652932b53a7775620034c6a80421074b81d0e7983a3efe0c6a5d2f84e6065da5d8d69254eb0293e218350e4b38c7f998dee44b1b231ecb553bc9272f1d9c842df697a5b15722b3ca1a5f523ded9028d2e88b1565b0eb8d8ae4ecfc1a46fd2032eef50ce42040c9ee0bdd12b5100f600fd64205fe9bd3dab3cc2522a6f32596b4c62dbe2e1037ae48724eb9e4f9a3efa4ff91d5e49b4909f924621e7a2a23e4199f234115fa8438aefb1bc6b4aa8e15e76cc31ae9a3e2c6056b795725e084e521d29050b8215bd7cd58a5119d5100c6f0da89f640f8547a77bb47039a2d22b57c384b0eaa9d815ad075d3a5d5c3b08b46498bdc5b9e5c5bbf46fd51eb10bff2f8f039396edd9e63db063ce8c4742249f396bd4ce8dc25dc4af2b261a15f70cc5ef62d0e44c59f53436ba2bed8e6f539a4edffbf0131ec7d57ad9284a0b74871753551c114ab4ae574245eeb4e1fb0e7d3e06de5c4adf5529b82a5c86d9dcb0df0d3c430fe64b76fa887f4eed3bd50133aeb2b9cc46fc31339902e1c10e9af4f38a1ceefc2e4736c68f49960f1e65534c64dc189318bd5a4b5a2f1bcce38c3b9e26bb15964a25e45c5d90ff98ec3034c35978c673010cd0ef2b4c40b62c4d9fecfe5c876cdce85670fbe577cc3cd886d839a0bb8dcf38c42699e24dd1b984bc9c48bb673ca2337fadf2c135213a0780fe982aa9c49986115716981d14c70f6292d1187061854572a5238183deb9b2944a37733b91dee733a838b3d8302b7081c313f019b2186c7ff3f4c6c636518dde0291a0dc70924476601fe9dd11e240bbdf773a532e04265069408a187324f9477b260be907e40df8f222ccb670b8f912f43922da9e25040c57e459ea21f5b22b0392e827e6017bb29d7a27e52f94db56591b5976f8a4777ea679c33f7bb48013f578d6c3274cb3a8e7b3c6f4e2f64beae087d9a2d97fd094077cc66743bc7673d4b6fb8779f482f2c4332b017fdd913f0e35cc23549bf5ab5fc4d15e90fe9cf2fab689d41b3cad4210a967bcb42f0fc193ff60d608704670f477515f72dac57e1a275d99cd5bc27ad30d857409790868bab94691a26158e870adbcc955556cf749a2e793bba552131159b6c4df80d845208013e06d755624b79e02e7c69a845611e926d8b0194c7b3ba8a70309da57950473406116bfe1235972a2bb16092bd0825c6edb8dcc89d8b92ba8f8f5d42e1befdf983ec0af1168394358e52edc88417ac9db6c6fd840dac63af091fd4833fd7800c4210f2ca19c25aa4e05e3c519db04170b82b6061a81f2e07ef67856fb3f0acd6f28612de77b71898d99d8cb33c49730b5bbee4d5911a0e4b6c79ab34a12fb396c9575ece9eaf7b258b79ec5d1781bb721f9046a8693fa7ac90316ee13dee99e7bd3526965ae573d9d9e8f2bc524cb7b21f11d31da7036123870eb311e6c98136827fc8bce2b2aa19058c63583e1dfd9adaf62e54cef2ef9f20fd712507a683dab7daa38e87b08298405673dc988c7e1d777bb9041960a5abbd2008b7819cf729d5c6e8a2318a066afffd98e7f9c98440135c51d4e981ff3f4f30b065df8528882dfa30cef497610f9758d727ffa08b7940a8ea38e4abfec99fbae2f90d23b44cfdb16485c7b3688e5e72992632683495f0fb8767bbd8ceb5c7ae3ab229b287c0ac9d8415f9197cd04e17392daaf40c22dbab8486055345a6719d5c542ffed35359e358f8941290ba9875238343abced1e11e1f05646485bd790ff7b1da0f66f6bebebd98fc57efd29711121fff5ca93ca55be28c03781df49ed259c7481e0b23dda36ca6c9f2100ce59142c5f8a4c0844ab2a505dcb96fc510d5625ecb19a0eb82a06255333c1b3e795767235127b7451e6649ea0161ed58fdb08f8dc2dae5d3b2a5015cf6e827ba35a95681cd7235a30e9ccf3d8f1f5fe6d752194c07325dab62bf25f8773c02b88c53cb3680ad8e23f763188485af1bfae465adbb4c8e4206e404cd90f28b13f0f4000c461f152a50357954624993a905816d235283bcb90fec530b0e96e2b2d7dbf17157ead0c7dd81ae1d0193adfc5b56193b01d5b41ac72fe214037286ec767ac33456430333791c87d985c0750e40e16a9c3f616e90141d11c94a5a68eff92770b2ddcf6ae25f32e87b4e378a28411b4de93c0136ebd46cee9588df4581eabc3bda650658b428a6a65db4beda0d26ae91b360e718ac595ac15a32edfd9e8ceedc984b28489cc777faa3e54447bf118c7f9012b806395bf4ce126e3635e11290c911b9aa48d6be92433040225ec797263eb2c332e24a6b45cc04967be1ef152e0b8e467b696eadd3f3ca726cf11ccf8d8480a96acb3e672adcf1bd2e860e1cf6bd8d3708241f919ea45a184b869c5c75fdd968460dde2ef6ecf8687cf499de9ad39f6db78e1d0abd3ecb737727ea22241528ea73d791054e73a7e1f806dcad2df155db49c4dbb34ef2b0d8b5753bcfc17f4484f7fa210a3ceaa8ac9ef68b44b347c1e3d69d6bb62e819beefe8434f8b5c46fdf7cde532f56cdd5eac9aee33258a1452b759efd3a35a575ffb0838bdf15c92266d8d03cfedae7ea7cb83ac00874b05cd5bcdd5e45c03f4625fbdabe0d80a3e3fb72bf904e7c995ef154f86fe90bdbc98ebd692e75dbf769549ff5c013479dcdaf2860e865a885a27bfd30c3de4a583cbdf2e22c28c1bef78b13b73df8a49f4ca07b43a9839759832611c02ace252bc770aacfe89e5dff7c714e7286eab40010ce5a0b3ae674e7965a64c734ee3648f000cac968f619c8deb7a843403aaf350ffff36b1cd16443e64c96869b0c2092eb2d3862bbc19c239723d8fc2ebe1330bb2d38d6cd05bdc08c167bb583a3c291eb361d311cfbe433243ab62e172a8ddaf5a8d6a8ce7294abacd96a4e53258d7071ff616a93c7cd7dd81bee0fca72150b4ffdd74bfeddc8ad207798b8e94b9a680b0989d0f45da04e4d57b5ad5c513792fe0976bc20aac9d613d330c2e73d5784b7a3261d84132fdfe2d019c52a35f6cc400c654fc359bc0f3a20881227d723bc4559247601a1c0eb6b08f29a4d8888d9e3c1d115f24b17cc8656d4d38f44186b2d0f2d9f08d263625dfbc78c75bc4d07caed9b8071df7838ab3cc06b43fd9f30a88e91a3ae01e0ef11f9feb0bb826163dde1a26c8981552b912c49b5b1a0e0c298c01805ec673739d74b6618da816f4fb2c1aae5631296ca6fbf01d33333e3d36f1a08dd94cdd8ba8a27843728e73f63d3d8c4a82a684ce5e81e1cb2e298d1cfafc4c33e6f3108da5f485165698164932d13f560682c6858bd9dbae19f71152be9d76603a5a6e1aa9c381e130a9464d45dff0d16e8e9e4a73860fa529f24ebe85daa650e7c0946bcfb259d922ea3f9e86369ffa69713ad00cba7dd82c5c96760fb6a0a824d2ed31c114c6e953cbedfbe06616f4e1a66396b0d02b0bf2376b533fa74707126234361691f8e698804047363ec13c317d5694a8e0608239399324efc0fe5d9d08c5c88ecf87cb23b272ce1dafcc9474e62ffc3b82a18263838d2f2209f883f435486e2db0fb4b66c390622133cd80c07b438931776a9c3a706536547353d1892de2d642c068fbedaf58b292ac989494984f8cd960512a66b2d7c1e577ad9e9f69979b07ff777db323f2766bb5adf748e75c90738ae65cac961a14fded24044d9293833d7b68b37f6015b57817d93651099a37f441c9b41f6c141971569b0365f6e2e95534adadeeae96082fd644966e10d345f7c4fd7db4c42120272b53b3a3b41b4b92af8c6f10af68218775569770b3de742854d14f6a204e3d81c10a60bc2457dcc9b91427475176e93fff552878badd6b5ae7da48ad8886b89b786d64181142998ff96fb4a87001b5a0254b33b85e06379bceb0704c08773f38ab253f04ce14df4b8d91f31dec55f5ce1fc2298b1196515b76c9081679ef624c1ea09cd8a3ff8e2fb22bc06fa40b38325ca837a029c2bf463e5c487d2086150887e701aed2e42fb257703e7c7911402e5a720717c9c23566dd81412a6abb55fb17e034eb8122f253b915e69aae19fa7100f4a00565e44895ca9231b9170fd208bc8fe7c02502db85dd6818d47f62e78d24abe878a0787ffb0fd92c891da3fdb18497da5ba14ed0ba14188fc0ad178afe2e97a0adacc7e436f8db1c184aa5a1ca70c80654c47f0066b1bd8a0dc74e767693c2f53e1ec070cf957e7910234d288f463aabc0807a50611379680e926232022200d9a7f8711555a4b73c4a1063adba43a2fe6e35a5507fe3ef8ef8d87fd431c5fe8e6792a821b5e7f3cf1b989da5e4b6bbfb94303005d473e8e670231d7338c69c85a8e79ad2310fb5c1bdc99d029a9b13c54d24b2c11d5eb856ba6e5fa3d057fb0ab3688bc192c2d44ce1b506e2e99f99094e3760f6198a319bd6e8321014ee5a51abd53e668177998bf729beb7aaef34d6e0de86edd4eb7143d283b39ae49331ca0f977b71a7043ca551b23091b5f56b3b378469269ed473038ff488a0e538b9f78c1cb6041520696bb1636af578853f0699d565ecaab90bec9d9018550614309c4dc68fc6dd70766a4e3b810b4e2e7da5b517b71fc7bc6b69e7d4fa854d3e894b57b863e17c55abbbc3196b784b4d6a5b12731099ab35ad48d800c07747e735a2049793bda95787c0fb27b1081eabfe732253690b2eba9000b33c4b20c7e85240342dc14f21501285063964c8828f0c87e4c572928e91b71e8f2e7a359c2ddfb003a975930c090a77cba46a6b9729cc42f8be5bf6547544206fb72b29d3f66f61561e364d9f1b981b94a8ab045bf9985341824873c06e26894a906adabcc68a2cd2d7fcd8405402bc6b93bd66d99ba77b268a3258d5acef4b0e59022d99598c23e70acd31d7daef9217404ae5b3932fb57f1a467ba86b7f050a214dcbcbf8943b3f528ce8f3b4d9012ee134b8f9bae9bdf729e59c68e08604eeb54633402df99f296a0bf187f4836bfdecfdb57e0de83925291ab3f87615d441bc11683506e21b80cb72f50ec8345d2b628e09e14a43c853794a8bf3570dd3fe76c363e53cd8f13742c932780ff17b20ae5e33465dac6afd25426aed48c63e19dc0d3a116f28281fe1a481791b87501831a29e33c6c60beca37c05a2160c261f57a9a4d4480ba854ce8d9faf50053cdc69e515c29c0570c73d87f5f1de7122c0be91e92f4e4132189ed635e129aec4eec751e7a2c2013dfc7c71b7ff9a504986ad65cf333ff1dfa8384e339cbd8b70aa4169b2ca334c3f2950b53466ac18d82ee7552aa6311e19ffa76de5a276b04a1891ae053f3d6610fdd8b9cfe7d007264f15f908585805f5177da0324e7d8a69aa95006d4b0b538916f6cab9aa9b231b707a481ef6ea858660ebf017f66704358a63a83d20f4c40eb0285c9c7d098dd3abff0c29a6b1b5e2d30f95fc608b6dc566566d3a8fb44058a4dbc091ce9a80d19180d5d866464763d5a7e3c60330df1b68901e2f83aebaf0263d6525da5e2ee9cbaf10ebc5ef0c2d8e98681838f6929af59a9d61ea3c5722ec709372a0023195cbf85bc2060f4b81856875b04de5b8605d1b5af6136ea72f04204c1303b71c4b62d075c6dd1a5bfcc27d4d0453b929c233ebb4763356c6db36c49b47ba3cec2290fbdbef479837d44967f4c962845686f23f11c7ffd329b8001771ff08a546e2a3363b19a8fb8fd7579f2da15cf82ab350c82a62856807ea7466fda4f9ecacfde1bd909516b6fa792a96a6e0ac1a59f9c62c9e3c63746da04023082ca4b5d50add9ca2175778ca1c6d71d478e3795e26fe537cee9419e779baeb40af0030026a844991a83842ee6cad27f4d30f3167a0cce25ac1b0871778b48665dec53fcadef5006207c985a8b697fe924b48690ebcf5be712f6794f9da78dc83b99c037c90ffef8c3015eee4725d23765df89dad93a8a7a485f8dbdd33dc5addc31c658b1e02057b9e27b68dad972187790a3e428d270a2b24aa6b64dc19496a93b5361a619976dd8b23f441283e1e3aa5a320e16edddebc97e35eea4b13de8244ce705d25ce37dc3897a50ec726e74819b1e73f98c8bdcf3df48e1aa25fcb47da53c869ced323bbb9e7fa6dd19cc4c70edef1d3c0ed2853314e34f510468eade4ffe4aef53c47802865bee25e0bfba076242b8b46842b1bceec1bb687f9b94e1ea5906c42bd5b0e3b10a19908d1629534cdaf7c47ced4db84a423ead0fa616e58dfb7e351d05d972be8c955f112779d5e281c4902057080db7d6ee66bbc8f76f79d0caf17acc70299236edf63090fac9a1940731bbd03bb5f36443ce2c106fdff0be19baff7dfb28d56ea888f98c1c4b8c0a45819ce506288cf4c5f4dd2540bc13e5d2c8b3b72c61fba74c215cdd7261f01b49ee67af9f0e24e6ef42b0a33a8592224f33e0405e5e694a6d5470bbd0bb097f216293a5d78c96989ef6faedefbc0d9ede83eaf6873a546697a066cdfa81f6f6d82201586bd3025438cef8859fc53739eada1f12f6260f53a7a8a3da759c2e770d8e986f21a45c258f1a1d06ec28c05846fa876504c979d97c89b6e2c3cca3f879a6c8fd43aa9ee548915c6b9e6c8d7901d2f521d8b9bf2d8b3dd7660b9370eea0ca8ccaf298a3436ea5500eab6f3fb10231cb0fe3a70569a30567f79e59146812e113bd71f7b4a0835a9308741ed8c2d57cfd268993561524e46d805da364b1126023ad7321551b98aa7f8d1949e96e03067ce99e007d0c01bf81f6060e1794e4d8b9a68f8c539a17e374b2c731c22afb1bb96aabfbc95d4a2b17af6d12c2943a6432a5fdfa829eda52d542053f960cc652966aac35747bb2b940be8ce733b7e3923337c69fa150bad8c390732dbda9cbe4ce5cf9063447b3fc991817770bd95f232493540cbe101c74eede628a7f20f7324b8eabed15a7d2ca2ff1d2aa3530d301105211d90ecd15df2391d8620bbfa988ea23f9c206cd668675748b0e35f35f2847d66782538eebe45d4b61f88a7cff1dac983e9c9da8b8d41a84dbb08ff8387d163bf667ca727907b05bc50cd1da06c1a7c8ad635497f66f9c37c4e5a7ab83507a7be902c04c153f558ec315eb6dd753c8e0f84a41829ec061c16a36d2c53c2ca81b216d696dc7b93742b50f1ed49a9bf9599e5ffcd05e6c8e89cb05b370bc824f00f4c0fd0643df6527b99dbca9bd4f3da8ba6bdc6ea9fd8145f5678082ad25297af806dae0ea5bb30144c8c7ba9c545bf8e4c14eec8b03f0f0094922b4eafa7d7bee0f9c7efa134e400f526d84506f501009d11ac30ab319f2fc6687641f7b18d6519f03ea4bdfbfb2bdd5c4224c8a8710900f74e83fd9f53685dfdf787e2948fd710616ae45de900924af758f9beb2e2c2d0bea04cd282bf37653276a0d4ce8a52d1a17f2f0fe6db2a50c8b90753040e91a2a7f70d77bdb9449804dab749aeecc9d2ccfc789ed03129d7967db28e6f5c0273ecf1fa7229112f866c6a91df1fc08cb2c909f4e909e73109b2290ec20265c0890011d7f65246db0292a253860c5dfdeaacc0ecfb8d4a1b109c705df00d8a6b87a0e70e550ae683a0a3c32ff53b538f22f8761a4f50aa2e93779348093dd4b7e77b7f75775ccdb98bed95b1100a9cf2b03f811e2f1691f263846e999b35caaffe316e507fb34aa022daa0458cd907ccb14d15902ec52d1efbbe3ceea42a844d02af44b0fd3c051e27836aee5873d68e5c085d62cd49a0e0cbc8f51358981d1b9e1a40485abd4b28e4033984872a7a2877d0878745b232c4e16ba238c92386c6e11db39938b67ac198ba2096475b445ca3c330f0e96a9d1d7bcaf2484d0a4417480a5944f1ac02d6730a2c5570937f57479dcad47c32cc151f39b3d84be47badb853490e586378f8fd36196443becb6fe4b63d38b4af72261e308f9a2450d3467e7bc8f85235c167c46797f5f433a5087bed85442033698ab091899e20ff4cc1ec02b92dbccbd6dc0d31eb6a583e514217e743f51b03709d63529524077c6b681248b667bda66a435148a07cb0028ff73b828bf4a739fcf04e42e170251411398bedd83e1c76b8e083041d21db30050e0a56502def6d7e87893ef6eadcb6d1516caef47eef29ff0ddefae5d35223a2d64b248b614620bebe889300d416c23701fb0a3d8f5aff1d238869746d04d6fd1468f85a79af8fbdfba4dfe0853a669477c3f8060426c33c3cd283e06e0742188eb0139b58786ca197cc6cd09219c08c0f9ab379e5a1932cd9e759d2e01c36f0049d119783f15f9ba8416896d2f5b1de4b56641726e5c42f8fe59d510bc6ef293ed18208976189284d3b2f2d06edd097831f61429476b0cd1104cdc973ec12f2859533aaef995c9207960b1dea9e3e2fcc0365dfb0e3bc2cd05d57f9c49561b5d33295d284c83f50967affe552bfadac23dfeb5d6d7c9e3809fef5cc08d6af88b122f6d8dcc38531c1aa6489f22ec18ba8ccbf7e39567c0fba0a2459e2ea718c0eae6b6518fedb066d05af7e7c8cc960e192fbd1b6804cb9933c0001152bbfbd570cdd11019998a8fdbbd62cb553b2745cd0766be5109d08970db726bac70b7f81927804a34a48d208a84e2e65865fa8ae5b58acead8de170850cbe2dfe90ab7c1f2ac10cd22a2375d3788520988dacfbf3e983b6f8fe0e6d7954b4a14cbe1b565c8567f1db54c4aaceb9becea76ae5448eb73d5f5030f9ccad5e6f25d837aa3e32dc6b411d053bf17fa823d69fa26c2f04f44fd0fc3fdd38279b7a6bb12005446a3d02afcea685ce14cdb4e988ae41f106d05d0c7ce266cd3ed68a5eb08dc4ca6820de52b8c01cd076d90965c409d0b4ea51f7cfffd4389d16ecdbf529b9d8a6eda53c5bc94652b573c389ef18d00b6c317de56f5ebcce663423391bbd52aacad589a527297b415f85412e08fc9064caedaf60d3cdfae5dc300f2386e015b7e6a52340a98e91720e91b323658f11c8095690603b459c21767002e7715dd4e75cd1d19ed14446432153e273b42358816bd30f04526a718e97f7f544656139d94bda512a6ce646d53ee2b7c7826eef1e9df31ea5a4e36a10ce69b35da0795043b1e27e3c9d5affeb80096802160843615a4bbbc9ccec1bbc6aeb658bebf1e5fa89bf7e84f80a0f1b1838bb4501e9b4295df090ed1a3213179d621d149daa22bf1a299db0cb23de9e0186acfb16ebb50937513514adcd9c0e0ee765226856385f9488c38e35edcb0dabdee81386f3356b91fa8d71809bf9836335fc93ae9a6c8766d17c1a1798b92aebab3c884ae7913e1e6b31eb5491197c4601788521a2236db3159329c67da0fdfbcad34f50b2732da3928e9f6eb06311c882e0d4c7aa5cc1322ce72e74e0fcf8b33f24683be46320e4c08a123d6e5920718111604b3d0b9ca18cfbc017a670610b4b4723fb9d2462d62edfd9151444bfd9e9364508931856a90d96610e187488de89769ae5a5355fa1159fd45dd819d79483fc77c862447f46c8b9e1a290d842b24a9450eea074c70cbc9bcabce68559e6463a4018b81bbda42e03f45aebc0edee1b973946c787edb90264cb9b9bdbcdb723e6eedd9e4bc62eb34fda910e4f4633b18295e02594b437509d03adbfdd06eca40731c2668bd6aefb4fcf75f535509c226089c9e80a0606a940cb1f4817aa72a50051f17eb90c8c97ac5172b26b630d62fc75cece9ed0e95ea04cc3be5e7948f5092bc9795edc103b56a3cee72639d511f9de4e795b4ee2ffe82992f1f8d45a7e17ab700578ab5e3fe641f5725858187bae582a759f32faf66f0d8326a22342b79c64b383faa6532d98a5d28b93851e949f8a89367d637d5e97c3ef4ea698653016b32d1217f115c12c0d7a3139f07c21fa8dd8a34b233cd892a4882d03e261c396fa9291d3a870d5962135a5d0df44ca991b9b58983d5338dab7668d1db89d40b0ed37459ec7ab08246112f5b1d855cb4171f06ad445e5ff809253ce831f03fe9ac50ced1c28422868f44ebaef6de0209fc66ba24b178f2d64d1c8f6c7e5c9aff0dc62362e87f9f784809dac6608d65612a976101f3ab73ba8311e9af485d02369ef7b7bdf31668cfc97ad82a3932bdffa807b9df7d6e3b573c2cb372274bad89135cf915d8f17abb5b560b8fb1af5b2a284aad26e05c38750533793b43bd8a3da6c7edb0472f3742253f9472a5f0a0fb84dab4ba724ffbdf95a132b661e34e7fa61d3ca0e0c475b1238f14684ca994e45a14f54c88f8e7426448237b77d0c44c295a43e1184bcb21c10d340ff13b37b8e3348a9da323bf38df35037d4f25c47e60ea0759cead090623125ce0953edf1f0b2dd622562bb3e467f40eb3e6de65ad5a1937017b173b9b56ed309d538281c755860a99a31d94d37e6ddd9a42046e6f56a7bc714bf474aa3e08fc99735c5a26ba5596d6f61d9893ff106be0043fb482158702113e04c468306ba7f826f296fa8fe5b1fc9efcb87f09bed2533f035d0fc0cf1a6ef13a8b3430eea9d09c4f285e735b75bf3694b63b773c9e89acf748c2ffa1d05ef4001e82d7fd66dce71db6c5f038f9ed184822c8aebd4793e7ca9321fd74325018e6728e3aea7fd05ac010ffa5165204f831fbaa91aca3d5cce9a051cf50f864b08a86f8b7f8fc4fe19a28804c00be134b448d65e89cc0b24cbaeca37c60247da2a38f6f18cfa321de7ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
