<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"328e35d3134627c947bf7aca5c7b9968320be8b94011d4234ba79e814b9f36b92becd6d42365f3dc4435bcdff087255667262f0890b9d21e0a54ff696b7e2dcbe778d7bd30ad7d29bf69b6a19c5f1184d54d883a47132bef7c708c4e3379dc8091535936be2896b68bf06dd8597a90925d227a30e6d09ee544e1a61705c4f2672c7650593a53a4dd4001785af1343cf21aad177f3417c0819ae9aa810f3c6664d57bb7ee7ee361943985853a421533c4e6b67bc345dfa382bd62cb66f34f13148b8e5e289e0438cb690d5e3aa66cbc4e1eda69e7aae1711fe32d422d477f87d64357550d358a6f2ef336ebd4f0124d3ba9aa8c0a2cbc144dea24a5a2883b62cdbcc1be79cb4f70abf4185fbb543de3145a71f5a9e15bc5ff120a5db0b1595d4d47484b2640e9730f3eb07b49b4516419ddb557171c3e8016613811c3c97c94b1c8fef5d4ddd66acb4dd30c69d6ab462b91f4cfd35ba9443631235e29a11ba20ddfee64a6364634b0b65eef49cef8807a6608b4009223ca9dc44fc5e2d37d4e1c31cee215827c57e970190ed3d90c5bbd7c3ea512168325860f9ef4466174fa0039db53425ee91f86217cd9b10f13247ad109e34619f6e19c458d20a63a6ba3e2bbc43d9384d201d0a2830f13334eea2ce8898598d36a75bd954d23a08c45835b72ab21b12f80a3406cd33e7dc13b80aa477dba4732bc64344d034295a7d66dc0db1d960fe97517395458c4425444d594435b6b84ec96408787f71e5f13540ef9b99dd676e0b5ddb9cd5a7ffd4f4403175ae6468bb15005de5045747eabb30e2305b438a1885571f95d22363a83bc33a077b29ba999f03eb358e8ea7130837a058b24dbafb68b0c86ad123d1b00c1ed5a73b3d0b65464c4129cac1a998bee7a20c8154f77c5d98eab5cf0bed93683779207c8e9ac27954b2d96bedd475e017fe3d079747aa8979090fdb2bc79d6019def2059c2eb21f1cbc9e7856b4b469acec8684b4544c9705942c533206dd5bcdab20de8c8c08bf11e69c0c7671812c7fcc0674c774edbed92ad52b5cc5a212b28ba172864f74c6ceac538129454b90f06c269bdf5fe0e50d08702d24e564f09f0e1b01396139efedeaa1c3bcf6d5a228ed710ab7968253855d5a6096a51fea0185786427c8535b239217145408de90a2b261cb3423740c2ee223388da1f12afa29b7e362a08bab70941ef274bedb880046354aca314e6383c9b6fee7f696ddf58e0f660d1325c24b06af4f97cfb0c1961b40611a0550d8b997b1c18c73e1b59d470199b728921b027d08369e0cb862af25d8fcccc4fcfe8dd4bf803878a6c73ddf48d13b3f5e1ccd40ae75b6db942e6c902b5f122fcb3de3708521578e16e61c6a184d8a667d3c727a191baa866db6d2e29b683324c65d8a426bed7de716b35f7b8f2ca0c8497014d496e8ba82627ae6ad74f9ee782ca2e67843fd4b2a57ecdaa45d927b790dde65f0823231a3e293e163bbe56e4065aeb8a5d7f4830c4e03b101b4f43915a1ef4eb3e6cbc7313fb35413f5078225185d8adc2b3ba7629017f5109a90d08514b25e5be52afb47c3af17054bae0407638db085a973ba7ab72f0ff8f0e451d81877b8b428780c66edc3bac3677cdf6980fe716ecf93caef023c04c958bb7b74f06375171ccf6444f07edb19a436a4030629532f5892c81ab295f54d7dd1d91a664931e424e1fb5aff46d46cb5aaf17f783a5bf6e19e73e082ec684b533049c23893f6d7a0de53e21075b4c6c2d07b2bef6e24a765dc5f48ca1ab4746aba2bc6cf40f58b90780240863a3a79b1b2e8df67b6af6233ee2859f7fc7acdc97806cd0616a3e1e1382e5799a2c865ae7190912c89b844edc67ef4e4c79c5497981e5c8047520e9b5ce554ef93a631a19da1962c9f3e98aa538fbc7243fa03cdf8abb09dbf575ff450456db0a9dc863b2758b5fc37c3afd673d3f6c7bbac541dfd5e6cba1a538307358e3e311733c2e05eaac2175a4481ae4561a4bb97078f53b7f29880d8b4874030b658a0bc2260ca416b9429b834c528bbe4dcd5a78407435731e5788fc76b746638c7041a858d739d165f2c0bc863a2039316115c3b9e3aee89510edb1d66c02ce18c15d76fb0990c1198ca6611a207a9a30fcc13e85086952d7b3a6d29cd54c3dc5ea63b9aafc25b39f572b034163a14854994a64537386660419a32aa778536c62172dfcf6443d509aaca827cc1b835c4335971e9f7235dc97e9cd550117e538a48382c60a92deb9c3b5ba057f83172a546702ee41b9a4eb76db575d817b4f4da1dc3f6568c7b8d3a64d4d05db637b311d615eab17f7363d40e3e285405e805a2c69400b5f0e6bad805d1d77e0c177291258447c0c95f74f5d612bb28aec0a502c5fa3383b40b2bcc437afd7d127a9a39bf7a0fc76d6aef77aa454d3cb4af978d049fa853fccca4cd32cf93dd02dab5a7fff6ed0fc8498d63409f4ddc7cfe5606f490b0b0867b7f9d1eb4bc47312581fa19e8071e54a0d1763bcb6f3c2157eca64e2465ec9ed355f076bf5f96dd11c30a9da77acbd3be5b74a6de1db3d32423f8e59e50917f03976ce393829a242d3d96a2922bc0b730f00b192573d00e0f6d50bf99fbad1646d549199f7c614f55f49f4cd2e111bd30e45e068890995f42af9a7d58dafc2c98ba80b22e2b1b9677f414395a37856950204e5315c4337eccb618702a03bfb1ef77d2647e75a5c27b2cfdfde8d8d441e7a2dd26be9f7d49ef5f3f54d8d583edaab9a22527803b065136a4710fd999afd36533bbd34fe0c8485fee07d221416665436a9bf163c8f05c9ef9b9ebd3e0525c4419075e1701c7d950bf21e8320f19ab38693cff5f475748dfc567d847b2552d588809ce5d76974322a568d4d404a81ba710eb77cb86fea32b867bb0a07ed62a4e4d135ba1e334b1595a61e04c9e53c034f9c4fc4334a549f8abd86b48ab94687cc5d1dc1f5a1e85dd8f3fc1d7183bc7fc48ab3b563d6d10c319a9e8a248e7abee26a53b609504f5a943dde6c9cf28ab5cbc0a798fae474da5efa152ccc6a93611ce83913e688e72675b0ef2380ed114e697cd888365c550fa8b2b7cc9f4989d5b9f1549119779caed58e95eefe7f8d77a429ca9f98b5457d1d16b9f230ebdca4e22dba8c47d5dc1c8c5f15f53371bbc1665bc114a86fb72ee1480f815d09c8afdcda4177bb6a920e5f760b39f39042f34942f792b7b3b7bb62c2a3889aa69f5d0aeca55e9fcb725e63beab57cb4f3a8013a974e7664ea2d0ce7411696d46b821ea71971bc32b1a0d3cb127bcbbfc121a5d9ac4305c166251cf01d2724c47c25f0087dba0d3eb2f4a84bba224d24b3ab485ea4c8882a28b7a53223a42e55268468e599fb7ccb3c7de82851e3ebd03a7f2aff1d231816eab152829969e9c1dac39181a17cc2f0604b5cb9d42eff873dc77c50fb2bf00ed19ddb6735077a86359071e68c28da508e20503be4e9a12a02982f0d9384c64460bdff30ae9e02dd89af8247bcc11adab8f928c92d6f2df2264b6c4d49f85ecc35e98b6c35e2a48238bfdf3fb94777fb15869d155acae5fd92bc7b24b3098f4dc2158010d3022d38edd7c5b409378341f05b89efe14f63cc7225d90a84ac393b7e535fe88819c4d7f995a3408cd2d1c4beb80aaf022a25a20a660a166fd053dba7f5c6576eed7b2d6fbeed67e43a2b8fc0ab73f081a56a7978dff1f214de43849e1b70bb2ee88cb170b87c8f0047db1e920e3107eb280968de34e2dc59bba3840a00e31a11347962c5d7c1b042a4a82d8fbb265fc64fcf3db7639738c445192ddf07b12e3db2de396df40e43f7ac370e6b015be9884880c4c521be06a42d775b9a4f934e35150ac3ff45ab3811d2be6f66c3fb4c483b828d12ef25cbeb040bb5ce12a9a3acc24a5f370b06c5ca2131522a2e3fee91b9c45bdfc7ccbb760ebc2f118f77f8ce093127f4e6d4cb57d486065680170b1cef39ec22d03951b16621d8a30b1139e5f5aaed113e7e7e5e371dfe69401f8cfdf04d6b063c123886ecac308c6f0f1c2d9caad9ca7700cd5c7bae074769f93341fef8bf9d26a473aa4c1f662253fa6190ce9929f4ae3dbaf9247bf260ac58390e95d7e67db1c633e569069cc7d15345f20494cbe03a2addfdce260ed721ad90e8bc3d43399aecae02de873af8e0fcd990fb3a8e87748bbcd9634556153e4ba530373b7592e1e30a16f1522bb929d2aacac8433c4c26dfce632e052784c811eb5eb841bd92044cc96049b046e5062fd4d511fa67f9de987da6664166107c92e08f640ca3e0a03832b84f9fdb1239a7a33aa4dd1b7499261fde5acf92ddeb3891125031e915f33ef7a318a624081030bda782ba3ba4f47ef7409613045dd1e34c56dfd29232aa6c410bd0315b9c3fd0b46a61fad03ac715fb0ff8645a178c879168cd0bbc33c3646e757da05bd4491990069cd5b65efa85822db68091aed5146ab734e18fb89d80016df226b9f08bd7a78220f871d862219acb9f04b79a54bd254426507247765bce3ca33b1966ee72a2bb80aca514cc05a79e57c0abd9550ac5c5176abd75f4f84983aa94661613cb5254f9dfc57035e76c07322372df98ad8957aa8f2b48a4b4d3bf98f996b289fbf7bc39c1ddf9fd027648be024fe0554d27aa4d9ef4c4ffb2ff9bf89c1a4d26dfbb832754797ab1acbd265ad8aefde36bf73344d1780b1e7df860150f699305ca4837a59023eba7250903208c21e10680dc97b05c018369de343e514dbe6a0c9ccfb57d0c2e0600d711284fec3a395342f9ed19aab3eeec8224093fbb0c40de5a937f544169a082bf719ec83bdb36e3255ce7650735972d33c8496f54ff627a37babd56cc2e8948a39f571a72f73c3ee905600544cb93d2455a237c275971297212bdad883401cd156516cf4994906f3bd905aa626fa471338071f79635424b8ba3f6064a37c8be6a32d6482ee342fa6d4f9078a890d84275bf6dd8be82a84f93d7755d35868eeb3f7e368c7cc4786bec870a5e344bb9c86d4969ac47c46078b3efecc8da7ce29b7a253bcf40d2cf978cf6d6a2a3151d9c7be8eee08a1cc3faa635ff37926cf4c25640a06b6ea0aa278cd3786c1a2164bdbbb2040415e6e76873be3df8a8d328e7e8108fae91e8916ecc0b6b00064552f5b340d6fb6181d248907e6f6b77fc9179cb6c227b7aeb9585cf1c6a25210b4673214fa6cea242918990c6d0f61473ee66b82287d5bd1406da0a34ab34ccc6806df87ee53a56dfd94da4d21920f4322262700503c0e581d9ab89e8293622c9c2d543ed895c88ebcccd26d3756303997f8b4676023dba366c1bff77d4abb6330504107e638f6e73faf13aee46e1e0e8716f680050fff466d7a1335f05c32e4fe4b8458cb997f5cfd36955cd2dbcaeaf840ab9e7efad0fac13e6446ede88a52f4757b39de6c9e888d87243328ee8a51c18c68658f938febf2d8e4b2236a47ceab3cab38ad590247fa2d783c5bf8e1bacf2ff13a1ffa646060c9285f41b8a777907cb7f6eb1fc03d197804c7da7de8a62e91ac1050f5edbc58df9bbaf6b8670c00b0e386bf31a283fac6d3e40c6ed1bf0222e1610d885f0c788e4d2b73aab5b069760a5db52f8a35e63477804fe219680b5000770c6cd1fb3ede2f35d5dbc84a4d67bd6f8f874810fe6b13b3da81a78bd058886835512b6372d1d4d6bf1a2867c6cc891c38ef248185a2bf475d44ae327f324981bc92ed4ee4d1bbd07ecc0b79b3895ec8c27d2b8ee21052c492960486d8a25d1232ea78f8cbf4588f7539ba9f4d27cdb3735960804086097eef432b140d96ac8e2831d77959959283ff706477d5f48d54905f65b07848b31143038c8c9ea0666ba1537b2cc5a139eeb4c2d96a2916b8ce952aee196983588809231bf3b12210b73199242df0c036a17e46eb40b9213fbfde137f6b5386df08201030c788c3ffc1ecc7c56aa159e2ca90cbf5a1df80d31ca7d5c25d717f5ccc1ce710060ca534b11988b4da72a2a99c93ae7a790fc35e6707b9929db8ba3ebefc3fd0b916759a22b8e4062dfe28e67551a7f72fd7e70296258793c0214a712a6ac0465297cb40d581eace85406b7aa57afb46fd165931db93b82339981c815875541c2e0092c1006a4675852d18190030410d3cbffa252fb325362b41a23ee729d672df48392c04282b5443d179150f05d38058ddbb42a003e95a468c8e9dbbaead156960aa004894517d54a037a66a2e775a73a2292ea355f88892baf65dffea307dc1b32be8264fcafebee83aaba157b29063c5ee615bd4a88ff3c767d4ac6e30b373750bc7e74e9458f2426a685447f834be153430dbeb21c18795fc271a6d0dfa3332e76fcc006f6243ecada8bdac1ceb1d9e032d85e27deb2497c0d20adf7652e73c4ec4d8a6d6e2c486f35ba48153d7bf28bca143a1a346b7df0abe65f5d15f614921a28df83edf7cfabd5606de6692f5b45531455624ece3a037343abd2a5e94c1bc61598769a59a1c55d4ba6bc2762db10e23c63bd392a168b6e778dc8d3abc2f269562aa0aba9b96e571668828a7f6d6902af824d6e61feb2c8dc7274738409bb3f50efd55d0b218489696241d09db19485296e701246b69ba00910b31b2e1d5af326cce306a11b60f77e30f2366a78522bdc3ec07e984bd1c4da6b9fc8abc92e1bde4628da4fe81296fd3825345f354416c08f392d291c6600f44da2c0bd11aa65f24086c123752d3f042f95bf0dc788a1e2bf8291360b505abceabb22f3340dc2338e7a6e083a2a22555d94b1d5f2144732ccff5767bbe645fed9c34a6e45a9086fa42692bcb448a921273b2a747636deddf57a81bda5fce36030b72ef5e8a7c2df274ec94c3bf76bf0ccfee8b90504c71b5694015d4c0bc89ce0c94e7657bca4b5433d129c95522fb6e4bc07356c501399d028104d6e4246e2707a976e6428b4fd8a03af071d6418d20144dbdb52892cc1497865299a2a79f24e04f0fd4b42f4c7c733e2a374ccd17688f188a21cc77efcfc170891c50ea3f3a11dd7ff7294c7ac2a30b0444c830311bc2bc14c2d7d9077b400d31c414e89313383fb2341df65f73cb2e42b54e267e46288928fc2b2eb504fb88fd5d8860944d62127972f410405461ef7741f1c5935850e66447733d0eacc765ef5155f9b07de2ae6fe648460e0dcbb40ce71e9ac14a05243e9d40be05e67fd7f3e52678ef4ce1efa4a356ce037be45240189d7c9383b8b840f8fb42ba641fde4f042bfa91d93400398d9aec2ed21e3b3941ae94c1e23dda357ab84795aebbde721ca2acbe0e1e42321edda46d8b20a8d8112bc2f471397ab69939e8df9adb09a8d2afb72de7c2c0e72efb98691271f6beece437b44a2fd969967100fb048fa52e3b0390da7a7d1c669f7268aa16970135420fd5b60242900beeb42cbfc7ef3a2b94c26c3d95a21ea2696b6cc114b0b6cbd1da286d22e25417e27cec657f0aed63593f90020c030d5b564e956b6b7abfe88e30e142334bf4d9f0ffdd734cdef82ee49bc9c971e56130e6a0a381d4dd65d9e913d47e891e0b506a3f58d5162a83d59b6383a58d5b27bc158e56dcb06ba0c1d7008251d64a6781bf519f31874bdd5591986b1808695465afe8713b3662e102f56f2a70f1859a71bd2e1230c8b55a004cf2780d6e98c12c33f806394f93719618f7c707342d9a18dce8d8f832688afbef877e0282e38fbce4490c57a061e1af4c3777ef9a179540c2841a048c49d4d3bb201a135fde986c19339aeaf1da2070a9d3cfeaeeaf8b682200b320009ab28df00a7a6037ac95fdafe490dc59bae6f5eef82a3171b396f78915cca6e4194641245c73341e47d38e79aa2438051c1f37d4a58695f85a5db9d97a38dfc119b5fdeeb2830de57b4a394414e4d8bd415255edc113e4fa95cf20bbe0c3b8fadd5b729db5fd650e5cbb6629d414c044173a4ffceb288e08b0c05d05ce05b732e47eaeee26d9f3fc9a6cd13d3d8b418b7bf444c54490423e5f9679fccb4720caf97a80abd9cde097d321896e05f3f27f79ca40d26741ef7c22fc67b5027067defb1a90f837a140ba780077bfcdbfae5ff4a0838df32c9a677256e6c9c68e602de4f53bd25d5a00f36c7b8b515f28e65862ef277a8e132f83fe836dd28351a909c9c324dd2b3f84faa1d0597aceaf3893e9048dfb19aeedd54ca1d521a428bbe393f5d9d209ff91fcd355fb090e5e3d11c280cd2dce1904e46abbcf237e83f0502dc4a9f82af1045fd9e03ba9f7479f83cba1f182f566d173690cabd3d5a702e36a0a3e4eebed135cad5d0e7b5c9e6471ecc2121f9f50b75b93cfce2fc403c55529bcd22d0811480b3249caf6c9a73db47046e0482dd67167ccc7123ab9f2525914d8c177d8c2c45ba0afcc777bea1641b81984d0414d615bc7c8e50b0fb5fe9c302e79c43cb604fbb662a70b43643663fe03e6e90daaf3179aed7bfa1b889751e31c91706b2600a361d55c845f42af7f4f07f2d3458202a66ea57267478bd85824260a737ac8325a01b21b38caced309b7c9959b4db1ac09b08a475f1d1d78b20cceab1167ecfe9e13f47461fc399d6179cf08dbc7c8ddeb0ea37daafb6bd13beb78f4989ba2a0c08b5335a3b6374274f82781cef48f3a2939b304933660fd0cf8ba61a0f1e7ec2d8778eeb92aeabf15cf98cc65d0e50843ca018bac5703d69d217def10cbf0731c9b78f0b22f7b4dc8224b628e89c197ad1a9d8bba8094c3963fc8ed8011a0d91a21c5738e79183f271a43e2cb89d8334e7ea4c1006b68a515a584948398c70818bffdc6f9cc90161fc9b988e3189860c90b0fd3b610b56e1ef2d18d4d711880273e8997550a906a39193a3eb103ef23060a9e8266d92aed6d4571ab3c45f1223014a0f2bcd1a13b94f8245760dc30b5b7f46e6d631d40c37ac4cd841e1744b2091785c6d3a979aeec2cdf9a209466ebda79911642af6c31657264a15617f125a5a9e67641fe1260d8fc26d7bbce08e4fe0b1126c5f00fcfa466dcad0d8f9acbb6b5a4c80df048efd0fc6b329ae1c49fa6289b4b8de762c84d763e0166dada3e384fc2b9f0f0cb9236b8fc7beeb8595de98140fbc6e8f78a8a4defdd6ac0a19578b415b1b0dad57fac5d7a64993d7542e39f2ff2a87ae89174991258fa2b643687bb2689793d3727740a6fe33a4bff940461df8e4ff6efd998cdede7d7865dfd1ff63b566b4c0ff577c3b5cb21a810e0683f50bcfe99ce195dfa135bc608a85e01181e9e1d0e886a0922890798f2bf77b7abcf4aa37144ba00f36baf2909843101fa26e320be9a7bdda5798e850ccae394de9f1ae5276f6eb0ad6c8e9ff084a4993e93ce21f68492e7d8d1f365d4ae1574c3188cf17e703da38614c37cf07aed5f904d76239a0bd085a68251fb617370a3ea275b731c6d8c6f9703483318b9d9e8606a5552e884d61bd3f278770872c2162ae199c14fce63e6b6411834292885d30312611befe78ebc8949acc73083e3db9fa6a30c5a6cad0f94c9d2076ca0343b384dbb8b96a5bd1195486a4c17f7eb1202072beca9e45ca3a01fb700d070b664e85635f8767862b27cc77df94aeabc16c24b6dee921aadca435574b86a8a3f0035c68b2a1354444973fd151fdc31b0992a7ae310a73829832b021d0bb48b3d9baa813de5daa2fc01b0f674753d80a15483a0e8b2b4bc2233863692d455ffc1251cb79055bf72e5c3bd23b794eb9a5970a5faeffd2b61a5f5b75d590f09661e2ee6d790d773716548153c645c8498865d9e6486567e2655505fb7f725b66750ba4101d8272bbe30d8f70f02bd0a71511d59ceacc4851356e2f88aae0064d1866de7cea5287aff430a68d1e4b1b8aef05b6e0c8b4a45c175633e22e370893c383b55fb527bc1ada2968485627b1cd3b548ab63aaa7621261cdb1745eaba4cb045644c5a81fb9f1561bd4d44c7a09df845c5281eb6c937aeb44495f5de7b09062a4ff89ddd9ca74eec9d963157aeb1d4aa2ef9abfb730299e328e02f7eb7ddede479dfc932f728bf80139405ba499ccdf22830b1484b6b53634d9cc9d5f7310d123ed397a16a07b6b0f79d5987e664d2ad65c70bf5db15c32bca29e2d640c043172001956158399d69bb23d3bfa05c64addd4f465766b5122c87450b7abc37ba5f2807ba690e7aecc70c32088b4e79fd3e074a8302cebb9bd1098c992f16fd83372561011d6fdc3c17b750847e5139e5cb7fcaf72e085ebd976824e7e6d4663cae66263f133a3b6de07734cea57ccccbb59ce58320153dcfdeb8225fca74fa1e17926b153a657fdd81f8903a4c07b31142c121c2a9fdd88d13897481eeb6d8c0f81e49cd60613de1bc6e2b06ea3472cf82f641d9b6d9928e895744446388f6deaf84b5c5bc0f3d4347bee498514be454660faecd949c21f4d3aea6d026a1bc9d924f1a0349d5f2066e143c6c2ea5facb5cad79105ea6a4f10d840fdf5a42cfd9ac11961af43393624e2fe01d663a502e216906707005ef3c42978b47c83d9a1f2cd9bff160ca1e30a004709407c8a92c70e827504050e72755ec47033ec9900bd3949449939519a4de01cc45965f87f5100a28a8069d398fa4ef3faebbb35a08ae6bb8ed0a962de71ddfd50020ef4d5a82ad23091825a4473b682b9d5c1ee57e73376373cc83ea5e00dd13329705bdef65018c675cf925326bec7aa4d5122c67093b507bbd6b5ec6acb52de11dd7ca230fac3a31b88d7a3829650bd9a801f98b531a9dc4d28aecb108f979e66996ae92e2eb3de23a00406ba373e6b74b4eb8fb0213e5e6cd5296a6ed124802ae4285060daa8bc64c9715bf6c68ef24279b02ca5fba0b36db5f6c810f6a6191a38577aaf6ad2c32e82a40598643d58547bf7e24ed6819cef225429bec89a89f7e622dc106c8a46f13bf354b6bf4709614635c809f51310c9779d955da5a6a43cb65257ca2f5083ef75c571a106249a720b453947e0412e917aa527ed45f4b1ab494353ef62e6eff217c90f7d1809cbba3f03397eaa84423d81b8b8456450564ca19ded8b3dd90d39a64cd1987863c06b0edbdbb9224988a1531937837b312448f854360b1200e5f3f0f33fdc40afe6745bdda7c7ece062d22b88ba540361dfa8d1c125ce9c6f40416e588f19f2c4e35684c8fab9040dd7ba7f4acb96348c4f2b82a01352ed0b5fadff46dc8cf91fe53997e24a5ecd97a9e95a61c5c59c9941d134846e75fce22ed0e118c701cc5492f811576935d35d117af5590d27a2afe9107af5cf3e55c51344091a65247cc6c41d24e48765da8e2c05f42c545606fe9796d1cf5b4ee6fd9c8408fe63bf0144cb52b098a85a9abb4b9d2bbdbf09e3a76ca794f288978b7a4bbcda40ef376de27b337cd46f86647d2cc0c424d55cdb9907748157403d76c7a391cf8c807de5eeca0410f966ad2a36e80670bb0b8ed7ed553c815cc9fbf262e2e121b04f91d2442df3226425993e0fa508bda10bbda74f1a048869a0ba58d4e0e80fe7e1fd25e71b0007a2a4f2823d9a7853bfee3961ae1c5dd6634f0302f1d977a876989415bae77dbcdccfc83e6cd0195eb3cebc2232ee731006b0f183c295dbab191ff8dcd6ca4591b816c91e94228e2f24b3f16e5bac72c4c4178d8cbf61fd21ab1b1e21495ffdbf14274d55146e89fe3c00a57a0471988c01878471a39dae671e825cd93883a0f1f80ddbfc43f79ebc3b5e297960692c303d454105044165e1c9fb0a1c1f0d63f58fec690fff846a0b8af98d331442f94b59b60e2ce4b4ce76dcb15a48de25379971c70471b6eaad0db33eaa876ef63840c85318306cb078db23d6cedac34c05a54dcb5b62a108fead6e19dee03fbeb1ff8229e3ea1a6d384336313431ec960a29022646b643b756ed146c71e22ab1e8c4290000aded8a3bc9e43fc90ac4c87cd7a68b8dd7aa18521fdd63c22e2d03282a4ca7c17136c90a2881db6592805e0191efec8013691494c435a3636724e0a4ead881a2001acafc5c61a9f3dc21b2181b15bb3faafc3a1cedc52754d6642ee7d920ab63c894117e274edbeb15b6fd3b699c5e8a6d74bea2d12d667e10ce2ad9551caf265f24c351913c892116e00ef95e299602453a7b508cbc6731d1d0b0857da1e6e325dcf80a79491afc982ecc298634be876625d86ae4ed4274738fd3e0f7cc7d518842a40a7df07eb83d621f387f5ec8bb2a003745d49c1a00adf021c074b4bf669ae951188100bd69f4037136376378bc6cd526dd12dd93a4afa0cb2f280dac52cb096254750e513c35baa55f6d6e1bd71ffe725b1c24d13342ea3862108853deaa8ba9b5ca523c518c9ee17760969dac27d6d4bb7d45e319c5ba7eae2d632c8bb1e82321e9c86385933f314f1be240efdfb8496ba8469b352b140e85dad5b15020fc13d4f275889fa76917713b320216c017bdb29368172981077d94d523759573e64cec9180e74f9f4455910250a14a8d7a65837c6caf24c2e08fa1e4a60786176e22ea796b8b8f7bb16fec5e8b018e4af313ebc9c955971e05cae906b388177489257acaf489efd1682c86de4f35f360ac94e1c0e5cf4bf37cf500f66ddd3adbfd22f364bcc4507875b99967f021f30a9666321caa9977bf65815949092501a9086f136603b942fc8ca4d60d2d63d12defa283dd168801e36db3dd590bbc74df70e1be0d3a647f4aa0eae7b6ae6bf672d37445d972987b133098b64c0a97941ae4f3414df22c6adec8472d7c397ce234d5ab602d1cb03f3634d984642e0421014011915780134bc39347e8d9da9d7999e10d253b5f86829119446f0211e87dbe5fa60f5b2a3d0a70be16ca0e9e0e8fc530ee38b15aa2b1716b005aa1fad639d0465c1b13f17e1d0c018c5ece829bcf653d791cf5da1360dd0186ba4d08815f09de55416dab5bb7ad3923b364b560ef7a5c1c4c998c3202813f2d64ab9d5f0b5441330676d4de544429c1724a1e32752c9afa2ec7b1752625f07deb7108e4d47dbdc412929563c3e4e1f1ba313184efb58be831ad8be4b90ba4016ddd0ab887e31aa94fcb8efca105412c0b94e47085f9635a3a5092da97af398ec7626e8e84c9b6128599d412d89ce97d276cba0298f189f7c86ad1b8535fa0d52977eb2ca04e6be940ba689f1ae5dde096e387d73ffe59bacf0c63e4763c1d3f92d9909d680531b3148164a4ba39ffb475c909d2e02388c9fc542695f433d8c01b3886dc3a3cf8416cdb694b3b0a3f73e440dee667f958fe47f77116702d14c25667278908e466b5d869cfe1da8f9fa1296eab455454e03dace574f051885d509f4f6acfa605ff79828842ec91b6b84b45f017b9b5eb98df112ab01617428c30e321333fb2260cf107f5fcac83af9792affef403cac69d598dd71a55d36efba1b56ad2874b578e9ed15fab22647f699cfd6de53bb7dff3ef00a402a7e23819061e858938f453aa4896c8da73bedccf8d754b301d5d932a783af2bd45c00b924960f05d523b30682a6ceea7afb5a70e9182261c073f370b7f17142436c066b9e26bbc656980ee1d6aa985cf0ba9ed788e91b7a27ec428ad258848372c6ce190ed6d6ed7d8d60b17312c9a947a88a7b39479ce980b1d4b6be4e3411138045b7206b110982b04ce806be242a9696d2af8de8691de5585715daf7c8851fc4591552abced11793e9cf96d20592f5854a81bfb327012cf5d68ea7ad5823067c27defdabe67c4bfe8b06e02dfd33c5a286291de8925008605c56cb5f3a8d377daa3b920b4ed8e269487bc6bd2b92313fa2a93a1eb062b2053c21a65e2acc8b0ac411557b68a18c72cf6978529807179187ee6495d882c38a05bebd946e36381ebdb3dd8bfc717acdb928a98d6a62c4127f559ebdfe7fd70cda827a2999d528f18d85a107b7e72b00f0bb331d6d2d2bc702630f969277a63d833d4d3b09412405edac8ae897f9366e3f3e6f63f0bd61ca0b518eafdbad7404a024a7fbc5b2f19c698042f19d6ff67e079b57811ad1cc9a7a236d2955cf3911a5cafb85a78519ae8a93f05ffd70e76360ae53d7e15afc2b792978d04097231414d5c9558b25d0fe581d2efb6ed6e512fa4af3c42a2e886a26853ceb6e26a48bae58037276efb75b9c8d1943f161704474487b021d5dc8c3efe4ac6ac4edc5cd8e526b0243d45f428358a576ae67a4013b04927123fa5eec5ba336f7b49ce7af20878842670fbf023d6b8b91d7d8173175b82cc5c4c11edd8395e00fa5d7c1b83fedd6545b1ec1dfea18d53f5fda7afe877634b9825ca492593f05d26db89bb1af311dafd42b4dae261cf3195556af0497b91e8b663181eb7f16917ab981957bd2440a3b4a48922671614ddf91cb568a1fad304270549f7940ecba023bda5b9ff34b571a1a5f808dc066aabd579c369142ac0a4f0fedd524c9ac879980b9a0000eead161ecac189685c8ff687ce8d3718650e207e3b17f676c402cbe57e63f85f321ff2fba621ec740de9783c07b9955667355ecb924c1e07be541929a92d9ed196d9e2bb637107622f7cddd687d08db1d3c0e7b4a6764a19212af31a1e0e599cc94f2cec81fbe9f70535727028e1b03bcfdc7324ed032fbbe0b524571887ceec5b25c38ac35f0f17af9a648e5f9258b56d7dc0bdb6bec439906bab7a466a7c27522fffaa7b61cd19b111687d30b72962adffd238315633c48e9360011437e36f4e4f7a1cde06b7ec2c76980ce27eb345c7222721a2f44940e319ce444fcf7d5934db566650f03b94c416bd749d3fd3674a38efcf891e83f1a4e35794155e0904eb82d5e3b86b4fb31d7bd0553f2c8d3462c516a52d1a585b95043bbb764d36a811209ed07027c6d60b94e2f6fe230c42a79c3aa9f9e05dc38027164868652fafd37dedcb49f9b34376ffdb20bc7b1e387f80a2af395967141c513bc95cf76e62ac9d549548602a32fe2ce2c2b4f1449846da613d57468574155b438fd8b18cbe6410790cef376154c2224e418088001d6dc8dbb34ef1288ca8f639067f9e08db03b8c9d4dab0c997a0dd849825a37984c699b6e7a5d90c03ab9015044b8ad6b1f757107d5ae60de1fbf9d693dcf30f7fd6f0fdf177c552cc6974a93abf4c65ada83883c5a7f221","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
