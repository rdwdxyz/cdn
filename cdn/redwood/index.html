<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82ce18119bf2ba4c31c222596abebd2d9936c96bfa5a22cb4502d978a1fb2372ed33b11ba483bce4ec9014577af2748fa07456848dec4758507af28fd4836cb39dfe2762bfc48c19b8d10e956af77ea87edc4b2a0ca0c01a2dc86cb983268ed0ef3b280b15f603b5629bfe352ad4258f5af4fd56a4215e0a5bc8977aa1a5c80cd139cc9cb0af8608059011d06c9325c176e91d2e381650dd558effec9f8f9e2eb1fd8445181f8f91f34014a4d2d1b7fca8bf46f98c6f39552106748cf66599ae504ec17a8de3d0b4cbcf88a3e71c0471a7a5e2ed7d57ae904dba25c2a8aebf262950ecd1d1f716411e8599824590559eee6fc6b287b8e2ba8735a9ad83a9fd4e73b21c1efcd331403d5de5a0187197b11e97f223d781807e6735740279f008d595b7c96217b453a0bc83d33549479afe43eb6858040054ac92e8fc0de82acee9ffceb83800e6405bf3aaa140b288a5d9d0da7624c55f844bda429473f011a0d306e9bd26607abe405cca63c84d5228741bfa1092a07790b12b5585263833a5fbc1af6acb21985a874fea5e7bc2e8ba7707abcfadedc42a5975d8240de2826db618a8b0d26b6d69c5db11c89fc2a734a9f24ea7b7208f72be27499e3117b350fd1954e0e42bc2369abff71a2433c0776cda9bca654ea37d9804852643ca5afadacf175bcf857a9447ecf361e851cafe3aa5320ce379a1cd805203577fb481d9dceed472717e14ecf54d0ee3392f630418879b9fc5ee819951829822b86629ffebb7e740718c53a4934e4e1be1eba78001880799a653990cf21873b85775ea1193f65f0510469a76e6729bc824fc9721ba8f06d02151dd3bef651a55e58c3232e28ed5b2e8b8fb5d0cbe4a681ed561dfc2725c0e99de03bb8796e6170ae4d955df8e750fbec2889fb35ff9c2b91d0a3a03441953744ef0ea90cbb70ee214cdeaf37ec5e658297794e725a36b166d7b5588a4011c015bca1c2c28a16f1cdfc2d6180b5ef7a910586e5739d8bec803c2dbb885a160c937dd8d3a95393cdc57627db810501d7d23c5f564424fee9696bb8c39c44de948de758c4a67bb5badf5c8c6b086be762fde2b17e3e193dcef7ea81b4e7d52ae1323a0e2c8e9777eaba625192f6329478aa4df76490b84077502ae9443affad118f9ee7cad2913272554afbca706438d66cd7b65f1ae02284e44c4bec2e20219be6bdc86399d964d87d891849b13eae0e7a56f8bbac4a044dba7b772ad52fb046fbbeb1e54a07b138c724dc16a49f182224755d3fcea57bec8eca0399275b447728efc8ba1bce04c1cad3e008743a8c5f4890869d775a06202b53ae6de3592da8aecfdb546a3968d4ef85469b1711f45f21c2086e23032dad55ef71d13d459fede4e6fd6ef125de3cf8bd3dd76d1ccc053d08b5a155021bc84d3891bff8a44aa97e4e3946cb592c66b0618ceb7b5c37e4cb1b5742ef48f33b8c0178966b20af0c9495ef42854b7d1689b6e141cb8222cde7da3e7e8eeeeb2ef917c2166e8accba12f18256ce6802cb3cdfb1cd81e2afa071e25df82c1b16a1f081025c69a42a2e0322ce9c364312669a100ce86763627dabe037cd3c482ac6f45fda73b84ce5727e2d27e76dd6865cb34e4a1f27872686e25a58a25899a8e3242058f9a19bd23cf41c0b9f9a8c52616b8c473114709c04e586330a280ad7b27bb3ce99d8bf18ac46914fd3ec815a58eef213fc6c2f9d794e8b079d38bc5ff5bedda46c63f10b84caa6aabb0203d4c6e9f642ecfbc7833ff4d463be7f41b25ee0d6b7ca16e94c4581fb8242e8e8496401aaf4d6eff6f3907c5f2a1c18be3d27edb6db8305a1e5992996d1bc9cb2a6c8152d5a32941ac89f8d5d21de201771b9e42887b80d0b70946bce5aa98d5abe31b920dffc377c61a132b54f8665d6d7174b803927e3e56f9b27f63dc1935676653d2d175c74fc973a5299a20820bedb617d3866486ac09328d650a5fcac44006d05b6d80ee511b55d12f75e296301ccc1a40dfaa3cecec9b320a0d01f3c826d67092de8c238318b25c9cfca82b9918e9572333dab721db6f307cd971958fb5389639091cdf75cbdcae5e0d5269761ac4fe4b4b64bc871bbcea52defdc94b57d85b1627009a33e3ef0b775dcc8d7e3508054111bea4c08c19536c40e58fb368a04de66c39b36e72c152e3e9a5c90d61c6a98706689654bc61d1b653ca864316c352c22e8358fb7d6421834c50bb8de8de5a4df89e223618c65ae26a6733f78e8c51050142a4c9a90b0b90a432133775a1ded08842572fa2a5d3a589dc4608aa7a29b0940d8de518803f32ffcb613118aec3f1a2b898f9a0709bbf3e7e07f59f4a13ba65e14efabd518dd27622422133d7940451be6b7f65f39c1963db96f8bf87ec73b89a9af33c6fa0f6dfe1299cf8834f1a4988361934ebb9246b7fb5da0c010a2c0d18b5c84ebd4d691c9ce5f3bd721a3bb73cb80032c8cb5f577895b26bc5bf51fef3de88006348751687b5283c5be60e21de73d53e7b6a94efd08906af37a0d3974ab962a50918407ddfb54fca228dd024fe76d02fbe803d7dccee7f305e837db8b24ad1990d795d700567eb206d17dabe5dbc1a6254ac067999d3cceab45c7a8279f22a6adedd60878c6ea70e4b5eb422b501c81ea9a3bfab300276533743ca98bad2f0110a06bdb10dc630a42428c5bb466afc58ab464212ea2857240aedc86db40b32c404c0dff07a8026f221c93ce3f9a049fee2a3b1029108a7fde35e8b0c977397a8e6fd85eda0531fca9e0e1e3e499f2ef2783e91cf4b3249e88cb7bf5bd246ad937984bfd0788f7438506641620539cec04853ed8ffded4cd263607f8affb4481a0370fe828675d5eb5875c1f10e9d68725cabc4ffbbb9c2396f174e6cebeb24e944fa1ed9204a4d70a71e4f1aa350874b07ba2b7557fb11a6795e629b7c2551c18bc87210b1f502ba66a7041341373e4d9faeeb97586ed9397ff3e3c4dc778ab3fbcd5adee440c6551d6db6bbe1199ebd1ff4beb03dba63bbdb7d7e62d6df0c724abe933b01bd2fbd2e2b5fe42e3a1a66c100e0c67e41382714a0d1d4c5fffeb521fd603e0bcf2dc69c5921fd10862d4ad559d6c429080f78e1383f7aca4e3bf4c57b2d3355bbc2f7f0550386bde21a871298e026ec2c1a696fb334969dc5321a47daa4d00b007405af10117b93fe5590f3831eee794b39d301b77ba6b13ddd640e63b4022ee64972d197ab71540fbabb1bbf6d15e12eba0d79a278326a10335028b9d16a714b68fed62da8f483998e58ea120927b164b439ee2f35d050d27424e73643806f2fda28660ecb39834136b4355cd69498cbb63700d086e6e48a0102bb58a04fca1649671f21c73d4cd5206560254f4adabed8107845029fe14f29745cfd30a91a978e13166a554ec2ebe4e7755e5b0120b13b64aa567679e328271f18250a23e019e88b9db9feeaea255bd96598384be649acd157a96b5b1c0486bddbfe454e10fb71eb2036f35eae77d1ef9214f67f7b726c341bcdcdea08c479b171d116e7e52e2aa1f0b3f7af9551842e08f714f09e85e79adae311523bcd0a83ec391349325fadc5a0e187dec0b9fc712fb39f9d5b1e2cfbd830546fa3aa91b6cf83a5e5177cf82d5ddfc3103b553e7edb3eff9aa4b2abe6ca2b0056dd0064bd409e685e50aba860ccdadbd5c9b2968d6283b4d27c4019267cb951eb97bb4577da3a9adc5ef496c651568ce1031dd0089787f757552e5565f9be346835c5a03845fc833647d2060ba4e569bc8391ed2ee215e2a3c810417f6b05bec0f09187d1d7e7ba9faa0f6321b2164734b2bc7a5c6ad83f0970456ba4f3159e55f514f3d0634c9406298840c5514bbde206dfa7dcea4797ad17f994373e76488628bcbdc45ab215a71a00497245bd003e0952599e21d40d1e4394540334b084b167626b62473fe4182ab92c88fc35d22c3c9c7f92b278c48c92d955d3fedc930ea41d53b9e8327ce88ea278e50a74d6bb0348f358874722c619089fd559c61060bc95023bc6206e5d328bb029eb0766376f9c357f17288b4ae465856329ffa65e3141a1b9c7eacf0ceb9127d712d29cf126ea86c4bcce9077b054670bf508c9da9ecd66faf6bf1c69172d4a75a7b17156c8f0ca41ed43934cd27f0cba6334a11399fc6ae0cac38adbb5c9f80e769e110d777a86f6a151e0ee1e6d36f79d0592a95692180d131e5f5ceb08ed5d410ad307259d0139cecea6f5c70490635fd23e42a4f2cbcfb022a3daa8e5379c8062c7ccfb7793cd8821e82a2a38603b556894a6dcb1769e0f24357a80426328ce0cbbbcc89361c23cb38c0a66abbba5ad82371e5fe8000af4aa70c47cedde9f5080713ef7a06d617fed3bb8393ad91efeed252cec5f3eecc60118c2c59178d46e0ab03d38326bd21ee48f305a088ceca8e40940e79a9936442c1d295d52ab3df3c1c581b4df44768f37178cf7f8becc791740b773e07af77f9bfc4159cc55d277fecc6744b67b48be30e11fbc9709dd11d517d86750fbd7c053b368a01373f5264db53aa1fb82615a57cc9eb55adb244cc684aaace15ef4595e9686b78d45bd1ca1523d0a4f5bb4e5107974bc3d9c93ba6b7437d3e9e1075d56dae9c70437ea03899d59f01ffcfc7ab915ba2ccc9c61bed31b88dc08f116f0a09724c56f6926de238c7ebeefbe05b5b30f65f39727aa4bf39e5c9f320b93d583df4853b6f53d19bf43b03246d8aa5bf2284d921be630ea96aaaec4dbdc885c11f81786806e46b175d3a5e2a445cb90cdf341ba89174daeda16dd136d64637bca8acaea1e0d7d8d583629c7eea914748fbe69f694d2fbc0f1914930b7ddbb309c07d09af7e4ab7b580612e811a4f7bf73b14ec91705d11a65bf475a6afe772417beab739d8f1c7c910460b42ec278127c6283183229709af94a800be48e9b81e57f4cfea70bdfaaa3c0d9033870d271b3fb6055ccd7a2cac26cc67c5db0c9564cf1d6747cd647a83c7ae262a74e322c7f5d586d405f8d903dedbf11bd91ac58c3a7011cd510bd99481795727f3447a91d1a181052911df29b83b0c6821c2fffe7a6fc269ecd9d1b79094650644f3c7e88dca30fdf42e6772fc70c8b4683702295d074e3016eda76aae45fe0ad0e1c37828b57c90e245e400bac71a97b3a553bd1d28613165e14424dd5d23b934ccc684c57ccd2539c8757b073d2cad16e9acddb60048c53b5c42c4b66cbf0420dec2e6deeac5b1259f8e03f0639a9c9f08cfc61e387413eb421673d017c954851492b5802b51f74d78d6901c2fb773247e6594d4c135729dab08f48f27b237187ba0ebe2dae58848ee465df5ef79a0cbc637a05fdaf47e8f63f83ea9221343b398c589471f10c1a7902d093eb5b96a32cfd43d6aa12cabb7fd79ca3b324f0478f72306ec0c9c75d8d18196af5450b078534cac9d53bc523e9c8f4f610bde555574154f3a817bafe1f2af0d99d2da0349ad66b9a8e34e1190726aab0b9c40492f511737c9e8f9bcce71cb394433736adc2689d958020b11cb6cc839eea8a7552d72d9fb470f06292a1e7ca96c3fde440272e03399aba1e3d3be9c52808049bab6d5b88cea1c6eee8afcb48391858067c36df9ca774ff65490e0c889bea83a26a74db61ef769a8b1229050063bdeb5f8092f1622eaa26df59715258a5e8041004963b32396ea21a42d509d634bc9291d36741b1c8621f5d58e81b302e1d36157f917e8b720a790113145264e6f625b8e4e8235bbf99e2373b2221461f08f63c1ff2b700bc7c019403272e307ffd90dd8824bfdcc1a15b83f0297be14c5536bbcc31cffab2dc35529323560db374e5372924940adc3eadfbbb284de41d8e4ef94584102fdb00d3ff25ef39858e9ab18e93f8a8c91d27e4af62fbd9f3634a0168fe2303b0dde392ffc15ebbbcaa2c0a7d32bd9808fe2b21d5e45d83c1f3a1ffccb07291fb4cecd9cf6fa59cc527ae28d04f9aaa476b08e30c03a2f74b253f747a0c81708fa1efd19c769474f19521f9a892f0d1d9b0432f20bb72e500ea15663d6725e840fd206758b5f072d952107f5aac389c7222ffd8d0b2c32afbad589bbca761e47eede46c139fed1a92f6bdb4dca83bb06baadcfbf089fa7be578150e36527fc82fe1d1046bb9a85ff5f367ca7b43166bac39a9abfe051509593a08ee565975a270517b9b542bde1cc41cc32466e27e686582c7471f07acd3f31c73dfed0864edb9eb45e0e71d1dbc570c49ed39ce56b7e2091c1148438d384cb4645262f69111f222a8b062029d9dcfe42e09f2d72116f8466d313af9f0f13ee1adf5fe4af96b294e5ead650e0d9efc7483d5b1bffa877cac50ab291c9bf9e2f5d99b7b140ffc5bfde96048717cae136993cca3319f9e6d54cb7904c3247cd1dd130d548fbdcf7f1b81c9863669f5d5f56489b1023c34f7e1e608726be0d9ec865c59c1c6b8891760de4890cd34524ccaf45376a6ddb572ff393e161477725e87a9a22e6d722b138ed3ba48c47ff0e9b6228d73d19ca39d2c5f2aaa903d9b8e8fbc69ba49d87f3a58ab0a40c63012d6d38c5ccee0e05e93858d69f96b738886d091d8ceb0f64cde80bc527ad3ab444e2ec8502f704949944ffa1d960c7b9070f81fc83349cab5b1f28096f661932b3c1c0ed28e4e50561bed3abc9fa254bc14d9cd7f5d48e24d2ad97960d5f8ee2660751728b1d8e54d476355b72956bc3ab36138d57497be2e7d4eee5b495af164f43f1e7d41fb3d2e6d5d8046760d0b82bf7af3a35e49f9611217a2c7ca5491000581ab79e835d4b9c95c7a0fd771452437c2d97d438cbbad8cd246c43a38182d8c66ff814c0f8fa60e750a755976b811f14de910adc3e158089b5280c47d1755b22b22bc11bb6acb7c1c6d3e821f61b48377d91c7ea9874b41b2a25c20a81e70a7e8e1392bd3a7576ced4d8135909e93d84f82089d97467bae09c306b04c8569ae569f6134d1ee68da7f1dd92baa8207ac1e38ba29fab8620f122daf08aeeb571749687b8159b9a16d54445cc753f638a3cb01408b208cb67d6fb3fe03f66fbf4929ab1579afc27b09a064f264e1f6b2cb6094e6e20dc8783e54d5db89c8ebb1a98b3fb96ba4d9d42cbda0145be8c5ff7964b58127fcd20e557f306f499c68fc605363c89ec87c82b3ae75d46723a43d37a86b5f5a7c167e25835e2a84e1060c3b2b4945d5afd9b2c4cc940ba86a4c27fdc6ff14f00d544af0a79390d48b57bcf69ed35b15897c4e1918972d5ccd0a191229aa3b1bd2698a489c4734713d45a4b56095e1925ebad18ffd66ad8297ab9c864afb6fb02d0be4e87a2df547482ad404ddc0c4975d860a51c7d9a50d0b35ffeb6452ce90d4dae90b5d244ba9e42f64e216b32122812de5341a888f62b6987274147c45b0275557ac41fc265328b180c1f3e45287f3f31dd6f3a8eae01f003341fc62e8acbbd86d175a2504de1749ded4d8dc0bc01754b314f1573a2eab8d000d0140b3e02086f1bddaad9eeedc050d650063e435ff6b1982a2db922a434c8cfb8456ed8ecd6c2cce04afa328e33889acc8b59c0761b8d7ae7d3ecbd1e8dccf6be4e2ed6fca46e164caf06903c3f398072d54182ff3f0f164433af8fe020b46274e3a3f045a3cf2751c26fdc85720e10d4a992e7bc8506ee483e66cb2465bff1541fc8c99ae73c1a24bcf7f0db9366d9d217be4eb463c3b4821fd5d35320db38132eee2ebeb0979b5bdc937fc694eeaa1142b27537790c7df8f9770e10be80fe04071da21b23e939f51969192ac8b1ee6d3e71f3b50178a71aeee642ed11d0c4847840e097a8023be822f10e9849dd4908f9948de05ecb76bbac9435dc249dc013f433ad95063cb93a37dc5b5d0d6cc265b78ca69f434171f252c9b49addc908fee7b17179dc9bc80a25a200fb63c3d1b8ea5efed1f6a14a5d24ef257241268e42a7f461c342fa00cedaf9b80047a06c80984d1b289a6dd8e82c8ff9ddd0f9fc10befd4ad53808181a2cbd0ebfad2d3db83cd6f9e7173a13fec2ea51e02a3c1da77ab321b03729c0a4b21c8c3834e951e8cf9da5f1e311ff53642ff317d05a42fdb995e304d0b781ec83cc5ae4298c576f8228375510d92f6103fcdf226a7228248183bcf10cee49fd928ab99c96018e04eb961e4d815b20c59493db448c4dc1dbb60730c82dcee4b37b18b4fad696ef46e434534163bd811068abef525ee4ce53e9c85b293df8600833e0869f07f02d1130aafad3fc605249da0b7e8b6ddae5bde3d817af59d516a0be25dbd9da5c0721d871ec641fd141f39892d7f96677cda4a3d7da3435b1f307581b93ad5ce808457d2cfe82feb845b5cd84a9efdd248ed22f93ff4ace880b4373dc88b4c2186060740b9e800bd0d6a8daae5ce90143d0c812f9faa08949b74ff014373a6b0b9667a9f648cb138004b57af5b6c2f82ca310317ad43a79e3365813856095cd177b9916be782682e70cb529d8e4233f5a638c861b0d98b4b441168dc3a0c2e007ff70e02d6349789e1569206baf08459b31b1c0edfae7e8b9cc114af7bcc8fac4c9cc0fca72a3d8a8e532a05057363ebbf4e93cec0fb0a1eb073b11e6befeba9609dbb3c5c3c048ae521f5801f2f65e349dd3d2a0d169417b70b3bcaf83cc14485f300b3abff45ec1205346327e90a89f0e0051835509b328fb7f0c32028ab11663dca2f295df5a3dfc3a65e424970c1cfd797523dee757cc1a20a14efeb7cd5979513f3248ea9a8893a2fd39670bb5196f5380baf5143ad2057771577a34e4888abb4454124506529735c1691e2ee611086e57e82d3deb4c5849108c53f6a5163efdf7f92cd1cdebdb327f2839fd3ebb637e22ca49437272bedaf091b9c1a493b61050b6ca220ed2ab77bbc02c61bff6e5794947cdaf509d56e986cb0c65d17f1d03bff9e33b8f92bed161448b4d524e7fd11504b3ef6c8c90fbc11b704b97375f363af1fe70abbfc4016e081c98b66032b38d4150520eb18ce0bb49236728193be2fced13a98756edaeb7186271267c4f0110a1d78146d1c0631792594852e3bb57513acd96368666d51f62cea98b32ec4a77fe3de26f9b1798fe282ea7527dff1f386cd80235525546f8b470d065c29098c8cf7dd25be6a91b91af48eca8bbc92609a64dcf64fa672aa73fbacd8c76d02877a24833a43f8fff1ca815bcb975657e7fa81085b94700c2853f8d9376ad53ebe6a8afb455b50007c5bfef8288350fb661c33b21db3a6017e5ccddcce047a588038cfef6e85373927c7092a19edd434894c5f455ac2e2b8db5944b925d5afd41820913c324061401de1dcea30c9a17de159402d74cd95ff78a9ff98c1ce195c56e2dd6f394410731a6bc94515371d6113edd1b839ec3e84b698fc1dc34348d8cf9b54b9a39856093a5e69b40d41d069f1f3a23183330ebc0e2d85a15f4b976ca072ec4d46fdd83db0142ff34047a258856322719962cafeeec8d0ddc434eb60540f2aaab6f1e9005b1f6babda23936197b6556e0aad1cc9967949b52be831f2937c51c6264511b0ccc74b100fde29adbd3644b9470e1391e272e2bbd582bc5a673b0aedbf4e4c8159b7a7381d6226d75123a32e8efe465b1177be5b34aba5f36c126f218a610ba6f7e08c02e2f47c394ad54bd02c17eafea1c70810ae90eb16974e66239d75177b0965537ffbe0da08fc42c58ab78d606f71191d57cda9638eb6278668d3634991924f10ab79cfcc7f7afabb64cb26ee607250c9214ef3a3d799144fdbc285e4266ade1f462fcdfc8781aed6cdd16810d10976edf0beaac469fad0c1ce53faa5586640b5908b3faf021b18250edd7be4483ddc2733ab06daffa027dc67fc2430ea181ec9c2518d60cfd624b132bbbfafca16d083dc2e7e3853f0c9bee544ff82bc446b400b0dc6c8c7e5bd33f371b9564c5901f65b05abef0d21f8d5fae45c2f7a256e9721eb074adc7636c2e90b2f7b50ebf30b9ff2982fde8b760882ad4e40004f623062bb97b7c45da6cb5087cddb952764d9681842ba172009c844daa77d8590cfb17dd880cedfacdf13f2f39f98a39766d45d0a3ebcd29f5a547e4d10c1e8cedabd4de264baddef095e12e2a9c0020d8d0f096aa7dd792a2922dc654a21af55f31f54219929a41ad052f04ff41dd3804f256f9ec55e632a1f9b726c62179c64c73285855f6cca3e54e7e405472b1d7b07d765ad2d3327cc9ff606bd4ea9ea2caf1c9aad39728b5ed58fc6e220b8e96992d05c9edf4d89012ff8642168697b8ed0d60090f7bed46082c056777120444485cd29eb0c7bc3f0f3512c3d9349153b10f2057e67c90072c178ad0efd2892f2dd5f1bd79dd85201035620e25a1ebfbedb1101486302ac33fb775496a34a182283227c93095df00df35ec42d811e2ab77cc5708cffd71feda2fffff1dda20b86b69e2e29819e69bc60a1981f9eae467ad5550007f2aa89414ca46ab3af9bfe8b85a1ed0d8183bdb800dccfede372c2b1146d39e28ddaf3e71f0a0d22a6d1fd500fba450d6f55342689258dbcfbd2bc91fc414b9ab5b0ba6a8fad0256df730e0a48a06aa2d946cd8b95c1c08d7f6e4644e1849c0fd7634ed137edf9ab59d8714d791b09835ed1bcad7df15e0c9d368fa073a540c799dddf17e232263f9036e8aa3d7679a2d6054e47723b393040d90a220ab13fa1c051ceb5ee7ada7d05cc7367cc9e3649a61159030e2933bfb686518480d18d046f57fefe397eda045963e8298c848a6ec859fba6a5bc87639f52c99c7a23f27752b83029acd1346ff9344edce98075214ea5018cfbd0fce681caa8b469c496f6dfc4097607706a2aed4ccafa190217523db4b7dc179be163f538cc91baef1d8f8855241ad20b5f23085fa48a01c90cf9a61c00ab878bdc8a20c965599d61680959c33fe474ed1514704f11d859d2e47ba976b646a4e6984d4c382e4527f6399b294f10a4a2bdbf9e78eca1bcb711324fee9fc929a8f5509e0b1a9708f256b4c5a5d874e2d76775e454eb99685ad41c9078720f74689b640890bf755a771b6100fd80ca5a26593a0737edf4e0fa0fcbb901c41bd5ce9aec0a665f330848857d95512f426b059437554be1a42632dc5b1693937e43e3e65e4250c6137dfcf0baa8a3cc5bf51cfce1af8910f61a6272ccc6ff844ccedb8c41136d8d5f935301f53c9f26b7c784736dcd3aa2ae5951091603efb97f051d8e724d90d029e4b8e4c15982e4e46308587dfa61238ee90a66a72a40513f06342d49facc2b5accafb65b499c73676261db198072e2b80fbccefbbbee5d8e7e017d53329d69b4a7c1cb397a4994598da8b22f352295d4f50f10280e179d6ba0dd740586b252babb7133ae33a4faae32bbf415743bae4eaaa57f064e42f2f9c1b1b1152bdaaddf92ece2132adbd2fa72b516b43a86ca75cd820523d47322084223799e2ef82c38250d59677cf39c1b1b2486138c0fb3d5207af9c927efd8728b953fbef953dfee6c560693543983b23be04888ebf0b960d5cdbe50d7f28a73f063ffc68bb3a4c71ec2454d0c23d136b3101e4b64eccf1a58c18bf62c5c4e50d0557102fa3b1249ca695541abb8ec6056b2bbc36493aafeae0a533c162c742f3050e1ecde26763c09ba65de9a9f070396b30eff1a24f718e026e3c627c1800935953fc596fbf1047b1d7b32bf550121e969a9fc602d81e77da969f283e1e6b5bfb251f941f5e8ee4bf8f81dca74ce222052339d25d65cf509bee0799732f21223df9dc951a84d4acc1c758ce4317706fd9814c7def61de1c5e8527243b84eaa0f69c22811a87d9b0ed08feba1112a39d544964ac5360c4036fbf7ffcf8268e9905973b10dad9686601522ccd1a0e149063e44ee48b72e318b264233cc38f968a4b5d644b0be11e479341d6d759386c74ebd09b851effe8c537e08b624055f374f60e477a5987a8c0f93bd50fb8318a341b79842565a3d71c1a00578939c51c6de70c2c16afb9c450e12833d159141b39816d54a7e7eb3bbbc9bd32c76fb27a4408935da769ce570a3c9a04fedfd099ead2a66e8af17baa4b25592cafbb906b9957386a942d7d03b44cef6c157dc9c48e692711503b4480294c1714dc2a9c74613b1eee5652d8e0392e81133f6ecfd3a51d64ffae2e6c7187cb36d3ec105170270d0312972e995405b4ecd026b3995c3efe44cb917edc7878c8e628662e8379024ca8a9b4902018228d683585f27b858be42afe5440522f139987817a504f65d74b7dce56bc79d77f8aae877092beda85a427832d47fb8f00d1a791d11ee57a1b193f89f53ccd535a7b56bc89e4e423256f165a916d21bc6c4339adcc1cf3bbb5933e615b098f5c3d2d4dccff9be19251adce8b2cce8687ce44366e3866dc8ab6131256c6ae8c34d592665a85f9a33530cbb8e54053e557c73e052dc9c3a78a240fb6f674d3182100e93f8ae5480011d2ee92e2135648da039e659bc3e999bf067196c66a94066be26e1a5f86b2ef4a2f3dbafafd494d9702844e332ddee8ff6ec7625b1b785bb189160a93942ad3a910dcf051dee4cead1d60d61a1e5f3a04098e0812b29b704e5af27755b966ac74a607f4b95aedabd25d8c30835398f33ca5754c4434f54458e60678c54dbc67b9e1bc8c7cad90184451ebe9db690f1e8934df869229eb4fe0a854be1c814dccb36c063a3ff605a0ac5190aff4ede999c73ccfd8e4acdc3e05c12d299887f812ab6c41336525349fbd37faffe4dbd0425baf1b79b0766a586bca44fb34161c4fab8d8ccbc2fbc0923d72863a069459e445244c699adb66f30b491f9ffe74fa0ae31a316456498a2ac43be9e21e938612b44967bae4be1b9c373bef4e5a9ece049385b8cfacaf3c9c824358c50b10eb03f59f6e70d45046e67bfc9535de04a6f5698bccc42a0c7e8df4ec284f0d0bbf786f44a7afccad930de65edecf4770d0c255c01bbf775b916d6d910420fb19ddf9de7434a06a96817b50c6e398beb823b8be49d5f28a96c1ccbf23402536e33c85f1c09d0834b9f8c7f14cd69266c8b92567894794d4ac9b1ffdcb221e39e2c190516a9b0847655df217c6a8c81b09fe5b21cdb25e27f65a3e55a5a6e84bfb1f34f36c63fade82b5b1578bc2affaa53cf168c99661adc4ee78ad00c610fe28122b69efffef865262e305a027a906d67acd8965a89f66b3c9746a9fc051de6fdfcfa8414f87c995e6937727e53c1df3f3a61cda9ee65bc34b5e395d2bc5cd108d60518a66da9dd3a52508039aafb7fb0f4525af993f808fef3c8dd8b88e01c9602f11f4200d005d61be9ef58e26b384f597f49594b1f4b33f2a83d84a99276528ab7ee87281bf3c45aca8098ca9cc27163e01fdf9829fb4d6dbf7d3c769885f57f7edc16a66d2d26809b83633fa6bdbccc0a7e501e674c4e74a25b5bbbbd94375fd4cf9243b4405ef1539fc3199b740c01a95cce9c1ff4d3ff7f37cf60a5dd62d494f20576f68ff225bd6edb850eb92410516dd375b033b8aebc8553276946c79a50ecbcbdb1cda6246aa0bd3a292761a0f67c85fe88d84b48bc6c68b8ae54f95abe0a2fd7ae4dd8f2862f1ca07fda6dedb74f2ba9062ebbe2579e5ad1eac3d87dcf4c7654b53e4d2955c0cc477ea1aafd4d6d5c2230ece30c0f8133a05217376c01ce5d2ed1e26849a4e25936014299ee6aa2c27d9c94b138529debdda16f1533249a704bd38e7ae4c50c76520a9688a6acfbde9789ef92e1eaae9cd1c04148dbd28be6b2b1de25a1a0494e1822f8c40a0db1b5a49488e7f64e4350f64aa04be6af853ebbf59f89d2120e0ba791431095353fa5d541bae231d79b96fe49fbbacba4f37fb0c63a8feefb08e8212445d37ab1106cfaa7e08d51e8da970dc3583a57b581060db070fd0cefefe370fbd561b29ee4d4bcc824ca9908715496b21b330ce1e7ec4a0f11904851ac1aa1b60b3859702064f122e6b365cd0e43af473b6bb276bd86c40ddb691eaf6da164d69143ed65675f22b7b3d7fb4d3e60a92aa31ebe26127e2848b3f194831909c84afad42587e355aed82b22b8555b3aa13994efc37302cd86fc1ce837c1da086f98f225baabb83d1109727592d01c044044124172ca3dc676956e7b43efcca67756363edbe69ee4a046cb03060864e0659a98270ad6cf80d56fa15c7102e6056a6d96300d9771798cd5acd3a9cfada67dc3bf09775bb5a6fba5c61e9e0f50f26173d05ce3b7dbdf683b5a8af967641d25b5b6a5b2c29e4c07907c6c91d5ee895685d7d50413b1df621d4c23286ed72f1226254594ffa3fbef865373f84a7523bde7fa707f6f1a0f5231c3fd8f45a2b4e4a01c70d07ff4539ddecf6561dcc10f30ebe76ce17c2ec7eba65ae72d4c6cfe7f02327a6add978f44dc2f7502affd77709b263f232fbcb73d3bb6ac4e411912c9dc37c8335e4036230bf7caf36a791bcd3ee300491c83b89bf861874f76ce6560a99d1f97f76ce1be801992093282f269fea6639161954a7ea640724513f041ab35248cc010fb9d8740489e7847a57724303fc6c0b88469b956ce293d4baa3d9825f510c5e2d34ef065f926f7bd000d8344ba29f0459d9d33429409d6a773194bb76c4b6dbe3ed440d7d45840b4793402fc2ae3d378d122bc4137722c8fddea30a1b3b6c282b05ee3aabb65a51e931be2029c72a9999586d5775545ce3be20836a99a2298c28153adca9feca2ca201752bcd209d4ac6bd681fb281216fb4e7cf4344afd4bcb72da421f9c538f8b80b2063cc407b37c6e73c8db99e529d911124c5778b85bdc48e7b8c015f95596a3ff7d0cc70bc06eb7d0b271bc8a753e20a4b7c62c3ae662b56bdf9b6f2be9a20f2400a999975ca1451ad28687c46630651d4764bb22c855c8c7bb5b6bb5ad7e961cf058371de1a4a0a98fb91f88db401b0bae47e9ec741f661c1d5497ab0c2e66787093e785cf925eb7a7d8c7d1628c0f9a73398f607c718c7b3416c2727dda3f94fa4ddb69d7a2526109677c4b339a3054d6a8c6e3494c24070d2d372ec1d821dbd11158ce8c64efb30e0ab37d0403bbc96c1da8791e82511a6c073b2c05e4f3798c0f8d4f8e5bdb7c7ccd127143a553ebd94bdb3546bcb4da865f58886174ed910a5cef00402768faf8a815e7cc634c8ef3edb66e8624547f18766ef13adc1f09fda82e7c128edef65e6086448fc9d780539499c507445c6f0db524aac4f5c92dc1ce500c25d53c74da83bce7fa192cd8901e8558040ab4e24b8dfd9094c31d6625a90e7874b7264eb277b714b346ce01bedc495ffcae1723e34f454c9ee9facd3da165f9937a51f4b1cc575ba1aea6f04536e03fab01c9ac3d7ecd94408c32c51b7f015c7a6d3a6a83ce85cd2b626bf81b412e9368cb704371d4e7f28404ddfccaf271f41dd1af1e5f30c4c33695d20d81aa2d7ce161568fd0a8988972fb3fa7f419d167fd5267bbffe4359b1aee258cf57816d58e76fe7973abd906344868afc4e6762d8e2b9a4a3c3fa2a9e707b85c0c90740721a0fd60629a6fbc55531e6871632381c325d293bf4063bd9f910e986a74e5ca5589f5c59cffc581091bf691ac13fe87baf533c21cc44a002017042cba083b7881370a54c10bede87995d4691619647ceff3d76ab9fbbde9d730c90fa1cb6420f8edc2a27d0c85ef4516ee42c44797487e14cf008f0f3462f8f20ec01bc3dfb5e601b02dbbeb3998a7531806f82dc9c34198f03e9d1546911d08edbec4c0e121556cd20d6df4fd48690f8542bc7c5c8915c2f42a3f6f7d4e8e5c0be40ae13d64911cd429bf9b96c289acb5b40d0e46c8ba1510c3119570ac07d2fb1cf2217f1bfb238243aaa9918f1406dfcccfa90780da883760fb3cccf719701c3fa3df70b10204f3ab8df63aaddbc9ea8003574b2fbecd844ba27ee65d6bec04ef1cbe3322d0d76cc9aa2d99b8cd0bf924abc9b4871f7ca16497380351e6d309ba22c7fc9a21f04be70dc21df15b1718ed72400747eb76b4b22f5dcedd58422871779d1d77200e25523055f9d6813de7ada97599ae368e018a4a7272ac1ac65bfc3aeacb599ed3c2a7b704816f402bddc46a19418a60281dddf6ffa06f4f405211b867394d04ac227de3c153ed86261dc6c773872f3f615ba6d2b787ca005da5c9321219657f30e228ad86605dc76a8896e980fc4da8dc0817ede713be5415d6fac50d2db944261abcd0e970ebafdfa2b7631701d206de8a0fbeb021830cf8003cf13665a103654f0b74f10a551f81444d3f044a9a66ddd54ba801d7b7a27dd712c02a6bc709d3087f0bc597b7beb59449c1349f7a8ae5e4110d8fbad9a1d6c11a57ea8ac2b15df2dd5810e8590e54711a2d89efe25bea2b7b2c892af9f0f05820c57c0516c64a3cecfcf30a3a03f92079e0a7d5dd21d678c56f1ea4a12df0b8ed7f2717e374969530804bce4bb0b1f3bb85c672f651a02bead05a4e48687778bc5aac2acf05ed5fead1c27f520e5de338b86172efdff813ed4d72454fe34179cdb5707818c2215c8cf3b6f7774da63334de2dc10bc00519edaf0934607f84e83742f6cff9745b9b926c493bb93ddde138fca5399e0e5d3460665d22b0a12c9537a2cb2214fbca764af5c61fb05b4ad5fd0682ca31464ce2417ffcd913b459bd7fc1748352e91d4e0bdd14a6377556df54aba411bb55b517d9cae19f43245308ef4cf8d4a8503612bc76257e5c430983eafee47f5c45a2d4b149e66b8903152e37b9a4184f88870961f0e335a417551ff8433188af0ebc990437609b3cb49ca6ee319b3c6a3c66329b1826269892ec53d04e543ad07f66f654d6319b6d443cea78d1825b3b30d4903742c547427b7da548f4a906a7961d6417dd2c4ff1b633f1bc3fa808311c6b57a73054d9e4a997aefbe336d10fe824aad8c1a38fa310883f6bd3dbc2075946e76a6913e9cd1daf53c049745874b31f7a5fee0828096796a6dd65311f7cec49a6ebcec3d3d886624bfb23bfcd592a8d701ed49f05e408272d7d25d2b4cfe055933c9eddfa6aab2c87ce9a1c12e0ea0d7f2274409196992e5babd28d2d642d3e7ec9b6034a42d216e5657ba31776315a43fc83e4e2ef4e3fd29197349a26754f70efc1cd2fea60ed9197686fb9005f85eb07a27b2f57308295e70f4abdcbe74afb8b9f347c065625d14de6f7fe7cfec55a12ae8ba46dc7c645c06f07f17e9a1e76cec75afdba8aeb53b21f3c3a3d0870ccf5208c8571e0a55e484cb31316d7dde6db28593bf43dfaeabc32b3fc91f18a15f2439e18d381cf029e10d283d780dc2e22b10662ab96f5e6d98fd151302bfdf19fd42e2e33b94ac292abdb9eac505cee777294f4f5f06a8f3d5909661042041158cc552961bb3f1500d871a02eca14b19b0e47311e3a2a081ceb6c2da6aaf9f46fa52fe48120f2fca5a51662a808a09a1fb85799ce2ec2c77de43cfbb72396e0df8edae98037027ec4031bdf6f10002d1949e5c9211fe1505fabdc7d333789eb4a2913793c72d66d52d3899f3cf082c8ea3bea2cbef455acbf9fa434b159970f641385d047886a0f271ef8d8fa332681f9ad573fae47861ae344c2889306159ec3df7cbcc613812ac8f7fe21c8b858242538679fd549fa41d93fa67c156e888eb1be312ee3218ac165b56ddb55fef1fff61179e31b9c8eec3fbf6796bf2237ba66da97e038c6ab46a864d32a42583fc6482dd38d21e3d2bc03293d4cd5c5a264c17aaeeabc855bee43e1ec38af340147debf263c66d5f491d118f576bc5d30fad0b18e793e3cab379538cff3e5d88a18f9500c4679cf5b81a9814c88cd1cfb8c36043dbe8fab29d6df3b89e0c66a10a31ce3e72596586a66d7e8c228a64a2977fff0fc71b1793449bce6d87aa5477ad55b9bde78c5a8f7755e2bf68bdaa0d1fd8cd310db1e57a13f135f9dc7eb8db3efdffb50d157788e1ad2740b2fa74084759c208224f0d88c1046e7fd72c5d64e9fd4b359727609367659471a9f3111d49a4b8644e244ca643589591dfa26b76851b56380d23af5929e5fab238ceac0fad15bd5c1ea7c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
