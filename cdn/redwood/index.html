<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a454623fcebccdaeeb834663ef0a3fdd0051e01fa44a5f52d0cec4f79ed53df8ee20e3e96efd75c9cba093627f51443231924cbd23d8ef946c8d7b457504f08b1385b3ffe82dd48f98f14889e50a90bca5ac6aae0e28ba60773f8fd51c4366b208db04f49201ec1b1029dcee3093712e951806cf33d2dc88ea67836601cfab4bfa327458f3f28f87aa25caec5bbed625c7645e89751298e9e3755251fa7cc54e926d0b8ae468c54fe67e65d0a77a68bbcb253cc92071bba398fe7a01fbe14dfd559b2948f7d8b549035e9b58ff71536463ae22dda10f113096f16270f8d68e619daf3cbf048b474c5fb7d5b9e8137ea1c73cce1c81b76eac41db89c6ec3f11910e66e52b25c2193d948336a6d3352df93bbb57a6ba64468d5ef7fc36af2a81f054c669d4fce7df49df2b683dbcc64a88d25aab9037587bf821d7e8afcb81839d444f49d0a94c60b3bd4d654a7f11233bf6d6b43a490f3e1be8d663a57ab6deab6eb81577331825ca973cb5286a96b92469d0c679d9f3e79cf8ae98b69e228f19cbbdc8b22cab09639e6bf2dce9b7864dc3a45a157bc6dd28db5ae4ee6001dc3d651cc525966a1d109def0b89c6e9853cdeaf716b1529219559d2967b5650982faca702c5d13b2d2be62a2e3a96432a741f7460ff98dedfc4734df2fdd7d4eb1e1333f0b9b4c790b923429c7e0df4a20d4c294b94b34bd82ea4a4c69af8594711ef4b0592f4f2fe101c28a353df61e84db74a57df4a6dbfa41142831ac3f6eb5840ba3073c779602cb8300cedd1590a55c55d31032e46debbc1fca8f37929c66d34c39e18b750fc5dcfa82c2cdc86aad760de5a5b7be99895e55dd90035c6650636740e791a282bad806465f29b8d69f48e5ceca34aace2628a41b7677850b3224fb9694d760b3a368c73d635e51c98592f5bcc993c6d6cb19e9f95456d809e4f93c2fc116875fe53f26873dd5e8fd76c4c339c6a14db10645d1f7e6541b114da42b73a26cf6f11cf0c9a294e1247f42f0e04b4ff4c76b6e7564d62a236d25bb3496bf2df5040a6dd4af484bdb36dc237bcf00d18459fc1df9afbe2e8c95782bcd3982a8aa50169adef195ecfec908d486f5dd82a36eadd1082295d31e1a4dfd30f8d2d983f532baa41fb58a61d2452e4e95789bf64dee3583ed2c8a79424f621e69c1d6c720d346cac4f0a9fdb42add2a68ba6e169510a2099bc5a281c891e95fd4012649be7fdfd04b38f878ff51cb210617cd8ea2648f23be3cd154f0b32aa78421d13c6572e98d4c67ab6bd6ca037d0c65806cbebef2b706bcfcedfd198296b599cbc079a888c8acd34b557f5de1881794ecb58e88b3aed19e374489f0004b50fb056aec850a7250ab1f077917609d059f1e45a32be3aa34637eaf580e84461e49112e8378c1fa75b5ad7e6a4514ed3fe7219925984f1c6d176af8b239b21f97254fbe1628df6cf2b89da5022f1578b1e853de70967e196739b9c1137cacbb50d0e30c0eb0b6dd193a4f791d026edc18920de364060218f1b1fc59a40e319ee4cd6f74e6eec55df04c1bafb5442ac5e39c8fc547754d44425623cd13f47cd328568c9bda7e33fb80358f3d9bae345cc2700ca620a4f85e3d486033da9bf3003e6ff991c975a396a28a39fd824657deba55727631133ac0a92792cdfd4fecd90a55d2e9272d38d81fbf324f073f9ed1c907d04e505a0029e8155dad628bfd9f0f2bdd218f51337ec589bb4761517aafffc75d2d863337b1c7ec655fedb53cecda202cad666585a6655c883adb8a9965953c0285ce7572221270111f8daa625a817b12fcb3073cc533612db34b2ef09235660f6229fcf1629cb183515617230f1430641bd379a1b50397760c3ba3e8e42bb071735815f30196de2785400305f5fd707fdc2763e3887ef9f3fbbd6621908309469e553dd8f832e01c8814f100027463deaf49c7d6c6ef26b9531cb5f19c94304a74a7fe5fb24cb216dda3513900e5a290017e16ecb1af4df5c9e8c950b80ffe95483bb47769e19a42e7029bf46e46f721b0e64f42793e7162b4dc7f915fab8110a9b9cb806b29a00192c72ee9f232b7f06822cc7378821d93069fdefff7563fec8096af2603d541d39c9e9c5220de92db534578d5c85115b04d467b88963af520190c060ea39128862d7f7d074ede7a29879a44572c6d65d428d81f3545ca3897e6d184ef236afd064383f09792e12c11166f3eb78037f7b22114f1b2d5fd94037222cc1405e8170529dc264ecbc639d684723ed65ee33ce24d7defa454946b851097b323225cd10c7955b9e4a48f627f01b21d66ac734a4d8853b643410caec4d650067d20b7af55b595dcae4d4933781b5ed2f195296981b03568b76408a947674af71c9635d952d667cf46f651adffbab94dd131cde3ed20e21a67f70d963cf6352ae33da5b91893a222d54b00c95eb8e45e17f756c0c235a62e22ee92c520a43a47c065c68efcc9331e527d5f8377aa2d6f5bdd1f1bbef71d6311d7dc184e0b6a678d14048e96c1abfaf37227bdeba4c4d2c0867b71bc06a54e785dd8d1da171d44479490d76a64493120c5322c925cb880afbe3c683d6c4be6716062bfee5a1bd6fe6fdc5bbcb678d5f42376c0670a802a430a041262f16d986ec5f99a4f4a836dd8c9f9b350cbd580552e0625dc06ff3032749be12f2f2c549460590fc8ab5af731b71471e9759962dec6f1a433c393a960b5b6956eab1c4f33c0f786cc55b2249baec48b05c4eff1ce33b3ee3ffa3ad5f753890ca271def3b3b0fd6370a57ce109e41a579c26367e0f137f7e0481697c6c2216ca95a6e8bb0decb71904c6a29d1982533e6963ff36e6f9203a75c4f1109a4a28d3ce04988aced0f2bb5b54e54104664d6f5bf78440027ee061337f573234d51829bf9929dcc65ed97d10f2365d4daa2a74a395ab732b79c3107a92999b7939f6a3d94274f37d5498656c2a94bf81f6c85ae347825c345d6d91402b7d9bec9dc5cc81d08ba86011267135b6ce09de15adc7cba7f9561e0e3236200a738eed6add0d0e4e2a818cc24ef6a8f643f27044b461030fddd11cf09e79e664c56f6290785fc8f803d7f1eddf0f25cdd6016b3a45803be5a3857291c7e0ea85429ca208095e5f5c147247dd9eb7a7d51f4ee5ad2392c287d91af4deb00ddb1913f44aac580625cbaa9c10060105f71dd62d6bd061b688f2b9fed406a92cb5d1b7e3cf9a93c5dbc1faad24166c83c2f24108dd28cd9db3ad8f5d1eb9793a894d9245ef2f8f6242edccf382b8ef04a03ee9b9d9b67603ac3789bcc2c01d413d2f08178774c83678e5f210ea5de642b208304dc5dff078aa86a9f965c0c4110283ab09dbc66d9058e7c8ace79463cf50e56984c17a21ad86b7c9c3d3bec1d8d9c0fff67969bd0c2766b27ebb0ae7c57cd24fea56ef6de55a63cc328e1583d27ccf56ac994938e0e409d01cfc076e868c7cfa60dde39e170945ed64f659c8781d85afe15f8579ecd15f411cc2cf491720fcca298f8475d5267746eadb61429fab05c3ec2166da5a0f9642354c526d2faeeee885c73b47d1a902e2f0f92d9ae91e6a15bd3ec828f9c0f1a5c1fdd7a38d3107a0fb34b7836588564cb5820c88d9575acdf5c5c6d1a88c8288605f1f80e46c83b8b299f3695471843a45bf8c4b9c4ea1fd3a7afd334f3adc2d48801a8bf3bd838ffbb13b2d62e041dd0baaf926452c4d01f54a03d41adee4c9a63790b36106e5b100ee1ef7fcbbb1586afb2f7000ad569cd1c6e4daa56e63245d926ec45c062c524564706cef027dd47d9c85375269c01613f900f8e00dfac400068188a8bea6d7b3ad2d9e78b11396af47c07e9a34742539d3a78104214ef133701816063799091b45c53a461d18d389976592fa9d408687637c293bf084efc405e9aac2138a86126ee404b917d60f4ef022844e7f826371dfa0972ee195c19ea7d08dbedfed05ab14bcee925405eb2412fb6bd3dbd85e8825526ca72a015307d42482fbcc9c0075aaa2de1231ec8a0aede4f00fa470f0ea482ce5bcfb44d9b72a580cd458d0fd2fdc239832b1f5f1b990b966c6c20f80eab326227481133136faeccc382e11ee86ea98d1b3fb15bf5b8d5611171a0f1bbd28b20b00020efdd7801e16b174b690fcfe77c9bc762bf5ac33cfca80d806516765d705effb705ea7edc2a68bc1acab5a3ab8f02702492f0d0e104e79bdf8907cd22b6387743e0706eba0516419393943c8adb4cc60e3c14ffd9a6cf7fc54ff56d209b96b67fd76f10e817e16a4959e3651b3bf125583721949aa96a8a0f3e6b0738ecfeb78e9cc8225caeb520a3684ce1a9a609763826e0eca2d57cc17dd7546f1890ba1d5433da0811dcb4f60aba86889208d0b83af3316aee75f5bae4a125a44f22a98d8fd64a0ef0b54a698b2f65b4890410fcd41303e8683df3fd7f342a8c913f32e02f392ee4d377cd0e4d1f4e8a5fffe1628ac41a53cfbf64ce96623eaa153fcbc67b0d10f66edba6f5e6d2c733152732b6259f0fdefee1f3bf775ead2a1d02b1496b1eadb4790515c7b781760bce72dfa5fe33456f5b9f24fb26cac719d653d6e9315b886f90b56574df895eff6d246c68b1ca5d1eac1abe29b217c991f33c158ae08cbc6df891228ff02910f0e6da613804283f0ad985c4048d6b7821a338126b4c1327a4b74726c747f4596f9b61c7d8e14b582a71491524effcfd3c1869093c6fb71f03cc070fdde8968a55f72e2f5f54a0d461b1bffbf63df279259b6dca9147d7d2d6a7dfa5fccfee07bd18ba0ee13b4450f2a0bd91dc26ad9abd7add48207a059ea1c69d38148d8e79a734b7663cada73abf43b3ecb8aa583293390379a1346bc049d847d9c3c27d2691ed9e64ce2e3e62601af9771600459bcf1c9b67bbeb49a452924893c298168d2ebb68feaa98cd20679be20a8dfe285429aea048abd1ff7cdedd77766be93ee7e885e8cc0da00604b607b31e1d744c4b0fe4cb669b86869d85085b5f7e71a83edc9417bb2a508f1bf1065a7615bf735bee11fc40998f9ac41abd38229bdbe352e50b771ec0cdcea649c9152a6a1f2d7d4866bd543d7c93d5943b910f47798129f6044d5dbeddd62c1971b75eb092ac20fb13ffec814d88680a60028450b390b0ed1b9d29777e6bbc793d1e4158e6b3a3ae2753ea04ae58e7c3c7998fd1739696fa32c5b80f2df172ff09ad9ff77cce9705bbdcff9c37289ed373add3ba60004685c24ecab8011bc118af3d1449ec529d76d172a166f422dff8ac0304d03d95a0be442fd1996ee96f6078ceb9955793471590f3d9119049451304e3bfbf9946f950c78302403f184605d6c57e4ff09f348cb0b20cd55932d395221b7c5b0f835b056622d3c1209a8a2d7402051a77110e0eccde642a3318a9faafcc6e1553197ec110c83b530121d22e31ff80566203136bbd8045827fdcc0ee29e996dddb2b34351fbe3752dc5a0579a086cd96ac4b30351aa65467499acb09d41ab426bff402343e3ba8098a2f1a819a2ebd6979a46ff2d815826da9a453408773f0c6d1f00c7bb625f3b2a982ba28b1a21ab52228f71e5b95f709a234b06ab86317554c14208431cc9a03eadeb73f7809c326e0a24595e7185f88b6fb47b0f7064fc4fe6ef59a79bbf05d14121bb920fde80920a0e54d9c32101ce6f3ebc348db69c46b8ff41ce6a8b580c1005fa22631960cd257beee52d49ac1c71deb5dcfb98018db72ebfc8d44bedf609a6b32ac56e7c5d68208f10cd5c96a9384111e276e22a6b2f7b4cebe1deb665a7a91b9000e4355e66e01cb38e9b116813700264f8bd34ff8688bcb327554cab08f41281daff1a4afb7616d74c1906f64bda1a2c62ab85336b7495d856685b951eec9bb3d10004f6f687d88d6b95fb108b7bf9c39f53ee1707d231af6760647b14b0d7917fc30a9fc792472041b18fc0fe79d8b3c14fad2b317e98849d55eadcf344158255f525674ba28714709281eba04ad2a2ac150c72c8161c2bbb68132e08f8fbd6fd9b78bc422f411c50d07f581afe51d5d66114cd05c248175df234d252eacd8c9a2902d8976f2f22245c417cee48027d18d73890dfc47c9a1fcd074588e9723151694f3603ddaeeca20bc3f3c6991956a0e0c53df3cfdd55dfefc50a4fb09153fa79a83a9a9898b9d9e18c19b5035c5319e17eedb289cadab1ae451fe09c32896fb60eebb82bdc70f19dddbc90cf5532b6f8bd2a281dd1ff94b828815e1a433c64a05c3be274726488dc8127137caae92483bef2a5bec40d3399014246126a6abab4a56066f22e2620026a1ae60e085b8e7bead8831c630dbb62af9d0e1ce85d17b87f05747ed40f776a1797efee89df50845f733ff7c6288ddfbb2dc00e4dde850a3a10188e4c9f6d06f7b312595859487dc8de6708aa5afb5087c3a7664ccf8d4e758fb5c2e881dfcff24eef76c23baeb7748dbfee5be780394b9e07eff37361f437068152ba6c73bda921345dd4473427408f8280bc1fea12675770a30a068b98e56cfda6a8a0516082033c4cb3e0992a6bc116f197f66859fb623c2033cd98339b42457a1d70461dfe110175902a20dc4bd215120a490e20858c616d909a666252fec606f8d737475b368b7f36198cb8b6c5dc968874213e0133d61ca0a78ba77b5bb26aa11ba610caba3bfe773ba8297c893305205254fec77e50bedf14bad39284ed6db2ea19d56651ce9dd05e4dffe62608f888d68c602937b688cc740fa85e632458a906e2f86c74e7e06370a58560acb43327fad1aaaf9adc7b05281269f42cafb406d4a6ae4747e7124d9e165378e43fed8954fe2eea8200ab881803420ac620b4cbb73fdce02d26e577432bb195bddf4f9fabc32bbbddb2a86a7c15c8c71ce9f292dd986bea53feb18f75613bcd4cabf0b2bbe1e9524eb733b8b4421b2794873c07cae83a9360d18c220c848264ef417d228f7bcac2725892d02f7fc83f40cf7529774a37dc9df06bea6ab04a20ec6f2a05f7636c5f6a4c8cde37de38dc88b3a57aaeebd386f39245f7bd757834647464542bad64fcf20f3e33b97044cd9a55be2fa28831196610216557c7321c040b98b265e7591b9f95ba5025ca48d2bd2725d34b6289d02ad5a14817bb1d1e48c3b188d2c1afa842403ebdfb8f553bfd66408890a7b4d4d1617507049853c97b23359b91ea6c3e2b2a9d5f28cba2f47ecab309828a61377db5f21a67372821d3d82254b2d967110ab75c2bb3b2148af31b8ad30772924574e87e8b5897fa8910abe30aa39c7b378753768f17842a5d62318689d1f5ad2bfb06f11d202747354ec3ebd1a980a9b089955f9e3501bd41ec40db7b47d0660b22809d6ae5155ff1dd74bb6150829bd6177c8e16cf883aaa526da9fc13dadd4837916d45bd0c2092b443b2412bf003c31bc3bebf5687d9aa8af058396ee6b906d57c5e3754b531d136becfce945e3c8b93363ac5970cd80c3129e7204cd72dab1400c5c87b64dfc35ebd3620c8c257d87892f68d2016ae242d6b2e25869d1ba36c8fcd4bb6797d2c7fd35c990204985c495d8168ec86d036d5086ad6a48eb4e80e333bf0ca223f6f112c5018bea9ceefc6a84db4acd904dbf09ec98cc91cd7f23fcfd01b3fae0a38552c7199685e8300e58de95cc3d8c82fbda028d870f5f338e0357c06dc16493792af2df4a7225f87112c4b1acab21d4b8561b4e67be16172cf5270cf218e5875ffb6ab62c927aeecd5ea4f6bd348ec14ed311cd222a4338fc8112e6ac426279574cb53fccf0c5234fa31c9f2b33828a19958835b285bd7c1a3c50b570385fbf039cb7c065d4bcd3af8fe6bb6e0577153c0e01cc3ff760a23ae528e94730230284d337fe83bcb049dff3ef06ee9a5059dc12d594b9bfa49541b04ecf94cc02f25c762c1568222c50640056e444939e4ff6d3a470320c414707490e95689820e4f4e18eb180dd1b311ebd8c6d63b195d053ed21988833146a9fb5f0a45da5251173789eb33b227d14fbff0d7269b196e87fcd2ffb2aabdc05e36d73b2a4d5b582b7f524c44bf6a029000ca2bceb669a2d8fceed6e249bb0826fa8f24a7023c9ea49e3d2ff18e9caa28a5816e1dbba5acf67108f797c0f93fc0f1721534e496b4e396e31152c8099308909aaa387d4dd4ceaec2bfdd71b54b0587c9857ce9097c2467b4b6887e35e2381fb177a0ca3089836dde34cb0518b3c3b0f99774e66b8b44a2d529e49dbaa694c337cb3136734f19e12ff4605a1528ee7c999b08a81845339df8c5d1622ab73516927e9241e82e8d87ac6fb41dfaf24a630fcd160d75b968d2bd67ab279337d4083335aa68b479d8a2e8fc919603871b1683df06c43717d69ff639b7b2cfab79312598f6c90f6b769d1aeb82e4922343b0bcf3acf64898bfd067f9634c398ee12661e085471deca6f382509504bbce2c6f0176beb1e6e36b18c067249536c7327ccee5e0fc66961dd87c2e2db9cd749276e3a2d8bcd814cb25ad4e1419aaa3d6f4953f7ae300eedfcdfc8e32bf5c657243378f26fd37efd42d65e5cc0bcb1bfc7d9bc9d6e89c9f588bbe28e569a70510c9801f47d4deecd219c7bdf215c8ddbc6bded299bd8ea809bdcb04a8a53caf750615bd0c6026f1da6ff923634d6b7976593d4df88e9ebd135b9b115401257b74c2a66832d4ba4081a9d49ca31800cd51bfd1f8f3c441fcb0cafd584902aa80b54c6e530fa556e06930e9f5e0fbf8f49770496c2747f983543f4f4d94afc4f4ca1e8f3d1ace5cbc681cc402054bb98ba9892dee93f4c0f56477160f12a7d8cb6273b28842b3ab19366aa1ab224111414c3264bce985566fdc6ff8cb7d391cf1fcaea23bdbeb252553e11e640206bd97ea1656058be494f9bbdff06d618b27b59fde111a3155b5ffe0d060dd0d2f634ed8626cda78d12bd9f54110b3b02f27aa4cd831c031ad205f0fdf9a26b3a7374f28f992fea8415a32f4b7e5e6c6fdfa8d13fd61927ba13707c5e1d668bf3ffd3a5b29ec1c60269acffdd9663cc60271cb7da9e275acd122bc12b4dfbffe6c8e848c28db801553accccce7479d6dc82bf51a04ff332abee4d8bb50474646ce0002d23e05d3a6bb47d6be771a4e6afb8ac7694615282da5893d078d16d6acba7c84783a0a091b7290771987a918f2711795d56e743a911f45e4a66fb9e39faf19c4a6ce51bc4e80db9e579be90ce3145ad0d8422fd46d06cde0d7884c2cf29a8562c853f9416929133a109bb133256df5088b5128159a665cdf293fe538dc5af4c1b9e8f1bd849e0df8e06f9627a40edba802bfd06ca6bf92aadf05e6fc65dab9cf39183736341b868eb5a84f9a241a01cdcca0d8f4d20e9ee8901f1970ae3a4ce35026b97a8a346a2cc23509deaa88ac8e41321dd226968c169593eaf7d21a2e4b4cd3c4ccc65e89cd6c59038b0ab06939d7103566f0d04d66e4f5bc934c96680fb59cef62de7bcff3330789b45a376c8a6b5f0d69bd977f1ee9c80443dbeca0df13dee14cbad4dc41c8d973e982efca79fd0582a05ee57a883a9700ee4d347754039bb801ca54889c7a26197c4fdefa0831e5a41b772d48e40d1ee05a0ae87ce01c6c7b94e709ec6ece1b28c1c9fd8382918a8f02c60dd914e3a7203182ac63fc2a02f05e7d7ec960ac40fd1fbb8c420f90557f048001f2258740cbb1e5bb4c881b528f1c739a7a7387054c33bfacb4af03dbe75ab6cfbf8846fc4d09df6d50ff1dd648755cbda29e7eef44e3e4980edead1a63b5ca4b02377c48e1f99aed6d70f460d209b31d3a560b2ff5cc105c4cfe29142d84affd345c31425f4379032b764f4332d54ddcc3e0f0dc03518265db5846d1cb5cac278fb926f6bfd14a007a6aeccc4e5cdf76bce1a281f4aa62b23d618dfce7d7b3f1df8fcd6a743acec3e7c2f361472a9a398343ed6037af3e5add6038dfcac255b347f539c2394a9726a945e5a079b92eeacfd3cd24654766f9f48d9bc55176edc1beb4cb3abe408e7f5afb5139d319ce3f3ccf3dd180251c2cbb8058e5891a07e326a27f439f4de8bdfe68342e208f8694996fb5d1f1fffccb05076dfb898e95ae9ccb0f53718c6763965db73b7b12f8b8406338b68996652e2be942e6a040f04e39c18eede3f568ecb52ed0b3ee47edd97705b665eb3b394ee24401f7fb375f0a97f6257f1a9fdef02afcb5934735477e7b97fb0a009fd0236e01eb2908eba491332960832a1a0627692fbfe14fcb6a6f2eb01b01ed710a411383eb9424fb2d15e1746c7f18ce64c6cd21ea62b3a0de6b8f522be62276f2a3522b6fdf61c86aaed33ce422aa52f06672addfba87163abd7239df675a0d26c007e0105806b40aaded64ca38bc5339c87bb38e2ddb1a14ee9a5388021513823054885d47ead9b920fb0a2ecee3a9d3fb051986531e7e0a24b670f1d160a9aafad4ae93750c3ad97abe7ea54d02978fedae77f376e2ce4b4d7550193d02d8211933b56ee2b50fc1376fa72820879d0cfd314d2b6d766e65e96aaf1a157ae0a2708178337af435041b903511fb2f0ad0a6daade5fa0a9113c7a1aec20533745111f8a321f7b0ff9140146cf57ee266b95a8592ca825d865b9866e9722b7734369dde5de58a529ef892ccbe9307126bc0bed0085f3a85e6b2825a4804fa0184ea43025cee0e4634977201fda804420effa75ef8f910e383211e09a8b1119e7b66a8494e8a27579dcbba754a86cd018b0a755336ea583561f399b983eac9e97a54f997f6607dffa65bc438f7ed42f3797ab7d839128b01766fc9bcc9af2a9047c3257bfea6148b140931e51375776cf946e4d9bf67c95b67c0b4c54341b8d02c681401ba388e9141495e041aa00a9662635f8d4c1a8819b5fed99c38a91132fa7cfecb92740caea5533b8c604ca19df544269377e7dde63ee37a8f066d281d3806619318ce881823e849be1d7c26b332e158c7268bebc6a7cb7674f4bfbb7332ee98acd280c3bd9855e3bbb2fcd7a7b235b6e4bc4b0242c6c1c2756c914d72d00bd5f9e32fa12a3f779a12db29bcabefba6176e1c3e536c2b821a56b3cf849547e925551454fb9c670cff16386269c80f7a2e6332f56524a590e1c4ee265ed829ee5518b622567b341d84bd13ec1cccd9503a726bfc5f221ebe0b98a4230be91392ba7f53877344cf61043fb7f0e395215420c038e420b5c1ab82a908b5f5ea61d0b74a4b550d9a636cdf36d8bee8d7c2ffede08495b7b5cb22f26681d50080ea3272ae0e5b5c55f56a4555a4dc3cf9c426fd4017fdd3535ee436e90ac1b740a6dbcc7a8fbd337e9e2de56473f4a7d182b0974a83e472ebccc6e2b2f07c5bae2f9445398957af1ef878b78532c893bac62d0ca8f5cbde89b2a5e7748f70cc18c940f6583a3f62722418700e33267c3c797c5968a5d974bbe54b857f83b12665b9d67cf3190941e4ad4ffba8700ff0be2a50ebd311628c02fdeb0946370f6fba526a93c5c2b3aac45bb33937196105a5e10f8896d415f3d28981c5f2e1a671f057869147a6284fd3e6746829dd6ef1cce9a4b4f697a0f6facb552c8e8df83e48e82bb3a4c7b42bbbef4b8fffb3ce6bd59d5287f3b29c6b7829f44470621ec3b7c8aa38293cfe21b3147462f7b32aa162d9db797f84ad7cbcb110a36436bb2986d093b753416075a4158edd2ae4e155a8fd8bb161747c00336cb778428859019edaa17b50bbc277d6e13b9548a79bbc9b94a4d840e913c33132e246358b5d512e0ff8bcc6f6d53b704724afc3a472a255158a6a46c200b02063ca2827c25db6b57c62e5392268814700f9aa5ee9d5a8bc048243aa3c905470d8c3da56d11265e2d60c0e16c7636313b005416e8d71f8372b22c7820ea05e625c0b364c4d27b97c358453aa27e94a7781f9a287d45d5662c2e7332987232c670f48d58b846ca13fe0fc63e3201a47a872e9ec7cf158e4fd9fc27a6dbce5079d29f0b4513444a346913ec01565692308bd7cd70d331fcad894da165a313cd7cbfcfcb9fafdc6b987384240556e7b26049eeaa2a20bf46d60fc86ce2f0f879dca730ede79c9297a8aa7cf1ea6d7fd0f1117671b1616f232277fe00e36e7afddbe96345a3b3fb335b0738add4d78dff7845cd2445f1e20c7ecfdbdaf7dae1f7c35c3e6252f979ab313e80eac297f02229badd44cbc7540eed84b116a032d68e180e4b32ceb8cd52882420bc4eb2be4a5a95b66bf52dd14d5e15201da33819f351e84f29ff6ec2951138655605ef981b93cfcc9fead1ac0c77a505b2e4764fe55c1634c650ceaa16598b787cda71512c56c8363c492f6819e674fe9ea1fc2dc35fece34395147350a6b7ee0991b3e1c405efb48d6211465972eed8f57d7f090ec0c8104e44998ee0bf159b1093d581ee96d0496d6afd10d46c150b9de6883af57660bdbcfcf2ac65411860006a4fad39987ea420bed16b0c559d5b072ccabd24f058a916ee3d344e124e9b8e5d8930815385673a8a488d4fa599afa3aef13163b3183ae4e6a16690fc725a850ea2167afc43bf2776780c07c35d066a4a5c594a4b4b152c2c4d296fbcdfe9f275ab2085458f000140c8357e5e7b49ae802c54369003bee28de225403c76d4805ce48fdace49530e52e0b22c5806d137f1f9799e5b990669331e08f4a9e966c16b258430f06855a11ac8fbaa3e1c4681c3d531bb11b16d41126693be4fe82bcd6c0f733c1ecfa9e0672b6d03f7b0bee6c1e5f064394dbac4ba903d95cd03bcd3f260b82790853a44d60801da395e58f1fc96f52f16223e4f3a826949cb6f34c1ef8dc00976d8fab6865471d758c3628aae0555a37e462a3dca61d94ab4bac3e7fe652ccb169febc69df5a9e3aa29b90fc636be2a6e8fb5a1ae8c4d0ff7b5a10c676a8a2180e0031835dce52b3854632177b9a2e7e677f1a8d1f2bf541b28e33589145288ab4d4f2e1cbbce74dfc95c363782ff2315d3ebe07790ac03e66b57045c8eb5d80a8c97a617df5d208a7839b33a3a34b189c13c5e0560cf14b2a01007152bdb84733bf06031d2884269247525d0dbb75ac034134588bb3b7f30251ebdbdd24c8707dbdb75016ea844c4057461ebc893ba32a3e3b376ebfcd3985b3e658d7d9f727b9a0e2d79694524e3fc863e5d869a6acecd1e3fba1fd1c9d76c464042cda741f38a385300354d6e05b04feff65b9f8014956edc2c803ceb3396f442ce9b8474b47c98d682193a2d5958032a5140d3be83d2ff4e932576e87c439482b863b53c985f80b40be8390268dff616b8a81f18a557a0223850d831f5d1df4e1eb36aa717eeede7e25ffd0cc7601ec3c6b0dd56964ffa92328072d870f33459b0c6653d6467b9b42c0f87381d48a803a240cb2a5f3f4f15ea66bc35cc286935576f2f6eb1d4b6993aae454c7fbccbb0fb4c4773d94776fb59028b7c8a61ebfd9e5310f94a5e460fb1e87613f06f9df82c58c13e23b4340b1a986adda793566887e894fa44c4638b0baf5a01c3a600275807ff02500b3830df3d3e0d1d73c7e7f72d17c15bd30d3aa3c7ce826e0d984262922138ccd5db7e65ae4f55a165dc71679dd92cfacd07e5960d48b80c23ffe2dda625305bf2ca8789b49a7972e5f3823ada0e321eda97b9a6f692bce2ef178ea1b76713afa7b26a3e34a31b41f164615a580e9b6302354d6db7f6a6865ead81b13a1c3d69eba85228899801fb900d00837ffb39138827fbfa270c89082139c88ac3dd472d8de75b5a9d51f34f2a212597eed0c5d320e9c22b2367c3ae1218dc05fc21f542709169254adf91d442c7c9e711db6c359e67ffcdbdaf657e0e392fb2d8b9455c83aa6e8c849103b6fc64c0eb4063d096efade17f54391e74db44aa1418bc3e6a4a9c60fb06c8294db23f06aa982452e3c08160224df6d6aaef6b1d8abb359794e2069b05efae6e94ef2e5cf36d0560ad0107b65124b37f14a7378d7e59a94f20d01def3e0759945a0160b5d92bb267b86f89193e859095ab1fe4850427c1f1a5da79338e2aa2a6bdfdf5cab2f811742a79a5f8ac6d1a075c9a13736cd6643a7cd8ec6559f89e71d4cd7a3996b8136a633b6b6f8895f1733205605024d59acb3b7c4761180c19532c9f3c0fab6a4f83360dc13ea956d2b87f6e1aa1bac5edff48b7ac24c3d4e16763d564ab3e82802938a6e7d2667bd402e5e379697b0c366a17bfb67fb64b094ea732ad8b651cf935c330143ca72535cb1bf763940f79e9cb0055af27645c044fda65cce893e47108ee9dadb3419b5669823b74abe6d5824ba527b973ce87bed4e9e40e977e2b9ce724b1d1e62bcc37f91bf1a19e014a3d5819e11d9c6802cd548fd54afd1f0a4fb386f9a1863f50eec70fcc64f2a562b6bbde22222a4b77aa2003fe38be2654d9a158783f14ef19c78517d98e4d4bac22e56e8f9435bf4dd798375454043389d82988cf8f589dde6d281b338fda9a31c7beb35fc8833ee88f4e5543e549f86270a3450bc1257a6ad3cbd958d8c13c564316a39b145bccc4cd18a1c3739060f6deb25e5ab6d6fe46ec5370f9bd58423ada4e34758760186c8ac6aed7a440d3364753c97dfb2339b75efe7e77176eb3a39e7ce9ba419244c9ad5a8f95267b6c6fb024ae03a51da932045891fe162bf69fcac9363199f9ba516a4eb8165a4a81b525f4f4ba7737ada4e912fc47ff8057f082eda38fbea9cc0cb332e1143ebe8a89f91b4863f518b3c369dddcd2f07a9d19a0784e612d841f7bdd62bac4368a26b8069e7fecb90a81373670010d8f5366d892f4dc41c05a87687277c6c5abe9e37d2600df52bcaf87d6564160376d88c3e8490d308a500e8204f1543805f8ca6bffdc09adf14b30bf57478922fce09ed5413845a92b30f1c50742112e6538ea90bbb733e9fa03bfbad35b76e95f6a2014ea76cf51fc6a2f135e8e7a0516bdb036f0f6c71a8fb475b9c6b7de0e87979d764ae5a460a0f12e5f1f754c7dd49f3c2adb2e6d69a5ea2dde2ff9f7bff47eea7d416ef694dc48a8f52e6ca7bc5041281886a35c8c10fdae770e89760e65bc22b7aa57ade350471695e7bc766b8d6e58705464b62a808bed6b74a756d095d89830286c40e1014a9570d3c7633dd337629889275f7d441ee38dbb51b73b1ec7d4a2f4200af3060f20a8c853ae11bb9a6f7a39ba1662dc4f4fefb067a3254977e3fb77f33843b3692fafe90a593024dfb111579de2fdac5dc267c88047e7ba0cead4856d8aa4ff6d690e9718da944816f4badd9b4d9a31cf09100e992b2468130cf11af6f73819f8d59f116fd3eb10746bdcbf182c702d28507722d44d9df7dfa01c0625fc34846aa42b2e441f58f600db5db613c639fa97df719d13cd5417594d9f288312fb367788f769c501deeffabf3d19c7c96275782e4b1a3542157b4280f1b89f6a966c45e254f8a5dee88e5ee6a3015b889696d39f26b94a1c5531419e1009720c0bb6081f5665b5f8294f6dfc8416927503892edd18f870bbaa8925911391c3c84553fcfbda071ba6d5da4d4616af47775cd14032e16957818d13ba90ab99d1fca4474c761927d2a6fed1b52d1f7e29a440a6f7efe078512a88f1d6e45d02048fc55129850c40c1fab65b1362853f430c1960e44875797b9fe180726e2e0af4d9d96becef4b089daa176851a080d3b64e73f5717da4731eadb9bb9ce2254c6478e00fa8e92f8f0195a2694d1c582a5d85d4375b7795c85734a683a284a3f5c899be99e6ad685b3b06eec84694223e2dc0dc0f917a5b11d79c557ad751c47e0c86098f2cd6a06a3d37c3a7bd7241b59646acd11fcb98c4fc18240cad1241534f7ea32c5d28b869a642a16d1cf55d9bc4ecf9db1cecefa1c63d083eabb43bac6ecf9830cc60fc7dd491951f039b51e0143a9c0d9c846f5f8cc084fef3f9babd713def8800a29f2cb129397c6946156051fc34997474350ea62e0de7d65c9e9336773a73268acc00d9ae86d32e1256135c9c630ce6e933c31f1ee395b35efe86d61bda51360dcf901eca151958b4a650ca88fba8ea529179839c057df0c955bd6b7023350be7765da4bc07257317c99218e0a2f042dd94e705bad19a9c02f70a4a96a5b68b35b4e20dc30a1ca10c53fb2aaa804ac91f31335c65d88faf0ec0ab0eceb5c2953eafdf8961ca18760ee05e1a1d285dd5753f8b71a49eeeaf478f734daaa5a810f2e8ad9b7448132ebbf5f55b19b7ee0c8691148d2474251e12d419c266721ec2d6b1def5d401b06839451708734e5caa168037b69a3b5a9d12e89fe5657c6021e5f59f89ecaa73a04854bf2e7b4f1e7aafaecff32351ad8d953eff5905327367c0d7c175bba06a4322d84c3a141b5d8bde6261b7eb4a2a7ee96ac7d3ca3c6fbb23bc661872224668f53498ab6e76eba628d719cad56683f321c90a0c6cdb4e5c32d1ac29286990fef82e53e79f29946ede1ed70ecfd0fc70d78a4adf63953ce772f4a5d732a945113e3912e33d6ce6a0fa2edbdc43a521e8fc3e239842d30cb55808cae4cd3d7fb80b661470e7c8e4b78e3ee6eeec688693aa3d63cfc98dd287fe8a0246aa2b174547cdab613eee9f239a7709a03f2ff0827050a04977c3ac8ebed7ea9893c9d9b9cda755cddf07456aef1469fe3c9e0438e37231f56025c9eea7bbdd12358e487284383a962f4f1a1addf26d61e262e93f272d0247c5e91f0be7491d6aeaede07779daa0ad3b514e07cca1d8fc7df31165041943b338a7d4950061b2013a8912f548ed4a4d7984e93e2cf47d1c1e6f0c95ba7e6f44bbe080f5c453b5534ce8cbc84f76f9fdf6f7706f00e4aded60d7b0db239dcb4fd27e08e8d0d4deb93c187824d57c7774c3dd283a553b85c6de94ab91460e1698e930b4d071cdbc3e3e163ac0a352394a2b652528daf943c963dc0dc0c1028d1d08bb5b298059cf33deb618cfc43b201589346aeac6b0807128a2f34bdca4ed0cb2212a9f1e4bd4c88b3f45dcff254c4c53ee30d531257ce08be265ee8254ae78ae85cc226b882610f6d629f305c8ff3680afe9ab9f2f9be30e73b71539e7bc2ccf3bdfdba1a4fce5111bfabedf5105daf48317a11ec30170a4cb3867ef6cd638b209f538057b6d0d12253d8adb160c16a5301569f8132061107e8b7f1a96160298627f3e15e842670e92b0b93b451b93340ffe25ae15bd910302ff383742fdb14741f25069a886a41a6ef13e77b34d80615b43885e6322d962c571ce1c8bd72382a65763a15a1c5cbd80c781572f6ebf36a3ace30414ca88282e2d9a81f2e79808fce2ff153cd49c29d3f052f3ce0645f93d1a88b6a87698236f21c6212a7953c0e912331c1bfd13a44afe9a9d02e88c96d2d2e02de426da75e2b766b81a14e6adaf86c566f650193f9d368563df4a9717d86c68e6c4ddf8b86bfb083bc08e7056670df4857beeac12f3088407f770663bb287e8556735457dd5fc6729a3e7f9dad0bfc947c1b87faf92c4aed370e0dc2a1ccacf13b1a8d4be2cc7652c4f90063b923931ffa14ce8349fc2f2919a30cd6b15ee92f833a302e7c6f50962a2767b39c56984d6ef78c23bac98e17ee52440b496864ae179b5bb39a42b27a31562906bde1b5543c538f5fbdca44789be255ceb7f8ef0bf023b5b9551cdb09ac2168afae0941f1b62645dccd253330aac77ce859b658dce93468d1dc8b7537cfce3b3dfec8b96f0bfcc5e92d3d4ff4dfd767375d0dec6cf968a2e1f44ea241ccc12b259c8cee78cbd245c2b2b491af11baa90da474d617568cc5c1be7b9cbdca95f67db4b06f39a33225ee682f366b6c11da3123ca3413c163e2a310e6dec9ba2f5dc6197b79b05acc133a5b7b3f2265b8a131ec5aa58aa2546f849fece2488080267d574ca07e77d9045650c80f3b2f86e958627562c5bdc206dc955e88e7d927d18b6f8ad6110d9bb25112a1b6a82c2953f8e03d12578cd990486a9e63024076af78b142024ef4f4b9da6a28c9c5b4aaec3337e5eb674d75166ad47942275ea526bc1723f058ca42b70b65a964d8ceef6af7b081acb93ccb525bd567aa97a111de39768d26dece","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
