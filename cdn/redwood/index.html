<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dab16d30ce98abbc7378d026ad4eecf61c0af941a82997acbf646d7175640c50abdc225f9d8b0fb0cbe586589b25f98a8fe980e3bdbf860d5529d84e3917e6b14ad7ddcc44b2875cfbc00eceaad6e86855af9ed0b5d02951143ee476cb7e63e35387af4b3ce9f072fb820033345c4fc62752bcb3513ba41dac8d24e54b6224f7ebb1e85eb2726af530112d7fc2f50d999f7ea583fcbf681fd64d261db9b984dc352649892c2149002460d3f66fc4ede9ab9d63b7e6c8a6c9eb51b23652196d4a9690020583b681043015770f05797fb2b78e0c3c56ebac086c18cf8045fb09910e897dad407d00277e16cbd9356ebd26854168c288280ce32bb0797fae90d0703a1ddc220825ac4ac0e6789180d80e4ae4bdc6585ee4e10b449b88939e25251a79ced4dd1b4aa38fa905ed719d721ce72ad02d201ab8fcaba85cd6e5105ec9d76583956f3a474ed2c05faa5755043fa8c5cf5af38b7845116b11c2d58ddafc652763c3492cc1de35a900f57818039563d99a3ba4cb99003db6d8df0ba6a428849bfd6644d6e2d02a994351f18dcc033433bdca23114fc56c24b1367fbc1f8109d3b6b2341339f3349e81254101dbbdb65c5a4b47c31f44d8c6e477526148dc5d2e653c295d077a1fa478613a4609d9b6d8ea2e4e27034412361bfc750bb6c3e96098a336e3cf230d3e4a08c5bdfcdd4a1a874cfd41f83c9d4e8fd35796d3afa69a4fec88e47f274571792d918b08120695c32b1709e40ddcb181f242e18fb387ac8797b64c5badd61028ea3c29be8c2b995fa56d5e8cac3b8d20d977e47cb6744f8b24034506c3df3a44cb4384f64273fa09284d232e241a252cc75522328eac6fb7dbe469abc0aa3bc3b3fd98c4587d4c8d85309b2095dd3d227adee38ba55a80bd07ae291ba2e4a465fc231067f545d86f89b7165a465a64c2331389beedf4a840d3e64ea025fd18b9b3ee89b9f5b363c1b4a99575d40fedbce3286d5d390b533bba8c22598ef9a0047bc1329466357dde59fbb313967e90941401334f9022aabad9c05ea58dade1b569b2d2d2184e025b41655ff6dc15c3dda03cbecacabd0a5bf87efdabe0fd10373792e072135f392e9450e506c10c82fe98d698d7b34a35cab5e6d4b31f49c3a1c85c5efa18bfc4e2d9fa6636f660b259bb79d450c9c73b6a54bde654779d3b278097e27b2a51cd9ea152f9c0cfb104aa5c33ecd0c850ab935bcba873c9b909e6c44832fece4257b115b84401cbf9c0e5c0af250684ff838f650a259deeef7d70628c22180154ef85de0b4fb0e81793c8fc9cc9fee17f2ffa685ba3a0b5bc4ffd17243096078ad7fc22d9a61667cdf771b9ab9263ba1a6726e45f348e02faa4ba055a6349046fe702a883bd5857028da265581cc3a82c32cd983840630f10d223ae57ee110781e22b2c5a841ea95ffced64d8a21c8a294406533eef1f3d76527117fcdc71bcfe8c23b43d95a9ae6fb158b2759811c2871904b2ca7e3d16846fd0d08d298daf3e0c6954ac403cacc63a1b4878171d06943dccca74fdecbda1d20c5f81792fa5af978a82af32531d278f8d6bb84f8262a9f6566286ca7c43cd7b8ac553769fadc86ab5e7da3f1a62a3c76fb699d895762a9aed6955b162d71b5529947812fea9ed9b98f3cc18545310085a89204b4edb85c667a184ccd08dc36bb959f3cdaf026de6d2f59c3a17a93a478cd795b485c94cd81e887fd7a2c76ad47ec4907b195e50fd44f94b48a3e9f2c5f080ff16a4b3245411b2fb863df8773ffe53fcddb024b7eb6a28f7f5a546dcbe313e9b6e7a6f81f4250261d2375974ac571df66f73720b9a3018dd79603e7346c4ab57e688a79b2ceb7fbde4cce35b63e2c8d35ac721066c3245965c240e58790463f2380a3b61cabc9ade52cb36eab4f203009228ce6020ad880a837394d088d2e26b4ee9810923dd9caeffecf8e28521859cf78907c85360d4d403718bcd61ac5d35838ece74d23542c891b43b24874447e86a5e44334c561d8a82e232b662ebe15589cc9f8713d4862bba972f099d713341f425bd37139f58574604badb6e1cb0a2dafedf1b32910e818549eb6dc4ca1c8635678f2cf2008dfda1413a24ec733a548be766bb552c99f31882ef4afc0f9930e20fc1dd3e13093a53b65ffc4e09fa0c410f317b3b8d1673611735bd4a8464022954019c3fb6761eff220a0a2438092778958f5bab0d1f76b2328ca319c6123047698f1b5b1e09b042cddc0484f61f52f1feb97263fa302e7a581c789b687213665c74758eaa46341a64f53067b9c792a42cecbc82fa2e1a5c2d9eb0e3bcf5a2b51f9a746a391e25cc5c0e426a2052af9fafcb011ec533907a7361c30791d0088fdc60da459a0b031f93dcd8fc5784240708e8cffeda71f23e0e31a3a7cf880fbad42e0726b127091d518d72e33f5e58c37cce6aecc8a139ff40b3e2afd9b89c01f36f710ebeecad1171155ee29483c09ef9b613a3fb97ee86f7bb6f58af83d4edaebe10b259901d563db1cd91c3e36d1755e81c3db8f7db590462775279158fa57320b8d812b580a90c9803125cb276a0756d02bcceb28dac59026c4374a97be41a9baa8abc6dfd443145a4ee767764dae19f169936afc1338f42aef3a70478a09be9cb52351d46d7999e4759cd0ae67d541a73f72b8b86b72608f9930818deb380474dd30fe072108176b1c267ed56c49883832b68b95031efe88c6a4fd4458c250afa0786bc8967089800353928ad9a1d50d97477bf94b23f9536c3bdea83df078083ad78c2d601dd9ddce931034488d8e91a8a8beaa0820dfc1ebc38aa9895180d97e91d5712e1da6ba13072fd463a18d44d323a64f6908aefeebd68a0854ac19fa36e57514ab2e1fa4839679762076f32f486ae6b716ac9e54d972a1a98ac33dfa76b6b25919b6cefe0805220e87c85850a5a816a72c454f15120393d623a9571bb12b8eb717c9375980ef3cdb8a1c6f4a80048df8c8038ba576d7f2cc0b5ec904435094307dd492b11a1e8e1b92f7c5750da9307edc8b1a1345c1d5bba049114ec3c1aaa08e690a67717611084ebc1624a73b04da6f80d6f09fea87bcfe4f1b91ccc263a9f871fdb951f197dd890cb614ed2ba5f5e08221057e65bcb0a5134614709cb24d3e1a78f532efa41d033488941fe6c1dd7f9158b9ede2af51d1fb50cab94e17f8767fb9a606b759a93c5b246ef17eaaa30698e78631261da5f909a43e76307186294149dfb91952a74aa7e892d95a3e1ec78a502603ff838c3ec80764df0a09c425d67ef0e730982d26c056c0f28dbb0842d0dd56ca9ac4c1dc4e087b3ba4a8e01a0f8c76db827b3db214fb513de81f4dc567452fa6de9c1c611c9b815f0c82a3559d58b52d231e5343b916c535f644d82c5bf6626f09762f0940f3b094ec42ff0ff35bbb9fd17c16dd8793502bca3030338a5f613f72545b95d77f3c18db01753d85472e20b899d975948c6381787807c94eaebacf9e3dcb17f32f77be866f822d759b256ec8d2949f9f8718558b840c1ab741776eb943703f0ce5da0d1d049cfda1541af692d974b4383f24b6f57cfddf07ceb54a4a7e795a9f0b6137a1825c2cf30b903f9b4394764b76d27aacf5630b41e604f9d141e38b0dae2c2339b27d3f26cc4ec5180842ce30e826b62b2fc08f0cbc061d96b4b65e5e26876258a9f520b6688efbbe124cf230e5d457d0823e08c58b57d2f9ae40b02ef82b74ebfb541aa57f14eac0384ffdcfd7a7425d701363afac9d8ed4b2a8cdd0e68ebcf60650fc8037da193e7a81c6b418904010e2c5191a8cdb843be576024d34ed7893582caf0b38c366f4348330400168ad33b12a916120f65eb154cae97a4d0079448b56494d1472858a8ed76a111ee0a2469cf37ec9a8cdd253bc5980922b72e363dbbe542c0945ddf190b205c77d667a6527de42d4e110e45d7e14e437819bb85a66352f355ca0d43b531f986949ecc0dfe54bb18bf3afa8e4369e80d443a8d0edbfeec8888dfb4867ed0ef1d29683b7e82ab8975d049b35b9319f2420edadc0a59e95f066579b61b232de8bb9f7c13dab221c49c03ae800c08a5bd00c67bfe3de153edd0986aca4e3006bf053086db29dc24dc3ebf57f55d2a4c588bcd4328fa84a7cd1e33899c894d4e3a80ddb7ccd05bf4f79e0d7717d58f63d004ffff7532b58df36edfca77d65cd6dd374929cc689caaaf091798cf62654ccc33c3babd739139c8b904677a406edec2f6e6d64cc5539b488dc0050ef65cd45d2cf28f374c7ed3a659619d086350f8d7b517de9632e59b9fce230fac553c270c81a3f535f17f3008fedb7b703d74b1c585693d43eb571c7e32e75ab8368283749b14be26c992f9db7a326ceb5162a16e2cd270ff8c43517bedc7f15c0e8bd5e3d2a2d1e2cf85d1b97c834621ee0f66c7cf446dc583b7ed40651a7d0ed260bcaf786c9d1c6ca0267b85bfcfe3119ed8f6e0b0c6ac96d2cd49b0439077030244866fbd28d1971cab9327c932daeb81e067cf3753b267226a599d3b73f12112e15d97f2902d94f5353e4acf7b5296da29cb4e6104d911e24929cd84fe85dbcc3a2790c958841ae3fce0c0aa6bbd6b54be2c17f8605370d9e592511e6fdc1c3015885a7058d40a324ab402f919354f80af23415c9d447104714d670fed04d434ac92a77abb55620b168b906354cb370bb090d537af2850f2a64b2c08e83ef3eb3a52781505823aab645b7c41c3645e51050bc54727ca3b01d1880c143386d794ad040e597e1d5f8e9b63356d6f028d2da00eefc18c851a8ac80e346bf4b41afefe22a907ab7c9d82f30da2d58d74f9684674160e57c7493de4848676e6502fb45861ec41b4499808977e28455771a4af9fbb6e605d8f5b1f763987606ba3da2374eaca270ae83b622c9b2ab8484cabde73b170cc08b8835c87d197a36d0af654fd48f6e40bdbe2825b12477955258dfee9bd60e00ce04bb9678fb97010aa44c9c04463e2b022b947855770b6e7b2a8d4096e4283bd06b92cea8af12bfb3a3b73663f59c436c5e98fdb97a5ea2116ef60f9cdd357f0827155a1f334f55acd44e804638ca144c31db9a3b4817f477e14fe286f93d8001d637aedbeb62d6da6ea47c2e8c95d503392447c30c050d3856968bce2cb30943e700b98a5f224a5c6d3add62370335877ed84b07ef0944c2b3668eec6b1ec7df3c7d13dbc44a23541168531175c4e8545dc4bda068b0ff5dc47179430d65fbd8ba8882e8a3284f665cce1b420e062330495d3373fc74d24d3783f933a11388690a2fa683cf65ec4061b571dba18081dffa9bd5c104694ca34c2a4798f01e111a79f0c787f5014cdf9718a7465a19889cd05d9dd0a17010e7d563e16bea6a0ff75d00c64e0141d81ad9144938ee089cbb2f72a7ece96d428204466a157b238d7970ac2dd232bed3cef60280dff737be6ca1d8dea2259f4392e33e24e856fa3c664206d3a0c012d893460985d61b60839b814e4d838ff8acd59b7d51f9dd77a24ca7ab1a422f10eefd9837dae0983b5a09ac2a9473dc5083ead4b21353aa2074f4484e2bd3e42b01ccd9e2990a2143919a399314bd6efe7f85b4f2722d805e694ccef74f4aeef7490938621a843ac6b73610999a6527ca79087e38c35258e0cd8be48d2c850be9537f360d739ecdb47c9e4fdf826b1824d241125ccde1de87d890b2cd33916033b6a5e642ab4392c4a09efc41e177fade54222269ffe0a56f0ef2f34e14e8c8f08cd1236697e44c134dd5445e9e06bb6d6b536f621c6a938f688e9d8c21af7f7c72fa1e642b6af6dd4ff24d1300f948b064b7f983b5c077b59f34300b732ac925ba0372fe954a0129f3e87cd959a9ce93832af669a3cabea432857590aaefb3fd74116300b70de7240d273f8335b80293cd45fead74a41c345ec039c88c199b1fd0af2d3de60e4995f870f09c737775c42764ae4017dc63da1c89de9bf1e164a508abae447fa9e042ae9a4f03f5fde8d649baa623e21f462d8965512281cc6f34ac42676570006a4340fd4a19dde7b45813bbd36fc00df02721f008bd6877d527a38ee3f3b840af819e4efe8474a383f1c324a9136ab2fe3b30882a28088b432c979366da10adc0f35d73333b6447f3bdf2fdcb030e3eee1e2c145d3e9193617ab697a69db7bbea8b6a1efb6f6d8b9b12c4a28387d54e917329ac11a91ec62455d6c0d370fc020776f2fc9269486850eca9205290a52b3165e9e3a7b2f4945f35a103fc22eda4e29c3407474ca044de0c7679d5b017579b893843426b86fb3a94518229bd7a9bb451828bfed19178ebe533b75aec8c7504df1db16bcf6f8d020ca5f115751a1f0e1f3b37544fd9ff5c3c1e15a6d44b1273445fb364e184a2686b21101ff7bd9e015a1a74aafb575601c9455e5884536c51564aabb4702a79eb3fb45072629fc0c6e6c384bd09e03385029a5ba0c5c8c3c4fc3d4091dc91dd563a35b16b936916c5dbcaa6cebc7dfcde22efa15e371ca0b56a989d34cd07541432044000c871949f42272a7bd84b3fa1f37d424548e0372b60eb333b2c59be3b0f5ca06ebd90f072be30ae8d400dfce3788ab6f91e4771db35e1242b336d26ee091a21c7b5845c0543c21a79c824e60b21fb4c82513c7d67a997fd4d2baae8b0bc617c0ddedec2151655da132aa2a6d25c237e8b63027b199671c1574b19c11770f483a0d66749cf47255069048a6331e188538344cfac0c884c0743dd4286fdaf1c558ef3eda8e617b8ea22798f5ea4013b0fd39ebf08ff929a76bdcae3e6033df00128968e206d24098420aef8bb16eb44cd3611be6c64d59fadddd94d2266040983587854a77a5bdf46352e92b99b68429fd33e5a051c109ae96d5392f405be19bb6d52c3de56464b1621e4ea58b68e6df2220e7087d8acda7eecd03eb15de12c645f5d998def75e9e48a354f3cf40acd6a80f76f1280a14b0f1441355a976c02aa6eb07c640866ae0a11ab445cb2cb5d9c435085fccef3c36ad5f1a8b1d9f8db14760f62ecee653205e90526fc6ff5f1d6779a146a5b61f4981db4b8e4809572cc895b86766d236173b9aae5dd9e3b1c449a39156fa8f012435d70176718f07868ededd8e9268861045014251106dce68f9e970709bd89e8540ee0afbc1b70de0043d9df7148903e9ed9db39ce91cd1c06d062aa43b0db9358ed84b2972c7d7ab78195dadd73eb414042de04460847f768bcf58cb238d8a8cd64e28cdb7e3e94efee4380e79ff465f010ab03ce9dbb1efccb922585acf0e07ad5c81a758eca634cb00e13aacc9e35e1ca0ffc863b65998ec626e82cdf3ef4e4cf9ac7f2d4f3596d1540beb9de9abda022c844e0cdaf5a3877acdaed56099fed501d78632b896ba1e471abf1668cc8b5f08a7700b811a26ecb2bfc01d2cc76f84e0b910704b3c9373e8e3b44ccf7683cd8f2cc84e4d5848e71f4f035f304c03bcf65aeec245948b1c16042ce671a531b773a56954dcbb916b2ab374dad8d1de4c18558944782b3169c7a5b3a61cddb440860bf26762eed30fca93420512b348d76b59aeb76766fe7c4305eb46ea67808495b70bd0faef1a27db086105d56761b090f72f8754c5e974626c35b6b022c6cda84eb660c1b4778125652899ca93fe4786609abfe761a24ee1f756af9fe88c355db0cfd1a943ad2268b3c73f384229940f5372e37500f5392069e5eaec6a6703210f9c6e3102f9c30791b961f17219f0c8b9ccb466532fff34aaa5aacaea262e0b6183d495bcac435a05853bf274e5d1f3375efb5f461031c81b4e02f1612a78e167e40c910c72026492576a9adf3a6cec6499829046031e86b73662467486ef175518149950bd0f54c24fc66983b31410aafc684f2f700836a34649312788125e0c82716ea94844b9963f514b5ab640ed1e1e70ba2549fcd025da5f34abb983d72727e3fa0ed8149babb35656c07c6912c550408c3b072f096aa4f48518d1e35e8589e259ed106dd5adf0e447212dabf946bcd748f2d21b65e94beca21f1ae95d7bbbab8a77b5dc2e65a2efe8cbacba96c21766a7c55cad2a73b685852c2d83884358441c17d0153c9ae8eeb4916be1a67fa9217f49d63e188a99d9fc6bf0f5f0c364147650d448c8d1d4bc68b3f611bd09c0488119ea746affc449b9e876d82b12d665d1e414b9233e02e57f494968382bc54767d9c60d1c06cb5a430be9ee6de4b161a3ccd24025ea09136fd1c5d1e21db7bfa34e5b1b401f362b65d2a502df4bc43ebbcae969f7d7c10bd03fa3b6c5e2388fdfc2e40ec8ce76c35c153a1465d4c83f396be41f26894bd636eab9820819e8d4fdee10bf3fc1482b8ce51d2dcfea1b492a24e59ff9c2a1119d902d15602a2b11eb781839a8deab272a7edea27bc859c7aac106b3eed199dd5e65a33d03f4409d89039545e5a346dd1585e5065dfd4726bc4ddcac4c2931f4e718efcb853605ee381992dffa85f2d60a7906a17f2bcad4a5b7e451e82b435c928d4c6ee5ad996a53b41759ced64b3e64423c84d034167ca7fe29fad7c09b6f852c373a563b7df9507dd4c71892cb2446f599c9bca33de6dae997fe5dc40bdebb7dd4ed94de4e306bc71eeb6e78f5457a6b931ffa01ff37ddea03c1c6e9e65e001da9144d426f4716e5ba3d6e9b3bbdaa7dbc23524a3a1505d57b60388edb4959531af49756884f131fdac96bb171923dc8c8feeba82f58a0a7f4cd7eb48967200bb553bc107761af37e912df6022c54fd3daf7d884fc4e792b2f070b8f465712ff044f9e009c90276c2752b3d5cbf7d0465975d0f2e74d045ea149a51e039922d707de104e2685d34197aea0eea8e4c7c0576e66e51b5c7f5ae3ce1531c964846196f823e328d942532bee257d0310c8d8e33adb8f2d3c624a52bbcbf54e98d60c949d02d895b5ceabd805a0f18f483078a1818fe458bf7a193cb20842b9ee7e856f0414ecd02891f2f541fd8a5b1b9bf5770e00aaefaa496cc91262ddbb518efaef15e5a8feedb6cb6d18c909ae533f0c2b8e546260754c997754260e21cdca55740367acce9be6c178df243116d771d1a2cfc4f630f8151cd8c4607da588f928095f438d083441ef1ff86c3347a4d42389876365f84c5feb02dc398731e3aef52d484edbdaceb2b557ebd50083cc824a35a3202fa0cc1c081f4e0e193a4b27ef9053a8990af8518906ab45e9c65df80f2bb2a61f15b8565d01363669bf2af4372b3071aec4221505b3114f2c3be43c2a13ef85fd6c55e528ab386608f165aa34ef9bc1b594b9ff53dea8ca2088d5363e80fc0f541fca5d71a0c83d488bf27291794418f50e96c87fc7ac868732d9c825c67e539c3e63278ebac2b5501f59666898f915f23fef4f1b7bb00b21161bcf6a0a5cff41bf55166ac0732490c1720ead2f9111d8694e8cc7d460a88746655816c49fc875173697ef7000b652de4adc9ac1c0bc95faa1c7c63683f745179d5c7612ddca1a19ef1ca94cb730b4129b96690204c24a4b71d8f9bcbbcc537be840d0429c666294f8f5fcbf10ca12a53a02283fc1490abccacb6b8cded7cc4dc0cf1dca5ca19fa101377e48cd43f3129ce5bb20c3ec3eee3f2b25ff6e7dabfe68ca8a6af6f1728a09319e43478064c4bf571c01b119102b9fc8ef70deed77f04600d0b84ed252bba77581e86240aef1932d3773613c2401bbc21e5f86b310bbe4e2f9d509841ce2f94a81f423cba795ef2f664dae7b345b7ff2561d5852481b90fe60697b52dbc09905377c5583dab1e2edd26f7b1136be032c5a2376c28aa355bbb0a50065479db2a216c18902820ebebedcfb135a2059e68795b817238ee47e51a8eb9049e9c9e636f177c6d88fd856280342b70241acae55314cd3ccb2bcdba4cbca53746b69c800c107ca1f122f7285fa418b437b8a8c35bc0370be9db1c232aa11b3a6f566aed607f59450066f1d5b014c336b4252b275d22874cc771b4daf692c8139b00c6624b5e44977d4b6d0ab48d12a6615006ac98b2b2ad97eb1476e7c5a6d03334e7d0b7ec653ef41151e7f75bed56d5c39841ec52adc4d45a4285ac0638b416597cacb50f214964f029af36cd7b22305beb3718af2d0056a8a07843a8f81aa54989e79db779bb1426d28294386ec84fa64fee6a06df23f74a0dd5bc5302204739e301ba75ff4db88f4ca1459361f2aee28606fb11b220a90495dd1f877a303a6160d128387574d27f9f925eef3779e4c6fae8e42e86a2fabea5d4bfece8c68e2064c2c918a495b56d8638cbd114d9140c2fafe4ebf9544dc43cb15df6b50eaeb85805f817a3dc66e249310ef43df12c200b33afc652aac96877e925338c1edafff2840357501b1a9a3524a0d86d2f1d97b4e591ea115e86fb38d7db04ef35faa97b4641733e6702ddb8f64fffd4e9ae1e6465a91639e39f7dbd1b1652810c11968a2e31eaaed5bb1ef4471af4462dd23ceb87c292cf26ae4b2802faabb74b1bef49180744ac6fee0885052a9d2e83bcc6555a014e5d8efa090e565638ae052f1ca15cfbc8cf835cd67cfa6f42016c3475c2b5da386d6d80010e9c36ef3a74c5a754f435f8809715d9ef14784f813d16fc5d1680042b63113e024bdfaff664fa2032c200b9ad0da83d394acc4e3fa87e0b40b89be2637631b9597459e43c80b956463d0920a5f1ef7a7eb1e0fd9bcf7faaf05a6cbedebc400449b8ed53a2ccfd6734d96df70d1edacf3c6d5cbf72a9b9357af412c00bff041f43f83fa0cf4762b2a046c6164eecce16dc3ea86c7c7204331f79f9fb9e07a7149692e87c884fa48792bf29a09c69e1b4ab79fdfe63ccce26b589956308df01f6456f66493f98c58e804d69b678b0603ddbb59eb884e2f79c141aafa9e239ef929fb403de85bcde58d3c60eed47621f126de5d1aef55d61b9ca673f0d20852dbe2ee96287a07150fab3f62bcbe4007d1b6fdc45ac44de702afb3e7e51793358edd09fa854fe233811aa79bb1ee5b1ab3245080ada5063d271fddc92d7cc16fdef1f82622d7d60169eaf33c28679a3abd6db56230ee03ab7e5f30de15d0131545f9e92a2c1e89abd8a60381e24e08ceb1721eab57702320d0f11e08575b61d14e81846469f1976692db4d3eb5c162477b9108aa5223ac652caad7dcf22c8b6d2650b8b8ea944a2811446a4556b9ac2bc9ca4503f328459a6c9d39d337e87c8b4ee485b24a68b1df7b17f411b5dad67bbf064076e5aa5f694dd46e36ff7fec17f593d56242a69921519bfb23974b15e532b4794d9815c7fdc3f23cdbc01629be1df4d50880361c7ec2bb58b500bc7f50774147bd5beffef12f9d41dda1c54d282bb917da77aa592e053a6b6d5f4bb0af40295669c29b7f6827096cb2bb669735cefdbe797467267d454e6926d2fab644f735ca1de774012c93cea17624c84975218add06020c9a592195b284f71b2457eaf2078f2249134ab3dc7069fc0ff6caa5130c9420a0e36aa0fdc869ac36c856d7616a49c5b770c958f8105f4bcc302518d8b552922984ac3a64f119aa7c5093f101f03f17f70085447b5b4945ba4cf5f3988876bfcc4a02f5d623521ce64a3406a7590ee655d5773fd9aa86fdbd09cf1657bac17c7ddd99bb3ed1684524b7c67493bbe7a8ba74c1f2eab26e5449595223e22222f19176a059333e36f5fae9f51a411b5dc9582172af010b19acb0dd524e14d0bb4628f1de16992b5f6f6c3432a7b56abb4c7ea12e9450e86863b26788ad4fed6451af691911cdbb9923dfca63b828ba7d82ca54270de98d6b0837ef4eea3dacf63aea4843976f84bfc454325fa094ab806a55106f58a2fda694d03825954629e2051379e67c02a15028099225373ddb0fd298941b3a0dc2898df1c3a2bef159412ea6cb522c774661c15d43e1f48fbfa48548475e2c0175b41fc50e2065cd5cd39dddf886ad05be572250b7ce0a4c8907b44900182a61f5a3118aee78f8db1f144383d414021af7db446cdb35308b665c28b9acf3770174e3e4bbdadeacacd3ff3b64146d3248c106564abf907890dec526eafc8f71ff5bc65301c7c42190505489abdb16f0990df9abff33581a033afdd4b4dae2830a8d25098e1468c2c5a684b6393fa9fda86ae58379cebe8ab9f670d46e8bdfd3b40cff18f6bd964df1e798bcb9c6ddc7d6121b03d793eada606b2db45eee7843db425a005bcad7413a6c6385b6c861c38ce6e4227b03e7f5ea7f05668a08b22578168538e15433cb49fd6100f3cd8b69f1c2141aefc8af81b50c44c7874b18dbbbab7cbffbef002302b09ad5be77406c0e2445ff1f6f4ec67be808f7d59e9b1670dae9982ea2bb0e6646d22be466b1aa47eb09ee0c14c6a18292a2cf0ac92d3dc6fe963694cc7bc64b24f1c896dcacbcf3b627809030f4594fca62cbe75f6e160ee2376f398e03d24a6da7859800742dc9da5d77b02a11c68be191449801d6488c82731ee6ef156daf40d0a635d83796f6f4cad133cb0b8593c41b8112c8f1182ada359f8bc82f5827a5deaf43d1a222ce103974a36c17021dc0bd83ac0acc6a145077b7baeebd474d662a2b19a301276337d57e871b3d48812ef216ef9cff43de00ed3aa1295748a0313a436fd74878ae559196151de7940e167fc62ae88e868f5a0e9460a08b1dc1122ad9cbef8e9ee93d8df4d0fc619590a7d5fe84df0708cb41e3740ee43c0c9550dc73f4fd72ac581a12cf33392f4b1a309865072f8f6b399d4044e62df6b6ba588114f05819b536eb3b5ad5868b749e8ef757fcab86eeb496bab67676d041bc4a4640cceba0502b91ae9cb655cf0988b2d9cc469ab94465189ec0c0d3b349d8fd945c0f4988626aea1347dcebd2f8e7548332647f82b3baa6a877f90dcb00d17b322bcd0120cdd155a1e044a09e80e2edc74303b693999ad2a6497f1ab8c1c456b55c3c2a4259dcafa561fdd1558532dec4b41389be35071bea32ceed2e355ae85bed9b94656634c9e936a3424ab686498f93a2349dc29eab49029789bdc0a7fc00281502bc1a6887c32c5e214003ffedb1647bd3f288f545bfb4d73aed84a97a777d029689da65a3b8f8659aff1d75d78102922cbfd506a16bc635c74f1d67a193c2957397ceebea57a8b61ae31d43244f5f5e18a7c1445df1dbfcbf93f4d2239632639f8335699592dfa92789f917932f597be321a19350a3dd949750368f07fde222d37730a3874314cb49ded890ae28f8d42f24f692d3b2daad8f99fb993050691af75dea51f0bc9e3789fb83b8b504ab536a321cc698b1ef82f32bbbb14fa13a0f918b1257df0ae9a2d25f6d5a42dd31b5224986d004a7a645f1c56df0b1081a303bca3a9e60c176a299b71ae87181306fb8398adbbe67949afa96a998b3349d1041ac62a8de5003450b5ddae6024ae0eb962d0fb373ee6f5b185a0f092b5726a34647c279f4a780027db4528d41e5491cd24390e095dc50d3b678c29bdce962767fe42fab5bae22ad18d82c641eb0fbf4d941bef7c65102915ccdb13b1f978f8809769744ad8db764cd9c513e7fe3fa138e47ea0ff497e3ded4969cd4a4c612bc0f96a0182f2ec930d564bb4aa9f9bdc313267ce0988dbc23c3118ba39bda7bda1d4296df3b2360cf3e51d63ab03626ad93e6591191917526ddf0fd14fb77ae5ba060cca250d50a9585ad3231b1f0d1c20162d84672272449d6c40a735daa1f7ea6cee10f112e8dfba5f96f740b89011b4e0cc655020b520378b28375054306b83a9402e81922af1bb28f7805bf37bf5309e15321d07596277c9e87b4ee9b305eec3722f19a0b4d50073cc6a32b9b24ec857c8cba2f4984454b57e6e39253e81ee1bb4b51190079c6f84928cb9caca500951296ac8845fe171cb1a89e64c3c4d1665f3a767818a636d8d1f4e63b25d923428f630ddb765a7dae5efaa67c8bbf86f712f405e268d0cef037c1627ed5488f39b9465e015157f4e3682dfb21f3eeb043ac3104f0110b37a2c6a1a64efda3986ba73b7fb0c2f39793693695b62abd6310dfb14476adbca276e7d6b3203e11568f9261e2cddda70b5fe42ce85f04220e17b8b9aca1a3de6bc283fd4782cf6ae4c3ecc1288dae8d02dcc6774404362803ba2e63efb0d5947e1a34bda47a977f074f0e8a649ba6acdba2935a07f32e0416895455becd6b8e817d7d65c609a664ee4b7751e1ffab85fe54290667ede4980544d5e3098bc8ef2e1868b39e24e28af5a81716e5dcd3d02b11c42e31970d787bd038239f40aa80d5c22b97467fce481dc996f70edfcdca9e1edf1b7b0c7663c84426eac19a497092c7dda4a810bba2eff78c1a0bf71ed6dd1dd553fbdb66cdfb90de747a76a35f7ec2b087bcabc3f62b780450d1f9f03016983ddcb8974cd9a7edab98a79af0523cc50f5ab778cf47ed4e395357cff5a0b0b58616cd24cd9cc2459164d3e104a6392b94260902fd7bc12e01739d6b8a58f33cbb3fa3ca69d4266d72502c7b504b0cfa169181fed542109f8dd8fe85efc9f143da257bc5df035acd2133418112af3ece865990bcf7ef82fbfb12ad6871ae34ef6aa56c499682856b7fbd9bc10318d62ebf94bf33b05689810d5b56e3343871dfacb9a4b658a3008bc1eb8d0f22d525423ab26a9641760f0e4898f3ff2e755e428fe64105543d82fd7d19ab7a740e29b70cbe8956cfc44f2e2ea3c6064006662184c86117b613a86a6eeeb33909a3359724cb36134abd667316cf107d5f690bd74e10f63b7dc21670af67190b8e7348c667f4a50be04672c8d373d81532f97ebe1faa7e1df68eaee0fdf1018a4d91f1a4ddc6031d5ef4fac15e595d4df4a5231478973e748e666a6d64df7a7a444373e5548c1c60b5d2bbe597cf8b0c62ff97366bf3bf6540902e2174966f43326ab4000e9c28ea7494bbd4434662b9df2b1b8f36bab8e34bf9da90c0b2b86aac83d6d195db59edb27cc97619b5084c869f92594d3676f0b0e63ea8e1272d438b5700ff983d3aebebcce7a8742adc5e35bfebc84ef3c8ac4d060de585f032ecc4dead72278392f823026703ccaa56fd2e18dd2048bc4722393f98bd6feed27b934b12d80e2db2e87973ce3907e7248e9b101c666944a214c888002abf59a01a8ad3271d1b51869a877667f7b752d984998ec0bb066a029d7f9a70dbfbab0a84a2a601422ac676593a870d9fed87a2091586d9b09a92e5f4aa48936ff2feaf9cef0c71315b21bb674ecc02bc43d1bab69bf00dd6ac75dfe1b936ee101a142e611730f35ec448a78b590c96e77d47adb1f67d04daed07b73bab64b7b2d4a5dfc221a2ee8915ab6c9736318d6ccbeb23158da73eb43dd0bc9c9d188ecd2cda4ed70aa2e57db054dde6f8a66d988f601e9350986af643a19bc4193b6ebc7c439b0f002c51245a704eb7a9af34fa212b773f8cb2d47934b3cb26d8d093744c61a9055e8b25424cdfb528133e38038b991f94952d1912058958fa3312e02de22f3a18fdc6a818020b453643583e4084c641d285474d58d3d96d8c380cc5b14ec085efaeb4fbbeaf3ff8cabb9161c8af7677da53b05a8ce510e1f7aa6a33397337f8934e94c7edbaba17ce9da8e35e8e892cfb5e993cff1573db0aeb198795ddd31d25d3fe51384d76f8a9f7b4136db3a1a471701a878f47478857d75d5ebc5f32995f6a655b4840a0738172fa823016b6cc856235e0275b63b080a6e3fc0e0d47ccfce737fb19078ed94ca4778d711d954f8303d077b04ea1d3730a0de7980852b5efd713c8d809cf97b9ef2b9adfc381518178d1596abe5698d29c92898d491ab85c2c40a20850b7bd6f969fb818c267f3b6019bce1c1c147385ea7db06a619daeb8f60d71e8db5e92109288acd86c45874f143e4d41558c24396ab934158064de6db3bed8dc919e8c903f428970a4beec561dae0e28cfaa1a8293e636cae17ae60698a18aed1858ded3540a5597b61c3a5a39c4cbb895656833914e1262f068dd7c2f8d0d412061a93e405c36d137f24608fb399dfeec7d652f2fee0f373440853c9636dc93b08d0d6148d402ec334fc52242f68e419e22984a3026b8c6af27d9361976c982f1e96bc54c96b42fdedd6261dd72b835075097fd20b144c28c05dcba2be68d8818ae13c41d5a2f8bb030d4dada64992ac865b93d3634dc8d4537093290d1e8976ba6aa83dfdc615dad02e8b4c7d4ab99213e2399677480fb092f8349c94c1f056c73972050c0c2691ce2eb6e342c3e96245a85cc311bbeb6568ac91ded324f6777ab533a46fa09aaf9db56ebfb75d52cf7de4fd5936cb918a6a8d015e2c85b865c2a903b4abee7134077bfc6aa4289a07a40d84319fdf2ec2ba075b5952753631364de1e6f32dca2acd7a626bc19f7595e3032f15b0c7cd391c385af431a28c5cd3a26d4954aaff966421196958e036c00be886de89f922c53fe51480488688197f818523d270fb42b29e4d4fbe86b8b20598a11b569cd07d0994a02fe5f951ae00e2ca6578b867096125f963896c8222c6a23cec0da3789b2abfc52841ec8639eeac4ede08e962afe3c36838af9559c6f331dfc810edfccaa5fd85bbdaac4d608163211483141fcbea1c45cd08ef907a68926b2427a5aee62df9ece69469709bcd881b4bd36b34a702f464e558aea7fee2593b253e347b0104b146c34a7650ad622a49bd10e758dbc8068c1ea007782c0779232e3855cf4dabead97785cb32984ae4c1eca3abbc4b8e6c5cf44fc3f81b51e5a1d85e18e623da854685f6297cbfd26873f926ac5bb29af85d7b91064324cc5e9487b54274151c7c67fc972d0f3291bd9110976660bb9aa3827a723b003e0c5953aed0495ca14805119c7879e8f386f353427e9762105c5e9aea6958a7ab4524dc6d20bdd4c1889bc336af61a7eeadb8460c7e22274ba3a736ea8d52ed0193853efd111bec171d3c61eb9d4bccb750f63b06b52b240c1ef85c4349851a00f3987795727561937fe14421d672b7b4d8b8417f0f33a5984bc97240b8fd710af51ba7b602b02692f555dcd79955f754e25098c2245f475ce1da6c52c3d740365c48cbc51948283ef315018bb132ddcfaf9271ebda39193d7d7c9c47f1362b803283063566dcfe365f713a36641c728adc08e092f4270bf3b0ff68e1b614e219d4b003163c9608ae09897dbccb87feece805608693ebc0228ebe02bba262fa99d7fd536e66ec3e975c6516e59243118f674b2bbf5a63aec5b20cc98a484e9ec5c3cd0349acb93b77b52d44ddf4772389ce88081b0409987e74d667c28afd84c060b3b81138cbf0712c23128272dbe7685d627df8e6cdcede1b835354c9290a5c0116bcf5d08e93151e34517dda29051d17e2ec0278caa9657641c785ca3e38647ef212e6361b88a9fb9a2dff2292dac572429bd3b04e470b84bb575110ccf5e74b628437f0ed94d78a334749cf4619d379cc41993e0dcfeea24a2854ec9e11f648007a994d9fd573eba25b1c46763b1a838f9ec45490b7f38cdc36db975ef5cb1badce271e877f52d5787e61070056f9e76f4393d84628ed44ebbed747dbdc1a16d0f473067cdf6416b7dacbeb9c7333d8673035638b59faced9a1d3c891b56dfd0d8ec3ede1c10774eabbcb3e3a6e695a05080bfb83a6c4958225d1e9121a9c1d3d84ffa6297a57c81423eb46b1c6fb87506afd95765f3db620dab918c7190f2a041fc7c03dd1a33fd92caf4e0aa2ee975f0484c08de0740e90d8f6a08fbc43f64203dc7c02443bc5de606a6ee9f3ec029dd9d5b8a77b93417a9ce9dd72ea4f79ca94c03ecb3171052c41750a298e68d506b8390bb35ce964cb3f822486fb29538f7198e4273d49aa8f6659b438fabc17c1c6a513803e14563d5b8107097b3aef52e585f5d3252755b041a8fdc90445ec0526263863ae57564defeef0d95c4f814960d46ca5c3cd63e7ba7f50b4be951657dcf0fd0dfa8d8d2da1fd86678a79575a243379cbe53edefa4962dabf1b192059383356f98ecd0d991d6b0bb1a636d6d7a5364fe5b90cb139f953f381e14a764e88e8637ca82","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
