<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41f6ab8b6d2a549dcdf642f788b51db7bf6b0260f886d12688c8751e82c42744363785b5bacba31e208a7016c9f276dcfe19ca0c6af06699b83c6272724663f6240963ad345841e34e31afd24fde45549f2437a1dda1c1f77766a50f34f332f94fe375b609fdcd79ee6ee9c4362987e13e93e99646953d6f420e5ab3f499e4e1b96ab89b76f8ea50abb91da8ea05636ee270a97d1b8c0f10ff286230996b7d0aac5d3e8a96ecd0c6579af39d4a1c203ff226f51d2a5115ea413b673af009cbf14334ae9a577e53b71cda3513f18efab0032ca4fd4a3dd1bc25442251a6f88bd558b0a9b4e5fd9b0ea8e63a653b50b42f4c5d1c9b604b7146b384eb576535545841d8215643c8fc4902d5626296bd9b89ebc292c555f47a41b4f5987385a9c04f189d6988d5ebf613c52f36fa825d539bc9bfdfa11420feb8f67aa17381d075cc54924a82b2441584095837617ddd39822d0cde8bc490fc5a18eefb78cc740130dd094fefcc4e51171a3454e674b8b11636b0ef765dd86d028cad0225736a02924f57c6e12447e219773be6a82de60460f317d7f499dba9ecbd9760bc44c71cafb87281f83a02342944a91a9984eea8145284806ef44ce6ef46636d8b6378882851bfdb8be71da7c92aa28393fe88942643d5386cd7184608c02e8a18e546e5bbfc2aa65c01f1d46aa2e8268662ce4102bfef7e0c8e361a0e3edbfe22c58672396770e012e54bf09556036d3c3e6fb11c08f408ba70ffb6c45adc73dfdb693d9b2f452d8a3b4079a6d46b9631d2b6334c25331cb9e1ac686b0f08b4a938f211f973f2b090fea41c05a352589a50cae4a7b60cc5b21e0bc9fe502623b47264270a95dd1896be4397b77e5dcc4adf10d6a93c82105d254b87438546b64b9037f59596c3778ed596e27389ae7409beba76401a54787b3005bd22482e89007c8baa12951cc6e95c1b821b73f3479acae58d4f65221affbb77cccd132a07540aad4d2a73ea68aa777398886f7830606758a4c27eee0a8656ee7aeb642391f2629f765fdf14c75099674bab6417b92eca16318df723a2c715667b64cf8563af84e0b1fe659eeeb695bc98a5cc615af351417e43fb9759608ec549d44e70fe697fc2b9c1cf98e5719a0ad387a1d3f0dd8f4087f4f11b4eda226dc2a7d43e047591faf1a7cf83d2edb0bd8fed5351fc41e08815599bb49fd105f6f45ae8262f72cf423ec57456a86a6d698c6d4186bc324df6a2ecdd4ff580782a7685f155226fd5562a43d638f24305dd138e992e07e6c6bbc47ac6fd017a2fe3e230c854b271beecfa4b9944be793581640bcb7c2eb858faf4da8d718720f60a535811d3c5d04669e324a5a836e28a47315eab6b28bf57e8a2f4b3f68159e0aee78c79ecfa56884cd4bbf7d3e21f27a8ff024a3409a6ec08423c27e8ce974d8d5f92bc9e1005d97a140393419f6534645874f293171220fd80da6253f43ee2b6eb582c605eadc211f2be273f19782546a25656217fd0027fc363ecfbe58ed34e28832c2e008f250ed50559240a7d402a8890be2860f0b8b3caedb4e64f849405dde68461f8a1b15781e221d0638eaac152ccf045cdb13f7a8a9f47c2dc65c74dde9d1e21ff660e3d3fa74d702d9905493d3d246cb45c67d88df993db732fdf68694571c6fa881bd8a0a46a95cc2a8d42996ccd7b5b6dc74c12a81a132e3e084c225a29f37c0be1f0a5772057827815876d34e8caf3456cbad9f5245e8399be0d6cc44db6ac56bf8911338a918fa1e29f1524cf39591d1b37bc637158e804cb422c6b657b86cfd19b88cb6a6baaf7c053cdd437909dbdc3b8e1e5c405854df2d41d07e36901d378b57bb7e92fa6c255096a1f5dd08a899a61ab8a536cb31317cb14a9958bf95280e209235440834a37b66ebaf1d610ce2fdb2c86d3a48ad126d08cb549af36bd678553e5fc621a349bf4ae7036f42e67d5101fa001a5b9c1a61d704bf3a9508b17fcf47142f767c872daec42b2fa7931bd536542d042ea61957cfef755ae43306a84a5ebf277ba51f3a35313212637475d6e32bf843e4f13f62dafa2ded0713521d7aa18aae9ae234b4be171c09f2ebbad66196726db874047896bbc4b9f3511ef743638841e36d8047c06664417b15a81cf02e05d6a732e06e8adabbd50ac0b93038f48f549128944c75317536772f4c2b75c158c947de92603b7c9759099b6b843940d6be90ec1bf66bbce2cefb524e0bb06eb375d74310a4041f135ef3a04cc56bfa740db206fb03b189206c15b4cb20c4cf9461d3aa3bf4e3fb6c12ae61b9fffe1e64affabc3c6f97593b7c714efcec72af40150c5adede01feb0f4667504037421102e63edbcfb717347b46019cd86e535a2f0cba12402c16451750f24ac782c0ee7eccb91ef4aa471a21979f3e1a078c86da698ab0b3305d2156b62243e9947620b496abcbbd8a9dd6c1aa7a5e7f30599e75cb44d42ec197d8df023bba267eeec864b266c4eff57d54f0dc4590579c906d17794379eb3a81623fe7de399e418b0d0c553c94eeb702e9d444b1a8e36d57d90f4f3f0b1159417e5cabf6c449dc0258d4a6cf893dec06d34767ff2195dd961549b15423b0b6cf88f2b8f28eb65f150decdf9de131793160e65881a382ccbe2132411ba00ddcc9a347e9ee8bc3c0abaf5774c7244c5155065211c5b6ac7c7beccd9b514c5f48c89f9bf66e01d6af39da84902160ad8aab74d282f03b464bdc63a718e4a1de66986f819cc71a004eb25d1e57e59a30445fa6de3d594b7b95a8c15ba1fa4a7d03c0163ba80f64e4dcc2589de6969401794ba4c270fa475d653cd451641d046d8b3d9e4d0229c782586f807815dbd679227eb4defc2271220f0fb3cc5ab726f41a61342008d316823b753a8669597f722ecb82b0dae285f1c7c299a85accf9be344970ad6b3830053af94bb6694f98bb277e852ba2a39570efffedc9675e3dd7d541d8ff48734137f936204bb22dd85cfa389532f4f9ecbecdb206ec0925b3fd9cfbbcf19237145fed9f2746030057ccab87c0276438af748269d37b522660fadf826f3eca97ab3510d2ec193ca4977bb3b48e07b54a2056d4a9e06a6a93cf011b7728e934ffff4b5606d4a28416982f412210fcb0130dd53d203a282c9149ba126a93b2abeb1a9d097ebba9e04b524ed28a058cfed7553472c283399ebbba610603ea8a7f2389ebf0591f27fcc63072231e17b913c00e6ed303bbb853bc6cb109d3101d45f7c1179f009c876668edf7d92cc1d24e88846ba0bb312b6d19644a65fef084c833e626a3d1201b07a7e987dec22c36bc753becbbf340eb4c46b45a8227f6470b85e74e525b6e67f05f5a0f4534ac19a6788d37d7f0fb0d7b55b0c9356eb07202076854f8681b6d87ed651a3f52fdd0c34d48dd26a4376bfe2e8f820301196eddda319e3af7b3985c300fd343b79f8ee7a7ce932d3308c7f83a2a8759cd4cdbf33e4f568f44b9d064e754028b1a5a7b2ef31f506b932ace4b0ea0972989643d6ae2db050446df0a17d20c1461b9a1e18e261acd073f4fa82fcf923fa40ca6af51f1275bf7c910587ec16a7e2ba3058b2a6138af6ec1320a64947bcfa7fcdda7f5495365dec0673833ee5ff585109b7b703f439fd4ffe68e5ac08f2ea82f7d04f91ed3c3e3323b28baaf99b84051ea9bf1b9c7f0333237c3aae1251b2fdab687a189d62a8471ae9a46de8655de676a8b57bbd2f0a8e9d70d89f54a4ea97bc2627958e230d8c72a6344b1efccde62c4b3794f43c70590521879848c1202d1c0f777ab0406617be4091a0fe7729931e42d4116857605594ae6b884cec681f3acf8bed09f183e7ca51ebc6a3c1d2d165f9566eab0b370bfc25b410eb5bfb24b433d754a43bd67538112d0e63485cb6d5e564880a10ef05884ebb78c009a70a03368f2a43355e2873d2d214829b30de76e8511b8744dcebb6ac02d3ba390c03b20605fb6620a5c08e9ad1f9c36f1ecaeeb9d256e0f1f770ebe6154a0c63f35037fe3ad228f7317d2946f6d2930c11fad77cd83f7f35fb6556d4c00719019db21847406e6d5d4d6398c52012b3a0e98058f2caf852525e04740b4981e55f910fb5ae8f4fc03ab8ccee0c0188f6125c78e2295cc2b01ec32302b79f0e1d81694862ffeb3ce8ba4ef78d90077a8bb23ce1202192a50b2f9fc8203c1d77ac7fdc25ed6b43af2373dc2490632f93cebe0ddec1ee4785fe876990f2b4193aa73544a2799d17144737c7c394b4ede6f65cd54a08d1a2d3aec57dfba020fdd1253eb96e0fcc94cf777c2f2b6802a3b578a0962bb35079555bb1b4f3cd4bb573b9296ddf370b3e3b2f9539b9fb298593a5a05d25455c375443ee42c4e66a9696d2485d1965c4ee69013a3f8a43234e5fd7ac3137e8745d690832e6c96f36cd7b54d4b5cbcd2db903a1046a2d3b0a7e0b4d8222a484271360310e613afd855ff6aff2464b75c2c5520e2d57cbe841278be24673b2e69080c89d2d5e2a5d8cdc67aefb292d32c1db7defe37bd4d758c8a6b80b98fa9b1e195cee426f70134f2cf05e045f64dd19c962231542504044dbb0427612aede1a8fed46d3e59f6fe68e3db2ecf25c7ac58c0c6b376dd4edd33879be906e078a220854aa4b4a4669dce2a8c06c5fc410423459c881528b0e812fac1a526189701f41fec92b2638186a886e688fdfb743106ca496ef4bb21bab21d780d803a701bfff14326a86cbc46b10daf48619e3d28d6f3631a6c441210703966842e61f8852c6a80e436925780ab8862f72463fb88c7abca51b70a30e92cc169a3ca6b0ff0fc0e7431a6fee50083a0c53451c2f86c1900f56242608950eec0984cff9e65d495510abef427959f1e872f046e3a070f1f58dcff473da913709bd78e09948221e90f1cba4680abde8f2d9507fb14f265fb2ecd7d9acd60d9539aa41e6cfc19ddac8172917ae2f669156a3a780030f9af432aa5a9f502f2cfa0873a87c32a0225680844006afa1b1ae6dee8a2d97666c75a1850ccd5310f49d5266ac29888dc8ce7d6bb7b4d75054bdc6422330b77cfec9e828749b8d4d65da589e74d99a0a756f0a0b4786605feb647a4d01125cd5162d254aa89de6cfb2ea5f23c4559b183461bed902c149eec83acdbf67c243eed30a3d91a2c0b3a278f63f2f1bda4ad0b02cb873feb6875eb5fc388d4b71fdd10110487077efb7cb85c24bec12452c1b9c28719d55306ecf6dafb8b029c48a2c63f9b3e086d270cc4979ee6eb2e143d62ed5dba46a6bb321bedbff69ca83f3f648dfeec5ed13f7c51a3e02be8444905c5f1e44e4342d4ee5deadad08d6f973e9db600af1f152f0e6fd2b3a3b666e97a2f12c33e089599cc2c405c7ae77e65af5292f74521f5d55fa5d689863deb4c7bc964bb31e0b9e7600448b7ee256c4834534754c5c26942b1a4dba35cfc39c94718ffeaa8fd301740da6a1bcefa4f3be2ba78d0483f57830092f5accc7e22ed64007d5a44427eed477b954938919eb6beaad7a46863ee1dbffa860b79ad6b5826d34e26713710cbd8b7ec581b20cc8c87dc26922b13853a1f353458ead8f5424cb0c3d62c0d368116999fbb20f5e5b578e34182f16d49db7343e3dff636c7b81d0e5eebd9b647273e20c6b891086b18a7310716066e52a75d1f7e78b38a7ceb12313d4e0bd2d35379678fb6749c6338d898dff3ba834d3e12c6cf55338a2b15cb78c50acef0db51598c78d4c5fc57a010b56a29d6ac5ee372dd0a35f954c141db8ac14746cb7d8f0651de1a3b58f8dc6dfc6a6c176b67b482698b6964a2309f99623f84d66b34931adff38b07a15936cdbcf715d2d7715fc804503e38d92c47f02e045b02e3bebbc9a8346e2e72e666121af84c2e575b9bc3a66c6c00f1aaced6f9b56a291887316059c57ad41e28292547c6e84e493c6aa7c280a43667a806d176a2950d977454ceab704326cb1a4e1403295add460e8be7009ce5e69aa24bcccd88a472ed3204b6835baaf09af6869ecf97e6738b7d374c387a89a29c51cb9997ab42807d5bb2898e7150f5abf46dc217a9dadff69d61fca356b8dd53bda18028e7980d1b0f85c8007ab166789ac3fc856cb45e8498e9ac48e8159894c2d5e26ef4bcadd2b5e77f285dbe16064b180c19a1d7995a44d80281ede3bafd718e7732810846eb43d32a5f7042fb8b642b6d3f01a6c24e4faa025674912d5dc018214d2850f44dbfd2b60c63157f3176552e40696687f52d431e23df63b1b0c69414fe4c74d628dea8ff70862e1f48ea5254d8b02ea43be3e07dbcdbae94010955bfd60ec8dc77ea3a0c1a0e3768a8110309b857401783245e5acf35f2ee059314b28ae08ab54e432e2a1b252af98708ae3695b8b761b2d4143c390412e7146d31a07e6a049bfdb090c83c2c039dfe93a20bed1234779fedaa5f7448808de46ed0d93106fb565518f4b9bf2cf65715f3525e2e22a48e1a5b5a6ec79bc60683fb5967d66b1bac4d13d1027bbc15388567804afecb9a2138770dad750129ee24c690b5a91fc70af962e9db96fb6c7e96610b690059786fdf03665770625604036b33b2fa1e06c45ea46b97e5e1dd214bcefd3d4827e9e5e600709f7217b7b5253be6aa1d32b91ca16f933783fa9cc68887ecf7ce7f1063dbc805affb06465bab62f2ce3272e2b97885f661635ac9c6d21978c968aca703687bf513dc8e6533a33ade88d84d96b8eadd3cfe963848c413e6da72a61a69da8ae20e39a3618eeaf0a437fb91436ccc6598ac27db92ba6613a6b2f2ffbe9dbf849b5cc8d57b5bf5578f2852ee4aa29292cbd1b5a684ca4d828deb892dae15d289665b618150de973e9a6b291ad0947fa32e9cc462df347ee580660a831ddd3be8f997d2cf188f640c1cc40f91a932d99ca2a53a46ed531fd39a225de1e4230d1a519d2b256abe2a612b69b2d856a35bdafa4e11ec74fbcf021a07f4ba55911d921c687825d64743e2e36a7059737b6f763ba0ec75a710632627035b6b6403bab634247efc838c4411514efd939e6dcf5f134b1b80ac5a1d77f1e1b55f20916609a5ce4f5502f35566129d62f23212b057f4899e6c64fb6583165f936478a5879826e25e32c4b82b19b9e511feef46052ed4dd066f5f60a33de4d04e5fe3f5dcd49f0502d7ded6222ef5767b554d893febead2724d060edd99ff7d007060d8b1d8ad8c0628d77cf23c0a1929fef642ab019775f4adf3335c577cba624a67bb3ae92c599c4bf98ef5bd5e49a14fcea54cb30a02501df3eadb1ed21e30709a1d7a04b597ce9e24bd4f684715687bc84630581bc03e9d96c0c144c297028861ac56848771aa0c44d306db6e10d2a43c246179d31dad977d41c1868e73abfec8edfc9280a7b78c5a940ee417d0b6794a1b0a32e40e47f75cb64ddf128f61e22dfd4e5aa98b07ad1e7bb5d6d722787ebf25b5ff3b9cdc704bdd2b7c995f076aab2161d644972623b46e74b5065953fede8ccd66c69cead2cc71013c890b3e438fd915ae374d44a24d870c6cef49d0c2a2c4ace293da34b6a420bfdf4a0e6fe8790aa4acd37e792e544a06c1336efc918008332277611be2ae3f6c3eccaf25052f0a7e9d8b21c11ef93b0ea331040b533afdee1e9d749e382c9e155519508b724beacf32ad42a01ed67287b6f94e1895c11377cf4c14d9494ac1fd0a3a0e82e1b65f067829e47cc33b5b9c532d1ff73c466cd5dbfaf8d582597390cd4ff1f7c4f76a2f546a84202d84d8af304c9c815f94ff7cdbbd5a967eb469bf6a685755cbdc3493a403de74ed62591ef587311220f6d3def2ab2fb916cc9f48a73fc2cfa03b9222e15ad72a54448e444e34694a66d31990cb4a37f665f936efdfad55d26582ad28eb71d79fb55a4a8078645b0bf3231a712fdbadd6043d88ca3ad2e17ac3728061590c9d0947a9caaa3b074d2c9240772c59cd438e6a7ef685c20bb38416244abe133d4b0ac2b3a6d45d92a69d408daa083a99bac7bfef51cf6007b7e979e0460f683bc07b2bd83da5691b97692422c7a6940e2080f75a660014d33dd1e52d1fa94920107d4cf83872b3c1c8d81032def1367e54dcf8cacb483c7abe44c834203d4588d2136ad8506f62df18ce09448f6f58f6b47e3d6a2012fb7ec8be4bdf16aa4101f62cd4e328119fa7dc61c03a58c914e69ff28002370e529de03404a715e9a97bcb984c201c9b707bfa40487d57fa3407eb58bc134a4fed845375e481e6116a0601032811746c8c4cfb6524fdcd7da194b9a7f545c512a780cce76cd4c5d235e59bdfd9d0098a55c47b7c0b6c6d3275c7818a6b8f41eb328ee37009f4a23702da8406edef761271c5806a347885617f7fd89bbe3799bd75274f2711b858e3fdd437d7d257038a9abfb3be79f107ea23ff0c2ec0df512e36b93509a82d9f51cf1c9b15e145f477184ebb61696378e0685155670fff8e9f8f380eeb7abcef6479a7506caaf686ae603e9003e7a2b435b1824d97099efd910c9d6f3c28b189d77e8e4a3432c68e5fa40305f55f8d8c926743ae928a35a1f039e34d14d1929fe031c0cc9f255d25a041be9057cfec8598a86205232b0eedb6fca1e9addc1c8af6274d7de8b11b7208cdffca0a8a7549391ef9aa0e7ff7c3cedd7fc7b5c4f2a95c251b76b659446d9de1f7eca177faf512edd92c550b9193e7680e5a66c712a989f299b983f16919405c638a96493120a353371e82f00a3c95edfd13475348c38d9a75e21e14eee1e4e2148be4b339d17143a447af338e93a1247e095b4cafd8a1f3904ffddf173bd93dde6a4547038be14591a3bd9611104511a6f9bf17d98535092fefe3d3d23858636e144392c7da1490572e344e70799dddb74f276acac1cb3335b12ab40314b8152a989758b761a5f0ef7dc07f645c0ce0b143dc55b3ed3538070efb4d2a5993552cd7084b2e95e923c7a9af0a250fab1e0e7b6feb19846438d0e64ce31581bbdf1cde8e90c4a801eff95526a306b9025233a84b62d90f253ba0f21e9b9fd505745f318d19453235b4179992e660846ff1bba40b0f171530ada3ca9db2f8628c7a27fabddd24f493d34d99bc6eb0b86b243ebd816b130dccd7c368bf71bd25dfe3a179d476762b200ed18661ddadeeef9e58c4638d7e17617ede55885031fd9d9ee140d6c14fb86b9110eccf4b2c810c173f66066584f215f96d36760cb8676df96f628bbfcab073b1b2ef25f37f2536c1687b2925bd95178993fa0cf4c9f6ac52a4b968a9c901606436e5ba5ba3aa2b8acd7620b8a03c34bbe5ac93278404faeff505b18de3b93c553f0a2a07b6887e8564cd572c491403a5dfe0b8691ef35c494574937aa3b224416baf5d7a5f1a35ff81173b8dc9f2c7a225520791da6ea9332679113fb352fb7bbe18333257a3ee8a1b4954f4e00e282b275fe44ebd7cec8becb66a5997b49271af94bf7778c8e395d4bfdadbead5911375d413d900b51af6dcdf1ca9a7ab3d37067ed4966d4efb197718062c09a8c0043bdeaa03f69573dfdef999597b8788e401110fe2839102975b54a40da9f207c8249591b4ac1c6e0a82dec5bd6d205a6fdc8c2c2c4fa64b5c1f51d164aa3b11c224b9089c48afa80db7e13acc14d9df620ff0ca154d218fd81d0bc3d0a046a1e85b6aaf64db39fcd2170607a3424b72a4adeccea5655685a979a6eb71645b4f1c140d59ac67d01ca172e0daee8f35050e7396e968a925840ec32c6d3418d0565f36b6f4f419d412a5acd813df68865b8623f9b500e562ea519052932503ef0ed78abafcaea61b0364f768b40cd3fd766c982b310319abdc7917be483db222f43bd72bb614f2f2c125fc325980cd9f8c5040442ecff9364c1f502e87498e5f5a4055a43b13f18693bf632f5abe871f0b5340c08456c3b6b971e62a7d8132514184f3c302637711466689efaadbc14ca4cdcbc8b0b0e6ef1c136bb2acf8d9a6392a23da5e89a08c300f6b1aa548a3537fb50647b9eacb81c35aa0f81112536a0eca8e7123568363a1aa7caa22318c94dad7e4ba1b3d4e17d20f8ec1683373acaed23582b2768fb1ca662ab8c12daf37548ea3222b556490e32c76e63e32083f45003b252f722b58204d1ae434bc9dfa5686af14ab400b855478e0ca0a305237d3855b7bb7d2067a1e40dd0ece41aafd82ee06e5bf670ae58cdb0e27cc8715ef9ac96140e376cc96c88ccdf0bdb68815162a550cb2d2f191ff9d8674d0ba9e88f8eef603d90e21eb978ad018328eba82e40d06a65ea14d0d50a1258fe602ca2ae1b1c1a2f312eac750ea80fa633ce08803c21727568511fdf0a17b6486b25ff519f9dcec405b29190f2489e19b2f3b6d714eaff4e4bce467e6311c702d1629fffde63c8629c1a171745346570b2419034fa5cff324be83647925818568a2e839e8189e81523927caf2de2eb4140eef46c82318c9cb8462ffffeff1758d4ae8dfc1e39e4930117ca84bcba8fbe13962af924a74e214f038e2c27ef56884ebb692d250c28beb729d24babef062b1a84b273f959c1ebcb0606d468f4964399966ecd46b441d604e97a875128ab7b4229806634e228dc25868d7ff8d7bcdcd2dd9200f0018afc2766becde97352b83889f54e8ba5d42d3227202e96c578043b92795a64e8683b9750e37e1a647a8fc3b5c664bc3326d9d80e84d3291d532654b3462a7ea19b93ae528fe6b2db7bc0f3888b3cefa45e04ab7f8a13e3dea8deeadef8ddca6cfe7681b9ee93be41c4f727ab52bcb6102e69a5dbac0f92bbd50e4d09d04646e0fba42c7f4c2d3f893acd9c9cf8b32afd3a13f11cf9a863f9c02abd7d63ca12cfb1000e1e4b485d8c256201a9aa6d5673033493422d42cf6f3fcb4df04264298e561a3387ff619430d71961768763bc0f18d658c726e9319e67e1debfeb63e83559e57e559aec26d977767a1be7c856e808a66b24b01a11d356e222e202d4d2576bfbba4f98e441f4e1e58b353bb66a9e04766f87a84d0c4ec7a88635f53466447ccb7dd3abc6fe4e0f5d4165419dc2cc47fe7c2860e1b1476f41b836f933b3126c2972cdc3198fd12d07353d210cb1a0ace7ffabdc03d4dfb22767025c4e21b0d3e537856ce89170b53ba54a55626d465feaf545f0b760d8e031b7ada4da92745dba51ee22922f821a25a6b45ede134c758e9117c1c51f5ff38324d0c04c2be0e41bd6e4741fad4e0f414ffe8abeeb0f0698d498c28a3244acb96b5e5beb97e42ee7be6f74cdb52bb5fecc33ea72d46bb8b5bd136275de8c6ec3813aade511709d4c9c2c46298d54c123ceb8de554a0dad7b5e34d52171478e1f55772d608b57de00180baf473182f98830c19c1b6f5cc9f01315dcb5a6ca7a64578bc1ff1d194f59d61f6d8b8f93e6bc468d47150c9faeceb3082bc8067522b3d7a5b3d4858ee42f91ecf990c8c20bb1dd8560eaf05e50fb40b6ce1409c8391ae00ce0e831c35b4239ed4224519927d4df52d145b0693a1e87e26c74b9cac0d6c105a554202ae734398c6efb04acd29f4e2f76bf0e53a12e018a6d8d7eb85e9af5d0ee6e0067399e9bfb27ff7f66d193ef52f745303af2ce7d36f9ca731ad582fddd0d5333a2e70a7847989e7b67d9401906338684d08d3d56167be029fc3782be538213a32632ab2ac7748e6887c941482655157a5b2a3be3b2b8cfa3ce036c92b8b49f81a38f468e5be824b2669a5443f921347666530d2772fe13a3ccf3a5ac55774ad36269f468fffa474b9c2034ec16d5022f2954ec42ac62ee3b6178e6ede21128a89885cad4e4ebb951131e59c72e263abfb8a00025640c3514dab301b609b866085788aba5ade22644a99b89f17f76227bfeb7fd4e7ee953123075626ea9f5a127de8cb056716d4974f0a4d8149e85ac66537b8f7a823769078509e2ad502250dfcf3fe47919d8c24c1f62b48d07cda91a294128be37d90cf91a130e72e49819c249d00cb70497eadf1c8e6233076dc176357bf26d9de10e9a8ad0c1e585f360558c318f0f21340d7ea1989b9a6eac76b1478eb26b6bbb2eda014affa12e6649f6901abcb1dad89835dab4954304dcce5a47090a56cde42e8731efd3c8c9c6952c5b12955e62548ba45936b2eb90aa1810aea5b8fb7abf78861e2867b108b310a91e929232eb04341c75ea82f6a6012284d2c74aabcd5e9e65f28c37ec98f12ccda03984a2a8f2af4a0380478fd81c7de88bbddad672c637b7d5c90c898f8f82766ad390985f39c2a551a45f6d77271d0dd75aa2c5087e5703c46f86f64de21caa027dd61a5af84cb6fba55e2c9e717a17ab817666313cd11dcef1c5e429ae30086b27d0420067249ca232e428dad0db4d4f479920d695d08d8f1f9aefdd6f2eb6cd9bfe5d995a9160bf5d73873c38afc02d77ce4824f556755e96e7e2c2d12b024f53a9511b77d28e8ca247835d4f08b9d0cf628f2d4c7a494f92aaab519feabb41518dc6a1ce9b4225f7e575b1930fe59386ce9e749edb96c97e2cf9fae1d8969233e1dc20bcd90951537493300b6eb6863f801e0e7ab0cd851caae4d8a242363c021130d710efaa90b454e22e6058cd9838678ebbaeeb9f1501d3b562962ee2101f23502d49c4735b509cf7d8aac04e60d9de267aef269f66ea856fac779bd5a929288c97a3d0122b541cab56e4888dd66d551af94a296a087b8ffdcd54adc463d426872989059e5604d969ac84dd17398791d1014fa5db8d877a4234532feb9f29a77488d1773dd9bc6b8f750c62dee42aae4ee82bfe0889972a39839af34b6044e85fd38a2b019171c3a57992830d1e40e4630400ef27f652f078f99ef1131e1b08b377477956b1e65506e1049110c4329804d37be1ba0e811fd1113ed196b7722813147a8e03681805b4530a26260a07eec8831d0cb17e30b8c1ac12ffc5b12d791f41f98fbede26c65216758a03f69f507867f120b27e03f712aa2346c12bb6d8c02acde9435a4f77218cd1409c2d7baf23469cfbd2c997c8bc166c71d1de4b8b4e2d02b46ca3fca02b61bf4480e37c59c5c9c776ac016915e5b22a7653053c734dea09450ec6689fd9d6607f2d5640903615ffecc82665aa9edb9c257e9b17c5b1bf024f97a3d00b37dbc8eab3bbbc85cb43cc06d3b044d18e7657b5331061ecdf777bd27aa9ea6019eb2db0f76a447026d21e7e46df6eca1355ad4fc6a0a51af0c15df795ed0cbfb0f6eb6a8eecab73a2e1568ac2bc4e61056bfec5fd8062006469ae4aa6ff2d29765d330e3935b923f18481a9eb995f76895de2836a9b92881837e78d022d4c49d66cd1a4d925fdd97b54b4a3d6ef519a8c962bd6128a118bf64dfc323325a818c453504a695589fcbf148fda776c15661d575ca3359d11ac3ba42c8a40f1d48633f432c565cee7113f553053b6d1eb97b5f9e87b0de01db867cfbbbda836bb65db9883200397cbbd879f4a0f71fee5dc4ae08a261a363905d1fa64a24fb3b2dc5b9021315702f0c7fdadac4cb36e5ae192d49043e2018f7d4f6561b9c7663c9deb460f08a5793fd0a78516985adfd065ab0614b1094c7db01196e947e40f47f279136f23d84a0a81f952ec90f0fe90d5a107a34bc09fbb1e9ab2aab396c5deb47eb16ed5321cfff149b2241cb1cd2691ab8c9f71a8090afa14d9712e9a46173f6e1c57a22fa019ff3a89fd0e8c5a24a83fd5294c2bded1cbc8dccde84aa0c56684ba6fa85a36f9f1f7ebd826c3dd657a276eae67bac37eaaf94408e1a956f1bfd2d593ad1d1cd809fe4d6de6b5a53fb8f77940336ac4c15e68249ddcdf4ce7b7275dbf61af359e3cf2cb8b2e2d2a333ee5fb1863b966d8897c41e206a36c7eea2b20f47defcc8f174d45faa4ad7cea83af8d63439651ab0dab8169cc53fe23399eddc1ff46a382fbfc23f9c3e96bd05bef7618e1ec9b729e3884c86a3ec5cc2309bdd68ef7e8d5490f0d2331e93e77029bb8d54e5c203224b4afb603bbac93c1536d1aab15d6b5bdd1ca59b22110fe9045e6a4dcd3e95c27d7ee266ff91cac3c6f620007ce975a60427d6509d91c6cff6c39fdbfd80fe541f92bbdfe8d685548b2f86663ac84d35c6cd804204a16fc6d5cffd312a96dfa8458a9d47f568c26901f1fd6be69c53387c930bca85fb6975252445484fa2fd57787c95a0d4c6d0b87a27872995b5475ad7dd17eafb34fcf065ea4fb58c2c6860c2f25a4714b6c1b896153cc58a3392ad44c4fe88fc15e2b33881eb798615eb8091dcaec43668aaa5fb424d1bc66e540dffb0713f89ca15eb0aca466ad7d59ba7ecb162a0c6c0deafe6c582f16a51076cda13d13801ad6f710f89703c198bd1f677b16ed0f93726d085bf4102d7574e0c282ad5921e4e50758ea1233562290c5f43665be7ed966be77625403179277ca2997a64c66b1606459d4cc8db85e0337d691d6fc292aca189ef3614137133a6039fbc7bf35250f39005fa9f844c05a535777c48ce3b85f3de5ad3d0912b58323bf5506fe8b73a586e889897c04c50c443589f4092b6dc989eb3014175cc16539fcb68e59cb141ab60bec6e506a0bf74207f0d54e8e285857627366d701e664598b3d09c68b44c455e5445d771fe6f9a7bef3188e6bebcadb539a17c48517f9c19a0d77df0200011aaaa6caac5fdc8acfb615aa5880ddce948f35028878d81828e0462b60a1ef207919880ad0444a5ccae04e08ed69e8e266bc9fdda38a491c325e5a16ae577189d55dd07ea5fd7e7b6b02d1456027720ea05fea5b1c66d8639c6c2f988fb9b8950a6b68d0fffdef9a17a117cea30772cce79eb3f2c425e46cd0441ecf43f018e4fc12701d012383785813e4778e31e3b3e30b0eb713af921210def80e46f22777274d70e31feb076728bad99a24516e1dcdf703ed14fa2f20cdfc80e3bd0a30b4f0b349975fcbdcca1a95fc5dfab8f77004fede53e04a0e5541e2a4ea0126ea39eb97e196e84eba9f209c799fa0a5c139948cf53d24eb0f893e5e31a3e345cad3476fdb70377c7725e2fdc1546dc90829386c504fd8cf0ddee8282770e3795119b84985b9c72dced73e03e16bd4d7aa25c908060cf11ec3b3fdade3f94581b4527cce4b803a3f76471cb1b8574e5c08e962c058ce168ac933466fc4f5c90f385011734b3a7b5c1ee101e17e3bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
