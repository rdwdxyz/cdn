<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a3cd3ff7b891a3656a11200e566edd0886932ae05fc9583bd5b068e901405973ae2d7e8a5f835c85d86c86d7c522b5d9c29d6b3086bfe26b9778238ca0696523a50a900af32163c0d07319094a8319f999c7bc1f17c64a091e9b81cb1f320e17142d482a7c43648c84b4eaac47e4013c43db1ab208bd5490ef263eebad8e9c8561cf98ecb6d66b5c6226cb4b6ff649b35753e56c683d4ff679f1817b64db98ea076b398b5c4ce2802f817489e8c81e4f0fa35aefb54f660acf8a1437387d178b5ddae88e5dd8926f1a5908de2bfa128d2f0d1575232f7fad62d0e45a8880c5a902d3bd4ebad665222a8c69baa8542506b13404be67894f3ea6fb558e029b6b92b0119f019186e77141d3e4ceaf269e721e0ade14462f863baac1e003a919ffc6fd10bab53ed13055faa664ec8308a6299ce0a2910a031fab5641da6fdfcd03f9bfa5e8ad0dfa744bf4443debe55fdb658dc13371b0d3c95b6bc56557fc8c336d9d8131e1522df1ac4793400a667bd6040fdf1e61be667f6a2bae825c07d4a5db5f549d39092bcd74661e012330cc1c7100556430d7170173e9e66445584690ef1ccc16b5d3ce49f77345e8e26c9deaff595fd86e0f580aef9750c00b4fa2582550024a47fa615b15267ac873569689ed4e9d75c092872e1a665f04466ddb948ebbc5f3cef2a896e0ddbe05b1737d44b3bf51db337844f547b488081979efcbc4078528af6f11ae195760c4c17e210548b2fc5c2a4d07216cb65e6a7c666bc518f6d95bfbe7772ec83ab3e47448d82a777419f928685e37a4328f31194100c5b1bb5ebe22915171e51d8e21d5d6584aed9473cb4a2895f09e8bdeb90356d1d0b2da4d438c4c784b2b1896fb4e9388b2571ff03843d66d0cc059c7f2b8437da876550c6182ec688fb0603fdac138778000a2495eadbbadc4f4dcabff0e7def67c2e0e8069e221c673e4264b22075ab4a9c7f1eef6af5d617e627fd20f6721bece11d79a5cc2e5ecff6711ede5ed696517cfc5bbb14c5d997f96b626fd7cf7b3905572e08e2eb7d0fb5f7e727d03e7d3c0ab2acf6f6ce568c92a3b6e906681f0c5069699e9112f4fee09bbdb7d11e7fa512f01176a37878d42fca81f3779215a4019bb1d12b5de7de962b96d9f9ce011e9cd77f65f0370cf28d50acd0120d14dae14fbc783a92e091b17dd590447b3dfae72bac12ad923703674615b90735aaab0e0d85f881e08539af747e01f84e6d2160789b80f4e13ba7c8a0f644082e8304fb7079e5463051ac0351bca8f4ae8db7825b3d40077ddc8bfa190e437fc55ea377cce4c890b2bfaed472e73e74cf95741fd73ce62c95962039fdae228931e78186cff3839e07cf4aeab1d6f8006ee8093a75cab83d40df4e90677c04f7977f94c7a91180c09c08175c7a8111487856dcbcce94ba7d3756c0d1b3d440e2ea88beb7093e71549e4877b8085bb2a9efdc1ea974e8f11975df39079f5d654ece385717e1fc89f0189a2952b1076b782861007ce62ee9aa20a59bd7f95c10a97a85788609efc6ee865db249f489a1f907524bc27f38dc7e9182d0a9070a553e011e76704793142957dccec0e6da8a2f75f96170640e4d8b7f6891203eccb0385a1a072ec6c6970282e76b3de6e858c02eb5d477444b239853c2cb4c901e1f63764d44e6ec6b6268076aca9afa0126294febffb11513bbe18333f06ed7f2520870b875370739cf40fe792f06d7666b8134156826ae125563f87ae0b0d7d4b75a370a2acc5cf21225cfdf02bb522ed05fe427533302464a19607975308c5324e4ad24626bd7db7bbf9638840915974bec3078630de38b74e657bf748bb1a569c1dd1a88157796150a4fd008a1b8f78a0ff289afc76d53625d2945df4752c7da57c98c294d3aca351317b7a952629d19a21d35a80086d2957e8215f32b233017301073933b57a84d5b8ce0b9a271c88150cad377efc091fc8ee92a5d3630ce9cd9e556662397252a5fc24af7dfa150ba06984a51dd9be0f6c62b26ea84a46d7723fbfab89324c250d00dfb7b02d375bd035166de73614e77428affd1ecb8aa112d6e38d5b3e7196a8aa816500d7d698c6bb143264fd7af0269fc8a1d079967f4f31aa43e4384e4e862850bc53b25d97d4e2e0d543fe543e49815f23b80c465af3e4434daa4e4844c60afebf9c06ff0704d1fa62812e6f371a117704c047ab9fc79a5c053bed1ecaf869f9d26584d27aec3b417701ac72040e44061fad656f157b2f7bfd5b78f617f99efd96efb4751fe227edb559209956109fe0d37ded39343651bdcf1928961aae60838175694bf33249913f5a86cb14b3c6335e6cbdd73a74654cce17acb3ef5352749f6b7cc68533d18501c29b72d560a7311249a71bc8d3c908d2941ac5ac9f57ceefa6bd0cade4b21542634aecec38f1de3889461176d83c718f8f2629e5e9fc8463a3d2778cf4b8927e990e9b0a4a6fb2a310047ff2ec21a29b2a417e3c97c1b727b98b2afebf6485c3f7f8bac229290ae13e55c84f3008cc1efcef3a444e6ffcf71e7147f9688a6990bd6e39d5c24efac4f8cf78df0c8a1de13c1e56977ec65ab10b8e43b341ea493b4a580afa3aed59d817e88391ba2cf1f61a98701e648c475191cb5570f4d8303e71b6c48c72da71dc87b32680a3b4295a9566a4e69c8e801a14098952ba87542707bf79644f14a5a9fdd4da8f449a7eaa20cd562490de879c06bf79a1337f919553798a245ae0b8ff8037c1655025ca6d03e7e97605c586dc356d6d7d701522e2954ed350603b314d741ce9b598157a137f679bc9d7f7de8235d3fb8a551611dcdb59350ba1a30f62635735ecf701808ca0d70c2cc50dffdc540add8187b99f0426a5dca8000c1feabd40e71cc32c868f7786bd1e4fc7e2005f653e32e178f433ec878956b1ef3b2cc5007a6af16960af31cb3c3920943c2876a18b9458e54699e294d8faef41cdf7019a2eb5a56dbd3535ee20fe64c3140f709fecbe9c8c6ef7b2e578344456a3a4cfb68b75eb02bd6a7aa571524c4c7a8147405668e99219f79280d292bca93817337bc2ec2d7c7eb696d9052e489aa7de86244a3bb899e95fb5a7d3bc2280ac71fdff7bb136afbde6e03f78f2106eaeff2ce3a5a6de1b7f2bad6985be54165bc4c4a5585c815b3b60cbb9efb6187b7c405c89dec06d2728048721838d674ac3c1065da58836f09acbfe844a60cd0d5cdeaf4d76baa39993f171ac285531090a5d65f3b06eba5ca2ab2aafdb2d9daed001f93ba52d324c9282c41d84793a6d8d79cb675a896078f146ae4ed3939bd4fa02c8ab7044eb41f2211966362d09c9ee3454f31170f7d5bd5c6d44cc0239dddbd14c417ea14eee30000edda4023bc2891ada72110bfef45814bcdd7fe378e9b97cfb09a337daaed26d9b1250792ea2005367b738f5a388b5ca71048304a3afc2980758b4caa8dc311f8e01aa8190b4417f336ffc5cc5518cab684b8fe5f1c6f731d84349e8290c6682b15576d34b13c2d954650c056326f3d73e58148b07915ed0b4b6e9d04a42bee48b059b5bcaf19602b9d489ed2470dfc55e868001af4d3387b82adbc2e3959c1b90175a0ce3507f77b367c250313b1ea62b5704ecdf54a83cacb1283c625964260ed2dcd7443854a4a8dfb32d49ead21cfdf1d678db67792ec34ce1c784281b4ca0862a7bb24752f17086e509220e54b0e7e36fbf715958213bffff6bfa8287b3364b98d6e3443ae91d68a800f193923ef9169b3e43a0add8533c1d42323c7cba9afa693fb439a22c1e7122b2d2fa826b2749d81984e4d7a041c4a3743d08bf4d5e30e4f5f9ef5ed66525bc961e6162988e9dfb6801437c25f982b3be8a98f0234acfa39160616f6297860a4faf44eddefaa3b33cf3875a33c9813ac4dc7a1643bdc82a353251fc987767dcdac8fcd02b26f27830f10d02daa6d49fb9756413a223f86b52ddc58bcb2268db2f3fbfc7079963046f2eaa25f6ca5acf25fea746231984473dd6158bff6d3a9d36342025533e6dbd72374a608184333c98c67e9a997dd295f85cf917bb66175beacee346dd4433e71d2ee55206f79a1e2b70f8f13fdc47e84fe078212023981cafa5d25ff52bfc7e89c9c91c01e155cebe500f3fd8e1b6eacf555ba29580b4345f5057951778f9a95444370d3f2190805737fd3616ee71618c9df92d4420be1e19df4da816f6c7e3beb59dda23a0a1ef70d708c7de30b4b1cb77b15ec48ced31bf27ad285481ff0caf213c3fba1364cc3eafbea9ee168bfc592baed55cfd4fcbbe7b7bece7802731a1a1286bb4c3eb439b99ebab90a1c9652e7bae5352341b169d0c6ed0d54f98dd14a0d19e6606cea694362d54dd6753cc840f3b89637b61871f3f5fcfaaf1ef3f5a6dd06fc23d6d10c739f7b1cdf5e3d2483ba15f17e0ee2f84611795e9978a983025fb74ff1b8384ebeecec5c9b0038aab97de735d393c26aa5ffb3e300f2bcf86fc9f07ad8010c9e670b4c2c39858dd5b20ad8a5f81a14740f8d959cdfb9250412bcb643d9e434ff18dba4933fd4066f9814f164eb56d58fad5916a057510231cf5973263f7af4de1d1a288eefd0fe5f68c4e13a80d30b6650b0a2711d6c7003faf50f3aee293496ba7eae4f97fe42550991d5dff47ac655227b45e8f38db549ef1c5f4981b45d72e906ce48de3c8a0c7c705f4bb9cf86dd8c7b9fbf23dc49e7b7287416cb18a81047a877635f35c3f9fa3040bb2ec3fe6e937902c365a772ba4870f8b79014fa2db2b5d782f023a674dd1e80f9977246e31f7e4b678071efe91bece7d08f7663ea44828e16c05610079f15cca78818883bf7b8e9549f2ce6503c1a428efb2626ddde2b6e0afbb2a76f78ae5829d88875d996688cfc618dbb9ebf118b74ea0d99412a15498df64142350700503c1f4024c4ab98fc892f75b4ccd89e9f52567887ffc5700bc2010b97b1ba8f1e3d16f49fa24dee084721af9d2f4f231656bf619862137af3c1486d69e0169218e29946792e16edecce11f8f21ac9448e0aac531957172fd42068873dfdb44fc14ff1c29e431e9c283d5a11ec0d1dae800e635a7a325540fd7efbbcb8224098340d248b9d8fc2b91a62e8285e0a22ad6d6fb6c9534edc3824283f1420a22c2ef0a471a7e3c33e9455ebfc65172f4145442219fd7ff62944446ed546cee7a2ed31a3858a6ad57dafddf59cec197b0130c79e08f2b4377a62526c83125643ee7c4adedc8a89c3c478c6f480d54ffd6d310d3b252175d052646cd25712105c7805c60056b4b5cdd69a26fee75c2c7001cf03f320a70231f6a2c97eb7ebf4ed01269aa56b19ab8253789b528977836655b98be9b1a43fc532eb1b712fa0192847e082135356225d0fadcdbb18294df25041233b3d7e8b1c3cf69f5a2d36deed1a3ff9d2057a976fbb948b76927f97bf0b64f0312b7e546fe341a5a2f6e604b7e669cee1fe86bcf8558d276a69939266b111c0ecdb05dfe6a5a4ea958177382e435f528f8287d7c332263b2c2e72d8ff03a5c2365fd4610bb1dbc839de055857039c8b62c2ae2686ed18829bf8311cb4595c9cf22aeeb1c0bf1098fc3463d82e97eae0712eb6f07d655f4993144d1fdff64a8bf4baf75c4e63b8716d50b8a512970c03091d68e7bbd3fd518a9bf95dd66c7f9dbd774c867583fe38bc902dd7e0fb010ea1b65173f924b125ea7638cb3a28940855ae4bc8c3aaba2c53c478ec937a1e0b1752056ba71eef57f9baa9becf4c7f1519ecefef33f0621e4c400d2d00ffbbe92af19c153d76e2648cbc75c52b7134a90edc7a4536e9a583940e5b18e282a32aafd035f41c4ce86f3071cd1500bb9b7adce293d38a663c8570588d5cbc95a11f8fdc8f3b1b6fa2e6d0c3f7b5b9e5ff4e7531205d095353483a1de10f0669514f4569227134fb5f81a20beccb05c0337afb23839ea9bf49706a98630b8fb8d459b5d1329fc8fddc478d7e2cfe464bfbf050d1f4fedfa75fb056405605850d1cfbe3f53bd38a49e4c67fad0de7936f1d185285ad01660022b3ee04ef2ecbc10aec4a711f91e1c6bdcd7eaca4062e826d5d29c7c294487d616c19cd0553d1c7d9462c4ea7c8e45d286b767d467a7478375db7886305f963c5041220b4e4d6ad125f1784cfa911f31ed4e0eab69e029ec68cd96e7f817d786ec6ead6a43607390f9bcce3a2ffe6900efa770ec276419e57e366003b9c3d7de3718b8c158dc0eb16761eb17fd6cbdcc462dab6814115f4bfa70685a8e6584e12fe91cf0789182d7257b16fbfbe025106f9b5a2803e0d0751bf2ef39bb2f5f4850d50dbee8248aeafb9c5fd5e6816ff8ce81905ae81d51da6058055f0d83061d2dfd9d02c37250b81d02b4ddaf757fb1f1f3dba7ec9e463fe71aaa6453478bd03b0765d96d864045f3ddce0dfbe9d42349026ea9cefb1922df8deed7111fe221da6173b300e953da0b26593349deeb5805043c4003b6b50afb8dd1dd3348ce1b8c9899747c8473fd4f3fc9ce432eb5dbebed5be7f3f269c2c371a65978f4abf197b87afa3fe8bdce9f9f5851c98aee6d448d786c47a0167debd3ba6cb4b73ccad1b5f328c48ea744e8dc1f70b5b5dab09de6a5ef94d4996cbd634c137e2bc04cf477dff089dddbce3f779ab3f8cd68b65e82cedecc9e63424e774bf7334131ca74a1809c7e93404b1942b1133e6dc6475bbb02a2d867c14c6da8c212fb0fcc51a8fb8708efd80638ed85148ce282480a717411c52cf0e318ac73dd83098badd3656d496076c6ae6bd4a57ed7fad19896e2c2d475db752fe4c0fd989dc294bf50b982ea22e616279c4bf4fae91d0220420a678daf88ad1a9bc0cc08092da759196f7980b400396f9da4c43dfd292f60193da439aa2a8a6a2485c53d0bb12a9b130c3aa8edeba77dd587798ae0bf173bb4ffaaf1366576fee46ba50185b3718fbf0bac8307a4e6743626953d3bc116f49b13d75dc56a58b2d12b499c469de332ac5502ce49c26b47c01ba6f57634ad52049c51cfe05d22c55e4e876e19629d17b568cc6aebec0b3b1e53a0528a5b53ca1b71a1cb7c6e4a6d98092f0d29b587cbd2774aaeacfc8997c0825447dba264886e10e99f6ac64dbed73500e9aa0c43580bdb12b6b465b6b94e00076208271f1c5c9c8ec58c5daffebca909ae2e43985311553e9ac409a4008879acb3e6f58329888c828a145b68f9c312ec4809eb9b4216c0be818cb540a2f654fc3505e2e4b4d67d7a80a6f7a9379e9e9f33100be169379f7ffcd0014e43746e66a22737b83d94adace89fcef1a244016942f5ab8f6536683f32524c3bd824e8739d9bc772e7d97a59573d128e9fc036d5e5ac8994cd7c2920fde5c7511f7e1726ffdf49488bb7ab42c9774a189885a55825cd2bf9d20ad0c1372b147ba071194ae7220497e2358f75dd301cb51740cec7e90172fb963b8a6d00ac533f032bd4e0596eb0c32af16c1cb95dea20b57d8b20cf4432ba55ecaef29b731d7ec0b103914573760cd7fa79b3973daf62da017f2b0e8c1759d6deced905b9a62bf89f3b976d21d10510b3a4ec852eadbddbcb046f107addc997ef7d4aa7cb74b84ba9445e0ccefac86b2c8a352c13a9de4ddbc27c4ee33ebdc67d7dbb0a788d31723503e7143d8b4ba1db5ac1cd24e38e396f06a52ff39de02618b57ae0999811e91c99064fed6a294a2f1b6d49eafbfaf9cf082dda401e7300d6d5a155a81bd42f34e6705e815a7d4697eee8b9b0e35ec61fe4b5afe5d3ffd7a3ab388e4a0836aa2ce29ca2baeae55fc7cf474f74fee2cad2e5540a48befa8a20404a8b821fa307add59b7fe24dd36dc3f2cd600d94384f223bcb3d9dd227d05a4490d2429f8b929becf9e96814b06f352d316843afb78d94f9e047a3a28a44d6535881d62639976bc269f7fb1a7ac92596cb920210b4310c5508019958e8825c3f3474a6e4dfd0e8964fb600ae19b2218debd8d7eb63f47e77a3979e8235459e6eaf6b3ca98071f7993f3dbdc086a3802ac3a47b7328a11af6a1f6159c469790765cfb0b2be4d2dc50d3db819740303c395b3c6d905a2e488402a0cad4b51969ca9e6c04ac49506accdbdcdd78e86b8a83faf113c57bd5aaee95c652f7219b2b38a6e4fa1b7ccd36c408a34cd0fbd4cbb227f7f2de5cb3da5340dc08418bc1d6d6816d03fb1e25ff22d00b0f4952ff1bb72a2fa2728cb99bae6a2d93646a9c188efd9f1812871a7eb42df4d1ffa711254b3d37f83e879e239faea5d0f23f5ad357a5b9695e292f6d1800d2d8f43d6078cd476b3e7bc30e321ff5219f29d456477be5e94ad2f7b11436d9cdfffca9e4be1f5f8c0fe50825051c2e279467cc4301938d5d727609d30f6ba921327ad75a43436c8bacf3c532aab48c5cff7dca4bce59ab0dc1d603259db5b5478a3bce9eb0aa2b7db01883f9cc47f23a67893c7a6f152dbc2f237a7d159be395fa643acb957b492d33f693b56e5084cabdedcd8eb34acb8cc98deff183767c2c3c722b1d40b504b74fe52c9161b6f5671f814cf110d1e85a0404158546b86539986233bb543e5a0ccfaf48b54ee5e9cf28e09500e087ee9879f7f171d3e758e87445e5bfb337ac6965cee141cd4248dba0ba375233b9b085aeba250a2b11afeed4b949f98e52669b1df7632af177780198c8d4452d41e878a1202ebc7d4759c466bf089edb759423645d0e0383e4e836b46f5f6a4dc06fea7146b11cf7b398f8688eefbfa7f443bc13e443a37fb8bfb6e7b73a924e408a75e1f386d28cd1114c72045c0239a22034caed491a7577cd890ba8266bc2a4f454a04d3375b3d8b126318608b05cfeed2505c467f4c91b39c73937cfc30a9a525c38301e6ad6251553893970de06e49a1134c972c1e836bfe52d3ba996c541bea391103f63422612bccc0ef8a611ec9f4bbd97646dbe770afa167d6069048290fe395f4b63b7222f9606a1e9dab671ecb031c7a148b56ebd2d1e9d9c1440609815379bc6b397912c0974bee396e409c5ba16daa0ae1282c12ac8d660e284f8f28c1303bc88f75081a35984004cb30700a8fde606ee9c31e3fc48372db1b70ae1ff92c146826c3c783ca0f39db78fbb7fcf96bcd9e7f6bb52d9aa7dccb24775a0612b429e10066888638022964f4cdf058aaad80da47c30aa32ced2d02f37f227c9f9f8b716675f7ad68f6037332c3173d11dd52fc3d9dd43e442ee5db866df5ac0219e73bc040b271f89a79d2a73e5300fd3c3791069e91bdeba5110b471d4ca2b844988b9d5e277b705236aff5ec5a187e8d3a1261200d5336a184bef470ab987d8da19bc7c350379ba74d1487b26b1aaf45d9f2176f9181e73bc981ccc953dad9a6d73298b8d93c0278aedd00b9adddb67c0fd0ed308c07178928efa898dff84f0d41c660d979d1efbb2a3610c47a4039bcb5ca977a6122611cc2efaf6a12d0e62c1ced3e4a6900416f1ea9ad7ba0bc8d55e355675312e9ae0ff1e00fa27540188ad8b93e7c313cf8f8912a9fe543478c5ff5d370f2c9e3a438be49a8655430cdd364fe679c0b827d2cb4407d44109867a7ae601ca7ef43376537485f21ca088dc57a339890bc83639e4bae2b5b1e690b704381dd053e26690e24d8b781f808d2bf88de6d503f4bbd50073b9b649d19c90f312083eb1fcf85f4ab9ec8e58b1ecb30cf0a8152406a0c7b5f10e3e2ca73c1ebd405dfd07db0df5432ab54dffd7d292cd97b2954f981b0ba930d55300070aaa90029d1bb976de66465344f896ad660aa199d68e216de3f85f450778bd8c79acc4350e2eeb21484bc23c35c8840eb0495348ac97fea05d9456134caabeabb58bd320cab841558a2108e484d0be175f99a7de6fbc8bb2570d2b8c40bdb439f77b7cb8e20a6113abff79721d71c545a75183cf3c5910ceca968f5f0e536f9836a863baab2608dff29ce206e74b95ac93051a6caf175ef3de400c303c3b743896920f409c8d253c5f8e001b1b4da4131e022850fd456bcf8c723f978f71e9e13aa2cd28dda60a1dd4381f4a0d8fafb222433ba5ea53e68353552b735f6e4e1dee9a36d0ee6cfc9c2dc29d1184cf0754ab813075ecb751a261f971b8f3bf4a6a4acee0cc8e8156f54c5f33940165809f33b248244a2cc7798c506a900dd2ba224a61177aa7c32c3c56268a1b59ccdf1505f2a5e93d1b20dad4f7e458a11c8d1c24c8b113a7361ebdffc242e4c37cfd137f8534eb00d12fb7ecf283318b8d631c31c7e71fb7bfe398870232ac6e5cf8cdf25f5981e9fba6ba1cd8563cf890a2061c6150c9cf21ed35d9d493faa15c45ef66a0d3d31ccb2d7121ddc0856d51e95125645c9a144d95e422c5131d8b23fbda51a615029b70aab013dd377ca8d29222615d5dc80d24d2dd41aef57351582f17d54d22bd4a8032e38ee6231a73ec2497cbb0d7d09d50eb71bc6047047e82a60a590a3ef0551db43d20cdf36e82d45097c2f53d237e200cfa7e9860edfd95df8b2c6dd5329dce32b0e98270325144d59d3c411d020706673288835c41c344f4205197f7366d6716cb3c9ce75ddef6fcd112423854e05cbc8b52de00bd98c90fb03fe878154ab81e978d63b861499d30fa90586e60b1ea16cb21f7e37c0f8b09af2aec94eae5141613f0504ce45dd31750c35ec26083513e4eff013474669b1ce3b34bcbbcfdd50c6c8f2575c3c195b5affa18f3187bcbb35a8d097a6e1b303739098dfb72802ea06c0e72ff7ec6f9eb74fbcf0325ef4fa12d3c05532390136271f7df929df793153ae13f48a1830b05049b4012ebd90279bd0d74c8a30cf620d15acb57c05cbc6be1db103fc718614f1760974f8632ddc69bf81861880968b4039d0eccf04944033a589fe2e6c944aa30f5a049d890b724d0e5a73e8d2e3fa0b4172b802872b9e1194e754ec4b4f1638654e277803fb63c9a47ed3997a3d1c625323e43f428c92fa0a7ed1dc28b1ccc9d20576640e8424a7c48e93089d2acf7ba824226ab6ab26934859c158625b5b5221790f3df2b0f98f373de9f1d8d1c9f713a422d5fd93842173671470617265165573f4b5b171397aa5ae29c971e02087e72554284d005bd2775816fd0cbe0e209112c34b6f11125308db64e37b52d19104616346d3a0a1fd797464d436fc80dda725b44aeddb2da251175d2980df0c4766eb6954658272bb74de2c1a78f7a41a468b7521b4e9b8a2cb196b1b02fb9293e3da1c8b7a557c1aa611ef874b3580b521740056eecec9835d9311b29c782851c6046ec2254801819037b0554d4771cb9dba880577af4396537ad043e0611b06473ed642af4ffafd14741e4dc4c960c3682fa278b75b07b09d2f4af4c59a6cd82ac1b0eaaad5a1175980ca2f907c9f89b6b696980c5ce14a175d9db47985da85160fc68eec31f34ea9e0f1ecb840891de6f1bee9260878b057ef2b78c2d5cf067efb99e72c553e875cf1a91718bca313077ee93a9872c9540851d71b696fc7816561cb640096bdfe05409933ff417380fb16f171a36a06e93b92f799232155e36e8da70c94a4dfff3bd85798b371c22d45b8fa847cfbc43e36be0201b02e0d10eb3bf406296eacaabeb059818deba942032e46f6c0122c4552973a68bae86d5d3b4ba843b34a976fa8f6a78b536984fe99cdd7996d85a007a8a7b06ad3ec9c398734d64e2c5a16fc1512fef746d71884b5e2eb5cf4e68d296a4df511134b04c0cd1cf7300c0a40b30b6281b9e3a3d20a82386f5aeb8d4348d2c1b34cc2a569db04329610c50f6dacc781aeeca44d4bf2b790d0b5897fc47751a3eb8c47b4d47b6d15786549feb1d5c8e5c3a1c758f19e0158ec8e65703e1e8fc46238b7fe6ebf9d3bf18209a2360b3a717b592851080583de785d336e46c5ded540b1f4d210fce2c90a05f9455db1bdc69fdd17258a6fe335e9331f76f944f893bc18d81fd564e66def450d79bdf48d9434b00fa26487ef9e3084ea67aa7f488137af837ed0e2ffbe0a34fb2480d143130677e95c3a18adeaeb85ff91423b4c8e2cb72da12dbfcad60742b86c309a2a42f57f0d3bdec989f1458bd5df0d59a61ba270e656272a53613fae3fb1dacf7be64d94407ce2cca3e076081084932f300fe5a0fcce02100965c8078067a52e305b8b0424bb3d00bc860548861e9c85db9f624ced914add00d977ebefef0f47421361e87aea9c1688ddb2bf7feafd66d2a029358639aa141953445c27d690c77c0324e37ed5667a92195f51a23ad790ea9a8b9567589e0604431a49c665b2d3e33f521c9830e73cf89ccb1e1c1c7476a6e0e0126b30f226379eb9a446b45d7f1158c7972c8b507219fd14ccff3153cde4c3cbf9182f3c5d56ebd261c1c4edd9abedfb52d628615eeb03fd183984a44d03e8366bb305c0fe40f4136dc0376a76e782be4d3f36611ed8f3432a1d3cd4baac2ab3c2219c6f32729043ffbd5cc8fb2253c72bd2f0c9e27d3c3df3505540b8a25faf4293608d3ef587f2db4253dbd41bfc3f6af99d5cd3bb6abfde366a42fa2daa937698b01805229e04aa28fbc7deb9cbfd76bb7b6090b191ec01a0405f97f76a67827e8efebe78306bb2baf4addd3abffe3f9515f099b6bb3059a7d757b9fa52d8b5fac2b22debbb9c91c9ac30fed9e3799be67b116d3fc5efec4f329e4459646c1b4cdb955ddaae5b7b51403dfdcf267547129e19aa33c7a107c3ccfb1630cb1da5f58e9dba3be1c71b6ab2cced046bdb71a87424a251b1f00e3bc6acce8926b3ffeb4b5b232c6ee50d9eda2393a3181033cdc0c6028177c7069a98cc0a1da540396b57d7695ebaa248f006c5daf265a751d824fa75f0af429bbc927e90a55ce91fa7d2b352f37d456da694fc095a159c40ed565f6fc3b3e1404f281f5cf19a8e1d15dca6d01e5c5e6f31a2d6d4afe70132383b8176f68e3be4f8594510ee1d2f1d589a3e2d23dd66a5cde18c06fb177a57f18f2e53c4a3a8ff36bf4111edbb5b91ba3b7b4f66a2f591e03873dbce832ec2c7bac938f97dff157c4c2574ac7ac5c2cc7ce71606aef5b5ba12b88652cf34abeeb90ee2757cb4c149d4cd6992a57a858c3be26954135b1b2e3f5fbb073033b61575a9baba51301163207d1ebdf8e3cbc18a2f7587bafc68b9f212b31657a3803e2deaa1a7eb06e3f42d0a89427313d2f81141e63416eb4bccc8a797aa17e1d59d73e00827e1873bdccf045ca40149b1f87551bc584f5be93d22775198851e4d8ee54884d3f3d2dbeedecb930d73dfac9f765143e24a1a71360debba31030622ba2cb07de0571b621f0da651e804fdd40da4d26be7021bcc3649b65592eeab8b290b29434e33b2017ecbc386f92d0f0ac15cb87baea6dbcac5238d4bafd83c1bd4092d39286b61b1dc69901c6331001602520969cf35ee3ad9746868b603b9bfcc7d13b444615f793fdfaca6e43874d1742a978e122b9b5482b1bf03b2a705b82bc3e25d207f4e2e1937562c562d496088b4bac588d7f23d301a2d62812cb353904f8a45d5e02b1b7ab56f847dcbcf575b95daef7a8afcdb663d2cac7ffc7dafb00251276490ccf4e084b5a154c66b4f07ce662ad532b13cd746c90a962eec003e20d596e67f31039ddcd966e9763c04be2099c616312198edc744d265a8061fbf66537e35e948e2f8c4342c6700b483dd4e22191604f973f7c33901b607ff48c9c0a1262a5cf844e715f59a9e413cff7f02895360bc189695303c6fb0ee504a3504d3cf539850c4e8915d53c9d044cac9f12b9f2df19d6fa099329e3de26bec5063a8f0e13bdd765d3a38a2934fac16a1d10fcf8b18c4c4b3e9f098794ec4f229043cf15584b3c0651edc2ecf5377e7d3a4d3c2ec45a9972bc56e833dd58155b235110202947103674ac2e93130fe1ad163184758a08b74e757cfab9ff29e480dde4758beed5a40025d527219c956eef8df33c77a64ebafaca93bbd31b66b1f82ee4db42cb26d1c0b6c561537dbd2e693aa540804835989618e672026f6b7b4d64813f3eed740fa03ceb604d47eaf0bd6c3b3ad2b913c791b1a3ffeeb5c5bd4c9c0c7e682fba24e087db598c4d46dbf4bf3661bc8d8b1d2b138b9799fc95712dba6985e5db6fe88de3c460008e97c9e8e9b58c80b8ab3aeb39f1f26a5464a706993c9b290998d10e5d40e328b6879f36cf97f6ef5d0e03c166becad30694f06a175807d5ee1134dfaf9f5e7b20c29a4ee880d47ef3536b712a4ed5ec8b3bfa9901a1ad351830db194946b795371a087f4a825c7139fda1179d2b15597290c8eec499c6685bab5ac2bc612328997671720401e0a19d364f0cf0ed4338d978a1d201fbefb215460751c0a7224186e7285dc18aa0836d0439c71c98670d988e11d8c3c3c570ab8f5cec854b8d47c859aff9f4dda873bf7576338fcc40c18561cffe04659459e7380bac75a37ac42626f8a9cfade829579253f03f67639eef35bcc01a10da0950a618ecf9e6dae32f2efb70dbcb2edbc715a0971f7465d713cad492601b852624f895c0131cedeceebdfea285beae37d04694565b424a741346f3a101a7be6ca1fee2c4c6336c03735b8379bde1594f1faf2babfb904e7f1a6e7c6bd308df6706af9de24fef343a538c1965fe774b4d52a30c2531e82214477011fe952950c59ca94b02339d46b2b6c6bae1fe22535820327431f34d13df316f1a84a03634a5e3901f650e353f667c7ef610d33e0e3b6cd93dc43e08531aa5a8c0f69aef35b346724bf5e70b4984718b59ea93df0f79dd58c90ab9f650745aa16f7d8d4777b24c59cc0fbb50bac5192eec87e04d558e25e0477ddd25bd6071162bbafbed7e4eb4dd04cdc204915705ad6e8c4c43f5c0bbc5ece0cef742332259ee32d603c3315baa362a3bc5402a74665ab050f1070897c54ba7debc3e408b483b63d4104413d5a72ec8467f38690127549d9b9c52826190cc936574dd5698e3bd7542f8d6064a710ca24fc33a95f3c122a08cfff41260c958f2dfaf252677c2dd5af3bc8a38c32371d1cd5e5ad797de95d986730d27b1629ce567ae30a5b4c658fa3ca4003a850ec9e437633264b45043fb093e4ca2b6177339ba8645de70c0148210de1d3f70b840b84f64504e50cfb24d86c06ce26d757b27b8e50aae8e6c84e968515edefa53bf2c79a64236b81fb4bc8d12385c5d46a234cdd49157bb4b3e645a1c52f1545f3823677db174320293be9dcf9b85b0585bfbb2ae4b83c78d5e7f25d4ccdbc635c8ca81165be6401338b4cbcbae0decc302bf8201ba5027e20d6d29c45437f2b4a54b4a62e0c2e738f0d1c1a52616695316135351372b0196bcb15ae8594625cde8d8672355c2db718184ea5e3334d77542c6659ef4d3f130f0dc3d568982a8f1a8ea376467e2ee95958ca97295422ff6a6eeed43dd7d556ca04a4f4e813231418204eab609c2c37b7049fb3db6f8e477271d05063d3aa03f27c83e59d56ef81b14b177101fc4179fb718a2b89618f986dcc952412593661cbfd9ae19a03a7724e721c3764e11965826584b5af02c820ce895db6d57f42ed0cda5ac830b49e600f54c02c8a79183f262b432c11002e850807ae16ea102cfa23f6626c215dadbd3d29071578d20df31d54fc31f13e61b7b378ab301d49195d08fe550e23222adc73d58ed565893d5e6d3310628d5037e8b38d49ef97e0633a7378503d53af58bbedfd3e2c3b28c0fd39c69a99c3aec774d071285931db1a46cf4b63d77e9a8fac16846f10779568e3208f41d5a9f0c0dc70d8558f71598b95bb5d08b76bcde387c201ab383655e514358d7d24d6c267434ac5b17487f105d82846cf95d1f7cebf5c15480bdaa4ad596e1f8a96a47d1edfd75f9eb843bff4e81364b214616fbb07643a98e125f971252e1f990f52292d9cf41222cfb4f675b588bfecce9ff080f51260f90f3f8ecfd394215f2808ef6f6969d9369eb00c30e7dde95130f9c5dcc1138d62b960a113da952e29e47a11e6eea98e0031fbd4e4200cdc2a35bde92bd78ecdcbbe4bea912a7830a86f648b7d408d352a83136eb33f66914552b6694217427fa2dab69ab4f36b0b993142047aeef910cefd979455476f2e39853d31c212ba82685cbe9eebd4b5d01746f35618f1e39ed4aa91a8948e322fdf2da7913308d03f73425bff2d913315d8b9952601fe1308c81065b5aba36e2c3f84c3fb0105829590c52f5542c4208bfa0a5a2ff978909e52492a4c0cb89720342848f7020902cf90a397c896245e87e4267df8c250c940fc07527cc11dc5767afe8a94048f1765d076b1bfaabef132e1a5869aff56b3a9b8cb7076a4b0a6e84a13c4ddba32b7ec97ce332e2c179f7d49c5ea7096b4179f8987defadcca568711ec45bc8a2c73e86e4db754486d6f7421e5841c7c1cada0d165b020d71257d74d8f6a1b23ee1d0c49fdcd095d4edb1869757a9f1b1f38f5657a9158179bafa6a8943aae416628c6db55f5ac84e3b24381d8e842a32dc615307935457ab2d2a6a8ea885d229bbd3e06591583fd4e8aa3944a38500cfac1e08d8e00952fcc81f0bacd3495161639d9b175843c9044d23c161356566bc24d365b85fe735dc203275af539e24ddc63bc27bd0445b79c2b3d7db6a97533200bee1bc6acec2ed8e54ef461aa0e82490754eae8bb185acbe331da280b44a7bce93312f1bd148546a270727b9e5a6662a5995dfeb22d6b9e56b046f3384c3d4e94c8e22219a95a814c07b7e8918574800a070d1b3423f449d9223e6c25330594a6d24ac3d6623fed5005eb57ea2586c61900fc6e35d4a311594eb13055b3ee3334f02c4da6ed648195d2c328b398c451ca5a4d8deb01830e31093dd5419ae48a361745a0ff698bbdbcce769225b191e553152f8276f96dcaf98e4a678cbde7cff70302b25cdb15aadc7f7ba683a78ca57d580b0a91562c3c145ce1556ba955c9bb74974c9a191b7f3d40ed75a488acc10334192429ab2ee4996a8a61dd965b512775f7d8c13012fbb97c1c7084ae96593f470c7f3f42e5ed9d12ad5aa2f85345e47ec84be36331f09a2294af9ed7390a876502e2afe29c7848a1fb310098830fb4a93dbb5109ff630f4517c8f32a08bf958f86e41c55d7226b4b8e759c6ad5d65347d8c0e53447385cf9cbd48e98cd50000f59dfd68b9ba187880abfab7ae7ffc102050ec85e0ad3d22dbdc7dc60758724ca5c0800ed04eb36be2f6448b44a1e261fb8c3680f9f66e5016490e6d3a9db632c48084209373b6c2a8c91a3cd898e6740b4b0335bd750e447e75f2d3b0c9959349b783c56b063b0ebd736f752455a8d7a661b00d6cce18fbcdf6b77e9d9bf0286d786234d359061bbbdc595179ca80aeec536dc67f72c02fc8e7d4df252f521ecf4fa088e1e70dd8c0db692b587b35666114204589367bb1915c0b78cf80e6fa30375111593d37faa7a3f171e5265e23d13e1bd7e8e8fab008de7f14b4cf764d02b76070484ec7ed0090a93da73f069054c5855629f2f53180918b8d24de0d9b2c3b0700e9ffffb0437d2b973be3a1fa8903f2097709f57ba73314d572751f637d163b245a25fcf40c9086a62a498882f3cc3208f1cfb837305c46482fc827fd84a02f838ab0721ff90989eae6a56d3e0b2c62139d173bb17167cf8f95ea9c6b607c6941c27746b786e16eed9697c9f5e14448ff726104f8948b77f24fcf256d0dfbddb5f104b4706e531db5c1e64c213cd7f1d6f25cbc4af3c81bdbbd0903ae283ac40057a81a18ad2306a0c46f2bb1a49fa61caeb1a0137cca9590f51af61e575530641eed1fe41bd9504ad63191c7398175f0db733116b858e257e92f843ff2d2587e7cd39122e5c2bd76458740a8746812088d2aa3a8ba8a71a6978f9017983c59a68b848a09c7a17881b89a8f80bbc84424d75be280b19e664847a1382585c7cb3f3d779cb69f4b8b775d30fb0e0be7423335892eb91fcdb5d91caf004e1ad90bdabdf242cc2304c8fae4e630f36e7332372b40f77b13d024ab2d24cc3b62dbf0ec06085e2785bf0980f33f1e474e260820fff9556d536a6add4f092c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
