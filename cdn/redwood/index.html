<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3bf701ca72d813be989ce85183d5630861a8a6a2e698d9d0ba61693d8ee90125f66be085efeabcded7f91a07b2a2ab5b9369b7a7a30822379a04211ac7ef98fc99db6cdf366f19a95a32e5f1bb213c14e60406f7dbf56f609daeedc2256017c908432240ea0a83d3bf83b3379578a9542083a312f6ff496b075a267d8260552a7052b376c98bd65bad23c069a96e7610ff4bcd09985c9bdd6e76b9a0629bb8f7002cca44147f98de61c2e8bf41695fabccb7ecf33e8d3a313c07f8fe32543f3508d675422f57fcc20fd5cbe466fdceb01dde5fa72aa172a22ba06a55ce259ab4ad23fbd4da711e03e218fba9662e0a0926c09e525dc508bf481563509dba368db6f614150146a2d0370e5378dad7ecd15fb444ace91d639a72df1876ffabf1cf504cc26c1ec272a12e6f43ece46498e6dce99bf64426f7d9380653ef61faad8c845f428f87c2bdba68d79a950c07b5df48e14f11d6373d7eac854c18feb86a40d659431330c0c6f7e820f41d2a2237b4c0fbc5fe219e866fa8b0e81435c9998c3eb1e3759b7ff5b3ac8eeb7ec5f2f43db85ce147e933e80bbe6dcf6ee98efb2241848c8393a34186a69d0c0b607b5e2f1f3e82d5896368f3690406b22f99b3495279736bb6a2f3fceae53393d0abad31efdedfdd0ef5d460f2129ab6f124e8bbe484dcd69c462b96d0155caa42580b488b19151aa7019c4bb8a1eed9c2919bf363d87ae4f845ff98ddaaaadab310a01cb484d4bf1252a2914e09e7e65f71bd397b701c648516baf6c0f4ac2f74ce780504f3c297b56b60235c981f6e831f57767cd2337639f8fb2aeb743dc4f98ebe13807a7e11efd8d3a0452d0dbba5040bb74ab023c1bb43339c49103b369485217e9fc5ee4b59daeb46c30f994387366eabdb2c87fd9a974e861095c69bdf256bbbda1c91ad0ac0fa99dc46e9360abd8a40afa5227aab67bb54f24e11bc11074fa5538358a6673d5c902df0a4622382756dab4de600324859352d78067c3c7eaf32c44103582728b2e84c47b8d2f21f01bc2cab6be88fba756dc91bf05c8a548ef02fb2e9807fbedb9aecd691e1b3ab970829ba83440e08d8d24787c18650449eb5ccf4305d9487ff40ec2af0f31e94e81ba5a57f333ed934bf80a27334fb4ce4095c29d256cab7ba1628ce93b71b6905ac9230d484d42f531bc3ed2f063b7e09256701170f6d3632eb314f3afb66535f5a77b2e529c7d667c47f653b6bab4717eb6c8bd7226920d6e258ceec066456c2b49754620de06df0af4cab65d387b56e76275dd0b64a72646b25b6d1f07f1bf60fd3045275131be1fca1d3d178f6a25bd09c625835e26e5e76b88df837a1f66aad62f0e6b3034867f224d08f043fc55abf4727b1e82655150c360ae8eb1f5e0aa5069bc09027cd09eeb9fe520ef713ca5f636cdf3f45146bf34ea1f07e2bd972a17abd3b2711a008457fc463422184f1a1042fee04692deb15f7c6eda6b3c1f62bbbd4d5676c75b9a99ed25b0ebff2455206bebcf4522c4745ea06ce096287d28edbdfc0cc03059ede754a50507fa767ba4effcf719e99cf4dca2d703f90b7a546929d0262fe098829d0644f2ef4d919fca98a830a165afb2b8632b3c0bad1990e8f99ad404f820b5f70908c90f53e2a226ca2913d11b20fb2f4994f6b5dae601de499dbb50d45e8793a310ea4b0966c70e68047170e9db5f8ef89cfd13b92eff72f177814c29822fe0f10bc0e2f45fca1d115d27a1eb2eabc3b1c805c9ff2d0abe149ccf9bc111552b45fb2b7026d84027f8499526fab6887ef97aca6caffa8718ff98980bb02f8c5baf78c016f5627a9b4bcfc329a2b60a23263c0d0b7b9c093f886d7be1e83b2839c1cda6db0f89b36b992cb9beee4c40b35f056ad90e2e25486a3e529d6a9354a5dc72820ab2ddabc7f7e8e094c95d47c09a9922ae3d71e720796a16c793d4ec806c4ed8410221235dcfa35a6a6c234bc93c97505c7e331f93b0ffe51dacc4f4dac9c000509f0acebf529de55ebd1ebe163215d2b33247a60a1dabc72d11bc03677a70e8f944544fca74a32b2677f2349e651591e1936c2c58cce1ab88a94dd58519f18577872a0a541c6972e652d23f0ba58b196a50fbdbdc3acd5918431d6dc3f163009e452692ad744f0c9d8f8cd8746adb7fdda2f1d746892722f2b1485550294a5027770306c8a111dd5de1cd41165a61eae629eda9d9729339a49cbcbb63f192d940be625742e5847e851c02376a8cb4bd339f67165b6904290c3f57f26012e9a914a2309d6430843e0b13a42240e59c5c60a0122f756cc0cb926a016d40a2d79a2af86d30c56b16c6e91b34269b638b07894b63c19823f4c86858afcf4bcb6072f51817df26b28ebf7842c8179b117713bbadb514181d753c2cc518676680918c84e4bbc9d5d33984616b3bb8153bb2e5481777bdb405e48b7b6ba4a881a8029989eb65debf9c6ff32996cadc5fe3e6e6135890c15c907bb61cf8fc984b85bb23fa16df44baf361a7818d7e2255123a359ce090203d88fe9ea91a23464eb2b756ccb66b56db3001d414034e1ab02ecd642c7dba271741098765ee87818af77262c02c7338c19a8998dc241314dde1ec8db1a623463034d23d80aa577bc1c48a116489a372bdd2aaf3fd7da54ae1e66f818cb96f25b971b26260158f8eb22f882089d8ab59e0e5adb5288b8312bb35b1fede231ffdadfc052873e7dcc852da4a254e73b14c23dd3f1d4e47cc0f667fafab892986f51e2b8416c1c460362e1973141e7b48d78ad74b5106d4e3bd9625559b0546e07a7ea62a520161a58e006d88f077db8d7f472001d1beaced9ce3d2e8e7e1f50cedbd6471a78a49438e3e364fff736fbc2f0342b1800fb9a1232bdb2b8003756d3ad54c6711820b14bf87c9266b85f4d55a20b3a3436d3e1b06533271cc25c4ffda97b9b1afa64b0a0a45ae2e477e9cdc59a2e721c452abf5e0081fd08a07fc136cb4e46c6c830ea5d2ff41b2439be6b6013fbc6f820633e21c9565f22739edd7916098b662b405f6488addeb8631c59cf1cae06c67af8684a319569e3ae2be5ca345bb18d980ec8e7f0fbc6acb3e93b6c9d6fbac2e567442be36a560f9143054a764dd19b9729a4fb9be82d0a83052b56f44e7138adc8f2d2060fcc107955f7cdb82ed98492858766218ea1bdd2190aa6a8c32044bd21c521731909dbcb1f8a1df3958cfc9711e08c51a7beb919500ca39cbf7d4b63b49256d93a41a74a210a4c398d53ef09829058497bf8fd7e3c2dce4a9bdbe6f62dfe1b5e9821e121f3ec65074495926eace001f0807728fdfb845e32b6dbc131b1a7209004220d96d0f81ab9666496ddb97a59d315bd7d3e91ad3d053777ad1c8b830de0c3c84f731bff7e2bcca6bf911d727e6adaf25ccd2c34385f47db5220a2c421ac9c78ecf2a323bed86e1366e68a4b3c33e3d003670aab204ca9c8d789cceda694b60b13306bc637f389afdc436497d3d2f3145a4e2f5d4e1e763da0af821ee391ed965ec5057f42b90081767e1f906c28166539907c110d6d0f701b912ad2148316fddfcc4e98be91c5e4f33105b564e20aa9e4334151b82fe70d43d64d8ce1f5a86a7594f06c332bc605e142906ef9b98a6dbd9d88e559cc16622c33731ffa2d5b9d7c067206b4cd59a8173aacb3068acfe339d7d8e990b73fba96bc921e6b1abecebaf4dc2ef6250e1ecaf4c0c7a627054ef27a8169197c90135c6237166efa7940d5ea9c17a5900d3fa928e56e4a7fdf782db0bbdf9678ccdec69d60dc862e2f176c599194dd9f5c798b1c3c1027ab57c192fdaace8a34901f11e42588b1a789cd0a3757a0b36a9c3dab0c4319fbdceb44bf59403d1bf48ef85687755d3825541b303ded24d7a8c6f7c9799f54a5c3281c1271f27552cc4b92608952d4602627a590d78017c9088c254070080132c016954c55239b5002fb63b92e8c8127f0d23ac43d318b3663701042ae63059a3ed3ddcb34d2970d2d5a7d7a02d84d8a89a989b1c3eeca4c76403f90b79568a9c50cb044d312923784eeb1225529a382cf91b2f85a3260ad81bf39996ad7bc8e278c90288779e690bb2a05525b771be20142aa3288d77f66e5b44d928742c383fa85d9d766fc50aad65b103ce777fd869e063eb947e1ae20688ceef55f5c68f4643cbf75f4474c5c1fa3baee538bb55fd334996753cb1621de0fedaf19251c1fbbdcc101193871d270b119c959f0a25d56f4a539a1b59d022018ef2368b08a9da170a9947ee43b888410cb042bf97712a20407759d5b4dc6ed81dff4fb728c0576e4d9b38fc0b54d29cc3f858f3fa578df1163db5ab6cb5c0e89ebb68539b16b5cebf52d910d48b3e51bcd95ce94af8b7b2850a1a8fe31d5bee5ae282c3c0fa7c01b672d81da5aca6fb91d03fe5eb430b478fcc0de61ada1718ce7732f6c5e47d811ee2eff31bcaffb0e0b73c0496f4f6e3830774d374fc438f9166ef2d6eca5c0280f43b803fe9f52977d0403a3596e54ba9bb596a3d6c236ece4fc81c36b6b9ff33f3927d2f4b131fe7e178c5efcf51849129389123f62b712c0b536141f8a37569a91c28ac788ec55d5ffb2aba62919ee4c6bd43c8c1f2050c0b63a1a12a8600a2a1fa363e5fb08cc43c379f4b76b762c2d667bf0878e966aebd50e14cd8b6cae462f5e1500a9c9f9dec2fc27e197451b137b1dcfb7fa9db4e2762e3fbdce40cf62697feca2b667321ec95a06d2463dae6b4af055ce1136ea4493fc467c3d562fd82bcc3bf896245de5464bb78c19c9647c6b12110d4326ad19ac83f8f51db68a6305bed414f93aa624686a374d4c43f987ade23bba49374149f7514d67abc734017affc625ab910ae352baa598dd229e61783ba59d62f1250e199d296bbdf278f5aaad38a14a252c8721b2c2403be5909482a1b9751cf9acca061dac043d1641cc4eea133121030dcbc7ccf4d63baa80ddc236f29abc5f3e94f4a3a63f4ed419485be14e1af76600b3dc80772ea26c31328e409e87894685aa13866931ef324fa767ad07872e40136c67de3d895d127fa7490783312c8a75ca283c27b679718ffbc429a85b529fdadf2cfb2338a09978f81958a897d934cf162daf4b69d258d9f4e1ad4089735934ca22d15cb1cb7cb579b180e359b199ae2e8eade7cfff6ac15139ba18c682070de24739377a29346001abe74b04f49be07927bd1c00d826486a888e1318b81c0773c222daaa1325e240814b9e60a92cf5e94ef979be9ac1ddd98e61d32175eec0cbff96e980770eec0667cc68701fca5a8b91f6cd47cc1c7d05b1d24c59972a0c93f6c3b2f2b63b24b73cc8a5a55a5611eebfaeb18f005990627692a8bf6aa4fa310bdf1fcaed972004ff5baaa4715dde1d03b52349440f4395da742b88fe9c9c20af963ffabac3806a6c0e5602689fb6b72e4d8b50b1cefb43889eef4f3cd6c97fec6315757612983bed8c29108600941faea34a776013d2f813971e2c6d729940d2b724dda2b815c3b2d7d5685193d407dcf5afa83a45fbc64a4d50902697bf4eb29843d8f5fa54702ff8eab684ef6d27f325b84393b564d8929a2d7dabd5cb455e558a7cf6b73a70500c24d034a9e4dd31f22d072984491c21d1f774119000b74c89f707902df343450935e333c65142721d0bd46d64c571feba26dfc20c1d76dd4e4f35979ffffc66fd7d70ce7b7bcf758af8fd66d4f386312be2d3e059cc363a194596c30033e2382ef84e165c1ed8b36722684da04937e6093ec25b50443bff3f59df22359d557fabef6c79227bdeb9f312f35e2f08c85afbc654d0e56bf680791f653ac5d9babfaca54d4614a906f9f2f1998c0d8f752d9c5aaaa9514f89a52422f1f41b5a21550271894240218d3e62da668f3c03c1c6b16466c8c8c3ca937362e5bcde996381872c75fabc40455b23134aa242f182e724da449c47f102d2eca49040419a3886f83d557c9dd402c69195da76081498886244d62ffefdd1ae84a3a9dd45ed547942934857d25b8b7012655b05af989781f230c9999d554cb1932f27b21c07187e80acfe169dd8770dc63bb24f652edc37db5c9ad0a62afde7bcd2e734c36e88df40ce94c79e841c0e48a87b7885c80079e187e0b9ab60cc158a63c0221a6ffd0d206afbe474699db885a6f6d68a9a94ac8e7c442080654ab48d5388e1dfe0757ab508daee3d09b6e1e7f04caa668309a7207ab40781151bcb3c91538270dbb2034766f38f61123110c4a02a8d6405a8a009541c1fc66e17b000e135912c3e725869675722f47218195bf3bc8f9d207bfe9b65ab7495e74d9fe6056c02ae45dafea9a0757d76b584edf94cc15bf896ad042831d74a03a7158424f77d572ac360f38f6adf1de22ec3956ad7eebec011790d46c130f5efa286ed00f4bb3ffb201cf4bfd447c83b049422de8bbe7c425ed4d2286518d55d49e6025c484812c19b97d8acb61afcaef1cdf51be89b2a5c23bf6e64361a82f8ebf566b8511f50712c4c3bcfa03252b156e8b04b7d38ce5b9979807b1afe54b3c6a4cf911e60b9088c4647c2a78400658aad55627e3611f6bc3df9e3c817109dd43041d39e3fde12f637da29aa1010a177772921a2fda4319d64de01e720daa5e76c4ba573fb4e61347e7ef0b4b092e97b788a38f9aeac5806ae6c8f071abbe8919a6364f2680817ef6ee552902eba8cef4a1ff606bf7bef9037991c5c7f39cbd04c62224394ae23be8ebf2452dbba0c2b92f68fefa0062397478c31249dcc9f635772f3dfebc354bd13b624eb923de7fec5386dbf3db39d70a93d83a9aa82c091b2fd3440e7dd641b0f377151163cf1aeeb9b0009dba93e4c0d6ea7d69defb1de9d49e3ee9c6fd0a20148c44d81d195561c6bc1862fba988378675d4a52cfff0a1c6d10bae330760bde231914ea00c01f8b0e9a408cbc12498c166be4402d95a784a3b6c33faed95bc863538c4c07e86d395a732ac83180a401fa8085347eb271ad672686011e1d908700bb33bdad347b41b52d2bc635029586b3d83737cd231845fc72ee94e2d268b6afc0ed5809f98637c202e8d78dc2a5d6a95d2e3e32e66fe3e3e753f214da73922b1b857fbbe12e703089d00dff4a6ddda5a76c979802bbe2930ab9feebcbc40313aabd58d8768ba3c564f5db47d02f8c1bf8f0d9c8214ad45ce5c7251754ee42faec616301920e0b4343b05e8b882f8468bf788ac36e7f390a6383898dbb467e06afe35b6014d47acb36748b40cfb4e3655b86516e864f7130a569290d82d3c26055452291c9092f8522ab7c7e6e53cf37ec82bed7f5ab4be7790955818e2b3def78da6c97a1e7be362fbddb13b3fe77144d67abb6f00eb6169c774b84ab3dce370c86caa88b8179120e229b7a517503ae8e1c14c7fc1ba3c48f2ff563cdfa809e7019eed4b64f83599fecd511c8836d581fd0b622fa487248c6040cb0b233b51a2dd7b766db6f92b84f235d63807208b6844f271e9d9209664ee764dc3020789870752520b553ed1453c923b7776a220f4d8a965d43b97665f042e081152ecf72d46ccccfa5cb964e1d0f7621596dbee83fc7de7b51588de047ec0ae0aba6a971c0678bc57228f0ead940ce7a914462b19bed0be7409ac10ecfe56894395e10a48d3d84139d211a62d7b2fb7d41bdfd5bbb20c9b656759f061089b960da6e32606f226e481cb6a85e068f72c44e80608966a320178701c417a5d7fb9cbe458e518947977675fad09901c6448eec93ea3bd399583fd0a5034ef0d6b8080362654d29796edd1d8ec1cdf5a2ec0b3be3f5272e6197b6581622ca2ca0170369b952f976087cb4d4914066bc0afc863258cfa2a38aa5780036c70cd19951329689d6662e1a1dcd779725ac0012efd26373688a3b1cf9481c3f273578842f623af429f4381cc5310907b10cbe40ca946915c278ecc8700c80e17c6149ad3ee685fd5de9d26ef5276fc9549cb40f96b2290d87b16b5f21c045a65f040d1fd1d35ed338349a447c1d6e51860d6cae1cf7c48cff85e6d4cba14b24f7738e6970252e3b1ceec592f6cbbae0406e49741d4e6351d9d4dd7318e124e5dc3eaf989d5184ab02e8b68b27c159863a4d55922757f3004a7eb695102f1d594df561cfa1a24fc48472ae49a8c5ee2ac2b0433c5ce3f75acd4bb5581d590c4c2fc81e0b5ac31f770e0eb57358a879e70d90fa9849b146612fe97298b9040f0bce3d36829d02c6a601cdd3645fb891e32452f2d332212b7e3d6c07f56fa0af3847cabdcbbf0fc6f1b964ed8efe65d4c93e3343e0088568037141c1c5438aa41386f1511fbfde4e1a7840890fa7f8d6239ad95bae0c89dfe85eca045a3ac666c741bfb16af94472dada8c4aa9e9d5a011c5d3502eeab9347d1672dd39599f71578c6b2eeea33e4b84eca0783d5d1bee7da2f731ec920982ba5c6cc923b40231e8604f7ddfe83f89ccc4fa22c250185d96bd5a31022efe8f4a2bea33a9c0cfd75cba6c566f94ec1cfef524b237de491eaa64d68343436ffc6c515a6048ed84a919e34e66974306c1bf602a6665bda1c29642610628c3fee44a177c97ab461df4cd805bda9e795aaf3db92113b715ddfc8b46795ad8f0e4a6a996e593b91b2ce79e5f1b01a53f3e0fe5b6ee06d2a8b8e795d1f7d8ec8a373493c23a8980c3262c566d9757265fc48190cf53ea0e6aa9d74b2f092916fe6daaae32fc2c4075e2d3d9731cd5fa6d260d99ac9f80b293d1e4c2e76f7f9605c363fe8743f3d2eff3e29ac3f89e7118890768fbed5faf04b78079537d49f66412c02f2435b1cd21852807e550f005339d7d06e777c8c0e08e463d8721a61f521a1daef2849b12c817e6a6e17d20e3cb2eb361071d568bb5852e0a68da196ff3d3c01766e8672aa3112679025f050b0f75cb840bad18a1e0538d199c1b9950d15ca4e155f9ca3c3a43ceb5336c38f8b8d812b900971255b933e6b64e19d82cac21bb0a31a23fc4b68f329d80aa4101df284f72378c1368d0d2522944b1a283b3aadd88bdcc628d9023ea60393876677e17f7a68bc52260c2553f6a5869ea1ebf24d435741fa78021790f61e006e8d3cc502f8c26135de78a656e8be6d138329c1257f06d0a0651e3ad5d33bb235f36e957f4c1c22d78e6b5f87428c66919cee02975830cf543958579b04268122c0e2a13e2bab5de7bb91779492efc75f2312431de2a8c14e1c7e6823e1b65ff39acbd5930333e154f8aa9432057721af4dd0467516db9c91aab536931f8f0304651348518a9845c7d1939f8259c43138ef4bcca22cfe9cd5f817c550d93153f6f297f96c781e2ffc8abc5df82258c0cf260d76324795750d21290e10ba8c6805ecb9ed736db198a25124d8b4dc1bc4b83a55d7dc027a6b972a4b96549f61ef28c0a6bf3e7d04df4ea39be6228477e47b83f2df9826b13d24e94f6fb528154e59928246b167f7a684c46beff074aa1860f9f3117fd10a1a39d1869532bbe0209c4d090f4ef899853bfa30817105b67c8f68c1858215544f2d33ccc77227677da0b85901c502b47545baeb92e874741fc65fc98a1f3c9ec5550b2e107264408eceba9c1a33e52579c8bd34bb47b73922b47bb2f0cd1ec850a5d687c8ef2783854d899f864a00e3ec16ce6c73b9e6a1dcec81a1ffbccb2590125c1660b15b31256de90ae678e4550db50d5448866a4114f6f7834cccb49b3f538bbfe691c83b2eabc6509465c186d299fa941d35a937869f6e93f2502d50207e58c50d28808aac4ff7b731b0b5f9c8b01e8f432002ea40c137c24efc7d985081ff156a0d99f06c754de89aa2cd4cd8ef3951eb038a26e965987bfb15c24f7d9968a5978f89977318fc84eeda58e4f3eb2514812cb6479e4068949d48640bffd2f1c6c689d27db26a348a369ff021ae0b5d9dfdce77147ce0db051957bac701e8ae6c67df6817efa74c5aca28e0521b5b54ee436c207cd069cc8ebcb411985308bc166870b7679342d859ab7e6537cdbe86eb428f10c757357e65a8a8d53153be0505180b96a44c813b1affbe20169d2cab56a500b097f0a0ad9199980f218ec5642c92586701e7723469f5c051c04169a124aa6d094814a510dfdd41dce7dfd8a51e7b58e23d881168374ca5a300bc0664c8dfdd69667586a6ef5a2785480aa9da8ad845c3221fa3fb176d5f7fe44abfc46cd99742ccc059ea01d22c6f9b588c210e55b6ae52fa86f265b6771449bf831e12ea8b8d382817c066cf793c4b24692b4e048c09594a920b3d2c79dc31ec3d60af77b0d82a1a5860f0c8d4b8e99729582a3422cb3623c13176d16b6ece89beeceec113c07b63a49091c1759261cf96e045519fa5af645bc45c14abb18ba06245c205004b70778d52ca64e2e731a22ebd10b1b9ca11dadfac7459e8c3ce3d6be5c17d0f21cfd76eb21b141b01e31241ac8dad55a72bcf76b79d048c27108f5e2d34c8555a5f5263b7a875754e2be93dd23432a6266e82d04beaa9782cc94f3d64d86a44030d0505202abb8093753d250220274489abcab807dee5de7441765ece8cb8044c0988e63d682d12bddd24f051fd91a740230e4e7f5e586ad89437e5a93085645724bd57436e4e53be97d9e48ea6a30bc593709d590a4ac7d59ad5806307d9e4823c9432b263dd5aa757b0a76c037121809ccbea36969298fba3e2fa4ebfdfc99285a7de7faa119e321d588b104eb37e5becef2328f75e8aa6be319ad0fe4bce64fff80d0ce113e56dbabceb40b57c5759be315f552ceaeb95176224c64429e7338c5d41e983f9df0ffe8cc3ba8d58dfd5f1e91ed924bc28a62943086b773700a7e9f7106f186aba89727c8cd016cca1bf36db275a628ad69b1ef20d80ba1c26ca2e29066f15ea1b12aef06f8044d7272ea43d4be452e84e24c524a9aa5e6401ba47579111c117bf310f4c39b67be8c8d8b588f4eed6b66a97048c2ab6a102089ad06bb82d51f9b11ad5263e9dbc440966cd64bd5393fafe1851df89e18984df69f22cd57d068d7a6d5745db4d5f1a3232e6cf869797da90e4436a214b2c9a990afd2f58872f1fea092e5ecc5d6dc0f9057be76265c2db6e4ead691373270031e03889a0d893e4f96db8b3d5737ee6d6ee48a5bca4f74ac3aba54c3185df490248a50b6dcccac4671f1e4d9f8c7fc877e2b51c1bac688abae5c9e66274b6b84e9f457e605f6df48aee38d3d6da45bb62144666199f18f4d7ad93c966cae58a1cb04047d4f0229978e1f70895fa2109cdc6616784c8bbb9fa0e00ebb63045fdf620d8a8b73d6a56a2d1524a56aead34349f5a887fb8b99b5051465cc25248a49fe186fc0f7faea28daee2e52786e4d02159a60913a1d4a2d2904b941d7937c70e71ee4ec3eea399ceb8ac57c01a0403d3c59a3144637be30c8ffb2c10f0b4bc1df3afd82eb80ece0b2cb1bcaa3a047c7766acf4513fee9e72d6cb9e41d06b65cd59b376fafef5df10c08fca459e976f28c78c74b31044c86519e76e6e98dfa8b6beba9c8ce36365998ee4cd58c581d9eeda3cec503921a6031588df3590c3b228ca5d084d36815de0561ad9c955595f98b84d065e9915276a718c77b29c8e082fec3cdf3bc7d220307207f910ea0afec71fd87b1a36b4db59584a2ef06845ee669bbf8987703237c1256f73b1a172cb53b531aec99b7258f7c95bf81879085381e8aea51fa97ef2d4189e31947045881846afb1fe5386b03071631c08d3b0d156b99b731aa133b5e7681b3c3bb3d5a3fd30051edc0eb9091de2bdbd826120b59b92b4208f995c8866eba15dcd63cabd6ad48788368159caa1c2909f225c202b200eaee12e20110c9ea82424a5e1abb7a376395dfc83bd000d96abcd54f055a43cb927dc741e56feb94caa0ee0db9561eeebd520cd82051b5e2297ac142e0e9c86f9274453717baddd6f76b96ec50a57ece28ea59e31c9aab6cfaa406674f6428d46f5673f07d57108d872188d94e47022f595ee7441c8f9ba3d963e5575f3ecbc3bc3c2fa273a20b48d109e88ee73ba2b481a7aa8013117be443abc03a1ad0728ae8fb7ab5fc3c3ae404d4ea0d17c609343848d354cfec8d85a7420fa5aefb2c35f1bd4742849f90e6efc71d796ea86bf1d66df3ef68907609563a9f8c64667c9f1309b021bf309eeeeb17d74f51dcc8660e111bf1f2e1d750a09ed7e49a157068429afcff4afe9dd8d740f84233c029dd0f1e226ac297e6fc7f0e2c325c0bc33d2ff806ff8cfaadf448cf0d0600982beaad27c0cd521244c355a9e71dff880058a247d23d27af18331bef371cf03c9972460b111a6730eb4cb11ca679c20b53309a8c6fe3971dc15f54a42e32c472d834bd8ac78a031a0692abe39e07b39142624b74467dd4e907bda53b4f2636e5ec7553e9898815b663c73aeaf0b5524800b8a85b836b60827ad5e4f9d1a649d3530b6cd4cd96f40eca9447a208a5634c9de106ae8c9742a0a722f843e56ce907e622bfddfb4c03e70406c5ab08cf318fd55b3ac3c5756c83c2073f41dff6165bcf5aa6cbeff843204afd08b8de7696ba5ebea696b489cda3b033c4862e1c4b0645432965aa88f19d4265cb7b7f7bf1228759c8202463c7674f8fa16859d45875699d83b31fcd92109333144c14583606fd30d042b8cd92b99b63e4949bbddf54825b79a155e1dbe07970af15e3880f2778168d37b4ebe9e9a15074302c698688b864c1edb0a07aacea6c8da3e665566b6ecc5ce1cc9f8ccd8b8b829fab1300979093474422c2395a9b8153e780a1f8d1b6fba1ea61071097db4acc711e8ad43b73149704f1164e7b69b83dc77a697c9f722863b841f763ca0657aa0161a94169057c99a3e1d7e6522bd524a454580b0f990df21d5938c87506d1f3b8c26759b592aa7349943a804f930844228db1daeef8c29201a147167e75c8878f31740e461d8dbf54db0e862666a90b707e112b978bb449724b9974444c1005a21aafdc3bd04d7a63f50c5b2465037aad741f5899a90dc16376a0be7b59202eed350c73f52d16bf134ac007188488a9926e53ef898267ed024de6d1fa433c404b0db89a1401698ee82d822bcf68359e6aea52e35b4c357bbf0efe2377f92796f9e68ab9df07f04e7634a89b00bb8828205e9646e897daf0f6e894c6247fc11272a030814c3b4c61b773fc61e705de8944d6bc58054b04d3c05e0bf1b064da396d9d8ace960adaaa6270f08e4964342f8bd9aea18d41cdd3c44af4c4793592c61da20f4ee39eca8ca06c2416e9673c97f6763449af1d2b2941586bb3385d38c0acc3c066f1c2ffb3bb8c60534b684e36b83ca8e8850e63e933d8dc17796fb636ec24716301fad001a61f048cbcf3c43145aebdfc136c1136dc8ef63e99e6930cb628768d82a9cbfb39fb22df622825c5188a2e14c3bfec6cbe80a1bd7cda6415b55a2ffa4c79a4539f17f3b7e10f85391bdf2209deb340eb39799961a3a25e9a3135630bf869d8f18668db61001a9cf483a05f5479178dad16e1c8014df390400d5e44fa7340d573316df5fa1eba8e6a6f73f7ab0583a9f34e9d56c1c6f46895fa538a65761274c59854705e0a22408613aecb4b3c4852a3280a602c4ee2bc101659c9e5e7bbbd76c96810a36bf333492747749935bf6d0b20aa19c258c445148b20aa49200f269d15b4d7e659a98481249a63395f4e2ad6960be5b8bd0afa2adc09ff5bb58a372b56d6a2dc6280fe60c3d41e2734bfb976a3dece4b39e2a67c0fec53ea6f63023b2761cd8e02fa00f3622ba0f8c3e196ec6dcdcbed26140e610fe188a33f1b37b33ff8f1dac1d1c6a21cd450a52cd9b1b6f1686f18795e34a384e6d6a40973efe4d5f27f38f21161ca8b4883f0527a86fc1519a7279853f29c459030c523e078df55081307bf68ceeaaacbdde03e27d34c7a3b6cb013f5d6b51f9999af03a3906c2d36ab51af11041ac0354007bc1daf690ce7412c78da269245d2bf167cdb3aae1dccfb96a6a763533285f872995da539f850932c2e004d465a7f660dcd1704ef121e8622dfbb0d2063f4be75704aa785635285cd6483bb867989f4b28e5b0a9c9fbc47681ad2f2c921e6e1e3d8cea9f7da4d75bee3128b752f0f9879b3aa25557f7514b286f2650408008bc3171ac234bdac3c12df4b84568cc0a1978abe314abd3ae25e599974fe2127b3ad19e1d3d6769ff4334746ff70fde0069b569b1bb2a450e20558531f6e6073e12c70da65fff48c912a18abc34954eb199e53e0428f8dd0e193eb31370ff0dcfc103a6bb7e643eb31194613f02f4e6b28376b4674ee79d37474fb75983a855381750f7814bd36c26e626d60928e6d34c8a4623fd21a526379936add6f071b2a2ef9a8b0aabde4222d9c8ef9eaf852781b1d801bd441a28c33a20de7fb23263a59c8df196b79c327ef3c0b24c971f70e05564d407d838891ea8a3cfb4e0ce0474e0afd028cbb81dbe7becd18c264fd94a702f358462fdf922299518774b73680022a2cb02680370ff1a1f1a55560646d9b0c10da0526c585ad63ed08b0ad97cea359f795c26058f171b32c68d3ecc0b9fe373eee263ee19b5284081742824d583af54500c7aba585bcd603428feb46f91fb968ea577f833786094a0f600e023da1cbbb10f11c2889d14f99dca7f659b6843ab26ae84abeb3a74ca7945376e6f53006d4e953f928c0b8b4fc63cb9d375aefa3c8933a97be797f41b7388984b52cfe292d12cf261aa195bf7feeb7dfdc10a4332acae5c3be86cf62376ba28e0590c69ebb62b9a0cc2c14063f02309ee3eafecaa4c43bfdd36d0464e73be364ffb70ba509d40a278bab744a7309cfe19881687ca9ef0d23c831ed21a717170a12b2fcf5bb88bba0547454c5bf62f25cdfa73eda046307c88857a9746f856dc370ffcca0fac5650e165439157b4798abee84a320a2af1d550b2a274d77f4dbcf3f3a6463be52f27ae39f46fad31e78d583e8557286a0fc646e3df3a2862cbeff539b747b67e25ae343e7a60b980cf8f5943bd0d3db57aceb413d0c86ae0197060e7ebbb1a6bc5cb0f2a09a4b08df226b67ac2ecf381e024834a4a23472d7104761f9c046356340f6255bb5cf77200253e1ec7e79a1731a75f01a395743237afeade67e314dab5e16f99c86a1b2e3cd54f1c022fa7ef018c719b3ebea3fe6d5337e3e7b7836d93df8103a65f5988df0309eaf791b645334a54d7b26a693a065cdab2c0190096aaab1dc02466a100c6651a5b9d733708c4f97107df32e616534d39d9d8429b8619c92f9334e2f6701f1290796680cc06a22989241bfb3c16e53d128b264a9ec0166f90b335c72eb50866f4bd64c4d194f03d7faa42c4b816d9b3e3927d42102f581ab2733389434c0f79d2b598c6a07ad5e7830d37e8cc35588eb61ed9183be01acc6bc4fc69eef7ea8a5cab61311f5046a33754508587128b45c512bc03d8764f3cef246e892caebfc395b156d3d85095acbd55278b56beaf5815299f196eab8c143bc380b62f4198e8e3b7464a8e447010d83257cd9d0ab95161bf838b60eb0deb3f1981fbabab6a873102520b72b49ce40212ee51afbd6e9069c6e4944770d6122638960f8c99a6e07cd748f5d90a12a0d63d0ca7acc62b25f830dd0f818ea9334e2ad2c32957b8b2bca88dc4f9a487088d33367a087a334eb8771c00a6f7fcb05c6930d7040bbd55bdba8a251231179c82ad62e4b4e00fa4604fba6d4c596fc4e3f9183358967798974528fc12a6042959707808e377fd36b5a66cad617c99be63f4325ccdfcfe20fb08889cde99f45f06fd137be6cc065db241a9658276cc21a0b6dfdf1f2ea56b9bf03bf8e1d039a033f19ea63f9dba873bb4b38df77809a620c0bfd9a293921a7f93bfbbb5f6a71164f329c5b2ed0c2d469cc8b5767f82432bb3b234469b0d55adeb1bdc3a71d5dc334aebc653029ea81d771e38210e6d16ecb172b2788e7886bef202ce84d9da1e4f1194e034484c605066cc2092bcd5cf9c193316b4e41d698866f341e0ecd82c0ed22ec24b30e7dbb60ae59006835f012db6da2be9561ea44ad1b0026baa540199e3fadb891d16ee139e704724610e464b95d3ec0f8039800af9d89b31eed0df43ed041ec3136f3c0f3c2b9dfc91029ab284d218716d5acd38c55f9d9baf959c5f4616d1266008783a0d1698af87e1d8ec3149f25b76d9ca5208d4c8d63ed1b1bbdc28cde152e6b5ebecc51a78e182e50f55eb06355c7301c8d508ffd6976eab8d748183ba722e5880f22790a522c5dceead123b672c57b7921cab54fc9db0ce537ebad2b177bc6cd714738326f449922dadfda399a8700d527ad8477ec77d71c5dd56f9df54c968ac9d2332767db89e9b84a2c7155fdd9fc374556ea00e86b5e909291118f493e5f9b72408e5cdc33904e50b9c6eff321a453e21ba88c177141d0262d8b493cfe8e62832bd357a646f09c15212c2b2c047682269526cfb0bc2285908bbe78ead4f491c232c37c55abed7e5100a4938ec293f384b4a1b255312c3dab8b609f2102b591ba41388e6b55e7e6570ec92885c87de700768d0ccdea7c45b7308b00d80bd5c3ca4c30a6aeadca8eae73e92c8ea353223c96503be835637b26e46aab3d0bfcbba735ffa0358316b7ec6f6197ca3f073e98e085c9d05c40d9e67c77b9711fe2abb4ff146a2416ed755c22bff1595bac1f1a39b770049e14b5ef8dc259633b7cc2f1ac08d14305bc86559b776b234a7cc72e6dc5d4d916511619929b3916cdd3429957c7a3ec255fe6adcfeccc1e35e08898e510e656b1f4ca9612663598fd2f0b2aadb402cbd6194ad97a59534a49d7c8747ff86c91a6ddb47cc10ef15c22cf0cd7158852d0c0af49ee95ba302bbe17ae29d6dbe17a424205bc4629392ef3c76fc1dddcd376c950189b8a8bf03f5d93ab61b864410756db9dc3fef12748762f8e3660483e160df62c0e707b647f39f0e2999405731499fee2d669766780c89a33e357cba116e64fd442690d365ee016c78020b872ec8474e6e4715c2887a8f2df6d36db50f30ed5800f8198d1bf608176c34dae2eaa0ffb6bb1a12fde53427996e3711b6e588f5639c08507b0826c95c6f2e0c8de2d2a7d4ab242b7538d434442630577d5ec3c260ffa385895799d9bdd74ab7be42bc14b1b55c24dd9c26536f402a189c3324c9d3c5118f5e25db1f4efdedb241dd9e6e05d371c67ac63c68d1359de0a6b93094f483e30e4f1b6dbe41333b9ec68631479946af316975956e6615371c52a6a3a29e6fe4bc75d57c84aeec094a43182e96f174cf10f6649a98e5653f6aff729675d4d953d12aaa37a19efa50da7eeb7230918e3a57710e9aa92b1579099f87c6a7827dc048a28584643aef5e3caf57340da893ef81d15757857886d81bef820fd6f978514b800834115858fcc0b2cf7a0d958f70ff306824ca33b7f13a6a66b6f42e4a614d12ee8796c2f56358cacd9dda0ece1ae205f52aa88c6c14640cb1da683c374b5eda46382c6a949ca273a77bee0589dcfb124ad5e3d6d9f0fbb4e77fbf5ad8bcc238a225b37f58422d6a374183c9b2d862b59582192c0cf8d067dab143aa3d5e60129be9c43e0177c3d4e564cbb1736ab3c0f6de342044308a3076be1082d669100eeebd84613f816a7efd6ea3a6a366abe738ebdc226ca02908b3afc47a382228e6b9874fb87efb4a3632633ac342b2e64321a225c49d70f9808be79a7751739afc79701025fd40b016720c12823a4f3c0ebe974313620b5f633ba9a92ddb684df2c7cedfcc2f728723b8ca755cf2605362dfa9cdd9df4bf79f63645ef7807e37914a33067713e9c4d4fc4937a0d930d7749dea45954947631fff222f57a9f09177d83dd17c38679117155407d1036e3c55b58865d2aae2a4c02b8a8fe250dd9ddf3139a5ed8b9eaa6ef3873188174b56c384046b5ae680b7ec07e804e50004dadc048f5c13b14d2d6499f755679f0b7b8ad09997ece115c1657a76ac487c8fd6ed34710ebaa4df0bbbd604754bc363ffb2d73423dec1fe3422254b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
