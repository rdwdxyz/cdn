<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9dbd10befb4de21665f5b1fc3510362078aab8872729b25f549e50d37690ddaf83d278b71732e7b710e21a2d3fdada4353c31280c62dd47da7e34ac9053d2aa5729c3420c806dce2228997278ac43cec70bfd5b03406227920ad1decb98b9c37783ed705e08d1e2012229135aa16a754d0e591b398ab31e3c99696c243882cc031141406c3815c1b66ac0ecbaac96fd57a602a54bfeddcba7545c713d0dfe869d4a52a227815df7cbe8c82b5628ffb10d6e13d2f1f01996ccda9e20a0aadbae1bfbfffc216e99e7bee36d67af20ead21c9cbfbe09f64612312d4b838a3f01ef988880de2e6ee7136e537630dbb7c4ff0c7599d3143c0d54439c0bfda56f58107b558948e2d8f41acce9451caee79e34c50b7c2d8e79c504ce77714a1483565004c40b868fb7f7d3b48ef391f7c3fea4d43cbd02890abe6beeb844eb203e5d63d057a3179f2be55dbd784664cff24c3a92baba882fb9555a5e2081fefd7d2b1caaea27007206fbb8a99f41da7b2174a337592ee11136a10a03c3665aa390a012554e4431f03ab6d357994a7f7f50ff38599186ed1afe7565f7a04a0d7679b091835d4b296525102a0b2929244dbe8ad4dd4343f86109195c25f13449f14a306b632eb60cf9e61444c3846dbaf5801a74c49e110167dd2bf25bbe27d66d8b2f8cd2b4d7a0b04741a57c1478f192c66707d21504fd82c55a08ef80eea12e63206b9734f8b28e83dd8ad1abecf2c556554de3e7fadd3bb91c2ade3203baed0714188efcc6aa7a28590ff9ec535149df11ae7578d4833668267dba7c73a538321eb9cc0791f98bc562b0d95b719b6d11b51ab6238bc84902ef28db5cb24ad4b1618cab41870e4351c7ee12e6917760f8d140ba2f4e41e3e464c84f4950808537df6d337dd66119821862d7f34397371c7ba42f63460a64c2fad25f198dd894f7783bd52ff052a4af159a4aa47676f99f794a254738937a8c667300913985769acedfb20ff31cc2982aeb07f37331ec288262db160969a83253b5615127ff100a0715278a5e434430ce369957e176c93ecd5ff5f9e0688ffb4ab80e2be1122b947de9fcd7c4343465caddc9801dadec5c4fbfeea7c0ff13303ffa61e1e88d8fa17f0ee5ef4ed94e227d7ecc78287b7f7089e68489eccc066ff563678f87686b7a01a7cd7e07a1ad3b8582316ce58ae5903e5c0208d33de3e98750fe8f4dfbbbe8905a6ca66a7b0bf347970a48c64ba3007b48804c373679c574a4665c55e478054c6a37c8e28a468ee2170017fb37dc6bd387a7b35263da332e1e65463c45f32f0ecaf98a9118ac5613e26d92f6b42e6dfa4615dd3655c89a4a0d2f3568db020e8a748050fce795eb337c8af345858621b4ae4f14a28ad14b1e7f9ef95085182ab4167e566795d89d95a4dc7f5e2955cef99e524e6f56555eafb96cbbfdfaaf16702a73d8004ca264600e3c8a6ada06043276d90b4138fcacd8fed9b2049cc9040bede8d3b1573a8d494b8aaa3071fe160c45f53b10eaf1d6d0f509a99671f89999f3bb1837d4b556cf8d4bd2caa68c4cd36f76b7973d05044b0f182b73626c0a7d25de52129d75781d0143c5fea0d982b473fa9e0e530e8c48b1d2330165892e3198cd23509565f397a87196bf67cf19d9e622a82f870b92ff513e5ffacade6dab87b1f1ae1bf17d9529d09bbe65ba99bb659be42afd02e61652479aa29149ee7f03524f6250900ffe18469b7e60d85f6a40033d5f49e091ec67db5c8d1dc6d9ba8313d461aa993ff828a8abf49d569b1b165bbf8fefda2162397152fc189a864caf08a64c2b6c3dbb76bf21fc58664748e5aaeab52e89e50e821d9a39226c235fcd4d91a750661f723dd170057bc0a4f40b1ec22416922018412be980267ad4c4b85881b7fb72a25c7909860a813a60b0236ffb52585ce6d948974f81ce8297b837136d674fe9d80726adb12f18ae43040a6d32ab0ec8146270a09b3951509b241216eec08315f53a4dfbbc60d466899cc0c8b957a22e64e25c513c3438431efa9362b848004ab93a91dde8a66963be58a87141141e2be3437824c34367e7ff9ca69948c8db58d577595f9aafc8973746ff2b2bdaf562983293cfc80dda045596fcee1275d8771ba995ecac493291c3abc59728d43c5254f1bcb72ea8a82a228b176ea002d01f7e4425177174322a22f06f14b3c89585dfd1255258f5dc1b3b085eee30ddea52d3597270ca06755c607fa1c4242896cac0c35fb7b0df0e40942a3f3bc890149e574d47a0a7bb704df0baa60c79b356a00b2e34b1740a20799978e2abed86b1df18aab731c6f312bbe4fc0c800b27f1b9e0595141a805ce7db5a0bd3ba10cad1f176c3029ad7c9d4c7ae1f22298b2ee3cbcb41fd134f25e9f4258c7ec90022faec306821c753947c3db8bec2e201b8f92d063739e1d21327f8711b14dea60ca25b7da0e8aeb7fce93c919207923fddb12abe86efb055bc6e123066a4d9f0acf19c24575a5320f1e440d7cf04af5e54171702ac3f372e551e3313b2488c43d9b90857a353ae9940993ec69d8871fc120b31644608f1f2b12a76b8ddcd1e5de0a50f0ff17062dc1ecd81bae50360a74e5dc60b4100774e81cd6faefc6f7eeb04a70b10d061a9a00cc9730168c44660cd694240b725f3ed49ce3dd2502f13a80cfe285c40cf8cbaac5976ed45f24ea96c3c1dd2086226e8eedbf39a4bf1b663a6007d03b539a53630c583cd2a5bacaff4e6c6523acdf142ba1483843b0a0fb4a2dddc2cbcdd2beed5c4d76fe9ea673cba34d2843dfaf3696e40b2bf02fca465fa91c6cc7a20fa4bd2301d6e7098490cf913cf4cd23a46fdd54172ee38722331fbcf3d26a7f7d7bdbe67b0b76320a7e036e75ecb71dc8dd8713c6b41cc8b5557d2788d5328bf3f589740cc9f591bc5ee643cd1359c556e7b82541556b83605dba32aa208ae34adc786ad3b8d21edb3750f2f32eadc1e5147a52b6cef8a1f24051990095b5e29470562a4defeed5d50a4e1e4191c6d2fdf3b82844546897d568c9e67254593c142028fbfd1925891ceb04748a16f22ccd6158c44043b0568b36f738af9f4fe4f49923d53d6477dd6ab41bddabc0ab3e7f082ff73e1b7d3070e797ec766e050e7c250e4778536a912205f05d835e6470ce2398706eef8b48f4501cfdc47833bfd023b9e6f4f9f83b92bb301ca887bfffb9e9687f280dd5f4c72bbd262d4eb2bfce7452123376c119d97ca9bc5ed1d1a96f63b68633a9e89374799e602dd8f85c6dca6d4ea19eae9e9185ba75bdcad9e548220d21cf7189a13016c6264e9746d1dea9e10bf9d2600334e2cad06979f6d0878d4b119d74559839ae08a11667d6bcfb7e570262ca964c3d046fe09a15461579d4f56fa00f288dd235600d34030e0f94d6aa8ace868616a6965df646623bb311cb30841eb3fee907bb40e1313140f5663b2dd43ab3b4ede56e435a7d19b30fb91863dac3e250d064fafe1e4b67c14729f92bcd12a486bab8879e0d4742bd7930df1d4ed11327bd9327d89593b14f550506a87e45bcbccd23deded579c29849cd2e2587d2e8578a70405fe60d9e6046716e5646f1364eba98060bd99f7be6f9f3196ebfdaa9343fb67b0b7d81f3c60aa9032c632b674dd8c53ecfb8081b572178fae2916a86049331b4be2fc7a20b913edb107d18f614e57bcf5dc55f69d9fafc594462815f0209776c5bf4b809312af8143b98c085a2b3a64c5fb50d7aa0c4aedb393e441b43076351e79810633ce16d4d6a4a2f6fd27758b9b5bc35f2183f42d0451e1049b8fcd63615877e21555afd4db2777e141e350a5cf8306c8c6c13fa949be629d4671be4f6bee757181a83c963d426ea8df73a346d35dc416770afb21dce40ff0f8c2dfa54d91eb7d776535be9528108e9d06dd4c09b7f1edb61bd64ebd50d0df0d69c4c112d4b76cf23e22a0a52067d6754f9e57a5a7208763bf05a5a66eaa4dc267d8baa3080411459362ccefcd1e6c6c83a7e4dc61ef3293f7f08129f9fcd579aab5308fd31779b9c49255dd7ca29feb919d91b83dc124d9923b2959a129c89424eb5640d40d3a2f0a6ceb41a05f124ff27671325df6f76231e447b06f145c600d10bfd8e86aa3bee918549adb015d4f3b988f98872bb8cbe19269f017e0b1a28c7835c500b59f894f6b5517312265f803db6a2d27367d4c693ea1cf6ab50aa35a626b945e1ba2e84187afc8209bcc37bd4ad0a1fe460dff12cc25fa224e054f02ec51c65b777ab26a719bcd5c04eecc9ea6d98acdd5b67c840795b9b122c9a04b9640d4867ef3428594563daba5dc60dccc8817e29d9cf95d14c85fab3411bbdd9262962c31bc8fc3622799c4238dd12dc50be63b359c2fd1e6106083cb4499097afb948cce87e66649a450d51df46936c6e75df750590d1a73fdc8d5b5d59d78900320049cd54a3bb3907027499158e57e858e2cd3694159bb23de04af21f010c0a092566664fe26a4cd04a42079ade8ee472dcc965ed38aa59617c2e23c5e4a6c140ba30bd9e43c4abe2daf4e04ddb22268a8b0dc586ad467f40db271af5b4817230cea090ce6636abe30b5b4b5f9371e1184b6c3f83b5458156a5446ec727855147f5e1fb00a95635348ee0de14db9990088ed822f1c4a38161936ab4a53fa8ca9f0f14f82fcbcc0d1e0738fb976cdad2f668be7553305c583aefc9f308893cbc207e9615b997c3b6964a674e549f09097b4fc6c3420d419eb8b07a0a9755b463f5bb9ec6043f3caa81e6d4b8950dc10578f5809800157bc7aae03e9a007b86670b72d0eef9787b16e6d693e18a5196114463854ba9fc9099ec107270862cefd73d326beb3ff41d8538a0c36a75b2fd77779f14daf1f20c6d03ba629306fe005b58c4d887c037c9f703055654d04b14fdc51ab46deeceafee7695fdd876eba5a77361970ff5554e8ad6ec824d834ec92a30ee3285ce62dde340fab70daec3dfe7b861281e3de3ec14179c139829bdd92fbafdc8b95dfb1dca7ec261cb660928facea0054e0f87a3f711abd92f02613389da42793166d214eb61c8ad44b5e74350ce8c1193e07e2e20cfa6db9b93113d491f7b8f2f818e28d2b639b88c23dd8519344245e2bc920e5601f12d61606059c5662fbd98619ca754d88e0d2bd483d42894682fdc5e8c23f8df851046c9331db9bf2045e0fb1b77cffb71985dd19ef8d6c93f1fe6a5577ebf1c1a18174faee225a8a301cd5361978f065c997bf705846ea4abe81e1c7be60fafffe90a8026c5e85821fccdd8a3e7091ab6dd17a365edb62d456798c00ccbee016df7467b45e8e634c6ebf77d90244e80f6d8ec68bb8372152488c35941f796b9395c40b56698c16822562a00d7b39ab2c20baa88f0d9360e46128a9927252b5ae04e9ec42d1f554a947e700c998857b4ec389cab0f09d67c151f7b0cdcac35727a45ddbcc7e120a616fcab330f2148c45273fda7a8ccc37429f0b722d7f12a3a9394959aaa63ca4520841050de126dcf1196e880ec5af27eddef4c9df0b8cd111124ae8f3656e3dd01f2432075cf2476ff8fcf6ab19ec94823521e20e6006974b939736a2a59ebf7b3c8c9486b8e0fedd0991a112897e10da32833d91f362da3a8a52deda1bfa434c4c779a4dbbabd39ebb588c4b714becbe555cd403da6a2d3efcc135af467dc1f2bb8402ee7bdac636ed2af62e53eae651d33296a799134b03ed18962df68c2c536ae239953ac92c826f3e717b128635708249210bbbafa3c16300dc92ba4a05a22e56fba51eb23eaf9af9d645dfd37f1d43d5fe25b45b46c17b669cbd44541503f45827b798de87a90c7a9896549dc8670f9f35db54a0ebf1f64707c1064c97273621cc69cd12480d0512898a8c771d06147c7ff436084aee6e23321b3495c8d25a2f800f731b2f10035d3e6d09fcf545be0563055e60cfff1bab6c84c9f0c9570dd2c660881699564fde789bdc6b20f498428c5acd727451f61336d67bf7d4178642aed5175b33d6acf12ac14fba3e7faee40153e248c6ef0d7a66cbad42a5c455fa2aeb527fa720e8b1f41de9f4575909d92b3546aa6be7046115b2ff61cb5cdf3d227b3500d05c05a5d6567cfa9254adf815c304cd825228b36ceed5d55cdae37a59bcef81226a504aac367afb11fcf969f00db780dabab69f2a8804222d2c6cd24be46ea740eb29d218e76a9169ba540d958b49a2ead1c5d9fdee88e13561d946adfb9aa8ca5f9d209b6056e9fd503c6312732248de397dba1aa4740f01f9c14d8f8f0f601891adc0432af6cc72a5fe72c533042b776a9775b2495551fa2aca286826538523a95406e2908ec551414ce3470a0df9a677f74d078dc1abd5743673d08dffbc577981006bf8ea38995ed5beba15dc6419d4a11e8bb4401d967d08528f65d2f2b6833843f32cac4f2eda7655d9fae46de5911abba606524052ad94696da0dafb210c8429240ad16789d5e51e7810e36827ff7a0ebf5bc2f83cc14b665f5435a850d48236d03c2301f9d0eeb759fa254c024445657f647a20758235a77b1536ce2ba05fac09076eee10042c5bab130bf6337de9a9146cea195bad20fc36d5de59923207a4901aa3363a15a0d71d866586bd538f9a6b085181d1a6153864b856d2e561465d3a075657e96c4a9d14682cd2e7f55b48578449f09d1d0de0ba476f0a30a036b4bf51e3e6217a3c8cdc1b9061672ca69da628d07f6693ac646efeb5196002bd8b7feb0f84f8b8d537f87d6d0909f6112f9165d8a09c94a50fbddce0afdafe3acbf01c593ee8002253ac5eed63c50fa126436e6a42b20480a0a88026c09651bbc50cf546f64dbf0b2906c77e803684f35a938982cb50bc3cebf91da04a587e50dd561ca6ff6dae92582ada16e6b34d56f538320799e09c8abecb397cdc62269d5371689bcb81f9d25120a948c966e495fe4a3098c11c0c33c12ccbd78dabb65c63dae23b985c3532589f693dd136c7edec7974dc8f5f80536088bf91a7d0735a6a5fabffa572a9a5634469430b677f5fdf5e566072535445e91d524c1dbcf15422d14f639ae2ad5c6ca9091cc7d5701b5eace9be13c42380467375cc2bb3e20d4d0a59a373f76030345c261347bd79d06c0c98f5063e6128c6b6c2b03fc91a22fcf2103dfcb93d8c260db93f84fa1d52dee93a20b178ea9542a4a7ef56fd7546fd0ae49e50dbac95885c5e0d734f041a466534d2eb2d8e5a4542928fcc465e54f0c5660e168ef8b923136d0375ad61efb472a22f57bcb1814f3d687a247c0631101041edd7763e8f6e8dde7ac6020a0643e54f34090af791615651947724948e87f826a72200d31342a494f97e17fab175f3d7292769801d07678e4f0066a88b223fea0c6ae840ce261a5a4a63846cb1aef99434571fd137f50e1010fdc9c82069826ceec7c7a34e4d5b10ec9a64b1aa4d3e37687f06a1c49920eb226c245beb9bca97015eececa812b2a9b9d5cf28985e98aeb8b0e76496bfae0c87682d89e221a7ec4d0b40936f65127c2f2cfae30121ffd35e45f6a9692d81726d37d32dc77af4b7726c4f54873910bcf601e10ed2606650907af405c0834ec5901794daae79dfa27fde3c961921fcc300a41a23ecc633c1356f712530e2f2882a3698893c4e7d453ebd23e24c2ab07e5ad60daa71ad9fa6e78dcd56969d5c7812f5818633738b6bd807c4ac88e2de9192e33c3400cdd2065b14549d66883090ccd46d3455e041b4d6c25d73fe87fd43771c5d6591d24c06feb05f725f6b5750341afbb35fda80f4c673c0428364ef354587d7f5e4924fbd72da69eb92963032ec0d3dfe8191d084a9e41942ea456cb45910a1a263ab08bd3cad18c57fc06c76ec116a522cec4156ed53bb7c8b51e050b523fb1e89d867c0e39eea92875f4e1fa62f0c7f31f251dad4cd011536b5900bab14d1d390219f3453e2382dfd4435cd620a16f7d0d4b684fa8a5ca14b0fcaacd67a3feaf66c7cb976a3f027877b898f7a0048640497619748de0fdc28dc1b25b6f8c50f1c1afb35d188eff26fcdcadcd89c9f73ae5ba7e1895629acf8df0088ff5f5e5e3dc3caa589676dfbc6c664d3490f0a2264b904692705eec985ecb341498c6c55f77f35235e7257a8280865a9324fbbc8c5ddeb3decb23fb9fbdf430a5f38de30f17fd5dbe7529eef9c8613d293340943f94a747735aa1cdb8360c2bb64e33b14278aa098d3e193a7f80e139bf5be3eccabde87bac41f3eb68671a0117f514d2b506ff936ff873e4f56662f62ecb9385de72d6aec6eeff4e248eb33e84478d0d831db355c95a13f23d2326c2ae55298a2300403db1694d85430ce37cbd523fa7c7f152cb58be2c6fa93e57ac777399645e29cb0b4c8068362c7c11fa208d061f0a0f0621bdf5e8bcb54622c7056cb57d04bc7b4e873c35c48a14078291fe3485326fdb25db32395095499e82ab8aad362669ab399289a800e4f63d3b5d7766bcc6f541fd3cfa306efd66891228dffb2114735059ff05a2cb807f24d8a86ca94635b98c5c56d819ed3995d3a4ead03cf2d039b7d87061568d257ddec02d56cd683d4d0b0c478519e977d96b8aa8f63c00b280a71520dd73e3f2271f2312832b9321a5cca0f37ccad1290201564e87002430f24668460d53855ec3c5db192a93ae53e49c32c1a7a97f54474be7c81b15ae3a14faa8ed3896e94be5f31929b6265c23a23592a9f18bb49f50940c3f73a38dbe0c69c163e7a6e7778ee0540177b8afabf730d06a026ea15a9ff5a09a9ceeb14b7923ced95492fe500a0ff98368d971ad98d4e1f28f666c4e22146b1f005614bbcb9c1d3634f0aa771878759a046d5101f5cf0aa56b94d5c9a470ea7657c42b1432f96eb76720fb28f339c0e24edbf03d32bc27c64c1be19e8d93738121223b13f616e50f1b2ba79c6c022d1333a5255ab830dd9cd6e8cea3cb35709603c6d3f0ed139366505607fc98a110396a9be7310d5e91390f96a82690e8c47e5f7556fc98379615e8a79aaefb3ac7d3fa7c906257316a37efc6f632cb8305639841261c766e2f5891d2b0d55587740653e61032eb9a2133389e71b0a8b2a8f21d579af54e4d10cb563cff16ecac7c54fabcb9b762e0f59d64206eec10f354747f7393dca5f14e237239bbdbb5cd9aa1e671cd8dd00c67feb821cf91147da7e3f80126371557f3304b7cee88bfb85da0b7ee83aeb4141f6cabbda617ba74199884e6596ff634075254638e5208d1ab21e3e348f2f47815f10e322ee804834140fd8226d54b6d7041d70409b27936d9bf95c94fe3dffa813bea8e8f0a7d566bcd678979a4b8b44385972bdfc0d053f6f4c910c4b5e3adae176862b46574d05a33737a9ca80310eeda33471fbf80b4a07f53927f4b11d74d096c6a8a5f19bc8b73311fc63afb33780f6ec8ab9bb80a960c5121d8c417890c92ea12d7d78bd7acc069a7425c5b208bb8bc5178c5fc4b2582639d7606742276531cf26c66255e38431ff25e745b8bd180393ea13cc3d31258344d4870495777874fe01d20d546d7492dda2662ce890ecb538c99c8bd5a6dbbf3f06079782519dcecd1ad09a389a9ad72ff81aa2b7ee679e13fe75ead37f4c0b14b02f0053a6b86d52d68acb55d1bd74eb498bbfe86917e4ca0e8f8966ad25a9cbba7a19db0e5cb03dddabcba19ac659ee1ff662fe2c4b8195722ea52843f289240a20c094e0d7c46637fdead71bfa8dfc2376720375c11bd4fc457a64ac8320f7898bcfd84784d99696aa9225f4ef3b3c43768475e877614b255c3396f429e6c463c1169ddf0a13d2ec291d5ee42930784c024e6bad08bc1ad9ee22e5d204fbbf6c8ebd2a65a43c3ef37db3f9d7d40310d5814324a118328a2bea12e56f1767d2c952b1ca455119e347b8b2c073f421d9c1d8196ec1757a21c7587844c6bc50e1e0356eb315b2b040d18c7a8c5c87f5991e313bd627da8500afc39a9969b8f6cb0cc18d5a6a61b6beda06c5bab9b69462c213f04163c43d7f34cc4f7d69f5197bfd0289d59a27a37e689e7fc77900a8fb9466491aeadb55f5a4e2d86192caa782719c160f90cfbdbc1accc410647eeafd3c3ceece7f16c5fd0ac541697c0459ef84a7dc0edc17d5fd783b8142c6d7d28271cb121073545dc0d402e743b8ec07c28700944c14b06ffdbd8310b012ff79a2718b40999437e89225f153046b351203ce080712c24fb143566a30afdb984f48ec1033031134f68ba9354932920dc76e077c72348f2d7afd16ae28c39ee4b42f91cecf0a23092a62fe6e00ee84cbc8a4616cc45c4fb36a1f0ce4e07313603024df45dbb1a20f8ec1fd99868291ea5b5e90e554bf22367f242192311fbecea58234dba39aad03e940dd7bbea64fc4d5c6459ad9f3705442015c6249833bb763f5c62dfb694d2ec721d889789b29d9e1af836cae4cab1bd71402974531179f025ffd32d1a51e38130b8d10c4c4a822d35cc8c48d93da18b6d89b06384632d1f5d7eaa3f3e356c0d5774e8567e7b037c3de59133b5ff791cc713768ff1619e5bc37c222e6cac3854b08ee8de1d033b50ad540ba8876ff7f6cf14a0b0119486c8697bfefc949bb9f66ec2a3c345682dd7fd4b0cc14ce8bdd406bb068d568569125c90acdd235f9114d8654780cf1a5242da7016272347980612c39bd297e35b75ff6269f7fcbb0f45eb9c1a3dcfe40ef45b5f77410cf4abb996228262ab2f57fa3c227b459466cdce064ccb01b699f6057bc93ad6cd574c037bcc399aec99b46c8c47176393b58146d9cd76c292a9a347447137cc21f662d1f46edcee5d277561a41317d75909fbab6062f32f75d47138c8b14b71e5b7c3da6127ab994daf2306c1a7080d155e2e40dd1ff7b23b7c4bdd1a7073ec983feaaf0313bd763c77e8b16225ef09985b7000beb8ece551139d65cf3566bb81f7c0799b41ef6bb8ee443f6acc470ebbe1122b187552a007b833b314c89a2fd0e060dc1eaf33cd66b6a11f0ad98109517ac0412cd9870ded56346cba0562b28502577e3803b523fc82c1f5b775d68bcbb7af23cd6c8d2a687b45cf8f4d8d52a8113b12b293687aa9b633bceb667a9d26d7fac512e45b1a326e5f6605c302df5fb596b9f8726cb78512b38c1c8ce0e81f57ccab818302d2f9d5e181ab67f9175ebc3f70cde72da81d23362744eab9e9229eb27ecf352ac13cd3a8d7d2240c82c5b6af186e3fbd8d13ff55f0cd1ebd8c3601be9b1542f3c9a2b3c73986b2f2c9ac0516d629709e7ad9a6e209117ca40681ab37fe9474bb0cbaf00c2bc090dca87c43b563af6ad5ce15fc8764a1eca0f45cc74c233b343aa78340c0babe6379ec4fb4814551720fbfce619370ff6e335fa54629f3c592bab9fb2f14f50de2bb07fe69bf64fdd3d886741868445279829612bb895e2a899e1e210cffe179e0f21bcffca5d26cab4ecd86126b62ec26feef8db27ea9ee4e42a291b7535f005eab5c661cb89f90d6f4aa4955775dd462ce3895cc7b877a134b0340b253013c313ba0caa3c6662cd4802049b57df9ea5ef7bcb8898d14a7fa6fd4f647428f95e2a924b57a4fee5053e9b22da6903020d5b4684aa6e2f7dd695a538e851d827adcf94c5ea1521077599d93ca3406e4e23acab4ea51e2f11c7a8973ec9cc0310a49d7f8498f2f7af639b6a6459f684ff0dca74a601e5afef1dd086c95140fc0fe11504fe1eb1bd9b45c2d5a5ff0b1388612c17a14007bbe3d12799f543705dae4ff1cb0b52e616c4b7af35d00197979eb5ac145b68ba3bf7c6cd339b3de137074ed88c989a3da196851e72710c4c948890d78639e1ae7d54c102c7d0f6f4c5d2e741d4f9609e29434d641171b38be08f5a3a8a63bc163c7823cfc89eb7c778e2b7ca29a0a2be4f2d9d87c511d2d56279d23372568abc8955ff75df5a3b7e4a32a7263b5c787ff432faa2eb1dea5889cb8347beaca2bc56ff69d1a5c99716194ab8a7e3f5cffe330fb37ce75e9ab743b3a9a5ec71c4dfc311f4ac08c09ea98dbc2974f7de1da45d10e122c70e139ce345d8a88e96c73b9d873d792bcbbeae26ec4bcd82d60c9e9042c6dda3f4c4a1010b2ec45d3c6941acd1aee31388d9c0931eedac0d446714b58d777a37480135ebe2444a3fc595331b65f52c882ca0a0edcabd8a952f23b8efe0ccb040241b506feb544270d8f9057eb1a4e5fe8f49d8e39cc343ff8ec65d7ec9f1cb4096d8ef01dc5ffe4227c250707c431b55deeab49f26c7a2f87768bd2343d8965a3505ad479a84877b945122e2256893a1ccdac7db43ece633e645d9be05ab2f2582362d71cb8af16a924bc138341656e824246bd51e112d4085a51a68a3bb6e25896f4da12b7e0d5a56dd9009401bd54b168b4507234fdd98b7f0703511472f75876c98dcf7c126509378f212a508089363f2ef33e235ea06341c068106e23b50adb44cda2955d9d56b0b4d490875dccaf46cc040d4fc593c8e97911f239ea2765a3d3442d64fc467ddc1c1f0d1f0ba7be34e2abbe51947bb0624e4bd6a79b68fcba932b0d766f5beeff2eac2545c2ce83527641a7ca76f13e79f3ed37a2df8d9c33b214192f5ec6d120d64ec1adb9eaf6101088488e0fffac68f42ec6ade619bcb56a49e2a355035b6f799117927f23f5b04bed7fbf5d0f501e85d09db486d0b982ae379b91139e0bd0a9d7fac2a75b71cdce24422ef419176516e8204b7cbf99ebe25457a10e424b1f53f6a32469707aa96a442c619bfd1fe0f6c743e4a88ee07c6f3abd6b02ac07f11178ebde97e70697f4c11f1282c2260cb802e3ed5db0d14bf6af0506bc8abdea032f8b8ca8b1862186d73a18500a519a148f143f3529966116bdf75976cc52ce480b836b7e3bb0d08e2260680096b7b94f47fdcf4f2c57d6a69e43667673d8f10dab88cffbcd1bebc2576c28a6a807b8233487e21f475647b89d9150c4c4ea1f27f650ad6ee9ba8c8e6c9e69e5a3a4c6c15a640f7a7993a2859e092c70a5c74f40c7e09bad58563463c25ae4056fd2a54a248a8f3e60ebd88b7b99b029cf86df44a5344f1bc885af981408e453d28601e6b69280ae3cc25f41b2bd852aeb529f17a646e2fc48d0ba3cfd9bd73dff6c0d3222fcff71a5e0919845286f3d36afd998ad3b83147d31746c70972adf0c1b7f904b8137e78f9b60feb92e1da048599854082a7b2093e8251bb4dd349eff45ce515c472372f2faed84685340b120422122c3fe9767130900732c93972f0848f0d5771bf54ae67f674eb57cfd339c80fe3b262a7445cbc77a5649da8048cca46c02c9ef508a58cd69f0b565f78f2fa92ed9c2cd96fbf34a00ee0f2c42d37cddd4661421caea55365dc861c42bc75b92982f67dfa2beca8ab4ae33c5bf7616c641ec18677c58f375b3335567e6decb020cd43735c0fbf8a90967aeab74d33f5a93f814d2d26b7151b0e2d5d7d2b7264c3b3014a8460c40d16ef5a3d5f5d3ab4a49ffc999fc5417008da262771b1b0dd6db0df8db550388dcdbb38ad18cbbac37e25d0b52b4a3824c3850eaf445069e0b0e3b2ca25d1ef4e293eed99554f90817b8d9d375f96d0f8d46f8e267f6dd78940fab465cabec776248ade550686a72edcd55903da3a769edb76041fddc3959052effa178b29e5d2175f7cee556902bee782e490413dd927a75fead35477c7c7cbcd2bf885dcccd8efac7bf74b90e2497d43f972e68217fd41d18d5fbd81333b690bd9bd3bf6769f35a3fb7a01ce9d4c54751c5b1ba3e7ea497bb0c376d0480a0a308320a3942d5b2d679eca14115c691b2382d3006aad20a165c745f2b07a202a4a9477cc3bfb4b4d6be2d1a671dbbc837f2339e61b37d031535c44769bce7d162617114b87276c51fcae8d107f31acb5078dec1551658a5148fb6bab84fd91aeb0fa92bd6a9952aee901f34667dd59400aa629d7a955373c911293baddf6ccdc97e9357e2ff2e286e9b764a6a87ad7e9f5001977c6daf0dcf0ace9a1d3adcf3647a9866f7d31b284b9ae7dbe69fad1ff73eeaf25048706493fc4541bd6d1c24b9b4e715322f68089e9be22f65958207d5210608b0e6fa3e87e9549e0a6af7e8cd4cc75a6de6fb5a9b9bcc3adafd51ec8e6ad684533ed3378dfa833b3a282c9817aefaa04b7d590121d7dd77fc861ce1962834c9cc18fa9c455d5766219d8458ee66321d1e350968af18f63cf4b3ec2e59c2242dedbe8668be159036005e4ef5e2e1dce375b4a8964d4f401dd6453b7868826335bda98c86603120a528a34f0634de7372071d6cdc754c460f0b8809ced9561d1fffea2c776a65717d3051a3bc5bf5e49efe818006cd9d035efed0169ecc6ef5b6f130221e2ee7dd168fcee12a405d832c694c34647a811d1351f4a694aa05a64acf214e7089709586827c84648ccd7c9fab70a13ab5b814a11a5e467de4d088baa2274277912a6faa991fef76912571f2456e283c825eee56a5e8cc4952be2ad8b48e82a688512bdfa7cc2fc39289dd1f6fe15a85eb72497752ade1ce53ce63147b18314110762fbad512be39d69b315b4aaa3c5980b5930eae58264eb9161d6ecee94dfe4678e2a8f9bb3943bbfdf290ce9dfceae548e42e7c10ab426539b8a75455ad4d999e3e198afabe692949ed3e08239caa94ed82d4b8b4b36488a2b0c041d453bbaf031921b1b9d683a0b56ea904741d11a6915f6d02172016f39c52b508adb0799819c3a222c602b045fee10bf9d46ce5b24be9fba36161e4ff4d04354470cfe18db06be6df019ed7ab1324babc41e8b517e2648084c9314d73c48652dd50c077b9c40934b1a2eb9f76be15cc64955ed82b02e6585e4cb0b8f7f3a13177e1e027baf20b59fdec8dc0e84bea418012fddbcf148497ad45dcd89fe9030807e684203995747cfcb68264286eb71353e74f23e9413c7f28a9247555d026f0d27552d5ea1186418cbc96e6ad8222e87c6171609724f192dd775e47937103d87a84462c38111295ebaf7057b4cf39cef6c5339d806f8d63cbf7bfc980a16ec436e9ff5cb0d936f8d9820dd63d8ae538b865822b018e703771384a7a5d9f2e4c029a554d2b1f9b455d50708feb34fafebbff47ec22b25d217f576dc3620b7b26b7d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
