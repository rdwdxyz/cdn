<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"97111deba21f9d66afa134ded98be69617729aa82663bd56a98a9ee67ee31b407afe74bc28aeb33c023c58a606db15a26a96512bdb733ff29c6d215a97bbdcfd88962351f1c28e64fd29055152c9893617d8cbe0c03fd532e94e6986eae60dfaf916970f9150f2b4e6ba095adfda6ab8ff4b7e9dd0d4bc59d4da3ae999d09ac45a7d947e86ffe5bef70937a76b6e7e4eee343a9403bf851a1b9bc1ba7304c13da304c49f9a2d2253d91d1e3d6e0c72d1d1d23ddb7b1ee9f915d620c469d436650c7ae7f1f3c2bad5eb3e9a97434543c9b3ffdce62f9130ae6758ad2764079e0320d7785a5ceae1f8ff49910547abbd30789f4410842e7451f0cfd4551e5437969294a5d4470ee970e91162210f75c1a26ac8e94a8830f804282accdd16a6e7c2b1fe7ea87977cc44e9947066b8c0ab2fecd80d2f093e904856393bda24c5cc2668da419cb2a41a5eb449fea48ed3ab376595ae57e91b55f5bb903b2bdaf94b10bb753b5d111c5f7df6161990177281de6b65e2a89aba6cb2c781ecf34fa0e400b7fbad5b49882dd3189511e20845b6e18be6bd1857a2871571bec9989f759bb29817d4b47bc8fe9826cabe46fc9bdb136b9d25722fed089adf6151ea45e4eb284ca33717ca9d04dfe9c0965fd72099a9c5f206913a2bf3fd65d80dcf55cb80b8c6158b62e84c0e9f8a5b5f8f85a49c52e98787687f113474021fa3c0aaa321403b9c6b1178fcae9b27d775520d174b194d17906b9d494352632e58dfc9750b499d415ad3ee97b589dd6032914a6a5681d17281213dfe699a47459d489bab9b51ecdcfdf8949b0f006bfbf8cf17b958c6aad7825212d6381a27537703e54a9e443b5fcb2be618334bf0be509bc06aaff7db970d0acd76dd84e04d3fd6f0d2d01e21b98dfa0420403d1860037b35616ea8878b5d7c19f6e6629065e3d369855cefa62fe0d71c66c3b674e8e83fdf1b879aae3b07ad67d0a8e9ad071a24ae87251ed46fcf1753478517b3268dd351db6e5c2485d42510e36709b70c53386f3de8b0acc58165789ef3ac25259c8eaf95942aec79799340af7673d1ff59b54dc4ee503e8797bd45f468fe08ce60054f9e3cf4df173fce3ea44117be9bbf27aaf4988a1b2dd965c5521da0dc79c180682ff75aefb5d14f480c1618e72507d9fedefd16fe319e8233d0229cda521f71ab8002bf92be7fef314cca28d20ab317d339665076674dd06d737ff9f0d2785d0d71d6d4882958fca126d8195f28a378ce2dfbabc3636ad7e1eaf588533e1e74037c1066599f6bc1470abf15210a5f80fb687f535dbab2fd07beb7d200955cf3b820aa22c246fe0e8c0715b8755a29cc905aaf254e44d044cb6189ded21bd1e17698ea933e19433da012ac77dbb48675c5440376577942b7e06e873222bf08fdefe0ad5c5f7418b088496a72aa101967ca42b5606591c9321c1a690538c35086a87d1ce476a20008d0967297c6c2d72655b896f02093eaf1276e6410cdd99951e65f76c84854918384aed27bba0338f0fd02d40e243bd296c84cd03ca9bdc03d7bd57b6840bb6011da6257a083eea9b6cab0f48f6c4dc3dbc6b1e830561b39b40e8c45be86fbf0d66d495d0650d833a77acd6530dfbd74385fb193354d1270855459e57816845bef7faa1b5a6150a31d19be2a7f160bd1e3be8f6a4366651807b22877597c824906324e165b0dd214a64f5b5e44b81e67bd50c2e39f4f76cdc9bee5c08e2e6fce827a64c9941c36dd9386d63f58d067b5f9625d369546bcb019c02437be2b3530ff973f231219133b0804e2db131a6288c227f4e0a10e4454df887ddb3bec2c8a71db279d332aaa0d4f5848958ece598f0b761c072cce9a3ef4a98071ac0e760cbc1e1dd8a15707f70c46f0d15073d4f44454e8b6e6aa5c4a60eb74b5bcb84403a0670085380fd690e66180912c848f01c6ce999b1372f0bd286804246f4712a363526f66780880afc6a14be7f607d545ee14052ca129319239d79409d64efc4231f7373a5b7234092d868b4b8324e78c221d3a983d9e287f1476c3ee665a366f0036efa5d2e053ca30f88cad940ec5d83eba69829124afd0a7b8a94392ef38e679e40a8f9467c72f2d55a7fc59dce27a2d90d164f5ce02b05dafc869d75e630c41db62451eb65443828d835643ad9f5c1b90534e0c142a1c7bcfc7600c71134db1df0123172cc3af3a90af3392585340d420e8dd93513011080d8470c1727f4b4be31552934ec2f8507f72bc340df10fd7c2a3e45e6a70aaf471e585a32164dbdffc4af7b6886f639d52b76838398fcda5f8e8451ee70d2bd136dbe73661232f47872a71657bb59e391ce23dbd07b9f2d179bbda572fe716860722e2bef370bed41ae9563eaac5b3f83daf390c413fc2a4dca7f0c1dd3ec4b750a793e5c4a23dfbd150442b13b9bb620d55409cbc40f58c10580bbaf0ec38c042431eb55dec7fa7735109c7860f5e43dd57c4db4570567ede993a66f32e9feae1aa172f0bbe30b1a1a937fcd2e85fc2ebb8f3995b5f0751bf5d173a6824662a7c5e37e65568b1b6d390e08ec93e430f3aa1d978752a128278a1e2d634c8d21eeb3c3cddc8b5ba8909dd3bfeaf8cf521e4b61ebb5a3c9f2a5033dffe99c791ca516a736c39084ba8ee0af0fb47572148f9a0d098f25fd074c82450e04f9731d337f2cf9be57ee2184300d155699c9a0621cce458358b6e2718b6004131434e14f58e909ca4e82d61e21e4f85cc987184ada25162d1a1be0817572ae260113f8ce727712b32a891145021c8f33bf173b97fdf0467860e47d5f2d1c2d9e3bcc1c9e5983ecc7dcdb20aa6531d8f25ffce9492bf1e2e6adab4c7df160594d3bed1c94292a213337a9dae803c264377031e4815f3d3d1816a75208b16244a6045f91fe12fd34d80db544af95ad28f6d3fba546a9fb09908ee6ada9859333b17c7334ed496634569d8b142e186819cbd5a508ae45d77ce8366b9574ed4695b0018db39fad4f0bf22643de479de036f7a4ec9eaf7484170d55a0e185f6e103ad5a750783d5e6071ce34e8e17722c33a0648fbe2526e5cc2ff585ad494d6ea0c2ba77f446f858c4a3ccc536a369235dab9742c358d3e82632a59acaa537559b7afe83e2a781faacdf600a6ef78bdbb31f060b9aa1fd5eb34500983f8aae2b0d9b39c1c962ea92633798b446c56fd230063650db764b3f75a53e278a632bc53b89afd0e032814c857fb20be6a5b5615db5f96a4271af672043337590041d9dc87a1f2e3de2589e8e577c38e090ad92c1e64680adb970b95a5412ef6feb298932d16b9c9ffb33b14eb0ec53f7b36879e48dbbaa84d83aff1d2cfd78743b9d43b89d3cf9c42ea8c55c7ff1f23121b1ae3bf303f660eaa477ed27694287abdc5611de770e3c94333aac6b0af5aadf37425312e70e9b467f38d63fa168a672fe2dfadb4732500e07944a84bc5148594ddf904e885953d80c7e035d828de7fdacabb4d719b34e49df755e9a890d14e227355e53d2e7bbef1490622326b54674de58f495f6331df3065e99633cde019705f414ce1b4fa0397579b9d954c897ddb31b696301b611bd67151d041a02991e27eae542cead86002bb1fa60dafc14db6d58abac1861f2c3f38d143ccdcf47b1f6c33cb2e251763daef8233276aa1b045c011b73eb5c6c2b9fc17e3a8c692ce5cf69e2623a40aec0023c637556aad748fc1690b90a2d12194e165088d85423463a42284491536c53bcf91e87bc382c247e3f9e3ccd9793741ac3ce60d921d7f0768c75391c0b98fa1005af6c2a4aefaad6466841acce3aab8b4edb24413ac09cd9598660c53ed5f5c8754f5cdf531164801489a97ad77d443ec24aa44532f4934610ada95d4431c4d8d06bcaad04044abcfa9e77a25591d094a13155f13f29513dc352e502b2e4a419db8a3eb51600ad1b5a19d1fb2343d88e54194705e3a87b19288efe0e22903bacc75a37b66e64f2d1f6b92a6fa9afe7848009e9db8891b658ce399c98368bb529888fd2b74769c8ab3a637656415bcdecea9bc993473968607a75300a52af177c095e99fa19f34c33cb06a4fc10721fb38995eaccd93bf8450f2b04d58820255c7e3a832ecef48233dfd298c7bddb6fb11e75b25d660419bd0825a6d249aec0d543732dcb203afc081e9cd22d35cc97fbde96a353d6accd10d76f3089075283617792d6458861d0501ae7312194c705239be3229ac9b439b14f25ceab659be7fad03d12ed85b69098561ebdb9d36687853b27272bc1dd8dbcdb276f8665e1cb319136dd6225608296fe315f9ee7420d59cc3dd0043d2eb64eefbd633eaa201b4b55406331920f510971d1bdaff9fc3718bfef56ca091caa84917cb89861434c1b0f300b850f824f9bee74ec1656f7a4773a5cd670beb122f48de964c20a72decbd3a211031e9ee642c1221a60fac07afe43bfb4a1ee3a88e4e3b2ae79fba41caffe1074bdbc00298f53b56d0d18ed2b227e48c395819acd49419ee9445830999c914adf4c6aefc4abf418d2c47cb5261bc1027d466e2eb3a54ec7f25e9770c389a521d1e6248529fe67282770fd50a3fe750b52f149bd88bd93a9a9b4d1cf2ad474bc541970ae7fb7a10d11f2bbaaba2f7c96e23e8d51ed084a25b56c813bb20d42ffda471635142d9e14b7267f71129a327037a6e3847d0b970d1f874ce10f51a0a632ced5c1e086353fc7a3237f8ca1ba5506835fd5d98603a816fa21dc1c9887119a94a4764dfaeeef1dc1eb5be753571741f8a301feb43d99bc9303a77150dd5e1e37746be7e2e809cf6fc60896bd3201a3db1621769fd7f1cf7dfe96ae51672af87eac534b6be84697420c957235183290b4d5b23d5bdd30073df909172d77872d68a1d493bfa35f0ddbeeb7cca22d3ae4374be6e9c865e0345aa13d1e9b1a86f07efac03119be21ae9ed6d15d8a51862efb616174898c181265aa4dba9758c59f5fcfeb9016fbfb389d57ee4aa6e8e6f43eba2ccc782c4294e09c80f1440a50715f60d69a105fbf9a662bb6b60404da5e7e6a91664954ba50199619f7c5866ecd963f3a642f37e0f22c86f39d42a91c3d1ff32b1e87a5776b7a891e3a43e211d7f7d2d62febaad775cf18942ff0920ca022e169a8a25dd3502e388014ed133ad7ebd9f3608e987785f2f670f22141dfc574db0e63e9b69d544e036fe9f3c3785b195d1befd8638b01fd6d4b32ba9f49e804b36934698911b3807f655ec482a58b1ef5fd1c040f6f6673d6b882b885043790ad52227041b2f1e981595a18a577b38b4c25778a3af03e991d3d0fb3be3e437b8691486629063d1a39d0df6217d7b08f2daf109a013947bcf94550d7766298c3952a7a7716ca1cea7f98031e2c75aab7e8c5baf5db0bd8054aca537b67e56410ee022d31a2702f2af3186f78a6d2289455c552e727cdf08938e8b1bd170b20b61ae91ac4a8575c8ecc5b0215d6985e9c9d23821ef6e113be31d6d263f150303646bf9fa08639707f671a13068002348ea9290f980908ff4c65b4bdc7c682d6abcde678aaf3c918405cd21f69ba741cbf73a36ec740a05dcac4dfe7bfb507bc607289df47c03f131020d1200fc66ffa706eceeee395d8974c1ae025c352f18e00261da8d48247013f4142a986fe6ab8bffbef1bc5db3e96e84eb4eedcdc85d1dcdd698cf84a8be9c54e74eeda6d09a57539eddb8f40eaf6082711e3f3eb03562b7acbab657c8955a23704852b8979e298dc27df4f389fdcf1d7c592db803e57555584c2233c02f1f68f4dc4235bff6829e68e09a951c7816eb73e612a167abdc9bba549e470d07d10a16e87be072ecd97e5854841225d29fdb850103e12a432b9cfb16c2182fcfb5f7bc02b49aa612498a12c7cd9223afd1e8155e6796c73721ca6b4470baee8d714463caa9adf7029772d5efce1df5505b2a3301483b0c1213b1d245a029406f8c8774898ffe4713088efcb31abba70fcc9c09188008d90fcbd76a92c7095464d64aac232e6c6bb570e0ac8f51d74e3a0d8d9bd9d766a885da267a3b4e6d97c0cf8200874ced859d333973f309dfa9bc7a0251d042348949406492dd0e8b871962bf1ad10a3bff83d1b933978c7dad4259daefb14ac90e53388c8904f63c305c96d654428d634d7742d67710d70a74b6dcfcb0cba94de16384469cebdacdf9efa373ea6c4561b8df0875effa32820a6f601f747aeb673d502e115a111e78e0f3f09f1261e4d3f2e78599e504fb03fbd77a45086edfeb29bceb79eaef42fb894edbd60dfdbf10d8440ddd53680f52c410e5327d1f05507c822cb10ee7eb08972d067e51cf560f77acaef32384dd9cd278e08203d6c998b9ec065cfbd498013738a2af59507563ea5c7f6b60d53d1103f9b127a37b1dcafaf795bb109e0455df3a494d2c308f6728ce5c7ab4f16b0d91dd663a3993fed001489d6377002b7de51b330ef36db6333e905835b4a631fe3f76a417c7a7b76cd64bebe5b3f724112c1bdf15344d8d5239860476a587555a8e33a7a3a7954036850efe6355ae33f5016676dd66a6ecf05bc8ea577be8025ca4762df912b1a3e7a992a1ce02211309152efcfe2fa96f56056654bdfd71669fc30036a45aa35311e45bb5ceeb0207d3e43e9cd9aad61c24e49396785ac4196baf2c3c5d87c632ef1d502bf7426358e6cdc50b665c06a0c6e203b3ceec82946f4facce7044a914d3ae7e9b004ea3ea025e06c034ac206ffe952b358bd2e30f1dfadec9ca08e37bbba41712a9c71337807b056b82dfc4389ca955f76bd9d2cf395292b5ab98249ecbef8ddd5f8a1dc44cdcdd8e97269a7407515b3446db7764fe3bc685cff48f7d0b124d612b2c0f32d281445f1f7c92de5b84036fe379325897ba09a25ed35c40431f6e3a050992be6b260afdbcf7bd24f44ce7661b296557b14c76e3ecd90189fd27e76b466277587222c7d5b9af904ae98529ddc8835258c3dab39a384ed4ab789066c59fd2cc007a468e39ce1870dd415194162bee2ca13feb2bfd9adfab244430e7d67f576ee2004bba95a219ac9049264bd6b9f8bc2aaaff08cd1ef8b8c190f4878abf5aca8213422e7c08493b1c6124a7bd5ef19651cb425e31f0612a0812bc8a1d6abffbd6438447f2f5b4bdcff94078a107a3ab3d2748cc2a8032f173f43fde30665c11465ddb10661ce1305cc253d2d75547eee021ce7200bda2be501a60661272057f5433c375b75e59ba381a740db04aa251ad16ff0d74e3a983ee1668bedfb3c4c52a25bd85ec3f3ce4e62f291d13268f29739713074deb3402fe214d613f20042d3c0ac8d919c04cedbb8bf29e065d9128d53128debfd18b254dc677a0c63ef9e1a1686546a44daab8fed0afc07188706785363ecd048f7be1b60188e06b5c0a3b3731338171216c315840a8b155a6e77525191754c775c0f9d881ac7ec2bdb077348deb422ec9fdbd0d4a9f8dd5e61d53482be5c936a434b511eae693cec3a3674e69e31f5787b311d7631c604f0ff3126424a7c0bf01b99dec399e4732ada6fe8fb44d70740aaa23d0e28bfc8dbf13e96e7e8162c33161286b8f65b6938afa41410434b5d6bbd1b73605790e8e2f95d47d46034ee35cec4e6b2257c5483ffe022726fc9fb9ae39a1b6b375e575da91ab053540389b8a9507b181a451050b80e98740b518a40d5b90804843282c4690e7b2babeca0a0e60e5c4d4ef37c99a8fcb907f1e5a95688c1da1b9147e0f9be54f5248399904e2b6a680983ee795a94d73e1c4831ae6e35f440b84a89a09d55045b0ee4b8fc475a1b73be5ef59ad57a64874919e2f98a48af93333aa13fe0a198b5a98e21534f9c41eaef9ca0b628c8648d4b8922f57ff20ddc525fc5bde13e6ce2638bc810dadcba28cd557e6bf67b9632a8d92bebcd545f017fdbead0317ad29831d26c51df10c46db2f1feee82a0ab3596218b2e10501e07b500ddcacdbd88c591c5d17507cf54b60d5be49d8173a6d4c4071d8f76844ef8cec86d91e087977777621a8550af294fac4b126e53c3b26b7b5049f572d28b328b969fc2571c76ff2da921c33e8c5ddc7ee570345d48b9465feae410637de41166f06da6455c5cc62be20156798941bb1e4013030eda3295b960165afb17e2a61e0885b1b4112008984c28891290ebd1e720904f6f9a8d7a5c02a647c1672363ac2d362a200c85798e3915d108700e5a634b8b52bd22b0e3db3b9337be293bf1403569076ce75746d23b7abaaacb43e26f973b47465f1777959a23bf5b8d2b80baeae2112dcba80a1a5607eb7e51fa055149966d38a07f574d7d121fe7b72e2011dd941761a0c3ba5822b4f6f5eed9852cd1d3ac084785f42a172ff71519216254f40e2836ae8d0ef50d2bbaf659a3c7716d40675fd3437e5d3f6fabedf6d8a976fd450a25d872d16f1bcce752f925466bb2ae4563a57c02a4f2b9ce6200e63158f12a9d058731347faaf7c3e3062a02d37f9c8e08a616b540fb496e128c0b11fb158bd4643b2f04488d9f1beb4d585c2a0ad8dbd4545eb0d41d431ccd1f9c88064ae1a31632348b65cc807b2686bfc2fc898e80da0e04156cf0ccf27d8363df0b561ed402c033de9c16a03890a333792bc2a5142f11fa6a900f2072375eb3c95a2938a5f5362d950d8b64a30a4ac7cd2ebf1d43c43863682710035a584f66aa2eb02e4914cb86336a279bbf999acfe939d1c7844d162df9f28c31f01576bd7b273cb1a57f8d938dded163958d26ecce62798b51a21d31e1d0e266a5cfb0e892ecb52c7b202130d7d1a3cd5f628ec0f69b97d3497d81ca379d258545848cdda9f3b0bcd99291b7724025464a63b5751b02392d4be211b450aec69c8109fc4abcac2ae73c6bad7429690781ec2c420258674036cfdc92dbd43d4614b17b2d9eeee88ea4184759d7656a04dc5e702462ef768f957317711299d6e97b13798d3ab9f7df8a2ede9c59bb21f13efa8c74930adc8dc30b411e60ca2a25ece402af45ceba33d0367dbb17903850415dd2e4aeab9f0ca0f8d9061a2f779bae1d561f25e2892cc51148d1ddf904d47e6318c01abce420c966fec61c56d301fe388e8f3fd39e2bdbfb5867dd463fc513834f70975b1cfa978d3be726f6647d2fd4f667e344c53ce53539c81d07af017f78898406c42eb65bac33c0786185170427ec434d0f097308db34f276906cecba825263d573a6cb75fe190269b72db51a03abb20d396f5e0863e0a0bfad1ad62f6734492b12f18d89e1a318021469a7a8ad53b40d44043ab120736722e2acf563c28414e871b8b22ebb5295c038754ceaa2105cceddee506060aa636606647ed9c9cb43cdd30fbdae1173a6062a8efefcd61e76d583557781f2b81431e961a314aa81f8383da660bc042c6b0b35f28c96ba7cb674a27e45d13571f2016970260aacea2c157c41c1250f8b37d48c27d669c21ed6671ffac06004e0e6079704533535c8b7caf9ddc9a266c953f9fca50c97491a5d2b65574ee45bdff29aa371c4c09c268972a9af00360536b07c41b4524d6dce264482d3678b1d34d1ac9d5881b5952cf3757de4cfce2e486e8f4850ae9a8f0f2ba96d0c2391b74c7776e1bf89696b767d8b33efe86b9ff1fc65a9f422bc0004a8c881980623238800939da263e1510ab8703f1eefeaf74b59212a1652149bbc7d6d9be83378bbc3edcd569172eb83d19d20fbf494adb0854510b81e9e52f5a1460ce3354f57227d782337c7f4e5160a3553343ad58e34ef5a94e361c79c5c5444e2750fbf403b4b66495218f18c55cf21fbf1230638e98f3b0d2fc97f437d34f412d42bc6235a847d257d5cfe7c0d574421784677b9ba7f60848188cb463ed41735ae4d940874d77c5d5035c327a445eca296b29289f58d9f4185f37984c857201188fa2a967a96cb845314bb03ed99b2569ab9f96615c50f796aa11cbac750a5fa594886699d7b2d4e2f7361aea13d7b36b9f624816630d8ec1d6cb5985bf3ed47969d0f3ebfb40b5ce899d6891501029a45410c8e7f342bc62e8e42d531c9b34cf266243a191ae7c4f41173872d01c1aef6eeb2dc07597a7d848e3424828cc2385fa861694cc132e22ce17e1c1386d313088417042aba91af3389e81ea608303ab6b31913887483699e1f1d43c1d50dbfb0ba46830907528a267a95ad6e5ef197b546aa4961486592d5fc9ee0fadc6f76c9682dc8ecf37cf653b6f5b7e4e8dab4f951b6d7f1c7d36828136de551927c4bcb61d14b8c79c2d414d6f907c9caaa3029a9920894f70773c2e8a1d4d65516996d9a3710c5e8ac78cb55ba64e2cf78e574e9ad26753b0fa517dcfd754c8c04452e26a6470d1e8f6430794db16d8bb1d159f05ba816c4a59b13af5c3390e8935c30b2a1aa4e81878c7865da8862ab246583d5a648e870949291e20984fb31d6b50a9d4f22ce6fdda5ca052cb57d09e46fa048b70b7f0e00b785f88bcd9a1846d605a38802fe21c295d21af8d4ac5edc650f80863ac3cf02c0f32ea013ae56027fea8d464c91a9806b387e5087d57fbad18d659bc05539bd3a62b900f0eb29320852a54b040cb8a191ef0ceb5035b8a907a58567e9a294e2b5e31fdc4877d5b289002900b081955ca39e805955c8cacc3827e291551ae4cb146959b88aebc3d09255310f2db983696017e1e8f4dc7b0e6c4c8194db309cf124c75e597a5a5c3befb4233f5969e3213373f442bfa3814a64ed78bca35f1b46a3b75f448e415cb8742a312fae82a7ab7b5b7101b1653f33c08ced43c96fab0e515880d6151402572db0285645c103b753c66bc2ee3f3cb56c8bd5ea813af8adc340aff883b6eb9a36a4ea88255d16518567e8ba9aabd60c1b52ee8577fbeb12dba2182f289f8c72f9136162aef5abaf38e08062f659e29a18e0f4e58809d37f0e4c5a40e8d3860898bcc27239c78038c1594f80663241a0d9e44417dfed273ad08486f6cb7b821e72a0cd6cc4560ec1c74ceeefc7d7bb51e4d01819e4b69c79f52a438ee831c0f0eb29d0b378d950dee9e90927501354142e5cb0573d57109a3fa922ac7d529cc9e49c8258b6337b217df6178801708ad85ad855257c66a9eef99f1326aca027cac57f67ec6d39546f547c89a564f53e89d31242313f8a2400d574c72bd2987f3b24e564901b34f62dcd19d7f3acca633139e5eac7850a44c2f89a15127973506e33bb691fa755c4fdc317792a8fdbc7eac5b3b708af548d2d5fc4015af01b7b20bb9b4890a084ab1eda39aa40832d8131dabde94e750aa6b754ecf7cabcb259c108d4bc09c054f4d9e1d1b21f63b9f411041c4b4a807c61d2138441821e4b590e1fec7247b2884ef5f442549c92e0012c258fb53490d8084688896b3f1cfc12f74a94e81ad07f0fb59ce4074a45fab504a3ee34fe572057a6b38433a659e267225bbf2bc9973f86505095ebd2904e7935e34a37987674fdbc0fb90092f9e25b4d80198e9ac7d35aa77d900590933cf006c07b49a27a1ee108c36d1ef4c728aa679add333e7d7882dbc0406f21567179d0a9d175010af55eea6a4c67beb96feb2b520600647d35fe0fa7b6a306c032563789e8c09051bef2cf734e51a4b49fb5e95d3e55abc741d2381553c252c39bcb4c4c7c981c85564ccd62e07a8e452d53b0941852dc666a2d31b645f21d27a89315c7035be02b01f364a733c45d3d3b44a9b2440612b876dc919109e62dfdec1fe74faf42228d75a1569cc8eac9d2c60942940c99cd8d4c5e837ea4e4f013b412e7e5be4f3d265d59fb5ef1b9c5c264fd2918a0dbebf96475004c8cbc0bdf3d2454cb21443982087139ae052dc2b04b20bdfb3461aa4227ce8afbb2caebe8ec7d62f5eb0b802627a4d3335eab86b21760f71fdee11a4a294ea0cb1263de9f821d180aa019c462bfb9fbab2bbeb7571c37eafa8f8603cfd80300ce16793b08dd76bccaf3a8a2ab4a2af940dad1fea8a20a5580b6418d39546858be3021dbafef91390b2e44181aa926be1db52e6e5dc982ca9efe224a87ac8117760c9347a8b7015d641abb0e9ca19d21c84c172449dd5eb7faf56f713cdaee56529cc8995e1dcfe489dfedb18ed1ac060bacd108def7148f7559c1b6ddca9f2d596d8d8e4750bfad58d38785025fa049483e4c1ee951aa07ef691bb94a7df5a0bd29b26166abbd2b01e7f0d0d0baf1a53dfa24d7e07006a47c396a03ffb0f8f1bca141ccf35c16211a37407edb1dd71f6283bf8acea449809a75fcc5abcd961119bf3f24116d379df62f7e9a14d796994cfefec6119f4f3586a0ca3fbd20ff2a5ef55e735fbb3cba468241303105fd90e24d7aa70d84b9b571141c14fcd70f6b4367da9c8ea1a5b6ae08f8d9b487227e35a1e9ad9bdd8aab1b58952e1b59a5bbd5e44c245895beb8e0d3dee70a6dad5846257e703075a131cb5081e4e2e9a6a93d4d61d0307d62b32906b5b2c81c6fd4c04f054a5195648498f80c7d0b8cdeb859ca14afa91e751c64afa3cffb877fb60ebb77e0e543489cde9eb0d7efa6094057195213df2f5c6c968618eaa09ba06434bf26f38c2e999cf5663f2a39f67031d8b82d13bee8aa74fc56c99feaab0ba4715713c28cb033892303104d723beef2cce9ec66c7832858d1878772048fab173ae3fff7e9f799ace795b4e9af8e8b22b742f7e1b04110123f810d731c62fb90a76e38deb4481967f72b44522460c88774bc9d1d37a136d5f1bf2e99125305c6537b1957f10fd4435f63d3dc5dd27485256f389ad81eaa67acdca1b4e3ed1344e0b1954231983a062bcd68264a6467489e619bc5300d1ba123d9bfbd754bfed9e52f30b1abee3923641ccd3d7f9252aac6c408d54311a6f6ae69d8852a9c50d1b26716d0a654c2b7c34cbf2bc3e22843fdaee5849ae0cd79940875c4367eb649327a8099b7422efe4b2d5f6f2adcd6644dc924def2c2fb0b9eebcc7eeab20751d51491a816c84c7d5f8eda4e3e56474320a3777ba4740ecc86b3c19aff4670817236e32cda5fcf184e41172ef286c80e877ca4742cc4618252edfd93dbd6bfbe1c2af26b18ac57745a56e234269b0b00ba1277f2666397a9a3da0e867b97719396d2165e910c926139da93e5257018dfd65f2d3253b65ddacdcfca883deaa0c255f307e40085fec79b45a9c5e1e8f7e476b831b60e843209b895bb5b5ab7ceb0fe10bd485e61c9e70d53879ceedaa3bf7d35fac12183b5b93ef5296d7b80e78570470ab83e99181d411332a0357ec07e6d0599a8945f71a8ac7aefd3d35b55de856534bc02b07e19c405b033a3a179d601ae27b5a58fe43225b417bf8c5c9ab9ebdb4925725f4a9fc25a0d15530841b7076b0528c31861de805c12ef602e66168333e1d90b072d89683b9e1afe30c2ecbd9ffe0cf1c3f70f234a293c6d17d05bdb30f1cb226e94a74bac0f81e0970e7d9ecce2d045d9cc501d7b8a5f5a1d71cd97bc27de3eeefc55c5882c1a4deed0370eb04c23896c2f2d290335c5d52c7a46f3f346c1fc0548afaa27e942e244abdee6467121119e427a8ab0159db94095001b7ce3878656697f250cda4c42e08c30c5e87149088d904f7b3d607d45353f2454a956b44169f24c74944feb65ca24b99c324ecb881c0abcb870a21d79bc672d3bc41858c69e3efb32195c62f849478c208dfc872299170f84caa27f251c153e7dd1bef752b5c1e4993d1dbab06bcda9ef3359d60f486aa46e03e593a9e1f4f5387db7a11f1ed7835615b8b6c85e1c069a95de88d76ecf76d5d669254817a43fbcbb6322faf4cfa0e175f2bf7b90ec5c5c2377eabb15d6bc00d285d1d0f926fa83944c2e0bfb4d2e70f10f5aaf7f42bcdb7d767ca0de745ea951290fdb58d1859a96b229993e6b1c26d9793f615c0911056bd1e731307bdb0db682ac3e1cd39187148b25f69a65398268f65cccd16291af389de46fff30d2dd871abce734fbcf255e616665770b69ddcc239f103641c9f9bb49dec319eb292d0878ae68df66ae59d6e9bb9c5bf3845fbfa3d884e30592f90b787a5ded6b34e7727ad3848999d23143e9d983187c09d4acd3c96a3dad7171ab33f9ef1efbf2645804e8165326457dc307ce90d54bfdcd2b5ca1df1438ea30dab3385d01771f388971a8402b82d6564ef258f6498a624a1ab27c1a7eff6c083eedfcf9967dd3eccd875ba503e54a72f0f2842030900806be49396bc0c0356d115003fc52437d082f8e46ec4a17a6d5f5c360a7b055c6ea0f8ca9d4196eeec888b082478061167a5ee49a192f03c4fcac49e3d42c97e5122fad36fba2ce2823f7c16ec9d5c23106c5b2cbac54b3e5da5dadabfa52ba9f1df75633c96679e5a1ab309f63dd6e4d7b0b1b01e7b268ee56f20ecc39bad079e0fb61776ea84f90dfe6c0e4ab22185b8e54b3d2ea52fb302b2936d34228afe8808975c6710e9ef0031425538a306f31e7ee6958c818894f8ad52ecc73d63b94508b91f7518b48ef204eb976014c9b0e067e97bab1b0bc70cf5305e934a61049fab269135547359f5e46c9ab786839e317aea3ba3c052225a038f997e3880061ef5cde6be9ef98249bfd2d4506f6f6241a445720faf0119776190b3bb76428552f4f108e4827d174299064db0eb68bb9c2f98f1cae2598a6541dcb6a3874c4f0e464f06f2e696fcddafa2db3e39a75d882996f04fd433f940572a6afc652b7ab7e5f20b5fff83a6b35bcb4372a514aff4ccd53a2eac05d34ac3281f101e8f5cd7ea909e917b66ff2446f20b487c1b5530807370da56e368b7a241c358a3d3e7041557bbf015b21b039f4028a9608fe22e0ad379dd9bd629e35207ed251f1ec12ab760840c9cba9dd5f81d46a94fd64ea14a580c9537e984af83d5b48c156dc9cb23e4c1d23d828192fa35c11a1db468d471cd2fc2a43297ea74e1d0beef7ec72fadb0839e73174626c3401c0740b9b54fc4ce9f4caa491ef7b93138eedb10d98e0a273d5821aa167fd2b0dffdd803dce1baa7282bac5854c25d08b17db9c4f8f27c5eb6a20f1406d14ac326e8fc8d1493f225749d0b8e604d62645a9740fbf0ec0bbba728c027672056faf9475459c719a15d6bd7dca6592c3c11f3590f6708a9ed49577f7a62dedc538daf3e67b7c8c2c7c5747bad737e584ead373156ac063c46c1bc9cc9de3705198d5d2a59c107ba7882b045c9c1518e30c69862b81aa6fc0273f2742bd39b4fa264e6a3ed9abee29f2eb42c5c9ce14ae5d5a6c2ea67292510b610f895168661b0c98a10d27867764e72d03ab457a2bb3110caea9a97299eb82f78d28c908913cf642728959ecc510556d0ad519b7ae649b0f125fa81b66b2aa609ada6b452eac20107005907b6193e7f40dfc77eab1f4675d4fa1f1eafae55f44dd2b052a9a546d233fbe62689013a65b21f24ae7322549a7b0cf0726d22b47e89610a917632cad59b4b8e9b973bcbd1f889c7487ad628c8a1791c99a93303c771878dbb4de41a468d8f9cc050f6c7144b2323679e51c6bcdb1d9b2c1cae51e1d09c446bd5d891b7caa44b62871128f7058ed87c2fde5ae95f4331c7645da6bd1bd11708274558a5fcac0f88a0bbc158995573df120039330055c3a9ddf91ae7944d13394406234413cc0db9c0baa4e77601165aedaa60c44b2b77fe93b483f52e5f254f1cdb510270a224321cae782ad2f02ead2476e61992951ecab01bff818637cae26a9f370f3797240c19c46db9c57b3022c8eb3544f98e67eeab28771e25d9879d9b7688a329a3cc6cf3f5eeaa66321d19b5234083b6d9229ae5694b3a518d77773101396ecb9ccf0d30294568aefcb2af70283dcd381e4e384e601168d92cb4a8d54c0e43ad0d540e1e942ed2559a955ba28b02bbeccf52b093234b68993fe33f95ed325c6f695607db751cb8c02fce755b2b9bdb91fa749783d25f195166cf997f541d61c0a0d4108282602bfbb0217438e37429ca11cfd770dfb4317da6baecf95333e34044f4eda3d5738106ef5ea9cc6c6f39ae56dbae89cf714aa725d58707522eefd910304fe09929f1ad0f88b82c35b6a354160e8a2104466856bd9fd9296303375c1c872cd3f7be39342c869418dd97b97e4ce545b6ac597365bd0b46bd8ab4af603a58d460d92235fc47ff45ddb583abe39ada8b6666dbb87f88a072547c306b95f9d6c3e9e10b24ed0b2bc8a1eaf358fab9947db9c30acb1a6ef0de52f4d7c13a2c2801804d5f58275bbcba6843ac682d2a3dd84eeeb66eb1eaa29be08925b9cde8e6406223770f6907246cf95ab17aabca7ac7a3913dc85170e587b2aa5eb80a422281c597051c9df054a5abc59102dcdd45cf7854901c24e6ef7e14d43b064bc1fd9b6f494a7a194d1062bf01811297a967abae513ef352ffa8fc7fc8c00d24164f6d8b9f9a75158073bc195fb29fc304e222b2500064dc2a4b40d65f49d0cfa363c07063ac977aa8f2a4cfe2e8c1c56fe9dc288210aa042eaca94811e56e70f529036b5885506cbac0c603670ab62a6eb1b4b43775b072e1a354ade4df302d4ab15bc8164e1e29270ccb29fc8968cc10fa96f8e8ea0cde59cad18392cf55021e48d71f1f4ae3d8eb46e329f2001e13be25360138955bb31138b4c4ae9c015e7c707ebf858261ae8804fdd61d1967b012e057f1c08cb1b6dbe2e7fa1e14d617a9eafaef2cd4db141d637ce9351cd80f25c622f696738304a4a2b8c329188934fe8a19dd7f93faae1b52c927cfdd640ea0a6bd94e15a497c25871e4f4375a5b0c87581f605f26ef5d26e2fc0c83967640baa27fbb893ee9f9ec79037c3c5e940ebe45266a6f1ef533356420f92b069b398ac67a5e55377f06c4a85449f525cf792a158da4c502ff4b4e8bc7cbe0d5b565b0440501cbe6e1d07af7d441c12308b045b2e8b8106c3a00573d5b342d7c7514480622df98152016c6448d6f9e687008550c3c6bd26e7564043c2f66edd155a109936ca125dfb54677ed855e86180ca4a6567d55e52f7de41ceed0deb54982cb1f3959e29d703a64dbc6a289b199d4e9350b55dab2c587b59f15330bd7e7d0633f20a5ec477c0f07c90d6b3eb00c363dd01d0be78f124bae477a71f7596148bec788f76896367e0ad134a3c0c7a90d377e71488f9d6a0eb0735806e7d75c252ec991dc6e9edb3045114c351c8a989dbb3c08f4d921984924a77e21977e3f15e95e8ea97f249ca1c35716ba5b0029c6bd0b46f605c0a0d7cb12e9aa33fd3260e362e2874c7d262396f13195448518b7b22ae7407ed2dbd71d712bc3ab6d3281299a8e25b1ca0c568d9bae4286071ea273d53642066d801180c879aec52c8260cf175dddef9aca8aa036dfe31a3e3b17d4c3ebb58a938cb6c19f69eee875b05d86ef4f1ba66522ca71a3380ca0d747e271aca87bfb82e5ee3d59a84e8e74a06ad50c8b17be66dbba3839f1784ce49db8d796fd71e4c3195648663f3f6481329ca3ea32502b6e82f8b5c803763ba06860a9d21ec6a3358043393520423ace9b4a428ef36af865d8aa53f7817ae910d6b12d4807847dbf9204ee8a6f0144584c31936de2d5cd96ee6f310a0b95ad89f3f38794ae8aedd28bcb0f83905f54938d655ee683805749541f05097d598246b91003d5d69eaaba8094b10f1638d787cb0dc6829d59750207ae156ac36a9e999095d24d8f90bc0e31c996eb0f550aa9d95f4a9c29b0978b124f4e800e7a08d8a809012d7f37057d7c0d9c5633411d22f165e17407ce88d469924960bd0e5af152e7da3385f030dd0ef39814646cd31d997e063ae58e1fb2002bfcf1252d8d155783bddb8e062183721a179dca794827eb8a9acc1690427a711dfe2acd02fee94b6244d00d16725fbb40803d58bbaccf5cd6a7fc58a76be45d4612dcaf3c64a8d0dca6d88ac50579af568cc512597a1dd1314ac33da721a84e7e473228228689cadf95d6689e0656a5cedeed868200d7e6077a830eb52bced1c5f171edf55af114a5b72b468b5130249a50ab41b9516b3fdd2d4ef41175e30225328a68cb73d060ffc0084d65d2dac86beb095","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
