<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6cebd53c8e8e03fe90f5e1e4eb18332def742a7fcda0d227d11c7322f4e77d853ec0ed1db9138b650c530d032f561706ba88773f9c75c12abcaf6fd95154d47d16198f16371fdc6f704c04aae4e0a6aff69de70a93eed8ee44cb62f03b9f6eee758aaee4176f87a86f86cb7c6679817d0b5afa8ac10ff56f2ba3a2eadc71f0cdfa2e8e1eba374f4ae4d3053a6ec37698c4119ee45eb7bb9fcf9b0f49b2c79b45be7db7f5b66c879ad7e2e4f90e504b2a485c4521f5bf9409842469aed13a8611a5b8abae37e52ecde042c267aa8be28b16af041cc0603ded5cadec73773df7a5a6c93af466e3ad47ab7c07ccf30f2e878cf9ac60c2f8f338b6eec945ebe042b494fd862752fd1bd428c1e4fcadf4186e37ccc0b500f8e4a6208b65d6b31b895a00ebe9054c2bc3a8fe301618f1a701141b4ee7abdb23d1e02cdd5417f1270477a56c352d806e17e19fae39cf514daa49e6cc7369d6bbd1365a906fed757c00e8667cba1d47822c2f256942e9f5b177f9e874509f5ddb21e4e9dfc418a8609d0b24859105563490975c2eb133889bb9c8c1224d506dfd2ed39f790c701faf1556807da0424fe7b2e72910c76dc732908fb6aab25e988918265e91d8e214a5bab10674b97d038856dd42470c0322453f8c7639d4980f6e2e3c3ff4904758e236ceda197c6fad598c7671ecdf72b07c0649a851d7c285a2be021c97f9cb0ab910348d0728ceeb305858adfe2dca51eaf94814504b1882cbe96826ba6ed94233513042fc4c91de606a16b1abb93a699f8971350bb064c53d03cc11c50f98ff63ee85a98298262f91ce411d815798538b80fe24027ca697e018db17b42a9b61312d3806ef8fae1fed1dd0406a6e2653db2b1147d1cacf749662e5324a9f6f0a87a92952c073c79646953a98c47ee2fff1db16d2a5969e354f5c6f30d64a90d5d71273be1476a5d34f986cc5656775075bc5eca37450440ddcb73c72bb1ff32061a1e70929fa8dd0a169f77a77a55f434990f406afeb55abf4902d2e4d340ca793436de7dc1d045da82238489067ef0153865a4ad88eef68e719202fd461df0534fd643ac2cbf674a93ff6762e0adcc192d190bd5d2e1a4600805b56e137c05356fd4ee279e0d6b9a655d409bbe90f758a0190591256ed9deb2a27562b274e744e8a8f3fa838c87a05a68d94f2c64dfbf6df1d3039142a446ef6c7c37f421c15f1a3032daf1eebe1493b456883b03744418aced040b70fd756ed256aa69486c56840e8e1b10884698da9639a7158a35e5ca3fcb5fc5fee0adb1ee7d61d96ba21afe7f93dcbfd2df2a4d49ccffda0ba75de2dd46612a1a046e3cd17448dba74e123f3ceac82c1cc21e2e7d6a4f888dd6b98858a4655036ef41c4b39f1298d9a92621d343d16ee3ef88d3d1ca91e81ad1a02f5fc0023a6181295f3d495dfae72f6186557b885ea5c47a738ef484a540c420f90659c304cfc7ab6bb87564ed98d9dc1f093f8060d902cec0a44eadcc87be90215efd06dfed2b7ea86564f0fea6ea7fd476cdb38aed95dfcf1f3fbd943a0283f79f455792f1f2a167bff2e69ae13836c2cfe3ec816ba0245a31dec50bbf7b5ba3efde39313ffe655aefbce7734dd33c522a3855417de4b8331501494fa5f002080ff668d3f093cfef03f2b1ad32e47da8f9fc928f1b4a56b8c6ef4550d2be0bd26cab7a8a4490cb0f668d4debe0566a6f02284be3812899213f182e3358193b199a7c7d81130964fc57d37ac8eea5764f017360106b98a86086cbdddc0e8174349c9ce85a285875868e5b797962d716f6c64a80a13ab1785c9e6afbf12815186bf4e07b05084f43e87c1f117602c962a5e791f911267ac8ca7b13947c650fdd1c81dcab8fbd59f09edda20cad813eed01b74d74324b7733838fc5678b7cd3d65131966b2ba8b00941f99ef87d1905c998b076aae10f8651c3677288791c13595d7720dbffad5def64c42ab2b9b1f8961a07ef49970092f90a15210261d8fd19ddea3a5abd28623cc62177afd322cc01f969a88b5e36e543068e8b31ad390c0a94c51c6dd5cd57937dddb6dafb659a00bf81e15212d5b99c156c0b5d2e1f69e780549306a0829f8281c6c29af2c42820cf08568541c2939d3a3f1186f75fb269360dab24c6099f4e1c4e7143a845eba488c1c042e4b4b3a2d6868e7dea2a8709fc55cf78b3c67cc4c18d4e6ded1388641740d3c2edac701a9bafa75546c4b6af2c95891c7096c500b24df1be5674b049ea48cf160b16eb700798ac8b430a0bc866a45ef15bc25759288b572aa2761bd64c609e7975a2e405f465fc10e098e8b0cb9657169cd77b8a3c5ca5321d9ccf4bd8620c8d02f5b18eb4bd858444ff969ca9a70b335d861cb834920e7f16ce927034259e2944a683ecbb80aeef33db93f94b4c23656c5f30e724981a8de1135fbcd77a198982ed966eec99904e3fe77dd534ab084b0115dd8ca6d2525956126328eaf585cde86d4f1b4187a6669654dfeb72d5f3262ab93863956f8fbebaee4282e64f4bcbdab58190ffa2403a58c242c22b1636e82f8bab8dd3917181c664ac22d0796c622fa7248c4c03a74f1684baf0d0090f1cb332921d9870d94cb7f9c4a989b6fccda824aadcdf608dfc99e68ee385372d58d79189ee74b328a098b59fccb49e86955cdc6d8fa91da091db4c2bb85c10f63c062ff139ba573e231f655117e96c4b018cc4dd0f11617df2d26490f3844c4e9f149297059ac03f4178acf667fc2a75aa3e07d2e5fdfb3ac57eaefe88fc1fdcfc59d9e8306c2497f1977ea597927ba93e0a4cb4b262412263db9bb26ac36eb38f953239a06853ec648e8bc950786a9b7cb1324188e95a6c026a7de6a063ecb7126fddce7d815f8463a57775ba280a53480a76464239af7dba54c2d5e4b7c23d7af11d745222dca25d07ee12f6549235d9065f5e880297d6891637da50f92c4c818f9659dd812b7ba1bc5868c9a382402c38fc88d7586a1d8f84f17dd848634b39b50af7b5f2afa78344b95005bf8868e55113a1b9ece87dc0bdd2b0df6aa2994f62964e676bbac7d16c06c57468da35d4abe8a4f212497208f2c65a45e5b6dd3405dcb8740b52656547453c4c362691fe18a1a6585ae6e4a8ee0a99b7be658f36369863adcb8ba06972952620b87aa088c4ca29fd1667c64bb727fc4b2a3dbcf5505bdc735e4da37777a04eb8568e00067048b8f89704aa28b898b5e0c9a886b412aac03559d251403dd68e5a83e85349f13182069c75196a7f79b967f55876730142eed5ada1b1ffef525db531130aca41e4a09172ee0eeb2f2c8769f4ea0397c29f708b839bb74ab07f14a25119781dc825dc5a9fbeb3a865155a2c1061590c9ce8d694c55b9537a3c31dea5bc3fd06d1408ad92ce752782170e8760705a105a8fea1d4da9ce6dfad3ff4fdeeb680d85ddbdedf0ebae8490ba84c2c3b106ca6326958e7eff6149a648da670143a25a83e437c47a878dfb7917b311107197eb9c4286faa2318781123ef94a2359674e8e3f23975cbb6d0055ec57a1a6b01e71c97f64f801368341c211a6d048105920f53c142f7afd861c23dfe1c457e54f46f290b91d48b9850c1113fe9298629e5e2fef0a9824712c729915fa3c785a4c7d53417426481db9c310fd3749410eff20a630fbd2a4b7ffcc735aec1ca9e5ecd56c13facba2b82fdd753fd26336270ed1c12cec8e47ad32be7e274cf23b36ea876022a10fd152b4a74ca3a42550ca56a2bd5016ff31dc54ad584f3f96e1c1239b420a152b77414a976972ce259d1c5bca8ebbfd49af402e304a042e995654226d4a12f263996df43a9ed47016a72df52dc45a7d296f585352c8305425fe74a838199c66daa805674451139e7cb1c326d579388c9d4be17931d75088a520ef3a5b82707455d81a2df2f04a62a5b52d9d251335d541fd2f8ce90b1b1eb46e04dce84f318375667d45c5f559c7e3abf0b2e87940983d1667f2cf9d5b5a45e132b37bdbbe4804ebee0e060f80e435773914e65fb4d7a0d95435a6e4bbc8cf94dcb2faa86196dfa0ea7bedd49f1c47705d28699d13a27e9edb065bf5dd2e1686297b28b152d17fab6716ba76e11a0b17482e4d27724d39fa3072944c217e746026fb4239ba9d08e94c1c23089b6371be6a2e24f7cd2736003b401b46da420c53f792b541d15bc1aba131940f422b6d4119114d3d4f9ac338961c97bbac2ab59366add7a332379787e060a62f96410452ccbdaaec4044072df8649db3c58fa68f1b7c9d2d1cf992782a72640b33daeb295adc32775bcd6eefb15ce714b78d570c227df2f6868441f1f8b36d42b4961055e1f3aa4aa905686b189d0b1466afb915ee402472ffc3a83256c39244e93c75802258ee7713ebfff00a311f166cead6276e3e41cb667de5f6c5eb93ab27d75a8211260c4db5ffb6b90eea021b4033fda29346255e3219e703168d425f3630c5b6810b6b987b4f740033c35cfbd7c75220c3648d3ab2561419d78560c17d84b67bff9704dfcc39d8aed7ac442ac6978fa4f98446e1e6c83fee83d28307827986f65d6be045d725d7a454cec0113a165ae598bb30168ac136e7ade356bfad12bb6d786e51b787d2cec79769038e789205592d903fa1509b4b511c20fe4e3f78b90ec41807515ae6b7c1544987ebf10dd57ac793695679330e7dd8ddeb5609ff13058613067d467688a6c0b1c0ed14bbfb44f8af93fce0433014d2d83d33c51681a6218f80d341fec8f1ab72f9f710b0c9471dd993e054f27088567abcdf3e4ef2a34b64200826831eb75090fe45f2c930d5923aeb8309cd8a02d5c322fef0a595c9fdd59b8e96bd5fb7d8e0bfdf7f97e13df7b230da8d5b79178fbe55009401a27ba1bd271e12299b86de5553eab24ac24923322451dce07202fbb504a96ced27f4fdd29f6355666a72068185b0a3e4bf50ea09305d08c0316eabdbecdd12ff1e0c457f1b60554f67b6c33f796b77780041999053755a8340e10a207add6713f8ca0da74d31bcab61d34e710d2f3a512a76c0b844fc5a3ed0f151c2dd2d3043576f5f10d397b48d832cb4b2b34dc82f8a4b9212c20695ed754caf6d81813ab53c5f5cbc330e05913d8b4428d2470cef233f06b77bef44ddf1bb4aabe7f9bfe2e9c29849b7a8cbc0b9452b0065f914f409e6939f16298b6c5f05f1343a271dc6b3e820303e41097e9b7d167a33f5e6267d5e4beab3d91613a03b13396c5fa650274e7fabe9f2f40b2fe4e371e58078e986245c7bc8589320c34cc668b8da712c78d06ccfb24401ab9390ca561a35ef745621ab4998dfb40f792573a42348fcbfaa1310799e9bf34d6ad4a06d48b346d68b6e610645271a0739510bcf921aa148711d846f7e082b49f20a794f101d0845e161a6479be6a70f83602ff94ad08dbb09696cac0b008e681d2f62a7dfcdc8f719d7eeb5acb765fdf581f2367b272353b70c0fb7e707e75f7c6b472005a7629e00ff3a600cb9124f4a91c092065c7781864a442607cd15a3f4ea8d0a8193e6fc0bcbd33d409998ea961abe52d7e3073be4053100d4067aeee677e9e883f332d582181181d5bdb719760b2ddfd9864147bfa0baad92828a36d31f6592929d657d8c25486f58fdb4f7624b3a146087a225a28e0e09a09a30525956daeba3f7b9503d183bafc17ff669c8493d54f1e89ef6a9312191c93153d6227a641cb3d318dc01ba1fd69249fd2e73b06d05ad42990b4c6b0827b5c2b2b48d8aebdb2075d0d628765ccdd35bf0b765427c27fe125dd69645efcf83e3bb24c6fe4cc71010dd93d5d1176e65deccaee628d9091b48838ab810a13ad642e6ba53d22c59bcbecb3376a8d60d01b4893c7dd9bcf2dd3b434dbe62e9883e97bb93badadef8b1202bf60062c3251c323feb1802dc389d7fc318f2e68854173693ad069e778084730576c58ce381afdc36845cd69edb0fd0497695cb00f57873cd83b4167201acb9001b0369d028a92c53ba15e389d2793bd05e6203c47bd21764136f5406af9833382adeb736eb49abe41cc3c15b7b7fa7388cac5e86e1c320b5ea6ebab0a0f4e158e3a08d26b8512e48e877e1986a09eefce52514312699f17d91deb9fdc98d7d6427b2e1cbe8e05ff0b67afeb1b5b0da6788709eb44f91db5fe99df55b84e444ddeddd1e1f323460d124adb84521dfb64a5e6eebe11192b9eaa87b3dc518ec3421b8eaf25c5bd09db9b6e46260a5f88884fa3d977c558b67589af2891064f18543fa76ffc4685c772368a7035670b41ae1f08753657499304be867c60267a460606dc037fdda202b8b98d5470ae694886f0ac4d793ed239c0f4959b8feaf3a45e5283447cf5d61f3fdd3ce15905c44701f671a014209255546694d75c2f6529dead2d9f8d6761872983fd311b7fa4ba12f1e25b68c639a9f80b0c8fd586ae53763657d94a03e6130197749419c9df89afd81588174a9b8cbce6e2c61eba6ea54fe98d4d4f451e3438c2806f72874fbcf803bee98c0dea6413cbdb7e000049804848e0c30567e7b44a3a7b2e2d896140da4edc308b9b05b7fddc11e4e67d49c19894c6f3bc53214c6993af93dad92d1b31c91b657a53baf035866108bf6927934b0c5ff1d142d13faa4c9b0fc7cefeb74046b7a3eb94ca34f384c95b3e73853f517f3fdbeb4001452d9cc214dbceaba4332da1483164c044e4d3362f2c3b1ebf2ca236cacdddf66d367e97d5453528b2fc622fd7e19dc3d2897138b78df86ca5d11a9f057376356b7780ed5d02360fc359473f2c89c690285161baa5334ce8f511b81d4d786e8724d6d84e8525a23698db009520a58c71cb7b8e4fa0fcc63639aecc7a27b382d00d5406a3ccb7133ad890fc5ed43b84e716b5ddf000087f111f5e67355c86953001da4fa31404a53f32a906fa9a84ae67b4c8bccb38eacffd403fa724ba73bbc15221ced268195f744a142e1eb7186533066e91dfb30747c3a5294e911380573a24f19e38a7d26aaa2df38d60464763bbfceb59921bf6213c427ce0185e18a4e296ad62fc78efa1d6db1631a45ac86416ac510f114aaf22e934ee3477f85e1af7d5fd8cc46e56cdff0dde28cece4ff5043d20daf6e6e1dee07184da43ea8171f943b411e9b8b275960025ba937092421f24eaeec4919e4eabf61daa07d9fc10728c4ab5ed023460784d135c318d98d84f5652a039ae1abb6f9860d0cdbaa926f70e5f739eb161f783a1ae1d1d7c9a9760ac07b978f13052dc7609fad53c37990440bae41a0b507234b939b61f685c4fe682fb4530086255e7d4670dbf641aa90f7bb867962489cdbb6b669fe99e494fe12aa229f817373539fb3c4b6d6566d3981ae0b8377e842f068c1e95657e26823d6a392f5b9b15ca1f5ad1c0404a9c53d09e19bfd9d9057abdb0d0326773b6f2ea1c94a40dbc7b065b3a33ec439b74c7c3407bc9e5307d3e338af2cf7ed54cad63a8ab93e8f8e753881954ce88de9bc4a5a0f90868fcc2b8494fe8ea19ca5cddc7791fcd156a95ccdd01bf57ba038bc480c4665cc0cd30afc8b5542add23e57baee89a8f9de918bceaaace720a2a1e5e87ace0a8ea9c256aaa5f0ea4d03812eff5f98dcaaff780e5d4214ce2ae82450533fb0bd616e09a54dd4cea21bed342ade1c6704d6a0bb97c9efbea0b7e70589e5bf58462f1c64e9e92e3d864fff8f8c08e92911e8f0b2d30ff00cfc4ee7f4447aed1c2b8cfb7a8fa233b891ed781dd5bb15f6ebab74a22d4fbda2895392ef39677ffd06272d7de15d7988cb8123a5ddf3b92fc17f9f6bdd83c5cbbbbb47a05c7329d25ded2e273c321776595738a08691bc0f276a4216015da219aa9f5b5b063fa447b59af72860d9e011f2a5ba5b4012df9bfea24766bc369654cb2ca62c603b3384a81b4a889b6fc2d27e2be2c5cbffcf1cd12f0469d20e880bea01de111fb65236cf4c2d386bae8e23da78a3ac1c0806dac55a71cb7c62677375c7241cb9a98be5f9dd6c5088eed8a5c98963cdde0f7fa175d1613e363a266cf140d740bedcb85df59ff7b20717ca196ccf58b455ef74c9448fd0ed7a1f616bfebd5650b3a2081437a29e5cc7df0a000c68bdcd7740f423b250ec72dc2ea11e798f2dfb8bcab3781db7c6aa5d99e27f5c4b761bd2c2de95d3eda4c3b0fa39b684c35bb40df9448d76bcb9c012ab654b283835827c49f58ff2a0d69f485bd618144012035c0fd06db4eb1d584b800cb4de8a1ac57ea0d2653a6a8b825ffb878db72f523c6c00daade020588996e7601416b99e26bbcabdc2a793fdbb4d7f0e3dcaa9e4b76ec7835926e8191b557ffd64bd4073fd674d4f3d75efdd59f91bd11284608089f222b98474407aa15b55ca8372beff63b585f814964184dd8f9dc82d94927a7f5851a1d5a562145ba42ca6140a74b0ba2bd30c9206eee935de8cf5c6285e238c845e6cbd9da63af0dd2e784b4fc0c14bccdc7cb517f09f0f09fa6d372a08afa527a000bc350c487aebd0d0866a05242f771213e70b25e5586ea671c9dabebeb9b100a424f309ebecc054cbb7808405f310fdacfcc4d7d7b08c5aa3083c2ce8f3994631df7c17ffc80f6fc4e99adb5b4450a6dd4447db34f6d84922fc3d5e893f20bc73646d0d05f229ce3052625b095ad2b6c5ea14920d43edaafb75f0eb8e54d20d2d22964499b74142f23549015cfe0241288b25fe773efccd63461ac316746268bc58cd285b7d76de063b377557c59490da5390f4efc6e5234fccf3bc61a21ff3ce656e6870ce2d8a9642d5d23f579b14c967e028f3b29f8d060aaa502fbe33d51dafda904c4c7d3f6e7ff46d7f006ca5cee60b6cfd05ad66e2ee90f2d0647c75de8a980bd569c5e441ac1cecdac4a62791f50f806bf0329732cd847f3cddadeb05feab52aa8ab211e679932bd3fab9d65878f2902ac186081be14ec6e5b78eb404c8bee135610e3111b2ed368724bb31a36fbc884ebbf8c2af8e9b98b983f037b0e8ee7fea99e96aa33a1e1890f98853b21526c6041df1265d9dd11a225eb35ba6b89dcf84dc7bd2056acde1eee11afa69499ac74911e256ced1b8f66e1e74c39fb56dd19e72e490b9bd93a05bdded2e7bf3c97ae5ebcca5d7f62d8a16a8d557c0e11d779e4debfb7b529dd46c6f75f106521a136b41839ae9412b84c703578e63be5afb3a9191392df10f32198731040a8a252ec69a1bb57d8443ca9d1e84e86f50bf4639dac2342b77f84ec37108f141a7a0e6e2c0b07abe5f7809c19b1101b80e71bcdf71475945fe70831dbc35ff406cdd5a1ada6ca0ea9e1b5af4643bb2b9e5865675a63f49f6965f74a3b8c24453519ee4719affcfe9a955da1a221bb82d0dcbba3d6366170643670e52a5d4683b0c66b9a3c09659e78e9f875d03f1db4dc85cc8ab4c037f6143c56eaa5c7d6a1822adbd8c75cf911b4402e20d0ecf77498468796ff8ea33c050690a47d4bd979ab85f80f2617fc44cb5b4bfe027da19fd801c832968f25d32c0a39436ff5ad46dc3d0ab7a2b828ca9fa9a51308af85ade5d0d97a6534f958671b0ab446cd8289c12ebcb696f82b303a9b750df12e0ab922bf96e344219f95b4f9297f82d0d209414c21b501364323beab6d05e2d9f75e81bf60804bb50885b07f088a4badf5d6f2c076180bd5e836e272dfa4b2307578c3dc9ffa4d4ef3db1b89188e4f53e41cf0a9b9b63aeba879530e2626e03133fdff13636912c57fbf5704713e2ea0af0d930f40c86e57a46d7078ef215530fd873bfef4814a59ff5a422a625456bebe671193999f514438820aa6fc98f8fcbee696c55c3d8fc8919e2a5f0cd57e3df9fbded4ce3d69521b0781bd2c790079c225a4c69439affaee6cec9a362ef2c89c6ffa29ced2773514707be0220e087e783ae00a198074ee9eb9443c60028d7711ec31b2ec4f5c4c8669113f5550a56a0ee9d50b8e109c4add9239989ab7eee24b7e743f61d0397dfbee7aef82182a5d4f3bd177eeec9abad6c1af5ca471f7873f6c75b157ddf5667152fa883e9b40bd58b464f96ad16e04cc8fd784c45a9fbbe9a4c4466b62db83a306f12f81402eed5f44b5e258e733c7c823747e782541aefb6770e1f52ef27ed749ec5f73705c9bd1ce427b0d936b5034a5884cb937b14765f8e85fe094e517233e796b92b129ea16267d86e20529124fc81941579e82a4e40da08143442123445e0de84187b086aaf48c5abda4221d8b8e341d9768923c556c597d242328c6251ad366e6c873e73c9bc8c70dba364e7c29c395a85cb02da8fbe11161d5b4caf77e3533754dc5e2e8a2a388b7363a4f25f4102387e0f97d2d9493db5af8e309ce33ffdb479b911701aa62a9bba13adeac4e288b5b9948ada9c1eb094521ccc0e37191cb9706b7eab186b5b1995038e23512676ff829e81bf117ebf776fb2ce7084551ab5d0e480a45601d218b1fc731518f39dbfc891997f470c74debf6115b6a2587132b0b7bdd113c08fa9100c8ad7bd5e39db44cc6d93ef7bf04e3811da547fbc341855a3cef8bc3b405a5a433869715f3c8280622a871772c2631317f1f241edb1f4df0b0a364e73c5244094414b5b37273483abe60d3c3f35d8573cb024d5680e81db2cc8546b2c4c016feb6e6b1a4cd580abf505bb67ac6e901c0db8e0386ff8c99d7fb5258bc68f599dc690fe90119e3bc10339c0999e7db32e758a1e8d77f79394fc849db7bae88dbbd48ef98348d05b2bfdcf9a8d96eae69dd094911fd6451f1d08d82af02e45f3cce19656fac45c3c6ab31f5c3dbf1de9c3303bb9a7e119fb630861954db2cbb257dd71ebc2641a1ff9d6b935254e8e7e7da66df931caee372bf98817d1a5405f46a325802372254a0ba5ccfb14c0bbe962f083cd494d40d64b1dc4685a28f69aaa4c048784369521340e2362713f65128dbb516260946c922009ab5d4b98dbf8aac8e006ec29b47339bcf85e6e332c37c9de496b4c67a54afcae4ea7d1521e6a7c996685a0f50cab3cebdb9df77576e493aef00b0f7903599a26d951b1d45e30aea1e6ccc575a4568458a5ac1a99c44a966e21d43ffca00043df0594fe5c0dfff5b779d3e64536114b59bc34400fb031a89c4ab0ce6d41a975ada8ec872695082f5e13ec4888d505c3686bc22cfd19390fe98dbc9a9f19c8e11d181bd07b7731b7aca9c96f88895d44699a07b43e6d93be37d0641d281f03f594cb7c10e063d6500881d47074e649071629e1fda155e5e908e61f1c053d90ef1484a26a7c1f6bf2877627ae6a737bec0297158b07414757f2c7210c1b4ecefe29f2ddf345fa431baebff49094b5edac296f1c27e907e823112ea18dd35cb8998a03da7f8bd90cd4b08e22711d4611380feb03423f8325ea7e78246da3c5a0136e3a5138b85b608b9be8081191643c93693100cadc12268695abd25e174c4bfa22d44d61b5b1ea21d61fa00fe4c8e2b59e021be246895a42aae6387abce70e10e0e642680560a68014f2fcd0cc1dd5717bb7f850173abdd0b8ab1a3acede923150d4f84635280bb9071aafe6d74f50c765e59f34d905490d15c76fbf4c85f39a64a7023358bb4a79fb58cf0a3511252dd8961f14c8e962dc130afafc848c5e3406847e9b8bf76e3845695b93ad83a486d2d0ee75cd7c22ec6082c91c70e91ec4cf9da9ac87f372f0246c5c9c072c0a6f0e2f6f5703dee11a7eb07c090614bdfea17d61eb488f0c7309cd7a837ab6c46b70a67914945f183123a288485098fa5b9ed173722c47a39901b6ad6e625891d26de5f8107a9fc9cfd8cc42410e98f8637d81cb87ec34588dd9d67cba15ba873b04a7f97236a20ba49fd76aba4af1b8bc932f81d88a0eb6b8e99ea5eb377767f6a206ef006be0f28fbd529fe80aa88195e535e5a12163af6c29782decbbc6c92ccb6acf8eb6e62ac6405f00e5edf449dbb9483006deb9aa135277a1ff85c77bab4adc7629ac4d41c16f696d93bc6fd5d6458d195e68183f93023150af19c4a76d2560b6206d6a7007f557d5b21e7feb36d3175de0c069e98bcd178af48fe5227ea5cc3630b35b2cd61563b35e92bc1343f22cb8761bab7300d408c44da03105ab3a51bd27b723e14869a5bcdaf3a312844da3dda2edeb26d6af062df4e874910b277d8ba80978c299932dad76911a894d5c2f215b6ed86881a4925d7e826edb672dfd8be9741468b89d22c5bb79a0bb132f4e3a1158ed4803fcb0829cbb1c4e7eda46297d32c5a9e066db4db69d72dede2fa4b8994d52ad679e5adc419ff37c4a1af7080f2722bb10962c8c5682db01d27ca059fecc2f32849c7152fbf145603f4e82e582afc7a99d86fd79ea32decc84b91ec336895ad8e6ea3656df8034aa1e110ca41013c7c8475c655cf9aba36fb80b1c3be24de8f05a20c41375df499cb6cfbd2476620153a962d882bb5b3ea91e6c8b9c3987e430d4ee3948e6a0a81aca9af9fd1ead0f9b3d25ade63b87f336a15064d45cdc68e1e073bec44492947bf7d50251bca257a10e34d56847008798bc163837b27c8dd603b8a7258b09cf0aa484dfa6d9cc9be0a1c1856da17ab89d857f0fcfebb05a54b019d55ce2e81217accb1f1eb9ae8f5ae787a45db566c5ce892b4038575a7c5e3fd4c91cfbc12dad16153d120291f47d547d5fac3e86c3a94e4efe379033e240e08f4d28c007be303bd68d4c395bf883a6ca59594fe0013d8377b2bc05c875ea563ec5d0b951776882de07046274e01187fa8af4e4bca0bd9194a483921265cf165825e7166d607cf1f9d18dc6815a79b231ef4d7dc020d89eee2df6183845fe4e97243a232af802166628628d2a7dc2a863e85f6c353d9c9a7bc77e4b3bbb6e5b5fb5fd0ec071bcf82009e927ad3df2c560a3c6d3113f801ee44a765754e0ac926b9843a85db9a35cc32b44c3a2e2d7129461623578ee1feb57adac3fa698249d9f3dcc9b71bab6a6b5c578142c203474c87fff723881b3631113ffa2ba2e0eb5c2c67a550113af8d6e0031102d18d1d3c22873175352fceb852ba8d1ba7c2fe7babcea1b8c5846ec3b2e69f85c429a0df0570878af192988fb7df625c97b51a393765cc703446b9abf6887ea3fffba61d7ca13ad4fad91637899b1645dea61123f34235ebeac811ce29245c3b035ce699720070033461ff6293db9e8134e2cfe1a2f8ea74c947069de8b8c9144390b479722e52432ee42efc758a3cd81b565b309e8624511c7c755bd26dd26b711be67e00fe3c6cfaf9ac78b7276793757b17a3744193721486378b37b8d66622b545c3d25981407316b687bd0e4a46b04cc77420d340d615edbe2d3c634ab656951f6b92e058eeeb22fcfb2f1a22dfda69dbad8b346c3ff54a82e26c2623f6e66f13e78798347df1de52147041a8a3e10434255ab3b7d1e573c7b099e1664c77a29817fe42dd3a58f8cb3b2c091c8ab98cf9101b72631d03d4106bf8e5e307eb729b95da9914d2c265b91ee3baed7f20936c2812e4d53aa907ab00cff61242b5282b87bba575cfba951703a84c397f57b60b486973d8a57992b3eefb830467b69d526e01f36d13218b6d772d07cb816e22aa3d70ad43f6d19bfb2509951f5b6df304a451103944a83f69dda3c25b34777ac3f93878c5706af3f99d5a240518b7d9f65cbc02d9d7aa3a276e95e6dccdebd95993dca35905285f42ca2904058729f9181f0b2bc98dcb3aa8bfcbb1a89634dca831d8ddba02df754baf11b10e5ed7021292aa487855deda1c21ea241176b23ba660ce6e730abda5556f9b0576358a8ffc17367f6d09febee5a3b5d4047d71112f8b17c79a7487f0c5a248395c33b71f2878a4a3783ed8d72dac9bf8a7ee73cfa4b6671978346641758982bb97438eb164118e9cfd3f1f0c8f4dada2b5ff2348a130d0e54ae301120c980d1fbdbe4ed2b818e9aa8799962d9e5be9974c5f88447f4f8bdd8df2bc024f985e44b19885a2af39c9f90e773353d3c92b431c66331a2dcf8e3f445493e2fe86ba3a5670d4e699c9be40d48f517383f0ce01c38fb90fdcfbe11cb41cbe409403840e2699cde332b20b17f252d9cc9abec3f59e209c8c4043925bae90e7523b234eef42f09ea351c5123feb36b533712d38fffac696be43fa90f9964ce5c53f97e81294dc46c0e19fb0eb3a920e3aeeb1216cd11f5860b3c9189aa0c1b44c2095f38cbcbc1496ef18780472ad2ed504971fe660abbf8f330f31a1e694ccd13de83fd66ca8776a431f4b739fc2738daf8bacc982af78c9e1b4036c1bac4a7bb7f11ef07510cc119043846ad1f161e1aea1256f413bd9711876d8adb93965ef3fb0aad8494c309f5b131d67fa2ec8e7ba338b78bcf1e1d9190c0d8a406192c016401a09f11f9bd3f80ea403d26d43b51938097055aabfcd1c9e8dd092c81424cd156ec220989502644ebf5a63ecc84bb01312916109a95aa69e362dd7b3f7190db6ab8bdc5336ac140eacfdfa2d993ddef4224ee713b54abed87ec2019d082c15aa730b9f11883dec45374671889c3f56b46e8c72019a12d0718957bdce4f176d14fd154c376c9cdc01e43c94239adc915b5ad3583c86b65d2f48f9beba293fee3e9bbc1d2ae361e14b909545b2948515ffbe60d39b4a78d4469a9d678083f2c36099eb20145d7fcf31fec9e1d72332b8bf6b2e7c0005ce87ae45f2d33c0d9539bdde4fc0256fdd467d7738a845dcc7f0dc74671152c92c44fc8592340ffbd0d9caf7b653e303fd1911523811769080470aedc43a2aaf0cf58a15a789211327ffecc7b371d75dee696c9c081d25e704370973580a25a326864119360959fffae0aa05b91d88408c86a11a2ca95f74fe721e63cd29091aaab0ef864751b3930ce79fb0ba45120ed7b1463110425e9109f04859fbd1f280ea2db31fb07482c96cc15db47fd3afbcab3d8d6c84db495cc9b53e30515ed1989402d1485bc0ff89d688f56a149e5752ee81c2ed15450516b2c5b468ba79ef96d9a268f7d10d6738ea976e9ffe2224f3560d93cc2598c5b642d8b1c42bb46e8bbd8833c62f51c5d782e1c84540a6ae8bfeccf38fdc86f00c0519958aee6f8a728405b461760c92ae7862bebf4c2a03313e30ae3457bce706c848a80194e43","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
