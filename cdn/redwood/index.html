<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4afb3f0d60c051109432280087951238d1840652095deba404a220b28ceaa20f76a86db193efa3f4673f95d05edf2f9579114a7a7ab04a04523554536e64e0d5bd77da3b949e5bae54bdcabc43c41d00a0e7bec22557b2b10fb171b1a694e1ea9d396649c97bd8d8c1b7efe48efb9b2f066f512736585aab451b8042cb635ff37640bde7dabc18bee3b7c35b0568de86225bdc4b4c746c4f0ae3c60f6263dfcf5363bfdd0fa6bd658c522ef9a769c839c9475b9296c0e04b8d4746e519053709c8cc2415944de27d1cb9128e4fa32ebe195181a34726b2af703f6a40fc85246b371f4aa0f9709335032711f303d2b3880f1c51707faf55ee931f901413646ca64b17d34e59aa39f41f34f4403a37f5ff72a15ebd579adf6de290bcfc617ae23a9f5db7c1b9cebf38f3b9d45ac556eb538001b898373b707075100ecfb9380b2b090c6a927e575996ce9aba6a87fa238daf6c9e5752efb093f7e22860603139ed080914d570316ce3afd0d756f219c07900c53ebe644be6598e609ddf046e58b6d39bd54ac3054a096d4eaa585c2dfac7ef25d6723669c6751f9f8eb3ce6dc2b2d0caa2ef25442fdd226f0c73d9dfad769cf5a7eb426ee949c3ecbc6e913c3197d30240d1355a33803286852f811565c7230c9785da717e66e5d2d78ca70dd6b8df27c32d5128d6d4feb1dc2124605aef062a49f69315bef51722ceb30cb5ec84982b273cd52611154b15b742221ea1910997a9e31e798c41a7f8dc2e77926ce7b4544c4f2e5d983ff6e19f03388015f56eda4e242ccac24a130d7b72ee1b37bea26d79aa18a6b09b7648739131221808c7e99c3e8a9dc6cf75ef212e8140db4aa85c30fa405434d3732a1e23abe808cf6f47227eeb0a31efeea13aa7dc8dbf1c379b891265dd08ff0da6eb6f81a89be2096132aa03473fd7c54c4d98df7f5f9bd54006a5940395b5ca6d51a8cd3c528e658bed9693c0670f3fccac111a3d92e4e27326e7f320975a8866a271bd204230e23e5b53eed60c5e7ab45b401a71386dd5cf87015a6e83e513f771642a88bae93fb7e82cdd7473f359353c6dc1cbf69962d4309024e20de9e412f21daa0f1233c20180d6ea92b33f2957212f4c833012f4c2a9ddb9cd3e7e31d7143b717d3e4db0102fc27489384528e39b6c28cf27cf9a6c54dd6a8d61d274387dd9ece85daac7245c8863532ceed5103dd816e9af9b9d763e7ed1c203dddea947f6d1fb080f55d4c7ea08d2c82fdf2c063185cff858e48b91521f7f7276bf37aef4c5cd6fb4aa8173d8bfd75794a8a4ed7264ebe98b8c263c5377387e382c67b17ffbca7ab0c252ed035513507f5f661c28de139864f0d5c9640ec889e7e421f5d0b6f495a1c0a249216eac96e0e9e1136349fceab84170e06053293294c39a9be09942c286f2ba7ab1d5764a9d8a0fa723d8ec7c1fbb4407270190c8ac4ad1db87d6a1a09c278987a0c75465a6354a15e0466dd149a813fd8d09da1beafa0db1208758ac6b52b85194ac00a579f3c973a0a52f690856c5961a74b5792e883338f881e4da38e4298c3684f25a2167c3e6729cf07ff29aae31f2ab422a0c2a7277fc36a96bdebedca56cb6be207e8630596a09814573ecaff7e853fe9527627c03568fe9a8e25cdbec42608a283bdcbd7a977c60d1bd9fa2acdf9320934e6342ba64a4b3399d0301e1f582d97cadbdea6a6bb2111a916e8556d1873fea5185951c0a7a7310f5a039987ef35a2746c79e934ec7f2242cae589db56faff74fd0671289c833d0cb332f3a5e56f222a37047640ced4f9e0f3cab7505b7b292f381d6b6ebb6709b3eed84ee173dd2c1bdf180d9ffe79a66bc950c9f3a871f2c3e2db9f308d08e11ab2e3ac0fc2024339adfc6c944cd0fd8cb404031a7eb11751db2dbd0d682670e6cb80479ef1d9b79a5603b07539aa086cf45a87421de311b04e1ae93255a045000935ffa142a1463ab1a43229a9a7b36bc8e5ca8cf2d1c38b89584fc4435a3de2ed25dc763ea74bf76c3bb8aebd740c3403fb4ed0f4480d04d25b1ac00d8bc4433b1c31c1b3cbdbe769c28b2202ffcf5b02d5f6aab70cf12bf481f2ae90e6880059a18cec9d8083d551dc42812d873404a1ddd40077712d028070b5452412f5934d146f37b25586aeb610f2d0e00b91a10c4c9a7f9bc24b739b8d4c2515c1c692520f2046081540f577e3f19ee8fac7e938531dbc9badeb1141112ef9167628d5f13304f77ef90d9b5f80b92cce8f6886839883a8e50855dacb72282d9e9255d22debfbe63dcf9eeb63d797cbb6826533bfe593a4c6034c7fc5e1fa43fe20d978b96651b74b0d1300ee24ed5e50d77930b6d9b6174fd0398ad96e80fa79a63e5b1d6ab9ea6220b5051c3067624cf6d5ca9b7fe094282f23e21d0ef111c62e36312351aaf43378bd7ba4aa5d6717b98fd226a33692830f305c2295d127bd06bf165b6a046fb93aa87d38be22cafe4878860d6b9c20785cc64f4915f04e756acfe164e706c3c5d57951729d70aa4869b2de0e5d2aaf91b6294cf1a742294ae525556f8fb5fa6d57e24336d48e58c2481f5ad4791122228d2102d52f1a3cd71a41fd6bfbff374a1f9fc8d14256103d278f6aca3a7fe19ce6f2132da42be1a0f3860bd0a1062db654fd58ebf98a458d27ea60add056626456bed50bb40d036bd3b126d0e200699ac3951323c89f4aeab641be0a1502feb6bc24ab07fb786f6877caa60be7535aac4672dcffd599396b11dbc7516634a5b4d3c33fb06a84dc51d0ffba84554fe95575e64d2dca48f1baebb20b107cc6eca11337a2ab5b6d4cf3cddaab8f3e60ec328c3247347d6b97c178deab158b68713b90ca6a2255b31ec78cf53b78af6b360ee2d4495eba1685ca58d9e22f50eb851467b1de6dd8b0758ac8df0b842b85f05fcac059ac2b0884d7e3c9b50e98009b76b59d15fcff485badfa914575b23b585e41a2c6b3aea1102e0d8f8d3ceac6f2ad65a6e3fc0e65d9b5e841b7254dd184282147042b20531d835be5bda79bef3b678bf80e7a23fa2ac4eb2b0c31d945c27cee4705fda43f44019649cc2db41ff304e3e48d19776d9368d9ddf39f49aca070317e249fef992d3e32a1b149f283c6f5b01aff2909f393fd91d2e457a0864b72bd16a8c8be7f10ae0544e41d311ced7d615103c7cb247b860af70c15b250ed72a772a71f93f2fe2f7ac2c105f7c6cf6f191c0f1378978c3f5cecb1a55011033bc0f8c6419dce5bff6012209641828e8e09ae588f76bde00bf36857e25559def523f790638e7787b960a1a68f8c13ed226c5bf3b74432b90455b7b30f953f2f3ded35a2e4eca214f5228ac939c33a00d29ca431cb7fd24794f6f5f8a47f87a0f5de6a8e0b11522c02e4c91507f0692bb26feebee8ce3253a8526017deff5d0fdcb19857c8c7d3f2fad3f5463aac1d18d1863394b2c1ee74241a59ffc069428bd1fddbb162f9001296e8299b873cc30d9416da21d5a19163d8120f32258b879d9d8e535821f719fb7c7827f40966d19b731f6d176277358ecbedac2229f9c22a29731fa331c06cd968159cb7cc0ce846963d405c13dc29b91ffa794dc0f3d85ae44665179d9dfc532a899fc893c706a31c3fc967f1fc5cdfaa83e20e0509869c3a040af8fbc2e0576da00b9778fb988f24688d825ab60592c99020016c8e4b4ac630211d3fb4c529606077ff27826383b9ff8f6c19edc4eec82c08a51a5c424e2961619719cee61f2d2f84b612554e4dc1f73ca7b72ecca4e47271ccc8292214d88bc9c2df66f42e070a52667c57848a61426e531822a1926cf7674ee121f03767ac878e84899e979aa45ec00d41a9d01d6fbcf1c632b161d39d18fa9254c734be6867408de249ad1de9ed6f7f942b199251c780ab8e82ff675b966157f25e355d994a5e0e46da28932b0f5b0bee8ec1752d95ccce7dc1f1f6221eaa70fc080fe1a5c37db8f2e3c7d6900d5943891becbae66859318701a404f1b2c32c038735862775f0cedc3035961775a843ac4633f2ee264eff9874c52fdece5729e206bc70652870f8230db31036f50bd016d4cd960a879c8d8943e53fa2cc697aad3c008c121102d961bd47130b6d73bba8304fd2a24c857d4ce94c00f2e1e76ee69418d4a237fdec7427cb9352fc9d504851613e806af640e361625f47269d0297e50ee6a35a5a5f518f4c1829181187439f65237ac5b6c88ef5779a75f8846cf20745f6dcfcd15ca9be58a0717a3306dd2891972011cb091fdcfcd9195cf9fa506c31b069482fa2512922bd7f8686f89e29f9b755c9d81b971311eec9063644fbf0dc879ec8f833ed01405a2723b2041d0a388e3499fb216d28c54670e0b98420daff6d2eadffb8924fa498594e95551bcd8c3b83837ab1f7baac1d6d3f3c5e2868d660e62843c188fd3eadf2e5cd8f97109f1d6277abed1166ce456621fd421b3193f1423aef112de705f4798b623d178a4286b561ee2246e581c31b81494f0b58438d198a169c86122e511613ce373812caa08c6c1dca292dd5525f741b06e7d40133761f5a175036c0446f8b25fcc77db1956dbf18dc90e3ac43ab0eb7f8cd1fe575db1227257db47a8ed5c81f90382b03a80a09bf8b038f652d48ef54070168b35fb2ac1d9a7520b20370a879fa9f466928b86d98eb08322c8082732838e611588a47365071acc788dae2faeef3e633a0d3fcca9036a678db9c1441cacbbdedec5dbb7fe81e9dc5e8fd71d97b4453159875d90950cb4f04d9cf8b1bafc46c9bd25ea45ff8345cb6d42087711526ec9ab75be23ede644c92964700d3f74f7b0e83574b7af94633c32fc380bc39b28d1a07ee4f806c8e9b2ddcef9eb3509a4010c2bd3b6ba879e4620f0083749806f0b65ceccdd7addb74c4a35c4071f2bf23669ae229967dd03400cc5fc18ec542cefb56c89b9afc4f9f519fd58498a1ef16c77fa8c760d45d3a7c16fba157886344eea0a82a464f62d132ef71d2d952c904bf886aa34b721818809612822aa89aba478edbb683683083ecc27257ef0a136247ebcf94218df8dedd0d5b3cc61c42291bf8978b13ca0b7a8e183b2d2d0b6cfdea56fb2a46a101ede5d21975e08f4834d45d90a4317d5b221f799bd4a0ae6abf1cbed2f6a1b1d6213d063e97df7bbec58b332a7b93b13bd1d549438c889a258d8f422433c0965260348c3d7b6ee921d4f703aea19aa6c9f6f00f4f22686bd99d897796a6479aec300910d714b5cd3ca3875377d0268dcc2dddc8fdce51ecb6ce8aa0a1c461476570ba3008a6083f501fb03150de10eb1bf22693fcf8146e4c1d560438b056ff55a43086f757dd159a58ea4ec8942bbead72619fce7bc6ca8fa4542d933985556229bfab919809905dda89080420cfef4478e8295111b560c9c915c12e7bbd5f47a34ffd4aac902db33b0c497d7363b0583277ea9a4f69030897342cb1bc33af727e23c8d77581e2a53a3b55ffdf4b6aacbebcf780c6b8a8c3b66274cb36547a84ed507dee92ebc533441fff9c7e16d3635bcccb6fbaaad56176a502b1386a64dcb9899bda49ed3934347e4a7c65cefb178111b6d48c0296d0af11cbefa82059f01463766b38e90c494c3364c660d8a8436cbef8611968d47d09d95b4d0b7169c33a74cd52aa3221b28937bba823df477763de9e557c9e7e58580680c89ad361dd8551606c3abd99aac743d7921e58ac266fec8b1cccf464782d2db98de189f61f59b9870fea3373f9e821315236f3305acd3e7acc8b3998d870b9c38aeceb70d24405b1a4e339a850ef3d8479ab5beddd44c8edf62086d6c5f840c4ba8d574935f56dbf5b6f4572712269ace6d87bf91e49865d67640a710a4fde33c545470d25a137ffb62c05f74d37ae4291b3ecc505670d2e3dbd6b2cdbf483708b6bbc8c0fe7d57747981b16dda769f40c1aa1c55f4494aadfe8664e66678cde2f8f293573d2610ee9c484ce17300c8a69670c5367281b9b62942f98130285e81ae9a1a85f080a68c8c067a364ceea388339a9a76fce238ab31340dc604869dccda3eb5a5004a20ecc52ebf011696023059a24c808bd9cf8a94de357f33a7abfe1891e878b11d6e4af7b35154409741f1f3b02d5fc11863317a045ab6c0b90e6e30da2e4c7f8229df926b8955dbdb26268c2dc5c29eca7ca1363b7bf6dc5b9064a2e3bfbacb67d70b2951d59188ec45dbea7fed5dfed22e400815bc82505b4870ea5029c22095d5afa7150f3e1d842ad113a4766a14ab95ce4ab439ddc2a38ab63684ddbfe77ce91f9743756f0c40419310ec4c0a17f3dad4ae2935d4de0c881186d6cc76ad629ed58a3d6c1c91e273a58497acc3597e54d2724e618fb926fb1ef6a5a52094e5f8ae6daf9b71965e8b208936618eead4c6e554de32ee88a70a643325b6de12c94fdf955f11e922e7b89b50988b8978859e6b19f211032fe711f1dd2f092cbd12e366903c28c4f19f0f1495af488bbb857df5540534d6676c6da197da1082e8dafdc43c839abbaec3b3aabb175131a03a5f622438dc6d0f93ab2f98936bd98cf5a53d805ddf92c880cd101d96c9a003fbfac1518ba245b820067bb97ba0b8760960cf2c1dee9f792564be4f2db06ea8e9bc2cf16fcc4342ac91b9ad1f16734d9a1e73fea9642625b764dc0ed03ec05bb43f41c4ebf7b1ff1ce6b978aa85801d37ca814c98fb2b7db79c129db6ce5695984aaf177924636f426e4b11e3b8daf5904981d62359263908a32091e88703428f83e801f907cbeec8590a8870e40f66d88307c922dfe0e0a734138dece3bc15f3f7c0c91afbcb71f22d58f47c142da03a8adfdacc00405b13139dbd94f13eb80305f4410757755613ee3f4851b794025265d369a8f26cdb09d74f179dc8263e2177d42da060e37f40243b5f8753815e6c11895d29f7eda46a237c9c7f747260b7fb1153212806e41d49e021abc70fd682335eef0b481fb991f3093990ff1f6f63b8b35849dcf0491af16b18ea16ce5d24568143a27ee907e1e060f49215e078c4a85fab9aff21e3b41ac61c967406237f8333678ee44b13f3538c5e15b6a0f82acc60c08bb95d3c6d1eafbf4bbb7ffc4955b23843d3974eb73e0287a15bf192bcb7fda78735d1c0ac910bf0bd204756557aea33135d7349b4f2e34cdf4fefb6d60cca4e38075144bdcfe27a459880fd3d15f577d663a32798b4a42480c15da8d14600ae6206c3b79b4c2a6a67cbf36795bd263446886009b2ac03c9466131312a73235f9834728488e9e6546c721804464bf6cdf045f6db396d577bedf3b4376279392238100f8c0340f26869e80e3a6bef95ae85e4918791e27f7685dcd04f1f7b9845dab81d6c1960ef1f09a719df4398b716a04b68274cc567e8626652030aceb2a0f1063f3ebafe65b8ca95898563577e2ea91cfb347a6487d295e651616c785f89579c3f3d5d98d8a6695094d2e54b69fa994f69b674edf9018c7d0352329d648e3f2da5f4b9ef8eb93a156c9443344408d2e1307e87070c93e8f8e28e76d8418fbbbaf85ce1fa103a7b0db8887da28bff58b9031dcf561b4b0e9859dd4d5719166faff2b1bbe8cde8ff7e14888ec3de442511084d4e8206f67bd9096e9911f62d4d54cd03859d5bac455698f36ca9723815545ca47ba628ca90ccbc41f57bd9d14dd2cb6d932a9606d05911ed0e62ea1be09c2ef5edeec88e2647ca4b74cb5bbafdb5c3cafbede72010b208011bd732adde2eba25188a88470fb14486f069d632c00beca0be243455e1a05e250b9872fa9936cf4f2eec0e300791146e2753545a121d03ed8531a65132efd193b445d87187d2dbaa86a246d1e6106871f1068c377e3e09eb38a1954180498ccb9432e47d2c4412e3cc2f8ad2d3d1a83b2fdf33ea18ce1da4f36161c07db1580b3446b1970d5cae7f103921665b60a0aef4df17336e165b655c9fb4f082d1fb17a20c9d436d552c5784774019895a467e8c9c1243418fa88be3709687aba69cb24d02ca8f117bc8839410b3788ff93233b649b09255f9de2c605833d771530eef5fc55dc23f517aff2449563b4df96eb8d6f0b37bcf876eb5d9d62c215cd094184f969cd0c86509e318664abb506e6e86ec9b908ee10829fe4350fe29698cee3ad61d26e9a08bd5cd4b5392e7293802b86c29f9121ba68b126aac6575013a20f959d7e52e527f1966a3b78a604fe3b8456c22bd619e64380864c88b647ac98476fba174b1eada9379c38459125bdea5e50c3e87102965c26740139edef1d4c8a0614b35a3a34fbcca96d6eebdc60ba413f415c7250c1a580d327d91801ed3700d07ad1533350214b69558e62fd1a037d44735c2fafa6ee2d338cc2d10088f3b764f8c47bb730a5acaafa122be11b0f7cf78dfc255bbea609841943dfc9bac6c82f7222c4a07b008e8b0d69d8dd6fce702f57c25b94882683dd8a58fbad799e8baf0d356d2b92a6170e5ae789d6b30543aecc409e22ae032a99dd8c386de76a44b3cfe3f4ad8cc387e405192b568f14485b77d0af6bdca9200b1c6325bb2e5bf201ba2a18856afd34361a63a8492d1f91702c8a64e0db48fd03c995964d91d09f2f5a2bbdf7501a96ec30227e5afad7143cadc83e46918c9f3b83df866dd60b5e24a13119ffdd0855ac6d8a19a95759d8ccbcf19326ec2b0c69039b979099e2d8cce2055fcb2c3b8c0b03bea58b9f0c7fd19cae0b7f0d6b7ea74ab36fd584666b6c16bf352fb0579601de551a16a54d87a3a059cba00aa9740a84cbea883d020770218d02eac20006a7640cb888c038307028e54c16102565f7017b96952de1499a515cd47209c3887d88e8ca8f7799c858dd0ff299026776236bcd6f15f020c85bed84aabeac7c19703817789ba917b5830aea27f0d07295091032672d6861f3685fdf355a8da64edc4314ce315eb97cb5e7e0283a4f6c5d91b09e55957403ee7c375b9d88a74b2103dc745be54557366e54e97be11413e103bbc112fddc4b4d416a151ddc2616d6d1b74dc7b1e18e19348b494f52142419e2567fe869c668d205163680e7bce0bf7b448ae122a05e4565b409cb64d3f92f604e333eb3be6a76e4699eef8e2531b8eff4b2d52ee6538f5fcc1ac45625413d90ab48d4833ace3da5697dc0a318034fcd0b2fb0be45e3db74fa0b90b61eb39b35c4c81928c3ec89312f47c99e968599f031a28bc46862c17a03df7441afd52db894808ae10ddefa1b21da2e0a71814cd276bf30b6f106d61849fbc45879f6ceb7e3ebc3ea57b3b13ae834e542e5945d207ef1138658ca51715bfe730d6549e54919ab914e797ef580fb3894d89f999e587554ed1ea4c13a0dd08b40f2370ea633e1d541e3f6d54b4cc5139cba662ac7b27c52d5b7bec46867ee7c06da6bb54da07230abc29da6ab3b0eaded2d5c519850ab0b16e5c02f166fb28f040394814e9bf91bcceccda08e8b21fabd6b68a7e63e31de3abf09ebfaa00297fc1a7e402ba86562d9da99b1c18901a7875fa3a5d5e208844d2373cb29b56f318b26dd5a17f6bd0b421f66dccbedda8065c849f83c278151dbdf6fe850e75b69763449453163df2f3df5a29371c187acec0a914753b62cdca8fe874159d46873384685cc2b7250564c09b1227f2dbc26bd916883f3ce391a9f2968e1afecb69cce4bdb9bf7db740d9986026c2bd56ef695418ef09a6bb88da1ce0ebfa5f0749f04d6860992a5a57c3aefab5404e626e81ff4a944d02b2dad2ee7768e09afddc9d8aa4c12c7d91cf7b9cb86c6b48f761d66c48212b7abe2f4a2998ad4f31935349f30fce7902a09ed46402e193229cab175a6fb66765178ae56dc4c431ec004493d617b30f00daf72960426c0506bfcb0adc5f4c9b845989bae90c823b511565c8e3059ec96e9c0f06ae70e103f0ae2f99ce9cdeae00efa9185c25e55945bee93b34e3bbbe1655d9523da920324ee6a1922b7661fee237531317ffdda2032050a8776c7369a3fffece2293969f1fe7977b2042dd4152fab3fc0196fb9b64cf11c59e536be7f1647738909f373cb1bf69d1b539679288e0a31e89f454cc9f300fbde2f6fe8f0e2fb3f045ca6a216682b71faf21ed4e588c3ee07a604579e2270d8aee6fd54be44554963c48fbbc067e7fbc0259e5485ac10b23c206a9dd0faecb079628dbe33d373e3b7cad71e7dbc2bf523d27b30578add917c7b289be397ed95d838e67342c116f5f8b01f732b806dfabe6eac34c4d0b1c64bbdc779209f74627434df67487d726114c792658fbf6beb40e608aed517048c39160fc9dee4d2c81c8f7676abc3eb7f8290302e7e76d511c637803ccda72f98eb22e6698619ee531ca970d7d5004ce6f3c6bd0caa83ca97a5d74f31faca59f45abcd415023c22904e7761ac677329f760c6f5b2a8b3ccb70cfd5b57c674ccf5e8f63565ad2231ba2e25e053137a7b0c8863c17fe2b140ad13e8fdc80d12b46e56a81795a45baeff787a80294a0905c225f5d3f51118743fc8ccea159df5bc1cd9df7fa5a0b7201e4436f6bfe90cecb98dcc3ae8e51318a492b98ce23000eeee90f1cefae11cb5eaefef23c1d48f7f2b2b09b22f74eed6d8ff3fcf78c47a780b43c96ec05c2892bc679d6b5236a87083bec8b31c6a17647e9abbb90e7a7d06a57c900558fa157116236b2e8971ac65abfc20a966ff55900e9f5c161262ef4c6a484640fccc6b868a92837d78b60af1084575de7f10243d3d095b32a5a6a023561bec9a137d767e787621f8b966f28990031c0d17ab5cb82aaeb901201883d7d6fdfee2767a82b79b06392fca8bcfab598f59435c53172293c3989f952e518870a511b32e55368445497df46e521e1dd6d2c846b88f72b6ffdd7d0f183779913a67888f8a8a480a1af0f99cb217587b55c5a3688512f7cf2471c5ebc5027a0ed9125cd3c9a1bf0ab71dcb39ab53d070ec97314b55b428836ede34b08dc8c6892c7cb46ea64f569e0c7049d23e43818d621c60f87c2a631f9a74287e69f8827e1cc2bd291c1e5de39c013bae6f0fadcdb8886e81175ca5d5915b3aecd8297815a50978f6dea42d780114a1796ccf6f1de00bc65ee34e118a7ca9da99c123811b08f9b4ac23c7d2fc40f93e1fcda593f51aedb04a205d5ca8326ee70b8ff8a015c635474dd6faed0ad7b92ef797fa2c7ef8b586772c11a1d4cafc9df70cfba72c2ef8a79ede55660461d738e64e68c43c872d083d317fcb6db1911216976663743b948553a010bc132dcaafd0416043e7862b3a552f1788ddf7bab3526044f04b613bd37c7813b9f8a7c44b1908e03b1d67e8704affb49b7274f112b902daa870f7b5b4b75cbb80fca0ca8484c7c561b9a29ba9866576ed82ac8b09568618639711797228581e9808f0d0eefcdf167b5ef064c140aaeebcbae147bba073104bac26f70aea5b683aa0e9482557c9a8062c8727e540a2162b9d6630f8ca413e1cbf7915f4c2f1d120f51e2e6188837466fc6cb3fbe9994a70d4d7273f8d1bac809201b6d18184376a37e4b4c7ba50beb2a676a909673fea0899dabfa178e84a2ce6849791ee3bc35537ed617f207cbff2c2983a6c442c84e4f73b22cfcb3d89b768050c72926abfa4cb2d541cab646c63ba5046ab379e72bd9fdc1bcfe1ad94a51564f9592f9cfbadeffe977b2b7b5a223251308d8e0a84c0db78b0c5e4a6f045bda64e81c637a74bd8d0ec91b69601e82a3337c6a612a46fccdc8b8d44702f0aaec4b150c85353b633ca6e6b7c24e550bdaed9c63cb7e6567c43c3c5ac51a19ed94c8068055d57bf83b1c5302aa2068f25a75c7446a7ecbeb1460b45bf4c7156f888835548f98b74552ad02c3787213868105ca03a7f2942eacfd1bf1ae131a4f292350bb1f9e0782ce060f043a4bb77b3976952166a0478558a6e1c05506da4a2e0790a573d61d6d3fabeba4aa79eb004d2f23abcc48ba2af941f71931b94f5e171771d6431db650de197602b270042dafee493848649c92673120dbf772dc3fa137c10b73efc91f945d73192fe75cab806be38f16f291ba7daa64d5957886c5955a593147f2eaa4f9fde7ab732809be5a4218c2d8636d8975facd11f055d01fed57a902ef1651c8e862c4defde24ec9f65d378c236de5c873013cb9a4f2d2c22ec4d95268a105eaaeff89d49da644737ee79b1c6378aaad1498e2a12cb261feaa7b12d60a25c9550c53543812c683e15f78e2b1aa86a5c22224f320f23ebd8c728d4709ddbb50142e647a25865bb7cd8aca7e3498ed659d5b8d31001adfed8d43b801f80b0cb90aa516d687767d9746e3a9b1ab35aa72be3aab5dd7abac8dc44940a9ab3887b867b3000959cfe5c838493273dfcb70136e11b01831251b5f113ca03115e423019e3658ecaec26856b2e9d2a0c4adc5b82f951df5b4d167c68ceb09cd2b3fedb698de70290525ee52e2356047a819ca57505e6f5a3a64e8e7c9c25cdcae49723a9e8ce46f9927291c9f49d94315cce0dae60d6530a8f27fc0298b212ad3d5feeb56f1a763a040b4114126a518eba3b04f79815fdec0f9dd8599fa41b2d83c6940269b1b95457b454b3e14ba020a2c71cf09e7e49046daeb18969f26eaaba586580278adcc09e3482f6ba5cb2754f1c2909b01ee29088772165c07a31f4ceed06962612b80bf006af6d1a98bca44fdce757de31ebed1d998692a02947a1c3fff1b51f0e01f3a1976409ff1a5e6fcaf1c4fb1cc88baf683fe919b7fe6d94beed6a8733b06119fe33abd8e4713d068dab300994b3ea9b994772a620448cb2debfb9559dcfc5877252e3dba4d62d3a128fd477efab9bf1a35422e7c6f71171093f737278cfc08f4b2417b5c7e9b1b3a85ba871bd4e1ceabe3b36b92a6199903f02b665f4444ebbf48dab287d552b510a41e4be5555a2673105917616288ce6cae884b62dae27fd943a700ff3f77a272573a02492606757d5b3e4ce2d24c2f07b0d46f282fbd5d2cd1f86fd8aee2a1bf7f16aa7a3da5bc65b1c1c8a58ef995bb5b3dcc944dfee608fd2b4b1b8c2aabb319b30bf143384c2b1c172a7d201dcbb3ed2c47a85c3e198c70f4f6a28e252c35f8687328ec12c32a26c31efbd3cc650aebd4f488ebd70e0c907b41cc9324e5e06c3779eafcde51c5066ea51794f7378d56642d7979297b869f583118e32571c7286d5d0830db0f8620c217f5294a928ae2af74fd125971e22755dfe769724e2a15895973709f8061de1ef16c156d45cbe51446b43f661c5b9e8d4e052e03c3be8fb9f70f0c6f24634177a4ec841633aa926fd910d248eb67b384543e8c5e2553d1e66ee416a802229dcf5aec46a26b22bebcc8c9a90f1f942cc9314c826e63c66f289d914e2234296086f065063a668f81a274c19f6462e9285ddc9cc07c0c86d41e0c49b4d4b5f90c817a271b0f861d53aee9c7d27831dffb2b8c9e6f23e5e67f78695fe3469dff49f339ec413c09746bfdd32d84db1810a7430cf05f8e62a52a2d6a20f59453de4ca99e0d25ee2eca42309597653cf391670f2bfb85758a6819dbbbe49c2555fedf01b5b67a5abbd49bacbe297f9dc66c01f9a1c9df499eb427812fbc618a516f2a05c4a23964ddfc45a313e14abba6f6235f387498100c95708acc0ec531c5de1d0fe2b185e83214308c4bc4c805354f11b945c138f7d95f2a9f25da499a84b6f1a2d750666c8ec2328d018f88a922d29008f12e91211f75cf8ab3a939d281d2ddf265b4026d61c436216a49da1cc8385227c6a60eccaeb30e4ab2499d92a08c552be4a9adebbacd026200c969cf3038cc0996d73c5b6954ea9c9fb98d47c0f517eb9ed23373b5ff13193362c95eec823c0a3bba8b3436f01e24886d97d6cd37f810f39bcddbf4acc7058d63ca89b25bea531e542bdae9d306f99e7efe0ce9d6922aebe6a3892785783013343446e9dda4eed19ac597bbd9f2942691f2bbb84e5d1185bd0e63d0206c6b0bc84308b43daaed701bb010acf7bc9d8dea8b577086d8baea48c6f57261664de473f05eb9c5899174b076163b6e0702694c72173ca7130c24c62c522caa2f92892806f501cf1ceffa093bd519973ce78a872ef59088dad3e403268fbadc6d3a333f3546076d4b28a1b5d45c60e7ae51d5becd539ae0097896ffa5f628a20597497c7bdf241106c76a5579b74f59f9378a536297501acef12dc6caf897813725285a1ef8fa198ac760d8f3c862d60fee34a0108864900a997ca43cbd77fbd82fe226e611a6f282eb84d5fadd437e9ed6c0f0eec75df10f2f0ff757e88f917e83e82519d5bf8755ad4da9d188d4fd56dac0932abbddca369a8f7f62340b5600ca489af1dfce2da0547282d4af177fab44561f48cfc106e90b3a12c8b13b7bc6bab38b48ca9fe1a19ee355a3418f575019b9ee65e65058d179238e8d2b336ee565b42f07249212d4a30d4760c52153d55eb71bb98386b051c3515f430af186cd6b873f4f4ef11ce25a0c06b78cf9ff88817b03caa1b221c1e7638ce516cd1bf6fb98a8a0485160b8f7345203f3612865efc207ab2a2a622446f99d12df500e1f0fbe8902734bfed99217e43dc25e057477d0dfab634705e096addeb64fed6b952e7caf4e96a4333b87294ad92e3c06abb9555ef6bdbef71a6222dd0f2b04e215c2080ab704c506ad608a84e75f64f08a9af63f41edaa5e4b5ddea11d45e3eb5e8b4695194be16b2d32308a84e226674fb3f5a2105fa7e533116071e2e7a324a11768059b9b60364b41919a47e874199563a1f2dd91eb975e996798221cc80e35a4891de89e1958edcae822b15787cf80dc340414ae4835e779c3e8515cfe74c9e974a8eee69062c36d68da564eab06c5889991f0d93e58734c219986ebd766eaa22cb2b5777b9e504f94b33d4b419fe7aeeada203774421e4baa08bf6d9bc0d071d71e9d12ded4ff6384791c33aa81cd59bb93b6556be56b5c75687fdd01b6c1b9929113d0e717c127e4c9ea031a388551581216f9852e8dc1ce5d1115acc7cb7f9ee3f643bd1a8cfa773e7921fb7f98e3c97643f34d221503b789df2960513d47c87aaf2d9608e2aae33482e238b587864abdf3c2d064606f1d1e5c20eb165d32867c51bc97806f7246a4f931f61ecfc8eb8ee16b95ef0b29103ffeba793da684726989f9e06d44eb8c20e2213c28d7bb6c5faef53980b90c321456885e8ec2a80e199aade867906614706fbaadf27c4c690334f74595229e83ea5e5241e43c28b48609c89af55b92dc0dc8416a4716cf3b3e2d36d0a82880ff0a9f7f90e7e43e5c83a6ce7d835ddb37386d2c1481e58daf4d77b2db30771fbce54d9915dc523c129eccbbb0017fde06b00b52c33394196e51ba296100adbcdfa4eff65ebabb24658a024ccc4cfac0e614fb6cdaa6a55c355f6ca1c1ffd71190221abe90ef3f14db3c66828a14d5a4d343d2a8958f302ce4a8074b89b3712fd600deff979cbd0e9105f151adcfafeb3ab446552d4508d3158ac885a7ec7eb9afbb394dbb95c52d0b07826ea45a9fa14ab236b77d11be6defebcaddd89ede95d13eadb96fce82fcd2657c7672c8f83ef02ec7f37e636783b4f06299a04197868cc9be2b72ed5387f510ff90f5493371645d084e6418e2628345ea0c7cdc4a384f249f721fb388b11e506509d4d51196ee1c1e7ecd22735bb043cd6f5a7c16da4b28bba02c94a67d02275620593e68b54b5299c02630b95990487bf5387ad7e6d2ad5c01afef103e4f1046a8c60d9cd69f12ecc0ff1f12fdb2e70cac00747bb88c79ac944d20af494351484bd682346add20bc9c493a151d350359f750ccadd5e04835b166ba3176c807081f39d6772bfdd6bbc040ab7f5e7306194405918203244a4b09a3552bfa7830b95a547a68b2a515dc0347f5337810d987e2777776f51a1bd42803c6ff20c7a0ab699b81a47ac42647065638a6ad18c31ca91013c0600306131c8d6280162d7f65338bd7b418640c6ed100756ee99548583a785b713076d64ac4c76e8be6c32126453c877e6ce3193a4c7764b06124535c06197376a787d9e80d618362e45ce19d289aba50388fe9f833b1a97bd823a8298873e993f14d4c2b0b30242dfd458dbcf0109ee9774424a22b4c0823364a108e4504f869c40f434247aa13578c5cf558d07f53b728e97013f579d0cc8836f7acf6aba553c586e26d4104c124471df1bbe7b41844106c2d93f10d02e7d20550ca3975f3be55aa0b5b545f57913a9d10f73a6c676bd2b1e05f99533bddcfa4844d41e18ef3739e543b662d88e928f2b55661566a40b868514545ced0a1e0a430381ddd42913b3bc04264df3681a5fc60cdd010375e20c0fb38c385350860f0a0e8c01bac5474f5a9c34d4cb8b365599672532852e22b12ae06b6918334a11ef617d6d2ccccec2e2b58c72899b18d7ca57a081e1fbb74a8ce5c59e60e7d64644d506f2923a76e1943ecf04a051ae8235c5d1b2aff9da32b7d2f35103c9cd019fdd926df8151800f8ac5e580e0c54ba2a4ba5c1124af7e85672b49ddc6db6100c5f727c8bec7138e71dfaf65cc796610f9f6c15edea0f99a894f143c9b50af72d7a603025858b3ab480b3691f1c1f6e5ab8f17fa522d22cfc40cd147634764c1bcb34c7b9db83d9e4f0c230fa82ae262f06c981b8d7d020bcb1283ea3f61c6ef64a9c9e7b24b64ca8fbdecae95516b18eb9e003fbae825be2d0bf1fd5881f417b9e6e46b34a02103d7607ae3f32954b869049ad6183e1eecf453c280fe254ca069a5d5cea67737a089b6400667ae33ac5c545745dcf2c1f44250d818cd0f87ba9823478d39e7aa4bb70827aaa4e1ebe9c315b4fe0bb8dcb8c205f0f3b1348014555ae401af621518796e37e52941bc56fef7423d2da5b88647782c85e8868f5c88f6040d0bf9967658d10121f544a099692b5158e43f91f4b60f6976aec39f79c5393c12b5057c6d695e44c21c089457df782bca777358d8ba45ec75bf50245ff4c10552e2d7292e2f79989cae8a9e8acae3342fb2eba5399d4cc3e0e757e68ecb3a5300385509b76f09872ce71acef8f44d7a45a35d5a20e373112aa0e90d20a07451adf65cc8f74f55825164ca5f229ca894b2e6eb89c09213cd4cd1f97283c5d5effeae5fa595f3ec4ba24222fa0bd647438ed252bcbfa24061348461d4acc27f8b626368cf31f7fb08220663d9a13dc0019122990de843f865da011ae1dad42b8e4f70435829a9864c20bd68be0da2b44b00c9b9415c23832fc32439e952d47196ddc9c125ee2a688ff3ed15f4cff1fd3f0ce52de6013693c1ecd752b3fce53c2e404bbab91c9051258c3e2dc74a299a53a75fd89bd24af5dbc3d351ab73ed0f92f89c3c32af511fb80d638d22d080fc0ceec86b6056ed5573985f7a79594b8002db6b32cb54cda29c918a2f06ca112570a93b9350222dae8f8ff285c0743320012e2a5dc2991babb0eb7982601af160d3b6a6e48685bb69cfb5e5154151eaf2d7c79de7b72551f74e9002a95c9679dbbb23863e2760c76d73128734aee4c7c4d9ff0ab93be22df025778cd98e160583b0b42d2b691970d5fc39b3ebae51dbe6f3803beba9137f09160936945d307d3b49461e47d2271843e47ab9d0d793737fb7075c45c2382d20d348b4be8182f6ed419467be513d5f0fc6e0e39c02603933b5b07938762ea24f15a6519e6076b4f9a1f1b47602d88dc7ee06af5efc00f2b0e60d638a41482797e38b2f2637362938545a84bbdbca46a1a5518daedd2deec47c908fc1743299faeea4c9fa13a547430474dd544400bee5ce5cc9d560070371d250e4f73a6f2580d08c53d0e54251f69687e27a4c34615f6ebaddf61da06b6695194417f7af6c9d98523a3d014fb85f5b007acce8cde58a79149a7ff0fcb911ec9a75ffa19f516ce6a606accaef2b9d835b528eb053bd32c9ec3e4949e8343e81a84e1c515f424f6f0fb21fb2eb04d4359bd2888448e3a5d594703f4b9dac6ad48999ca7368fe334f7d47445b09faf35a67eaf78b4357a10e13244ee4c8f70411d929e1e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
