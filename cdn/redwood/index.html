<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ad19b478371d7a2fe66cafc40eaba88be2670a28da4fb5f79790861b55d29b69242a2a18ad0abd40e6817e67bace7d1990348379f6c2991ef2df7f4206e2a61f81507f623037f0339c5aaa03189085dc309ef440a3dd5610ea34560597c065460dbc46bd9d96a08783d8d88e1b303100fa4519e7c1c3de953e533c9adcbcac08b24cf1ae664bc9bb64a54e28080e6803b5083c4f9cbf5cc6169dc9027671db07f5cdc3365fa30764f7636855fb8ffdb36e5a09c0159c8df76cf77cccbc6ac892a6f1d96dd2f9fbeaea0f466894bbf97ed31a9c86706cc17aeadce229e65f85d0b48f1724eb78e1161a2660f3c692e7edd84f1050e4419ff32115576cb3cae891a0020fbb3aacdb616662cdf7cbcdcb89c8a8f30559461c28a60f52523c5523311f18ce10013700724ee712b1c3bf56355495fecaf73bd06ae12163730bac51fa34dbeb9da1ccdcb671274a2464d31403ac4c8c7b7108388432acf508f17dd62739e56c8057ff148f82bcbe03d7b9b86c39dbe31b2d8c1c7d8a2d81e6e68e819584bce40cb4c85d4cbd3a28e2501183b04caa474421f09f7d475c0e7aa88baef9461c0d22d999fd160a3b57dfdf3c6560f656d40c7a77eaf0f2756f0f5959229cb056cdccb3b935b2714a59f32ef1625892da200731fe3a91402e3c2725749bf7aba641dd1ecafe42ffa6177e5bab114e94686c8e37dc5364e6564871132117957af79b9dc9c9f1c33f83806f55c89859d2ae1b713ed6a8cfd73a23133e5e5a863c20b7f3b889fc5cd6eae0f287fb26dbd82b9653ed3793534eadc27be290a6182be3aa06ba0c2d549bcb61cdc6e8b2985f65f3eb11138566be0539ea2189e47e795cfc509817cfe6501ef4d9ea24e1ea319560ad41ab590ee8c337af36c4777216f62e52da8be85b1bcbd838235bbef907105250133b565754a781e8e533a505b36f32559deb5909bc075bc225069c49368aeabf5f62a5fd701d39a52d173a12cdcd3d100bca3fd46ab8200b259b11e0e55298b4034224e224279e723cc35e92d5a9dc9c82c0e4dabd9ad033d041f607f1468f19f0f087b58c6e586c71ebceef5f53853eab9481eaaa2b2994b5bca0191536fab5f465d51aef725f60e24bad8a7cb1f4d050966d1bc4b28daf4e3c2d0bf016012752ae4c41a3f553e50ef962a473af8cc1e2d9717e0241090278166429d71622c5891b9036f1d2ad34717d229d9cbde054b50837177279ddad55dcf2e24a2d9f9cedd19f5bd0ea4e97f5f211ca4420be98ee58a6638070e6ff25b11715af8e6f74fe814bad4374693e25b5ac12ea4813773e10093b072981905d23639c5a23a27d4cf8f0b4299e37c7e1b16ac2b95ad3e5e8f8fd8d71cbc7893199aea0be1eb3e9f69cc0b52f059a6b0be164ddb581a68fcf552021aff0d492d87cea3ccbebe472c2c2359e83d00e6091dc52bf1e798f7a2823980a18a4e7f7e3ca17d52c852ba7cbafd347a6a476136cab68eeb0ad8ae438768dbff3a42ef31e65e6e3823b4a64ac325d8b64b99e4099c3eca7a94cc0a7f20a6988dcf710bc6f5d23729309f05ed409d80bcb160e785db5d22ad1d1b32bbae8eb0545c1fd9397abb669ec8edcbdb0368e11b6576e5557fef30d3a8a42c26ba1024c3ff9c15bd556a482257dc9a42998f86697fc266e201af7b2fc7f998c4481e993d0ee1f6d2929c14ea1fa0077cfb9723bbd9bf578e584dbad157bb679a6e79f0b0acb9d0e43f83d6c88f4ce2040805d73dad5c74c9a4310c45dbe124e4ca7f582bf57148a7b5886f24f67764c484b0f7dfdf26d8b8522aab4db199f1a2e1e81a756113998eeeda70c328ab935599e5952638ad0da4e49c1f259010ff158d8cc31011c649fe0bd783cdff0476255604005b90a4e90807ea23d416b76265cbdac0cbe289a9a776d1d390dadf29c2f1a4c51bad6deb5540eeb5b41fc52cd54225193f4d2ee957d3647a6cca5b222e77fb1e831c7587745c24fd5e7b2a590e8cb8cbbfcbef61581a056b839a34c78a77f21a817bb6566ca572eefe53a4096c03c71433c0f43dc89a5989633bcd24303ed4095dcbfa22bc47d6ad3973fa696b3dd479b6e7eeae4aad2665c854168bc2d8a3e1eb0f863bd1be6fa6d239353e768e1b6f088884b77495c1baf7767c9164fcbf1a9e66e1e83cbbde765506868e39b8a539616b084b48f12c7bd8524cbd3f5211486c95d4ea23c6e0787f034699904637670b958c82ac4c63829d2414ae96d5369dafc2718701a9b482440e8e2eb3590ee198e8992a4387e9c5cc64698e361d2c4da8aafaabb9f79c353b08fa792cabd52f71784a5173b5b0902c627536369b44e1f5b1ac8ff50d2c2c59500b0cafdcbc151e8801bfed4a210ac3f009a31ead0014e80c30227d544202aa7ac2797b8483c2a82807741a6b27cba772fb8aae1fd015a6354556472bf00854c16ee60d72e00e749b61e2c05a13f6a54f25a0b22e03260968f439fc7b6564ecb97648fc44c7dbcb1f824ae69d6458b0bb2468ba9724e593d0d6278fc61012d4cc7645df819c45df1546076fe920ef8350f4d7871be752bd3955bb994507385101ac412df343a9a4cb4e8ce0b7951374c38349592a9ecd4dc80fa79bd16d7d376f3d92579e806122bca499bc15a84f6e1a8bec5a11422cba67f13834954fd91f435fd2f61bb90db7d35ae54c2be8c6cf8d6383fa97216d054c8e1bf5f1bf89399c7d7695cb91dbdadffc35996200aa5da79503fd8bef24b1adc07aa4448a6771d477db9233def3d2d0a2cd3a5b15b353e7fe04984493c97ede3eb86d050b444c45d4b7c5e6cd5abff9341c76a5d8bd8f74c10696f23c834251b12d9c03cf56d77b6661d9cc966b9b79620326deaf53b45a473c5d774bc5819f005b3e396e03a83aaa3adbe94c7c2297157264e120ee11b125cab1028d84dae0144cace427d0eed4e10a938fd8d8182e3c4a46828a116d39096cfc18297329e0e3c4a98ffa8efa92d7b2e09d3df155fb5d9ae557dfbb8c8e9d3fe206952996f512c8b03381b85de4ff0b3ddba6a09f66c839eb0aeb328709762fc9742b29226b8af57f0fb29ba19ba9300ff887a0e64f9f500979c16b0c68e5e7ee87bf3a9488269fa0adc7f8461a39d11810552453b55244938c208d0540cb05a97a5c0b2e065cffbe298a54451bed9fc19f1ad5c426b1f526d94f0c898b5c057d375495cf33063a5ab54a64e2ceaf553ede977548ea4e01c1726a5397c638052a327e88bbb6ac121e64679c130b4b01f5de530ba282d1ad422b701041df3bedb24e30517b5a8c2d7ec4908741651d5fcef92e8af9f19c34ade1324f9c1f3c31456c245873bff60de7cd82316d78c7b6b8ed41b1722d5d58af63c5b1652e99577bb53a2b57c1f79ca56c0280e245ef8ba960fb668d77991334396fe5baf71f581cde5903a1d549acb3e6efdf40c1f9136653b52caac0bf5bee6bfe61cb9ac9da99bbf410358de68847b6ab389aa8d3737baa0368ab71f957ab9812b349fbc8b9d807d3049e7f6f7bbc1e06846d9d254f4643cc04eed9f5ece34f744266e3dd390624f28f0b3cfb84dd265cd3b73edb68e8435de0d3318f7f50bcce146af96713bc8fc1903d5c84ae2c2cb40fcfcb9fb00f10a2269abb82fdce4a0d9642aabdc81163889eb79a3501561c2daba864e9dc0b3882e861c03587418207e11259a6a6535c058f3219a11e1a28a3ce1066ad5b7e6f725bf6d481c3a45b70359bfca102275e0dac57f9050b61c424001c66a657ed57d6aa327e388efeed2f46662c1b75a65370197ceb333d8a80e78b089f1c0f5cdabd971fefe239ff38b4f388e5d8e307df9e7ed7696dfaffe7c3c80241724a148d23e7349bd0962b5e8afea6a9b017d52bb2e42a2eea57de4f7ea6b7376e7b7f60702ceafa62e01f9c8414d9c2b438f6f5f468156c451477c470c6000f2e507503aa08b2a0abffa683fed62a2a13cc16f419cbc7666d99b2254d7b185ab6d35617fa10e9f055299f8b5a97fa5a81e5526850699e842c8ebea27a22c0324861cb664329a34dbc9683e77780b27368b3c9ebb0269b5ed054ee43593d7c50b8e5993ca4311ed2096566a147d1bd6b36cdcea0603c3b478e60457ce81e91796ad7c0a0c23a9e730798eec7e2effc58a9bcfcf9a60cfbb409b7fe14efd2f78c588e7b4dd4808c18f0813a0903e1c946faf8a3942a5604df158c6cc5645f2ea30db57721ce567876e6a10182b4bb9d6ab5d25a946b21f331d3d6c04d7b10c30d71925c7f30cd2ff9b33123b86855628b491972b6b7a42960d117a07da9390ceb840629fb2a22db2d2bc974d11e3424d8235c5cdf396e7de9f4b1114710cbbcc9f4317dfd7f8480fed6543993f1e37d8ccc71d02d457748cef7c72950da39c85e27314a62badd3d24eebbc9141c8b26844e9bf988beb33bfac542d07721f040789f15f6017a1ea0564409e9311a7ea43f2c89f0eab3b078347a1e0e0c08720986dceadde6d4513c2f7a10b331dc9d71eb8b1afd62d2d638c6a2d5ae5e21ca92c7c9d223efc1bfb18fc1c81c69fd5aa6ec749e6c9f9a355f6ab06d376ccfcc91a510c94ce3e8abfcfaf33024eade4de097612d29b60b3c41f3a1a653b9c26d7f4cb30b37e5cc8ea14d2066e6cbd2a8fb30715589b68e0c96919f6204615507efa5a1922e1b3322ff53de18c50cc07464ae90c4f1d74a8da37ccf84a9b1944a0d9f065a5c327733855dbe25df3db7596653578cb28e597d230ae2937d4b3d499e74d592ffaf3f58132eeda98c6d73511ffdead44ef17095cfe87ed927ff0b01884a0b984cca7877705b64a89ecfc3776f9de9382749fd1a51a251499bbc706d007ee5ca0a234c1b549cb9d48785a9a349e8bc0348c550b91c53ddc40e5dd2bebe60be084102fde69a9be72e726a315b1f0a88c3fafea2e3accd3222fd98327cb4a822b2dfe6c79458a738c60b45c7bc1ad8b90e60e6badbeec1a77d9c965d66fe32f7f9183149119410de79d0e0c4b6a56f9be2c3a418f23352740e7acd30358756aa880c8cea7faea90dcb25abd5836668cd513a014d41454f39eaf47e069f691864893a0bbd8ef7ae46a0326677d5d1fbefff62203c843370305fc3d2f909f29128c89af92d017668799a389e87bda09a799f6bc651b6534f638bb814ad8ac9ddfffcecb876e585bfd14c9b21aa4dacb1afa233795e08f83a4fe12b0d5e7ff6df9d3af690c98ee88fa89db6a9d6603cf1b3330908bdfe2f976285951385feb4f7c7d4b7d3914d8aea42f5c133b98d6ccdada78e040a48b6bef7f34de0d31bf56e20f905480cc0274c5bd7ed4c9f05824b58ce9edbf9af0202d46707e5aeb167d20b5cdf1b9591847c4de7dd4ba579ac010dbc7b40d254da11084bf7189832964b2947525ccbde21b32a65ccff640bc1e042568e3335d06ea1ca88881ef17ec15160faadaeb09fbda40af111427f1639c88579517897cb974e9ea7d2c55a469bb446915cbb8dafb482b44d9c321aef9bb349cc58218554bd80910caf6548aca20668c7d3357590697d0abbb6165fa0e89bbdfb9eb054973c85366604c67c0c1924c86217d2e708907f8cf96aec5983c5ee0164ed9a69d968a15605d5f566444e83396daa6d4ce805fd305d3ba1240b8eb18c01a0b5c988b9c33f122362c809d92a8411c03c2bd357de0dacdbe23e81c111da95147a40339594bea1f0a5ffec5d9e6a684d97d3bfe06b4b2e9be1992e17698e36af9f399c2b171c574bfab6ff87c632a01aaac19b5edae4cf923b19f9cb33fe38d4b73144af821e96138fdc3a469c14b6ea2f8ead9ff4dcfaa30fb01ee1e84a8c00bc52ccc6041a5620019c406ec7e5d7fdb267d16153134cf2d9fada17196d7f2c67bc148b63b40f8c83826f3de2b746b9ff1c3c11db9cd0e30e143e4763f41dfed4b5b725669e07e540dfcd4016b59c41add8beb68b00e443f46f190352bacb47cb152b20bcf157ac616b7c48ff81a6059a9b578c659dc2fade85b718db9ede5e53512be491eac76d3fda50ba710f250f3faaf1f30ed3873e40b92eb26b6b2ba3d3179d78233eca08c9c50106ff44dce64e4a8e733f5a6c11e7687a3c6832c7e84e2540cef003fec5bcd316f445eedae2b8f593d2cfde9dbc92d7d9b354b1fc31303a60d673c48a5bfd9e1b0747cd7e4f982463d54009af095d87c155be1e0453bc882c80d077a815a5c4d2444a1c3d2e2a3a1c24232c5d6e8f8166c541bdb8b48bbde3920b74bb23ab9038e7df82739f19e2555de4865dd659bd815ddab9caed093f804c4077b025b104777934fa92eeb958688cfa22d49f50afb2416d5b47624e7c115917e9ea83e8f79c94f4c6469a2c11ea941ca802fdf80c91a7f54213e9eca83ecd7b521c45505cad35ebe75c9b6926e492e0153ef76fad8ead316cf3900930559af095aab493ab8f0dfd34912bc56efefbc922876aa91029a9dd0b3b8cda0bd69c019bb6f9b816fd56133fbdb9325e64957762912b18ba7a06f32c2ad6c3339a54f5085331a5ca18e0029e740b3abace64e60805b26fa1f7ade194a444e0f186924028b78dc614cd53633bb10b788c4d7a924732b7aaec479464a16bcf347cc726c273708382a9de2693695ab90ef9a86ebfef00c20f8b463b4a603ce278657c2a216c93ed3efe90fdf9607d7101207c79eed9ebc0461c60e442ecdcff8412055910fd8d68199985fadf34a5986677d89dc79ac6dba9783e0489c4e1bc35c8e789202754203e37532657aaef5698c1688706a7e49f3a176d2548005327a22b5005ceb183a7ce866477dc3d1dabe407a165dcbe78e94b218f34add2f351f95114f31a19af21bfc06c528c123d5e7d0f99653384561747f5b653abc0c56cd3f5783bf722e36057cca74462db40ee2243e1331f4da13958b91d684f394a98e2da034abe92fffa0c453d4fa8020b39456bd1ec88116e49d25a655134849ad5ae3a7e510b3f083f49d935ab3d841602015f4f95c7d15f575ad69016d68398ba4c3154ffdb54eccca87a5c98a844ff466add84e2e76432575fb0c42e69f732f0b7a05fbd3cf13c7e6ed4f0212f9f8ec9efaf9ce5f786b4b411194b9b0aae6aa7119071e0e440cfd9316c91f7dd09b8efe2a6aabe2194f2d759be55bf1dddd43b48fbc8c87a6f3a0784b283306e1d56373fb1176cf92280f519d420ff282ac8d5ac73caeb17fd883829045b1565f121040f47830fc7f608fa2730db0a66c71fa197ad29fb937495ddfcbbe05c8bcc286010aa2e4fcd48c0bda61abad75fdf98f9c79d80bcfe8c05155c74147e7f0c66e6f58ad183cbfb0823028c50328bb1b63021d086dc62e006071bd52ab9d432175808a1686b9e423ca3da810cb0ad9dcf68da322e29f88f4a4a624beaa097c7a4e8074697df19a4edcc9810abe671acf6c99a90a0dddffbf2641d6d35df8b5eace603b3879ceddbb6f3531d295b74bbdbe3f2a498cb1eb8174da566fe62b1a58c8bc4c289b9de640bd3a79a02e5cb9d62fbee0aa63a56f9af4c6fa6695cdda47307c1b699ec47b6b00d7906483b4e716e82da1de666939bb8426599b2685cadc63b0a702e62f5554917050c7d13ecf727b551d6ece2c935385519edbe88f16e1f63a65f46abb7d6f19f36ab41c4e1b2679a1c5cd5de4209cb4a0c193744c8de2eb80c849833d26bad694f95ff35139ef593e2c1796672ff93178cd3458365c9d752544e4e0515faa4c041bc619fb0a55fd819998ae2608008cad82be9da14d243ec9b0cfbdf34897629bcb552d06698122e2978aebbbd7a1f8119710f1a5e3481fd34eff3af28114011bc6c6a884db7b2d07343a141591691729ac234daa6cb4c3be2f2915a5514d66cccc14d743025750408afa1021f18f5ca4a035fe8d0ea5bed8154050921875b18299acd2d46d049c21277ca14d6150925ce3ac69dde7cd68240e7c7194cef3f04f761c034066192b9d0213423c6618779281ce0b7b89b502c1c2c30b1176ae5c9a6219fdfb2ae08d1050ab832a086f7ce80e875bf275fcdb7641db20dc039be5a0e68a5be59299a7c6902b9c567b79111d2211f1b7ad2854c666e9c6bdead0416c148c2e99893c78b9d4df15b7c08b8fc335c56fb0e9e380902caf3b0baab006ec1fbd73b075934ae83e070da7867504f42ed263c70839faaf77fb2251510b99b47499c7ebe55249f61e40550d16814dd7ffd7364eeadd682aec6c209840d8b7fbbb7efb053114d6631bb874d7c66bd570e73d47450f8548fe41ce26881b246ea01b405881d99904dfe8e6061bf6ce9ef8b43d5613926904a8a88b6841287bce1ac4e06ad8d5471abbceaa258c4f42dcd95aab405c5d1bcdab9eae8bd4d463c22c89e69b76776f47726d9dfa9de632963c8245b588ea2014291ee63948fd5206f9326703b3a307f5555eee73d51d9a0e5676bbff8200f8275f5908f385fc7a3b3fb693990c796d4d268fa7d3c5a0da7590e438b892f78595230858b55f312e00ccd88ccb006b3a306178718c656461387319cdf4630e67420b0932eac950605bde422ffc00349669c6fc26a71534b17ca6be7b742254eab48033d94dbbf97f20c0cca78260546f7e32025a5b33fc913c41b53546e87607c274f3031c9c38f7d899d74ef365e69039d9c0a2a1e47835dc4a396917c20f9c0e1caefbbe65f230bfd6667a87f1853edb6cb51f8983e9ec121299c64a25734eee1484086eb370ea44be4a9299900aebe66e4995f49d081a3da476621724dc49924f94a0b42a5195a9b211e1d5e4bd736f928b84d9d9fa5606d34c5348c885e8f72f216240da2a2cfd51023ff1722187ded46096539de6da1b139c7fd3246b3f7607b289d70d7320aa57860add9616b50d736675a41e1053f54e4bfe645fb33235fcd413bc576dfddfe832bac34365c5ea18acbc5febcde530971739d49d2c58102ee1a6aea7482b80131497506b24bd6285220fe9136db9e4c915b1d8eba2616461e20f251d4d555af2fec7759326ffc01cb259340ff0566980c78a17366cb7b19c168a200757a5f4cd1e1e2a4cb985e156f3d29ba7490269fbc7d29c3ab329bb9147c160a51ab61cbb840905b39094a383cff9d91b06e9835d6d54ea89ac72c3eb45d173a8209d187acae244da43b6f26432f376556b591dc3f97c35648f9e3f0c9964eef2fa8e1d1d4e9dc255858e24f082808c677b2d394fc280d2820adc81ce3f3160e99b8f400f4b7373707efeaca42fe1ec2eee0200b9469222dbe6bf5ba7a231fbfd85f0d7506ff3b27d1ceff8c6a9f9945d73e6777eaa7a821593d1ff0a2b88a3ef60aeace17411ea84a97265388e3188c88d4defbb55ba5d41a13305c7ac284539d3c8d2ae4cb7363dda3accc4f6d7788d5473e6277a66f771eed60d88695a0b75c0849c07a1e2f8bae148f3c71336ec891b0ba480ce30923e9fc1cc6776d34f3ba28fc3ba13a5ca755fc18c104039eb4a290dc26cd64a119017e29c0f62d2c1a7168718134d2fba73f4a1509f401b2d0f7940e61f94c60a9916532040adf60f89d19b3c23fb887650e82d65fc1c492bce82700e5a37b4d92c1bf2a3061f6ff39ccac76c0092d20eab78f380f21ec640eff177af7148518eac70b00c583fccea06964b82a230d53bced4088ba06eea385face48afac9d8f1e0afa82a67fba9b6a38a2a5150e98f6069fd6ab897fdb16eef799bf3188e8c514bfefeee260a14dd9b33929ca46e217919a6b6bbc89ef7044a225b3d77ccb3fa518fdab0bb9b3b287d852d88c5f6201b480541cb46c8ddf66fec3c8ddc207d21b37f975c63dbb463499063f68caed296e4a39771abf18f8cf6a5d5a419b9dfb0e98821e4b0fbd79b2caa1edd513a02e396ec1cdd1781865a5f6ed7ff958592a6f8153567d25482eb25d050764775e70816b9d3a631ca31f23340a79221ed1940b79474597ca6bb5cde00abb8e9b2243256563b3dcc9a29cab91a1d405a7a1e1f300b5ec613cbb263054b77280e8a85ce9b5416354a90db514670803a270b917259327fa751bc564971c49d5076ffaa23da8437bb1f0997402b92babc6f6f912699b75eaaa604d828ab508b1d27ae83e09040d10df7f74af81776903cb4ddc4379ab96eff9976e1ac5ec684a92d2a1c7c9f2d548f8ef00bd9bb6f4419c356be254ddf91c165584b656ee7a99a2cc49fb1f4724cffa12bdee931e3a17b6af090a8b35242e82e0535e6fd1a777cef9a92a3872364af4787d63b5afab7583d48f95c04a835d944cf2f195ff10bb58c26b78a7e1f79c1e864b1ae99b3c4e0e05bfed1500340052d410eee6affb494d55ffa82f381b8e980120863a0abfede9e5cf5f72f7b7889884fcf1c3ad889dacb133056d23930d4e8198f7e6e4e918640f7084495dc9817d9092d55a6687b20110859d51044dff33c793a39861e626e14b49802b3fbfd4b7b3c3d772c4787a8bb95f7caccd0b655976644adcad88074c0395770da1878aaf351ced6d813e513c0dbdb15ca66f593491255eda4842a20d9dec529b8df20eb70d178e2b5433971fe4307b4de82e6711f468be1b14fd722ec9f17202c334ebe08d0de3d65e2d4b0faa3803e5c8a77b2b44be4b0a5494f46e6f3c3b23b61734d993d82ae8eb2a17f67cff5408f63c846097cb2ac3604afe1476973d353b0d27393b17f8759e322e913fe19a22799f645d58b3c943dc3a349c54f70be0dd653475b2da12defe398be26b8c3fb6e485f7afc4c4eb2954f8215a495585a2175441bd8125850f336282d210e74380fa54bb5404b1e9adecb84191b176b3c251622432dfdf2e7b1d61f28f459736e0b469f60fa9f9b524a453d3d4162a52d4499f847308fe13dbbdcf568fa1657a6fef06d03c9a0b8db171d06e0ab124471c8a3d325a588da24ed989e5acda4f18722abc186a97b5a853ee423aa0781777461556393eef0613804bca49cb692fb78ec15e3c4b88cb870d376b2f264891abad6b03e43c4c2d20176b25c9feecab806092ddd7be69733ac59ef9079269ba87a52e8c54c53b3c679f9d90af13811eee0d34918f2ddb6fce4256ddb9de335f470de6100b98e32af73389b4783375001f09f827667ca602791fb8e0eac3412ee77ad757c6d917b211043669997d1b92a88c05691f82ec2d0d60c9a474da6d392633e85bbf577282d5f177681313d2ff6cbeb127ab0632a82cad822965acae650092cfbc3ca461002ac6193f8bbd18a47c577231fc1183c0f29b492f5db124a0c3b8ab8d9799d2b345e634dd1b3014ab743a0dc9086537e1a2b6a40c677ccb67cbf75c962975fa17b38018656be01405f2cba53e562d8cb7292281650743d0d4e577366ca563c78b55cc84459d8a172b4ea8e414a365f3021621038f55a6a7faea3e21207e8266a26b3ec69e1647d4a92f8b1c4efedf276b17c927fb51f467ed7023c4cd4eba3e5f226574b954524d108c8d22ddf1a0bf512c0a261145c4faf7c868406a1a06fa8ca6a8ffa6cf71df661bfc5cdb2468f0edd467ad75740d58a1eb7612cc921c46b891f76ecbe425f5690752fa51f65044807287370f1e34658e65ba13714e5a5aefcf70eb1e015b8b51d06d2634ffc53b3bfc95f9660872590c15b4380a984c3d18f7b1199c25aec32a844c810df6fd0d43005d8e5edaacd7fbff2135b995255a689fd991a9571cee7f722309806dec019187d3b5e730cee7b677a6d18827cf149c474191b22afead9c2bdc8825a824622c779dc0273868d8f5f17a4329b67ef02f3eccb4954bc446400a6e9d15fcf55ac6af026a076db43e89fd282435b87109928ee37f1036bc78eeb14570fbfe93cf3ec1ba2883795197a89d3e0747dd807e7eaf979d9423933e024c6754aa690a79da170815bc9d414695e1d0b7c437398c2f3afb63c07199c748ba82b48c2d39c5d249e836e55f443d70b86b6260fd65ada4ba45020629c74b898a2abe889ec5fec0671c0b1a179a11c4708443a5d112d8cb7b7e80a1c1301d0d4f35de731e178dbc6cf952674e91d9e667c02b39e5f5c8fa6f02f8bfe7f465691499ede2099ba168cd14b74af3576042c4be5ab316f1f2ccdba3c6a47c02a267cc1218ba28a3c9f79f860ddda754dec045d0be54239815d74c2e29bb3f6e61d35a8d92262ffe909caf65effd1c5504e721054adb82f7f7a9a3e6472aec1b536d51e226cbd958396f683f9df9fc93049acae9e9240f956d6a6171bd08fa6d5b2055a51317298464e875354d04cdd45973868f87bd131c4903646936c14753d5dc906b682d0d4a565a6ab0bca1892838920f44cb457309d924e488729a53ca100f187bad9f8d6181c04d96dfda3c1636bfad326a611dbe1ca2b384a70855a863e51128842cd98a20922aef3d16cc1adec41e6b464a59dd5234e89aff615d500b586e015233f4168d0eb090697c46a1d58028d660dcedd2b328d89b63ec86b2623c197bc560676dd0c2c745cb68c7fc4594c40c4e22785eb3e99d6a5af67f2e0b04fe940d436da2b381ca43f10c441fa3be86be6392efdbbf8b4642c5ffcb39eda9314e35efe2ee649d015f0d63feeae10556170983a0951bf7499d2786b0703647a0289bd209b89d7357a54d53ea604ac4b5b6e032514b46ffba91e0e691e32ccacb9762950ee162d6fd514ea8eeb3d70dd9879f20edd99b9eb2afa05420b8f2c207148a8b85c13ecb02439123aad4ef87f24a61299e63f085f265c57e2ed0968299e9b780d3b70ae0ef96b068bbae40f6e3c9e89c0db1b764fcd54dacb20d487f74d5e7f0ffb7722cc7fcca3cb98f9e8ffd982b5fba51da4367997f8054fa86e628396e7b5355449b1101a5d90ef8825b7c4099026e050797abbc6979ed6ce0ab938b12ef1e41f5c26b179e798d836db0684a033428207d1e4b417400937c9db9cd84cc3b4eacc928bf5ef2b01d67f8ce1d0a7ed2b93e8f17e2641256118d278c31a842ccab82d2f8a33764c54829f21721d24e77c2d0a0ee0beb697280f2d6994944bd80f5140659f8f8d91855f6e4cc9ace310c13d080a42a237d271cd77026a0847eb10a035f0ee37bd7046deba4988ff96845ad98a08a3d125cc778cd63f138c0553bf79e297a7c4d9a2974235dad8d958b20702e7e9f363b66e3be8c8fd6d96de35459d351f86bd234f04777f6a54ec99e94aea646a92d8e0f7d3e56389d1f73dde012c93b2bc4fac485312811137e4c157f956f804ce83cdddc9b1fa31da261df0da727ce461b3a1eaf9d0d565e46da0366098a9533b1389835ec62536ad3440ebe44e1c4587b2ac11963bc5d7f901a6acb68322cfd31abca719787f42418e80eb8a5571c2ff2f5af38d024df7cb5205edb778fede845bfbaaeba3404af6fb74c5492067131b2bf6b58636117695cf78aa6f7715a1b0875e9789185387c62aa27cff3328da3dde5426118e2cb7b5e95f345b85feffdb089c7fbac6cfd189c53067bb764a0fa20e79e563e93a6399fc1d36ddc605819dfcf9afe0547e16a1c30635d48560f808eae5366f083ba137ebd9c8d3e21645141e8ac6a64d9030c0e32e331526613f4e3ed000b905f27e26c9caf94a16af697cfdc03959ab5bcb88966f432456ccbcfdd1ec96e40f6e3957f29dedde9ff0dafcc6b016575e8c93f78b3aeae59d08c6e59b342f9aba3dfbb7c22d82d3ff2b021d5379d85a0b53dc4eefc2b64cd3897688b127f0a9d9bc17ca40c5b69d24216181cc92c23ef36408b2db27e4fc44b2a5514f26a7156a6990e052b4ffa989ae0707abb7220dafc4b20692507027537eb6a4df08f2aa752de6432696037615ab46e2c10f739116f572cc341a2cf26a74c2d1d5fa5b3789733e1d3d6de934ad6834a87bc1ce0345e80f8814abed0806c6bbcf2bdeeaccf5a0d7d9193b433b2a1aecf2bf3c027162811d5222711aff990b26d71cd85ee123eaf4b7ae3a4cb3d98042bbd78f9515bf5fe878a3f3c89ff4ebed47e2313906ff338b2f8dfd83e73f0b62ef7b663f4ed590ee35fecfe7758685189dc1fbfa17e51da3b28af9c5730e5b3d4520f113e4bf460759e308b3df95743ca16a4989720248098581dbf1dd851436060ebbfb9ed3efb7fd08e88b650059418cc9a39118faa464c4a66d66c73bd6c9bf9a1ce7d048998245af18bbedb5401408773620ba040af1657b21805840940efb67c3b91dee165883173e10ad02260374164393c69a9a9dca285219faf15af3803ceb8ca4eac487e2535871352d2b8062853360d08bf7bc6a06e28d96841a9aa9a1e94beb3ff1e6c07c79909378c4e77efe93d578abf89efb378385c8fe31023336c797f40e1d4fe7e751a75ed69ab11d8e95120efea5730264ecc65e74383b3493362a433c859daf980cbfcc885bc91f7ca93d603e639721cc5189443d02ac72411390962b06da0bfd830c2586dacaa69ffbfabf85cbafa0fc0e350e1de52eb66631fbc79cfbc36f29945facc7de5bc5662baa35cc4db17b13fa0db26fdf96e7484e3c05e867c182087312dcb9f9e4c7cabd984d4b6055b8675966eea7f6e9df8ed46467b047930adce8fa689edc3389cccdbbd61364ab3b32697d632926040bad84b2ae8c7f416183eaf23a95a882bf25fe8cefc168a636a9768c86bde304a3f853a0158744fcdcbca4b8347b1cd7aef8bf39804550407863ac68e607f634724580dba65f74bc939d50699808eaadac32c0a4daf642186d64b52cb6ac14f308c7deb5c62da724f483918d2c1d4b7863de55c40f24d03c89edb2e2b3138227094b4d1647d832c289097d44b14fb218164c7f6c21b00e78483788f2d55db254908455ffa193c98bb45b887ad1c867a2d3c34b8ca99476ac91bbb09bfb5311c28636022636f5d7be3eece8c308191fa0268b9db502bfc3b6e42af634e9aa476222ef77c8d7fb6e59c1f4000c4fc8a5c5823b4c2f74f71d227e48e04ccfcbd55ecdd9926acf147685358bd7c3684511d927cd8023e77405d443dd04995ffc237b7d2373fa996c7438f5a80adf16527f9d29b8d42273d6d9d556f786af889d8b4acec7e4209d014db024a67eaeb90141c2ba6e27c8a8d0b11dff18878b1b8715071efe0262ae7b73cab9e03bf324e6e21102a2cf8ae5e7a8b2cfe4407f356e3bc5df172b048eb98d25a0578ec86110fc16ee5dc7446c48a9254a2cefc1b1f1c893962023fa99a99192556cb8a0164510e5d7baf6e0e376f803791a612001d51003a48cca199b988f44adc294fbbcadee2cbc7fb05baada3b58a580ce297eec8bdf121e66fea4ea95f3c562221d25441b0eae02847e4d86b58d20fdb20c65368a3097c45bcfbc6858f4a40f54da8e9f5eddfa73f22df13d7192b0da3e97fcbbc0ddcab6682ee11df3ee8632ac0c24fb19931027e0a4b2b36de7b0a18841425a92079e3c73f497af7bb69e42d6b8e88f1a3617b4f9aab836e7e444e4e45c13ac6117cc858169a5210f8e065f1453cad4007adc285a944468b19eff6245528d0160ef1f0eecf0fdac5bad0ed18f52bf49f067488e9a30d8dbba269cc88582467367dafc31b3ba1eb958554ac07c03e780823df0aed2c89f3a731de4a50267911167c800d6fb117f6ae6df37efc13d4096e55e4dd1f153968e6326118532d031ed17d3d25617b2bd9c731a8fa5983e06465c86d41d25887521037770ef237e920b1ed4bab5986b20afd7cf67d72908b83e0db97aecdaa690ffc4bf72b348bc8ddffbded01ea981598cc60d972d8cb6ad65a2d85794b97c0d9d0271843499a2c7fbf8f9fd8ff68974b6e3003223891cd3f67cc4b4e2ea5ad2718e32300bc12bba6b1afb8303b95cb7ad7f6b69f0baf01d9aa7844dd498864c6f022e6f0d3ce8ddc686eac85868e47fa6989d695b23bb3eca9fe2870d4f5a4539f588303735ebb5e15fb61c6362ab8c031544f40d46f8e059ae3f11b8e779a0b01b637d0ee0a4b4e8828166a8328a793eeb95e2691db94b5c196794b9421532e36dd2d01adfe79776c93c857d7df00ffc32cd20fea1acf7208feb81faee0b7390fab84eb14e2aec49c9ab40fd3e00c9b431c33450c73da526c6b1797bd059073b940634cadd03280f39c7474b28197d03b468ff75345d097fbcb386114485134ea34b8978f7cbccee5028d0b85013b0b5c9849e6e6dd544accade716584bd2bc2b6e90820520768018cb4e45e3c835ed73cb9ed066b3b898d725a98d07be12012fd772fe349c6c5ea76d3b631e1297561eda1bafdb2d28a9845c2c091aabdcd0b661be86d6eb227abf3c53a11aea385555b56f7ae483d6c9eee678231331959fb566fdf88b6ecf04a1c5fad940b95752d178356c01d5c08fa398bb799746e412d9704a9c44a4e722e8a0b97a26bda5c35365b3424a1babf93e18f4e53cd5370ad2f8f4ce6a4bb6b0b0f76ed1330cc6227de97ff0b288aec19ba1b7668351e1ff178bae742e69db53a287a63cdc765d42df82ecf9e12fe2cc3ef5fc50e73cb561d3dfc2b73d5466836488d672f8004996ba343a5ad3abfac3b83972f3424bfe4aa9ae54ee34871141227b8e3730a98c201964c50f676f703af1d8f6a2e498f1e51845ac9ac213612857313bf8d984e4042838a235d7ae13b96043fde7af0f35f66d1f3afb9e8a733a4579084bb50cb0912b9a5306deee10eba82d4d83ef01e858b6c7a5affd15fb3f7cd521e65921ce61088d54a22a932ea0e828fa96550402df9fd3906e7d398c4f1d33577c4ccfbc09fd8ea0a1ae1b57f0674acb9ad4c9ee2bd06ebd9348d01f2f43901c4072c82b76b56698c34080b08a18f3f3479a7ac638b12a089271cf6d8ba180a0a241b2bc68051c168079c2849e95f1fb235bb9ae11cfc0af1304cc39a1aa52d308649d5ccda0ef67c4c9dde897b20825670b32b3190d5489061c81d7168e97e53df3569d876fcb00cd8e1ef217fd2c38464110b1482584620a08ec197ebf65261b7f596eead402f326e19c61fec81d7423d139d1e388fc0f96cf47663eea1880b7d225da145ae9238d3904e9ada1ee3b6ed7cd340e03d570e0ba4a20d0b28cde9547376cd375172b578cca2e4c5c49b49248cd5c3c70acf7c4fcfbabddd20e5907906581c32046946a25c5bb06aa451e417c86594417f3c1f3ba56785cfac247734389d5b9a4c41a6c987e55a35ebed57c943618b43ca7f5a1e67b803a5f40474946fa96dd95ae925cf98f87ee25a60727e7b666496a149db53ecfcf07b3d14f6a5d02f283163b0743e30614e29d5dd50bbcecd701865e619c598714bab05d2140831452287bdc1dee7f1993b077947914140e6f0a16af50f03645e6c5f2f9b848adb2effbb76c1804ff108365b2c9c648cf4a2888efbbcebf96df92ea0740f28600245f8d0a85dba9425379ff583ec77fd85479d3f430587d6ed982acfe87c20ce46d5c6926770be7fb19d4ea760d88e0de23d49628e0454383a5d0f19542e61cbe05357f279c40c3be74e9dee3ab8023a0455de69637ecbc7e9ca7f557a77d38625a00ce4fd35e5eba346e8d4b1be16c72d8291828b1c04eb71b44f83647d337387f4db2f457eb473dbd30cb4a2abccfb53a6a2674ecf60fe777300bd7494bf523ed106ec3c24b84db45067163c53b97de960edbbe0983c5bc2e1d0e1bf35b82291603207e8316319fbc184f064fa8be0eb6c1ae95d5458d69a0552b80c06774fcef4b3cbdde56b07c44e7b92b74787080c6afa4aa9ef7d98b019e8567f88a0fbbf40ef3f5b1b935e51862721899d803be72b8573feefdd11f352d1c22eba83daba1a2d121b03d4739a8457746fd7ae2741a73696ddedf97d75a6b7e507a26af72abb69331263b56956b24a577efefae58bf082acb0c9875c27a9222817438e2f87fbbaa162b2ceaa88722bfca5c910b507d9c9485ce29203b0bb5a4b853f474ad198c67c87a0134cc89d0e5a25c536a412601b3cded4c581680ae26b7e3acbff1bc648c3b67d0ca07569e97cd2aed91bc95e14d2787b383d2a9ced37346fdd76a7489e7620f4436e39af15db046be80fef210ee82c14e0a4eecfc01f34df833ce23d942eb5be5c84641b843d7f1796296e78c24c27a26ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
