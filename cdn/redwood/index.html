<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2622114ead68a8f756ab6e11227531fd74be8e663a0100d7967d393d2b3b6d793bceb301f932b41a60b5bb108a907a6eb393f5a844e8a7c9fdbbd484db9c627bdea523a20fddae43eb5c63cc17e82fc743ec2952446889a7407b304615e36dcab01f3df378418f0a9a7f652907c5f3eabdd2e432ce510ec1fbcb497d8d3d557192742a1dbb162a7249f8070ef5181a98c29d0ba823e5fa1836b90df20e0fb721d06d1e07942a0d058e856acd1156fa25479aec5b4eaa747cfebf472602220ad59db027fd6fe1455f1754d6b6bd058f7f7487a1f7c5c48c8843eb4521f4f6f1d48f4a2b67fdd4220795d1104b9cbce4b61b61939712cae07edb534bbda59e627c629c202af6b9ddffaf4c1d6bc9e3f9b51ff056c08f25683602dcf025f3a3e5f73651aeb821c94c711fa4cfc73fcf751d35b4703e5e813926d939c8767f1d7fa1108cd44059ac645f53e52283ab68ac52bc3845bae5ffc1b5a787f345100af096adb16d985585679cff57a2888959ae0850960eb09681bf0395818c143ec712023d3af94a0d55e2315605726f23e1345601bacdc6866cbcbf7bdfbeadd02a70b5f6e56ebf3cb206ef8a056eade778c9fb6da600719ee8182243d91c7153263ea8ba12c330c46ddc39b41708186917aa809a20dcd8a115c4eb5bd2dab32df7cfbe75bcaf97cd67c459582ec8e39a40d4747b6e43b0fd25152ce5c0d5a9a439af560ffa263c70ded3ea251d17803f8b37f870d096e73a89cce1eb3dd1b3a2d7ff91a5199de3edd457e643a70d1439414bbd19172a4fda54ac1a425bb1f3ff0a61c40dad36d1e1385c29cfdbffb56fdc0997dd3fde886c7dbbaa208dec73778dcc7141038aea72575e9cc64d12c4c4d3c8211c22a2eba7af02d63a5cba9bdb2227b1f91ea15cbb35abea88b66e4abb03b06e14e245b2be0d51428a9b29ddfe3216275491c2057bf977b69928435e062a3c3ed6e9f2efdf252e373b3879f0a3bfd709faf4f4bacce41cbeb818d35b1c818d7ab1c95836f262f536210db0a77d2f59bca2ad0d691def791da150fa929512259b23f33e170a44c949a02826383906451bffe9847f104724eb31b74279c77537465036cb850281c22aa5352978d74692ee766a90948b92b4db5576ed70b82ab7c3c53bb1583718e516c3b697f46a9b8a0eee18c9107e4ea7d7021b6f9a1b2f990bc1581c421a5afa2bdace08d0b2215445a2532435edcfba4181f3639133f45712ddae5a7e2d43524c909669d838cf3bbc286135c9465a1d1cd2fdac0db3ebf1d4519ad86efea501b41023ce5600e675a6df222562002488156fe96a9ffaf1810031838c7892c37788233052e2369d8254bd63611426e4f7bf718abe5feaf603710d43c0099b4f71fe9035c99ee5cb8bbc8483fac2a70f43cd46d3c3b5c17452d20b1b726ab027b5ce51350f4eaea00a3559a74b2bc91bc7f75c038410648dc12dd6bc60ffb9d39d8ebc3b66706c62cb73fd074c7e6768f868653abf62b28ba5100db83121bbfb3f94aa229059fe2a91b2cfeb3abccbc873828e5f5e3db368b12c7b1887ae2b13a2380e5401d48cf52efc40bc536aed76de869921950e0d0d1c0970d618478ac90b9fb1197b219e7106b921a22ed2503a38df16718fbfe14e3d6b26a1fc79e171e4591c117a78f800fc054ca2c3d8530811b7c79217ffb922312a7e149a5e2b3a656cabeb6a3ceb6b437a6156b6351b155e4780fd6ccf9e8526188d6b71b4b9a08efd992d08416634a03406323b196ef55d06e68e03786bcb56badb3f0e8cadd76db3fa01d9ab9de2f39e0fa38acce3f82536c8062dc74a3a7b6e8454b0e47b807ead54324bfebaeda14a35225690ef61bc356551e4b240aed4719b5a415b4d38f22263404bc619d1b244adec472cec4f9cc6527b17a62b7c83e6829db00753932f952856671e27d6f5476f9a92218f9f0c32ed1f1ec6f3ea5cea97434d463b366b34c74ff50cffee6896d8a8200d48373988944c54bf7a177a39a9f3debccb6484b5613907d2508e8c330b59ce6291efff4e56ed9cff596d3f677edcc239cd4f8be9209c4912c633fb3fe729812d5c68d409a9de0e44f4325ef3d1f8b3d00be9f2aabfdfcd51bb3166a633fc5bc483f113cdb8ae9126e5ad817a0d17923235089975cea4f841be05d080bfc3143c67129477a0bb1d00ff73266b7a1aa5b877ff4687d8bd8085447d53afb681ad713cda9cd6e11220671b1642acd1cac309c7a56b09f80317b4c5e0aaa0d467f56a625877e408f981ce003b8091888590b786e867608c299808c2791c949dbf14fc9b89ebd04f1a55a0c36808ac68359a08f73950c9355f85784c0cae16f0894ea7e278b109a3bf7b452216030fa6a14509175796456d5b36ad3bda486c26c2d07dd125a5ef50fc50a07ab42694751c4247fc695d72b64d87c298c17dc10ec74f54cc3a01806f9e8755f51db874a10b1981012bf2eeca3b707f60916def8796c53bf874745f3cfd3630117ea2821725922a7093bb73c1db730f9e42b4ab53cd7319f8e87d53bbbdabf1c5c5e6c8f200f56f495fcb987c92a35b1027a8474b3332ff13ff579fc20dc57c98bf9bd783c80993b5607dc3821d14d6cf1a68503c530051c789d21e971b59553423ff4ab3ea01148870813966b576a40c7f128751df018754042c7a6e452aab5728666722cbba619dcefb854f5af352d3f2848132209f310b0c7d44ae019dbc8f45c634bdd0ba632f79b62e0807e55edcc06e6c9af8232465e72ab16dd269044ccb63d8215b17d785c5b3d5db56ed9b4f80421ed8e727dd9cc901131978220f3064cf327b442835a435b9840791e464f8ef103861b0f0c8875fc45803894e168fa4af13b693f868c94c20e962f73c46a7d5a9cc36ce70d88788122a5948167f83b9225aa5458a3a93d3341f10239015d30761bc416a9451474a19f1ee08774e3722a4dfd8d90179179c0c00db5c378800f612fb6e5dd09d00e49327ea09c07b60a002ac1386d2f60253a9c05622e140b761e55c616536f7a1cd3275e81c73c90f56ddee8654573e53874f87b71de33aa29a0417a0f918cf23f83f5604f80115aac5601226de2565ac96b36779817609366ac707e8e49cad37562e14c790831ffdb37a3416ec1d5480a25b745d8e3ce0b3de320d440d20cb2741c4733880333864e8dcb4a07844729a43de6f9e6613fac051251c46f8664f62a6cf0db92c4127e122c962abb16167e71a374439eceb203e9b9869cb2abe5107a4cf51816be551f993e013e853c892a00e8e49f511f0cb8a4fb623aa523e50452f2fc47f6e1a64eef3c4115f659e15de0f001bd71851e03133c7b5755935fca40875e5387851ba18f0fce3f682369102b51611b840504b6fca88602499a0717a28ec157a555415bfceeea4d7fb9e2cd6198f64c6dce8123c001c6dba390f1e63644576b48a361affe1508c7ae5c418cf521a90a57c135cf6973d4d89929619c21565f4f5ed9c5545b0cd14ce5cf00476c8567100effbf8884098b28e99bee519490a1f9d1273f66bc9ed5660a77a5fb465e1f668af42822e421c5f052fa770272a8cd36287a1f21eeb8e6b1accc648f6fc0e34ebf57252318bd5e1e39998d915129a8ebaf76c9ceb3857ff3ff6693caa10a22aa6011beffce212f6baa199ee4b3858e896a1679700adf39b06df270cf4bb474b3df6776a052d5cb0c2fa7c900386eaf06fb5a22111f56f6d55ebcb7a53b658421a0863a77a5e9327f9a4156c64a6152d45622ba142c42ee361dd07d3c5ccbe4ac1f6f9fb111ddbc9f33103e916c2e284f75786f1be98325ddb0cf96313d95c25fb1c926235224ae4d1ec20a61e290ae843f639680b5b00097950b595cc142e3285ff0e47910a4c2cb3221864361e93dfadd272b0c1f82d71089b2ce43ed5e61c498fbebf2eb0adf59a256e2f1c4c83471c582308f04e0c0f2b7147836ef5d5a23494b2f1f3e47628aba52fa007f9c42ea1b661f4fa9e8cf4a15dd54b9af36e8c0f7be5ae4ed466b61a5b1fa3d018a22d3b95814615a9c9a89bca50d2a59794c729bdbdde74d22030149b4ce635456171a2bbdc1b431d56224719ee565c70082e2ced485b085e0ea86f3647831e4f033d3c8915462d8c9a9375b71ab7e8ce6d4f6cd3608c969568b6efede02dbefd5394f9ed0da6b17cef7819241a6aca42a40f88fcb629807fe46225dd79da5ec129609e5577c46274303e7bc1ddd9b0efca14a10a048080263066cd252882c4f3eec0c8a0f37d6cf7da6100cf7bcdc6f012ed2ef6b187f677f752426fe5f96a758c3635a557107dc2112275504bbc5e33bcb17d251aee1b88503fd91e0b3313f6621ba11384bfc6087011e353cc99fcae354ea41b7a0417f083ef6250f72c738973c361ad1dbe6c5118779264d200ce27dec8c31c89a1183cb1750881e0182df7f0241fa49a2affce5536ba4eda9148dcde1fbe13911216270bc8a296f7c6b25d2e87b03dc64b3fd0e8227b7cb1996bb5aed30a94543f99d8d4801a161a92bcc89f53d906a4fcf71424f78fb1ff132c131ec199ce7667c239458014e03d1f244ae34993bd5e2a62dfb92369be600bdbe995ae3b1fc26ddf3b56329cbd037a345c7c6d808687605c9308beb1c8657bf10f8c6b47ed21e6af380aec2bc43ca45ca8462e73dde40c5a586cdb0b6168de3fa78d6bc2968764adb424c6a1579e469860dfa7292ccc3fdd7a65a8d6e249cf5c0c1258a7cfd4d03e6d1a473659c75771a020ed817228900ee421b7ee29fd08df184a0ba83733533a11872833e9e273af047dece0983a62a5ff3bc67c7b6e0ed9ad66ceefcffcc2729637b267b016912f0a6fd72b0fdfa1d2df67f96b9524d98facb8f613e5f7895786bb83129179b1ec0613903ea4198abfb15aed0bed10c102453e6e8bc5e3d61e946794998aba01c30a7c5718290b8eeb31391fbebcd28f725b96bd0405c77869a408e9313a509785996bd46cbb788985ab6f8c48ae2cac2d2466d963d197b044144ac5f74cfd18026e4814867ca9e8460bd1e004c043273318825fadcdb634cfd7cf887ff17fc198b6e6089e9491eea6fbfe603444a77d2ef0e4570e7f2ebaa273b579e206dc4e3cc55bc8e8e5da13348eab7c850e67ebc22c95bb5f5f47d480d44cd1c93233c86a6d691870f5c9b992a8082cc5c1001cf80966e24f2920f39f970c98fa38827afcba84ad2c74a50e6f0836a54c8f676574d3e2430dea7a89edb844cc8fe65c587f33a0f2c95fc6d199fa798d5199d3aeaebdd58b77894e87de46882c0645f9ad19e02b499478496624e373dd1b837245bbb81c3e3e58a210e26d614587ef07d0064a2d939dcc82522ed6162f1f7a91cfb560ac52dfbf7bd085ea10e2393949cea7afb9f512d122bbda7cd7c63f6490b5a9bedf0d8f0a8fb6bf246dd3e601f576f368ca100d1c3292c55cda4656561dff779ca0c930b3dd20e1eceec2a89777bd53aa4bc0607611ec245e03ead0fac58e7da85a37b692560d928fca9ba07d5cff136909412dea7dbaa4ea857d6e0ce61a171dd92e1448f693b8ad97df3b1fbf23bf92b34c3c42661416359fb1431681f4fa257b8ad56d1f0725ac4936d6ff6397201d2f91f5d4f55a4f07711aa4bf6966861bddce4ba4a6ac79e37153aa4510fad7f45d6feeb2af6de93685d8a5fc3464437e50789ee1e35a09c7faa90dea22ee902c424ad3e54b0b34fce4c3389882ffa6a88088ded5960ae7eef1cac5085fe09b33874865040b04009cde0fd3f77fba38cd19049bfe77c7d88c4f65f4d144db457f31a451d388d0160c6e421bae8179ed5ab5010898a6aed3e825b483e2344e4415e069b8465d7fbff4c777d4b39c95ac8aed3f0b1ef0b5089a7e6363ea4a6f1ad41875d11314ffd28a5afa817d32ef23eb2690d63577ca33cf6bafae84cee009b191413f217810541b045d2d941fdfd981f5b1658cbc405cc8d6e1e6aed1088ad3b986b9fbfdda6416bb49fa1780eec4ee35798046a1f2c4710453f5b5bd6b5ba820774bf87599ae31ccb327f6333fafa2cae26502d81a6cc22e7a4b00defaab8157e663b1e32b3ca24929478c08eb4bdbba41e6b023031fa9ed04b72b45435c61c5e169a6a2420adcddba3f54b5321e5ce11023b65f1f07bbdee2eb2e577921da58720f3152bb722d24543fb998bf43a2745647c05d26d639025b40b2910fd40c73df7c05b460e94717d4a6b481792a7299dfb908dc8ea3781a89acc1e167eea1cccf9c4b4560e4d031fa37fb098de39c462deb4d47937a628d8fc5e80c37078a8f33466be7e712d8bed2580e6942ecc3171d0ae8b967467d7487321881e86a880d702ea1a5e788e7413d0e87cd0a0536472aa658734e686519e705ef179d7d4f8f3e12f67088525def7cc2b0d148310898894afe24e726638ba812ba7438c954f63863f230114815e6a62f8187c14565c4a3d25cb86359d4d0c72fd8a9545e5949e5b07888ec68f949e6c098913a5cb1005dba6b21b502824686c8440b2d09eedf08668a0d502a9c99da9f60809ed5215bb833ea7924c59c49397813d0faea7fbe6aad058764ab92fd969df646d14d46732fad3d2fc55741a4356968a6bbd7fbd1db14cb4f7a9e3522dd55d4ad88d5c87fce7d7643a320e79edcb8640ab01b594205d045d2a8801fef3607988c23999a76934a391115cced754631cc65cc30a405c7bbcb66b57ede979db612f865a392d728f9c232db6b14873a1e48c70a95c29774212b8c302c0f5560ba8f1ed383bf52b80daff8a0e7d99ddb22de83bdc76dc9062abfa7e4d01009ec985e9f5ff6c08c9c1716307391230bb003ac92dde04a2c41624a2d0990d39068ac5ab488c6b26164b8589ea6f84bc230db107694a2eba40462100434c40960f494cd6554c6b80c458fb053be8938b55053b10ac1e9415a80129921dce51fe85e939b1b2460d88aac3f0ec7a108331a861852678c67713fdb0a7cc2fb89469835f324452adc1adc52985b3bd83c3fd45ad70640b2b7b30c98c767f2d285c446150a0d1b5bef6d84aa9ea6cf724501b67185bc6d9339f802f074c952cc1031e9fb0a13cb8306d6baf5c8685e00c73552e45731398237576c7541e0559a60263cd0abc96fe0643fc055632286f3247678da38d50b7610413aef8306a2e33290a2a5b0b09821bb0681c936ff85b74bfe206035d7e6564056f2e9bc98acf5587bd6d020cab634bc1e8c9e5e9f9110ab3db7bd5c00c11fde4c0e06ea5c5dbc9d807b55cdccde1fc9411f7fca07c9b53ab17a20e2677fcf22199c9d1e09f8033d8d6062c3756764fbcb4f0e6489c6086dcadb9fd3d2410f63500acfba26f8a4c42b5fcd7b565caa3f42792b784a02e2c8212a5625ff5fdc467c1c86bcdfc4f62b79a5a0608bb1e2e87a6825ae79cedad722358b7db42ada1a9f0c36c0d36a5ca29f926fcb2141a31a93922ee86f5576a7ee451963e83f1f68db44e29ab2c31dfac51a37301427c211c9e107d0e32a46f006da596edf7f9de8766de59dfa737f2a76e32e2190ded19dbfed325237a335e369e6e7c547ae96badf4562245ab91c2896035cd9f6564a55ae18cd4dd02b3b51d2517705fd70a216fefce73fc8ff7741c076c417d04f5012115b1b9fa519c9eaa6c02d2f7534d11b45d04cb76de01c90e5572b6e621610771073d8e30c24e6d4ba2f0059777ff61115d32da7ac45497638ecde20333a0c65b2c28e55620d38139aa5b1a473704b567a85f2da47026615b6f5ea5d8b1d3abff322c0550a7ef97e7e922255edcc1a441408fe1db4e2a0e323dcd869453024a0f134b7667a607c3c0854fac8ce4fc99e346d1c10a33d16a855d479533e46880a6554640697b8f97f38648e00caeff61f87b310a3fdec309406cf047e9f7c49d68243274e7b5e6b4911618eff8551a601bccdf6595413e76111c28f47429cd451e384ecc13ef5358eb023a55b419b896a50fb0ab3b5eb983bd51ec0c1887efb2a99c513e6b6ec2cb79a53d12f04c72ddf73d07572dfe28b236534d515e9857806693ca84b0c9a5a427da6eb919ab73e161ce15f7ac017fc863ba71dd31a51258eef44d4245741ef9c4981915ba1d11439647f7d25fa3decc7ef6f546ec9037080eed24600bb14e5e12d7ab2737d71b46c66f5cb534e5db4ffb8975eff1038127010d47f6363b6c1ee5c239e53dc4f50c7bf08e86ee45297dde0ab2ccd12399958a7c568c2cb671e51af9d406efd463a000c44b114081a2f677e9d9164552229026b94d06cb3361022aee1e771de1b44e90797a0e6767ed898f0526fbdd5055f8f8858698fdd0967e33881ea540feb89a1c9f9632d5cc1678e1d2a4a8fea29c7c42b8ad9136a1b327f3d3fb0ef1b191c4979b969baf52790ee8c5858602a34e4e061de78eceac41e7029a18d1cf98a566008b09ce795144b3d051378cd538b3ba4605f49115ed0b12c0b1ef044a9dcad3600d8853ec35bad07fd59a8ccc0c10491df2f8ef646df868deeaa36c0e548c3b64ac24ad2c6868676740b4dcf617539a23b1fee520700640618802c79a1863264d6dfa8e07d62d136f30b7238312e25f09f1ca1a0483d5a0f9d17235b5d45e435bdaf94841b5289b4b88f1a80ae2e9d12883da6a3468af4961de8ea00bc7b80c5700c505bbbabc30c9064ddb96a1a671435566ff128ae2ae5ac9dea2e9e946d50d0b2aa6b380773f77dd29322104fe153e056792b2585f595953bbcd889221cf5a6e018185e7b010220b10adbdb053cfa6fe163d6e8cc041f5615fc7530a8c2f600509131c77c7aef0d549b0f56ae156f0c7491327b76666d1aac07416450b14325493c4292c315e8a7a794ae232cff6e283146fca8fbda96c2b9e2ff7ff168b10144442b229238b2f972a53b2b6adc7564dd33f6c30f3b1867f50e4c5322d8510ce11df17d2f1aadb644cc338de4cd5f2a48830b333f6c971089e6ee2a9b1eed6e8a8423839fea5b20d39675e5d82a4ffbfecbff5a76ae6635544aa2bf3d7070ab3b28303317b2149a67afea6293e0a5d7d97dad68ea8a5ed7f965fe95c7145da6d4ae1fec883a1a48fca3e6464447966eadba3b2d0295c5f14e332844eaad0cb895c2400f618691a5b169e430b181da8b173abf00df579968f6f419747c3c186e70a54772ad7d3ef7d2c5a79e7c4617662eff0d46fc24fa1d46d4c9b2cb17e64800892695b520edb6a3abd698b0767662203df0e79bd3e6d328370e10a75dced402b38809ed98a53846eb5b1c8bef238e7c7722323d0170d885ef1b07bee402882cdda2e0424d0b40c57e60869768655974b79349796cb37b08424314562e7f070feb02be27eadda62a3111f6737763be391f3d3c63ef536323970bc500dc9cac99138534d19bf53d0d81774b45bb3a4514f4a1434814b8b308c7a6a7c2f0f78d2e4e7947c9cd2b20812d072efc9ac064609e1e3ad801119f215a4b236245de5217f0571fe150746f1977b4c439ee08f2d6a08fb626e7b7db80c14e8bbafddafc2b06015b28d1a40325382d84f5450ee8cb0791418ad21949a60e311a286b06311c7ee374aa423e7141206b117ce1648055d9670e335d109d1699b4121ea634fe133455b8c1a786f129b964d88617f8a8707fe99cbe5eda8935830ff3049b5162589bc1f2c66c2126975dca630510fbd9656aab19faf1cac4582be591c9d5c188409b0efc681323a5d634bbc9d748dd151a98554726ab9e8c7af41d3a6785224205050c229d26515693bf0060358fff9413bbcbaa2ec14edf4c5c8462131237273a417d81d0b6071a6f9bd67a1d094186a28797b142a4329ea615e5a54dbcbb1650400ef1515546a471fb42b29f80afbb46dab1fcf4b200077c72780d92732c9923a86ead12f86f0dcf6ac50c80bf86b821cadf598aa1aa0dac808ecbb7574d3d9e15bf3ccf5fa133752756bcd867bbde3bd6c5e47a1be2edd443f885ebc60b07dda635f2fb0b109aaba799ba36214650a0c082963f3c33caa7772a818e0620844b5501745a3f8d8ea9b68c30ebdefd5e57fe7bbaef1b7a5b4400872264e9ea650fd05ae8666e879fb7fc919917b58408ab8894b488484aef5c45ab171fa090aca2979fe3f87ac5d5201c3bbb73b377d36f730a10c17c6ea00cb941c7e9c737a17322facf11b898055223c70f221c6e88f8cc17b527f354816ce0fc8a6082fe8edaa4484962746b0166950aebbf258388fcfa199c2957b27c7b1c54c03977f29640acdf32e3239e2f2ebf9b54da056eded2d8a731703ee0a173b31f4075d0a43fea02c4e712821dd12e2cb6b12400dfbc4f0b6921821768b3f87e2f82ef49b7e91c9f100fa5d1e933fe641ef7cf575edf1a14ec2c82bae56fc7d632857bc6c4580ae43245812f61fd223a872ce364b8088cf81337324b5b49eb47c97b54887a673db5e88dd27de3190e8f5d6cca253b434216575f1dcd428fbb80b0a6967af71e76819a5e7220812af91bc90f33e0ab085680d060d504e651b432a8991596fb54be678553f013bf41de96c4e631439a1635446573c616b8f648575c986892d68061b9cd694e12c3f840a391e1ee0dfc0f9782869112f490ce48bbd1281a10b5cb5d83b1794bba70ba0a79e3284791d26c7f9d8d5ecd338144f5edae73fed5b73159792b033f4833ab8cbdd8a3ccf995db6300579276a6c62f655985efbe39fe80b3776d52c8d6419ca818605bb63842a525eff44e3713410c386fee5276d9e9df32ffaf83eef31bea42cd4dd8c0dcb6047c32f818b16e5c25cedc98d74fc624cf00ad7ba13bd72f1c622019d949e2b7a59ecaa6beaf57bfe2d49f854904e4d638b0b45fd3553b51731c1cb77f7138ceb69884b6b9da49668878181f70c625865a03f4964ebcd6424c5ec7621bdb8b97c4c9e0a1fa03d590fcd10fdc28775506f9765ac4b26e66ce55d1dbcdf268e7ba8fa976573133b9f810800153425a998c61fbf64ccfb6bb27c52ee50ce83ff4a55763d881a67d6eaff28920484f9d30d697d7550a001b852f174e4c71d01b3845d0c59113d371da4ba17d677bac49fa3392b165b179ad1e4f2686de28b67e32264284ca5eb8f3752940cdd1340ac42dd8ab86afbeb7c955587a83820134994c33e0123bdf9d2170e9c2c45552749fc4fec83a7ef70882ce4c7a657817bfa7da16c335583fbc13c0e1d00425f21589085965db6b172a8dc8f807031ff9b9d9a78ffa2fc0d985d661de271b6b5ee6f65ca2bd6b351a7127e469394d03687a158cc315c702579b790b7290781ec901a8f15c2e5f1417e0a589a0effc2450823bcc0a7833d79dbcad043bd129f8c1ce793fa9cae8195d84ac4a2bef0fe09368c6687738f67dd637bb849f43c71d7db3a81deb7944fa6771333c8352dc47ae0b05ecd223853976204aef1179e387427baee0dbe0f11e38b983ed7de9ec7e7f9036f945ab13f84f2da7802e1eff9ec551c5182fb5cf7c82170f8781a53534d5613c244f2d57de3dcad299524fb547e07fd7d26f995995ceb4685354262ab110176c3b626abb14448a1eae4e61847b40963d87464cd0cf3c555f9d0b5d9de63b127e60eedd74939c983d56281444a2b70195766034c4dbc8d9f462e1a509b08f8c0b9fba8fb8e51b84d2c9258c8f5937e5d1e5ed410a60da634bca215ed550cd301c3ae2491d004e07ad225b994f7316dbfd46aca5055f7ff5974108abbad9ea3d77f99940e7a90c212ad9bce716d15991209d5430e08533d0d3c7cbbba839583d08577c4d6f299eefff17a341fc83ce9a91dbde5d531ccd02bc1a43a6e75de9d9e1eb847b7cd4acd4530a222e1fb1227a1652c6894dfa4e55c4a0f2c4847e1be5c3212bd629fd1d6accac711a59c81a8f12afb381752916c84eaf5df03d615c670868214b011c71d60962bf8c1396828b0ef41bf894202fad5ebf9b8e04d4330e3423ba7b4a8d589419492d58ffe7ef4387d748d450cef9e59bfe0a4aed89a7133e740210a17cc0bef922b2dca5f7db14760de6c17dc6412933ecf292e89dd01907bf177353550af86010a074c8439104a6714fa589cf5a6804d954700ad478295e3e41b35efc25766d79f8d96dc8f9fe5f7a0456d2785d1b8017e492baf94f019354fd9bd8418fc1fcb72e75bf43f859ec01ec94fa9de4fcbd3d1da946a670f929428222730ddf973354bcbc982cd6d9270d20dc4434436e58bc86a4046e8ca86aaa7c392288c5511222c96293f195270b3853ac7f8ee2ff2423ca659a73bd30bd2c1a9831d6adc3734fbd199456d037632f41bd972a5e1c093269ed4193fceb04fce445a609377613ac5ce2716b991b00cda05aa60f47134c10a0ff6fc0baa80ff21caa04fc399e43fb5b20675c69b4a85ae0aabe497c1680fc739523c73768570d0fdaa9651ee59bcfe2d934c140ed31b425612484d62f41101c5e25727befbd204a1d393b8c041461b57dad662e73b524dc7aec72c9ce3a30eca13a49ff756e718294d765b8ef81aeffd1cde10072ea7ec8b462b4835acc5c273c537e9d00dc8b784bcd2bb2906546250ed50084053b1511235f011ef780bd21466c296c194ba8ac89cb180ec732dbac02c970d2e210498df3a376d1e4443c0f11e574943ab931df53067d42a48c9713a2848927eacb34b65a45a367c0c41f385ac98933db23e66056aef6c80667d720cbbf4f571f06eaf8a65aebe12bb093ca81d746558a61a04d544ec74e2ba1576118d91618e4b4a7756413f72eee905ae03a1d332a7ea4093d12731698b4431513f1e771e87eaff0b710c85510f633950115e59f11389c20d561a1ed625d7ebce122dda1be329e6d98b55eb85b538950454308c3bb124dfebab55ee3798101b675ad74f7846760ed2b390c1ce3986f2b8d39eca4c82f23a60919d789fa3cbdd7015f21d51673f5048a5729f13ac54993bd60c4863ec567ad9f51cd69c6cf0d2d1f8f36b645be51e6b612ffaed9926f660d35c209213e362b170098c85f9aff83f54929b634e2febc1b25ad86faf24bf01865c55a2d04f4490af2c33a4a351fb40409118eacd755d6adfa5f8d6103c7fbf878748a4e6e58af33d0c30935fdb07680fce8deb497d10a4cd54fbc92d0d0317fc19136c1960d0eb9092d38b4af2919499b17aaef00a6f6ac028947a6841a0c5adc2789400b51f6fcaf387c862282b5d327642b256b16ee47037a2e18e27e33a41c2659ede979c3ba8210bac3562b5db5b0df6f09a9b970a0e98fb2d44605749424512755bcea5a00694878b48762e2dac7dec55a964b7b26ffeb75d0752c02b74649f1476a66a45dd8235d4d0fb6dc3500e7f6807e63a21bc8f7c5c4099f50cb1acf05f5a3c44b9b2414d40a4d13808cafe06625803a25a7afe4c8d5f37d4426a91179900f0075a65c9e30106efa1f3c78cfe27b3bd1bb70701f3ac6dab4cd8b7cfe4ef9b60d96a12ec2999173c7cccdf4f9bbf131c93049e26bf4114a2c2f6a19f57a4c29d8c363d9d06ed946b024922fcaeba1102fdad9f633e41af46d203ab568be27e20d079b0af2bca419a40f1f08f64ff4542194566520cc156f48f10f730658d477d322f9a5d867265a15cdb73aae2723e029b9e88001a86414a9a91cddc6fb532c35293eab61d0e52d188c7b5cced3fca1737df12169dc33b980c5b5991fe50528cbd409669042aad3cf8f481157304f4ccd9533d1a3f3988ce295afd3bb198763d9435415df2f7a6907dd24c09fc28eb1df8f5b96a1907454f2ebe3ca645470d7837287b7c59f863ed3631e1c78943e6e0f5801e0d570d91d639d16dd78ef6e76a7809342f3e126c5a91831af884db1612cc6e90a070ac2d3190630b3b802e380636c2db88d0d0efcf80b4c45fcb6e235756f3a700de18472c762ad6f4019a86f613e0b0e9ad621cdc0741eeec1a370d42539364decbfc06a095050c06801ff134e276044a7bd13b859022cfd09774d1c4da2c684177c8d9d447fc51dc8d839e53428b2d2d1a8e304ae978f0c37cebb66a238c4c8dac3885ccf30c2088a3fd8218ace0e92ac29aa47c1e9196313198d5b827ab6b491d3632786b71e7048999062b3b29884dad86e3969969465da48c3e44438d06d77030b0d653418566549f46c20480f93d5cabbfa8cac8cc4fea419ce34d2241a04e5dfd11aaffa1bfd7559c373b1b4f73a77f686994bf1f78f18f00e035b15620c4f1a0525f50de5348904a36fdebf686a28a59aaced3950760faee66143b2c384183e773907babfe3ff51819b2044d7a93b230b010c1e971713649fc8cafb9d15710620760f514871787d88820c3415869b099cced09489dd2f658a6af34434725e1d46cdf19548da78967227e0ae24fb7a466d8066a136cd4cc772b283cee410dc249c03561f06c048b8470b62c4b42a294cffe7219992c9334734c5037c5d1f9c1164fde5ef58ae16a25179c8793f16097a7ed193b30fa848ea03c482a9d57a25c961e6399d71afc1e3503cb59dd0c6c1d93324dbcde8bce56a1102bde6d24c418f992b573e6907f34eb42b09075cfa2a991fee510af04bbc9e95e099c47bc6001ece60f5d0d1cbf203fd1c4382282bfff56e4bec8b7aeb1bce7e5d18aef58340cc46fe4eb39b96f4e99030a4c98e826f300c05db41b05a258e4aaa15f4a01beaf99f07ed071739a1d2315d56e2725d8e41cffa0460223a84615b2afcf7a00ff7ae0fb5911971950d4fe4c11d95d758d3a0b9f323395b1cdb2c5183856be2496821ef2c970863ee6ec2d8c72e042d2e93606412b290f4d00b6188abf73db9a6613531f35f950d07c223a53dd8c043849f7e5ed67fbee73ead770bf32ff7b4b3dec4a3f0852e8347bcfc506ee44f021597f5c4f2aa5664566643c8d8ec4b1d0e39d32ec2c951ef889f50028b3279250fd62fae037f99d42da8a027736f4ba4ae74a0a78cb0703d612f4d7dd456d7b6b7b07dc6feb2c7fe2d41da5f91200ce7a6110370d7b9a68f7cfb1f3b8a4dd009489e86757a4755011373a12bbf61e944c04ce365f51be97df51c4bd16fa54f716e734a3ea4b5b73e1709774de8c7f9246b0078512f18eb45a20d4f1179d3eee57e74b07f03f840bab7935626750c98d3f136d04b90347cb6abbc1ac5a0a736c9060ee94f6ced0d6ca9d4f2677a3668ab48645e49c8dd40756478c18af0438131094463dae85bd5f146539666963d637a01455e4485e956dd9f0c5c3f0ec1d2eb8f99ebd025a2ff06c54e7fa49eb59ce195fd39ee3aa9281bc9f409bcbaeeb9433ef7b43e3234eb3f63b6a39cec64c85d8af35c1c4ff44c2d746a5f87ab873d38658653183aa2b87bcc8742fb3df416b4df3c559bc2ca581db83b34b4eec5faaa0025f8cfdc2e4a7682b3c11ce3517cbede261360b3874f4b27ed9a85f9bb5054c0051a662186d114c9ae41e581b4379496836560879e412593e4cd8d0d32570b047c2821cd86ad9dc4abe199c7a6efe935a104c692486c72fdb82eb7c70d15cb113d68b9096c830e885dac5ea91a771ccc0c8945bcc5e6a6435fe9a48fba308f4529d0681a84512f67e83dbe4eea0406c3c52c496ef7e1c259fc47b7aecd2d6a7a54759c9aeb1412485c59415c89d45887d6bbc287e00b583a0fadca3e334e5a2df3100cd8c67986761ed9dfd96b12f0c2691feca46250e7ba248e54faca8f8dbf2f2ab4faf938910474127b69bc08faa4b668112de0d47cbab37bd0157f9be6eac72b51a4a71a0ea1d6ff246729dc5ba7870b0eaadebda21607ec509e2a9acf4c89577eb760558f5578bd3401c2c93fd8b338a8a61ee775de66ab49202dceb29b8e63e25b6c61286124dc64b4eba943ff0ada73b4ff69b2cf5208aa2e6aa2b5d5fc50c72620e35e1a5399e0aee9798599ef8b6836d0dca765a18e24f290a633075e0c0fa6a3f45b0a7c140e982e130d48f16115e711c87ca792ee2612175efc94dac10c8bf4dcc2dabb6db59c66cdd592d7f96522c3b72e3ffcd15c6ba7c7df06adfea70d55da373aa1cbd2a6579b604f0f92ac8294c3c0cec3340b4149076873f04c4c1358c76fccdd153790d81d9ea0b159a43a0c3b037fac71fbb16b84b7ec1cb30e5920342bf86c391cbbba96d927be506f83486f1892a3897b40551876f7a6f8120375c98afa3ea623413a148324f4af2ea9d12df6ab9e8aafa0e87752add03e39e3de360d06063e4c4863e2b323e5496593eeb8f7e435f1f01066a92e4410c21c794105dd3a1973eb3b6fab89210804e49d9e6000607a9cc9e5344203d1296c6c233adb6fa4d467d5d0d4a4850b3b9837de18445f5787d1e4fca0e1fdaf5871ff1273ccc89aabcafe72b3cc1a8a4c3cd2264c019df8be77c8a653b906c29f789b4dc17b29e90ccc7779b3f2e605c8f20e0e60ace2b19ddcca9ced742423855aca2f3cc7bb1962d4c91a71bd0947ca6d31d75e8c2b5ffb386c18867936c83d588582b8f53d1c7070d6407dfabc643bfe93402ad3e708de8daba548c7f5e02935c9d6f08b867de99b41f81221387dbe19656a055d33d24a793b6d1d52747f0a15d6a37025f479bdc3bd4282e9d63022c408846ffe321c449e43cc7e6cd5a92d5ca80debcb5f487eaad880d17580438db3bd3faf27b53600154627880cabd91dd331bb27a5b35b7a2fcb3538c69a5d87461adccedfd09854de728b6751181ceec5e3b5d32c408c086e69431cce29e62ebf948f26e3bb14a2ba0f704a601b5d09d156ac9551b10ca423299679332b3267e38b842205a1baa60916f81477dab6cbf91fc7fd469afde907f3ee8ebd23fab354cdf772fa8a2b62e1c9904deea8ae8227dbbf5e91071e0bf62f1db61c9bae64d1378d1cc0703165f0d38205f9d30024758cabd3af61aef0c5c448eb5aba3f6c4eff3825790978090625c8eb5ca97dea4b3136eaf41728711a0d2fbbff527434e8a8db45ce4846e8e9e4fd7fc17e051a0b7ccddb7c553427cc631ef6f951f744964d37146cd477714e2094f64d340889c3f6bf88bf3d118f79eeb9d37fdef0fc44a881f231caeb0fcb02c00203825b6fbadb91f83c77a6e2eb3aca0f85187663053f15ea365ce95817df088564bb8673a3ab03142cac6568a1d8f82ed24362dff118dece637bcd1bbc0cb7f778e856617712370eb3e72ff6ab81dd0bd440cd5f43161d56c00d6ddcdc7dca154f311744492560a491e9c200f4771cc4096839e9e2939dc8e719aacc713e3dc3ca3ab438521cbd5bc494d8ab7a9f33f39d3585b60e234439f873ed4c1f5f56323b6c0f7f06c8e4de65ed42f0d276fb7749ee4f10166f8afacd28f76fba179b4fb90eee0260a49e98c037d4c930d67ef1ca58d70097f3a571c8e03d55b8ef2ee47a9ba0b0c069a89e76915a9b82aa149e25a6028e94f6d2f16e1a5b61ee238364727f3775deabf8c2ead223da28e878f42fc49eacde606117ad2f799c8ce728f80dce8f1c40871dcf0c628876a77e0069ecf35278f64bc0b6216ab28b92dac3c446feaea04f145df06297b7efae3dc275e6089e25c8a4530295dbfdeeedc2642ba8d825fa6169c54cb9c444d25a65305949e6a3cbb2c4e8d117337150e714f3ed68876850ce14fbe52898b1cab17399791854de600285430999c9b16dc8df1cd6e2263d68be89a324c646fe6e2e9c7d96e86c84dbe986c2975c60becd5b0075e110b871c669a7b8df0a4169e32f1afaeb0fa4f0d58a55a9c66ab05c963f765a4888bd00d690603f5978034382c1bd293f9083a5e98c8bfd9fff5807cf4b3b2d7e546625361b5a4658e8d134bbcbb64a2062ce3dd6dab9750b3f968ae2439c54fea7e51d6c5589d26812b6cb8c6055166427f04a8fca6a3ddc16ad053b0068644664af55ae2a30c83c9429fce52f5de3bd5fa656b88a92918d983694c98018aadc3092c0a6d5e3511f83811e309d41be0dc8d1a49cef6ad7464699fafa772ba57e6f82a1ce5112228856ea9cb7bbce55d598a3fa9c340dfaff1baf4d1500aea046d97bc0de15c9ef89216e8011e6a6dcea2d4a7e6de9cae41d95caaf2a2aede950694f96caa4b90132c9abe56a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
