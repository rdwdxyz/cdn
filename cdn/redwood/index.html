<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dedaf64df519038ee7b2b32661764317f97e8e3e4ffe0dd4533ae2ff943a7e7792137fbf8ac7e45cc39b62da6675a4da45ac53b94a91712b44926c57ec1b07e4b47708607794987ee084324d5ed56891b74ce42d039b9672da2acc9fcb39b56520e89042415d8ddec46c69c350b343b161b30b6ea0e771d233857345c5f9b7b6b9dcdfc71d59c9b6339d476de4f7ea7e27e65012bf9e6a28ad4426b41afced1331899add95abb36f25ad10e93c4e1730682589cc32fd2a213a64b92fe0ed0997ccb7279612aaaaff041a6d1752dd293140605806f313a9692b765b44b4745d8c0f91fd975a57fa2ee6ca2361f6992cccab3cc2e8bceea4e5c232edf428ebb2a926cc71ee4322d1a2f46b842afbad1805f4be3962e0ac37bcadbb7142c3fc49034a5271257c6eeb2497a708069c1f2548545ed06518e98424d85e5a4af05253d96604ee9899f46ca7764e5ab8ddfe59081ca794a46557c6b4852c2d80eef91b7f08f7892bacf2a2267a4a0054ab11b82712b77d5bdf45eb217ec067cbd40aa40f32931ffbcf4483f969b0a05d27119c1b2c7f16cea475491d4f7a341303bf0f8fb2407a808c9d8af54e192f6630926171a7ae165612f234f19806c6f70962b9a7d069646c493151c131c13f66d1fef5d8487f97afad689dd89db41f5b6f25696429dcf95beccb597cb5cc79af13b01872fa2e6950fce491844e0ff8e630ff1929d096503fd73f9fdca2dd4c326844a27bb5311c2349dcc48be82cdb877d1ea99ae195e86d71738897821537e466ab99733346f260901db44ea2d1061dda9098cf59fa6fe7399ee652df777121f0c532f42c33644196960fdf77bcb66a98402cedacf0f3acc7396b90e87bccb61fb742da26854a35627423e152eb304a6a4d2ff218563cda37ede1fc63b343ec7b3a44abfb4db5666a291719dd0a51ffe2241a16b2f8abaeb7ffe7cf4e183aaddf0aac36a14c1cab48e5493e6ab48f4f32baebe5bee9d7b0639e75e70d20558969efabf570da0afaa71d9db0f65d0909bdeb268e4d10a8377a110bde62cdbe2d062dab600cf046b1879cb16f3fccc7d687f17539aa41aaed95445b7823beb0c016187789bc247176e1d9966aec999613d931b4b637b2868723094222f51c58787f5b78237ddb817c08039bdcacaea7a8ccee31b6849dfc7c5878a3ffc4e7f60f931015b8120e3ac2203d1ed32acae5d2325254f7e113b12b31c1bae952f5b0543d2608f7506dbb74c16e1519189ad87e0b212c83c9424a65e32ad86f000aa583cd3f170a448b569a6d6be65c0e590367234a24026bd02985eb44470791927b09d69537f1de4fb988f2a98b6c0672d8c50891366282e11c4975fd8a9ffbafff382230d030f0d38469a04a1c147105fa2eade96628c040908c239761959c242c9d5eabc393abd8f1fe5f6e8defac3ebbe64cf470cb6d8eebb8701c6012ce8175788d9bc412ffd961250ba059f2f30f7886d9903b9e805f2aeb759385e2004670a6f3d0596c04d8c3f92e2b937e80dcc8d02caf8caeb6881509002f5bae5be6826e5d9d4ffdecf6433932947c56237cacba6ded0451158a5b970a3c61cc8f12ff778c4bbfdc8b6a4ecb8d2ce52b2f4e64059f5f0e2df134afe1b5ec4c7f92a6632bcd78915fe4744488adb81c383d57461268253c2b831dc5e44f9187fca6763a327212050ffec9375236954976822c435813a7be835fd882f1f7fd09ae1752a0e26790e93243afda4d3d5207ec39163215726b81220dfc7ddd251243b1dea12f23300ecffa91d34987393d53f3a62b3a639959fb65fcbec5f304669ff530735ec1432540afbbd3a1c8801e16562bb5e29aa1fb4bc9e05704ae2151a67487bbfc648617dcbbb4f49e147348d4553b1c877218481100806480db3a9893b05f7ddffd96c2e094682012d333e549449f0e7a8717b60ccc44a107151600b73edb6b8cc880357a1b7a993f89a0fed8e2d38573b710f950181ffb305eaee7cb210629d2a72e5b8b8e1b9a567418f68a5d2570fa71240879af908731d959ab82a11c903ee3c72444f0bb6186ca618b639d999e5dd16e813810fa07e7db85c2855c2ffe7233cc97ac4b77aec252e22a8c2150cef3d9f9efd62162c2fdbac0c045c31a364ad39c76e255b92e27df97abc39e92cd69b67d7f05d50b6056e9aa03c8cfa65890ec5fa4a898a104519999b05a7e0dfa6833b11312e0e736441125d755cd7f6cdcf812b12d86ba3a171ddec2d8d4b2f29a216500c61c05db5cf9571a8dc978b222c5fbe183eea592b4476a805a544a4a7084517c6ea6ae5d3df951543d7541aa53258b31277043999296cfa9ff88c1753e232b077f60362e2064a2297e3cf52f82486cc5b46a791c31e6e9a587f9fd402e75589fcbe52cad9f19c9b5670ff0bb3ebf24872cfcaae9756de40f4ff085948b5fb032174c31cc6a99f3d0bf59b2fb4f4eaa08f4e59f051fddc3ad3b5aaa877e08b83d90102c304910fd700fa6b6ce8c3a4056ea6d85944b7b371acf4524f3c932c293fd63ab9e71e3938a4f9b1095588a562eb04eead3e235a2f4c291608b3e3b90ea16e9b93d4c1d06205aa7a647d18db81edb741e9b78ed5d347c313ad6337ad760524da5d8d693e9dac6fb7b996a6c7a524046ea120c3fb2eede5b74f95d7eeece8769f4e22ed1d8f4497598d624603a855d085b957c98d0f7d2d16bfd340901f5fa5afcf5c617b58c715d148074cd2c2f96e06534e92a0a47154f276a5c3e26b837f9af44ab9ba65b039f0478ec0b431d36686674a9fac056cce75f01c8e9dfbe0d251317094531d052fe4ba72e11b810f44ba85fcbbec3159d180ccb88a71a1ca8ccfb14e8b4ffc08d1c34464bdf1b66716820b48e37c7ed998bb35b73b3dbe0e47f2fce83aa0cb52690c0852e7e17a94dc6228e2dfd877bb8b61d31dcea3e75e0a07b1d1bb7fc9c3ba5a8b089bcddf1df2134e23a6ae392511b793e293c6313097e2230d6199730548860792ed9777ad982ba7baef834ab9aa0ff84d2edf6dfd77c46940b292b753a443a7c0f053cc330c3206a675ac83d6d91c0bd4adcd33595a319b8c15dcc9ab1fe2538fac5771cea566100bafaa0b22ef35f0221ab3099f1bb0a5f05b9cfde2236fbb3100597f30a5d4d8c2133e24ccf1f0f53c72a26de4cbcd46fb011d502648e8f0508c95c103bde48ac10dfaa7c8f92d0ed4d95f889c0b6a0602bead463a5ff95b9ef9d64979a5801813329be08ae846373e4805f0118c42eeb2b2a45242ffe1f5daa14bb67b6f534882d60f90abc24e1ad791945200db250ffd313169c8a1dae4d5f486f5c42d985a8183be2d4eafef951724c206e83913d53d45e2ffca443b953c78ff799d02e4ec666a510293ba7e37b99b3d9d5e51974045510e0f4f6578f8c290b570a37cdd6616168a5c22f1d6fb8241032600d47438df5e6337833cf9f015574515fa86b7615f369bcc36c4d91721703b092b635611407811210830ab72499443f0b372bbef197188d89b0f36d57caa936b591b1e50978e527b0cd18f9aa9bdaf58aa2bbf82a06ee07f735dc135f52110f0ca414fc3a66d3b0bcda223fa8c03ee7ac837ec535438c56383ec369e44037eb19fba783f09a816d74481499df1303fe7ef933c710c0aabcef71807258657edfdadd21ddeb2b0e80270150f0f95e5e7e3bbf6d0d5561a3c0cb299290ff7d6728aa6c58007c6f98f7673abbddfe69180d08f79d78c0623568470a18bac6ee4a230583374927c4fc4d5d0683d79fb686387dacbc0d191b450b31adea7b5ecfd51757a4e21be6356dbba223e9269dab6f07cd98a4fdb26385306d9446d1b79eb4c4e2c91fa723c8a91c99e1cad8560f8cb76ecd9f6e4342eb3c10826fde42fc91f7e74dd4234f9c943d36495ed2fef842b4928e2880d1875b3af50ed936974a7099d15d01985bffcd9c88c94b629faf4b78a7d80437756ba1331241e71350e486698a3cc6513f3be742420907bc9c029ce07536a367ac8429a44f43b2a5bd30b8270e59070d0a90caa898a18346d420bea3dc02f8e50d48664194c3092711213f0ae448a95928f3bb8142f11ff30ff532f6defd18cec209fd81c4ab8574335183fa143f356cbbc9e407e440d2356b7b8fdbe8323868bcf1f5057f45162f73c6f597af9addc4989b2ec2bfc81ea28383c241aaf8f87d1613fb358593f501b4fac999e3110734cf47d7653e4f53b699e216a47f4e019d1bbe1039035c0bd7feab1c04d1d05069026258f28610e5f65c85cfb8b9483ceda7ea6aa2543fa9168b39088e258ef2cba3371ee0b5424880997760abe3d3b3a335efa0bc6393d2ea6ce243150aba9b2a9d3a314887d7c07f3382e887d9b4bfe239ce7f7eb1f5d818b99d04526f0ad2830382e6f94b37966fd0ef0c17ace0a797e67b8ff54240bb5fa20e78d09390d5f9019d6f7dba9cd16bcba23bdc0749f7ee0c5abc68a6980b9bd1ec1405c75156afbeacc5134676a394946bc7400cfbcf72f6969e1ac952448580ba69173805f2714d7fee4070a71def0f1ba3c2777d87ccf124b3ff97248dad7350ba54fe5698b79a707d8e948aadef5000c5a43687eccc84f0a4b61f64033327d7c5447da2d4040806da4897beb1539adb57788ed3d36c232a255866cc0cc21ad9072909befbceeb4d3b748424f1e9ab01b000d96110fe9fcebfdd43b6b12f3536edc755c20cabe49d75002396c46ad95f382487067d7dd8981409c15166b5122464d590cdb808f07bb04f61c0a68b4d8f7f7cc5c5bbfb381271b55c2728c8b5d2bf061d33bbe0781e1b84c1b5fd7c3eb85d0d2612eee78f7ebbd2a04e9d771c12349e06a906b415334a21dc6f4a9a359480aae08d8b3a41b65fef31c8bfd04ab3b5a7ea5f36e5dc4f031faa2230db459f8171613b267e8807539ab15d16c181c425bf7ecfae0ddb7178996a2f30f2170bee3a1451f23c1934828ae0ddbc53c68f758f8a68cb8f46c4635aa1eb53333e162ec3c2cc8534730031c9746fe1d60b5f719d0e19de8796c94885c0347aa2b5e15f9a4438e075c91e1650801dd94d12a95ff4b70a3b031ccdb890a8908346db947435ca724decd6bf2a26987d48296d2f42e0fe9f3512d07f6e9c60d7393128165f67ff173e38e31c66557d270987ab153e2da9f666d172c48dfa9cd133e845a739b7fa265366b0099eebb2957b7b96fa6bc3eaa530e39b0bd620cb47193438d4de8df64930086d87cdfbee1003b6c9375e5ddc082a5511982925b3f8571ef6d28b3bc58df2b3cea033801545bfec2b29114f0d65cd00b12843c2edeeb41649137cbb7c50dade697a7637eeebbf6fcd85d18df6433b73057799d5f45cd38665172f2d0238818ae565c63c5f55ca46268cc85fcdb400403cee5e49feacd0030d766eac6d5170fa9221b14c241bc3a42629b811b75c81d172346fc9deb6f15181caedb911a119d111b6f6544b2bdf12fe5a7400761482dbacce6f2e17d744e42f73c9c30af91e0d66cdd2a9cb651135066dc5feb69ebed3cd22c6712ac81394f1dad160e190ba578cb64c4f6fc166af6c98a03f0b3426360b922d915d235352fea276338b114745cd3fa0272e49fa7b310c64cef6670d7c2772fc77312de21e6bc37e9117d1205c838373d63d919f40e4901f05b683f79fdb5d76d907c6091cb9502c5f8cc14b769a43f84fbab0b2273b5acf188ded1623f7f1a33c334ef62e15fffd1d86cca9b5ed557f900d510b14f0642517c1809539782e9436dbd894798f7fe90e32ea19ae20d66cf59c23571adff01ec4c979b682650b0b7a28ea29fff9a85d591e5ebcd9abce4692e3d436846eda9810b385301257241b7fbee3514a9772855edc4c8716d95a03a4225e45183a3a85c81cc74d50c00f205ffb0f022f04d9c5fe7b7b0043dfb86c8a3a3ad072ec787b3e618995cdfa3ce509ebb2bbbd8204c80b28df8ea3c8e7fce3f1f431735200958d0816f3b9610336afc3d26febefb565eac97c344312e77362b30fc37bb57e190e960965c066753d2b1a05fab6c7402a4b8ca9083fb7e72963b1b7d70e936af07701c02a24d7f89496b4a0f6d61f6d6109cbb4e90ccd4af393f765044f0aed2d6e179edb56c851c07c67c25d834aa3dc46e753dcc3384c5e9c7d87b5918da1c941ce5a5589798e9f64f2049ce97a0bcea92392e55c0bf9238ef593686920ae047c60dae09130823689c854735a4565202a28aece4711f1ebd757a2fc3363c093cd99ef9b548aec0995128501ac9184fa5ad7200bdc99f0e1d4a876e334ab0efa6c4e8c91615e4f0cd85405f34adfe59172de1710cc1dc739a507bfb284d2587f7b68192b723d2833bd1bd9ad90a7efa434b63febf502045a5db06cff7e777fdde5c2c5c0f8e5266e7fe10467dfd8b6fd71b5860f604c74cee3ce17e4cf244e4b57ee3b3f45d15744e915e3c761936d6423ef3f3c7e4437c8ee43f6b892df002ddee8b88b5cadcc5e2195a46d8fa318aa69d7d1e82fdf968c5e6ce6a3c1b264ace4426fb7d01a45efa2f8f7580dd338c9c5aa089a9b3ddb63afaa39a29173e2cddca32ce72857cb706f9635793518c1d3343e0f7d043b9c1e67045c796ac691353a7f10efdbd50784ddea969df5435666b32edf0b3d36a6e49f7e9e8045bb7e9f5be7b3189bd21bdfe0db3ff7c4b08f15d18c062ef74f3acb1c8f17677a8625a054ee5a96d52a9bcd56f640aeab2adad8510aba77c2e2552c2f669ccbfc22e8a0e090e5bd91e49a9176b022c46e5c74a2a2466bcbf1dad769defc30aabc0a79426102bd8f7f86c78313737d33b7f24ddae4e948b1a6a74177ca83e9f2389e640ed430a3b1cc91144eade597a58a7b6b2a093049c6b7b8b92104e3770a4910c854538026781053846f2dbbe48fe8f547153d4ff516d2fe02d42bd2ff3f95016f60f60b2adc0067d4d202434bb02edb17cbd1110855d543c958885172f45063b2fbba404c488f4a8a0602d2d6aa0696a14d27439db09be04b3aeaf6c4098acb912cd88db78c7d037b2834647e3dc312ee58f24c5040a85888594e7b6487c1d07068658e8732c3dfe080d392454f6ce22e58998eae29e0679222f1e29f4f30914cdf04c3187172b3a396b3065dec80b3dabfa7b0e9aefb73009dad57e2607f0da44cf43815adac53bb1337e303a3fc16bc577adf44a0e23b15d6b222bc5b813a6fd7cac58d4ebd83ef4d985bec801a2d398c7ae6e10f3700becea16e1b3d0366d62fbdb5d7404b9a16d98b5e8382f7576149c1f4a0e3baccbaa4477dcc8a89a2fec8302dc45c67d59c25abd05113bba757c7d1896acce254e89d10b21c29012df387b357abb03d758e4d86219460812d762a23a5fe6dd02282a295f899154632d64517a8f64b707055222af66d54c73049fd11f683b03d7cf4d17d66f26e981856500063f7b5bb4a6bb6ffad09437daee117ba8d12b7e702f42cf32577c98eb1c6146fb7066a4932a2a927c8182d4f90035a74170190a6ab1d992b955c585d5266b650ef0d63820682d13dd93de270563ffc5e0fd672bdd2ac82615b28065788359b3e0cd7fd4236cff63049a4e6cb258724ddf1c4fc78aba734a23059bf83121b13e982147b2cc4a66da363cc6e48246582f9799a44e3be084f0d902a25c621065228b42ec2ea7686d76ad790de7e8114ceee6991513c46e91d115d95e36b6a0a536afbd20629a35be25b4c16a919c54923580746cbef399e8ff9c259e3ece2fb806c830993b5f25c986471bf06d1ab0f162474f3169c52623d8a0ddcfac2aeae460a410ec15eba58cc2609442f51a00410a4901da0e50fd7101f0e5c93b2e51558c992e1860fd1337a2a3881b21a70e269cdc12205e50d5106b299cadbe54540bec58d5798d5cb6423c2065b11c026569f51a3fa748015a2c9b5fb7c6c224db53c382b1af939f9322b603683b7df601a3c19d412a6f28fff097b69f5eaed335ed0e85b14f5c706a6880ecc486eed3f19b36deabcddffc7b3e90c1ab3fd9232209c78de7b5f23ecf54d2fd0e9df9c2793ff8160bad706e492aa0c37ffda42dcf56e29a234c2792beec61a75ca8cf1e30db1c525c85f8168f3bfb9bd1f51253d027c0429e24749c170d6c3518b022580b65965b2eca61d3ab550ea837725e425054283a4ef395a6002374f7151fb059bc4421d9f61bde69a2be88a1e2c212f92dfbd148408a844a045c0be4df97695c7d2f6f70cdcc5adeea068f3268e7ec8e714a793bbef2502efa20794b44b71d93caa419eacbb6d790630b1d52c1e7fc07b102c417d85f72b8face2d7b036234360f8af137e1f5b20889a30b486c08a7931a5e43b0fadd8e87059545017d595abad7387b96c3412ecd304742b7ca46948d15db677dd0327e99983d9c11ef69bf15aa075f47e8791f990583e37766b431a450f2c2982a9e0de0c7a2e68929f39afce7b4e4ff5161dd984a365389ab05e8603606842a17a0d80660ab2a10444f7d886d7c890d46fb9f15781b9283c183b08a4693e5514ee3a1b8c9686fad86fc0b4645f73ca076bee36931be310e5a45465406560518016fa94f5c2a99a1e44d7d23308168ce4bdfb2c22f7b8d27746ec38eb79a2b45491023096d47dfaa4ee23f969568de57c3adcb276e76c63db0620650aae61b50b3fc4b4e41e1f6f092669b26a728dda955fe81277e06d160f97358b7bcfb0e97f57f35521b62f97479e354fcedbf952a49033e42bc3f63b4a4d371fa08e923fc34a38eb50c29b9cdd348d987ffba98b26ce8dcaf454e00158eb488369bf31dade30dee372900b9bbb98888450ceaae1750f213bd399ffc25b304fbae69da2044e94f66bda8103881abef31795fbd7229d4d4e250be2178d391195877591bc680dc5262c2706eeaa3cb94351ed9f686f6e9ef3085be8023851021c59e05b5118ba119c6542ae7633355c64580162ae34a7b483e4636b92ed9f4a49d5c806feb322987f7d8c91771b6fd48d8d460e27df34be7f9ca835de427fefe26ef62102ea02498ad8846628b3a2d1198d7a644d0486f9cacce15b550c3ac7a58217087240d24e5a90c04fe3ff7055ffb6d221eca732c4ceb2c014294bd7ee3971ce23b7c72e86c3cd555110137c96c7b0e8cc33b084adfd918f473a90bbb122f19267200a598322f22327a8f341fad3202e451c54aa3eb54453d9b9b67e35cd1784986263b98e7c5949cb25e26ce16c68bad846308d3ab09819be9bc48cb37ebe633c37598f2097dcb8a92a37bbd4870bc9398b813f6d7cd88e3934c8b4fc279cfbc53b1eb00ba9267f87c256555b31bc8a5ac9227f95b0ab4e26009556acb22feb8c9178bd9defe23a456956f7c8d358cdf4e67f7e49fe833dcc65b94ecf57dde220b03b24d7d156df0593ca76de58d14b740129db7f96872debecd405f856da0e658c0b3f4a2d81bce87f9c06c5d696b06aa49099d08289a9377d720b51430aa20a6ef6dc31e3c7a74bb26dae8e2f236b5800806fbef2af1f1e350f646e1fcd24040248391aab4833d9db34696e66295f1ee3d031ca019c345e4c0e0d61a42795ffb20b06587fca533c03bf06c82f8780a2b5ebf2d8016beb6a57ac1882683e58c8b7df870865c52839f35a96548fca0e8876f4f698557d3f7958c837fb7204278acc4012c6b6a41738ccd23cfc9ff03481f7a967dade6149ff8ef0a40b672c17003d26424f928e70bb971b1ba59d4d86cbd3d82c8bde75e328887bf66ac94aefd23900c2444381797afc65f1f8eb89363c840b4f9fb175d83421f6efc5a6955eb3bab12ddec110308b24064bc43fbe5466e6ad4c9050aa9d6addbebc141c6b1b7b7dcca156af125e397d6deac003224a4bdb366ff8390d59fb88766dc91b1de6555cf75a94d9e0df7991c85082d55fd6661c3142c54d9bfac86c9307c0d4f90455d14e97ead55414511bd6ad9f39bc485ac884620d8f57edee074db5fe090189883048b2ebefb2b2de64da29ac2d4d98d57f8fb2893ba6f1e3d6866f2a5ae1272594534a493f3ae9d8e33115809f3b88437988fd8b3b2d53fa15750196c272176c1f0d3e83cb27b33feaf3552a2ce844cd43861e068d507abed28b7ad026ff86e9698d638bf0747455bace0241a2b47b34e26dc6353f59f0fefdfcf3da7668c9bc7fe4e5918ff5760628fc4a38dd9db0b6a0ce820a36d34db50fec1a1f56a3ef0ea7e728b6406060b8ba23451775f7b7d64e5f3f8895894b57a87f26a33dcfd3009945590e26a1944d08b4f7e400b9f94c0f84177548426fef62749e5c271543c92fc023c1f9ba4dc5901a5f018aca8a5049d6b9a9779eeca0c5e2214eef383ea92cfa33d39e892ff483f039baeae986d42650444d89bb0dce87641a13e687e03035ae9e0b31e07fc68b8a62babda30ac1e3ebb45df1356990f5042d149aeb36f9975675af8738261fce0d7e1c570e7d14184f9848f757842b402e6fac56e49f0e643a3eeb29a737027af604481826c67292447c2e1da9d9704642c0245642e1fb25c814d6cc2e191eff958b38aa155ea12ca0b4fe13737a481106a3cd71093576d77e565c89be7b73f5d64d12c44b736d9c1b2f645ee6cc2dba4e3940e68a98940adaf8eb3ae285f962931edf0b843c477262a3f5df23559ef08a77c26ee42237552042cce9dff07ef85acdd0a8530391ea5f12cccb275da616aeba74cd1f69adafe20d972e2fc080353e30866e5454c3747c3af3608082454807bea637b3882e48fd4e2ff6d9e1a72c6211143a38a7d5fbf142b38ba159e62c81c4d5437fc65163b374b344301c2eacf2a75a6f816f59f2d893bf04d08662f0e53d1741dcdbc7aa0b81c1e22f78267525eacb088fa0680fefab2d71ef590023a328d4ed207b04f6f811544029e67ebac1fc2cc693c1e8da6ac3ff12a2dc58c9f005a63748a377bf2572cedd5e6cce3390f6643d1cef570ac8634cd205dc2b9593929dc02d6a6fc0cde33bd8791bcbc676b0286b97631693694750496a7901a1f21898b49a0b06db7b634c9efd9aab95383b6cbaaa9c9ca04d1adfb4e04bbbcdf66b069ee0519090503dd8c92b6a1b745ae209b0378b7be775abdf658ccc30f88fb23c188cfb9b15eea5565075bb2fc72170ef83204faf3a329b247b7a80d6c3ff10a52a9e2297c3a2010f6af261cee2f891b5561ca1548d3ac7d1390770a231131994a69fca7661da65bb5675609e1ed717ad898c06cc72573769dd5116578231f778160b8df40706e428d419c02c77db3ef9c321cc364f8e7a8e597f889b53c23e5351ad3dd820eddab7cbc8e11687aa12152ce6ef41d1f0f258ffd64aae1f481b3ede776634dff5216d47010e8d1b2d92d845844677bed0d380d69f911c2d86e666efc1011dffdac06bbf3dfcf0899256b53307b8a55950039f556006818201a25813a2538ec4330a17692952747a6c04ad7d35432fb12a76134ea6a9e1621bd7a5734b97fbe5cf10fd6bb2e16c755e80fd93ce21e50da17388b5e7d85b721cfc34b17d55796ed322c1e6d0408ee04f99037aa5863c22244174458e67404afa1e778ea4980cde5d486e82e57c12aaa07631e5fd096c47108d8d037f650751d7fdc22dd7c93a44e410e853259afe60778edd9eaf99d58f8fc74486dae1a74185f951fb79c828d0b8c39484aa88bf234fba3301720ddf40ba90d1b214f817d4646cb2bdc694976ce1f1d4181ef18ba5226a56dd9240ec9c1454f16669fb1d8bab0c99c09ab59026ed4741dee195604c25a6be22282ee93dab1f7524d62275f17089df580c75b506054c7ca4bcd23e2fa1658bbf8df4b8885ab13266d369b208ece3721989b30fb1e6ef7412f385a598ff9702674ad18238f4a340abe125681040bfd6aeb221c00042f690e69ff5e0584b47b756139cc10d0143a1bc8a65238e2d18628f4baf2e5e6bc56107dbba504de022e62806c36e87b592ac24a4f681b38d4f0031fed1a587332940cbbac44fb26e81b8a18e6aae9bd7cdf2f71cfad90188c44304d48f6daf7b639d2018a13f19416f7e631bb819fa05cfc0596f652e1620019ca016b3c946dbb85335d67e4d585956e93a82e10708181d134ac4ca41dcb4219a340f602636b59e058cca8b4a928a5dee4c5606e42acdadfd6cd952a5cb4cbde165fa1b13b6876a6df0f79dd0ab5f85129cabe322ea168258c2841aed2bd36e5d5555c0bd2e4bbea01cc2787d0703a1163deb6e42deeb19dac2485258d45d654ca3f4e90b17105dcffcaef73c0cdfa5487c22d4861c8ba2fb6398553c65a91e8902c7eb94ce035f0da967515ccb697ed28ff74c820c9e5bf15bb6562f4985a78a784edca37eb290fac75c7abe024b2360fc1430ae845ce5cdcaae6b5dc07293b9b0b0d0f2ff17de836ea105faa3f6394497a890e2bd4732814527e9965368e3a665705802087ddd7b7e41464f83cf3050e3d47d8f43bec504b7f5a672be3d66299cf38d1a9a8b2e05781f3a72461b94b56c50519fcca79b7024c895c8629a3a84678cfacdeee7e3d118640c563f8f24c854240ea9ef8459aa65388207f6cf65ff5f73b48c348da2ceb64d51366ee5e9e4e3b5470a3c4828095b21d4886985e39576ce74a7852bcbcf7bd70ed2afd35b856f24aad1b24317a53ab06ad8c9dc886df1257584f0d85f66b0339400fa698803f27f897b5d0e9a7ff0414365e9534e2ee4fabdd95a8ed74bcfcbbdec53ebb01778750ca5e40dafa49a6b2237191400b7d4afb5cc71cda9d6672ade0f7aa360b9c72c528a33ab9d30c4065b0ceb53029629b05f36c6eead1a7ebf8ffb4e96454e1ace936f4d6a0f0e946c53f6c49b4925d6c44d720b2d292ef80b331b405479a32662654e695495664f8e4779620a32b217cf604e30524a8d5a7310992c42b88a82de280887b5c3b49e8aa0f41218e5f99ed72728496d05cff1f5966464156548e64e6f388bb5eb01a4b20c5494e22b3a3c1b2b0d820a36be9a9e85db42eb910f2096b8ddbd21fa3aeba9013cd86afc4ba9c734753cd56aa41680aabd0e742d6e7488c7e7fb3dcd0a03e705abf0bd8f1ba95fee1c27baa12633a9f9025cc1d4f8d28178f3474ff1444ae6be40127e3c0219ffb85975888437e085beee97aaf48c409f59246d9515f114104eac99617ac8273ac058c9714296e54a59b6b23af2627487afab84aced4a1aadb09308d18d44ba332005200793e4910fb3c36f456d5f3c9e682d1b423bf70b6ca0319df64958582f3471db7a1ffda27217dca6c4c4552874a5c5f2da0142f1f6fe1fbb38356a4a3c82999554855b43ccd54eabc7d1a3a087f1bd226ac91195de1640b9e6f12b1260ff0157e0c2f191efe2cc3d7d972484e9869c8692406e448aa420573505fc8206935917cfc4044b6b7570efc964dbb28e47541de141220cd3a9a448fb39fca060e97a771d911e55b4a59be6d00b33777870e613122b7b2e9f56706c054964794ed8b7a549f1e750b41b6db99c12ee759f0108f3f2df1bb710b9f38820aa6c1503776d2474b976d81407de0f2fb0dec981e8f314637c2e9028cc2eebf836db748db57e9f982cfb85b967890268534c320b601635635d7197c93ced8513a226c9efd44eaa4c5cdd24a669c21be8b162d830338cb39958cb8e8d03d358f4039b1723f122adaf9d51840b30d06898a0452960806d8d5bcd8fae19c7b4545cd66a2bb31e8ef95c3c448ce6ee871f161a050a3531db7d1896fe378152751a9bcdf3ae20171d8099e5c8a5cfdb1e950ac54ddeb04322b3a153fa02c9db93aed25705040db1b29bdbb7bbc512173a172e863bb0e374d6b194ce8b4975895847de09d3d948b1189006df0c7ba3bb0bb712c0119cb6ed76a30f7b09b90c13b7361b3d0ade69be2c5339212b1398da635bd6835ebdcc2729774d6f1fcdf5a845ecc7ce0de33adb18fc33ea416285672fdc792995aa58ac024d196394f4be3aab4297a5881f899cc4241a2d8cfeecb6cfab988ad2d2d36e675acb67b10319e6a52c16e04a406aefe67d08b209bec4a292a5a35daddda644b1419a8f53a629529f146a579125ecba6173c1a774db6cf40401ded14504da814433126b248d858f4699e33e5548dd9ec05cb4291ae305f6ea5d18b80ee0f2bae0690ffeb890c936d7af92c0a6948bb752b0be834236bde43ca4ab310b4b8118278fccf4f12d1659a7f5ddb39ebb39c56647d7471bba01d85f1df248697297ccbd21dc0a8ec1125caeaaa9dc494705762c92dd9ad4ebdeb556fb41b26a3736e20952d29bf23d0a95f9dfebaef498309319bd378a3dbaebb64183fa7ae3e0bbff7ddf844ca36f8a614a30dfefaf728ab5b43f1921ff9cabd654747729cf07e46b82bf99a01e9b913bf743c8e6e8fae1f9e596308c3c7bcf9bad3b85509f2375f728340bd777e095a447a131cda9248ae6aa526c6cd02c14c716122e5644d560be5181698a4282292aedd6d65eff1113492586019122285b5ee259acbcb8ba9a5b0386d41eb5ed40348c67da72663231111703fe1652fb4ff9ecc9aa3ce713c000bc4d637bdfa34dc474843caff51900b50fc734e9537ee0161f8a3185f277c23a0bfb0fb9e1afbdc31723efdb04f39e05d7b0d84a3f8c9d5679d500b6a4fcdd37c2e8f5494219c24212c745a93c730907b149db9f9bd13d4b83e8ad1a8117e6707ee559416d5d1802758ce9fdb2909d204614822fb55b6248e13f9c6a4f737ce20282f9cfb54737e074625795cc51c5cce1d0547dac10bdee15d8aeb88ebc8f357210abe02a44d733a75462c85a961e048249f6aa288d03c1c556c141d09459f1f1672196ab70cb103e075c0afd522790f5fdbaee6ad613e7cd0c869cfa69939e33b7ccacf6695e9558105d2f9e01e3fa41137928a49212799dfbfe6c6440a5ef6cde47c87ccc91a1b4d2b08b24a92b66d1b58e5d96cef6f85c19c068f8722f965da24d6592102b46a69267b230d93400a18062cad19f4a6ab95927b69fe7b4ed7f26b9f63e1ee13f209ac4c4fe63a20b2644850b8d2f595b3f61898e9951edc99533822b1858be7c3fd5416881ebca69f8c345a15349d225f0a3971f1c846ca775f4a90c4b1434d339a4ab46f489aae4635146624d338e5248f40247e51d1e3a3fc6055436661eea5f77d30f53c9c2550c6e64c469e4e240401f0923d2250d68c2f149d22782a608fa46461944d4c3c2aef2fbc5207f5adb7acf9ff34fe6ae0fe9ab26421d5a820c37d29f48553687f387d7282ccbc868e723524c95552e4fe7dec0058c2c119fc91ab3a450e4c61a7d48610dab507ed5e421a8dd34396ca377e033514baa9e87cdf7ca050c16c21674feb9d2c79af57fcc61130954a062a14e5b980d7286e825a60ecc0f08ad0b6b6b95e2fc14606da6df15c049a320a90150735d7d380fab8c4796e29cf305d343b0a793a4308fb6a733830991c4ad5626dc54da7af18a0e93a5d80e51b665b313498b09c60f7996e9bd6f87a13dbda8c52b8905f3a15c2ee2d254ab5334e4841446f545f3166a8da9afec1702b52bc8fc0f706feebb8a823565c870019b39331a748a45c079a29f6657bcdbb6eb82365c88343682a741e7dcb2b298286e2c3189bfa8bd1dd48e4a8ecab3738b4d3ae0ff1e7f2b15e817a2505ef21d10a160b2c4777219070e09258b46552b533477f952ab0309db0379674c8b77b7ad6c34ef7907a28e9a8b98a9254d46271cee16a34c3619df0cb90182f40285ea09aa0a4b283ddaaba6f0e8a24a2ca3f7f894be56e9eb4d9c54e1013151694bd773c42184a4eb8c45072140ffd4fb1992a6feb50b7bbf38f467a17d466fc178258b876d5e937457afc10fd0d1df090d128e74d2c554ac98a9531554ed4e288861ab6cee787cbaee8e85ac7f7da7b491ad188d3d7920277b573ad0ff96f38639d213a41767d450e96a3773652f52c0308e2e6bf2e82f7e5deae8e915af15ee66db443a819c1c8c1bb7eae2ffceb841c35bff896b60f7a7336a350cce95db2c16c846b87616c1fa612d4233051183d29774865286e0fef233c1b98cf1539be6c6de279bd20ef02a077ecfdeb8197b2ff8afe550df943f00c4c6d29d6bc72500704639415573ed1879e187764f603bc962c7957a117ed3f97015c602f0e9851cef884b50763c33a5e4d7b378c5e0c13931661d510c33b465dcca8b47cf2fa063d660e48f0b6d61ac9a5092f90524d33caf553b283c654d62d74f8605c3d89edab97448bad9b9d594ee890526a644c975159325a672cb07bc21fc327a92ae05f23b88635bb1c03e6cfe73ead2a8e971a938bbb24f98ffbfafc6452e46b74942d648e893ebd880aa0b8cc9e3183512d4dcce3d34a08e5c4867e78e33b56768924dea1240bc32f71df384bb1b378fd96336a6f8fe9c8da23b64e934bb0d9db21b885ca99986022e23ea1d57a085ce5b65c35a1ce905309edf00624096408c9da9b05c35d02bdba1eb66071b03cbe5a490dfb2fed437bc789294b77e8f29471d3fe89fe3cbd8c63a19bf450dcbc00e5417db0e744c597218af9d7cf4bf675538006d8b4aef70afd7b1937d609339290c42503a0778db3a0c8a04fe4516da00065d5d98ca1d691451111aa760300c7523457fc1bdd5111bc8e863754b58e00a9503cab7cb7e510ff79b4e2ba6d1d7f2915cf492d874df7d1e8464b55f1ffbdb609dd9d4e817d538cbd143f101bced91fb6aba0e3a4805d279807b35b3a6213a263892763831fead4267dfd4444ef1a91814a9a540edfe03449eae5258d80f2d3ed4bae62cd41be4970e3fb782fa6fda823f8de1922cebd330c4a9ab7bc0057e794ce3a827463bff4ef2321592188e98c7aeaea6bff37302f33b8f691cc5fdac2eebb3415320d906ad047aa12992d3cf95690d42b453a497f8bee14b458a9f42be4840a35c2c71c8fc0f0278aeb30f1e2404aa81edd7bf09f7f9627c9b5fbd954950bb4f82a864765fb7b269a887b8459548315353e1b15a30714a75379f371b2a48b1628fe59d720497e13726abb8ac45cc49e1358766f7bffda8bd5de259d04418d0794375c60aa4824d4809cb675d4c3c616c916c954f1cb9308f4703e5349a21605f91e1ea81e3279e85a23876458f989472eae1b65345500375783147d23a01b98e751596bfc9c82321e3f6e50184783c057b051b70f4f4872c62fdd4f0ee49a8da6c333dc4e2987e8438c8a9672520e5c65b67a5beae71fa73181756df884f77c0b2b93311134a6b9cb5481e7d6820c2968a5dde3e0e8cce5f40b0f35c1ef4326ef2cede6832fbc80831670aa35aeb72413e55f090ae4818c50800a9389071cf0cb4a2a06897a3ab0c82033be2fa922b958ed9521cdf9b56e4ba090db857c7eb902f5fd2ca338d2956b0b59f5a2fea342860349bd27d91e474811b433655e872fa148f6df85c7c8c025222cb5a54028852bec3301fd3177381dbdd8fe12d14fb54136ac84449a19ca29f78eb1fb7baf114d5f11e141e7c02e9211f370e1522b08dfbb714afc1ceeb8d293300de72710d591246c8d54192818be26b36af4d20765955e3279dc3b4416269e623a2286c1c63d48fc44dc8cf241ba8ef4fe7dce62162c7a8b21504628733191ae5cb176f49d625130e367e1e42de5ae6ff49a7cb99e9b31cc68d21367c99ee64e85bc8e3c568280f3439b40cefe760752ebce0cc6961b47689487f9b30ee26666bf982816bcbefe83117ef8931c6d2703bc3b37c6c9ff0e10b670bce628295319c00920a00f96abaca16a777a01d05e66be15f586de067c8f4622ec9d6a99b755d7d5a25e6e4fab36a612c616feeacaccb7883be4dad7edd1b333a6a4fdd15b3095298ebeb76868154787ed350e8be76ac5f22b7f53640c1d15151c7ca287f0e73584e0f265b681ce88b8273273c6de708c8214eb173c107e94dac01244499c7300956893342e130ed1732b0dc57242990c984d48dc270d273a774639a5d88e632ba3afeff107fa01903f2826cf60428ac5ed804cfd20ecda963fecfcf6be4ecbd0d8602b171da8c070730a8bada64920010f4471e672ccc9777009340d547a20adeb8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
