<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"56e4383b8e0c20cd0fa7a4886b247c7b90fbe1e240891c611ef79eafb125feed510e02a568b333abf997150cfb75696f8774b848a82d1b7ef4069d737f851077a7f83aab59ede08e9b5e41de06d06395c9ce0b8d32b6b6e612fd62b8858fb086bf7e0f1774210733bdc0173777a53a7f5163c167b345b930674096d7bdb71ea9e6f81da12acceb92597c1948b509c18eeb581f019eee463665718eb7841659d28391e465ad8e405341e0a0b5d9e6e487f123c53caf723b31bd325973a5e5b696af2197bace87c8b9327220371e05b844f32f7fb200a9008610b50f43a3545938a991a8921ba7786a178cdf00ade6dacd2cd06ab0409c9498a8aba20e4d45885be04326a9869f66d273d8b8dd39f62794bb10e75094871511f3d171e8d18a5f310f99a1278b84f3b2ca8d5c569610562572b24b3507d568e893de350ed70b23ebb1bf19bd3d6fbf553a0325f302f3f168ff6976ccc86c9ca41889cc7455216d7d7be72f8d8dd7de78666ef19cb46047ee7e7f15c0d84d2cc52e1a2d5faf24ba3583ad6bff82fb23a976038cb4469983729707f90d6bc8f1676ffbbdf119490e24a107350b968ce396e0272d9bc0949fc5cdd1da7b032a188f931c08433e54de6dbfc2031b4c7ae7a0032abed5466486d87369c7981643ef3d706299a896879863809670fb6ff607c1345614c85d7c46a9eccb11394e29ca8eca8f5911176b5a4795be17d57cc84408c1cb68f264db6fe5d8e44e89edfe440dc2f059e43806fb3987060c902d6fd4b03ebba02ab36b3420683951993365ab3b6e628d802e90a5e2c802f1525b22740ba537373e66eb195473515b7194aa19212b0b14a77d3364221d682c55d30f0fadaa6bc75b204fd520f1003457e28f36cdfba2140c1f6762b6b4a5664632e2a9c45c51b89962471af67c8dccd435bfe547d31ec045f6ffe6cdda07166bf5a2dec4e465b33e8a8cd2c1cab6cbf397989bc4f833c39462760167630064deedb0fe27e83a1d3a0e3159cf77ca3e1485220b39cae91fb2204873b402607fa14b113685700e3f1fa866f19568a6d641da0d24a28ea30d60c22b899dabd9a18b54475f2ca02a40235229893a6dc5f05c86b0c0e42f67c6eb7bcf496930dae4f0499ccc320d7fc6311e7184a24e242780f9fb03f51a08e9dc512a20701d4769dee2981152998c65c93ff21be1586683d2deb22a9b2ffd8c4bbb09441fcd1a5eea4115452c2dfbb21980fb60050341b1c4a70f66dfd1d2b03e65fd8f2489e51c5eddcf97e43a9920d2324038b7cd9572c7e0532f2cc199e55b1b9842aef99d183a4a8ef46d5127473b32a3cde7ed0aa5a0c24eaa6fe84a495095604f4f2c554125257c03454a7de2a729bc8b607bdc963a2a83b45773c6e7342aa1f47dd0a8e8655d477f68dd56171a873e51a5d7329c245e0593e2b454254060b1e3b2eaf79e9455d4f745ad1f0fcf4676d5a87470021bf63fe3acfff20024d9fa7fbb75a235c786ae7f1c0cfe4345f262af2a8fdca06cadf77ea5b3c69f79f6875935c541fbafb0f4af42c7b24f9027280435d5d4743fe42bbd38591934e23ce79e79d1b49a2f8e7fc8ec4573272631e0b775afedf36281929bf7e7fe57a5b2d1e583da2d2b97555cb3b8da2a4a4f53d5eee246004fb146c66291446ee52a7195d1107299b78846ef948a518458fd831d34b521c35ccf6e0fba42190239fb7a8f7cba39f558e39d7984ed171152658bcf6b6d801421473e424e3e380312c613ffa62df16d71035df08bde4eb6b1e7eb56b5ca89307a7f84296ed4e9511cb204c5ac2c9144e227827c222c5035d21a30d8d9f543b58393e2516cf07b010a8389f2c9bd772524f4c6d29d6711e9c41c3e773adb333d675fcbaf49b8d8479d32cf52ed098274d75af9c87606600af8fe497c422750febad47a3fc94d1c548cc5a11342a33ad185e044462af88ad4a83680ee8db0e7b97103dbfda182c89f25ee4cec32d9ffbe19ec26b0777b9ea458f7ad4dd3a2b23e613abc68f76919fd8c523fd3dc1cf6fda133c1b2b09eb18452c3dad42a05da9d684b463d4ca86d5f8ba1d595574396d2bb380d64c315bf77d3428e15b42e4088382c4ab7b116970f7b6535e6c167e65651892632f5bdafdcaea66a76c5188ead5ba18912445ae92efe4277c371ef0fc50c3e6aa05ef6a330d6d718768ddab31c7ed072ea3ef0e0fc3cd0b4916dc6e0b2d85419b0ecf66933bc71ae87fcf497cdd9dabc6331cbde441200c43538dad54c9c51ce9ab4a67be64b271b2cf8ce290f2d1a934f56885de75e88258671bd3525cf8cb8c824344f31dabcca74a215f995e403765f71ed4b79d84aa4bd753c1c3de4142346f99d2d0bceb6dbd21dec3c5b5a302856fd07c6ac20f9021e316a18b8bc70351240c943062e28f44adb2730036835bc167995d6dbd5827da20e03cb496d043026171252049cca7e0d247ba965108396ff8cd2c5d7e3d05c4961d69e8412da34720fa673e77fdc7cde4cfc00b1295b455da0d6c64a7bf965cacd5f82a7b3c277fc07019cc4a475874c6cffbef54f2b2ab9f3b4d4da3cff05d3554287ef2cb906a07f089d51d22c83a8a99c3c52b2f67985e2b4775a7919f901349132e3a6d9f752d57304db177a6a6b341418500181b86d932a5e56fab0eaa7a6c0ea3c7c4eebd763c1afd3248f58c183ea7f8c61236e825f375fc78014e80068e358956b955d554cc873109195028c60ac22e5d92349deb92e43984c5314d3f7f27638ebe45d0c7b6a6eccac19a895f580a3acdaaaa2dbed0479ad9d5be52db0efe4ab7577e979eb682f55eb11a5ef47f490f2a88a5871c7002c44d4616379cc92af5edafa3f6b7846ac651494ab8aca877c7cc0f1e06e73ce61f8efab07b7fea30695bd699293349d9cbaee9b7e8da504d48b777ca545f0c0c7915089150de7eb2f98dedf6e176378d5b970afbf020e9879b7dd88adafd2871be1aa23145b3ecd7d652fad3b25f7f65484e75e6217a4f345179ed89ae8c77fce56da502db92ae101edf353f71f32d64fd70ffbaccad0847a6f5e89a8f4d772f7cc450d81523e256c0e3962f494030d5dbed84fc307765cf482f3d47caa797e03a11c80380de326c1606af81993bc31d466bf5690c79d8b7419d40260a185ac6e95cd02fcf71eec6d639428198a4d57d1173dfd0bfd274f668735cf70ff1d5768fb4222475a918c741d1f517b9aae50eab17a4459366034430b7c719294459a5a519ac4af7447b1f074ecf9f261b1de1124afdf1bd77be3512fc0248d03d4ed72115d8363995fea7838f16df59d99863a390c32e1f05cbf1cf3abc7bf17e115fd3b44d119c9206fbb0b75cec39a7052d7dac2c3578ee17aee3546264c87a6f4b5cd22f1e76c6055e7600086f272d7cc9ad0f8559db645823acea9ec6b3472d239e7960cb4d71863ccd01b8cbb872adbb265d2d2e2637e0de95db9fba3adecc4db43d5a1af5b4783f5621935aca55d493e8a202cd5f10459a2d84d683803acdf436de74ef2d89237129225c5af96b18d9088a31c5cf8649bff290e6a4314fd5bb1eb6fb862cf366ea22e829680bb1e78b336b54b6c8de2f5cb5d6410761dbf9489a4c19c666991a2b03442547498b698b7e07d71cc76095345e1d60c99ff8759cd07e4ff59a8fd829ae7a491d111c8acd44bb72a9303ef23875a04d604af159edcdbcbf7a9647eab57e42af98c3de536ba2a2b93f7971706f77c14b1ab544840bf7b402299381e44450a8c79f55befa52e25f2629d4988363efa6e4f37a14c433f417958c8d9c027ca51b287cbd99acf6c8510ea59d99d0feaf0bedf8a3eb4e2095657b7fe67855288b6397e6ecbf6937b697ad37a43179b53c03e6c718b5e6ac2a80a132825da8db24b248489b9a69a5aeba348e69bca8f943df8fd2aff60bec30eaa1e15ea43b9d8837d5e6bc3ca6caa33683395cd122b583b53f117272b6744536133caf68437bf91c1ab46f9c1a402d876a218ff85b9600900347cee30291b878c458ffc749590cee2e0e2085bc928211f0f1b4071e43ce3a16ddef3223c47d9da624233401b9506a36fa3b8aa831534c1727fb0fb1bbeaf80b8f2b4b1a14cf6b2629aafd85551bd2f61a143cc5667755b3da00fad47f464b21dae884659c2cb021860b643cff7f32a9735b9ea31abfb9f334f9c93aff400faccbc79edf8aa1d6dd194eb062131ca0dfa40bd28462c6cfe1ef1b90e4bff7e3f7ad45e206a5696726beef4e0bccf69bbb7b7b39f4e2350faf3f3accc0cf68626fd6a13c0b9a41d84758970a9f48e0f1aeceb3dd163a18ca32963419251aadda9e180c32ac7936409f4b99589cec634db6fa144b24338014f216084e67d7928670a844fb7396d28829f790f6d7667772dcc82268a15e7463a6cad615a754e8a1927aeb1d8064e82c0d32cbaa1f94befe4bbb1810c50d5a11d5a5a19a77e6feec54b17498f1a6c3f638f11a963f64d921da905baf66810ce3e5c87e71c042573c6871f0bbdae55508baa1fbaf64b33260d5bc9e855a24872a92b87a03bd2b91c1f1a2779fbf61d230efcfa40cecd8b9c7d67437fdc479d41a7899f4e4e89ee5469969b3f11e3db7502716aef6bd9fd514689010cf9d46b9f9dfccfbd2e4e64cf6506af6d43a3a74d142436140aaa05b8c5410fa5fc6fe2640164cc88a7a2cdcb893ad73de2ae8c7d79a3f002aa08ad60d1bdab29e557f62d3f1848f1e2f0c21ed9a3eccf678780c5989f4eb653144ae81f26a364bfa2c06da2589ceb1741b469549c33d6dfbedfb70d1c618f28c046f593e1305f2f05467c850f115e153175fcb52742922f49b92aa9ae3767e184d7cceb61e5dfd1af30f728d0eb1714a5266a9e7e07c1d974af77cf50f3d11f8cd4ff28790eb048958f0940184a6b9120c02dadebd060f392175ba64a1facd2006444eab57fcaf67a7e3595b816ac99c4a0979aa36ccfdcde0ee1f63562a91edf3a1663fb014d66b58f72d6732b56b6f0b593af7c5e34f24f3f5181602df1a14217dc844f38a23f2f6f68025f132c783157f1d557e845ea35af311a19b7a00d468856888ec38bfa013a09ad756e8d6aa3b8906a8ab32e3f471923d6273aead76f080d849367b7db70963f4ca3972bbe0550c8b516ce044b652ca53385d18ac11bf946545e1c6d8155d7a22a3df4be571e766bab86c8433b46d6a6abf37a94cd2de8e35d21e07f87b2825f0704a1e46308d4478bc3769e3a0c7cde70ed48670e24bd7412ba9ddab97d87ce3d142de44b054338e83ca9da0d25acb1de42ea1f137713b019fb069ff054104865ccba2ed40c09257ef8e16a935fd7f9310cbc74300e6e24042bd4c3f2e3ada649c109e27bb34eed532de5d767f1dd1778b963f575d5ac31971ded90d211e47b39c6cc03a4df3f1ece9c401b5e5fc12c914f7c99b52473c8f226b21b18a8971abe1fa48dc8d36953dd1467e4836634d4113eae9da14599d81deb608ac774b518a2e8acac3e86aa836a96a57bc703f1fa8e87d77458eea27e68b2fbb8b305817a0744faf7cdbbc8bcb7a18addc57819608cf49ffc7c4923a338ca869f3ba1f83751bbc92b8ca3b0490cfa34d41c0fb84914d418bdaef9be0a2a947449af022cfb5028266656c37bd69d225b82afb8e408fd950d341265d87fa81cc32a22bd8ba49613875e200b4cb9b93b9d9f662507b272ad7f2a4cc3d3c103d17cb73b2164f8cc23357405675a8cbf4d4b779923975d354f1af4345ff52b45e7aa461553c18c87c2d18a73d184362e5b0a4d36b149ad3378a135adfe2187ab10544da7238a106fbdfbfe8ed046f4089daa2496abc35b70c23ff7e142295d623778c8eb7116b119932fcb57c0465d17d7283225cea7d003c091f36d1f4c8db05b64a02019b822680d058d0a4b44f0e26153e1ff2ae9b148c4838cd30d29e6e751478b6d2b3319a2097bf91bbafc7250a94b80134e370f451375cb3d8186ac65aeb4a7b6cfe6d479e93a86fc208539a0c49db278870fc7ff4055952a4f356b3d899bcf2d35d4e7e141d462365f02bda1ec7e9ddae7a0a08276185d13bc51b6040bffdd91bc1aa378426bfdc37f642a7c61d70eff3eb9019e933cc4681ae9c7818c5d836c358d35b55b4cad0a274c3f6f596c9ebc3e88b2824631a35c6fec3fe908678315f204c64f88b32680e3290f67bf63778d3b3e33066fbed62a0a0f8b55a8383b251680f36dad02db6054a021afe41ca3f796631aa98afa6ce2477d8c2438f1ccebf02901b524c43b1c51ba9d2301c321c3af2d2a3c5f64738c2e2ddc8bfcd2cc82f1399447417ec99bd8265b18ed75325dc03a2caf9ee380ac5d86185a0dbc13617b9fa163e753792149e197549c35b20a9919d562d3803a1896a137179216d54c3a5ac4a30350d8f5f84e3592da67299653ab7eb9ba97cbbec670cedfa3c1aa4a08f2fc79756c5fa629b8d1878ac83f5e6886563204375ebabd0575ac4e1a1cef7e137163a7befbfd5d7c110526ca94b410e2d75b3e6c6853ec2a3dbf787ad51a770ae77fa8f611a404fe15da891bc0133b667305085a5a1d7be2d1371ef5bce7c43244c571b52a970543607bddcebb86b33f132dd834529e0e22afa1aab5ee639704ccf98b4fc6c804f393f7fce9b50c362023a9835f0c5022b20c8dc57e029b9b71a928e42bdfdde98bb0b17a8dbeaf49803af768aa308e09f325d076055f1aabe21530a0dca1963848ec70ee93a4f6910df329205c0a089a7fda6f7e35e31f89e55380c6af15a947e157df79776a31776ae68a8d2840399422f939a8e22dbcdd85b4039af3e23dcdd30a097979dfca50889608f401ce044f308e1dd433117b48db3ad132a89879c4bd46f93f94a516dc79b579c26ce40159fe6c1e95878fb2340b8388f2fa692599813646b9da4417d7a7796f6fd186921e293d69442ab8813a65607f9e4639d7cb52d286c337e19a5614e6490340aa9fa01f46709b6d91fbb3485e23fdb874bacc64d2fa22fbba8b8621478ea6c8974cd63473f312b83d530525b739a3c345e6db08d8848a0edac25ca479172c091df6f89d9f1e79389724c45cbd463bbbc7d04d85ec4894f093dc3670840fd7045ab84b42f2b039a08645b60cf0bb5a56d053f7ebad3ff10998d1ff7552cb11123fbe9fc7d88d0c03d587a191e7c0ef3a6fe04557e5c7acf202824f21c5fd9fcc312573e20e1e4e27604a899ac0a2d5ad2c9da7a10d1cfac40b0bd211ad24d76d216e28125d9f08c16d05ef860b70bfaff9aad613dd61efefce3f8b0750c9210fb14e19cb1c61c693b0e8061cefaf9762c04b37b484899f0218cebb9017d6d20976959f40db0b086d8cc01e7329d02ee41f4a632f1ef9a08ec1eb2fde01c879531b6753d48bfea27e8a312582d3b83f87923bdb0c438553dbf3cce26618e0dc24eccde70c8d350e2a9c2a36490857bfa5a07c7b4b792b36ebd7234be9ebbe11a055399d74f93a57b62cb794f75f0a3be46c1f5d8aa12e7d43bc7d7bbe95e1f0d43f82c34e1d624bb2894df59bc3f8978bbf33e829095a9af6496cdeb1c8230787ba65b7c64fff25d2cc4b14e67fe207a10d9bf79a42e8ac637fb122427c78c1803d2aed0168f31ce5989806286665428e87a932f691ca5667c01c615f8df000dfb1be898fa7a5d33bec7829d5474166abb3966ce2be3f777c35342688d0719d8911019867a5d426f35b630aa37478abe1f47235d56134d7889344ab766e0a8ec0a23682e7541d0623ea613e243bc8a8723badb93d7ef6796412447c146edc71d1c7b508d9a4cd3fc29da944dea85edd4fbb53e4d7ff7d5285d9d16ce3684e4fec7ce17b4ba1f747d46d3431e3eb05a20c3fcba3d5089ab50f88da2785549413e2f48d32a575ef71a591038edb70f6c76dc774528b8659783017412eec1e881420429e1531759231d638e0ec82a402e40f396d79bd73797e67893bb9644dfb5f391869c1e411dee06103b5c93f43a8eddf4e9a86a3d104eef88dde80a75039b65109eab71c17a48434a9cd31f44e1a8232336a0c539e8e8c7fb04ee6e22d6595803a10d8a171d7d011d9c0fdb0a5564c66b7ae4edc7db16f2a08dc3bdb6f58436f26f248430096843ceb16212871d14651bc3d60928096d13ef38315db8ddb8a7e468dc71652273ef58e9e6f00b31275bd7848daacfada4d036dd95bff83a1b160be23cad5179e1c7350a89e5262a4caf5729d3e6d80254049fecf62fec5f9cb6d8243c49726d0582544dfc122b52ba8e8c356992312b1939dbaca4f4753742497ac655abbe9bdd35322fd22e3f191b2bc8da9d83d87430fbfae518c26b3827a1454dac806e2fe1692860a3dc7490753545d9d873dc8640851272d4282d838e5220bc970b76e62015765baccf90e239a155f3e313a75fb9f4cf3d467a16ddc8cab920b69eea7d439833ec2c9c45f80be57683e3f6ae018ed8082805c47f8654fe5e430e3324da13f5f088038411a8ed56d17c7b7d10ebfeaf90d802b4d020ac4ff787b7a50f1d5bcc2fadf3d9825f82a31736704a559b6439c0d620ba8ab2b5b64299679e014110e77b8f76f8f2ac22c71609aeefdf61f11d3740cbfdca997b5087b410dafdf16c7d2bb0855eab0d1eb3a25edc8fe54a683499adcf717ab629b492fcb519a2ebdc72694e277e99e387465b39a212d0cfaf611149713edfeb944dde0299de4f4a4e74081166ece6c45b6b06bcb76de4da6a59d63907470a11cddc397575a538f4f0a010a93a30f7519511a1fd5b2eda676f38bc5b8f813f9b0d817861463c342738fdac44447ed78901e4fb1ef80e5a6e6e78963b7b6034b3ebd99f845542ee5576b02e5de23c410f330a5e5bee8ca709e1826a1462b51752287db1a941a42239622325e628eb7077d8620f1539ffa632eb46bb0dcfafb77b7128ea3f4d75d2174dafc61e9caa00c7e9cb0eab719d0446c2c1278a27d645058c8f1ca76ef051fd915f2e4c54fc269d18a954c257a8e5f00a09e50d96c323bc62b0e4443f1a23de56e41b0a79921d13733c87aa8eb579113de2d93e80f9739d2ed1fd97cdb19f7fff21a5dbfd3dcfd41e5568d06ce87c288cc73f433af3306836e7591e5ce26dc24a0472a11d2853517c81b491836ba1cca2d00aa45afda006018ac3998eba1c9bb18b8d1a6cf04b32e9e8a734d6fad02c1185b9ea40d8eefed62f198186cdc02d47676a76e3fb184eabff8a223c9691b9857e8d62a088f6be2663286f2f618fdc8447650176397cfdcaf9c63d23ef91405af1e7cadd520b18c988971155862b8ccb0de4d2cbfcbecef3dba034b9ed1c9951224bb03b9cc0600918d78a20c3633005624580dd75e8f007360b5af85ab914e624b9c0695ea3278c79c91b96dc96338351e7d5df5ec463cc5b8232a5943705ea55df6349731e445556278a8badff96f4703cd1ac67fcac9ded3d358714430d49b59161a19a24456aac5fa62e4cebe7d8ffdd1c61ab382511cafd78776974205dce231c8c34dd65077856936195af1a0a4d0599ee352d3405a44fcb4002884227aa4694ef5396ffff87771bcf668e63ca4ac1a2fcda7d6cb5f4380505b19c7dff5d9e981fd626f0a319f8abdb1602ae5ec678597bb0cde7ad73234b5f5fb6b95e95630d24d1abc19b150c58c76612ca94b18e095941bb2e0ea8994d87f4e3c578b01fca727d01ea7a20fd2024b9a9224eaa15a13ac645efd4de9ed2402b190e9c20be3a4f2a79c6f70d2e28fab54843d02ba4dad108a2d985fbf0b78ca7a447e45fb910f0aa6731dd5c11688d49b73719bafc5c1dc9340c0f9233a1651e4116b28ef4a805689b9584077ffb1eed87a61fce0db0425c3c2f9223db145efd4a6ed82adce7f255d5fc2ac506f7e70d669c9466c3fe803f73c7c92c07ea632d8b5294463419cc59a6e1b252f96f178ca6274f0f0f40d4bf4225e4fef19cf23c5f6dc3be75d93a54f15b080c8453536f2c7faf67bde1745b4b27d1ae64e59e06cd0b640639cd364cdfbd8010da816c684f8ce72707eec196ffee15f75a753ad504b4995b151ebbab3c9a001f90757f33be631a35f9a80269aa84d6313e888116a31822cf28a131be27565fc9ae523480f0988c1122c0637eb1cd71ce7faa4017ffd7a797834f2d3f2f14a4a65035da2788e0d3a0f00036598c916636b3e624618a22d9b6f8a5a24fce10658a4294d83bc9ff31b517d8ccae3e564ecded81697a5c23b666a604c702b38e263e5b69341f26d225e53a6940b6543f475f3043f342894f93e46eb0c65fb237a9ba3d1314fb6a17376f00f08ce6c2cb9ad96abff5df4473ac8f8dc1ea32661931bb478647338157dd8761c38f9cb078ad6efdfc4585ecdb79da7086fac34ce8212c5847b93d90526ed2e53efe962e8cd257e10bec55c0b77fc0910ce748e1d9b9e566c277211675a5ba1fd7036f0cbfa42d0eff3b28d13a2258158e4d71901fdc4531e999f30f517b256f9dd4fa2fffb4d2f0c8ca9a0e5aa788c37300b9f3450cb559572e9d9ca10810d5167cbb7540b4282c090d7b6fe0af3613a1de2418b1676e46283b6a3f744e33d8580f4e1790b35d14f8d79451f27f44f3520ead758f8f3807785eb23be4d1d7e04fd0dcb0d97832afb4b3aeab72474fb9d40da4a395c45d0e5708eaa57d48a3486edc631b6d9c0ed788e8c3a50856cf881672aaebfaaff7d098ddfeaa6206823e5fe1d1da14a65c8f66cc33d25dc4f5b573ef3f96a4408d511168f9a07a21d792ecc801e11e63870b50b734a9c6bdc41b9f9d04ac589f29f2d5de9fa51024dba33c08ae1fb3aa9bd63344a40369eccd4a1fb644ce90c08fb9933d264f0697a733534526d6d021df6057ed17187f4cb613ac6aa2a9e66d570db7aafc4f72065f872e3281c4020a2f532aa556aad2cd69ebb815e9d4dfc87bafb67b18594f04942098d9c6a3d992488843cc011e0c1ef2e0ad8abc5bf01c93811cd904350e1c78733941ab096d787cb4167ca16fe6a8fded80e2f7c6fdf39633d9bf89044bf8dfe0c54d9ff83a4f4586f49bd670201d9f3b86b8dffcedc0973c30fb5fbf60997aa0ee598c12fc84896d2b826832eb218197a910914b0714f76727e44cb6a39a4ddcebda94c614f6fb2d2bfe2e8ec239fd875e37b8d57d761c46cd09ab22e7b2e5069c6fb1b0439d073341d1e7f23b32a2a33990597d63cf04a187058e15592ff8f0be3728e14d9d42f89d24d803efc0b170db4810984e16614a8608ed5a1e4f714b104b7b5a03448b18c6407881058a6a8e92d6d4ff8e2c5e7242e827cdcf33d23dd1cccc9a4e9f252330ba25598778579306e965f9b6c74ccae193e6ad6ad5db3b0695afbe039cdeda517e20b92bb7100b7120f53127b5e29cba2b6c28ea2a010880b1b5deb23e00a26779d3d3901845c34089d52e837db42c9965577ce88f66ea82295a96ba2f2ce25d7cc7250d138a33c84cf02191ef11fda78aa11a78db5bf4841b6116218297f3cd6a87a49a2e8164b624aa6e69ebcad2a37fe09fb710f4a0a640cafeb343d6803ef639d2f5e604d68ebde5269a684cbe2c15ad133e8a2a96fcd1d22e0b32fac3cf92291e2fcf75144eefa85c0e42483b451898955fbf4246c15a264cec771e7bf146eabc568d3bfcb18da709486278c9f016ff3e577f7683078271571ba935fe4be38a27155aef4d35f7287f614eca65189935c410615d52895f453527d250f2317a6f69a60829435bf39ef950b749090e2535a9794209b848acc8512899bf8ad2709255d92709f26e92b63d3fef11c44cec008f2c6618007b8c5797d0b2bb0fdd94c39319a7dd40be3c67a57fbf77cc547d4727686aa658c73f68b6469719c3132d55126a188b491adb4022796fc1924d1e194028ee66ab7830292789e1931aca8ae4ce4c951344c1394cfb746090c45a2cb0eab14dfdfb5d75ae03e58d2abdad2c21e930d0b69079cc3147cdbcc9c32f4fedb97012222fce3a9c6b46e084269cf2ae636c6bc55e721ac377d85bae68cb059df65b376deee2dff89e791bd03579dd6217909bd3a85e75f5019647dbe0c17fe95ca032dd0b53711656afe1881d727eb04f266eda8b029a6ded76476426c1abb23843debe59b84566a22902ebf517766b938895d5413f2cc3a1378bfe14375406c66ecbf6fea8463a791e6826efa3e560ef08f705a5d5b9978e19b12563749ff695b6d8ff3b53a507b500c4a2668381b450c737ed9bc6531189e5469ec7b67e09e38c2bdc053d881349d0a2ff12332812066b3a2e317274efdc278e791a69ff22f927e2fef24a7f0086d8f1d6344c9ba63c60b95f422f802de7ca4f18083b0d20bc6397351b85465ab700bb2412f47f233c03c1ee283647ececc3dc1f8a4d0f525134e584d4cff61eb84bca6d3941fce307384d94785d94c2efd9d5cfbd2777ff6ee167f0fbf103aaf6b83b3ae1d0de7e873dba0646921cd58c0e0ab4d6feb381d42d164eceb363b955df8b7874ec15e885e09b24b51330fce9a869dd75b70765b84f54cf51eb5a68a5f06e2cb8f21170f9d31bbdf1d26c1335f3bdac1386c1750b29525d1b00aa2f71659a5b04ce1c11fd60733b683e484f88779f635eac5e73f5486cbe6988746c5c24309a4fac93ad319235818345e73574e0b12b86bae5bc27dc676305855205d48e87df291036bf07b183f79270477e568c16674bf9ee838934df50366e128bc6390ba1c732137174fb30e67db0c1f33dae3393ac7d53d24994cc77fa5997da962c8401091a61c8448ff2cc165d84aecb3b8c1f2b25084475bcb7d22d58242a4c9c921181396fef6a086f5fdd2b8d6ffb0e8550ae00413ad4828e7d4d0dbe1b6a2fb4637dd1f9995d2ec8c0a38eded879659e95c2026a77af2a37cbe55c4d4f66add37d7d38069c48e202c56d6a4183992328ddc69a01c7bd839244b10977769af6bec3fc140ae4aa00bc7eaa48b23405bc51f9a97a5b551e7d606a26c839351d97faf56afd5a5549ae8319b7b1a66ce975533b7217592730cb7219dfec28c36596ed9d3acf92ac52e5e15478c157aba213a9b6b480c5358820892c4ca121f835da555d572b021808cbd7ded06d79119322ad61b8fd4f48ae2f147e70e309b46d2ece2cda4fda62d9909bd6ae196a99e56471da7dc00955e69b1d22a4c93df3b388148d20af66f4bdee5fbf03c0254f1ac7a28a374b16553d3f49431ca3c35f9af7b618886c4e2b49b03b2e1a5dd9d33a83dc009ed8f9d2b24dde4c13abc23ad7fb375a852a6309cc1b81c409f1207a2f7534095926ead482d54225c277c53e415dba5a380cb54349a64b89ff8407c7761cd07abb172c5f83a232178cb274b3e3955f9aa04f08e56caa9b07dd28973c95f52fd689b6d99f7e6fd9d0974459bb2fe2ca3f5f7b3f3ac11ca984ce16fcf80eb4ea730581862f09be4439da93935b421d1e83dbc71fe2cb1ffe4c980bf2e31eacb76406a68cbbf4e5fd98b162f96d2c818cc6dc4433d3a3900f223a519b6e1b9e6fc36b7144e66c1102be4e5a9ff72d02ee6d33208e0fc84e8dc2f9edbfd3e84b2f90e8edd37b3db23b9f8e21490d5fbb29e0ff0c88d1a59982ce65424e06e777f6966997b698ef4b13abe03b605c0fa2d403592ff00e81b23803ace2f63f413fafbb7e575ca74fd72cc9f52a8844587bba148a1b1e158de21da305611640f45caf34fa5d4dc23e64d061b127bdecbb0c9e8b033809397e1facb36c6789bcab6ce7d3e52bb3e201c4f99d4e55f6165863a0dcc0d9e7376e4f0eac10aa6a6cb82b649ec52aee72642286909566042cb5187853ff4e505da6903bce975f2b4e2379ce9c45c655d6a5c6f03006f64da086b5d6d75e32c5148a1914e477b219a2846e340d6fed86a6a3f6204ebc9124be5b499c72f613e5fe1da5d11918b9cfd3d8da14a7348e13f7f0238a4a749e502d6e050a6b34501e5a7a96519f382a4b0d5974963feef7a6a1daafc8e61b0ffa8ddc089f910c794d63d93e11d482a57373c1f06b864165130ccc053ad189981e27b8386ed556975d2bd52c4b1884e6a1d50d34e00d82bded3f5601333833b292943b72fb3a73a0bba910baddfd9cd5b0adbc3be099280030e915e186b47e4c01d5f82f2bf206454f7c278666b9a1c9965ecb36a9e89fb61c6722b2e3603b37b178d2e5a4aaeae91d200c4311cf8221402e8ad458d0eb4d319383834039d87772781f5c11aab8adb63b12758bb8cc609a14d3b55a6d3144a4156a24539463ff667f3bb5b498e1f8d5ce53c0ca525df2a87b459bb4f6c7dc591081d88880921111098ec18437b7aa8bd73de675953622d4e4ee53d2fd3cd0c7f0371223bc8ed92b273b89ddb51052c91f357ded6081d1161d7045c01b89bb665ad4c3f6d70e3be2fe23327a6886f7bb28de071afbf9f5d50efda3a9cf48286526432030bc4e96a2c7bef57b2b55c0ab34ece3e83c6c5c39b5622c0645adc43c1922e4ffa71e09a407c07bfe13e7e193aa018c02ac5942254b31bbc981826b9445b1a42b8e7099f295e8396cec7041fcc5e9c8fa7bacf34bc11889fd19c2ead71522f0264b5bee54d75ec18a5c028d3bcab9d0a16ff6f430c12bd01ae3897f593d65e22e108f844f5fafd7b558d971d893e796aaadf2ccfc67cf0731e87d7c0090b6f8ae095f0eac3d72d06881dec1c622a42951288c4a4253f4742e54f6076b98ac8dcee5083bb18622f359969ebd92f0e931affe00a29fed8398031828c096b28e74f988347f088f207842d8782bf209b8502880153057807b39861d3ea707c9787867b11cfaa8171b5000b956ab350d25f79e974805395f9ece44462a9b75a1e648e6654b7e38e41bff9c6dc3f79a6b68f9fd5c0ee76507a9c66017f21ede278ffd641208f971ec8a50f3425700da30a3d7a0c783341c9310032c989b776ff62bbfb4d917fd1c35c97a536b8dd25d9ceada04f97ca9bb0da1f7641a00b05cd76addafd1c1772d6eb703bb5e75da3231c11c4f08ef8f9c6e5a855b6cda50d53b4c11bd1dbdaf2df36c2eadc73b8057aef7f3224851a7d343a17a2c2f05470c319763c17d4215dcf3d929ce36971fbbbb0041c9def59ccac0e903e9afe5d31271037f111b0c89a44cf5f56fa304bbdbae00d1c9ecc2667b94382d5b050e23c3cced8e71726e09c99482fd5acdfb10acba2d18d174f8601811dbce5c0aad4df10d5fa64160088b43cf9301251642bf6bd9361da30b5272300409fce1d0fd158cb8e18ee313d1ca44d19d3b740d268d56b84b383434d10c051cfbe4c4e062918a8c72a5906c7a44e97315e4a020c1fccc033a59350bdb7f9faf087b731e834084f59651bfe657426bce5794cd99480b6d6832f6fffbfbd91d2054a1141836cd54057ce1c7167631972845e965479d0f7c20d0432b9da5fe86f71fd832499079d5dea63d40353df8b585cf52a49a84708c1c95120d4c825e3f3e264e1553c27f153becb0dbdb7c0a27a549470cc38bed7cd097e8f0440d2f3771b22163b7c3a144a117f70bd4b32965a1e76a238e430d0a6b04e992376765879798d112855e312777a4aa6dc2429902478ddcd9494219acd6e8ac1931a9d5861c3765475c233a1bae76d9704188507413c2b0ec24f2ebe1fba534ee61865d4e8824ec34af567ebc64ba2805559506b66b884bf98d95eecafca5688a9876696bf421d09cece64538426cc934363028faf2f335a9ac5651b6ad6ef3ba22dfe0d4923bde55971f1a6ac43d125577199aa6f2654f6a0b76a662b766c3929c7302285c5afb0a544468c1fa5976756696a77b0460e161e06c68e30219c2e80c46fcac6c3e7136f4043509ab8427e6a025ed18848a1222c63ebfb8d4e922cb19cd933c5fe06ae8dfb67aa7600d21bac480ee8895a6fb313aa983101c920ddaeb4396777c305569e3f5b43c624c29e9d2b7ca53df4ee1eb7068599422206a1d950d3c36f0035775f8bf8b6af6d08ed846e6fd46ad20ec5afa425615588765c3c51e0ec2191b810d279e864d9b49941665eb8bfb772a86c5f72748d55bac5c19770b13df4de74be81ac74e39fdf9312668d5be4f02631af41aee2d2b8273ba224fa0d87601dada5b66dc41f08729af6202963ddf97ded8e4fa9df8ee060a8625f16d46b832b00faf6fa4cfd8674b09345bb5f91aed892b9769de998fec0dd1af9e9f114af34f63cf6db8cdabde208bcf82ca9f94a58f417f6a73ec4c3bab0d05043e75e5798cd78bc882dc34201afd2ee0bea4f6b9b9adb518d3dd63280310fff1c9b18e8c0164bccddd8b01bead377a5cf66f0627e3f6f0ae651988e221db00c224a36587694bfd71751ef71e74de22c9cef14e507659e76ef24eb73e84df290673db452432725131341b9ad598fc04047ece137a29f2d729156c5dedb33a5a6c0ae73d9d5133d93bf6fcd5e84d7ebd84a9ac93e0081fc048ce23b6b840a4850446b890b698785f3c27756e2edf141b92ca9b74a13676283df41e579aeacd0b6c234e80762221c1c39bad4a77a3bf5dacf61ab6ef7d36d79d189b36bef9c983a4118d6009e62502c2dcc34b8d5440b78183f43db024117441fb6dadcfb74ce307002cb9eaaeee3e7a2c279ff4b6fff9523951de36b88d54810073a8e43cb3c04bfa863868148996ef1b61e0eb5f6164ffa1529bee4cada1ad7ffbb9f40de6abed60fb9eba673de1bb651c53ebe99b6bb689a2f0b258fb44074a327c68831737b8214cfc5c527941c3c82980f69263ceeed72c7c150a4ca83eb53c579619b0614d3bef6a7448ab3030ebfd7d6ab75a1bc738dba9cd98dad78e777c7266eddb3f5ee0c88d714b0dd7e55b4ed69f9656f7533ad6e07c16fb93b7915c8f85c01821705885485b19d20e7a579ddd267ea01777eb719a1f57b46273e1d921cbc1deed297937687b53dec86b37dbcff76c1156eb759b5c0048c7f25f20ed37392ffcbf235e29b2a36899bccb348e914bb6b0d152a751708b2e82b21b69d0e1736105d962ae47bba3f571febad553c2a12ddf6e45d86c798cc409dcaa8d60231b03c2b05687bacfdffb47c06c1260c786239f0ab39a1787fc5756b809f7707d4f31b60513e123837768e7c10d36f511ccd3df493687b7ffb1f487b179fa5b3710574ddfe4030e4eef2423b164349df5663c7e752c0958ba184b6e045d48640fad3366ed19b4bb072122cf9ded46889a816e74896b689b07329ef66275e68110e2afb728d585b9f468f822fdc5470904cf6a557cf11987cc93efe5126b5f907a2b5b382639c0116930dad15fc4c8f30a42d8b50d9dcd73072ed9848cbb4ca61c141df9a6101bae293176782a57ed83d8197de88e483810fd7d2273cc56e4ecae9724ada6615655035957cec8f15e0dfcf2798a864dc08b2bde0be11b8785f3436b3f820f9a25bd04e0bad34d9ac72c4c7db4ffc921cf308256fb68b601572eeda86e8c72ce6c5e9b5b217f1008b4ebb896b69037a079364916e16f6d12d4f11e4916ab2a4aab4eb519483ef3cf2013df0d88289bf5d6884c7f2a9977b89045dd34798e51f2207d405d14b25594a2e2420d7b9f4ac678435a5ddcf0f68515db383fe5fde6ac266c1d6ee34535f3728f17010c9ffd003d03be10a69c91d2b97d20a5a87e316d9c8250185e2d84ed7188dd225b094d04c853b5895c4f68d5684b7dc5bc6fd933c52e6e2b04d27f9aa2b78727e78b78ba63132aff737e2c878b0256a6a5cced5494e0a432a18be5e1c2859825c1f418f0e2c1246749dd34f7c7989eb578f94e6393fa356d6b1cc98003a26ceb417e079829f372f53ebe2dcee12df84eb88e542c6a6ede082370bc8106c88e6ebe55ffb970f21ee371b36077151bce86f539770280e598a96f650184d3995692278f87cb129848e393fdcebc1953bfa12c1f6c37233114d2557bc8b8e8a1e31e3ea18f3b1340075cc2875046b0e7edab0a5701dcc5d381923ad66717fb212f65136746f12367532b20d7ae72da60c0a0115a5b3d2710966abeac8366f1b406c8cb2d3438a9ea61fa4637d08fffce804e7f0ce8f555f92b9245a27dab55e5772","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
