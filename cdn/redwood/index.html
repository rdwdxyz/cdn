<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3c927950b21588d632746e0f60c0bc33e2f3a797d25f17afdb870fde1b568f14458f9be3b1a65d9877fc963cf6206e33a11c849c961b7e1692d5eea881cfa33abbe548a59871d23d6ee87a7e75487f93c41e123e6cf79fd092e3154a0213d32a4947f3c6424e669d34d07705a697918f35d1435ff8adfc7c0489c11a6245af5d8e7144f31f606f94d452d233de21fc33dd3455f0b6958a294452e192d5cbda7a63f0fcac704953791844f7848f7a2da1c09f078925f952bcbbd1a458a32e2f9fa2be4c2880e2d0f93c3663dc6ebb84e3af5505b77b257cb5857502f7c85cee320d786ad6c0d6a599a11b5a988a736de3964093e9601126e7ce11b497ff4fba53f6cfec9a3ac5c11b51ccab189663560cecf232b2d5c221ecb864d1849a8b628b70d3821ecf2419c5f67b8ab7291b9ac976e5e94f20339a118715e3e647b5548ceab20273d4c4bd01f12d4069b50386426711323489cabe3a870e2da17c7c02d3484e0e9ec84f6439982c392d61c424a1afacf34244d53669a9f760f12a0cc979d29520dce716659baa344d103bdc14e03ced0450ec4084ac7ac1fb4d9c9f16f009364d9323227bf9d8e46de40088dad3da5cdc2334c174eedbbb9fd14fe9d32b1627a7e78469afa4449bfbaf91a9889043e30935774f99d9a056da70916f5a3e6a0b8bc2732f09467de82b018e9942572b85cf68f8648843b355ab41091675765af3a201d8a28d6b0e6d69611d601e26bdc5be8213b66921e48bed405ee4d86fe514ea9c27331d32c5b415d026df716f19c0de919e35395dfb319e7b4c1c26232d81301e330ec96ac7bba723d189a2ab34a20b0e8cecd9cdc120f73ce8c07f252a68f50509890928654acede71b7183d13c3ee583ab7bc78000956e72aad754445951e260e6d6d528b47230ac00ccfc763ac4e4db61e94c95c1fd36baa288ef595e8bb7e7f435ab2a956fddd2ee383915ee693816b6622776983a29a263d8e1e884291372eb723d49ec6a1930d94e12db657c9a9a422d3cabf7ec7c6428c9f96d4d8952a5f0f82001f22955490cacae44e3c4679a674e523f6bde8105f0c3941c45e5d53fb844a5484faba631962d9efb4d725cd711afd4e6b0677557a582efc830edfd06a959329fefa946752be81c86a587cd7662d1adb0d72ac84f173c2b8e733d1d633d622bd70f3dccf2c48547c797716d083a73d43e88366c970c8133ba2c32c94ecbe276b399fcad7dfe7d5d00ecf9aa2c398d28161e08fd95beb62bba6d5984dcab9a48b6b5b0642e03e761ed3c19576be186b224e4371cda50f0b6e4499120b7e891d3a83a865e04c753d4fab4746f9dab726e879267a708523a6701018567c8930e2896281dae64bb88bdd89ecfa2b510129036dee9610bcaae5aa178d167b7f6c1ef811d847ca4004315d77804a15e485c1bcc1c0922ecb4c59e7b812dde32564e07ac6a264cdbdd040d227b02317832fc9c39d4746da157fe5c350a000c7320a46904cfb065bb4ded35faad5fdc2cad1f7e82f13e88b82da126b9fa5e95e11569c9e7a2a63c1c9693e24984a807c1b7b59c172eb4f3d2787f950255f7c1fdbf9aaba880330663d3f5e366248c2133e9f6f3e339567f1cd4e91599555760acdb4d1b56ac05ac33e9e338bbb5a02a8362d3184826c4e824aef7d547387ca816856e3fe9ae98846bd236c0efd5c5ebfa4d6a827647d4ba8af5da13c56acfb7aa3dae3756f9d6c7afab7146d082240402f513a7f650394b18ddbfbd5cb443e0f056c403d6fa0566d189a12c4bf5863f10a86ad7e6538f62a0da6ae3c51d0cff2aa3796ffe7f619e3a75aac26a243dd036f0d84f64804e1571e6d3b834d8d7e4b4605b6bdfcc3e68797f0b41939f03cfcb2cd559601514ff3904e83008c3df2cada129b34768ffa6dc3d634164be7564180586f356b275941d2b9521cb5afc2d45832534876f758bf03b263b82a88ee98ef7e0622b542144164958c8be904ef3c78b5e7b7bcef2371e5ca36602e226453f0689e248cf39730f0a41da1eebfb94e9be95fec56dcd9192cb38d28bb4b734007677f22360da7d7546299535b767f405298d9842c0f902f587edafe8cf6e6a605bc5dd2c8a1216e1753cb68c8515e127528dc985043d76feee52598c180418d708518e4d82ee0b2f5ef4a2967ededdecf0f1acb2f6a0c567e57910e7e348d9ab58cfdcfcbf09742f0e1b265a1d240c2cda1f2948a9626ad526f7948942b3f66ba02a16dc1640960b4338b141ba198bee259d180f483dbba65c96c544c7b8b12cf87502db458feca59a417b906e173be96300c5aadb579dc447027dfd881d9d7332a194c2ad5f0493e309e34bb9138489d82eb38da32f2d490e42c6b44bb855a3887a7af374ed3754d11b3171437f8b486f5809bc69416a32fc0108f91e5616a4696a998708e47bdb9ec9edc7e4f1d44173265e59b9756cdd475e778f0c4f009b8604330041553af948e51e8027c3a09fd2e70104e9f359ac485167dc0d7cec1d50a60e3bb9b619fe4bbdad9235e30b73bdf4b64b07a14e68a6ddbc334500865b9874ed2af8d269f999f583ea70aac15f99e179733fbb0504a8e0be32bddd76dfe2ee9f7276c779a0ccd7860d998da183fbf11d423247154ea97a367dc44aca1943bbf642c49b84994e8e5ef64f89a4e983b5850658ac44d9e455805ee33b1d775eb11a5b6a26d2f86800c83be58a05ba213afa1c56cd89c2d862618fdce3dd6b05f8f12c7b70d424471c8446ae7f6d2681a255045b622d6a90a0ad58d6cec0db58093e61ffa3fe9c8d586eb5b820838be4ba07424951569ebe6e77841cb8c1c71e72f8674331dc2400cb72ecc26c6f5b5bddf60aaa8ddce0459de8269fc9032fb6ab222a5682d443a41e8ba0fb1066b290a360f12bc40e9381eb2a6f39ecc1c4d41bdbce5f864cfed27774262551bd58dff03e8861998b08bf7e1620f02cd322e99a4b7cde6d9575fe54b643205829a39b2f04d6f8e6e0e62b6c693d4cf095317e45c9ce36fb70e618238c793494c4603c8c73eb9040863668d28c9966945adb984d320dd354ae989b82816c891fc12515570504856f3f8711e55b1990b61dd2c8dcfe1527544c2e88cc7e7cac598287452f5d9ab05668c2ded8ba5bfa070177c1a72a40e95fc7ec03a1a3714abffbc26db18e9ba15959d1e8b59ffa0f6b720e179c45f3c36748ab2ebe1287e557baa0bc4744e82ad068f979841673f9f7bcebc91c34c1dfa67aeb8088434ab6e270ae0074d1510f9fa97f4541bddda6b85b9b1f52a1ae8e0dbe0bdcfc98a10c82c6f2d9f4d4cfdc0a0e6bb3824ef4b9f93e098e2e79dd8f12c2c7c0c0ac1489ae6e213f37a69a9d6b24c3a275cd870b78d319b45a50cc55db4e9d638d980cca332f74b63710a0ac7e50b17358d9be5c6f2aea22aeabe413e56acc04618675bfd620b16a9099c24d8f554b4a52951534d4e7a1b17080fcf1798b7ca8d43b5298b0119366334bfc5505ff735a5b2e60af230aadb275b63455a9905a1a6e1938a29701b00b20535586beada5ecf38c57e76957fce646ec24b5e1ce004fe13d3196741d6eea5eba23a75501d1028de222750367b2b06923a3895b9a395695d217ec728af3ec0a7864c60deeb03f30ad89b0b0abf044685b2cdf509ce33a1c8dd794ef67126f32a3845e4aa762ff73588e8de4effc0713e583b3a523d6a99c1f5e78504cf6e4acbb92e3e24dc3eb7e90a1883c2054ff6c43be9b77c98d2e6fd32298fcd745958944d78da676c115f9c1f6645a9b857655ba27be06fa93f8ba9f1c3c1788dd541d59f03b59f6ca13d0f9a3ec158a27e914799740d3cc99209550f790ffc53e3f2c07d588b711cd6ca074afc46ed3ab7fdb12b29344b3e5ea8c33b7cb2d8b717ff4dbceeab68dd90d7132bde935ee41f2cda7c20b3f51ff44948ae87373edb8bc25df8743dd435a02e9f480bd6d33e7588072f22b359ead9bf213bbf7dbfabb47da9f07438de93f9f7b8963623ec52a9a730726b81941b8b95b1eaafe95af6ab5d268174aab0f38637f3196dd096fe519edfab98b774bbd132cd5dfe913cf78e0b9e05e44907433fb5b3f4f6e71683b20933971cef9497982ce9e42a1296173c8db7c71929474dae2680b846b3b321984bc445970afca00e75fa54f4ace662dd1e3b6e831cdb5083a234d4e9544e68bc17ed16a3cb795ed7a1900e0c20f20da61d03983d82453fd3fdfdb2c622719564dffb2839d225e6d8ea10149c522a0069e2e716134e97d390f612be0cefcad64cc0ccade2a8f69731bfb14529632aae36cbd68a8ecb7e159fa7d7445750c0d119a65f5124faa8b617e6ca7e3bacbd08c73600be8f86f819c646ffdcf85570802985d05c82a0111fdd787fb09bbe865dbb60a84c3f4602d7b4483ab0608443714791931d184b722ead723a4c491eb4dd870c6a997f9a2523021feaf7889f1fe4b828895086a7eb29f54c6a125d134af3038e0a9674a4842ca04b26e9db9e520b236b09f67ddb96de4042131b9b9d5d334f4c55c2ae470380037bbddbb185efc88df1cfc10ae3eb4a88b658ad8185c0b0ae4b11fbe24e85b59e978ddaae32228ca4ed4d90d7a67b6efdd0a0dcaabd095e860f946eb9967a6d76e2fda4c37bf616df326ddcee1f8816f2a2398559a47b14114dab3e26ff6282c90cfc9d9960150d9d18065d90b57fd93a5d0f94778059903c8dc7229cda884d020405b899ee4742d83a71e821355baab48bce26f0ab12fbc3b4bef6a9146b7bf45aa7f75fe839b3c82d3795dd3b4dd3b6e9b4dc88c9631693fc4db695b826a6dd68740b3d50dd3ba67ec5f18112bb79a418575f602a7aeaa7431c1c617753212090b17192871b2bbc4c82d3edf5a43a287fee8297eb87750f39db30f46f2dfc5d8b29883c4a60c0d41fb2407a55d7becc353798811e5e7f45fd14cb12ae83f5e0dc46072b0dc17bed34331c46ba2ef7bbb1986ee6e2978d9942ecfdfcd39eae9481f902032787d0dc84040cad5ec646bf02a37909dfb508cb5fa7036f59a59b712781f84b523293e1e3e4ef1ff504e35c56d519053f973feeef149a2431d735ec29c67690c656da71374410e0549a88f90d57dc054c739b33af69b132041b7f60a1028bae073df91e93c9ad1be43f321a868be1c25b775ca3df46190745fde14b837cf1eb9c84cc882ead6f56ccfb7ceceac334c47b523436607e1f8e6e58f1f4ce488e1248cbe39faaa7d611bdf8662f550779f1e56e7d1fce73879a430c8dd655b0fff67e5942780cac861e48296c3aaef8c46449c039cbf04503322d797c74c9604018bbfac3dc70862ecb76888400fbb0082404721dd91a1025f19a68eb0f30d131e5cd5f2dabe21bd2e7e205f1bf3f8828aa7ce754f30fbc5dbc291bbf80167b0b71ae47c8faa5debe52b62bb68ba483c465434dbc407bcc5d862b1585d1efc26b6f58a4cf262638cf008a26b11c9aacff9ce6b7105d661031bf5cc325a17b8f653f14803861d147ce86a845bb35c0d54a3d4b80f318b59b71e417871c09d573550248932e60f0584819e98172f786ce6d4959bdf8d52d2ae50402cbbbec89136117a16894717bd03fd13ea6de8f65431af7cab675b9ac7ca4e0de52a8c0b481ec137ec3f6737323b48babd3c3877f5d30e105fddcdb4d4e6bcfe6909dca52d9a20c051f3600dcd5a82996507832549e80e88cbd1e7b5ecc22c8e25eda470c12e1993a01fa3450f18c5b0230d42111ca89c2b503137a181e4a4dd22359a2cfa3cd3c74258847c55f803da14cc8cb6c23b1991e0a2242edf5f4275c13a52c7f1b24d9712519185f7983dcca335e49dcf6576e03f86009890637331fee70d064481407ca03f81eedd73d31af0d518a4457eda26e751147a0537a877b9a79d5c6f64f0b5410989c420625d294cf164a7a2ffb5f4fa9b9db944136a83498393937b97cc572f3138a83486e4af879ab84d7e651cdfcd888b53e36c514d1de45da13271ca1c27102d9a9531fc9df725bb2ab4c8d3815808733de71f8fb7c6797c978f014f856ab593c4fa3bc51166d47d1c3576b56aa8708a15be99f505908d701607271b5a70c2864d3805892055f5981e6f25a0f512f9e8fdb3a57fc32c164b2d9032772d2412feac1a6b42317f9d9785bc159715dc31453c83a6237fa47f6075d64823223d8032738412f7baca2f9d890579824c741ecc7c5c9a90a21881e6436df8cdff9169a61cef5d43014663901db97593552e6287dbac8c421fb53b5e81c9f04d46e62755c5979edf08904c79f4e6ccf2144d68e714e7191a17b33e9bd9293b7d96d95acff6fb3b3ffc7b17cc8c762a1439a8a9b8ccaa28f06bd36ce547f37bf4653b4f5ed6f9a543acfdcbbbd663e32ab2d317c38716a914edf769bc7d7f90f8026f3bbb3485b7c827392a907e453e4fbd2f04a6f584db1f317ef112521d6b86b1ac7c6310dc61880878eb5db7cf456424f2c8d0185a19cd42757f6328dd39bfa06dc1c4f4300811776176237de98583d928b6630d9aa4f97a912c2bf18b9703881fddd71f4950d7d8e20b2ae740b3063bc2ea79a5ec0e04d4de99bae42741ef0bb5a24430dbfb1fd629d774dc1fd92a122e8c1474c8fc26ccc2a8f79a70b9387c32ce1c13bdf40fba26f326944e594ed9390235ef1346a53d103c62e5dddfb0799762295bc4f1a60c23280fa895c03f7129c16b4894ff1db287093a5e978a783f7db6062ee095c49f4fa3f79b18f9fe55cd0c4e6d790f3201576df127577cfb8c489f99a753aecd3aa8ba334985874fef4b2ad853de6b4a9f0e780645dd6c7739fdfeef4816e5eddbaed53bb93d8a113d0d4cac45bb3f06730db4a67c3dcc42b2c5f5dad581e7c02b50b25cc8dc23001e9ae7ddb95bea18e515fbb9843c03d3d5753ef3c7c3b17f5aff95757de9e5d67e554cb3d1ba524178285370ba0c119e160bae66243d73748faae54085cf1cdcf6e74e111e7914db06173c29a65ac3811504a462c0969a86b6162d4eb3258038113a199e948162d8f41d22472ef675b629d37814d75bc25305da3ba60907e5c4da910613332d1c93cb14ea89b99843807ffc2cbd17fcbc7826c3cb4a536eb4c215b568bacb8351a3f68a92ae4ae31fb9ef35cc36ec713b809fec41fd0bdb427a46e487af113350a7c8418673ea5f4c1a69db2df2b4034b8b142d9ba207044ea2e5cc6ceb7f775e82be7a94db693ca98ab6e2e2419d1b98d4930b59b4a1884677da3d2d0b16bbfb7b15f9809025a3ddc1a8cc9acf6b77991d516ab946cc6f7151358ae8d27f8388935b8ade7558cc092d7046554af8b0de0b8083d8a5f8bf4207c0a37c75632f2bde1c2a24385685a4cd739062a5143afc138c50bda8747b2f0c1d7b6c9030da0af2f35963c4945d2b4db193bbeeb590d50cfd519bac7ddcd9b268d0283be369c4d7ed9659c59fd45fa635d5261e6f346466528b8e3d33463fb093894779a5377ba95388bab2a704dbb0bc65e997fb675be828369e263591eb6d42f7dc56dfbd3929f28a6421a9b718b0b8af793b0e38e502da96712447d8f944ec1f4646597dc51f5b255a4706e42943abeb6009c30daebef4ca11a438cbe338b8ace80543ac3377481877a716912513b18dae6038b4102c1c3087cbf720f6349df6be49723ed226a577a82a05718b87942f5e4e2562a06eaa89528efe4bf99daf6d586173bbe29630bdffd4431be1cbe5439a36a49dba2574841124cd532db834b011b5e83d9464ea23cf9cdb108da0de4b8554c8b610b83f0673d1c9db8057abbdb096321042c133c39d78077fe19292e94b8aab9ed343c4083b424c91b7e66acbefebef7d139227f0ef78132fe766425a5556aa9b6e229f029f149bab2ce6c7ea743c02767f3e6f2d72faa3bd7931820606f05e059129b5d4a48ca3d16e8db0fdeb7058c9c4f4e9a47f30708c11ce850d60435d8049a6d84d4580883cd963cef699f486d7d390c8378b2da34ca6f9ec282c0204fe5c08c63f1ada80e0700e0f1aa5fde400469e72ba8d5e584edc590196ffd245db5d2b7da8971cef3c71d1c664bbf6400b64c7c7230e6362ea653d79404d850091e8809ac0ac24552d599e2db04e6d7ba2451901d0299e2c642f804ab951e431051dc56b8a8cdc974bfaa199256a7772a336eafd3fefed09b9f974bbed064d639ea8f2737980afe255b0a34ce867cfe98aac5588464854eb94f0f0c4f1c43632c29e7e94e8b8c81ba028b99325ecb2d5208b04c456379fd32e024805280fadfe9fe14704f2fa18ddc002988862e494300a767927b53f83fae1282e24a6c68b791de7aacbac28dc5d6f974b570a170bff6bf9ec18236ebae6c42f824ef7ff9accd295735dd9e01d410c90208bc164b3a37958b28c13bf4a397ecec2fa911ebf89cad9150552f1784c403b7e2e789eb2a5f3e7a6d66e9f174f0920b8a285cae33e6f6dcbe38ed0c136ad8fa86100e38a27894bd41beec795a518a5dba30d4154df50d73cce368d8f6ff4098f623572fddf2d85d50d5c6028b42cb7b9fe0670b8bf9998de96eb36023f44e0517af11f758d96c3eb9a55f738d66774f2f3db8cc65501282e27db0b6472e0a6f6d550bc5685308bea32b1895fd20bcaa82ab446a7101824b6c8af23b044677df509518a257f020ec8695ccbe966bfd3b0987c0bc7505f0f40f32d46beee150520f05313918c8562bfe4d60771604d8132309cc19e055fdc96a074be6b11ebae8d3e66827f6e32fb5c6221f867894dc526a5a4d966f9ff0ff14e042880c815c912f686dbbc015b5d5f5418a747ee15ea8f44b21171e6ef4f1cf404cb82f909f3b7349060703cb22f66674af6c64a25e5be729cb6652952030c55b6bd04af58639a80094ca0c4e03cd96cdee168dc9b577439d3b4198887edf7fc308335dc67628d90c5cf93bc01cefa28fcc8d2e9c5ddc7bb335a726d8f076f8744d1088d1ae163db7208947e003d1224fd43be362a1ccb5ff4feb8161562ed51d16bf581f04bf978680318a6ccfa8e73155e0251baa0c38ca6411ee29bce7f284222b4cc8dff9c202a712091fed8262d9e5530c8c6b5ead28e6aaaff916229b3a1918eb30ccf81d37924dd8864d6316d2718f055058370b641fe9e03c12e0d89b54c299822f8e0b3d7db401ed8ad9e42e674387b0a4f7a2051e03ad225f0d43dc7c47b4e0ead4253e92d80bd701ea50e63f4bee330c448444e344b26067abff1ea2b4456348b33ea9278e8426c10e74d4f64af0903db932b8f84ac162a5810921b433675de65f62dafcbe98823bf60a049b13df23dcc5465610978c4ee394d6733b966e40b95362aff4ed752794cb88d5cec7688adeea267b745574edce78012f6c14ac79e4bd8fc73433365939706fdbeb02c6d9eb742876aff9b82871c974a7ff361c240aa7079c4bf6b7ab1c0da01da919d14447ad16a043b1d48fd0c9c1db99e799926f125a0478e5e0338012fb512c2ae6da2b36fb547f5615d5a0f1f57021ab6242f5022551774537fcafa12fb34d527c5e4d26d9c340382a97a2c5bb3d202cffafb98c4dfd2f8bd8f028991dd6fbc4c63e6f9eae7a282e52fcaffa6652477ee27af7b7b8f5f9164648a7072fdf4684dc0d44176b4e2d2c3e31370a814a366540dd0bd587e39f7a8e6e65f6cc48636c1acb6d40ac30529736c96c3a4b6f2a124556a6889d9fe3b277e127cf2a464be7321c5afffd6f415d82a10a1f35326cbfce42a1be650b14681bd5999d9135b692ace362214a8b0f408eddfe2ec8189390ea90733cb71b9c49a9268d0bb4c7a703d6b16b28a8f34a074fc57fc79cf8dbdca5a3329b24f1ef2f317aeafd947de76d10fe40a02ebc5cc1ea2f7888488764f4eb1f034ada6bd55014d55357bd84ed26b5472a9b8ef05d793218738030e55054e683739779725abd9408abd4dba5a6672f805af61044b04e26c266d1919e137ce68676fbb945ba846c99d044356e825d33b5920e16d791d7c06f370559f8e7f629c67d4e60d0490c98fc835b506aa4c235889827089bbe9bf7541a1c92c7fe0c9b5fa5de356d0f29975c3dfcf3233d8cdce047bbdf801dc35ce84f414c77e26112a9a35560dc37c4ddbccaa693a4dc1d4c5a09b0df4f08f30eb84b37ac540b0fe9fa06b4db4d3bdded3bbe42bc8d9044a0ebe363fd9900b38672917ac4981c755484f3a43bd3d62d998466c942e882f61f6b1e2e0e8edb72ca256431e40fba63b4ebd33564439250eded869cfbcdc0ab071f6a6041dd6fa25ba044dca6eee86d0ae639b9b858ec9463695ec0585fa303544a1d549240210ccd40122cbcdc11c5825a6eae19e7bc25f35a5ee201faabc918147a2f34cab6c07d70d6fa04f2d1f6f27369e71fcf297eb111a9ef4a66eab3323490f25f3d5541340be6e7bb37e87eaa9e449917e461eccef06fb1647928ec2b7d091428126773d239bfbd527fda04abc7f225f7619fce6007dc72da8c9a3f3d625ace27420a06b83bf0f5938a3540ea12ea6ff63a52e0e3b9460f924bb0eaed7b4f3444acaeae73395a62356a8bc2e80ed1786fd3ee75ba686efc43ac0ac5589229f97b67ca8602cd9f1df7c0f033034b45966b911a235ffe8a3a6b6e6727a6c1643cc6e1a575c426a0d55a7c58f3193d80ca819005eabf891a702308ffdc235f7ffb939304c6a538ab58b2634590a6efbf2de9a21fc049f3117bd971666aae79a342a06dd287529d23393521608b9247e6c9552a97a233a3474f85aa0773a0844f5e325b4b73ac6782dfa96bae202efe19dda4e03852a643119b891f410a5b09098c05c077fbf421cbce005beb3d78a139a34aa5655a5a53bd01fb2256e2afd0dfa983383212ffd8ce45399fcd674c6f3727458707aff437574fcf899839ffdd52b00726b5b96f664d40101430c743f0dc4f9af43eed493f5ff4de5bcdda62d98dc6b5c43aebb5159a0109cb39a6164dba3958acfdc6a81f4c0f86839b0d0ecf6e58f02ef9a7ca3cb07a1880573b7377270f5faef27975b78507f2d84120a62287225c9ab60c2724eebe8d455d407799e8ed9a5746f83db35d1727f96a47a8c85627edc498456742e1f1a6a990c68ef55b2fdccd4ba1a490f0619641ff9056ed689584c8bef637433b684d099f4ed3637a55488433f2900b4f0ec242971b001acbdacf164aafb1f61acf8c11158645253059e3518ea4bfd35f78010f094bbb2f43ad75e8c32cbcd41d2b7a0c48bee4983c9d1eafae6aef76a29dffdc5c5090801ba9bffbb33626f849358191d9f5aba394792d4a3dc027a5701888010e4dee35cd3f6d0ac5a63e100bffc497e7b11adda93eca55eded13a4ba429517aa039ea0e3611afa87182b88102a4e0192c2012b18fe590529c115f759f39cd54b503aa6492d137b7c5d434bafeabc87c7ffaa62e4b1a8545682da2b2caf5025aa0b6ed274d39559d3eaed7dfe2c7b43618bfd58eac2edd2f9109bcf523cde409ebd34ede96a3cd861bf49af38c03d31b575f26147272f157b04747fb59ca656d0f90ab49521e30ed9afde930266bf27e9c38e61e22a8aebd468ded954f23ca3e47501c5dfc467843e2f6d528d237a74892eefb2739c2940333c4d477ef231c71f3c604735271e0eb25ea53bcbc7e5caf0cf25daa570acfdc2cb42db593334c605dc57d3385cdc9eb2e67722ed6507def667d806ad5f119deb572d7ca96d6a630e13482e935897d8ba99d7a672ac7860fd253d9a5ef2b53f9799b52e014f9e563346d9d352acae2add41c39684b2fac958ad3b26bedf9e9560eef243eeef8df232738bf427f622cb6817a08a874e230f597fe26ad7646e8d42fc566d51d99e4f5f6a352f12f10263da409ad8a2f985d5b70ed143fe6a7b718468b1bbf84ba9242b55bb374496f899a1434859d6ac029861a796e4cf1e39ef4cb794c84aa36160c47f22f86c630f79ac73d7249a365235a8972bdacff797b6c2935adc3c595d3a5d6ca77526108a4672b680fa9a55856d4eb942b757ad524220ea58bf6cf5d3f6b981eed3f5d447acf0f015036e289fa874f0c3b014893f83bded0093985ec3acd914925026d18c4195d7f644f6bbe7068138097de268c106b704537f366d5f04f07c0f95e08a6d76db32316b80c31a129c5ce590e1831e30262336aaedd17b3181df7deb10a55dc3f32603a8714badf060d205b38a550d63c90bd0c8873cdff6afad39c7301db758dc5111579ba9f2ec846fdd634ef910182180d0e2758dd01e583e4ef1972ad3983cc67a6311345f2fc3d411c3a376a4f7e7b211af2708dfd0783c891a4d652dc57f52e700102a274f2579b5d4e34a9a1f6dfb76080f176f2b024e1b574f126a10b8f8afa80b20f61fb4e1a66333fe1331b41f81142858f9e3b3c051bc2732f4c3f01927c5ab256bdee4eeacdb41c793c6f37e2a2ad1304e80f51313e7ebde5d4f6779e0d930e86822b287f1923914327e0aec8a25b0f12d4160e36fb36c96a998b7e616b76d7beed2f1a284629ef540cddd7e29c7c64692957d7d3f93305823a767b85fdcc3f3998d18793300a63ccc3f784b8dcd5c747eb5bca147717cb3009a523253e25ed41c2ca1d25f5a95f235abe2c5bfe8006d245ae8d870b5341f6530683d2a334cb067a4dc7c2aa4e55baaefe63ae45e5558b36569e4e3189833bd7cc447d70661d210d7030bc38eda6394e2f63dd034a63c2b0d0583ca78a1191d2b15ebe0b346d63f1c8fde12108c2d3ceeef2ca3b829944ad6a7257da47692b50fd8e08018089cd2418837ec8761a86f27cb1f915f8b0fb4c725f9af3bdecaa263b66ce8a5f689c865b3486faa1af2dc328bd933693d34d19bed3aa531e91421ca9933c7269d8ec313e5a3eac887dc677237d1593b73ed58cd0ad20241cadf10f07d2f73b6697f5706104377c6d8aa50c98adf58de14fd78dcaebfa5d93d407cc4a732378c0c82e152491c88b2700a8b79bc43298e0ae95d52cc78921cfff6dfaf1e08f5b045d12fef92ad80eef58ff78f2f1db6aab772c1c49f19f6145ceb85541232e500630c33c0b6b6e931eb43d244731b3dcdeacf68d16d9c664a176fca423d667edbf639eaa8567e957e6318d0f51ad607660ace9cc1fc25766acca2d2f4e41b3db3d47406ecbe308ef26de7eeadf317f23608c1d46bd77e5212c3759be42821bc999b7505aa8e1d2ea16d7594409895075eb6ee5c9b6b2890ac1403ba2e8c93c6e11c95c1d52d9ac32ccb2d7db82ffd34268368e34ec0d54192bb2743f1c7e4c8ab4a784039ed503355a32458e289214f4d860d913dafd07d0dd1115cb3c3a569a64afe1d673089f6047ca2b26c5f0ab9bd9273a0184e4d05f7b75f5300b3fe34e477f2aca59a938a5f9a08f1859f5eac91bff108a576b14985a9ba88122ffbe9cb297eace3ac77ae13936126095028769ee49a30919ada61769070b9b7031bbafe6d1ba685f9965f3d5061f51e4aefdc2943b7d047de0dc9dca1f242e014a5b5ef9a4ba69970ab1bcc1a782faa5934101a40df85915592cdaa89cfc829e75a74bbc77b42ddbc5f33a6115cdffa458a7bf3ad48eff1142c087280299b0cc15d8c3583db197f1b09af2cde08adb68061560337a177d5a1c9d9e3346124410a9eaad2b15269130c6b09c7bc3d8df57da232e96cdb0327854a2731cec3520bbfaa2807ab46fad6eb694eaf7dc89dde5259902330a9ffaf62aa6eeae2f5f5eef38595cc809126d9e184e4f7221fac06233251aeee10522d293238386e022c19af56d2eae18ba375c48e1e3bc5a576bfad8d87e7fe39529d63de1bd1759c0d1039aae0ab927d71fffb79c134d671559d81ed37dface242b8e30676b694800ed06a495a840dd7cfab078d0b0ce0f0fa118faf40534a1cdf5acccb8077acdd9cbddc117055da8d72e0c5b0aec853e2c4b2c9079f3cc9c2d9a0c2f417f13c839b40d17f6b461963a1e0a463847406a2aeda74a2d5f92185290701218e442a244953b6a8c8b1b8f772ef4a861f082ee9539375d33c2641e8e57ab1eef5efb43f3d0cf6af64bb393f1f5cb35696cb85c9300bd86a9f9777d3a20728703dcc22866ba16f11ed92a18a7e68a7669d6705b56d190a60714bf7a7269d41879ef8b4c918be18e648c1bdb0aae818da3084fbc2139a5cdf2a0ebeaac31c1e3536d8ec7383cf7ae3036554b22d6ee31eae37607d8705ee250d0f3e38ce6efed5e183997c870acdf4b8afa24c3df23acc5c8ad89c55223c70430e059ec31122917a837650bdafbf923b897879b0e6f11bfbb9c6998c78a0ad1baac83dae7366d77536c2ccb3a253475a5b4899a87d38b556e208df364b4be1195c484bc4a527573df0ca17383485bcdb6d1fe377f4d19ad9ec7af72d2ef97faed70a4968f80703c8917dbaa58eeb9480c081dedb0cedbc5d4a2ae2807ee2bb73604ef62ad295acd8c059adf34c23d8dcf644ea4eb9d6317b35473b2ba336ccb803d5fd96bc88179706ebcb3bd261bb7a6d0feb421772d3c4f12effaae69e82fb321860692d253cc89fd5a43730a8478cf5d9514175e068b46cda694c2486c5fe37e60a103f9784ce5d9ec2b7a085740f3af64bf69ccbae9e55427784591bb26360ccdcc44daa47753d42ec85aafefe63a0c2c31bc2445fd872108e8546624c5aa22c45a4f870f147d711d3277fd3d66d1562c09b4e4cb0f08fc605e578abeaf565f1f5b99f6a7e3556902465d11d3e60e4a09ef909b18d5b56c6fe45b6776651de4a270a9bd60b0dc966179e5cde06be7716a97ad2bed958985b09f9bd4f13cc09698eeb28289b95637babc5fa1fb45f77309185cf0aa7b1486b608d05aed990637c9536b827cb5e88889b26c8c1325b4b75611966ca5c5c8505e04e5d1ab5f18b11a43d58e385067fcd3b27b499f7b04afab3300f17c471eb82b1bbc608f99ee8e40e4e1a0a88e30ff052d33a11720c020b987c9ac9c98c32510376d478bb12bfb9fcefa7d4d0cae636fac4c4a5ec33c5bcd72d05dbc0c8744bbf794f2271649a040011f05335ac505a11d3cd88e2601bc6fbc30fca96d5571a8999baad0dbad542de88c4097fe9c5365d65eef80af32acd3305695a39e7716e7f56934cbd0c1aaae0d27974c6ce62fa7753d49c9dcff86e8132117db2dd5245d590900396cecfd38dcd62d1da13cac8cb3d97789829a64150b694914070d2203eff71ae92ca8e20e2e3269e3a74b166275f2264c9b2bedda0c1628433ce06c3c303b7c8daf6ce02b42c52f0925e5484a9d1ffa582accadd44028440395bce2014876ce5a97d66f93ef1f3a07aad8f69b318c8d52e6ade6fb91af9cb0f65c54098d343c396b8052d1c3c724b87ffd17df464e62cc957a3f68c045debd138a9c7c27de89f01b032c517adf33da3670f0bdd897b5600351c5f9e7f1c708de201c7af9c06ea6c5dd83a724c4cc6f57656238e8831107ffad0ebe984cf845be68cf0fe1351d3f34bfea44df8b1ec85644eb52754529262bfe717c36ef916c72557e47f7b98fc56af95075db7b02ac0d947c6570fc5e36d8dd545151ffa985052deabdb1cb7ec67c576b8bafea91fa6f109b2ab596b54aa3309b1d108db47d7f1420217edfaca1b36290877a2c51946ca99ce5e3d20f6864b920b18450a0bb41a4cd6ec75df4457bbe084379ee552621363a295ffcc0e0b2f043d81f3ef024aaa46e02aab7e764488cbc445129a095e13cc306891c1e6851919e65590a7c1d50b58c888938506db8e11301619617c5604dd4fa0d98c31d1673e25699bb307f04900b25303551a231c8266cbce1362c98c4b6777a95f9d381fa448d6026393937605ad649ca22c5ceea48d007ae1f7840adc5746a0d22bfc4e2329673469dd6075e47edd0941fea8f003da03fe70dc3e04fcb25d51ea76860a9002d926b8ccbae1f9be62f55195bcf2b22784031b283ae68f56bb17f1a6272c1e498dfe9b100cb13d0b795e4b8bade0dd9017c2962e85233484116965e7306c3ebc45d197a268e7f7c0d114b8e57174a02cb6a6346193aa0da9c9d9ba3fc5d61890f178b4cf8df9283b5ce59957ad5ae22f9fee1f342f865ae2b95de6559b1a884351374faa2566c1cf5dc75fe2989ad08121f6c28b1656e4f12b368f5931ab77da2f6219de9ff3eae9b10ed638299b8770cbe792cb423e3b1ed53049fcc4456bcf57c8b74085705bab9ae1797df6ba0c8bbc0bd3b2f4df10da8c0742782d5ddb88c39be75e84b046fe242b543903f2a9302053e62da41ad30831c6a07846bfc95b5f20864e067768ca15d503918312e0b137a80e3f8b9c99cdc2955532633862d2774adc56605697a63a373d7590e8f361775297a60307b4c26dd33ae4393b381ecb6792c7422ca8c4ec71af539067426eae7e32b5665d3605ce50218f158cd0b2143c01243865ba005718a92c0061bbe782c67139dee6b70571c5e089f5db837507cce64f944f68670d49286636f8bb948fc20e6ad08982bdb81be04b4b8b91bd700a988b674ba8e1a6702ee1d24817918b94a1a041d037de76d6dea9eca79dd05400aaa23d9af079cc0a15c3581528bf496287966db73e6ac24bc8adeefc324011de3451d2ce8a5f7278f2e0a4163037fd5fa175b7a36c41c85068cdba62c589b64ab608034a2a950cc2bdfcac7ecced76ce84b57c4a76fa4dabdaded62295864ecd1608630ce74f4c6625cbd597248e6cf93c078e340c372824599fdff714d45fe5a5cb3efb6a51b1d719e2b0e687f68d5a1f91321f034e3ac25441828bfb767404db3ddb4ff5d0515f56930e66d30f4b0fe46a77244b68c091834499cfff4de6cf4ad19b54859a77295df7c3334407305f7c85bf43d2724578d9da7cd0f95c6eca874a6dfc867f3e4af2c93811f55868e4d27ecf6083522f6b2d590a38347e2ce36236711b7c93a1283f3b9678af3c39ca9c16f275f061ac2af095e134cd62f9d7de16139d071d7c4d4ff1fade80ac363bd667fe9cc5c08b7c1635d399e30dc5a2bdc5c3fba5a218e267b3ab28d945abd11ca4137955bcf0107fc145b8cf737b6e93bc3f27e223a062258096ca2fbe17d461e3c92038881297ac0d877d51ce6bc474c47a4ef8996eeeecc7f6f7ae7a18a6d5c8c1ab571f9e197a6464bd19b58cfa185aa3c51a19029ace39a684a5f141cf0e5c3806339918b121f0a5c3e8564491ffc88ea8365e7f7887f9f9f9f81a16a860b96d781f083328c2c00bb7ded36eab03add850fa75204dfc61a228425292471c2859b46ae3beda99532a8daf34e7a0f08f060c85e5f41112387d02e51d34fc169854dd50b81693da2f15d7fa2d47bedc6e5b2fc70bf96d2240604e7a6fd1e400d9d62bcd377a435a51edaf3ee33d1ecee46d4dbeac9e14c8e6dc584af79e0e030d1fffaa4a68a6852dcfcda319796820abb71c733b9bfdbe74141ca93dafaefb649874d89763da76372a4440fa5123020cb34975232a85c7788558da1c6e73ec2f8c231e0609a57f0923bfd6593365d4b01038dfe4b72be900b2026d86c069bb77cd63b735e71d046af7a055a88810b51b96d10c8ced804447ff4221dd983e0c90abe18c196c0308abb1dc8673eff3cb9c2ada4060cf880b0f8607fe5f7f6cbef6d0f94d633dc9c8a27b67f6f1102fd662cbd622d477b5ce23f48805074e4011c149b0b793c79ba852a745ae60a19154156fda6a627faae32550ab3d4a3fdbfa26af9a2aee538014e29d6fc7de772ef661e8b50242cddfb7ae64ca74607185d7bab1e8255c21c3020aee3e5c30e5906aeb221ba4cbad34a683aca38130ce52d6858661140c750ac7b4202f2fed5f178a742f9958af7d561916f6840f680d0fc4f9b8a569d1baee9fb2928aa250b66cfc06bb7a75dc37952649ed14a62246cd35d34e26fecaa654e330e00939897593634e202d81234ea48582ab536df3ee68a04ffdaab044dfc2e4bd3ec7a7166b2f782d166027447da4f5cce3d6ec180e514414c2b1b2fb55bca40cc902d5ad1f860b34a7f5f884cef987d395a3b5db3922300510923825bbe5e3d11bf0801ba6177fc8cdf699ab1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
