<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a709291794c8950d9de9151b46142d03f4b3bf666f7ff3eda9be099943f6d3a181c6280a2aab60acfc4d58d8741629fc20b75eb4bcc1566436fe0b5a5dfc2813bfecf7ca762e6ba521c3796c315c4eb846b1d0c1a017106d57506b9096821779d9c92d36d55fbc393f05b884d950cdc55bebc8742a45a363498623b3de945178ff66b003a708beaea290a6b602ec76229b81ef85965b87408f5f07e3fd36477ad352d653578cbc8e1ec0ba21456887282dd7b603b52af0a520bb019a508a5e4d84c1cc1aa2c20638603a56524a7cb2fd6bb08d8d9f90ee59cdb38e1834aea551ee877016684a3f1c3d478b0010647bf77628d40936f19d82fffcfbfd9d14a02dceba1d591640b7d6229a9b9dc7612c2071d5d9231bebea2942976a2b67d6bce23c047c3cdc423588facb3ad1391939ac75193936286ab8068e9bac74bcd26f0b3066815151d21162fa49033eb32f8d54f16f1c7f3c022822adb4821099aa3504350119fba8420266745a8ffafaa18adab7fdcddc0e82b02d340f7a24f97c7fbeba2cac99b83c376f92be732e6a3d5bd0357a106da497c7fd36b23812c981e9ef82db302ebb313bb7f0f92194e8d3232e78e6404b14bce25c90a46fee5a2111200eb079d0dd57d01ab3dee85b638c54bb8b03791f4f5743ed9d43abbbb634ba77bc72bd2089047636a1a42c0b641d63b61f70a80d7f61ebd5d2160321ec143da1b4dff63f5bf25de1161f7955119773a7c25fb9c4c9617811144423e40f90ad65c7746558657bbe4d257cdafe26894ce7c05b6ef037f50b04eda736529797438a1140f25d72a7e8c2aa396fec08da5ad6c3ccb1f62d11872e16bac009bf3bcabeaac543ebd282d7092ff696c5ea44f58f01ea46ce94ff6d9358d0b5d9949b53f855e40a29656f03f1144fd3e0afe7a2f6b32b1f3c62c277621eef8e975bee5f9f88b5ae33ee910412187c45935a361dabee925ca177a2e48d67be7b10af3a14d2ffcd57c544ec23fd52d690d5869a2f9f2acb03ffd453be93dc6d13ec8d06e69917cebe113ad8a8d3b3b5e069059b6cefb68ff0383129c59df9bb87ab31138892778b1fb40bd4ca883a91730b6601c7b2c9191d45284bf156068a0524a6433d30006179781f05cf92ab3978ea76d3f8c15ffcb82ce3b2dac40966749ca12612ff94d892d545a552c8adf482072e3cfe306ac9ac29d2b72e445d01dac4e87993202ca65357802927675b9f17f91220933c00c801b0fb22c31a7bc1a1ac3a34e9919ab17e5f7930c4282a99751776b74bfd287e7cec18640375374a6635bd715779960abd25fe612ea685ba2451d89d3f3c70612bb248a2a17c76101c61e954bbd16d011bbdb0168a32a5f59ee3b41424fe442f1987228b559479c07da8b28a6a15190887808078d5197ae7941ccae079663106b5851f5b05e7040ffb8e81dca13b8f4f2cde0345aee119ccd9fd86510ebf088d82e200b19d0323e72c72c6f6e3679cd6e42ce0d1ab565630831d20ceecaa374059577ebc5d3fd92bb6140e54b5deb6866952de9124c616942ce9ec92d2f6bd1e171a2ec4b6e2d1eb7288393254d42fe500f04054220f8bfc12e074668299ca439699862b583b0e171bd6d01f34b2d498263b3c86d12e703099bb51c13baf9b117c26f4f48316ca08ac37ca0dadb1cd775b0108ff6b49b2e4942193ec048779c61d85aad48ae41b6264cf89a944d9973980dcd3903442e1d737819bad576884e2f2446703016b228df13c1cd545b890f0fde0c020cf1a2c0ceca01de4e37ac6c7fcc3e7d8e689bf53c4586c438d8f8281d2cf4cfa11bf82dd69c294be167dc7d982995a87449e246f1f8b6ec28c6095c25f0f4d51470988f7771f8d9fa300148faeb4484ad382128c3d123f53f849e3db1862338754ee32ea8636e26737bbe30909637e2a8d64288958bcd38ca47a03a777189297368caa88d6977b0a556159a9a621898ca6a6e434576952f447fd5221fa2249d2caebc418322dd9b85ca42eb9902498e4629d1b79439db8dd4676515f949c8db75d69eccf2b96c26bec06a9ba8d12fd6c394145d373faedae34444462c7ed419a257c87c1d373c9a8a604f972b7f1edf7d4481c595d47e2d0a33483de2efe63bfed708c54132fb1f98ccf0991db78c34c8592cef34dc0da16c084591dc745cd7fc3d49f96e658d9ec5f5c116e407323a29cd08b725f5cb3f04ed69e9eee0b277f370b0a10b9c8c54dcfaf8710ab6306b248ad1c1d71d96344cfd4d50771b72973bea536e2526fc332f0f6367186dcba220aec57e14cd21d8ac54d794e0a42cdb495f9855e9e155475c92c36f769592f7a310949c3cd19250be8954378c69620f9cfaf250976ddcda30290c81de5a4be470913d4e2650acc47a0c87f592df6f59256bfdce280f36b5476c873360480c004cdce6d1218a089a43cbf3512f7ff5152a4b6dfad19fb266eddfb1c243b289508f6de370264c820e5b67f81b4b38357e6330db8bc9194a564935b46ef03d7a1a4d6aee06b2c5a320265f21318a3bc2ccd890079d41a4feca78e3a5a7dad9017a471e7ea6553088a8401c1121b36c63e2d6451caa44b5fbf842874f0ce17ce24e9d134b1b834519301ccc8df06613af864972449718d2c7e9a6a78a650315450a11563052647fb861d889ea61c3f345c631e5e4ae5f82b70ac767e6ac77d4d83a1367490adcfee21d541333970605a70857240e6951e6150e5db0133e9196dd10d694c0c74eb6f3df961c667e598e0f7587baa9d570b15b214fe25e4a87bd3c62ee5de80ab14e70b340b092cce9847fdd29a8a32009d0bc7dd9ebfd40a04d2b9207dad06e6b752121a5b764d8cb1c77cd6ced51b4397a54715cbae722d6201cd9e038459dcc8098e4c4170ddff182a27c03078def187fd9878c6b36d6259293ef1c809fd4c3cf984145f247b93cefc6d7b9ced7ed1f4c009195ff6f1c83cbf20be4089d47401b47563abccad273c066798a63264c409eb0bb067033ff3d2a13b4d391b461fdeecab9c739401865e0ffdb36055221178c3062f94b23d00d43c471e8141c7fecc2397c807d022a986548d53bade57180e6f4e904928d8645a3e204780c21e772b689feeba50b6759187b24093d511c7d1bd00a0804b5fd6721f62105e9161c79da1ccabdd320037cece406a041457a7c5065129668789844cf529873a2b641595b1d58c7c915372e869eaaee41e2712764f92e883058a37be3dceceef6faf5e3517a852dadcba488ce4b0f4f140a97679d136a447e9ed5199662259bfbd8e04356d94ace0f5c75fa582303366b974daed7bd3d52f56e0294e7c78921cdd2687616ae456aec48cae0060246f4a384e10dc348427d210a89d08c97ec33ef7dba8f5ad6e43ada8f1dbc2b8c6f098572113005615ab4090ffdfdf80e822af9ac1eb257072552bd5adedccae97b44dd69fe510c097ab823a1280004e72863ad2f2e53cb6b7f3e9dcf5e1379d19996cdf7988f867e7ab3444b0f2efb95f1eb253dd52b341b87c537cc28ca7b0db37787bf34365501019878484b4f6064c816b42c78388f4144455e06069898cf43e100d02eca087c22090f158efb8dbcae127fa01425c282ab8ef61e5862edfe26ef11da02c4ebe43dc3ad6bc8e6eefb4b35899411ae4a72fa526aa473ca7b94cd3ec26af73d105f9e09c58232c01874d1e0e3e4764a52ec5cc13ed944e994e50947c804fb6cef1205f5463d0acac0ef7e166603c952719908d010a0752771444b2797f61f434c1e36ebbb5157f0dd2b788c860a589f90d712e315ba61299d80af1a36293a27495b0cb79d87814199b326470245134e253a4e3eb401b0529bf8b08662999851a25503ce3684216a5efdc6cc88fd8cc4f6b52dbbfd6cc89eaa7f89c25dbfa14c90e90d7d8ac44e8dc903a0a75e24d07201fcb66a1d760ef071ed4111da73de1fbf2b26f1e8695c90e89c126d1698e124dfc576edd6f8a25b5b0fb3c99138edf1d6c4e34b07e19ca578efe8fc4508834f312b78016d04a53ba446a8a5b050f44f17ac69ea883f0d5c5e662cfb0706ccd2179c61bfcac1f28d3bb0b83874de085e59fb2f0e83f7430d3c8ac3186d09baa1250bf373897ae45a595b830f72de00b6597dd8ba15e4e6e7b32665c812b77be870aeec16d508ea3009f378bee709ec452a6bc0959a62621753ea4fd91933e3c1937f08944fadfae4f809aed933d1c179b1de549b21301c2da4633a026492ebf43ec1cd726858d63f249a5e4eb133cd627d293213c0e97a8c784d1368d2b9ae6bad82ff47b89eadde0797dd9b2c456aa307416fb40aa384d0e3b64e47c6484df7635a278f8617689cccb85aa6b76a7c2b0e5e8cabb0c8066a25cbf90864fd407b70eec5c52f379b0bfd1121ccd9441362db6b7407e21823f20fb93aeb4a3609a6b6a2df5a3b65ea077c88f075119fe534c48afe3289576576b42a26a8dc7667b0b2dbf1ccfa9d871fac85c03ed265b575a429f3ca1442413895d6f806da59ebe56fe364fd0b9fa57de466cf45f1fbb462f837c6a9371215322d7bd2ce719200a517e6ba4363dbcba82c24b0441fa27d9de1cfe004636517f8a87fcad3f1f44a8b5f1c0da36f5b288faf039a8e050316a548c422c914e3a7fe092dcf7c675ab600bcf08113284ccb76506dcfaa56f7a71a1bc9871be8c7492e1669fb03facac42c93ce9a9be783ebb9f0947ae679fc276745dbc8b841ec93daf50327dd7e3dfb1b468c31b9d77550ada5399fd476acc5ddc7586da61fe8d15ea9b03396a6cbe788391045c3ff8dfd762df6e70307c490fa26d5515bcc4c86f6faf50e11916ec5ebf6a81fa622128dd881cada53844230f1d2229f46d9c2de29038b8aed44b37341c3d29472a80b8a45d4551c4c4278ed17e08476a9e16803a0df04bbad9507f7650fa8fc43df998aa0f5d998bbe3d2d306f91e4179a742758fed0e371dc6923e21bbb44d73170156e0e1a2f8dd1b71094ef390132202cc5173ff6422c5f31576241f6cc29101cfd2c43a00b6cffe4fb5be523806ca5579117b61f00321b8891a6a07107abaa5f5ce805d74d145574a741578dc0033fd1bffd51a1d944f966aa03d95748687b78c57b9a95990fff8bc184796a2d3b47d2c66ac1439968b081fe4d121982ca53b50c1f3accbd0334d2ad643861305e777e52d0c369d817ad87b87c10594c5a6f6195095186ddc1aefad99629acde4ab211bb2740662d4d9b7d1d7fd67e32c423d08ad4404fe44432cafc18dd9a2e5d7d009ad242bf113e10bffe9008c8da2896ffee4ab9b7dcd267691ec4c5dcc968908ba321fcbfe2e28afd7f5fdd974fec74c051d706c4d99b6e7d96230988a49f6ececeb4983d9533eb54f6e2827fc1c873e0de5e8af040190d72786608586c929f4fc9da54b6043798ef527392ae494016478e608284238470eb76c880c74f524e694aefa215bf81aeef3bce330e1511414900be9ea2ef49bc5484e359d4fc3e55692f176b54a49d04adaf300374852a5be309523ca9bd68ec728abb3793894a749f47ff4f4684ce872726d5f9bbed87d1e2c5e766d580c9d6ca3ee164bf53933af966cce31a8227f77606773036517018eb1ddb3a25464b996b488f2fd8c81980fcbf77835fe3d0bdb24a88965058c454c6973e57f8bda915931099d2aa6692db24d10597c42c876e36cc9ef6fae5c2b901556c911618d65364b71c6c4c47703ee6ea83a6e3a4f65eef33da37c52635e403c5628f67e2d32d8f922d1d218ba9f39c05a828f9d8be7761f2a53c4ae5adf00713e3e126bdd17793c73d711ed3792f924ebd29a8fba388b769698bd18fea3627fea54594a674caf3b7f08037595429128d5f476b1a2430e726b7d8261f9fbc0728dfe2ff47d70c367afffa5353c6afcf86c2d401bbae4bf01fe0ba7b4d7d30b27e5bdb863700891d6c961a0e8eaba02745336a187d9e727eda44327b327eb78fc4bb9f0c46412fd5dd318700d3a8f2b80cfe046ea01a3151af304dc0188a1ecae4e923a6abb2124791a9df8aaba75023c76ad7c514402d65480cbe883c8e90106f56aa4b0d84aa864b405d74979368938492c72cd847fdbafaa7196ab1518e978b6bdd847b7b4a6d3a150e3e8ea9b3deeb40c3932a9ca888c46dc1314c692c949610815268fabae2ee08dd3a84481a5cadcf34db2ab42c7bd8924461ceedfcd0e3fde07180a96b178a4b2799ed686fd7a5ac51e8d9993b3b14007f05c4abdafb8cd509552a1a26d2a61c33f00fe0ab8e093a08d65cc5881062aee758b62de7a41a997fbff0f45a57215202e8776e87a34bffbe856f3da7bbdd670c1251df8a8d71151f79e07322b2ea5f156bfee8c90c2152076d240332f8c3e643e101602da6c7a898b51baecfa87cfe6a71368f5003530164bc55d16c6ae49ee7d4eadc09c7170faf87bef071d64d1abdb49e7c65bebcaedf5cb773cd6dff1914858b058b7ca152333b3db7387f031d0ee93da069ccad7bd1ee8b0777c9e2ffb61559a20280a91b0fa3f727e91d4609546bcc9f75e5b82598c30cc829308864d94ea2ef4f4be8bece2dcee573c5f384e79b5437a9ee050fbc8c15c0859409c6596c3c410b5e5a769a29bb567fac2521da5b548185ca5ab27a4ccea50742999d2c8f06536f6ad8d0d74f1b59bf579eac4320c1f6b08a825be5e5c6558adf6ef0d93ecad3fc793ae37c5d752945cdd0f873aba1b3f0d23d0218e9b58e1f2a9a5c2ebd806f15984c4d4c3a1da09624123200df2a1c9e421b1260b1ac0d77bfc65416dbe8647a67519982eca438b43e1de67b56c9c624178d807a00ef8f6b6d8d938816a23845be74a1b5b030ca6585def89ab97ec62987483fe05492013465eb21fe5ffd763964b471915d9574c07e543522d4609b630ecc6013486c7553d82cdf0db2250d1e46022506d9f6d1e7daa656d8a666c278587b332ab01aa245737cb7f2b25cff8c929388c3d6344b1d5ae44949d264573bcefc0140b63e995e6ab4bee5bf6e8e0ec73fa1d322088824868eb95a940c2105de8c15946d38394e342fcebdd1f196dd9e4b1af2f1afe2efe9f591f0fbba363461b6ab4f568b3a42c584c282a3f190e910c07df84303e809d136f2fcdaf10f0f0bc09e74bd4242cef4e8c3cb7582ed4c570a271d2e84454ba4fa4369743d0945f03a39c4bc9af9a0e1a591f9f57afe014edbc69ee1ed5ce66fd8094d4e25734e6641bee367bd53930d04e0f4c8f16a668fbaf3e75c93bacb26c17ca26c1e7e9a1b58a5a075dd55cc76c43f473d4cd05e15418b3b2c2703db681b97b36f804796c418496d2fbbbf7488cd472469465ed6e7a5e2710e7b0dceea3cbfcf7132b7dc554262e47080878226858000519774a9b473ae53958749bf5d5c539da8dadcb13251811280d904c07453d9f2d747d6094f5211ba31306ef15e24cc0c6b05a00f7bfc7786625416a83737b07df722e8a75777bbf89a4a917ff55c5e66d4a1c8d05567e95f035dd64647c6731e12b6fd53d95390249442a758278989254851da1cf1ed12865b51f09eea9f551d126ab06cb1cb9c5b46d6511bc4bb4764bbe33f91898b4c100a9e9b84310823736c7947679bb71a9aa85b382f44a0c127fe2891a27c7b8e96e99f9f27c8901b75823f258ff2c7b442bd1ce8442b72f83b180fb0f9ec1aae22882ab21705a884824b0d7a829a7a98a370f9d9deb912addcedef5187bb2527d70aff3e5c1799e3770d1e387a873b3b39e4e27dac7176a7bb2c3ba126e4c82a75315a7e6a9343f766381ce87cc6ec3195d112a8dfd33f8a8319d0af4f934216a6084d11739dc6d0f6dcbd5f936547057762ba7293b3e99671a410a8cc53b56eae97d85e8472f5041ded5610339bba5721caf39c041951ea22a12bcb433aa1e1d30c350ccb246595a2a37ff402a2ba32fa7b2e50e0b784045daa46092e3854331222244c6c5e2bc6037f281eff9d29c555bef6cc2119b6fd7eaca87fd1b7e5fd9d95d34a77f9b1d15b030a7010d98d17c0e49f8b4359ec504daa6097f9661e713bf67952a35f4f8cbe07766cbba6980f6237ce62eedce4e645f7b6d6b89599a55f1faf0847b999e21620e130739a265a87e4f2679aa4bd3eb83c02d79ab9ef6b56b4642b8a86058c289da67c200087267c6105a12ef21c554b41923ea15921cfafa8c3e84d15cdc07b5a770a20b7b1f5faf7e0dc84913dde9301299eeb804051daf3c5af5b5fde53652208ebb26de43b11bfd4ddb53998a8c0d31f206b6cfeb54b2d703c6db9c5c108cd2dee3824c2c8f427ae5f54b9c3e22d57bf81219673bec2a94b4732472c90c19e994d0011ab6ea21d855319bec6b85b0e08b13bddbdd7aa753e97a0e83ffb80e4462715c85874575a8d1712ea3cb2fbf0745bc6b4b2632b9caca18c700bead64b0711822358af8136fe782d7632fc84d91e184570193f0bc2c388e19ecb5717f7b96ca4e5126f5a9b1d49b0f10c846d6941b295b796b81d35e1aef0d691afc93cb9de48c4f0d9a7ff454be303a991d67863f8c9bbcc406e44cf9c4d5149a8143efb009901b1f036cf268e41d73926c76b3f2e620555e7a314f3a09af04e9e2b80aa809288ddb0f2fcb6f2953c3c59a23b9b267b5b254ca222b74d99e12ba09a72df07fea806e9cb1006e109333969b1bf3f7f9bd970fffa925bc7bcd75b461e1c2d688a9c67373006aae642be7d09e477b6fe914d4d589a716686451db544adecbd645bc5617e03c14e1214b445a3cc3395e2e6efc24e8af1a3565debbd844ce7fddd3d247483f93618fd8ad17ad5b32521c9afe8fd271af0c8d3ec7f5d084009dcfeb5730a95b461dee4d9481cd0c8c4f1369f0316ae437b749a2f385f9a1b4ef932f5f886b8d175d4671699f2bf10ac36dc452e77a42fa86a61977a2f5a7de29a25ecb364a8b2659064c1648fc8b1742ca4bf6b72d289b701750a53cf95134f07327b35ee2c2890df95d6f5d1a76eeb74379d8bcc5f34ed7938cdf3df474d3154a3f6d638dd5fba9f7878305083adf34d0689f9a11e09705dde1c5c6fee470959b88e73e6facacb27d06dab0a7e4dfbb5f518dfff670ba454da4e113b9a80a69aeac881399ed67e07cfa0cfdbf29435cdbf03761ba2065a271393136049869caf5432ed5f2787c0e282125f70c602aded483138efe52c62edb967a3a15d5e3f2335b1731a729178a2a1759dc02707c8c2af17e32868d68fdea042e17b115a2b87a80c0223b6c1ef31575afb8f0e007ae60e92b5f3854a65ad79d5723584c230607bee39e50323df726a7233f6f004c543e1c141e5d4cb806f7165213892dba393a668185423ecbe24e0c79fe80545598493c1b96cb111f735746a33efbd74db8f3a824380e3392229647571b45944fcf240f306ac7614e1a5d8228dc89e898b4b48470ebc44d5bee52fb2c195e372ea7335e0a089a1b63c6c6bbd9e74c12a732091220c41c7b8b26af7f873688a099e0adba871ae235bee50bbc46cc383e6993794a55b955f0976495a458cb4aec4f0e1077e3e0a1aea0a5d145b7b78fbfd483a2a132dc780c500fb45e41de665a19daa2422c40ec9c7e4c3926bdfaa2be949948b808891c8da66f2825571648701eae76b32fb084b66cc056a18403854789f330e13045573a3d22f4fbbb57c3a64a77ac3d909ab55a124b49c2aff2ec67d927552ae07c22a59ecc550b62db7b9d4939bfc2aec32fe90fa6aab39cd00c305a2e9de3d7d4f188cd82209c18bb97511759909e517bcfb4f6c73e325c5bac67ab88023c9c3bc8d0e375d6dfb4b924c8b74af82a343234550dfc973a575bcaebf8ccb46c32eb7b97f29c2a54baedbff11b252d6e6ae3d623f7fcd3dbbbddca24abf1847e793fc808be4a407e319a44c38325e4ce960c27cd400020f6c1bf1c525ef89130ee5b239a72dca8bacb7bc67b2c74952708948c5204b5fcb0a5014ed9ee57ecc62f8759c3f4af59f2e00bfbddb104bae23d5cec1309c95534508be6345d9862913f473133f85fb596cfb7f83b6d9ab9fda4e1dc333070042abe18bbc02f7768ba41eb4a8736907b54d8ebb2f22849aadaf25d9ada9e431f33226ac07801e43bb0de7a8cd7b48fc5cb9946106dc56ea4d59a910f3b4460f1933c9e4766b20cd943143e681eede1f2bf7e9c921ac5fdb41c12eff0b54d78fe0541e0b08ecdb446af9692d0f5656eb81b1a6eafce588d10d1629ceae15d9b68a2341f887b16d8853f0ff94d366e01cdbc97c6a21720a99d7bc57d6d403bbae1d892f8e645b6716caf8063d35d77078495b35896af2f881edfb64e64e4e4e3751e1930aac0570781be9c2e612c79f10bb993ea62e16ac9997da928bc244fe95bad947b4e9561c15e17ba67bbc9ad6fd0cd8a7dac2bab7630eec74045f8c30c2c1e6f29eea33e3edbae5bb2e5ee6868ef4e4655be82d5191442c54bc0fc5654b2850dc68e38ca23600d5ed370adcec669e2d52ccb6c2509d4253ca7cfd3904a91cf8b2dac4c4d995b48ac3cd3d5192a770d8ace1569f58e069822fac21f42c25836534fd50dea93db840e1b22047c3bf54dfbf581ac94fb05544416e3ab510fe0e24d689504452db696d75d7754659ee7803b2d4741fd7a3b60e9de821aef85f0e996bbfe897efcf4e280de774f8bb3f18d1c7b07a4851f3219ecfc57490bc5864fe76d14e40002a6f9d6177baa5d9494d73c9ba71bd7de8f820beda52d03613e4343f406dfa534c51edb4774ff62cdd048f611423dd1a80450f1e8e0945a9b72bcdc12255b5002865808906f17357146b7dee57c612f96c4c4200927c296de14da5b45d31b1d851ca7700741cfb8ac75ec7782a388a20fd5cba226428969d78a5edec6d0d9883b531cfa02671f9e3bd79fb7047dbb84a7dd2fc5a95d7d55e2e97a39d506d3358baed16bdc57d1f2ba22be81a8bda91d61143f3386fe3be17a31ba3b932461223d886ced3091b7607f8d1be38a8648462180f72f82dfe17e130c1d3b3f5c663f47e5dc09ff6e7d041de008eaeb9cfb50bc24bfa26261d8bbea9e4f261aef1ae42e1923714c68e0e2cde55ca9010f133fa01a01c1d5334b87284e9a02c7710ba7d7169a0aac8fafb29bf2ca88c824ffffae186c1636d6038f279611ccf5a1029e5cea8384a4071f6e7fdf9274f777659499c49d3b21d54110d5971e0d44a57d3f70f6fe445b3e4a09def441943c782e1237d024d76ea8dff568325f3a95814f0a650eb3a7a90843a825d119e089811c01f5d5aa5c7244c90f8eaad37579b7790d28428c0daef2dbc6d6842b9363467e164d1a71efc714785abd002d43aed818bc32c60fa30e187d7f4cf10ec6425c7992322a146732b1a7014f38c2f91f7944a6c45d3dfbe68137b7cd78e4a08f13bcb2e60b04de7c9c66ab04fdd572a70e2309aa51e87d94fd4a60f4934592d9b5d3ab74f9e9d5007f03cf4bf0a0333af05b97b5bf47b4d04ecaab571ecd2e0ba90137eb4ccd5cec580de15198f93c31f81a9864f0e9e35bafbf82222e7a6e03ca087914f32caa4f4ce290b753e0a861ec733ef960f36ce90370d717cc7ff6900ba9be0dfc22579f4a3526158fd684962cce76796fffc2975873517677197b7f140467fd50fe06067ddf2a4ed8fe31401f3edc11604928d5637dcd2f286f8def89306c06e5d5e3ba5141eb8167302835dd01ff8fa1a6c08ce9bb69eb64df508a7a9b6eb73e0440c8c03059311d22d66b21a56947ef9135028c1dc5b1ef3f620afc129a70a334af421778e59b0795c82276d409bbe32cb008578fbbf6ceb3d0f9d4c1e65d76ae50693a66e44bbdfbb5fe06511f32421357dcdeb2ea846b51333a07783aecaec514606f3cb3de40381b4b34034906830cb9a9981305de880238d1322d3145168fd29b5ba2eb8e058217ee703037d6d91890e6853dc4a96d13dbfd4e92190a4c8ecc3c72a972ce0ae555c6efc9dd530d296c2b77255c4bd931b2e1acc7641be719ef9b961ae977467f5fcf85e7387e24409623a822ab665f71c060bcc5223cb349912c62ee13a6d158844d0918436d673780a45b3ef79c4566ad553b18917bf74f8f244d4553c7736fff4b34c7832d9830a72178b9e8019e0cd8430633573e0ebc173028dba8d73d22c0bd3d9c6e42fa531b956f5491fe01c0ff1a0003384c1a9a138649cb732fbb0ee2dd553ed31df1f7c49eb72221338012a8e56feaa5188bfc0047f4331d6d4f6c95d8bf5d25257de14d29457c32e0f61e6f3a201e9db785f2014c186b86b9cb2c5c419eb8ec5919722ee1e477aa048de253131ac7fe5c60ede01f0255abe344f99bf1e33b4d94151afd4e6afb7a05ba5603fd4fc0ca08c929a666b46abf8a92d8cb461a08b97cdb77b6a31200423d55abbd9adbec6e747752027e7908d9d40e018a876ee4f9df1f636b3df7193314162e3e43c31d19062cb9e70aec0cf975ee7a9983a1c144a34e9c3175027a157dbf1a0a075ee2d2d2da1551f67efff2ba6df5970e5b2efeb78c02c4843f1655e23d1712fa839cf178f57fdbeec83e15882618de194e3cc660c08aadec0c27d22c0683f67b0b3ff3a99977546bdf6e9095f4ee2eebef88e9a24c5d49ab5e063026d26f9f023d690e9d09d5e39cd1d9d957225370c1dcd5d7930775f35ec310fb5811b0bda27cd96842db32e4372516449a18fc957fae8fc1d78c19a0df8a33e42e90c642c42b6442c16f8c19e70446fe0aa58aa6fe2d6d90e7d6b28ac27cf3ea1e8a22a602499f45f66ca26c01b70afa989993e7f51dc50f9f62713e8d3290e9ea6874dcc43eb033a15db9aa25f61716f54ee55e43823efa8e4440520a46efb9d6859058fb51d614d4da63441c8d299cba7008c3a398cb9e09fb8700c8289b15d4002a5833741ff38ae433790de4dc94064e5a565371e02e3b7ee25926a42867e2e09b99f10158400c7107d877f71d9fd6ae424b953b0c59578dc7705c7288ed7d19aaffe6e1723ca910d8cb3d894b7cbccc82ab906d70f7d9e902a8480ab51af6a4a754f017d4cfd78ed70b30b5633b34b4ad4aadc78916168d8ceacd1e53e04e5bdc443b2ad97e7fb620c0d906dbcd66a1bf7745e3e7660000c1a31d2a92e7d083f49c223adc7390f4f56351349982b196cf4d9a1b8e46a0ce0c20ea486ac13043da4ee7aef2d3334be647484c9a9ccf8affccbb7f2eb27570a96bacf30f21114efec0d36a8d7990e0bfb4760db7b05acd93f0ef09aadfaa16dbc10404d1f0cc79394d9b84e269c84a1e5d456adfa541c8b1304d9926117671fbf096fddc80792dc118a071c0b4d3459733ba9c59d65c8a6373f5f4dd5b3f9f5524ee3b8de2d0250f1b6230874b09783c8813856d4fa4ebb684cc7b8146b509d86e075d234daa997c13f12d9e407ea615e34476d88b8ac64f53b1ee0e09c520fbd51a15ae6f1a2905f517ee0f21fa99e0a4183a9d4a8a2cf0a587dc82f656b10dd8b10329009dc01a4fa08bb7350e520e63edecdc2dcacd04c5d81e36b7e0c8fb84b43c6c5f9434c8c6157b871020e084113263efea7b06672a7a74f21562570ce1561be13a36d4f4c49c4fc7530b247777644d67cae4893096d847e26b3f955c8028b4ab66452a7c10264d979e697ade2530cd0c8681e1b22554a80cd0315b157a7239ca4862bfdde99c407e2b8c2be7f5e2e1fcab737ccb2118f303ee6fc94d181de008720b348e1cdfbc2fec40eb410c1e3839e2fe5ded5b69269758f4fd74a96b87c25052b1744dd4e6b3566d6a21de8fdbc57ec2f2eba59f968ccc5e38ac8bf783ca8f722d1ea88d37f72f169da61403f483538a5f979974e4ace62812d45686a86a4c425a15d91a44c6a70d2b89dc2b6645c564c022774bdb10515900550435068ca762217a3f5170051a057db68189964eb310dbe24d4c9a59f547f4726dda7d0da0f6011de36e21bae1efb4b853c9a90d589ea938408e6ecd9e25a639f256a80275adcf8809e1d4c289c0f07172475ddfd5812367505c87b0b8443af172c7bda5fabe6de09af492af103e6982f14fc0780575561ebfde940147125f5096eb1d509f1eff393b92f8ed7f17be15808330e0b83315b4a3ce2aa67b7a563ef96ad6cf88351539ea558e7e10346a32542f88d40ec483a697372d6efd335157524f1c2e0093cb8132c4e52969bb1a95cb8041032e8fa55c46344813c0fe8753d8d2ff3059ccfe9e9d3b4e4804a56a35d9f929ca600c7207e0120bfc4abdccb36c33888e21245cc67d86fda893923d6fd39493b163525a1483435908a172c43575796015e6ace7ac3c3f5f2e84a2acdb0b065aa0f2c360f75551f616e500fa7d4979abe16050af31b9d35eb2d9c7d663856541928dd5f2602c77990b31c4830cc321c58635b53f9510f4194f4d5efa73ef3edac7523cb609f13b6452b0087bc1e351cb31a4d05d65a9807929c8177ad8198893fc9a7d5c86210addbe3202006986ea4ebb3ff6f17687fba35804654c2b821d929b94f3ca4be91ea2599797e1997a1d4eaea7efb6cdce3880372a457b98efc912e6be05657eee6a49da240d89f4cc5d9b0101b1d33ef0dfe8389191bb8c5b908124243b370884f2561becf209c60de5559267b78a05f7d24e437099d07420ba595ae6eb3a76d65abe1238d7714687d33f289ca180b3d65b18a171f31e680c567b119777bef92650728942dfa266724f3c5e819b5d6114e239fa45ffa1f21b3e4588da4158a3d594f5e0fc21713d9d7879b18735c6e666c1afbc82b83ac8fe60e036667920f1c495c0dc877ee55e4c09e36a0305c8d09e6d129361a5b95753f533ec4178a8b7370797b40f432d00378b1ecb483f9e6161f5c89dda244d2a3266dbc0938d063a9a570e3c043caf4fae6ded8df84631d690051d0b925042ee122abf17b724e6bfbc7ef3bd2b12bd3231161035a116bed44a2cdc4cc197196757273d89ada867148d15cff7cf9bd7426195401712e10370fea65e314750bc7fff2db03970f3379af31590317279a21dab3e96170a99ae39dade5d023dc5310cd1fef272a040f67ccd6c99cfed03092ead9bbb79b494196981817c566eafecdb44c3ab3f436e1587e29e2002c57d21d6c22776d2a23c7c17410255945513182d74f66a736b7f6a415f8a417b48495b67b9ac6af574c6c4bf3869d8f00f06f34cda67aee7d0b25427421f99059599c2fb7a3bc4554b968db5b1d5b1aa3c136dc2fff98d58e4e133d8e1d96f1e3106be7210a3cd5b71316b1342ef8695dd58819e187e07e89b8a44a31bf5e7fcc32078ee56b9313e961eb95d4cd3cb13e93f709487ce5611eda6e017c8ab52dbbace872b85d73f707cb9416bb59efac988fbbdc7d156fe5e28894309bc2d7bb6f5bfb51d21a33519e5f526a12aa74bcff47e79066e9359690763e72651d344c3aa03495599dffc2de2da972974d5df8e9b858b30eff7bb25985890cec7b604e2cc861ae7180d4d35239ec5b855693154968b8b256ead911ec01014b6f57aeadfb72a9a725b697f64800cedf8d278bc6e5bf7a1add8edc0a976320eceb10d07e54de195512802e8ad0d7652f5e354f103041da4ebef8084d0f878494b341a99f49769e7a1bfb97edf9596697beb892e019ea734d2c66358aa4949bca2a1047f7c539be12a522f46fdbbe3ca6c9bbb2974f9b494b6fc2d8ca76074ab5d60711303ca6b9e87892e2f4951faed949c9237af0d32e5159073a3d33a26fd2d3f6c305c95001782f93a4e23e15211b2c472a1703caa12467939bab19c9d22a3d52ff2a6643938a2eabbe435feb7022911fe91ae9ac86620e30a4ecea6bcefe82df5268310625557d5baa15e70d2c3eaa7773c17a54b391e90f3b98605867d129cd82025fad8bda8471d022a0ed5e8d95223335d77f8eb22a0179b6fcf2132407717c83bcc8e51da04056b48172ffd8916de7f58e5adfda727ac07c500ae942c185e5599dfcfa933b624dfd41ae469c21f85fccb24df3eecfeb039e158c5c455d0fda5f76ce102c0c273d5ec4769bf97b6106f0627fc955101769f803cd7df590f83884fb15d740723c84f1cc15e7d228c3c4a9e5a783fc8471dde924fc1d6c40892a3eb58977c1d0ef974531b226aceb8649a5fd1e758b01a06a69d7e39e5e4da62da6b7cbeb100f3a3215f694968efabaafe9775459d1bd7a269d47cc7acd8edfe4e061a75321331abc723c914a9b453fa0261561d7eeccc29151434c3b8c42cd1207642b777aec9d441775bf14b383ba549dedd955c1325003a18f2dfc7d3bb6f986a7333f88eb6ec043ee7e9cfe3847d0ccbb527f864b6c8c517e51e4b71f6b2959338dc1981c86d522c771f192b92833a226bf22994c15df870fd69493bdfeecc692c8f89d218328a465bf52a320020a206873fe8d9a3b9e6f57ca8907f9ceaad0470acfd2b28fdd3d42c6f5524e8543e6440eadf70681b64d4384129855a3f28dbe2816cdc9682ce62f0745a913dc1e22ded44076036f10597966b5d35e9b665a59283378be9081754f35ac0be94362e84c74d2549c11644d7c8f1141405505d82b8b4934b937bd66ec71bbf4ee1665c91065878f82f1c0b3c0f8278398992e42ac4151d10bf84a56ea4fa4993a526ae96a0b8bad6fe6e4316ef58a193ae35e8ee9b49241a1d75b1437c0ce6a4510b409b1eee2d99498b484c4ff144b73329c6f3f53fa3f082935841f027dfb2491c6035c8d6a616415bbe81fe66703b44dcc21f4ed666bf27013d82c8180506833317ed688cffbec218daff0a8919d81528ee7952d047e8a9ec1d04113cfe48798a402801d5fcd1b6d85fb6b7e5b8c5a9f8d87f6dc96702833de220756310a2da66212ddb259f7ee43e2e7b2c17ba9bff6f2a3b402f23dbcb818c4018d8cac2332e7d4b427831a3c0618849d0344df3d548c40896de54afb4e1c4aa455c77d104725aef1c864d57938a89dab195ab965dd1557ae668aa55cef4a170087c2bd37e512a0a81976ed0e143ecdb606584f7f829986fcc86f44e9511b65af9e43840589789003ea827b44f7d05a47901533ac90f77b51dad7aeaf17e7294b398bd149520453c6b802391f523b20afac187040f68f205fc3a0b89e85b60bdc0eaf2f1f7f1ba9e033f2081422022ef217d8dee84c87de9c3c2cec8e7710a63582df325e20048a33b062f1799acdfaf95b5776762bb00b246b75df7696ab696d80bca32f81c472a181f507ea16fba2825ad1c71d106e0483ae377c8368e48cb7f62c2a4514cb48804b60b2198790f2e3a726791101e1fd13eb714cf38be7b907d376fe0642be61f43c5d5194c44f340987afe6a19c46a76c72351a66aa0207eb2cfd2406ffebef705acc4e8fa1e0f3e14f71028168757a4acad6c4f44c8cd5cbf7195936112c5fc94f37fe97130ccf514327d9dbaf9a2e534779706f1116b7b1a9470e0b8bef2601afe260a46e40feb1bfb4b82c5418774dea84adc44d4a38bfd5cdc88455b2a1ec367ee423b7b59d108d3ca1824d85348016d4f2ef6f3cec468ea00b6779ef41b3dc91886d15ae931ce382e9da923c2b7c467dddf62aaaef83d056205c5c719b1a1a7c0e2462976364194624d5ca71870d54692c3aaaa6c5d93f74478f4f923a8cfd660e91d20742cf40389e58abba774941692315ce494e9e245ef4f4c66a5ae8930140fce5e7b365ce561090a010d0404ec26ec80fc516c3c840170a525766dab5ba07fa2fcae6332fdb19743a8d028beadc14e83cb13947d708b17919f9fedcb05fd8f607cc03d87de0e4f3d5900a17f4fc8cabfb7836072cc42d404d0f276358b1993e74faf84989ee5e57840a31ad2899d0b0f75688c149766150fb4f244134a034a6bf3d65d86e9f9d0fb4359c9def170e88ca242d74c823c9c3a1ef430ba47d10b4299f106a10045feaa4b91ddb95723217e6dd50ac607bfeb6b8383c4d1bcc5f6e5b5fa16c36710d720d476644fe114a97e3c034ebcb1e993456dfa841287d1e36dfefe2f2e98b56d11cd926e104135c6a8f6b7789db7f2c7cfe98b961f5346f938047d8ef918f098af371a9c2597918e4ac","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
