<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ebb4655abebcf9850018aec16bb385e13b45d1a3978e3b5ce41bdf0343163ec043ea46996d10ee28751bbe67e0d9f3a6b7432ac4b478f3895342ecf6dc1745e4e8b7f6e33b59fd23c8c744927595432559a975bd091def81f1073f413622c418bd0d325dce273507c20a68015d80abffcedee2b48cd0cbe139580d2f046e34eb4a73779760c4d1620805dec60196ef8b26e6fa1ad8f5d2bc10ea7543a56708f308499b32307d304dec395048207c82f886560c5f7017b1700f00128f9fd2efc3bdafce8af341e28dc49a51dfb3884f46a8dd57dc612168c4a8e681836f401a377e5759d9af145b0b1917d92b2049fd66985a12b6828a1ecc95e143353df40bcb45142b6972eb6f81d84be5b84474664ecdbe3aa5c6d1347313282be4b39c45f7ac14cade73cf6a00eb9491a1257f665668acff178b1aa87cc11092ff4d82beb69c95bde10c005c112d2a717733404250a97547dbe5c766effb7413278887093111cffaae136ca38820cfe1bc6fd47db8cabb5dda31ae2e00ea6a5060019778281fea43060b4777cfdc665ea48716a5121d8ad8508c09be7776307efcee4c9f900e11a31ce4922484cbeb9d49679d12a0f0cfadd288ffbd4e10f7a646efaca6ffa1a5eec37785c88ef15bd41e7f601d568f87cd34513ce79522e5e7f2e0e10c6af0a9e9ee30834ab7f851440a83a2605a5e08be787959db565c7c19e68f64baaab8f64b3264cf66f24c113caa2456a4e2e45cf0dfa4cf2d7d5f456b5afc20046a0d85a817dfdc5ba19e77fabef127d8ff57c38ac27defacab8c75715dbb12ed2df88c25c118bf834ecb7c6b8faee45a29beb182035a4242cb0e01efded4c135f2109848a7841fbb64ea48505e46fb510d52184c0121fb311acceaadc8b5baa8ff1f342ec35214acf71ea980fc9145921eb1631c9d465b773f5a07ccd8bb013d50d27588ecb1174254d4ed5d5bbcec2f6196ef99c179a6193244f8940ab05492eaf6d2e56ddb6b94e98b3e13a7e145674bcee26d7b12eb40944c8993bfafe70fc3c23bca4ab6d9c01c8d0ce94ecfdf01139eeaa9bf5d0e1ce8e5c206a64caa3283b9a49ceb7ac782fecc971bdfaa782b45494925f3cb15a8c68874b38758d26814a5f46c50120b7dcb3010060c25697cf882dcbaa3d2659080390125fc9719af30d7f80be6bc61b3fcb25b405c2bc057452f38362d10aacdffa391608777c1aca11b91b5669729ca781a18286704a36349c72ca21118a71ef8fe1df0b3997b8bc3c305ea8b36b92e5e64fdb57493d15acf00a380e970959cc1f4291268919c84d1e4154c9d99fe0cecaeadef9eaaa833555875c6fa40748a8fb8a8807464d0548c0ef042dc08d3492d414bf43069cbf0560c769de7df1cf0a75eea559351aa8aab2664238470957d794032b220792a258c4c5a68ca1e0546d766c358d602689f1f9c1ef7869566e381cf273d9e4efa17adee1448bc5bd8a9e59c1ba97c2931955da3ff771fc779214e9b5aaa3292c0acf80c6e4a0bbc96f2383c3bd3994ac206deb6466b1e060c8d99465449ac5711b81c8a12fee12297bcd7f4a962748d07dabb4ccd602282e8850219c3b113c904e0c74ff6a80e20482c73fce6b9d7b0ca00d722af202160015aecf0c0b04eb563e932483871b786ca353a9c4e980495685acdac96fb9f25ee9c89eba211be548abe4d60591c72d96ce2941ee4b31cb9c2eecf1b95b7131ae2dc32fd6cdccdd10708276ee609ff8b90041a7bc84a5d4cff70fbb5bbe7ab06029ed46c357c24719da5088b20c7ba96af951b3f8a60bddbc01f129b2ce28f58dc0f088472d77f92f1e6e879270b3e5f020893d27705f45ba16f761381a46e1166126e408fc85ef58739c36f4e5060fc1f8b61a1a76dcbe66ad7004f11001da0b7304147c26f59f8045910c5c5843de34adc974427c6761d2d8505adc1e0470d40ed14917e56e4bc80ce015188aa61e0f5e3aed1bf60b0872b4d5876f57c01bee57fdf4311c097fddd980bb3fe9a3fab30186dadbf4a19621aff73f3f6cf4dcb310a1ad722c6f1cdf9afc412387cf22f4ba069d53f87531a82468c4a81d39758604feb49e9b7c7f8882fb71d611cbb7861c501c4dd48b96d68b653d38844a6448ee7d402289cf9f3201f2c10a747c6c554baa5348f9bad886f33d60a1182797bee23e2d406783b46336df25e354161227832cf789f9d06d9ee9670779e52a7a3938f2f4e058dd6a61b4476ff40a0b765578ad85d44dd3055e89679a151ab48a4df83ffcacd07524441b29a1a0fc4ea9252374524782e6740d1c5dc5c62af3b86936350b42575e648dd3ee4f98e286517754b7e1bc10e19a219ec5fa2a00f7cca321a582cc136270b01ec9dd28691f85f19e3015e0c486cbc027328a6b319e271127ed54f4ad396eeb87d3d247f9fc6f050ac9d80bfbc4d8e6fe20299cce0922c78100ddf9e579055cb4f3f7986b75375045586d9acb7a884d12d96cdf2bdc53396c2c77d91670bd56423dfa36b31308f5a8aed7acc4e1ccf5fde2587f25295ce9f03ad861fb04e3042beb01f9687ac74534e7ce448590910f35ed73141b2b7e36aa68268f3671381450ffcfb6e23997fcd56b80466dab151132c42efac339be11e6ba7fdd04022ffc31e8723e336e1dae92b8565e89793cc2555821faab87a433a95d9cc01fe0c1dcaf791d889aadf495ea0e0041c05e2f3d63ef821edac1a1588154c14e73bbe217a37507067e10a47f50add4278e576f51f61bf8c7296d725aa0aa3054c3f6931811de459c70a873240d989145c6ab45a2c3384c4aa367a54bd019078ef4fee30f13698e42da6d9d658d32c8f1d69f58916bb120971e580a5da297802d87f742cbf908aa0c11e0ed128610a6e3eefc641e8c98dd5e7dbf92d9714cf4e4c95d8fab3dc382e2aa07952c739d3cfc76aa3f20a01cd82fa2577115937e29e60716dd682bf81d6f65f688acf2c5e4c856b708abcb63121baea05f2a2150221472c48647d096eeb44a6b115051859f3f8f8fb7def2e37602bcce12d4d37aa4c26b5017a43735e72c23d36ec4d7f2f146e553c46b2c14cee718944d71dca4fe9f32825ae2f563f7bb8d0d859b4e13173c71de567a957065935b58612373e68927cdc14286c8abc9991d9740ba2690362fea4d4b875e91a36e24e0642bb61443e96845ec096ba3cb481f87ea2a3db60b56a5541a6a2563516e95d74170840ffa4695ba4e100372d07ed7803f3a6110e476fcc0807989cb88bf8175b9f715d8e5ae54a375709625b3cd304237579286ab55eb949c0640931636a86a58b95173caefae628f5ecefa02629bac3e4fccf73548def2191858cc61b6f701e6dd56188f1135e5a8e0c8be24ea74a0a629d3145f990a865dcdc8eb66210acbce6162c88cfc90e2adf9a37df306e96e54c8ab88ef3e627386f2827c8fa486ae210b9384600d573fbae8c926c0bc62b480fea9d06502c73b265a035d80e9b900a1256622b1323789698122afefeef0effcaaaf37a9e45351381260b684f729ba47cc771f03634767cf6b06b7ff4cc94fa46a71c1f9a7a0e2ba81609879729eda095e56422b14f6b5e569fa2dc5db36c413c586ec6b1254b9775c9fb0a9bfa7c2578f099558c6fc5e2a064ece4cf66de6be222e542329870481172ae154754cd6a0ad43db24e0c3a8022e4aaa60be7e659285fed9f10f30c90b1774dff4ee1fae810086f112b3a8bd9b109bcdafe68a4894590f166e144a849457c9e4018a8d173b4152d68859738aa692580ad08e0ccffd2400fac1b6c954004491c404f0e2bbd9a48976649fef431db7d9327751059b62f4ce4a846bea04b8bc76a6b0c7c5ce98406a743cfe73a4ef528a3ef51e0dada1373c66c0f6172f43cce9ecaa6ec271d10133f440ec0e12927a766a87fa2b38223d3ad145a5cb8aba139e36a53e3e6171c6851027c6a60e9a48cd8410052071ad8bc020df27e3acb54c965dffe6373600464f6e5a56b40600a32bf9fee97b23d96c1c12cea3f81e18dd4ce64365d509f4cb9b9bda89178a22bdd3c99d3568163c91ea4edfac9161e49707b4956412efde6614e882abaa2ab8511bfdac1efc1ea5cc5d5315d2beabb188267af130b7fb264935c9d0c4d658d3befdd2a2726a88492b2089e59e116494ad3b9ed2c092a609196b9c50dd5c61f059bf4e595f2c0f727586b4e204088d87d98673b954df7ea8f4c40aedd9475e9d215f2018cd56017d16065cf61536edf63a2f5d71d02631f833ce3013031ed2ed047b958675c6b2e9a0990c9031ba3df652668beb8576690dbf4de1f4a2eb8378077461097b6cddafa0f5c6ad6869851f0d7ae33e9ecf1cbf9e3888686b99752e56a8bb74d7c7646a9410e813b3aed9edee455b66af9ab0881be2cbc5948656e9e4d8bd77367358119cf6bbc9ec6804dfa195330d4497b7cc923d900762754605ee7ccdfc07490907d4bf15a7ab0598d286250830f390abee8a3ef4b415d6a25834fbab0fb92d3c42d2c7a4b466018b4a203739c196ae6f4de00624a13cec7a12c02221225f21d11fbc7cd965f84bf8d7b5c39d660818b9b4ea831d418ea542336c6c63e657596a01eca042b037e46126525a777f89cddd99436555b71a71d3224afff7887851bb32ada40b3936c3d7626d4f38d69b923a5e88e1ba08a2c0f43f53c8ee96a1d3e656c0a4cb117fb6336c03b1952419dacde433f6a6d9398183d5a962c153310f1c640f6f627f245dc04f4476c1322ec753f15f601d8776598aa4374222782dd062ff43af3fafe3851081b7afff46e6761f8e76d48df7cc2b0c73645b3020e452e9486b58072f6375e6cf547a31670a0f5943e864a73ad25f9c9419ff2800fa1a4a19aaecafa90b2c6c9c585425dd1de26ee32adc16f510945c72df1b5881ee8c525c34e4c308ff958c4e429cf12320fd05cd1dea0a3b16d2dc09d4b930062594aa69a4d4ddca833aa073d84316707440efc59d9a97020a3caac9f05dffd8616d439cfb50635f3bc9af3e05360c03165aeca947a6c2a8575ba5ba2ed23d5d78a2e15af48510c5e3941ed443ace8d0be58801e27f2b69879aefdd90062e19b269945485dd09c13c0bcd5b870470f15adcfc15efa4368ce5c7a172e5c28a9acb657baf305c5e304aa74e18cfceebb41b1d64adbdac2f0fb75d4468f28dc113cf34d06321fb57c3c651365040caf4400e87d448eaa58def40f1d7ad2c1930f33dca3970f098986b6863f4b95ad63a928f90e829262c67bf50899abae8468836ec8b08b8d2c6d3c540367baec93e2772646384bd37a98fad06c4154fcbcb9725911edaf7b8c19570cd01be8d17101fdf946e79c13963ee761a7eca504f5de17e409fd4d86606e9e62842b8f9e27643f7fd91547e48d5f15a2770bcec98945d60c6305f92ff6e78f8198201ad282b0cd188f42d8eeb4f9918ae9e0e36e94ff5f8206170fb895996199dcc83534482501f9b23a9b815f1cb6ec154ece08eb42e0b65b0d7082e6c0d638168e51557b45d5aeb98a169e0d4b99527b494fbcf0469c5f1b76d75f6e9e3c8b3f4bd4b422a4b2246c905cd12ccc4f9f8303ffd07168cfd46a3c56543cd636d6a7ddd6a15b93c6bd98fbad1062c32f7ebf1f0d5b9d816dedadf5dbdcd544616fae7679b596bcdcea0225bf3474d5eed6a61040bd5301af7470e2206ae1d953cc1127180581a489a302fba3494be4e874df5d6536d14073c8039d50e0e4545d4d46163150190c10edc8e440e09eb2609553ab9342efa7282a1260336191a51126e9440710cea1b218ad0885321eca1c7b00babc48091171abe2f7ad0d003f5676102ea775937007ad58cb5574bf80d83f6e21f1261cc8bd62923dcbcdb2dc9dbe1f72e0391864638a0d17b8ef7b9ec62925af188d16c19dc2e800f467eaa3a7fe8cb48feed1a0133eda6ae452f51913fd960e654a1e366fabbf6a5fd908547c23da255d846685953f7e95ea28fd151f70335437ba44030e3678194c82cebafc5217a182ff4f19babbab66d1b90beb8a8576c1c33749f5432824fdea2fdabcf34c5628d414b75f08f1a8a10d30d35680f8e36db7cedd0ff4adda5cd56e14a76d3332aaa70f30890c2c2360de8c8c8018924edd303feafce997d2233ad045b6f6c8a958fd61b5bac40f1e797df89201d582c6ce04307d122273bc2df0dd13ad0a8f399b3e6d1c2f5ac34e570f5ce7a323542b26b44f9cb6a074b639675c2db6599f6324816472aa41278030a3e117cb4d7ecb3f94261b62e3f71f58b4267fb20492ef48ac402afb4b7a59326c185daec71768fa8d3a33ac316a2fe37ec85b2d6d622e75010fe83a4bb42aaaa4dcf4159a0df7403a705482a323c41a69b0b4fc7cc4ea33a94d44370e9b5cc70eb7f4067309cb4774f03603161baa4e82a60bbf017a36e4be2d2155092bf190ccb9b819ca2abc6c8394d55f45c82dae29914ac5dc3a924f762d07e75c246e343c8f8f199ddeaf20578e0e47e98e2bc6f5277a8bc461ee1d63b3aea9446c27f24d47dbc0addca8e74e4adabfc10b98dfe24f7673d59e8cf8df5338756bfc5b46fa05b72d9f4c5be490ae106e4a156a6d9b66e07ca89bd4c91b28fc90d3b589060d387d62ee65d704ce6bfb5631a812325b6e44066aa998130f5b41faa98eb0f24cf17f3975719cc6cebf43cbf50ae7d6316ec340e72afa35930432b357813ad1891f19592f13db23880794b20b5ead1980a29d3e001e6e2478fa2bc18383076fbd1950672441050f979a451d06445e05bd0523fa8a6f41b7f860e02b099b0fd4f21d37400e8ebc89b7dd733849dc1bffcaa30332257303326d89d60e428915e2b44e41a16dde26a6512e0604f2d3b2445f131d12503fcb04897739449abac1b98256295e07c622ed4035fad9a1287fdd9ab4eee74bafff2541b8add2effe44332a3c2fb63df06662e088ba8e8a77e9538d1b5abb1a6a8b13ec1c5de7164e27ad1359783fb5b33e0326d06af5285acdb1689085be9545a44620a6100fafd2061ac1402ea640aa9254c333e62cae6f0e4e480159faddd308e294e8fffa3e25417da9be35455cba7c767088fe785e8b7f62f0f9367f2db6511dd0dba99fbda1b7ecab0a9625d82c796f930799aff57f41640ce06e12ee484a9f04736747130252e5294ed9e16ef407b59cd992ebc8d03366e25137da2a92c0096d4dcc0143db39ef90b5d0c0cb90c51ce4b9528669375fe98737bef1a18b96295a4b390969dc02db90a9826a777b181285c373c04bd4a7d8023703c88f66781732f6516ce6c2dd005abbf5d882ed513f7844048a94368fa303297517c8fc831f3b404de2cb1019fe5f7692c7c8a83c4d2a63ee464b441519fcd6e55669bb496a8b29f8ffad107316e02e777779bdeb9268c0dafc5b0fdc99bd8e04fce2ea3c5eec354895bf8500324775765db81ce659c32229ad1faae64af34453a9aa71a488aa84afdffed81638052c1b1aff280cdaae3ef78c1cc2a75fc5ccfad9eab25200fc267e5e4c38e058faa945983a08408a99f9f97c74d26c35a9026c5dfa781316269962ec087a47527dbfc099908d86edad7ea08e5b32304eec1ebb4d4f344faa4a1e78bb9cc63c973a1ea639a7aa67ba2257e3f17112c0d4e9dc32656569572cca30e004c37bcb21a90aeb7c7f24f0da52769c7b935477da4f2d17b5c8c3eb05aba4dfc99c028787f9179317c34f854f1eb286b0f653771c9a736ebebb43a339f61ce9658b81bdc43072b99671da3b0ef4405ed1066acb42653f173d7636ebcd94362e2360e591b267bee851897f657a7e4c2bc16a4e0a140bdfccd0f41459198293c7dd2821e92d536d6cdcf80c1991043ab70a8121220d21f214c3bebd43f0fe98faca8ddcb216f9cda171deac26d6957c3f78b7be405634c19d7bd86f67121a7ada012590368f94a91387f064a8224e935ad33e9a33cd85845afc9eff9d03c3fced17b2df68047d584824f7a7145bd73088bc54fc7b9057b409b1386159ed2724a7f048a95b5f009ccc64e86d8099be3bc626b67a20e411a4b88e097211cc1b22df65c5281b7a814651646920df942b3dc0c38f4620303d4add5a2bcf0b4a5f2ce0df2d1e2b485e3a3926512b23907951dd333f2c57ea1dd7f7a03200b25152f577e0a4103f797913ba00b54a65e6a81adce2683255a2bb8a23874ff357c1cf9c2f927f2d8a04063f06e1a94a73300e3dccc6327da76880efd7333932e87a3c329cf0ce119d2aa291f502beed394cc5e4ccac8a74533728396735983996149b814961ccb6b585107f004f508b2f264478a1b9fdff59f557d56c1ad6bb31a93dc1203c37e6e717508d7f39857700fe26c41e72173d81d284379936262547524799597dd146b1c0849ca29bbe0a439e478dacf459fe85750cecbb06c8e60a769885bc1001808d8d3409c8dc018f6963e78e69ab2dc1391d5cc7708f6f4b082543d006d6b9e107251094fbf623517d5c0a429c70dfb4a633b4447006c7aeda2ce702ded5b85781ffb3f3b11a3cafb04c7268eb021915a53c9afd8843aff850e906783ce3eecf6d2645d0e7b72c97d6b60acea240f74386b924e11f2be85dfd01ba3e13610d2ddf156277ef85950f14e8bffc5a95ad2a43941dc351d2fc9c555d549b1043dc31025cbc9042f8cdf976516f46df1e5f8c0538a80863c6142dde5da2def3e02fc921c193116a30060a424cfd819b1e8cce0d651ba19ae19fb7f794329d034acf8b38104fc8c9f08b6b08d7f92ab2976fab6e09f7a6941a7fa71414ed4317a3f2a4a27538edc6ddea115561bd35e603e0ec810ad2a519bbe733b5b55f3f94089b301561e18a4015c5eec54683a166abeb8fcbcc9de2e6ad567bae259775c1334170bf984d07bbce1c1aea08f83bfad7773ad4b4e7a65eb5aecf4867ed785ab24f8b86921385483b7ea0b9abb072a70270cf5e54af2b0f6a1f397cebabeef5392a5df8298e056e99a19d198a59861753c0a8e853dd610e3fa84ba8ae3dc277ec7ed7d31266a883c2861dde48272fca4df188b4cabb14d1044b1d560d71e4833feceeffd49d5533e9cf0a4817d178a61bdd14a9d45baa517ff2fdf274facdfa96f3ca6ee5782420f37af2017832e1cf22a7200a820efedb2072573adeb5b1a44c8fe0b2bcf4fb50652a1436d24a1f818cf90e11fb679076251b00ea206d058ed8cad60707f29dcc55e8d85187d3f8f82566b706a0110d14da0ec55b38a6df09b084251445d82da2fba9ec76eb89accd35854f89fa44c6205a11c996aea332911071eb7df09319eb765127d7b613c2a539b260f52ce5cee858e022c13c8dcf05dab9551fc340b40fb2cc06798c91adcfba14d7a43ad0231e6b9e5230ee80876c7d875e2dad561accb87a07208a4347aa61d9b4781510ca32168d68d30b69f07e3e9513eb3591f1839ddd279c4da3c9a5d138523371f2c945f09ad4674142cb7a25460098b89b83d1f53899da075d94fa9ece311b52734ca6084d25c062bab0ee1c1c57ab720fa74fa46a18096472e4fd530f1d383f8a020efc90d01ef230f799aaf80caf00b12bda7a618cb2b49e8625707767d0504a8661a8298a9490e115d9ba6cb2c406eff29e8f3b979cc680d133782ffc36a72f3471dba1add42e570697d11a5c4de23577204d5d81262283eec33f75d1df4e2918399aa7055fe9222853480fd09ae5278c12002dc8a819b498028b52ff3e50516856ecdd52e728ffe44956a117be018f4c5e870e19412b64d04dbfd35794cb8b6c57dc1502a0a49b200a0e2bc705280cfc945fac85e4f192b3ddb883f9132e7dfe690bfcb0efe3f860127b32d8d488c2f0cf0df8563055e4e56f9f97a7134e455ccd2da95a94259217d05efd17ed4a76021d7e894c172d57bd74de4cd2747f51f8cded2d6cf37a83a8b5117a8d20af4c8bf1fefc753cf81e0580585c7c4c38914e0946451fc8ce556ac2873a8b1eaac3b42921c76c2e6bef19ab608cffc32c1bd35fdc5be45014de58d1472e699650d1f1abca90c8e60a2a2a75002a13fa341ec5d7d5e314f62e595b05459acb026f475d0bd3067d26dda6750dc91a19ed4fbb136a90e422f8ec574bd2025cf8c47404f54a378400f7f3b923f4ffa5bb5e2a34def7bdfb8ce1cadf458fa7da98daa36bc69a9e9ddb5e099fd561571f13f6a3b444ce0c175c1e05fb66b5af8cd47a5732f03b897ec76f826426ba8ef589d639a20c787412651835d290981ce93ab11a91818fd8986335e599ecfe04b5291560da161544e3d765f649a4d4bb4353680fec5961cbf5992088de92872f5ba973feb13b13c98b7c06a9b7efb22fe09ab34a721d253454762546409b1171fe98024ae7743ec84f610d3929ceacef575a0798279beaf058f0895073cb3e985a78553905c1006db243c9c56dbfc9e2a9ea5f3426772b169526e868eb98be879e9b8b524d2ede4bf5d466dfdcaa9a33d819088e2f9c3a66088d90b497212e2357b645ac519320319c1329b3ee9d241b9f06ec0ed64c7412016f4e8cb2504d2a54a7a961d1422306f276eb682672bdc19d6090901e56572b542e61b28f92a71ad20e411f68d4722fbda13a9502bb13f7ca403ed802283584479e3a41e75b7b0f2b0cd556c5484bcb55513ec9e045867579af41927b73e5b8d97e4db3ef5462abcf65e5bca5e6ebfbb0c802592b9893424d06b47b1bb3f33106391902abcb27ce55b688f9f2412dd5ea0773d25f1893f2333b9e26e33803fd001c1836940f69ba1c690dbda24d4f8d55398e15d2a30a37bb6c92e2b0839a2b548ba6f5ac5d42110a53cd834f84ba3f1508ed74458437687a062ea7e2d285a0e10412d2584ce9d8845035f1e001a29334b4ddbd82e8b4c223c405200c01c20f34b3b5824994eb3a0899a5532829a91c4aa6c55640de85631eb72147b02c254d24696c3efcf5a4b9438f1e4222682ba07436de0710cafaadad0ba7d9e06c5422ec1b22eff1b0ac00a95c9502eb5dea0261999d93eea5f6d690ba53931bcd4d84851819079c88466fe66e4cf1105b4af55997d75b06460a864a5817f01f285a30a695f0d8ef43292035b4bc229c2f5bf00b48dad0429b749020f895bab22424ecd76733b6f474c07923f7339c19ede53876dfa6e069cb212b471aa121b33d9bb6e3e49b0ea2ca2871ddc39606a4b95fa9528bf48e27cccddae77fe93d9ece059bc0497e960a2c500925e7ee1b42e20010c5ed59e8b0fd9857abca0ce48776c9ee60a2da3d7866dc258fb0ce136d9a5d84ce413555c153cde1e33fa0b6685df06642e09420dc00a12eddb9a68ec12d57812664956393d7b9776c3a93e86c2a821841760a4d8aa05846da28998f2a2e8cb358e734008a2bbd54a4d5e77210a9b353ef4a59b6a9855998208959f1cd4501194c998e88880215534683034015fd5bea02a67ea30d0a6b88d5b0afc6227eaaeb1b32f6d1723331dc87d3c8d83d95d1b6ba97b8dbabf55d3b002ee5d24d4757309b0d4a19e63b87ca602880963d0d31d874d6a569040f43e8994194085341443bd84e8f731ee1f8c6ea61f9567f31fcccc1ddeb8860f15f66569e524b6abc2c140b67d1ce3ceed0c6c29eed90723b57817bffad05dab16013d03c3382c1f484d1fbde8413935b5ce550582d6c29ce0b822e511c4e606cabf3c01e4c9b3a61fc403459819e48ab2c57408b0c04f76be8c8bc592a5218eb194ab6b2eeac4817b5d237c2e993f517075ebe172f7050c9077c0cf7101954a5dfca2be253c34eddc3493a0cb5fa10576d56dbaa05acae3e0f647a75919e292a71aefbe30408f14456e2c18269e15accf412ca7f7b685d2e9ee64711f11d19cc89401820e19c3dab5ed8d6251d571011f6474bdeb3071a1b4b1b26ae5c38aeb29bd7644a7e99debb661f1c8ee81a920aa7fad56a070266244c97a7e05d385ac30e835b2575aeef17369c6cdf8a6742502ac10f6ca433328c2ee5795244f5c29091056fbd54227aabe69dce3469e72541957a8dc6e56d1b13a087fb9a01e98acd5f1ec0ecbed9df269248ec79e0c02030da9e6c7ab958951fef3016a4e1e0b7d91195b251bc45ae860b2c334848e358cb5d749fdd71539a769a948fdbeb5df98ff29b0c068697c4e41b14e72332733483357efba9ec2a63cf3a88d514f323c6f080ee45c15ad839dd7aab2fa8acf67c78349fda39286fc8307c5d4446431d26e5bb69fede083244f64a6af7b18dd0438f798d9b361f662968ee13c23b01599a786137077ef1a9e6022dcd0a0552aad850d0bbc410e3d1245cf8041afd00775d41589cc992efb90da89af880dbd487e12a3c5a21d932a03ad44e8aa97527d3b75476109c7c47c81fe47daefbfcbc18400023c72f5be67a13eeff5b5f19503c53afc2ca452850fd9599c9a2773123748c8945817d9df322e93e35a96813ad83f180d08cd9cf0753988f67804edd9607cf7d3b7904a76ef0b250fba68553bf9937484730ed755da16f496c97dbc6c78a9e786f1358690f0edc603ab89b1731eeef400170db62aaff704b441f5c236b30f054a46c5c2f53f7eefd0969fcf2e62c3e08a67478abe6426681d94ef59ecf1a28a71fe995d79a46f8af16afb3bd9764a093a2105f9fe28bde5512c152bfc9e5d9bfb4985d306b92063a9b61ca45d398956bd7ecaa04171c768ecb500058934bb0b316b8f34bda51b0fb573b8345f517e961f12428eb865a3a7bae1707beac8016c993bbdc65fa8b5ada8b65cf978b624d1ab6bd98356008223e6a2264065c09fa9690347aeb8b910f7c4f6af213a6ae75863f1abfba7f8d68323b997702fd809b40484a475d5a4e9c60c581824f9b471efebb6ba7a0fb8fcbdb239599dc4c151a82ad2614f3f47d860bc38f6aadf5610da4d06dd99c3bb252dd727d2e9d86b7ce4e751d94dc28201e22194775c69aed8130a5598a0610de8ce2bf9eeed47452bd6c0e7ae0d55af7db4cfbc2d0fa7f593473a3a9f06c213f18116ebaf30e1e97b1aef626b2cae1c211d62dac6f9b9e34b3b8e55e3ea5127b41d22705284716cb44512c4c841ce8bfad49e1f36180e6e8d1acb92ec84ca939bdf9d8d062cb4ddc961b80634f365e8b7b02a0b089472f05202fceb0f83f92d739a5a032964d90758fbc0cba77b4bd788b94ffd1d73d9a80d8526458330e900c9eaec6a439075b55d73d5c9d8d57ae48cffae26da4c0718915657a2c8058ed68cf58feb5a03c264fc996513b00710e7c2c6ea3a3217d4cfee1c06760d203c2e0be04da2cd8d4ad913e375e7c5a6f296a8e3902b4cd08f17c94e8ecebf3c84eedb5ca2dce791998f32466c22e1f0d05597c3189af20768835e410c1beabf63ebb4ba772786cedacf0c1d297eeb51f6d953fe3798054f291a5378e1bcf936e12e4cb72ffb30cf87941e66d28c7be00e67e5535b944d4cf3e4aed735a71711243fe41d0ecb8e00cd18033180b35004f6ef76097d63185537af2d6a84263966b3217fc797ce4ae0b76c8334730341b073f7e26e1072d72d0a21d56b2396ba66bff0abcbcddff66d662e4d66d3bb1413ace77a357b3efcc5effbc1e8642c3144ea2cb39b8f301ace3172516fbab5f0320ad1df287db363950c11df63c4f2bd5e69a3df1604f62ee04b85e0cc4291200c234f1562c3f5dd0521ff2d380562a86668339828d90628f4add7d8232391eef5d2ebb289809443e994e12d2a4bed307eab746a2a9f12c05a1908ac6a4e997d1b438483436758b264ca7a18961c286ad933d9f60176bf3a2221bdb2fc76c21bccd5af10916f84fbabaf05df7b9e6a66b7a00f7a07551e9622f78fd386905acb03dd7756231449a192d97ff43c2ec50cd3f14215a9dafb01228c564d5b2f8d06cc08a6c32c74db5965550c1220e5741c958f8ae6639f6c7232be6de51d85f9b81bcba244350fd292a767e9499bac7d9ea12e4ad560a81f3e96ec73c2f9798b29f98ce597a36f99192c47e9a604c4e13f272092505d0bce918aba7c40579e574a403c6f74ac5ad56b33d0b32066db4beeb9c7d9e0ae81df0f42b70d35bc88b88a3271d28a82f13a3ae35909920c265fd97128d05d02e50d4db33d164a337b590618759a9745cd7e8dc863ee64cd954811ab662a95c9c2652855582868a46725ca81cc2ba91928f5a64fdc496229aa0c12c1c44bcc22f1dc52404b9ec81dd06d2f0f39aad7f006f6614634c12437e0e765504fa87db38405c600f3158d73fe9fe2b32ca148dd23e94953e2471e9a31b93f37fafe6ff2e87e37884a7b61f9d8406b693e3336c7b53268f323e8c9c361b830920ca813b599fe75bbdbdd383def8ba95b28aa673a7d1320e9e447867499f20d9ffbbb5eb2d89cb871e7a3cef0ab6fcae28b5f151d5ac24cdf1d392a721110a93deed40f0597218df4cb6abc06d05ce4b1ecedc919420e874ec1eaa487a2a6a23174b9051ca022618cc4d2a7c07aeaf2f06e407cf5ccf835fd69c3cc4eb72e50a6f9e28542bbc337ae143d76c441e47a3bb02e697d058d5699a548fd9f4865f776a191b8d152b1f16ce0d427e045d71f0dc203b761097b3f26dfc6c62a7a783c424428049a795ea8cd0cd90caaf10fb786d4530e53a4eb000c12a79ba43ac7306b902efbf0d7270b628c4f0750c4853e08fcf95817f6144185e10ae4220f0f9595442487df53552c7fc965d1aeeaf09e63829641a8818985a063e1a8024620f13e2b4afc31446c690146a137908b66a0a95e834d1ccbf988b6c13b5989212b5001be34acfd4ff5f9b291d070f780cb474a26a8d01c3b46e42e479c145fc67f0f7f6c13d5fbb00f252af1a2fa7cccc8df72df56e6c322001327035d5c19d19e0adf702783f5267edc56441fb3fa8ccb981cdcfed3c6f4e2c2a56d73cc53760cd90e0ca0dedc82737def1e48cbb49606f04328212b6696e276a6985ddf8d6c0bf234a2d4dd0a215a34d1a0983270c9b8d74534ce8dc7078699d358f34171080ff1cb3c40fe53c5b4284fcd03b000e1da1e31d2fbfa0538157c0897328308c92b16f0a1bfb2554f9e17200230d0edf2ce6534f0c0125fa6e51e7746aac6c134a859a4c12a3c52c5704f9d304c1b20d447ddb237e0705c09d8187737a0bd4b113983838615d0a3c4764cdeb0240482d7c31285c990aea0808abc603497805a218b986ea9750e12f8e04d4ba86965fbc587db3a935a76a6e67c7d164069928bd4d3ec67a7733b835aa486dc2e269c92e853765cb07b75c18125fdb45f56d26896fb08a377c160af39be0e6e1dce735d212119b088304af9d6da434b24f00248b13ca60d4970cb5d0b8b5c4b0105730f706505945eb2c67d1b025d99307e3fa935b1325abe04c14d6e5ab63484403cedb61a9f44ddab4142fd99f37092c8dcc59fb6bb5f1eb505f78a07b5fe642c4e54bbbfcb8eb99d970eb30850c850072aca362529ef71a22bbcdd2d13418f4b92b2dff18f8cfe3b5c9e481423c861a878f4930fde8c8a8578ce6441f89389b1ffbc8158ab707b25e7ceed2b77bd26a2506edf480e94bc623b93d8bc656eeb06b95fecbbd3efae94da85c91ce0cfd855ab70669096a16baac178cd9f3e32f2fa280847c34892eed76302475bd31c46e9983da1244f7bb04c4a189e646ea112dc3533cacd955a2ec4bb1cc76c61a6c3a480a2d3c4d0ccbbdfc97b1b6d550422fabb7dc584589cd7e7888c701d3a095b3c40c6bcee389f9a8873c8f2f4d92d4a87c019f7ba28e731b38d352808ed4ce9ca415cad039dbf89423e12c5a5878033284ad911244d0c0cf44c40f482967d31ad285926bdd544524674c114faa3c9f18ae2ac02e31623f5e61c55b41592ea82413e4c29101da06b3021c8fee9fbcd806f7eb9c72ce0081481e0989f1a4b8955079fba86d99dd7507ed0cecd06a28be6994bb3a699b236f36758ff61d6b248b9b53b2603750e6685de85bee11991d1213a1455fa0a9e057d8bdf8be2109669a1dadb4035f28cec4f10cef6cfc2cc5b07c8a6ee9d928ccca1a078565db55cee1098ec743dcad265f15a01ea74eca44d560e41a52d961cbb3ee6f53241fe95c8d2eb7294f52905c15c58dc4d8192fde78442b844f4d21fd73399cd149781ab4425c83d233f93f09d82216955fa8e7974064b589200d5181cfe0c07bdb69b40f52f0355583cd1182019c4a48911d678ba8c1515d6f9e92ae327a005c9ea4c526772205c1e901df59f0e2bd811b22f2b41949f44990f9779ca36223b201ef16efff1513c9bad4a7a3b413e2679467fbfe6bbbb87986beff858e6e026062492fc15ef962242456acb6fe91750ca04e6c449e7e6c50054bc9908df1601b08c28987b624830cb6c3e387749900e454bf391c6f9490370ad83b3c7a454e1b25ed63b1a5e8dc4cba02ed8742f1322573ef12d779541c9fc85a78c41ed09bb9ca956028135d9ca54e5333d61b8ee9a71df9b150d6f67abe89643db446c27797e7e6025c482d4c4c75e406ae59a38571e9788c719ea28040b85ceb13c67216b8b35fed740493a7df19552e90e9a6aea71cacc409a3a24e1905d33d1e4e8ae2492d9e31017c580d96ec005d57e354e2366acc61226b7c6ff64b14d0d014769b0659d068e5c728fa78334e15000b4d991dee1d12008fe73e42d7a6f41933e3ea70dc2def18124cc98cfc1b3c802a176c98f0c5b907cb0bde11296a34647ee7afe6d20094304d92ada631ed3f78534fb01b488152b912506ca120a93d07b10f49e3da896cee5dd88980ea73b63f8bf6af5af08b7bda2cd930eebae66eb5059bba5538628842f110d56cfa43aaf0f8e9d3c97a449320eb5486925715a37fa375eef24f5606f83fe07861cceb7a9de65a2caaa7666b1798d2e82a926f9f851b60b3f645c9a1e71995a3454659387b325a8c051320a5a77d6963f8282cc478f4681daf282c7e337df03dfb78a52ef56a6abf3eae5fd5df8b2bfeeaa1e7c5136724eac70f08e48f07a365112f5861556dd399315adf28a9acb26f0f498174e993f2c6b4765f9847308eef8f028f9e4e6bbfee5402d84383b2f75c3b76e504876eb7a9d572d6dc14711d52bb328e429bd501b3dec63e968ef168e8af56aed28b3773e488f5004e3ed51962cdc50003d8b70719569189506ecba886260cdf53be3b417a1eca62b96c5206b18d4d8837e2e13aed08171714372c4544db064e2d32b002c7fa01a475a6737d6937a1a762bd464a2033b9a693e7b78f8222964220ae0863f5be656698057220c988c351bd45879b85ea245a151e4c67ede2293f4c74d3d26ce426d947ea5b660daf5738ad4c4f7424a5498697bc67b93d9fd0e72ba23ca2567cdf0e012c111abcb4459f542ad34b1ccf965055c4617353707fcebd0b5cf9c1d1b507c468ffda18840008fb9c187e690e49e7cf28deef8afb9d8f01b95f5dcea41c82055a91d07bcccbc7be858f266c57754268427816bcd39bb283c1c3dd8347e0c4c101d72aef4ed15bd5881555ffa2c509869483f720d7c126c3c873fce0c7af2f48241e60f4c95662cb715f116676f23510b6652d911d71dec6019c8e5965c145969f0c88d1fe14c48377fe48f0a38be2fc7a89878ff350e2cad3019e335dc7fe11ef7a80d126603979e617ffe915ae5fea7a251b55f8950434d7fa5c921526242a3ef15c8219acd9eab3896deeb9dee7ab1f980c7356a6e1993ef21b3227e9a0ceed933cf81780f8e8f21bcec800e70bfc180d732bbce25a383966e248a0fdc0ccc72b2f7a8a6a5a5f2f4d90803784aa2b6a31c5430a70d04ec6acaa1c457d37b0510c328bdfff07bb405a84eaf8773949544ea32c4f836d6e042492563f00a0367a91d257d76abf481341dd9611881aef41f8c9e1f6cad181680576483aeba76a01f98ae9fe6b7eddca17a4edec91c4f9648ce812dd2a0e73fc8aff6cd433c871e274a5a10d8f905f3a4ce67d05eda3cdb951070288c3de8759a53dedaa7cdb885e93f049a493570d63420e33bbde84b8381dc2180b26283745272a606c9c527a7d7dba4066efc9156aae90d3fc2910a36cd8e0d70b12d8bd1be","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
