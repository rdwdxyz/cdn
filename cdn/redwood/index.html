<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a884210ed235718b226071fb5c7e41b3ff4e47c54fd8fb24a72c49f83bef656d5fc59de988de3b315b89405edb864c1ce9b32bc835a424f95911435c26b22af6a7073879b650967f29409b820100180e3461b32733e7740a5b470c6423b59fe26f4f948f3fd3b03ad8d5c81be9d6559fc8ba8669763aae983579f05b05e1f707464a47067fd3a0b39e5e62886fbf9beb4494325d3789ddd87d097aa83b63bfbf454504fca82a8582df5fbfa68b60e430f04c149235bf8c1bd639d341b62c8626f5a836f9f21a505a8a55c306c8f265587de2597735ddbf7ce9a6ff2dffe24724672dfcfd053cc14a8833c0cd742d67eafb5a91f136499807ced2f9b29c85de6bc1037d42b14bfb3259015e6ae8dcd375f0aa56ab5da627755c2cfc1b17858ee2a1af5a1f4433d0926f0702e3ddaf4083cb152025b46ef91562a21d54211093c58731d6715c1ed2e1c454d4c6effa69be2b20c998ee37be63e48a161d1a115b02aa70061cfc45b7c97bbba4e130658846be57c1aa643260dfa416d1c4b91a3b83af4ac19005fd96dec5f891e1cbefa04e6432bcfa7b72cae963d8db075338ab2fef22999cffff4e0b418a404e56a6e0c8f59b441926ba38598e18419ca20f88d5c82448a53ed67160fd862cfe91a65124001598a568cdf70e8101122f8cd5709d6612f6ad0838bc604f3e84f11cae426a286a712e9964670a60cd967b4540212de58c22aa1553f00a00074a4093d7d279a260e1778bd23909bb3271389d0438b3d154c6dbbf79a0737015b794b7fb8231903c924848866c9b654370f2becc2a2ebb6ca93f9c74cd101761781276226babda59b6c722dee20cc8f92f2144ec16b2a806aac6cb5df59ec6cc04671b64905c64b1ea33b965cfcabe5b9cb09de7d2bdeeba5ad07c2eb334e56214c82ddc48155a2f61ea7abb6f8ca0e365ac6db315f79b800d106da490fedb66ba0f61711fd8580f445832182cbb646837df8499d206367925a8682705b285ef1141308f65e58a2815032c1bd4d58309bf34a6340ba427ee67539aba3acc77227010e0f6f5c710741ad1438def57eaaa7278f089ee5be9a860a34e24e5e869cb457256b4d40c00bae10523492905493ad6b7b2ebef5f64fb08f18567969c6803a3e6d2ea49ae3d0c08a6b21cf33d0ce2fa980cedd54381e73335d8774355501cdf8a99ba2aa485b08d71d6c16ed9ad5a13e21aee7588c249219683759f5015b4eb4b80418b3a8a585f7c7588446b6279d1f24f07be72e57e4ee4ba675f1b4e620e949b9925d79b12f19bc20ffa6e7859e4720e88bc4155f51a6c7200d5a12a34ff4c13a2bf5e62a5194ba2c7015e8d874cc950a1f7736d9519da93d292b7e808578254ff767ec0066f8a004f7d4c9b8d39df7f46be54f38f58b34d7a2ead4d2bf2c0b71d0be26a436aafaf6cbf56f2e97e36688d24a49c9b37abde0adbc5d35d9a5ecb60112cc431271b7fd4c8400d43b31d0c791ae1016b6631b85b475344ab11e7be634c55dd5321a241983c9402f0daaa4f390fa2591ae30775a6082b5ff043fe7a651cad92315ca6ce547bfd336a2a41c913da755b78d34b8ed15c077e58d32a3e710d6f960b03c4b0c9d5964d48951f0335f7784d0f291ed095e803ae42c9d20a0d0f90f1b81cc0ba4632d3260bdf46e10e39e987c6b2f306c14ed25b8e4fdc1ea1f3f8d89f10322b9b7647c60dfa6a4a76295e5bbab6697b0b5c1a3a768812519f900c691767b5b429aac6cbba2ddbee213b41e95d6edf3423a12da80d210c10ee7aabada707892e77632c7dd12703c60282025d032cc2629e34f10b1ba5e0b6181ed324745b90f3c149cf8613e68bbf4c51346dd31d4b6733e035617026ce9f6c021e05b9450b0cbcf494740fafc8337fbef5a68eacd1119d399d19e055e7900c4278953ba2236d670a0d3477bbf216c51feb5cd7fc85325ed49c0ad3d0b542f03e97ad7620c9508e47675c84bc6305ebafde714ce609343f9033ce723260bb833a435a2ca565ee09ceb33463fa4fd444c2652e3e1fffcc6b73ef3180967d99fcdca13a6f21943fd7620d495f876a7245987ee57e4d824980611250021f89749560fec1f97bf4af827f25b4b4dfff806f7c2ffea26fc9b5c226f4d46997a5ccad82691759708e0ecff2b64c373d4ea9bedd612778840a344429b7e317531384d3760cde9c855d333a1a9a7747b3768eb74d6a12df1d62b46c1c638345adcbaecdea47c4cb19006e2b2fb4041b3d8446ef83a7ebb9883c14f0aacc7ff62eb62f586e323bcd69be0f8442e4330b443f300b3e46e955f0eb1393c82f6d6bb3d1d683b2ea2f80175c70282c45bfb0a11f1eb0486f44b57a4dba322c9d6b123ed8224e8b1a327da006d59087250549542c559b187b6547d0033782f5b7f914c7ff22b75a31e7086c71563ca6a3fcfbe386f73d50001db162b297b339c67d918b52797b054c876229f42a36c2994853d8fe13bde481436bead613d6240ff8df46cdf54946b4884ecf5cefe8e83f857eec417506b5cf6ccbd265787dd126bc52f8ab2346d1d19f49fc78a30bd3ceb30470ba5d5f02d770ec1123f57a87211b394f3ed04c038ed09e7ee119062a22529f27f6667046cf2ba1394851a52eb7ea7c43200e9fe19932d6b84d7744a835c60d2597c06b8efe68df4b1270f804e360f7df4deb0be6d3d050e3f7714feec5e798aede1bbf71ca7ea2824af92631153c11709e28ab52f8d7d7699b4f7c6cf5502d1761bcac20baecbb79587a71f2a482af1419ef1c9893fa33e5624516cb5660e6bd63fcd97bff34bb635cb95180bf3575a0b67866b063913e22e9f7fb1be3853467001b6a93c344b1bba2e93d4cebe3f9656789380edd7d7856d4b8cd81656ff3d00c032c99ef71b2094ba746943c9ac6c7560615d37d081d28e2c3fc6d8abdeb9dcd1bf720c03090febfc5b3b4dda813e214cd72b13188877c7daff1b73d4f98bbca6e3edca58d2f48461f5d23f7553017e891784ad9d628475ec60584202eda237544829667089c2ac306fa0e43d25d43c637e4fdb4871e727cb7523c58c1663451b8372ae0f6a896f3d3f62b127ba410867c6b3dd48542ba9a4048634ce6cec6319285acbd214bc7728b459a24da4f9de7a02c3a2d4b186c493c01559b41523a80a60a41f91d99c67c09b9c8e8ef40064c8b6dbc10c84040d38934f63d3c74f05c8ceebc70fe89ac4bf3e63f67bd752a85f4fbb7fc14d279ed1ea799a7404bc3b58442e4cec46778497b42bf33b57b75ee2fc886ebc30c64473f777efe8a962393a4434277e05acea9b88a7d2239bda7fc0d295c0ec71d629355eab30f38247c0efbc327e41f845d73b55e397ffe2288cfc3963c14a331d75a3691cf87ed3179dd0fe1c51d6b3f3c839204cf8681f03c01eb9fb13f5d0a980c676a4c2ed17b2364d2aa652d48e62a5af72bd1f3039bf806483b29be2476d3cff04a95688a17bc5f3231ff40a309b3430cf28428fccd45bd314bd1d35484f7257cd3d78c10f9f7feb75a86fe6d0a2d79a372c8088ecdd6ac35e5e6cba7d16fd6de9f0c011930174765ca574a93f4dc7323a8bc002460a32e66217198ecfe1a544ee429356d492d65d40daa4fe492a33cf3888ed076f6554536c96b3a8f32e55211b6178c2c55df57ca65cce9cc11bb7d7d0c770efcb39d1bfceb109be35d34ce21377f39e345ddb301799dc474dfb1e76b93997fba56ff8ddcedb9369d9958ccd75d4eb0a89529b4421b5551f11a36edb1ef99aa2a1375492362c763dd7d3223e13d846d0bba9d2e1140f5a9287bcb125f2cc47631e5a5f924477636ba6a3fcececcf3116cc9fd077f38b2df7c74e863454910a0fbc878018f3a3460e22bafb126361e54274d983f1f3d4aa1afd9cba3ee28c9ee13f5fe1e0344043da7a8e6f590cc3802ead542a56c688d31f5cc5857c83d8b38c2586a9a60106d3a7daf68127e6992fab20b9d4b7f6c09cd625ce3b5bea0a31190fd8cedad8e8a4aaf9ce81c400b73f1028af29e373fd8071f0e50d8fff6824ab8102edb1b7bf4cf14551511b1e9ab717604db914f1d986067008449bf61b0dcb04de060d3aa5b528c70f0010fa40b8240bfd322eb311e0752fb6614f7433d32a1b2011f266a0d6deabe422a118935d54f185514d93bfbd668698e0b06a6adc97dac77d0c4e73496b4c5a82cb4c1a77f89bade29093cdd205a7ea1d1c12a72244b6d6d13d0c4393e8c2db19a0cf0faae53f78d1908a4aaef541aff7d0723c6a365929d8edc88270bc8c24a7e54b519f09fe60cb9a277b95d0804933389d118b2e27499aaae7b673f2ce202ef997259525962df9d057fde1e100a208360fdc1a53b765e5b994997f06799bd53dc9dc7cd1396c8b33c85463dce4f408c2fdf6c3243a871fe7fe691a5aa5b86efd2e910c8a2f2b80cef41447f5c47f5a5f18f43b6bce976eb2bfae47116b0ffadaa16ed155adec670ab72e2c94e2bb720d22c7b225dd023a7e38574670f2ad6f36e5bc42804cd736a9f1c29b584b73591c407fd571c61333a5701cd851470268289bad795718bfedf2b00b5b56501e4ab8af37e4be93ea824f90d5e4d24281a21f3892486ece6fccfa68f264017592cf2b9af03b133f5929c163ce369089b0699d1a46d9e01e61f79c6a2b8478a3d5691e6a31ae9dc22c81115a1ee7e8985a9efd46a4130a65d19cc7ab8e19b3668e08a661f4ba6cc22cf6e3d945290a3b5f7551c707682a07292b255f887bebd04034cfac1468a262f67daec89b33e7dba006ebf17b4f0f566d859351e88ee015629ef70670329b20fd1d432d70a6250ba1e56f5de847eaaa39d69af9fee6c60e3965ac15a5cacaaaef03585a885fcc8fef67146e3a3238e66455eb261a446f34dc1ac67108cb7b2c69e115f5b3893104a54982783211ad8464b2538282d92c4396b06bd44b2dcd1c5b154a92071ae4d3176d6e4c9fd380d174aa3c0668a24461aa9d31243eb05ecc0a5bf8313573734e111f81ac0dbd1bdacd4ce7bbbe950b641cbe45a191bdd489518765e707fc965e9df89792316b5bce641392026b850ad1bc7784b874825e8b9555a0e14c769aa5aa33e77b11b539c65d9709ac390c07a193fbacd2d30e7fff2937ca6b14d7051201519c6fdc0b87d79db50064890d7c306379f8152d6a839c40bf7a5dd4a8b48ef6b17e6890acc1da6d99d4609d5cbddb04d93e432f1316b77ad44fd286fb6bfe665cc02f030694456059c09d742df08e632cd8d8d35bc6ac88ee8ca993e1ebbbe0a749a14e8a34372c7204758f4cc50ff43080679a8bccb8a27dcb87d48e9ae7b6e29de29427004f428154f54e40e9d04da15176b6936b7f25b8f89aa453b712bf4569cdf5b712c44ee2fdceef3c122d733a760e1a3adc53a9d324ee451a4662599897cecacceefcd6413d9cd5d4bcf2ea15e5b938f0b5dafb5f39c89f747f7abd017aaf55e7ba986e3139b290c7080b166bd5b13a99370b85449de99f3901d09e09f0f8ca5099d94a5b1c16ef5674f36974bdc78244ebad3a624a2367364c0f033b48eb20041bc2c5c4d8ec327f64c1ab302fc479ce2e64a236cece49af497a5fcbb2124eb25034be6b4461368cc1fc751c19a9a8e22c52c7640b7b7b7db57945a0c8f2c6120d43514099952a67b90920db38fb1e3f1b284ef2b3a631c76a997529b11c2138e83c9b5bb3928b3696458d1573402d0badfa42f3680a75e651272d53dbc7c66d7e6acc33ff762077e5b02eb67fee5c866695a4c3abc6c5b21936f6ce9066551764c745148d90496c9173c6efcd991eb59e097524c4bbe02a41dc29c8eee27e29b87b8ca35bca6b18c48ca422a735bd25f375fb87dc178659b3be65b56c160362c42c6083b1261498bf6711f9e3d2895fbcc486db56aa2c252b27a9ec8591408531a3e862818c6f544d7569a3e4f8c9756a3e200c88bd9e9e2fc6ddcdde75c583323281bd274466f68d9de08ddbf103ced030997a2b3ae89fc91ad6df66cc2c65d55f7cecc912184c3e5e01eb2a165da6bad6666f5f16a8ea70a153d4a6a8e5fc485b749041068b5772133f2081f8b6e948d79c7901cdbd2de4be6257054f001a1ad3e3c92fbf221d302e0eaa18e0333f20cd5f1dc37a757375b91cd40979933b1e928983fd87c188aefa84279bc755cd4d617842d77272d858407ada9122e8b9ce965f7af6d2eb32bf80129af9da795220703f568035b6c647883daa8834976effaa6069a893d7ff7938887954869e31b7bd87d6246f6c0f2df1f901e3a00c1820afcdb4a78eb43b073a9678be8cb83a12a3ec15274ce8ed25a6b459fea2676e1bec5555478d78e64037e9ae3e6d98b63632830ac329da1d2bfd2fa52ebcb847c15df733b1befbccf6e64db422fdcc111326680ccb79ec309423c1f1807f9671bc8b5904ddaaba7a73a5860b19e9dd9f74e2a1704409ec5605d7dbb842088759e38c23e2442405617f9008778e37b71cc40f2463f7c952c87b75a334d8f0b9490200c5552caf086936fd57bc6a6e694724087a6326fd38ec51974eea25698ff1360829dd2d742c136142e633833481951051d4c3304911133071997bfe6c2a863e10c3d0cfd3ffa333de64fa6454a68dcb54c0d0aedcb7d33e9ea79fbb00d775de9d8ebdf87ce7d26d6b8b6b8eb7a82dce2967f96a87a560476371da15efe8c22b02a854e4fd7d93cc711a8240de4e4910aa2a8de49c11d620294392bedfc86938f326aaa3518da050d329c25a078c69dd24c3ac973f0416fa3f11de00e149a5c74b69dc1119ec5f103382bbbb78f56095dfb98dbb7069b0c6aff1c5ba6143f6b43fb904dcb5fe2f342e50f0f432bf9a7a54b40d7bad7c4d0e4906e5ae942eb0264a23a1a1de603f1703b5d83139dfa72564d2d71eedc0b6ae1e119ae742ad8123bb63802b566047a66101c00d82d2df05528238a32e8fe082e845a3008d6a61d1f9838d512ea6c72e8873e8070220e7181827240c0027a66d1630c437684e7e14669dc398b023db0dd5663bb3e52cbf75d4be147ef882d4a41db9e9e24aafc3e42e1918ce1f91e4a0b9c08e7da086f0610db1d65e29c9cef0d8c0e80000168eb9898495c063b4629233b241db0a36df7ddc44ce4432881a1bd0188ebd4371ed2f22147c1651e472e333dce7a38c6ef83bdb1af8a19c6d5c5f076334a213492cce7e241c32e0cd1370f75fbbbe7cc4d911883e4db4ee592c047297f9f73a7043bd23e3063de173c6339fc2a8a697bce1ac89865614eb985afbf729b3f56b564257edecc5b8bd48dd3d0b12ca260d9670f9e1f84a3d182d952a7bca3b3cd07e523c4a515cfb077330154076391de38120117248e89b36dc3c0ca8698fb92b0caa7ef5eb056f0bb9faf82f4a9d9184c35a30b2d31342b22a4e12f28dcece4d52d022f79b78ef3131e875a03b5c38227bcedb79864e187461cb8b656fc9618b6a370469b7f8bafd2ac744bf2edacba184780085090f8830d1ff0ec2a9cdcc81db4496a09411bfc59a0dc2d7b6ba9cd69e7c06934f0bcda46263f19ed1b4587dec80fee1c407695ed1920145d05742053fbc95e54dc9cf35fd35f1c7fcaaa1c6c34f4fabe6abe62820868d9692851a8b271727728dee7ef1280522bd686c7330bb382bd483672777405354f7188af6d91e22c7311720f2f76d3e0f0c3159bb3642e54f11efe9467d9f747560a376fd0243bb11ccfe2155e14331a7313303732128405e2e304b4196896989baae086025ec2eaf6fd8eadcdf07a33f2c0e0d2baaac77bc0875a289674d8ecd5a88f2e5124e1c5bf5fc749591a3c778321082c34beb4a4b20b457a19372a4bfe20b98298464471c4fec2f9d89557c1b83b7ccdee43cb0cfecf6713714f81604a086f6864deb7a6d9d1dc0cbdef7722a72675b501d4ed16e4165597fd20c1427ea07280697a2245cffa3d2569d12d663372ad822835562ff73570e238debc2fb9a24fc56f93ab7702457e738b589dea9879417fe7f12ca28a32aedcaec17adfabf84c786b1db6322dbd3abfef4b84195907a5e433637d8d98fe9502498d5f95513b6b7050317947c98739325119938d37f194611190b9cb187ca6f356cd7556bdf089a3f03fe7726532e5e5a07b166cf86d991819b91264ba40986ac311f58b1eb882f5fc47c0599381986bfe2189bc3cb6503a942adfa5424d199f149a82e49a14a2ec3aa087a06d721113a272665418fcfe019a3e006e67c7e57ee12a041db0a44942a47de43b432c335f8c747ab8577592bae630b9fc98c12e712d0fd16e3ad421dfb8ef981a7b01f50cc3ee1b3b06d20fadcb503bf23fc82b6a13b9b8c71e83c262458590d572069de4045a4f4ef5b308359c23eff06add062815e3961420f5972b8bf4a3674b16f3b76e9cf2e3aa122d6a3f8ea548020d3e9e6436283e253d248777c27ffe4b71935b68a4bde73a83e8f84cf6e473a986af65c0fc61d1cbb3b0266f2a258bf9459dc68df9d738247564a4c2c536baf063a827c47be0cac9a0934741d98e4f4f157c28c91f2150918f92ea31286a413ca4f82a0d7029824aa3eaa9b8d118398c84bf20727caecabc9946b9349544d42bd83d7a5124c532a3bb94e8afb92d092e01d3c39847a56cf6f2d36d85fda6475c0454a0ea927f9334e629434a4ad1fd947e3f4bd1cfa4c04c19ed3124ba92d6e1f88a665d80707576bbc5359109c3bf920b77a10f876d35bfeb28652d1c75df828286c44938150401dcd215cae02087dd0e5b521888ec2d2f2eb18b2b78282f549957ae62bc388fd713b21757bb30857604e9823939463210d7f7dec22622f14b4687753d50b549c53125eba0f4f3f4b8ac89888eade87bd41723ebf2449dd238b3f1dc656e0b3eb157f6d0f7e298db360f2d3ceea6c7383daaad6fdb73fbf39210de17d1fbc792a4d9b8729a0cb4ce0c7217bc62e3064262527f2c2f081206243b74f804875b2d1cd4a11dae59a5537799b0eeb94db82f18192677530017d89da9eb24ee1591ce324a0f477802772d6bf695e0c8471d381c22882bd84c629894a911e7bbdc99b3500ea52e999448f0215f3678382327ab6917764eab1b2dfdb6d453d5038302c574a051f1ea9aff4f976f864a90f763af5ce5ded8ca9c3ded88c05d7509a816061d67c684c6b90f401c8d9cfcba8ce155c0875ba3ba14f436b8f0902050795e5ab9c800355a552295e88fe35b4d105737fa16b28132cf92e22d0570e1d92389933d6f50708590553b9ac6245060314a3b411ed7d5c041415c321df06c05e038406510ba6d6df4431b768ce302af63299a81dcffadea6f5986590a4b8e32cc6078b7795364fb03b37c364d5b2902f2b7999fdaaaeb4d33d3bb2bde9d294eabcab8e2624df678af71cb662e37835b6451c75ba3d5dde6fbcf2d2f85fb63875bcb94de2a99e9c7edf9eacb468ca2951ccefbbdceeb9a09fca78c280b2604468ed86080e57f2f4a01c745bbd888ca353b59104708d27a8cef4c82728780d81429f99ae848ba61b7cca18c3049023bfa1355901c809e7356455a8e0e8b59ddad6da044e1dda7fbf4f0d6cd4ac65427eeb37a3dfcef6c5b91635d7f1e8d61e7bd949b70ca1aa0080c49dceffe5937015de49a9040267c0a7ab5e159cb4229fd5849889827aae510d50bb7512c17f8f48e20238ea4b68a6933b247a543f9954fd58148d4267c376cacda363e817cedf77ba14cf61ca02954e2966bd9aaefe59ddc0125e01f5442b8ecc5aff52fdcdc18d6435b9b7413137ea2fe7c0ca4edd365e228031bd2c9ab791c45fb1908d267ab7f06d4e42b1363d30f935214746f42eaf6e9ba0f6c8193400de1c6eaf66e01e9f6112bdff71da8969d73a8c2da06b90de759f7c0ce75e020d22159a3de6981551e327118d88d3ad7243013bbed0cf9fe7cedb233f9eec460e80e57f39a24e5a1231eb70866e9ce7e3cc266f70da23acfdcc199efe6f88717f7cbf6c15746b6926f435bb4eca6a345ac08703dbbf7af704e9c3d2d97e970ea8664c0d7e1558391cf04c186f1549d9b613cd343e4187ef2b51f80c4975618ef64546dfb0ad3fbba1a2f3c6c48208c938268ddfea6d3ed88ee28a63951f0357c98b048043bffd06debe659f7b96db3ba9121d011dc278cd685226c21cca514a5e3ffd61d60fa5c5d614106c2638cd12e584c75512cd150eb715a2215c8543a0251bf62711bb1c96f89f8e6c34323ddb92cd9259b6d93912c647fdc9c684069c20faf4542b4cb9de5edc69d551cf4bd423fb96955f28a714b4dd2ea7032b7c270cb8fea46b3a3aaf96b928dadd17bd0ca728fe1d4ef5be62f38850aca3626141e4a0ba1a87b48b165556bf9f933c086298302663311bd1bbc9dd2e050709efabef6610b70d9c1f46e8942a570b810ef442a064af3a45d3cfbc429392960e5848244c0e03a5622da4765705f3269bea4977f8e2d254458518660b9dc0689aaac4fe5f31f45fa76cdc9198ec1e2f9c5cd65658fa18aebb64e7d3bfce266bdae098b403eb66ba7c1dae52b4191e4858897b412780feb0c7b8b8a9e31db1eb6a28d027ba5ffbeacf22457b068c8e335260f6f22b41792cf464735185dfcbbb8c7bac53710a91388a7a47768ccceba7063ad28086824c21206aca3487abdbbd0945309553d13179782ae17e90ae7585fd3ee8d51ae6b1cc76d82a488746f0257a43f9a81f0e358ff5301a7258bbc8e36cae9a9ff30a5cc42e51a1ee6096cf6ec96b426cbbdc60c82bd8136316dd6334d2f87fa4d40dfbb9d548b0f41f144a2d7d9587ceb5f360f0e0d3ee2cf72253d3a611c0dc2c28e2b831ff525e0e67df314be358c39962c4a1391b668d9ceed0192a1e206f435454b729206d6a6045221db157a6ac90114278a118294b659d140a0df6a6e535257afc2f489536ede8665d608edf2eec3813a63b28215c1a5282883868f740a80d14e6c7d328fcb5dc2eebb67586e729e69c36d13eb67b89ec46d3075d9024c9b004f027273b07236368a044875deeba0b5569096b4253eae100c285c4372e8fc78ba05a4ac3ffaad0bd1e6e64281495c11523c45279863ec8cae2a934d739554789859d4403a5d7119bfd3b075c8f508f6596518db9a277524472af3f1e2207df7e1b3a9b2eec3f4e20a0d572e75bcdbd4198165400efb21fe8be2e962bb12dc43f9fdb3f270df1ebc967876380198733ed60192762c68408ea4a7a5b29be6dd951fb9126cac4f03ca6e71469019558ba76d1e83692126bc2ff2b6932b652e0dd40e72f3a8728085b204cf542e4624cfe3bfb0c522a9d68fa7dae633b5275d0933e30fa7b490c1149b56c1dedee096bf6ac61e8d959a6619a847a8b9a5b3187ae9d4f9c701d2661c52cfec180de35da4f3852b8b75bcba74973e321128766c0f92ed29ba0161b2e7ba0680ad315fc2df87e9a60262edb77031177456276896620d916809fa7deefbf4e7f70890e5efef5c8fd5659e913e1dd989dc1eb581928d36d981556ddc9dffe590ee56f7c8674613a98f7f92382ade5908bbf368ebc98f87a6b5f2a6585343bddc444f31c051502f3f0d195aa877b12d6aaf4850bbbc1797734eb4c6312556f6572575b3700d6603a8089a83e501f228b390cd2314f659a2473e859b4513175afd37f081b75d16e9484e3dd901045102e125bd621d464b8fd6da4bf41784242a423ef3466bbe89bbef4d29c4187ec999e485a63eb5e774685eb7b424a5bf5bf4d0bfa1d1249d5592c23d7e46a5756cbfc63bf7e0e111582264b8622f40b4d6b1bebbcc489c8a4e627a02b0930719350c184744f14ac4ab9af65077d1c6dfeb371fc7bff361a1381b527a79d8a7bf86d48c4b3bc6c7ed3c9a72e97625f05b6c611c86e08a6bb5b6eeeda6d08b98d53bf5f01fb436ae749cde0e06bb505bb3b45a49213487e0b1859a9b08b521020f7347f2c13fd662166295adc4e6bbc9fdf1e01323f7d5458a97eaf2b2242bd9094fef055ece536284204ab47b0b30a0858581b7b7cd3b8f91f2ef8f9b415fa464133cf7bfdb06881d24a5baa0b182415775fe5e7360bfd4dd1aac15983fa8b4880e32b1caa9e16f88a5fba7846ab7a9cb48d3733f0e400b15a3dee1c83d84d0376a6c83fe77f947182472c6af971a28b1e1b5997fa9025c9895300d58c415308029da7b44b3179aafc923bb10b25b71e8238f2abb04261beabc4973cbd8f90bdd333d9a2cc72306c1ce93c8fca9a77cfd31b940c480c17bf2c0a1ddb0b6b131c3dfd2fa37427f5bca67dc6d549de1e62a6cba3003e6b26e9136b13dd74db21300a60825b914a972c6d633a8e045f0278af49bc44ef222680e35ef58e3172aaf9e3372a49c258ef9a80b11a4ea77f185ab95c8995ce84d17ccf60ba87c88f5f72c0970cc5d38d4143b87a0e0c0dc960a26d65eae0a72cfa7b4d4c0f0e1779ada8a9b1bec747e7018fcc96b292a3ebee53fc5cdeabf1828ea90c79aa1eb0a21ae58e2199a3ca617ab0b918924da55b3e49f76270bd2d510ac176a3a4adc47ba56d74131d84d6471b9f1bacbc329a54d5d5676431c1f16bcab50573aa18da59fe5c51b4e07296f179a78f2682f501eabac574519591c7ae925e9cb81d8f51210703dd5310f19a16b5498922ed125d5e73fde36455d1075070f9e3d23bd73972abd7541842a62a571a8c50b524fe93dede350f3e46bd98a8d13aa48a6b1ad78f68cfe9ea3735a007c74ba065fc7455b50e362a7fec99789d69ed797aee8a309ca7bb8fc63c0c314279157315e56616a441b0c9897b3cfbfb41c61ef39a1b0fb1fcd02695afdd2316c616d4191a9fbbfd7ef6830baa6f09bdd1c0681da6021cd2814182bb13baee9a59a62476b1abc96fb64d377ef7a56ea021aa3f93d17f5de7f43c49b7a4c7f818623319aef944c4ae8269bf9433cad196dcca688328aa6419dd27a2d913954edbdc34615a09ad978e9cbe8764ebb14f05c4938bb6fbe4ba3a347353403678a71d9e5e2b0ad5f222e3deca5a4ecb448409dc65d6037fdbe548599e1a127233d1e8bda12a525fc3f536ff0b40078665605144de0a1a3d4865436411393c56858dcd21566f5847c807693d27c0529cf606294f8821c9c4cfb6da678d9ee6e9b033a32f85021936fcb191445286c2964503f372ff2c74b03721eb3bcc7ce2642c21e2d58a8e8fb4aff050fd67e092d3c7f2094490db3a79e3436328a7ebdc33dcdbf3f5ee017f58fade0e6aabae038b53ac485e053cfdc9362299f6af92aea622676e1dc5c0f3410cf41d2a7b000833daef7237e71a26efbb3ec34137a499957b15626541244863e5aa4acab814f2fe6a55e6cc9af79b30e08c09529bd5a674b67c66369a38ba994cc741634d4171e6e7da95c0c9aef6d06cbce5256fd419462d64e1e8c7f8af40f48ebce46f60afde2cb88c988b9397a9dc2298e2ef1aac601fea904d82db6867f59271ba8ede341eb9b3518931aa91cef417c43ad3a274ca41ca16e396851f0a00c7f41c036264efcbddee6bf3f2d0937d2e8fb03e2c0ba8f515b3a58505b12af1daa9f65264f958fc6dc2e05c0ec978308a8efd2c4dcc9a402141c8c28f45f08a4146b51eaefbd62c8e3d6a335935796851309ab61a57e638012f10729036b9c01037d7cfe2cf372b50ab90e341a26ed6962bc9353930f9fac3e96cebe353b46fcb1d280a4f84d14d6def69eca0fb7d5425165378b646f3c0602d27d0e1d0a8542e69222d74858d1f5578c743fc5265a3ad25d4bb28e1eaded8466a281dd3aece651d12152cbcbd5cf47457ed47f3528c3e79de726267cdb4299c6a954112f6f730a9cc1ebc3b98589d4a084d790f4d0ad0bc31c832f5afe3368d1a851d2a6678e3509bc09e3a104566ce7ba66a0926190f2a687163783b4dbbefa26be16367a64b5cec145a78189f372d2811ce5917322e5422c57a099c70141993fee55c639a1bbed151df3bdf8f1a7f9ef67de6d858035e69da2f825c316646314b743fd7f8262d76064a91161ca32a681a8bf383933f652fed7a2d3cf42c03aa4273f74278d971174a991b33da688bfada06721a79cf589ef0af0ccc6902854dc42a9150f983fef4f8b06e38abd02b9556aa7f9a53cca3b50eee3251ab68a1f96b135d6bba3aad046074e4ad3aed3c92bc90708e9a233567df554b406cb35ddd697b4f5b2824b8705853ace24cfef12a25ab95c35678346a0bbd69e3d1ef5b635b32199ed97faf1e90e39f50d8eebfba36d7603839cca74aa00e69cc62418904236d9215840fc5f13324734b27350cbfcd4ee72ff76b26582c67824457dae0de917672215aa5430787f79f95e45ccbd4a4aa3c28d17eacfbdfb3786de7808fe9868a2220aa59ba66f5c7088369842df5f8bb7011a6462360ccab6f3d9ca7fe092a6a7076da553e7d13479431ce18530eaf2fba0e5f5241011365ee083567f502b15562084958ea6d5ce53b80ee721c33e7510a424f246ae4384bb3262ccee336a4d548ac8682edcd117d3a30268c6ca4b2c0dfe87220d9a5a96bb6fe7e8c11bcd454325a16489bb43d394b443eeb243d323e9c2a6739e809cbfc8c6240701ffd9e89391b4501f636b91984e11ec0cfcd02dfde9ca867ad906cbdbe4bbe5de8cc3d0979b4f9455abb8186d4a054612265eb0dcaec647766e11b4a826a27159fe21c381a2f26f306099e50bdfa923bd9a11561db2d468a2a774519bcf2faf71e60ccbc4101d5c70e8fc8ad50a0c2c34c6f62fec977ec26a803b0cc728274d12ec64c3b50ab340ba7bf7e58497c0aadba3a049083096067014dd3c6b87dbb395f702e19cbbc563b9d78a987cde950497eb86c332ac44041ca77077fc645edad36ca462cc5e946b30790fd709999c8c9f4a1e34dda5965047a3e67610e2a35d102866d3955c74f94229a899402646990ea7774f1a6fdd8d70b29a2a6e0d5002e87d07953ce9ae13ac7322f1933a9a4ac9967afed2fdad2cb3835daf52aa8f60857461068e4f103dd7df9d4c67f2a96412b489e4e6826f01bf337ce33fb34ec8997c3de8bad0e8b14fa6734c9e89dd1ee3349e01dbf0e31a033ff49b8554730da99ffd1d7746a5c96865a76912e4a67ccc5a7a038fef22c71e1a5287636dbc826eaa5c8e1f76e7aff40313c28a73ddab77dff5623f847fd0ab75ba8d6f2837d7702356a794d5385dc8711a0de68b3b34e21ae45ffbbc262288f67fb100bcfcd0e3c870ec25103d72640cb36a758c56a595ad611aa6186a1049f7455b5f04b00f63cd71f47b61b7b0a485e44495fe1b559d5a3872cb18604e431f612ebf330cd651f6cd55927e39c5e98744e26e37564dbabc95057b8e70ca136b9d11552fe3874abbf664e565288dae779ca8c34b227fad29761af5829a34fbbd7f0e077d92064cc89df93229f287eac16678663bced084958f451c17977a59e4ce5a65634f7c1fcbdf7065508679b09cfcec4f94a68b594baebe37e39f9d858b1daa3359408cd897686ee9301d0bd16617f3e022c62e45be636e9d49f75d714afef6455b86792de2b338bf4a433bd85eb99cd196d8e0b3250b9d0e3d8a65b08160caa1021f3a3d1d2dd3daaa5b08fcdfbd13fb40ab784584b2316181c344d51ace1f8cc7846debfd4c82662da5027b32c57172b2841d5b459f2c830dfef7e096ddd01b1a6f10eb474050b90cc3fd9852b44c34b43a8be6c7c99eeefeffc91c780d883ce497f3b740c04dc10e4462e38489cbf40205b0b7ca9b9cd8bef1b7f620d1b19cddb906996bb67c07fe5e9434f35169f1797ead6b337e3d837673e942c9ecee7b392d781955cd8dd054dca95bda6d3cd0bdcaaded07e757383685d16aa0626578df7eb31674123d0731ef5118e1c9949aea0261069f979d16fd896c0c341c2abb83cce056df749afb4a81ef0c2fe084cfef063179fa1cad4088c0609903e2735c4cf7451ea18ce1c0089351557a7cec4a090cb8e3e6511c93a347d75cb557ce43e3ff4843641519d27005d3206c6da2a5788d998ed7cdb4e1a40e979965522e589998fa5a438bce7a0c22d815efe4cd178fd12490e8a3976263afa112b7432926422a47e8ca665e8941acc5c00109e3e60da8f1d6252fb759f1dfe7a2d437b869ba205c0aea1446ff52459ad71a7fec27962794d622f2f9a7ed968fec01c7aab32b97a411b4d1d9df63321e73cb1f4f5f73aa6ed7ba416e98953f18557c3bd9b28d89fc89e3c7ba10eeacbb31da3e35b46bab62f71355ea2e030a6aea8ec81e771b1d4f3040e36d72e4aea3cd6792726dbc2b2fd184f00f41d32818b06576bf9257ca76d57655a8884e51ed2c38590e848bfe0abeaf9ebeb1b095e809daf867baa2197e7eb4eddb7fa76dca2bccaff5f92cae7b1ba11f58790218aa3ddb862c312ade416305ff972b517522221870f22bbf66d30bd63a0092b0f175a0b6179288b2f49d4827bc85f50933d80402eb2463e744c5ace648649d4fb07edcc5aa312caa60a2d6a03a6654f35f9bc3b32e2015624bd35a93b99cf8e2946c0ac9121551eadc4e11a868d56c1baa72e39f72a4c72bb7ffc3616d7ec10eb77c9f4bda2d238a3ba26ad6bad711f393d72051d036d37558ba5f850652f4b8f3af2cd87dc55a20ee7a31202ba60407923c6516606c501a3a5797499519ed0096006841493ada66972f335744687409e939dc80e64ced5f41ad76f278bbd21bbd41e4e949124f99352e87b0dc613f3acd8406e826fc251a9b7a475a2be8cfc9801d42a5b6c0649a013986f0774d656698d2f6f3d18a58e4fa9473fb72ecc1e83eb8654eee1a10897c763e67cf4cc374aab94d62a27026d94eeb33ce58e355a29356dd1a47dae8f7dd2a7e8b13d64a8a25a430e971ca40df9e944a88dfb375500c317f1c64a22dc55ec40cbb52aea9559b04cea303ac6715cc8470b849488f8dfdca00f78e7f5a3827fc85f06d3f368af963cb3018d0957e81043ae7b2d9d8b520eba1a4abb6b138abb9107d3a7ce9384871b3f907046667f566ae3c773135bbb097e1fa17b16950b1825a9b306d252748bc91663e97551ddbae73b053dd5131933cb9a93dd6b5cbb3f6b527facd3607bd32469a38c7ab2f1a6ede4e6297bf2e62c15385a0ff305e9b4f7945172badd6ad22d847bb65102e9b04043b1ffab9a4d985960cee677d46126af245709a493c274cbef711ef9cc4d44bf6adff5fe5859ed2537e931d0ee7da3f4e074510be06602413411bab0f4c0b34cde0bb5ac0baac3610f9e7c4459748af8433c18be578d9b6b07da99baa61bd019858ecd298fc09813bb0314301485fa7ebf21f3c02c553c8badfcde6fe3c6ed2d04753c5bd3589c980217a014611deaee2a778406b7c26160622ac72e98a318291f4a906ffd7be01c8a71feee2927bf83ff76be17d7a5ec18a835c39a5a16a28e3cf7e942a00292e06df121edbaf927c2090ad1bef0579fc5dd8344eaee46007b05aa4af7005930ca57e77a53ea81fde75d77a9e206adcc4b5b277d811131bc021648883f3e468203374c49a8a133fcda1b93b7898677691078b3a01139c21659e41ce2c0a75d0ede3268742ae375f44ca584b737fa4c05377a0568342c7ede5787f6c08f5ca75327897b20af49e489e2835c9e97d32be365b468df5c1f91b618582034a36bd90419d5fc04ecbeb3225527465a9fb0d057fddd33343e327fec54dede62d3fcc591783affd35859ecca71fa9adcb173626022cdf8093e83260fa9b8661d31502ac79224b3a3d91c676657117e624197a8d3def6ff8d34ef5015aa0938657668a4c9f7deb95ccb5d19232376260a58177b64e72d3eea64367617b74aa6a5b43bfe2eabcafd47bdc1e8058448a2ef4baa479f0137d49b6be84a19a7680c83254b78027e3cd7ae43759e6ab631b69bec673f97c1b2a5e82f6ca29f974f0b89d205559e49db808e62efa0df209c7fe3802cb36b958d30501a6d36e62a1ef6881726f6519203575d8bc77f5820d46c21f8a24566b978c070b212a657901c9fc4d469e8c77e1c553a44f36f3e50e0809d29217561c3c8309218d661f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
