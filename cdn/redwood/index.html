<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1a8be69616a487fc354f964024c1f532e74a9ba0413402fbe966cd6cd60559f2624cd2b192c343ddc172a153d361d79c16f2e11ee3481f27cb86c1cb2f14d30bea32811fca1985afe52ed6015dda142d8dc21c4e30841035f26ccf3ad048ba940c227413e067f72010a6c8b28ad3328a8163d3aa157c6118188cf68007a23f0c9c36843e33b4bd229fe49cc2f974674c53f6ca629cd6d85f2dd2f4abb7151b38e56241ad16974840e2f239f7050f5a28520bbf98e43a4173fee9060a059b7da4fe833a2a8b31b47615893988e6e42a7668315b1852c5cb31d2b9c443818ad7783265f8b654825fb96973b402d0429da2fcf9ea5c1b77e3bc3b4b8e84364092c09462d9cccecdd54f04ff65848ad18744e003943794e42356adf8029e793cdfc9b523b9034f125701995fce5733b78315e8abda40ef6e6af5096f65180654db8c0654ac229273f89daac31fe2173b4559675f31355b7e4956feecf64caac461c595b5bb58bb34c52a50677523609e777510efc2e89dd07a050a25f4ea4c96329fde2ece312de19610409183d1ded121de70fcbc318b279ac2d75715dd30ff00697ef5d03cf627741e155ce756a690294a4028f96272870c016772cf51050056468a5e81f360e1baa515df041b1b88dea741d878b40dd68698cf745199823382e1f773c87116603b82adce74a6e876c534d8ad4c7e3367f8dbfdb242b0c59423fa86780b0c46ee260254330c315091c5da1c255b7c64c12903084ff80bd6f78749a24d2b64ccf3f791c1af99ce0e7afee8111684619c186f1ef9a7c8ab2f1a9c064eb0f89e7e43b8b50bd366b977011af53ad36296f558b1577aa778e83e81c0c31b754f9778107e8a5c483ed40890ed761e548a400c163d5f8f1043301d9507654e6a06727a7755cf5def6776f76df992668db57363b7ede2d2fac253b6ddaedb98f6415e0297cc128f014a2145d52c26aa6532343b5cfe1486b7d1821e5bab2fdb026716c84aff6ecfb68a124fb1a7f94c5bbaba166d8fb2602553e3b94a58ab8e61416bb16a16d892ec3aa507e56c27556d3539a8307924e8770b1c0928dd82a77c0fdf49aeca3dbb1ce00b14d7490f61750b58acc1a586d5fcb5c722682af7444e1321704a519a30d98cd4c77c2328223df8e2bf99e731c7dad5f859de19aabddac2e699adc17c239750c8798d1d9efc036b9a98edd370797758c01aea041a37fd0f39bb271b1c4fa1a2ce88b5e7771f91f8f1755dc7276c6a63134c13280114d2fccae33c25a8696ae89867bf429e87ccf656bf5bcc7294b6f4859513e9263448eaaa1219a97992ce620ad61b1c90a37fa1469e945b57acbe4d300e47952adea3ef797ceb569782a36933efe97bdd3bdd42a4a556d8af9036b855caa686f9ecce1170a5dd4b9fc28820a7b4c37761d2acd03804a79333cd7a4fb9303222134e5e3776b024cfa44efd665cd2bac25cb8eaa4be146cb17b79d361b433133d968b9fc9bda01aff3877f66b3b90c75710104dccf6fcd3b458926bd3cae7513fd0e2ff7720b4adfc232ad8532c2b792ef588be27c6a4f5f8cbe9c45174e03fb613e3dd77cd6b7fd145ef33133d0f5a30438960b6075841ddfd37535e9af39204f5a4bdf55a8aa4f061c3c1e2384dfd4242460a4582621ac961522d8d82dcc5950681f55eb20a2cdca28ee3eb2ecdd4df817f0e57efa3ed0806fdffe3e6257d992862cee05535832b33fe8fc1b07c2e9b80a69e4d7d4d4dc492eb8f070d6292950f746211c585a142a52ee0ebd7d637d1bcb7968f2aec2a40f177e271aa98073df206b5014c02933f16ae34f7877a79f15f78f530f7590beea1a0ca82c907f50be8cd4e1b1d8be876312b70e137f27c43796401cd3d388400890234e933c70333157438c70c8b264b4f69da6e42cc019857775944734a4b5a8c3da8765ef82e44eb6414e3a0d71254a12d76271ceb1174282e6d973cbc4506985e4a96e3e8d3f9bf5ee9d4edd9ed2246cc1cf846b6df0a8f6ee3613149b699f1dfcb0ba9b87e9880d4c7094aa4080fcdd6d872b6c6018f330162e3e8163e2209a0c52cf0c1f2848c23617b1efa231e0198b3bac5365129c0f288c3c8fa7982f76907f9a1675e17d0a1ee97f844a0516daec26eaaa40f4ea6f87981324ae09d614a40003de5c361cac5a44870073ddc2ecaf30ddfe56730f12ead5da11c712234ab5b1f88b59b9feef98037c75cf85e4288448aac58aaa3ab9f7ddc6e359402f79b36590b37ee37445aa1d9ec16ea1cfe0b6fc11f5b1012c73dfa66ec6cd38cc2ca2af532ca5ac1b7723ba283be9d9295bb89bdadbeaae3b861ec957414318ca1a9c1cb4aa45015b7a0a41a2afe0f0a497cca0a2da2b397a5b22106c35dd469b3b0d989ddd21eb9c4de74fe104e43d91959d7379a1b647316ec21f44a7c93d85cad0599728261070e46e9e78ee94417e40ee66ff3efbcf377886db32157ca6cb6fdf1ab07cae34a1677e1bf2f620a34e4048a031ec5316ad247385962707f1ba734ee08f0a718c5ed78072aec6a8d87257e5ef054cf65d765fe01a766554646e1554e0ff0c5d643cfdf9419ef7a9726a58f6ff0782ccd2120f02e3525a6b36f2c6a4a7cc6147a2fd49d2a6ce387a48f564e69b6c9c3804e17138f853776c3cdd2baf22d220b6f27501556656abbcee323eae0f9b81041a6ea085188aca6a3193bbc9c221570f1e7776cbb089886bddc87651e79242dfba930b7a6e6243c090ec1923745ddb6566e190c0c9f496a0190797992e2f9e72eb4d6d942e0cad4e62501849f93708b41ff245a27f0cc651fdfa3f3c24ceec290ea5d7df1a253cad145e42df87ba646cc6224dac25241ad082a1a0c1d81ddf028291e31d22869442befcae25bfc072ff9112062ebec48785a2df85b496d6ea14ba35e8d118dbaa4a55a8e63678a28a7381a479dc833c7201fa749bd9bcbd26ae54e7bc06f9d116eb9707429132915b557d5792b80a935e678875606d0e28665284fbb693368d054eaf8e42d9949481d39ef04d4a369c9e0f28d9f6a78b5ea1cd4ad1daa051bffe4768734777a11ac4d602e215c43454cfe226adfb7cae3b7bf60074cd5d1624f074a28bc89ad4e1b86fdacf2bbd9f3d2e727f9fe21768c6067c9d6d1a1607011d97640a5211c72b255175cf04f6abc4bbcffe35ba7a149c309d5639c931109e5f224bd37766a2b61a56f556e491c4018e5fcc43fd8200a48f18ae7175f87405f4116035602b00993c6452071fa0c4f33da574019809d843319ab0f0f8b1f852d3fedd04c2089ec5fe6b5121086bcef6504f6318b13865d1b7ccb96abc170d3d5a95f034eb13bb7c5c701507254422b195bd7cc6d8ace9afe55e759cffd595052aed2c891415a3f676a9f04d9f0b1273c200d9e13fca704a4b4af1bdadef447f5f22799c57d4fc08fadd2828bf785f5c400378e4832d0ff0b70fc558198362df0b545a1551d1c38fde20a5f33ce045974b57745b227b4b896c3a0d7401567d5fbc00e9c9b77d1edf67a03d1f39392b522f6d261a80c58e6631fd488e760631b3e7bd9be42a5e533e7dce09f50a3a4726a74acde3f8a4c097b012ca35ffc676645ac65f743749903b0314d599e8ee7ac0994a14727045232cae132d2bd866a6b1107b77656ab4dd46112ae8ce875aa561de653ca695c6fcc9ccc7a8d25172304866cf64d580dcb853be35d5c21f2fc40898fdf5ae61f5ee49e0660c86f907919e6354450abcf10f66073c31281a00b1e16d65611d8f3ef1da168eeb8b01ae28aa9930a38c56b41ad8176bb9cb4ba30d97ca4a4bd0ee5555471e9e95eb90549870ec82ca70bd2c443aac7a2c4bbfb02ec1aac410cb04fb4525c80f5a986890add0ca452b425a3a88dd038be08badc2bfa7dd13d1b0e9c34dc0a3cd524f7c11193f4b57c72b35773c400dfc8e3980e27690a029392b26edf44c8046f55e8dacea582068d2ce0b13e4eac2ff29c3ccd5f3d30340c11cb8c6439d6bd731e75b11397fcba8192e16c51da04e56317b9a7508f66ae47eefec5084881cba78b7881805c9bfd22c4932e940a70ffbc59283f7b8cfe7ab6e947ff79525808617008542cf0f59b7c3bf6c639d5e6c8278ad1dbbfca4c1be3470c35c52790b9090b7786bd3456d60d2fd453ec60dbae2710a6c132760ce7dab0b3f3fc37c6fec4b145d7b2140bd69e12c7b892faa71d87e9eb724a8d534289eae162f24969060b18f9158884ecaaa599c1eca99b2cbbc4f3153f434f605d3bc69f33d9a6a62f8591ad8d89d751280020b65abf13415519d28f33e3dceeac1e71de37e482c55b1c229b2dad3e699d5f379049bc5bac928b70f955b3e35703cf616bdcaef46f8ff6a40d9757f86c53e1868b52d0126841541e90fa80409c4fd84735ce26d0239251c3a61dbc4be2b4bfd10285ecbe975b37c1e2d6c18dddf01977d071316afbfd6a0dbff5db347c55a63614b51d91357aba6a4ac88f9ed93c5855d5f2a95cd246c195e960c5f50c2a4affea6fccad5e825550082da8cd2b7999b5d119ff11162009862f5f292f41fb1ce3295dc67a115aeed313fe046556fab5871bc261ed2ce3021f41f83c540496990307cf8d268f59725e1ebc90a842167cc963fac96b806a775a115c855e3dc94a3351e3a2e6522d2d716963675002761bf64fad058950cb34c3b656bcad98aca0b52663d52821817ff2d195fcbda97eac71b8ae81ee718d8c38479d0e03576f907bbf42ec74816f0eb7f1d24ae81a78beb4361c5409535d23590792f1d4e317fc2e3e41ee52ecfac95782ea0bd14b74f0730863da8739c20f31537c09fb40a859280dad1d2a35185e86a6129d16527f2ffe972d169e6787b4e5d0a180c7f6029b389aa78b913982acba8f0bccdce1d1583d555f30b9b1ee9088d0e02a601d150f52339753e1abce32a9826b4fedd4d16a9b201c09866d1666b727715279396c53b7ed3edae0caa1f08bd30d9a08befbae56e7891f0b8280207d5536ae3390ea1063dabbe20ea870afd5200488a40e70a1c7f5afdb23bbad5f263f82a06151b1f31cb4dd603e32aa19ded437b6e634bed548873d5c5da8692cd81888147146b9acf407cdefda399fa73822c83895032358374744ec54a5610334f1947027dfce89966d4d98e8f1e4c43890bb1fcebad72257878fdd48ffa2460445376927d0e2c2e48d2b9c585d94aacefd8e434ec162243444467f35dfa420de25bea1cc6ab45b4529122adb035e371576144b0b64aa38578d4bd8392c574226fbfa8f7b70340fc0b7e2b9cc87d466f3ca545b5c1e2560023373330b23521f64eb8bb4096d4dd285b4ecf57f11619f59966da198d3a49c67b6bb191ab0a2bbaf68e1508a795f4c305c351c2dc7a4e5f1f30f4047569633050c40bfc5a7d2d3b57a3787f624366c8b34e61a4ee2484bf280dafd6eb0197e85b5484cc1afd5609d76570dd5c1d2faa977dde79b547f045ac7a88262945a8b0a68fe1e7659d6225b4dcc62d07300cd869b14c00265e9ce6213bac4526383d75942be154e1cc89a3a0d4bf3576fad094809557b062e0c71fd3d0fd80a229541c6081e73bc1f4bbd5e0c23749c590074ce1e0a4af138c444ad1a263b18efbdca4732f35dd33ee6410e2601a70fb39b464b2831ebdcd9139d18e4bb57173bd8f34f1717577d94ab38d0c43bf1753c9fd83b5e69ae853fba50b04eef0e3202e395ce289d44b7fe0550c5df47647f79dd47d0da1a15ca77553e578976e69c84b2fedb30d8d4f58253f7b1920859b9a06870d95b63ba6fb8d32fabf604db75c26bb9ec7c15c413955044f0845ff5374babbe9312e256750f443b9a3c3d73e3ea2da7ba1eabfd302bd3d75c8ed07e946da8c2e47b44c889684b03c0d5658aaf8f21bad436bd7975aea93d0b4b07923b93c21c89327a69c0ba243939647ba3ffc54fe80403e646119b3d5423845f76c5eba976f8c2990d6ba71add66bfef81d67cdefd89e14adf327761d2ae4dae617e15aa2a6c92e54131602cea3e62ec349d5b341d929b8f0ab5eed9d4c3f25f145ce8a48c8a9faa0278c397c0be7252543bf12fe379dab6e3c641694c635c6bda263affbd596389a44fb546107a0c5dbff2e5613cdb161102670c87dbcdf0e06cb651dfcc955ef8b21884e440173f027d5b89e0e599adee0900cc126b36dbf04716a0d75ae6e29db06332211284bedf752627e340ed3e527dcc9b1e8ca5b468b57a993b8c65900887a3e05ace868bbe3b6e3c66c25a3eda81102073a82f2d45b669518ca64f53e1b36144d822659a2228991ead96823999b9b6314fb15bbd398aa1dcefa28f6762f6e0e503f806dcf549a38620dbe5906f20da68ff58bd174cdf311793af0a0eaef3d26a52190344aa2b660ca2302447a4f8984402a88a8004726348e728c4d4897f9d0c9c306f2cc5c468ce7659974d5472f9d793a835c3e82f20ec4be2d8a9b5b009d404b6c219fb8278b3a61470045dab06030cd242164a2ace895e39b7342632239d0003a14bdb432035108ce9ec6cb6080053fe83f9fdb4c158a236ba972d924f676421ec5077a01ea567b8e7c4a9d318fe569af269e9686f6f438c149a0fc518b48f1eb6c1ba60d69c206cdfd88ca02dcd27e71dfcbc088e5814d0e28e09eba9a8ffc4e0e757ba8b22ed830bb21d2033a4275857ca09ec75b415116e10e8e8b8769921017a77473f079dc1f2d108012c376046b20832e278d059f116bae78a2ee7559614da330025bf4bd43954873586f36a021c9c5973bb853d52643270baa66afb37e7224bee348481e68ccd1416c3e01dc27bfefff00556548def3520aeb99b488f26f476c06fe1dc9ae8b4b7d104e174cab9517d313113239147e28d31cbc2da3958c548b36741a82181fbe03cc99c10f12c6d3801aaa79325e425f8651f630d177b2a13eea354347d7b250a5c1d7d901d87047d4093e815388a9593a65e764a76fa167a659e728a37231fc8fedbef9a4e631d06430d8ee4b028be6cd3b7dea7ec7d1fd24b7eaa77992c48bed2ac08e1c02a98a34791c8bb6d23d4a0d4021c648a053992873cca2fd048d06020424579d57460111d4f8bb55e633ffb3654a168e30abf626107b527b84b9b77e088cfff8215453c9858554c43766472ed12904eb2e76e1a967493771a78bde3184d416e40c6c99c7f82578c43ad686a320442cbb43ad18387b1dc069dd1fb5e5200b27691f94ebb52857ea1ab32fc3dc260fc44cb25d4cbcbcd8a32769af8466b841839004a4b8f17552cd3c66fc2825a3e78ab121228faf54689a0d6036d1cb4d5937a1a71ba96397c2efe6a3d488b359157b4b8f73d0706ff9008a85ace06b6ef499dc1acdd922a2a7cd2f1c1dcbfd26f68b684b6c240772dfc95cc61a89ca694bacf0a4788d717643e9e63400b1da7ea730573b178e33c78e292104da61019ae0886dbaf097b7cc7384db4059394e2e7cf7b6228f879f6736b21c35338d71e5fc7c92cf0b0d02dd7949e41c401e0273088a029ee09e33ada340f77b278022b2302014a7269264552709e4bbe93ac04faa86fa209e4e3f2f6e6d1f120975ea0aca4270ccf809e404ef4c501e58efa74d694cda537bcddbf481c96628d15a8ad56d981a1b27376030267abf637343b73421b50b96cb7ab98cf9a219f6af8f1d97d937fb65f10aae3c9565d5b85900c7aa573c218edb292a6b6de94888b451798c6bd72f817e19e36b183c9807ab89def5158e31f029cb659fca4b3266a0366c3b8e2d4716f5f93c4abe23e6d2524aa48ea3b00f6720614f6f8f4952823be24bd3ed4f010e390d20c149548816dbbca6922771e5a267eae914675f35169131ed873efc98819ccd417971a2245ee3c657aadeff3cc15de84a83d00b990aa49f0a709de705e7e378dae83550d8ea5bc13e8b1bbe4ca6c31e132e933fdd896d8182053fb20f5c8d458c5e95bc325facd0a0a838853604aed6866cf6ce4418d608da789313c716ed91d3e6a97a7dc99ce2361444ff6ee26aedb78654635efb7aabd49d9d63d80bd06eb5364f5e477e7624c187b71c041847d2671de7cf5c6356800bc46239a4a83088eadecb22d73c953d433598a49a06df9ca9000bc0decf34b849633a66a06125683ef26842b57ac2078523e5aa379737910260e6046ac602b6c1c7766198df448232ad73ba2047b341e13bc9c969015b43f58c40daf8fc5032e61ec9d2bf02ccb6a76e20230a3acdf14109192d4e3dd32420c13e30f7a7d2a72c6b3f7db35882a40f8e1c7d8cc07f58c9382f2f11db82eb31bcf50afc4f4553665dd985073bd7e8f09265376cc8bfb86d3dcc5e518737330c3d4569ff9ed8191590bcd5fc35a63c1fec5dbe401a5be781e668aa9d1f233c20613f14bfa875a3bd608e66ebf58319735d91673fe61d21f33153d8e74b32f56f386346279b6fc11a3135c796fe94df8507d6f6bcf6ff9b13a4d40f56afa38c146e8a4a1daca1bb6bc8201c3b94e96ae85c95ca76507085b16124e663a7174a74134bd8f31df6522ab1708a048bbf3a55fee90ee3530f8eb0d4700b0affb9559e33a8f06eeb98c856e86b882d5fc4bc3e12f3965266ffcf11623705a0251be52999179d9503c5f759f6fdb90ec3fdeb4f57c5586738091b7b2cbb6c8f9955d16dccced97fe779a72ab33c049fedd546b1409e25ad539268e467a0c431d8ceb8d3ce4604b782c6b9ee49567e3d3bc9efbfc4d9e0c10abdc64ff9f953b8c93578ac6409aaef49b7f5f23ad8814fa6c084f37fdbdfe0f9e561b734b1751cee87513ec522f8ca7d11262b22f97abd1d685278c86273abcd600b9f574df41864e8ffb51064913d97d03812d7924379266c52f17d4415a74231d2e89ab51079874a2345119947a7219ca9cdba999b20ef71cad7fe21092bc02fbaab4310f04b0672053e35d62c6e31a77e6c5dd5cab07754a1b1cc2cfead949106a98ff6caa9e034271261fdc5a85c222b5ca97f1d626dc784488629d0533e48315bcbf16042b031bd4bbbe7e506bc05991faa1eb5f34f5fdbdb9061c1a6173113c5038f63ffdb7d27636c76bbf7bbaebad64ba3c07fadeeda2fa15e7211cf0052d2201bd1afcb3d13d85a436263028c22f3cbb6dcaf97b8244ff3bf5e9939df8aefb8a19088ba868bbd7314f1ce634a7f6eb9ca72b33ca53a2f618d26715affbd7f79bec607eeeee10c47b3ee40b5a1c6c4e64800f01c81dbb5f5c7c91cc2c090dbb0b27276aa89c5554303935d63b48dd6f8ff68b99eb88504796d02aff7e6b24da931868e3823d72386f340bba1e408d1102c7b598ea89f1fcbb58aff13470600dd6f8056bf1ee66846a8d62d05183635c8d47e41c26acc8ff3728e2290f11698d2a05017d603ccac1bdb5fbd29cfdbcb2484ce6b22e3abe8c654762ca8e780eb7df6c23a471b1e74288d58112f74effbeba5c9a5925159ae8d9ee589e651ef320a541648cef4b28b482825da22fb5142e22d20a2894d7f814b22925034d9940776f2da67db54f32d4e676bc0a96b87742dc80bc51ec808af1ab7f26abc0220f668b5848788e6a0ce19ea8a1207c7725af590039f81da96ae3966d68c53d6360b8ecffc9224ce5727a3dd3b7a14c087e9fc9b8007fb2f583a919a9e9fd4c97f375b996155fcb9e9581a514c89138673e8c1f0f3d74048148fe72c27c240e631831070846bbcb11054b9f804dfd68546a0373e744c981d9f398c4cb314ece211d11bcae95f500d4af956deb32a2c208dea149b4ce37618bbdb673f6eacacc981b1c0450e365fb365bfc813f0015eb26457b85cb124437bf07d1c774a829a4fddadf4ba5df73949bfe95dfd26397a93ad0f7bc6b16948245f5553ed50dca971c80d5d2c6a3f1b63b1a0a47aba41ca55f63706d56cb3d2a0b1a646def8bb7717302e0db763cd27d1d717526a73edb5b4b2e4cb157abf9b930ca4484d5bb8700536222ae7e8b6910b2716f5b6642ca80a8b2c6e18f7956cedebb136bfcabbfb55e670e19c52ba7174ea0ca73cdbcfd73016a8baa85b49e57b5acae9aee81345b32f3d57b445fa245d22711362530652579a4ffd569b8c4afd633c7068ff158a76313fbb45481626282d4b41f62a71ca13af34380858d50625d5a1a115fa0e2b021ff5d99f32356291c6c12b4242a0c67023108319eed3e06117d2bccce9a3e5309887d5ce216a559e55f74ba36ada8442024a637065247176311fb8e3b9ac9d0edd59359e7d7dc4797ba3ea693afa12ad6e839ec6ff1feea0710405a33d6acf892fa81c38954ac637a54aa08fecb7bc06abc642467553284c8c1f85a6cffe8fc00c15d271debca5eca9d3d1cf19b871d963331b29630721975e9e55c829d9e17dcec70507c9db3d217","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
