<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"64c373fc17a600f257e2ecb1c86a1954d240df910e09057eec10b5ecc32f3fc5dccfe4f5e5dba65d42121cae2c404d7ce5132a13514006c41c53b3208cf6ba2dae4b6deaf10a6fceab98b03a546fc2e714e23e269e53005c89f6ad9c0551dfdb7111bd3c3b1f711306d71d1fcad5ffe48348932fc61ed04ce011f636c3895362ff394af8acf794db1cd6679fa1906f1f2d7b27e0affc7f40f064ad8e914baf1e43f7a88bc92599656ae87f36ad74b409db05378e3965a1fb64aeac0157f8baf7cf57ad473b375fb749c43c587ee854f75d12da43d4744d154ee3b456b5489299173f038941c32537ccebc50f75479e99a10e89f466b65d30a5bfbe025aaba2235547433873e06ad35be27ba242179cc2ea79bef55da414b8e2dc0f556befc2321ca42ee25292e608c27e2eaf137b85c11a83535255d1bcf6a099deb042af79ac2533afce88d3a51cba793fdcac767be6c1fac33555a610e5cd35db6db34b2c4b08264bea227b11653086addd9bff80d5b389c7499fcf4127a10e436303903232c8b65fa54ee30f9623d0ec0a7fa3da2be5ed8079bd82748c832388184906777948445409fa07ca581eb01a9f0e15d9e0fe1302fdeb572f2fba8aa0006bd2050aa1589bb92a30abc5a54020ec569169afae9c404fe3c07b7f5d6db8f4c56377c18f317f0cd0634895fb8bd585569d057746ccf5797ac2139cae94e99163b4cd30c6f75897d53594256fa4fcf207324f1c04376443f1750588545a09fd4cd4d37d06fcbe284faae4c5b6dcb872f4a6475a059dd55b2c92800c8e059d3ac481649b4194511fed556736bbecbf02ca222a12d7ddce17de14c6a63b98f688d47a60532eada08893e4b940113b517a96a12d9a878bdcc21b3d3b2c25313a0faa1e28a976dee7a4ff7bdb66eab3c695a72fe4b7459dd042b6cd74077245557a2374b9718a53abacac265c4bf76dd4eb6d0d53f059563e5a74fc5d4fa0721561a8db174144eb4115beca12deb7c5dbdca9b53a3691dbaac5795f7d8fa2c9655a3ee3ce9b964594abec078136b0c8375c4338c36908b56038c757a9c93438922bddd35185bd764775c561bb320a1bf5df368361f5d31c7286fd85c581c4b57eb943636fdb98229d2e79866e26b54f5cabf61ae82766560db34151e04d3aff34a663f4309da8c0ae9dbb82df50581a3df32f1e2827d195c5234f6d53001bac96440bc717f33c6b7b6200743489430131a87a7f6c3add928833acf1f4a2826f4e1dff0442d7ac23544753539f0c53ade43187e448cd986265c86eefd9b97690810253afcf17d20c6a1416d1d8f1ad6f496a8d1a8c645d4f20a82a3fd0e79fadf129ade858437d29b261a3a970c9f4928a890bdd88ec71918fc1bc016b7d1de6f5806144a2f292177e21f3d046f091fffb1f0afdd132dc19c62b02f0e2c7b30728f4e54ceecc289f7e959546bca8ed9e421c519ea038e549c7d8ceacf92fb44cbc4e5069253f5bd2609004dbc4cacc5f43c439dc529382100fd4a9e87d20725473c433d85fbe6d2d832e198e18b71639cb3d8c238f16f9337a6c2de44376147e8413a7addd10472d83c0f26fbbf751512018b25ed8850495844b79f33c920195528b6223e7c5cf61cec74f62cafaf18abda574f82adac137c63de796308347b007bdec04e03b2d85a968ce889962f5728305c30fcfb9d1c3272947dc3ef5910b959a22986f4fd59fbdbc94cd48e53cea11dcd4c106b2f5c28ce19e84b3b794b464d3b2687773b368fb0788be4c398d4feab54590b2d531ab8b4b07914e3dffb1d8de2cfcd4ed73660ceee3e6a5c9eee9b5ba889d39cb183847b7869acfe222dc2f0eb6d616896e82b58592bdf09baabb0974a7afdb99b0244292b5645b79454dfdec78897fc5fbfcaad331cce15e2dd54161a792c0453d38c1712642999cbbe78a2bdca3981afbec354aed9b7aab8e044471519daf81f961b0a6893ef1ed8f3db3ee7c34d2263c650f2a6c9b0453a70039a94968936a4114e24f6bc2506df654607c91d81f9eee83fc87f569a6f013ca72a03281e035bf64e4d40487667a2bd5d2cc68cd45a14ce1ce92eecbff35e709ee859701bd990971b50dc862184c68f7927c6a87bb09b4fff6bf22a976f9efa1ced52b58a50132e455c4d6a5fe2c3a7b0a0f5c736509bae01fb18f2519c83443f5cd3154e223e2f8923c9ea77782d7d709cc137b6cb8a2c568c9e2d822218796917610403ac43ab69c6f2e0d914f966eddbded561f4537e7dc1b99b28624b135f4fbc6a3171534e346be3e7a8b1b2b32a86a521db01c0c1d479bc4cb95f588bfc82771ed5283c4ac6942f0562c607b46c8b397d9f1952652cce55e0779af545716c71f71ff21deaadce69ab3a69124167ea67260200b8ddf5f5d76e74c49f7396d24fca7214372d327acf036868a8fe1214abea9b2537e9674c124663afac64f9f4b42ca54d32f3bb1fb53f28e083c41352467aaa610143b4de8a996f735c8900fd6c2d966016d6b204cf15787b08927b814e4f6b25f95ca114f0e4989379de40e0ca29a51c28c842e28340a6ecc565a1b38f0048deb157a02029f2e58a6a6c338975ef120d40f62abc39ce19c8868de70fd155a5c2882f2cefc5ce72fb2c1802ec3f18baed77772fa72febd5f9abd5460cb8767d05559587ae97d27b58c4bf24f75c6c00e9d66cb2c6f4da1626a8ff0013828acab774088727cdb07a3154ce5473cd78cac4a9ffc5a09650d9590d5ec47efb879030e4802a8371f87882b1a4728a140e4c86b7c3947ffd4b436fa497373c1ba966fcb0d4fb38c2bb1cc091bcf83d35d2141c0e209e12317b8cc47b7b9682ee63b7ae7c6951ae72b2d62aa0900c4bad0ab9298e7140b88a10659f96aff2f52b07c5e74d086d217fd46b0cd7dbae3dcf513f727dd05a658f9c1dc7a67930b7bcbf738456fe64f7f45118792da7bf9c030da622747ce8fedd437c89b8c6273cd97f9ecc6cbfb7c8f15df4ce61dace4c3c8a7996590fe280fc06a6f8ed4ca86609f3ad6f22d7c7fb722fb05e27dd8b8ad41762330b575333caa12f0de35328fecb913e04eb18a009eff993fa72416d4af49f6cfe548605e4c49a5db0ce30296afd45df1907777cdc122437310c8d0bfc95a000de49e1a28c03a7a1cc2fc2a267e3237755f5b11dde1342d1d456470affd40cf873ad185865763c4a150dde2379cc0c14b41d1f55d4989d82efbec6a22f175dab793fc17176c622968969b6b9553b456caaaa676f7c766f5f17744d98ea6236206961b18ec80722cd3fee8a3386e14e23e3ef699b4232e71f9e081ee02ffc549ef3c060b1590f4f37ece9f724d4bb07a4f3c17901648a8baf8dbd174665fb80e2aea22eb8b66355d2bbc391cccb4b3222ce8f8d3fc04b97742353aa9507e17b0fa162ac20e5343380c8d2164c0336e746f2dc989e500fbf141749870ddb79397f411b1e98ff3baa2983ceaee3e0abb3b65386f0a9459ec35a3b9402e1a7f2a0ca04df3a94c0210d3a0e8ba09258dfce881016a1ae156d4e9128ad1c25a707dbd42cc8e82fa0e54d14aae58b6402268ca5f6ac9befa919a302c164c1e2ed786e41115580051228fe9dce484094ac7fef2ba7b25a834c500b2adeab2b9487895e7fb0e63542d12327f9a00e7543eb04b65cae422b29c592c6cc6423800d885d234f41a55885319fbcd48371e174f9a554aa8e09545a027be1d82fdd0b037e6cefaaf1703e16e542f8bdec66d3b2154f9f8fd659f09c27bb55053d3d1eb3a1b09218f093a8fa5a536dd71ae6a364d1a892cabba780aad449ddcf82269b2e4219afe153ef55d47033247a0e03b9c237e694aed73731c08e5374e579eaeb2e46ae9e5515c0a80d730947c458bf145e7fd17290b98733046891cabc9d795c9ca63109c2f15658d2c88f9a03ee028af36df808ae8b96e1a5b6d3c04423f19287aa1af98adc37b7ec8b8bc87f283b196f3b7ada02a950532f0623ff032c3fd14563b64fbf06810ccb53afa2fa23e1b68c9fffab06e71c5914dce9cba61ea6774ae9b47c77b37b2d5debb9fadcaa1f9f76a504dc3163f86c64123ff7e6172b3869c213bd47110fcda92181a8879848435c335462befb6f632b49b799d6dc3866821a6f55eb3427679b827b4b59be0bcea3b13f244f532b1e5e3344f4a1b415aa34db44d7ec13fc51207ae2e02464aeec2a8f1a81c5b7fb07fb5180443aeae9d21afc841e01592b590950892f56403e34cfad8555dbb8fd364db59f3dc028b1694cabde1b78b39c79229d3abce6bd5f5c055aebb7444e5d773cbb73bcda9853edf238944c4e8e48a04403d72c6aaaccc67e06f4ad74ff4521da09f2a01224a6ab7de83e02820ab1201bc090f67fcd43502e2efa50db75d117a5bd954c3f3123d970fa50171f3802572b162685c6c4eac2e5ddba28553b103c0e7f1caf9d0855d69ebe9cfe20c3af8567e71907443f30a23bb6b7eebedec7ab05f618c19ec3996252b2e83f16198885e960978b9f8465e6cc84738cb07e754cc7fc1e1a708b2781da1e1b550f4c3434e3dff240f54f22b94608040225127e27d4650457a8a7fa9eb499c4cc4867c357eed13ee585c0ba6f705cd44b8ca0d769a3bb9f068724d2ecb6e2b0f17f1d43115ce6d027113972c4e089da4a2a5e70832e5c7a2af92687be93ccaf46e1634800c403c74181695c98b341d4baa7cb990fdfe90107ff2906a17af0d8c05bacb636fdeb2d64472fbe3ccb0e21d3eb40ad757e46d2c37faf81e7728f82d94fff2e9a9cef6e4486e5542cb06319c8427f1002f6f58df35f60beca68bd7321491ccc780c8797143c599591dc00a5c06fd4ffe33d6c1c074b9898cba03d052cde3779afe7ef5ef8f10539889bf146c77e2d6e06dbddc9cd7f88014b280c03d3a16a66326b1e5b3ef4008b5439d10f586dae68ef29d1ed84e936e2eae6e5227c5c25cfddc9f9a7f2c31d92afeb0e5ff1669f08b6bce40d3e43e48e6317aac33708d4a5e4dae49c7d10c1898828d533a0344e1c94a6f49c62e823c35b9ac512834600358375c0d1a6a4b7828c6e1e7c9afd38065b4bcf4486260529802d34cf7b0d9cc5f7070b525a275369f9aedd44f4d3e8d2903e2196a253d3522d40861bbe2efffc417ba66e4d198e7dc608ef7c5291661b06c98e7ebfc824bad3d1c335ba09b8d138acd31dc22177c3d7fda0b43145fd15228577c3a12b013b990374b7bc3612658e9d580898dadee17d90764fbb3a31bada9494a116d8fd0d65c0077464056a46ddbe6037c48313f4b1e189a277f6018f213ad07eee27ae97409166f40df06e540abdc2cdd5ceea4268c6e70b51351b4973372ae0e4ddee439c5da5ffb7619ce3b30e719a3979950e72903136b4aa0caec4830ac590d15d31034588ff8ec80ec9e829192dd75274bb8f3208089949dc4f7c02be60bbe266d1216c8cb3d112f5ac2634bf096a677842103215005bbd9831cd7240096475cc81646ccf4b709c4ca6a508e52b6f2d3254f7c28303bc6866114146956df9f2116177f89939929e6c367760e4faf095cac9a216491b406ce79eabb0fd2bbfdfea31c47729bc98afa4bc64241a754ec7db048c11bceb89bfa940e0b778a3f53ee9310c091ec2e572595e9d0f3a5e16bcb410c292f38781267c064af8d06c5db43dd27217695fcff5187b2605344f7b258ce0a3d3248896adc2cccbc28617a516f072b48b8c5de4e06a36750a7edb5d4c74b8399b4ff1f39b429d75154a8e3b7737f728fdcda1517b7dd33b2bd955c9739230340612e00b83bbff1ace7b1d535f9d8fce35c38e0423578c09e58010fee3865d000ad9769289553da6c4cb105f81f6dc66df36b3ed43958550cecbe9cf75dbe056370b70f603e18a2617e00a5bb5562d08a6009585d3a75f2db900da7da7aac4659967dfb7f75a0a7ae11cdb3960bd82d9cfe3379b7baf790feccf8e6da3726e2a5289b68a68803153c3b807b44fa3f3ad505fd37cb6569ea3b36cf7f4a4c3a4cfce7db3899622614cd21065fef12562879184e6130daa5016462eeeaa0caa2c2bd3524052c5decbcc69b5d65fa5e4e4bef364461c99b7eb39992094c896c372e18f179d65600f13ff40a127edf53d36eae82b5130644b17215e788b59225f0e2b3cba48849b644102a1e94f979ea6dac9ece452432f2703e935045d26da8633ca980049f8513ced751d4cb079de8fcdde3cb840aca2d1b4ff232085b34c60517d1d0699f7c0c2e5bbb19d5a742feb5593e00df1622b196f4f7dbfb07f27d454fc9a1dd382735361fad0d1c0684df3c2127b45112f9ede24eadb95cbe32aab66579d2cfffa4c890a571c1575d8a9cfc5cb4a5c9464de56270b80a1382fd1a3fb0c0e5247b64fe7b3e05eb2240e6c6592b3c9edd5a0496cb539fd1b03c964965a6892bfbc0cebeff5ea0adc8695639086a9373f88d1f2b57fa00366d9b2a2a4e18761b5a6be450c0709918f398dd03419a863b695a9b65d855cdcb303d37f5b2278682d2d7e4a1b1873a4c3be730fcbde406c5edb203a51999822f31690feea124869cb871096d1e7cfd6a432939f52d99d3c12b5333a63a34b2f20d66f5cfa31a96e0c3dde419704818a947ed98ff0ada783168667fc0dbe490ff876c164650e490dcf17f71d3f7b16c9423d6b935d0d9c4c921291e4d86d510c3d08b1d54a916b517f07d85e9e42aa0450d76b0fd5aa1087758f2dc2d9ec497b1b8ea8a63c49f609876803bab270a32e10338cde46fc5cc369287b6171797a8fa481549f22577932849eb4f70a5a6561a3034f5a7b8b02997cd93b793328c333cd005f4e1de98c475d49d7873fc15139cb55c5ea1e851f9a2938b693317158c58883cb0a3ae10d010325edf3cab20863f8ee5f2dc71fb002a03a9be184e1d46e9a8e850ee1e729bef902605187ea883e69b4b6b72b7467dbdfba76c9a05f835cfa1cbd5da58f6730417d5df2d50d41fb098065d38298ba6c49ebf97778fa6a7b8d2663dcab77c5ef7d14e0cde11f991870ee47c37d12a2c1046d0190aa0c0767c5743b718e35a0461f2e035cd9b7136627506a292890e9a3b6ecf670508b1174a00b34539529553427618396529c2ba4ba71ea3d4f09679668a678b0f6cbb410fb91a5f2efda46ddf8d60abc4d248576073270596bc515bd754da9a5afa4f1f0a169e6a704f069144244ffc07a924fb45dd49ae3fff0ae46af3a575272c07c1810e600ee81c9ef1d95978ccfa32dc0dbd8833bc9465a6109c976b799cbf25bed60592cf8ee2fc2d17c9dde8047ee76868aca3fb04a7f74cd34ab2571db64fa611489d47d2c1d3fbea8c23e8c545f0326e6379aa386fc844aa81b2878a7fcba35e0b7565f60e776a15845b36a7beb50987c63c2bc14cf43f360a45748b815d71d16084f22fae128c36df902f96d32b8bcd888c6bcec4d1c5b828686d61c90be88ecdf28e2014b68325cf903d39c7f5a23688b1a89c6681263cb0907a2560581f0755d8fe91daa1095cf206e814cf46f37fc5f655335db90838fe15660b24e5732fea39c0d2b0c25f05e26243d0cd22ed5354a30c738076919cda488281fbcf71bedefd193fe65b5d678e8058071f5bb01a760f242b9487903ca720a28f743a60c617005867c46ed29bba6d2cc2a4a2886c160dcfa99fabbe0f9ea28b7e27c781fc404b08136c3a99d254e017cd5a64d04752da969c4bda748023d6dac744ea73aed822ee95687e4c9a1054223b495ead3e535ad0eb9896a0742dd0c0e52d0fefff33003bbaa57cff762fde2310b8034ff3de7eb7dcd751c7c6f8f59d6c5200f495c0a48c4c5bfeb6c8217917d8b78c51eef86ece141b20c3de1dc79e43773e86c7bda678d0b39da0959265830ec8389043e6f61bb6b65235106a80aab2ca2bc4871ae35dcf5aac4c6e6b46be9d7e446d36822566cbe3c4abb8194346582be108e42ee5eac4c2f9fc0b2e6fa0328f232b178b27f5ccfd09ecf9006f4e7ea8129ac0af34663b9eff00b35d2ec3d4edabfe53288d95763905608a04712b4ecbc0c48e9f87fe7926c626e9b642565685efe212f05c237db7df55cc1ae3e21f3e1c82632bdc9186d7504be943e7c7572b26fca85defe5ca3248402402ceee91876fb02663f1de174c93bfe942b23dbc04352a9dadaa738d0c142b7059c7bb754966b622fadb60418c4ee2d46cbe3e51eba0a897157697cd6c27fd668683e4fbc40480529cc9c26adb74c4944f63bcafe1d067995fd986f0b1e4d366b8167b37fe841002b7e24343b5cbcb141921ed03926566c0c426ba8e729ba8ef338fa3df6eda4f39b5f955bea2b550d3c43925e624e44bc57dbf289b82dffa7badf42fd9753c3957b13a1cd3b7896fcc56b349f08fe06e3ac2678c7f958300f0d6c6ce21cf8e1be995cb4edb303e501adfeb2b430ccc54c3ed4aa1f24d8ef5d8762ba1746fc5bbe33efdf01c15211f6846c6e8d14c5cf92a696682083c3a8d1ba12938c2f033ef425da05aca39e6c85ad433c9b7a38730d2ee09441874d6aa2410ea0d5b898eb8ab00314a8e763d8a82aedcfab31aa54046cefe9ea90555a375bf7cbc5118fc98de55f70376662bfc0cb5eb29ad8329356a1cf127f0d7a466d29b15a60d54d6ae9f5047ebc51082f409afb8cb53ea236ee196cc7d67310041a80575411d2b9fafdf5450a9ff76816d80c118413e64a8b5784c3390ab4bb3f720cbd89e69dc3c59bce08298cdcc372f835e11520401712b75bb4022910de15bcc4edac3faad18107cf32bda9598867012df52e10e4f8edbd05b7c5b6f6c72b18a2f5a79bb967ccd5a10d301fee18ec1b415b57e75d1b0ee000f5acb2afb76de8c7574ebcca30788a984d595f5c8c65d972565951f0ca573fa789be2206c5c1329b611ea2d13965e64dbc645c6ec7f35a223b926b1cd58c3d134176e35c7ee0e5c13c124dafcbfc4e735a5b1187449a31985f238090d914ccfafa6a708965629ac77b823aae2ac40ecc59dee0cf4e1055194f7fc5ba497b282b9f09dc80103c4060f53d34a7d22ba72d51647830bf041e0d0841c178eeebcb74bf1b01cf1b05ef61c2c6ed9f5c30dbddef3dbf21cea77e342c84b989e4a27f0c5d01e3e8545f5fbd565efa81f1c30a2b029cc73f8b00d1ff343912b63dbc6e62863f0491cbc762d2f52f85e488d0327efddb1345b5fe9f1781a1ee6fb437d133e28fb50cd86af933bca7d5000acb9a7b66712c4fcf321d1ce0dc4fdd726e2c7b2aaf86b95a443fe52f40875e86da01630d27b6b8d8b2da0f14d7a35b299bd800ba64359b3d5b830a8561568fda604f1b41fc5916a83e8354a8774d5d1a323ade6e330d569727802c7236db7ab836748766321150cf355e158e39aab94483cdeb4fe987101d35ec561644cfd19c7e37e229bf009e7dbd92ac64c6671bdaa3c7cb537fbb1f4d7c78d8861650773920d24a53556188fc5440c9fcf667e67b394d367d0f919d933567e598f34527c3c185d1d46b4044e7d0d0f790d9db7e5b012ad6b8d2cedb470e1e8398746124b1c8b6d7aaec7a567858e796b4291c8e87a33d7bead051659836a4ccb7bafbba69cfcc7e44b003774b0e4f729f474cf5691fa87cb53a36e9752656c586bdb8cb4021b8a42a4661194aa7ae03b3bd5190d93781e85f9c7ca297f41da18c25b3e5bcaaed2dc9571aa8032771277b0cbf0a2b3ac7154e7c720f60a40adcc64bf14407fd0ff3476df7a57c31c00c613d8dcbdddfab9b286260a467d72306fb668dc698ac463f801024805f874d31a0a25a30a47bc2af85d1f3a94ff760adcfb6ea313c276366b41e7413231e4bc731c2227e20b6093291653268c4d7de905b480064dc38bc313df06ff432763a0921d1ebdccb4f4e7dfa1f9582c33c6ba4278a5369b43dd35f5c4d47edf6895abf977f898df92f6d7bc89fab7ccd5286ca27b71f45fdbb0f6b07b868a3b1231327472aa64391f2d3398ddd4ba8e43ec4415ac93882614b2ed4e7847b3b4085ea34d35bdebfc700a6c5efb08281b6ee1d2316866cef7d28fe56922c0143837cbff440a1f74899517a20bb654a505d66741e3f968cf552d889e0250cba53dbf497663851eafab5206eb64b9460bfa51c9e249cd66783ef2a5d63c081ab3cf6d001b9891266c0440fad37276121ff5b5447efab2606d73dc5ffe704ce8ba80046d24155451b646b5762aabb8772c4eaf0a7f68d5c26004df416efa78f5494d460af2dde839e91383b04941d3a402a271b8bbf25f88f8c0833c956f181837418d6b4a6529082820901319a151a3fc3674b53372e8dfc2660a3344c200b48241dee342289ce64990b7dbfcadee748927ce3852ca47942fc4194ab0dd887bde26f11227240e53623e26b8433ae37a6b9b3c0e1cca81c1914c9b0cca2000201bb509cf406d28e1cea53bdca28e84a32ec96a032126d3003b873c903df4c1df98f6b27fbaa0d7b1c50eddc55ba4aa9bfcc6281d9e26300dd066f31ce5319a8bd57c2fe129f4fd882d57135766e80e3ca44417633d27a7b85a877e73981e7387efc49adcfa997791f13f461bfb97a56f35b3dcb63167f2d42bfba739a8f19a6e5fe20e9b51313a0e35b2ff817d47ba941b485d71cbfc3f3002267fafa3e479f227e5e420576669d1287d75c75d9d294703dd8c748bf6b1699154de4276dfd500c789578b0f54d71b665f0a10b10483b2f7cf38a6f385bc5945deca67a606c638f763e630e0fb65a7186fccd6adad042fb80c807dd8793967c0ded1d4a6e9ab93f70cea0afd9d4e0f8c554f30a8ad58bf0ef027ee90d318caf0e6ab1ea03320c57f2b5402a9d7337989c2aee694b0fe711447618c122665e8cca6bac8c02c030860c3e4656dbd65773cf313a58b70c92fca1c4de5ab1b3edc0b6754007a19797ea8469a8b947d695dfaac7997fc08174db5452c0e79e8fb1cc7617dc64b7e41a41fea7e3a9827d6d0cd571fb9565d27350a03cc0cb6dadb729d6977b507413a227c1b5081576277e72dd23b029bc3f7e657f0ef79cfb61ad2d29166385f529acb0424db46aa7a820dc14fb9522713a1ec454b47d319f06ca78c95aa1810adb13ddc86c7941c4648c77622f05a442571cb73533ca93708fc57069ef3eab56332a3da24b905138837da1cb90ba1f8811e1c1f269a403060eaa90164f8c3746b861b9af4d9182055e3524732aae0d8b33fe2c2507f7f593996e21b7cad79936547a172eb57755ea7a150659e16f3cde793593869b3b94f497eb30dfd8582b4b8de0252338e04447f1f23f9189548ebca2dc41f3de136433c4fbf819b66019517974b15f71b3aa0085c0f6ae9062efeb6526aa374ffa4146323110ddf7d569b63d67d140a107b7784347e57ed10b2a1cce0a773146e2339942d9d00e2f5fe82f3b8c3819af30d3bde1a6f2394315825921c11a2b9dacbd4024395403cb1ba000e32ab4248a4cd3cc5a427646c056e87c907e934b31c4115cc147f518607bb6cbffa82f4f1c447c884f6a89a579fbed8a46326a55857c29ff1186524f233039d65a11faf33bfcba62997ab663889b8231f428bf417d02213d776c81d7082f35c0990a0cc502598952ccbe3de0729bd38782b634aeed2922eeb6b3bbb6b0f87e9d2b39932367df65de37fe2778e49dbf7449e4169ddb7ab43540ae4ae00f493caada95dc88abfbc3f2651c4fd24b1ed30ecb1735e65fada289ed9e89740f9b6094e62dc475013b8bcb73c8b9053e906d9e1ae6631d4d2c6894f92d0be04647086b486ceff041e57fed0c8e25bf1ef3f6a8803d977ec239974ad4a85b65c6ca1244f8d52b14e994a3bee226fd5a985bb2726b159048cedb38eda6a2b88b01b3f8b353154039bc1575d112bb8785ce1ac19cbc1ceb9ba46c9c9da6e287302bf8f028c7936bdceaf92b6cdc007262d6a7aa26ebb1bc5cdd618fdfe3298a9d72917147db4e80b364b08f76f1c5e90f8773f5687a8c7eec2154c61c1638d0202561d2e0fd55823b7c4286c7c61de845c0e0043a1a05a367a5f1a59fbe2831d227cadec46578c966efe42e0a08a90c1a51cf85aebc6eea078fb73ea5053d8610ad517b364fa754714a2cd5f5aa483c104f06157ae0003a87b07451c602d58b7099e1204a64f7bef62a305a6d008be2753d3c7c0b1d0582425a82eccad131d3fbb199f965fbf40c4b643445f9daad25e9f1aed2d97a26cfa6b584f0a7e401a6ab12a8ba065e9e5beb1b5e7cb00c0b2d80f1b0cd60b9bd4c6e3f67851a11863f8e1ad1e7016821b92fdec853db1c566734b5015e96ba4ee5a14b66a3eefb00240aa696c7524ae0af5baf7763dfeeec51ef80e73a0c17b68b23dc9e9d7f19f9e4e5dc47d1b89e88bf04b1e980ffd8e9c2ade7ed7dbc4cecbbeb520c018e753bb700ac24e1997d371a22342b902156a66c3367f3fd304452694496e7344457ccce31214f6795b206e849def5621405c0effab162ebc877f1e636a169899255433d7c95290d8d28c170b254bfe991a458126f79c42033f980d67a897ed9b97b1a23a4dd7f8e5d477fba2a803e0ba15e2f4d1703b92d15ddc67e20bb1b57a68a469b5efa12935b0550f4c2b6df39529b2c36278be58410536df175af3e6311dca188c318b130925dcff5f50d2ee4b8f76106ecf8c65586993c67b7391e3694b389323147983cba64d21c0bad63390671231e21595b69106821cc37203b5da9cdfdf560f421695302a1f1a3132e108d913e8a17d074b2f43752cea744e26e29c4ea6c67caaa6b7ee5cfeee02e3fc116e446b9de183a284ace2feb247c30518566768782340511756aa67891f9ca4f1decb4be4f9e8bd79f38482410c2720bafab6b9235d4470f70eff0f1e44b69d2cf362d9098b719fd10d89088a7154342e9fd8b7d3b1521b3b323e52aafd6c0a3d1f4612d3c12868009cfec5198bc6a84122732f71f0de4aae3302f5a7f7c8aa312c1f2e29a5b26feb879a94cee5dfea05c9a51079791b48a482309a1114be29b77d96bb194f947f69e37c24b8be9acec0da195f9175904920032dcad1cea4ed75dd1d7d41a1102383a66f7cec64ffe25a9fe02c008736b9f193ddfbde763955380e7e76239142d70237adbb6ad1f180c1d5854e7f7114fa0de06939cee9bfedbf654a15d39b3614f0b55f2219e329fdc428c0b6c2395dd948f1d888f89a3275cbec0bd7f3c6af67eb021f1c7692424cbb2ebad4326bc164351a03df05e3083092fd0897d69b8f9914615935783349a9772cef3f42458c7a76a7ff258b2d9a5527af35ffb06a772a1a596eca5d28b7b1496f12d5b5dda5729bc90ee7ee137a705dbe1bcd6898819b69a9d273eb32d377a29664dd283bb6112a7a2e6cf3a4272b8d429ca44db44ea0f6b973ee881b08f38e3ecbee58a64915dc38f90aeeb11346c3876d2562a123d3f8dc975a0fb0d5178a3891f9e4d12dea81c535e2a419c50fa54b46b85a7e6a09b47b2951463ffa7297d5817af9371e34491b466bfe6301c7dc3861bcb2ae9c8009ee7e64cfd532de76c911f94bed500aa945c674fac22abf2677e4d2b15bf4c59819dc49a63c26145c231bc97d63bdb859a7ce25b1ea67e42795a8a0c8b9c852ec4de3d6ab7e4ce3624579fd2935616c51c2e44bc2b4834fc23234e8b0a5af1b7149f4c181163935adc990af64fb1401f240f431806c337423acccc97701e2a20f08bc63b229955c405a547f167365cf7f0c3319659f3da2737f0d87dddb170ecbbf5cea183d0f8b17ac0292534d9ae0ad9183933bbf50015a0a88155c635b5f34cc95b28a8944383b545df2d9cd4f8530918fbcd99c268533216cc61bf2301693602df4ce13b764721709dcf233428f20783021fcdd4d7f6c3515f15ee208c7bf5c626ef91a27bb6bd8f7d1abce4347be24e8e5fddd48c230c1ddc49da6ef37a13eb3f7583ce7eaf6e50d704101d037172067c9d96e2ab1f62f5230195e2b0cd3cc522e97159e401586a9855cffbe3a5f06c63528627f98f79b1a4537c15549adf9e355a956c12eb0bd78a11cf7dfe4e39563375317ae8fd7a7d04ab497ca1f5c43a5d0cfb0910bdf6bd45469014f57209bb235e7858cf9f5d4655d861b685d5f41fb29d59814b31dd7a592551a09b2a0c3bff7ca3556cd4561f2cb67eef12bb02522e154321d692ddce9719093009bc30699c98149d235b55f84a5bb2d75a571d9de14d911c8bbd7b66f6486063e256e2b2024a8c7b3002b3f6306338e86e0b38a6210ffb6496443db05d0587bce2d813a52f85cb79f98d024dca5e9381b318e8f7c4642ef09c9cbfdd626d2114ac474b18f75f6d54e412bf18d3b773c0b7840fa57df6af5add2195dfd1cf906934dd3d207746974449359431982931735851f7f86db899647939753c4793ff30f12157210ffde4f4a089af5ae0868b4edb162f8b68ed2c87a188deb7c1887579359fe7b7482b5690de59e58f0827df998f0e8473eaa6c4be28bf86a9589672d1a94e8c908077842d113a505416d815bf8c590ece9fc0a8af76b1c373be09272b7b3b1d4dd4448d65d6fc3fa6c10dbc59185f4c03d893c24ca478106e2cc0dade21f7b4a0fba140c45a06805003c9918010b4a3643dd46eccbbc1d202d00125ec4464398e82912135f865cb3a785e643a737cdab6cf35dd1264a361ab992b692345c3b63808221088560a7085a804190eefddc30b2a56079c8abac220d928bf528718a2a85b6bdc58564e74fec2a9a9be3165b288dd64f6a51f1d57416d0a3e86cb6f32aa53ca74a86eb9fb9fb16fa5da65ae2c84cf118e60890328123ad3d5cd46d35ceb6c9db74cd3e58d5530056f8903445b3bf3f4847bcd67839a4651d7e03cfc9328c80ebbab18683117ef7247a56a5652cab1056f3ef7fbb5d3a29f65b52596dbc15a632bd271ee062691a5ce0b9c67e703506f77d73ae28076ce9883a1a6ad6bf364bf8dda9261b2ec7444ae361b19e46c17279e5697bf022aa2629d5dc4346cd7d4ac9c55fed1e8f0991404524f0245be699be85ba15c268505088e6fc59f1a92bba5143ebe2ac2c0a98a451bf6610b3123a2e4e2c220487408ae59237d60021faf593483ece20aee026639d3f259c9bcf25b4df2949af19ad5deb23217fc2cf8ad07f0f54da018306a76cc8a53ea3ef2d5eafa16ec5676550f4b448640acbb6d942109868e8c9e74e184bdecb0a1494f639fb55323a7ea574f8c529be336d1c585fabc27c7cb0863fd05ecb028b24b276edd0b15302f293f99c8fd2cb1eefa9c8a5c21d9bc81bc372c04ae25cd9908f17ae27246c3c8befc94fb27735dc34f42675ff745c5869c2260f83eeb27b73a478b638a49f1104a49e9545396b1634623f94ebd72bc0f3362725cdbb48137816f2f87ac369ec021ba59a6cabc91da31ac3394621ef849e980ea92115740506236f837c4d907452b1c1174b0c736c3ee5a741bf846ca41888bd9711515e6782b0d4cb1a96f406509eb0426048fde1ecad1e6e13df426482f75bcd00914824134883f5da0234d46d402ce5184067235a7a84453eb2100a955b772e3a7d2a8cc299d9cbed30e1a4aadfe9fff423acf5dd84e22276fe3bdb0aee94092023bf8982c7c8289ee396da240cdcd3b63a16e4ecb7c53d153e5c17464696dbf51e0b46e5d6538201eff2ba130a5eddf3b1606ec2be7c058f33f936ace9cb370dd7a74d2833ddb3e15cac4f7a395b6acb7855ecb3005012d3d49f69ad4d8a94b33eef631e44d4ddafc091d3418bf445cbbaed42117257f43d506b4e4cc55010b62bd5016512cad8d99da133c71f302e92bd05b0f2cb07bcb7716d44dfcae18c6360717c03c6bbfeb6a12b81c823903e0f66755c57eb706b628a07b416d2fba40ec22308799bee368d9a8b77cdfb5daea730b5b56d9cc6f64729c83c37b8e907fb232352c82a26acd8c00a0fbb5c83e58b5678aeebab9ad8b958b724df5b647f85eba54e1eb723eda89523b31a8152228e3d31b710744eec0a334be31f4ac45d54031fb0a831e96596d1849f7fb14328b2ad316e54f1a7a18ca73dd0c7d8442e40882c2284b7cdacad7d0b2e30e695ff4bdaede81ea7b165e00344f2fb27259dc845b51e14cef8771f0e6b8b6596f5e552a16a2d336d069c5bbf0a6afca8d107fc2a7e8ea76a0062e8ba1171e82b658b892fc0941fa37519aa3be0ed781053e687e12247180f3feba8151a1f54e4d512804daa6f8a0c71bda80a5b022b7d6becdae16c9f6f8a9a7cf12976d9864b10a7ea15b1226ba5c36903a92dcb69368a0fa742695f39309ed52c585750e82df0ad75257bb37506a0016e8fb5efd540988cf05a93aa2d53ef019869ddceb0066a3748dc1c9f2058cdda52b85b64e0a70e7d2d386710ad80f8e020c7dd0931f713b1fa0bb21e30a3613c1e633ea8b297d73592804de1eaa4c29857658f7f1efb942bf96ef1a51fc90f97ae37754fc575e98c4ed4a170acba46fe052d48f70abb9b1b1a58ded0ac4bd5636ec6d1e7073b3304f1d893ceb4ff2b952e5f5a27ebf48f1b2dde271e63eb2cc9c183530767cdb7e88aeb48b6e6fdbfe1118f939a3c7feafab0ac7f7c5652af534ad15ac6cecfa9c233056f45e1401a6a39802a7ec0f56209af3d10a968388412ee0b73894869f1f01e4bc45351b0aac324572d0eaf20b6330ae2b42bc1d5e0d12e850aa1121a436a7c28f8b7ad062227f9631e271e41fe5aaeb407b093bdd9db0556a6472ebc9a72b1f0426938ff858754dee136b99205db02cd05eecce965aeed5ec1b7dea34df67b18ef4a5a204c3d36479ed747162cc4d874a07382e1cb271f249262c249e973437e84e19757e7b73f550b51d5b8f6b7fb39d7b81224e603fe94f549d77abaf75a29cca246f3ced62c69f8d77d35d49761fab1477dc15717ae6710329ff00d223e4f94d3f5f9f971281855efe417fb42bf9c9bb5e2187629528347b35c2f9109bf6f85d70ac90a3bf3fc68a3f2f6d05402662fe79d139cec84c0f24ac61de91e33247fc4a55c0c7d24c9f94be2a7cc7878c8c12b03bef10c08844c8057497d96596cdd352b9d7a7afa65983c74fe1e6ccbe7a8c53cfac8ec0d47337c8460d6aa7fe040abfd81874929117c37550d2f039014c3bb7710d63e0c57f5cca4ffbe867a4122f5ffa0e9eb08fdc772d3680baae2789a50bb172f9ee837065a682354039790ad45421ccb7c845d9455577f5d07fd588b2272ff62b701170099dc8c882d5de7b88d83cf09b0038ebceb0f4cbb36cc5c71ad3b1e37d096b5b20a28201e0b85d49b8e71ac1971a159df8303685e8ba1015b29b4ee55f255d478456e2fc63cd6e589dfa4c973f486b66934734934bf4848368f5cacc84bd39ba486e1a109a00dcfd14e04fd361b189f461417e52ed7a997857690e305a8e24d37ccd65ebac3eafacf394bd1dc99c1dcdc9ac0132c815607c8288b52edca8e79fb6b1feb4e575c0c8794bddbdbf623e365e3a5108e33066a8ebfdb5e014a23718ef98576c382c6dc521f20b31c129c3dfa2d19d58152c04958619273155aaa3eab6a7287f6e688cadd32a854c02fbfe2523540ba790641447afd8688066f72ce4f2f7d902f518ff57c3d3314990db09eaab06286e65dfb088ac93d519ccd7efe4a3d446ea2c9122d05d6f48bed22f1145d1f0a706b35aaf5cdef7faf83274b8c377cb61e4ef9e555c423f9392c5819b9b5ad0f5ba58938d8825e759ab46c97c4762e006e6e89fbc0388e0218b76cc3485cfbee61241e7b8b59c21807b1a3657b21aa90551ae7e7a1673dc3a11a6f98855c8849f8e44586cf02ff690d75c32c7f0442e946f02c9d8cde308abb5eebef5c18828989cb8fff047c72563182b9e58f60de91814856844c0e65d725508c29424b7b66379196c2955eab0fa3f8712b86e3e5894308ef5a8c61f9b350424a92d2b96a12212e4ee5eae591daad70cf5c38e733e9b4ea52b99e1427459e7634f3690e1af232d6fc685d3f01556a9758c088f14b7507a7a1cd83b055814e2156aed89210823eb5769692b49394b743121ba6eb2277101ac83c09","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
