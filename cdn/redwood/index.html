<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c89a07f30d4d1cbcbbfce643ba6e02cfc5d80878ad67dcc902241bc33fbdbb03d3133cddbe26c10ed0d88f52e690acd6406ac62b0c7188b577330de504b910912f27cd22ef4ab09a546ed84c48feb90ddc1e3fb82376d09ec292b5151b2a975cd101cb8764493e8ba578b07dcbbca033b2e8063d96715cfc798d4d59a8cb0717f33b0866bf0506d321a6cff677c519c33d3991413aeb3d82315b105a86ee255ef26b8395cb16602547282bd9aa01157b3bbf3cdd2e346f6f49f522f6982582fe49c803d8a77bdcccea4d064b45de3854aa2b79296b22f341b8aac7a54d1b8fa7e452e27bfdc3b4e73e4ccea6ed2ab1c1130ff08587424a14455e05dac832c5730fbdd556957218ec571ea8d4e2ab285745467d81e357f48eab8d706d1234bf407aa98ae7f027ec36640d2e63072b50bc2cc05899d98556d8d63260b5fa9dea84562eebe87bb6887260c584bc39df9a18d6b1fa61164b93f5c25aa4bc3d31fad8e470fb4c7ca69dc32038a558132b8e25e15004f8d00a2b6a007d5654bddf19e97bf6d185c209145a129d53f0b264ecc4ea6c1e0b0fb15e49e7ed43e79ba60458f7efe83b02886ce0abe75042b3b9ca16cedcf73eabea09c44a8d752a3c938a72d8be11cace2f9e3b034ff5dee964593ae98918d66adacafe40525998ea1077356607ec9fdec90a4db8d85f7b9f96e93fc2750f88738aa1a36aebce4eb2a254d7d7cca73ac9e432f82d4b5d2851a2d66eb91f208342e8b5fb04743e379e6c762a014dc16f9e20e919e7b8d28061f65b4b851c80727c083a446c0f78e63b2e62553f690074c91d2347dccd0d74a2dfc531a251a610ad84789080303677bfc446a53922abe4816e02560a6641680627a60878f07085897266ea4849d7c4722cb8a6eb74124828ad67b87f0e86e9ce2f06be866a2755b5956b02b28d2d5824aeab56f7b09470051af59a2f4099d04ebdf338e6cc1ee1623e55df82a670c807d009188b700d1a48a03c0ba97677a3eba0727abbf018c56e02fa2bb2a5ec6a7a8f71658a466dc9507b6954aecd35bed68edb563baeb6cddaf59d0b454f91faa3b3b6dc8a1f758f5cbbf07f0c34ac065d4efcc4434dd64d3c9e17ca97a32ce55aefca4954e876a89543536228c536c1e86de8162b6cc4e41d8e7cba9442ec654dfaf1bce227c9f49b111c8f7f6a7ca3f0003512ba9daab9e40b863d6faca6c4fe2420e679a52379c8422253650977268b7ee6288c4f530a183d7a24a5c2fc30cd6e6f1613664cb3b67d7daae553c91d555e41b13a00ad5f3a20791947c61772fc2f86f1ef10b7e79190febf73787774800691c469474586d4c705a96e6abf3058cbdbf9c20011a64909c82e07961061686e8060ea205277c205dfc1de37cdba7b7c1d7878c6f3e0766ed438e4f0184cfc50fb7b478508f1a5304e2a9c15651b797f2e0dffe024cc08b9a127ae674ad8cfbf784970e649ecacf6a810788a4f4a273bcbee3ff252d8298c7b56136c980bd034ad144c22d48282a2035f84b79e55a53a6eea1a059ff4ff3a1c7479f14e150d2a3b3ba882242806b6deaa86e287bb4180e4e85145901c7f2c663c5dc616d7e6a6c23dfe0ea2c51928f76f55c47a065a22f588dff91e6d684ab8b679bcb5cd27bcc07238a5f8a8382654cca5074b5f3fa4096d0609305c7e8db1782a258cdf739b87b3f4b1e1584ed3eb8fa697a5bd57ac925e3ea0a6e741eb7d1f2057dff9e9834aa788aaf4635830164f434439b21614ced1dab2ced65c9eb11a07a5caaf62230abb99eece5e763fa55bdddcb1e1d06323c3ddc40a17bfe80bc4186ec0ffe15f2facd1d5d1264ca64fe0685b31c9082b213be0239d79ce1df096aff4f1cf6a21d542c547a91016bb28f53728ad3c0003757266a7e469c21bf7893fee150864fd0a2d23867e0c0e1a07e72d62f6744b8e9148c31f5d0eb74cefef128b9c569a091fb69a7b073e8ca9e03085a93b753d3c467d56a0eac8004b0a118819b38da97490dfe740d6cf830608b77d7ba152dda42b3430e2cd86d9302d2ffc0c284f2ddb83dae5fea570232e9420cdccb6e0e612dd58b73706aef6a897c785cadd4913621852399302d9c709574f3fa9dbc54f0f5d901e481239e3d3416c563fb6657c39463f4b1d208fbaabe25d6391956c5eb0337b950be93d53e056a2cc4e5cc3f03f6cf0ee0eb2c9248563c48546aefc045eb134a4a62df6dcee89790e20e308c4fff173451a04f9775f1408137e270d83a6cf8ec9398537a7245bb2b9e63a22b1ccb96b21bff66650924743a714ab9176939c824ac7cdca8b6236492db9d274c94c0f112043c96a46de41e64be0b1a964ff62cb5d208cde18f7f7af8fc0e94d973ff3dcc1718a7f9f85be590e79740e0680b3d2ffb2ee4de09c8921f58bc54dfbb4782bf59a152dc9e142318a00a9f1c16b4819ec2b3bd8b90c6bd5534eb73afb2ae669e77703721bc80c22b96e0fc9791a6db5277ea4f63de0a67577c1ac753e72fe1c88ac1259dfbec7b73ede5d52d65931db36cf9bb15d0486680625498ebc15182f3480d0ab05f9f03b19c090b79be2a0bcdeb697286330358d33155d7664140a4596be057e08f6dc6b6b55b5da671c1c7dbc6a45ac207d0bf638a03f4015d60bb2a378316992a5ea00442d9902aefd348badf6bd6ae375e1993c1aef949a299014fa43ab9ff8db929a4cff07d582b82b90e362bfabdd02bc9b0608e8da4c27034671bc3093f90488d91fd3201bd6bc4185a2b115e8156f8af376345052a9bbe105b6b55cdb06b5845dff2c0addac6ce9508cf78617b270ce69866fbf448f8211253e8d195fd9a6b3560a59579db3b6a1f0375a98cb0d7c1d4f71b558004dd53f2ce2f8024665325e4e08126d8d030c28d2a486c1377450ddc9762f4e47d5adad8ef4e2162f4b7bb70e98233ef20f91fc8b0fb96a55a4a48085186a7dabe952f0c9038ba7b7219a7ade9e373a8f3219a026052ff12af17d3c0e00ef2db3729129f6b07679d0a3c8ffee319ea1a0b84f519c5ff6576bba5d0999dbebfeefbeb4c6244a8d6059721a64dcb15d70031e3d3ca1609787ad72f19f5ba5e69feb128f86c6eee94179bdebad5d3426435e0e14d68158127b8d388bda46fb999e3ceff78f226a24e977dcd788ac9afb443a89d0b576563b92e6143a1ec1c5abfb7d42292f5c994edcac7360d0e85195cf418d628e11307508c118783bfee5ff4dd4d2db23fb7e2f7a2cfd4a0706a8a475342320e54546a9f4b0e01276eac2e7d6e9e898b79cb6c628f8fab6ddd4381b1b4a2e2b1132a391235e30f246bbd9fa8aed5dbef1133208e4754fe8d86f055b6b05acddc6ba130f7e116ae02c04626f3cd5f65e07c5e99d525b389f257a092b4e9969a389712cbc8c6aafbd1cfc2ead34983304126ac6e68ac01206f9cbe264c8477acaa538fedeeced75677630c29e22d67fe1aa14d7716fbac0159e03f5fcf787e99a3ab37457d07e1362e689ea94780597645217478a4d2e4a2352d252bd3068fcd6e6f06b6b7192b78727a90d9406db0cd3cf2840e846d379de5b398a8ef3fc6d517cf77929528b2fc4d7e48dd6a4d61dfd05fce871ba8f60fd577148d085f311f3abda4c009cbbc0d71f7d88516fa1f728719bb9897ca4ee02a5ae4b39c19938ceb45ed14462752df45bc55c19d7b10f1ab1b57925028ac0fe6431035a7557045d168042a24362aa62461b6b371b255a491f351f0f968bea7fd00aa0c4b19d8c34fb366042bee9ff57e363a68820785dc2d9d65c05053b82a910bdeef45b181187714c636208f737c5b0c5a9e10ec8faddf150eca1733ee361cbe96e01ca9b93f8aca388d9933fb94089108698c5538f7ad98c5b401b84a07e5f66d1ba9924bfd31a2739dd21511eb8ad1e6c0482bf6001fcc106110e65bb192032bbe2afba82409ee0e82bf3f2bcbd9f0b70ca8bd1edb6ade76fcef919146f26fcbe6d45bb1e8b67031067fb3699513b70ab2ec272ff8d324bbc765346fe0d6f1f20471b9927413140d791d9e6984bb434bfd8d72eb2a17146c52d586d9946d2efff7cda878aa0a71dbbaf78d83d091a710c8d46f7be73d883d32a5cca27904b8054a7a5fac0ac5fd3586f486cd1eee91c1dda09750d5bd22874417550f26b837e056076a03ce98bbb8f170b5fbad9515b5a77467cbdb8a2b98fbd6d563a5f866372e0eed5b6def555997150a0d6194c4516d0c9595a70c7a13f1d5c59746e1256a3838645107a855a99ed6f2f2192a729c3dc9c05126efd8edfc5f25bad3cff0533cf75a01288e770b0bb349b062b7b4c98a508094fe3a5ca34e441a527808231ba63ab3c6bad52d75abfa0782e199adf05757bb9cbee737cd3a142f6de4993ad40fca96a958506402c1c47d23f5edb9df512ffa8ee2d5a85d19b0cb61db4e00606d0359dbe25cdd346d4b5e33402245630ec74750a66a818402dc1e6d92d9ac2857ac0e91a9363373089af5ddf2e26070e95c9dea70737cc4e453a63fdeb0f8350e10d91f30941a0e40b8fbb7eddd850628a03ebb33efed3730ec04c8f958581de6c91b5a07fdc0022413f253ff4a9c28221685f4ccf610278c5da3bdd8f80308fa6d0293888a5af9a80213d2e833c6f3a3acf1c96f4944e6ab10d929a951dc5d0454dcf03d1ca917c543586ff4f64f68365c5985edd46c1be7268c4e81dfa9c693ec3ce0a54d6aff8ac7dece42f233813c7140fa343dd625f39762d3e4fb619f244a6a85512d039a1b117e926f07c6b0b3336e7faf7458c34721d7e87c83baf321e198720629f4bf83e9af7fe70a13120a8a9b5bcc126ab1e653fd299ed1c17e73e8a4c09512517ebf235a125cedaa20f571a437a3e6f5d88cb29fd45edec4ba6304f6e18cf2cbd5f11cf9d53111abd6003c7d7683b575cfd7c592637901e1e6ae9255c0680e2f09839180504d8b70e5d476864f30d0f258a7ff0fb52f98b3fb998ef7cd870a4ba7c2e189e118bb2e686fd802df96ad002dd9645ff9795494459f5a2fbf1f91b4a2584e384f8f1dfa60f889a457d41b4dfd993c283ed90ba0fbb3e4857978b55161f207363fc722bbc543224733a9833bc2367122104dfe37a4b2146d023b361220743c77ff5da11b109dfb507fd652df409d53eb4d99aa345a71b07ea449f905ddebc80a5711a6de61e662e5b31c2f7a135e0fd2621811f575ef223996887f03521b4447b776cc3f7fc2f67c760a78460470b41ec28d032d83612e8deef95fcf63941f1d213448bc4ffed8c4e120471ad4419f6917e153577b7a1f1894014382055c1efc3f9073b6595ee838d9f0c2e00b593e68a058a9bad09749932f72533c472165546366a95d84bdac16eefd4262be2ecaa409e369df8d524967524d579b684ac5e8f99ffb794acd7dab805ca793b108ac621174f115163abe9b9b9e0ecd84afbf215b12bbb2e472d49c52c2c4cbca8d272d703bdd5a5b6e58c12007356e30d49db199190e02a59483d2c64e69692e526e3338cee2112f87642040ff25e879b9ee52c990538e09ef35fc9da75cb78101eb511ad21034b8629c34fe695cd7accb2aa1c904a384d5c20be95e6765ea951f4d8c03add33ef6e2eacfdfb048b7331ec75d5777188960f72e4a5454961a90b719921e47d48d6e5ef9dde305b1f22672d8cf74d2c6be1390a15804e9c036e5f30b4aa2ca1fddb3756c364df2fc8d7f96b064165c2c8d908dad7a96d63e3e93d746c9032fe5259993de6d96f3f82e17fa0e5e9911f75269d0a2907ef6836558be644e5124b04fac6057b1ef33bab140e2c6d7c3362e67b0a9f4137baa2934d583375e5a2ee086dd87d70796e4bc1d024eda4991241b9e79169cd2a77a608d6073939804dd77f8ec35050570a7e9001f0d1b7a3ee947783c8173fa3c555d1dd04c8f4e960a835764d2481735bb016b68183966109be80b55160d442158f0bd861b1a063aece06a688a6eda15308aa36544c09da99d488d6b72f14192c07a41177388ff340b5ce3eca529cc211396f661a4a9d491268f841cd6d6cca2437cc738596094706ad684fc13045ef8ecba6ccd8dbe8c66b1d3bbfa2c7093f180758dd542fe0d4d8c95e1295a9cea3497ecfd1b9b9263faa3e86a0e7f73dabe558af52c0d28383a5416ec193916078901d5d693b6f588de83ca217cd531acc590cb84673063a560d679fd86285d9e051b141fdf49d75d7802e47bc2fb0e15f4530e862b56aa5bce1bc002322a5a53f009e83453793892dfa3e8f8f43abf3adf75b447632e27a2cfc14824947bc4b0f2319a68e22bb74a30dd662494a7180b2e97967edae2277386c96f7cb7c0ffda6d8a208fa7b9102583399ec3bd4c5f1dbb1f9791f381db0129b4d412007eff5740189234a5de710c9a9e597e9223f83199a8e5dcb8536df0f18095d2907c80502137e9849b5c5524918467ae4276e8d92ba3fb56ddf4abfa4d403f40908b88681fb9c529f848a96ff16b6e2ec9f91bf0f0eaed24f6bea52816854a453cb2079e10ca13560f74cbfd6731bf237b9e2408e3f08f767e935ce4d69d095bc1f797f766a001784a3fd5c6495c63be3176608007f1e28e9b692881dc6c1b6255b6e3889eb5b4a6fb91ed0d7c850ce53c58442c462ff6fa0d6536a9d0a9636fa352fe504839ac788d252b81333f5015db1eb9dd21e4d3c38c1c5fead237a871c821300763be38b07c68694c201652761f1ddb49ef85fdce955aed0e4be726bce832444641b36ab7e24e5c4ce0e13ea0679733ae2fa22beda73143eda11ee16a19ca0f8585a64e59b46607957d43d0a166cd6cb32cae43cf00891a0de18cc3158a25bb27ae551db65d0b85a62eb98b84a10533f894372412d4f1acdd0d7541843038547acbd25d8fc7292cfbfb5ac7ba16702dfd8ad25cf718841c2b2a243379e4944d3211fb68b8d0a15a434e5463d19c965f0200b389419b1b6dd0f970a2e321d641499fcfd8124db4f51b14e67278a98051cd32f0fbff7220de827fc948d06529811242b41fcf9cadb185ccd529641ea2ba3f4791b619db2a3ea879f475ca778178c5c1e276b1fba2c98bbeb6402df34d413af0ac90e1ec7963d6e5983089f7555e8e8b1fe8f1991d5b9677e5c1bab88c8fdbd6cf740e0ddfb876415fb31126c4d089fff23088e1e79ec8396e90680312a002e53a680c856dc9427a758459c3ae26111ae76accf99b05b20035a4e4b854bcb81e4ed83d5c9317bb4bfef69f5879700aa642c22f0624b92dabf3da65d39ecbbf9d666bca6d51de80858b482658d2a97e5a8a97bde057e07ffe8f2f76da426c35aa8e3448f5098ec3ee7e511403bd82a09662d9a34b1853c042bc63cadcf750b18545f28631d52852cbde954b833de8bc94b45154f21033a83fb4d705581fab8a2d9021925aa35e968103b68d036b082a4102d8d9524b69436016fb55865cacf41bb1d910838239194bd1a45be4df5e17cd5033fd065bc5d7274b899797a25dcc80da6d0160ede5db0dfbe154c79d8b660adff35f5b71ab8eec49467614cbfc80d40d4a76b238250e98cd8858d9b86a69f5743d6429e61b0e56168db51792d15d5c0e6588e448c65b80e71e2eeda631ff60422c4930f4427a5bfb05d9a042324ecd4b5f979043e56471a4689bda816c840b1f6fadb27efd8a762aa4df459411a28bbd86c92f495b85182ab5d2973260fd309566c5c54c4e9d9d5f14942a74f0f17375eb333ce17f9193ba77a7b61c22995b6fc1728ce917157f695909168aee8016dcaec55c6c11f4e93d306d81e35421784bfdca9e892564225fede48ec219864b328914a22031b65b33407f9875729e2f71aa2d71e76d92de340b520159b60b5cb2eae034db53c98066d202bde0fe9f6e7b173d0178c3fc8d4b499d0c81d49a732dbf17f353b4db494c68b1a906920602b66750faa84775d57c8747def6170e2d6459e97c5324d95a9baef7ed77573781e863628a9dfdf4458c5ff67b66c3c5465f8840afff89f1553d578b47f62af8e8e1515bc66805a0c34aa01076d98301cad363dcca6cb6f5aa1166bdb2ce7a12a49aa4d0be456a9cd91e9cbdddc80ec9134442a3aeaf061627fe50adb896215fe057ec1bdcfa41b9c32fbd1dd933b78aa67ebdfd2cd99d79afb82451bcd86189e75a0e642efb00be659f52ed8662420c4f13c0c35ecf1508fc5ff926f0c7743fd0bdbda6de3b91552a11a47f962b3d549ce595ec8641ea9c88fab49088443122b7835e7c32b5aa155b900012497e9c7add2b51f82db0cf58d38b711aa2c00b5f931bdfd5e04bf0a5bcdd5588498ca0edf8bedcbe8f14d337e7ce380b2707949ef41f79025331b3f88d0a17e619f81422ebe4bde262c23d840b604778b06b752b14b61808c4c8cdd7b8a1de827d4876c53998ef01206f9a5e7d13c039d2abe29c8955c59accff16864ac20e76edd0525f5a9eed4ca05876ea79990a4723d85810f61f83023824a500481df7642d576e41a62327852229270cdcd4a4d22c75a74a25344cade6c5976db2e3ed15f662f08dfc21cd09713a002baf3ec4b10ccb040c8273a83029ce2e31f51a4aa3606cac6d2c68ae79d4dfd900807f59a5f005657764bd202426d7274be8660185636f33fdd372d5bee2b81d4059476a1a265eec689396dcc157dd5620944c430ed05a453d84050cc84e24494e33eeb51af33541e44e87d0444bbffd1cee0d43162ae7f2032255ef887723bc9e326f88b9dcef0c2b6f99cd8103c661186df3b1deb5127f42e589755a454bdfe8466ae3ecb67b7064bf2b63e2acb029b2996004f8b175f42c5544bf64ae15246c650244ef930eadc2d86086f30943f1561038259f3bebddb3be210ba313fd3e2b12965aadc340940a3718146ba15a5197331baa585025cd1a607643366212dcfd339f336ab98f9e2cd7a188bf8cdc17edf5bd468e92bafcaf1b304c6f72544e3fb97d9231955945e1a3f60bec30f74de577d8d2bc00c89282215c74dad4b97039e1861f83141589535e6de21825a58200387a8f198b4c30eac78918a2730e5e4528a087b79146d63ae81f56211bf4f8caf37380df5347ed1c6606c190b57c238c68bfcdda750e8709359e1207d42f89d10819adc0dc3ffaa8599f0f1d3db3e350e7a5b1113732c57c9348e4eb945c6370eac10ee79a982a787935b61910e16b2f12cb6eadc9b4886b8ce3930647a9f5108706e107c9cbc477af1efa26346d720c86dd58be0e8208b173acc00bddeaba83f6618d9ef19b3a0cfe7deeb344743dba3aae894b1f8edd1ea12bf47b97a3d5f4dfa192414b734388a536ff7dfeda704403ae8da4c1178a18ca471a77b2cd08a367dcb271c66239b142a1213ffac4a16e431f5132c2ce992f3c8fb790e2ae735b6739984166c99e6eea4aec3ed8b0af41dcd4129906ba26fe93182d2bd3059a94c484031bf4f938b601a62e1b49a5156c97768ea66cf1e4b36a531de77710cb7deb2b0faa20ce3425a86e455f96e4920b0341dae6c711867aafacd36a83ed98c883300f233623c9149d2de825675b8dd7b4edf5833add63ac3ebe8a1452e3268ca5b2d44021c267828b00297d15e1b06a60188695c33ec5aac145be4c2dc6a37f8a9c199dea9bd3c30152a2fd8875f50d159e50f34ea0a2ae2151adc11cdfea03fe3aa4fddc32659a155b9815b4428c1847a8f79d8a1be58f34ac2ad7d5d34056e304d033ccce3441f6397a1e382702bf010459d26ed475d9c346d12900b28da619cd53b0e9d7a7eb62555bcdc2ed44538d44482c34b5d8ef81fdc9d9b78af817b3abba6a4a3a36538cb6e4100b8782a64e345102672ed1bd2167758f6e00cb4fdb9ae56c1b4f877ce1cef103330dcf0f628bcb3c742187c9aa79f5b1565d80a72205202c4e0598e1c77b0f700cbb247267cd20064b2b3bc6722d01f4f17d315532bbab28511ee76f4fb38763be68ee72a4c92d1ec741132c7e2a439b65c6333a48a0f9d92756d28df1e098ceeb4365568ff563776b63a61b95638249bafc59e6b4ef4563d90d1e0a7e2bdcdeaed40f5e64524786a7fef978cbdf22bae4138820020d8de048d6cf34bfb7a9ab670b559e822257c9ebbe1f0eacbf42c6ea857fba365fc1c62198d7f985ce4e542472d25147e0d5c4f12d00c82d09969daf1bd036e337bca333fc0861fe96552fbed29988383c446dfd35e0f63e2c572e661e4d4a2f5d30320ebc83f72e4907d973f97c736745fa910819080a3013fc602c81f6069af973094c7c45f71a6482bf9a29bc3841f03b02d7e30959c9173a476377cdcf3813bcf7f2db1b603dcc33aa7accf35ebd103c83ecb957cb144bf199a1a1ce019ec643e22d7a08c6ce69541705b8175ebe4abe944c76b6eca91a4464aff2ef7f660b2688200a6deff1b2f97f59d21a0f1486d6c2bef88d306c1f7900d45291aeafff157cd78d633ecdebfc16fbb6c3c845351ad752e799b74e9bc4a87980d6d6f2e8b095e83f0fbfb6e52b5b0f3773d17997ae5d040618923f7d115566e94d5e7104573a1ecab47a4278446749fc18290fc12fd11ee54b955ba68e9696ee86f7d301ae560f74b754cfb58402720d87e47d7d7db77da95d95cca52884bb6358f06c2863dd4ac29422a36b44f11f18748a8eab7cbced0ede162d593d9d650873c74f81327e98b172a80e7a0724021e9ae334921a1e2fc82592517668c4ae8973c0ce8a6f127efbc03174015d02cacb779feb1b2da68fbf32680807be46ff2d88cd80fa3569294219a25de1b24783232f21e02df1359163c728e233f6a35a1f35b16405c2f491ef90d8727b9b2397ade955aea0fb67bb5637a061b469d9d6b757e9ca828f9377f9de03157859a251d5b83867466322c459136b1aa20d771842232d05cf6ef39c9bf7dea00eded71c923578b86d673e4de010951757d5995ec14dc3815d6d7f8add73ef0cf978393ef999e3f11e14945e29d9b67b7f7aa669d6b73f633a66f6fdab1a8e8ed644b3a072d614f25b6cf483a4d050679bb7d7c06c5f7977231c1ee71e6532d332c1fc25be59e5230e1828f219ee4115fb4aafce5a44d095876358b0eaca07fd39e452223e8837b8806593efef086a86bb5ac6ad75a450cc1d6dbbd458cc7a832e1c25eaf4d542a3bdf40481e1d52f4a7a6264511074f560b00f48d85415559ddafa302a84c4f26210f4493b78ca00cdee6f874ae3a5b81f1bc1e1fc03bc276dcd72cb9eb51f1a9965ce974ca08ca2aea009940b48ab5bba276c2364512e3101a9b4c80cd8e0d72f3939b3f81dc67c44a27b5b2dd58162ac43639a49c085a9a6eb4623b11dcc5325e5fb241faf5531737ce4e46c01c44a0552b4c9be3cda57dc23ad00f6922d7e4200470f79656ab752d6bba4d256ee5db4aaa17d3aa21609d246f147f23378c7cfcad60688723225bbf3929292489153cea70c9c3d34aae1845cca4249244bae4813af1880f524e5cb844f8012ad491022d477268289a5ce681a6d17be18771facd816e46a740d738e82e989f50182e21857cc8adcc61f62df0bc22c375507e988e89f7e5867026f633b9e2ee3adea741db158cacd2dd574353cd7cb1e161a34656c652ec977e462421eceb8a6ce06961decd8a64574d305ddcd7f31413cd2dabb5c75a53596b7b84ddcecdf8783636a52ac4deeb0de951ac476f0035d907b23fcf67e110006211b5b9ea98ba1b1f216b4d72537b25103b4ac8cf67b2e034fb0aa189f266de8540db6d33dd964ba9c9011af24808dedd23fa15574f863d3100ab817af7d6f74a52d7a91859a88ba6a5d40ef2aec0ac0bc21b669d9cbcdb88673b5049d7a239dbaa460254f8a1629b62d628f58a1fc3c54dd4baa2b53b68060044fac4e1988155e991270bc941e920c9fef27d59b2c4b0bd1d72e9be5d35e04e3213025ff38b988502ff047da46f6ca00a0c5bb969399fc7f489d72aec730c7f6464b4da87d292eee8fe0ab695e85368234bf07dbfb914b9d5ce5eaa11cd1ad2b877c4ef83df0408c1fc4239262ee392f4ee5498f7c4d1b704705f97de4616d0eef660c40a325258f1281aa1adaa96d9852b20c48090a30b4c354e60d53cfeb63422455d77c0b7525cbc0ba0dd2fefd3c3f66b278219da22719adc5952d4d312a4274b4cd7a2a584d8712e993209d3e7fb6e7fbd27213492cba3c8f9ca33444cf398a089c1a98450f48cdb54e83492575383855c0ab4cdc2921b94a56ed93596e0ef4847f2164123c961ee7f110be76858514e23776be4a7cec9a24cd25fb55fcff88af20eea9b54b89c280584b3f0d51f9aaf6929028fb3f239fc4db23aad0744f61dc0e6968a70f2b1d11cd653d5575c37ab55075e61917498cc534185c7d3bb58013074a2ea2d47830c3e37435f2d6a5a39874dd524da13eff839e0bff47ce6d0d6dd1e4ce8a9ef3932813487ec2de5b9d7360706030d3500fd14bf7de024eb2e53cbf2ca98f0d06d7501a56e9df381f12ad29311563518cac0c54cd4a9d01a68d99c40d7ef6591b9efb1d5ae434b3558f20bf2447977b84da58ba11f1d90b3b4cc719f168f317c1333d53e46d2d31ff9fb5eb30628c5de013a3a04fcebcf4f6f0ab2d1a25e22248415fef9b2ead53e58433dbb6932600d131ab356b4e403e819bf668327c3a252614fa27fd4efed1b3ea2b4d3207044fcacb4cffd6430c2788c897bfa59e8b1d59de59183a7425626ae5d45ce15561f91043d04d8902ded5b5ede58cb7b286d57177b60cb4943d1225d205c05c46e97da5f613ea5c3a8681bcaf11c0393a4f391165c1d911919b1053edcb8542c8e54a73b67d9276651c70236050d0b1aa84d80141ae4cabb5c397795afe14646dfb0e5d46c66ec79ae4b25e80a64f0cdced2414ac2e3fbd4d7f4b2f56f0b93b1782e2bc061ba299d85a26360738db348701ec02fdf6c192f55c0cd784bc5fa4294e7cb2e492e279d92f50e5c07fbffb00eb1b37bd21c390bcb374dc3f8a1a565c48fe52195daa80203b6d979e5616389f1b58e37c6a7cee5df81e2b7f5ae79ddef1b44c628e680626385e0b80e705859894050f7363f492aaad5606e81f339040b09b647229b9f006a3921373a93b2d9809c802a72510cf672742734328193a985bf7938eb64a800f1cb3412ccf91fd7fc9cd811efcf9494ad73a5ab1d89d4542f515135933850f126e53dde2e7f88ab10f01862c8cc5df5ff7ed253e24f6072ce10397f83d9d4cf2f40e45077d7674ec34fc1fc1570d2429e3ca9eecbe1380df385215c91a3246d40d094b4012d8c10acc6537705f5794a105398b0a16ce25d30b8344b8179efc7296c3a36356ee33ae2e68d34d00ca2ea1c169fc21d2ee6de3aefc1c914d038f4cceec420b7264129a826b11dd549144579355084bd119d490fef54d10c8463c1b1dc6749a87c4b63797855d417087254e7eb3b64f9749429cbd457c8e0968e7dc951b4e53ad3396b2880b7937509a6021751f10950ec939a3c14d07f55426f3f198e5cd1879c74e436f527f42784d0a8829a8fb9f2acc1000b37f2cd359678a09acf976259d5369b4c112b817dd17288a92b698f1ddef4fb9c26e8cccf0701797921cdb025092a486b6cabc2fdbb58140feb619a608d3e4ebb1bc96886eb1666a44fbb3fcfd56adf9593cca30b0f3863cc3ec2fd4f42c0a09ae611623c22e70c30662e83e0a55ecc7d40df9e080f5e748523884aafdc7719534778200a475ff6942b4f13a1e44f28146393a098fbe3517a0accc4090a5f70f288aa97df43093f049f1dafdc0b597ce243a321292c0bfe6da43a2a75ecb13c3110f5844ee67d415f950ca321a26b6c2d45a6698f349a8ee374f686002c59019e760fffc3b3dd04bcd564dd806f0fa25a6535e0ee5abae15c61bc809b42d83d245b3b9c39bd4ebd24749a12d17c1be0728c9dfe8058384fefad11f4c2cb3f2ef3ff1c998584cefe84c986c27813a71f194e4fbba8e1ea8b996507f904a1c99ce19729ff906aaf50c7516a5c1f996aaa40c2196608ccf773816b0e92f34ca2588138f3d0129aaec0cd9adec4f3488cb606c71244bbe2eb198e516004c380eb0af0028352687dfb0f1c9b08f9e0d3988573a2242b6b1165c39a67514ff5058edc6818cdf2effe3f112459d2a7026ba3b311bdc59b8b5856931772d54232138270a1e521e8a6dab22011d437b9690333a28f69651d060ada3907e19f1e3f1cfc12b8e10dd30f3174c022c1bf4f170491cbc88bf95a46dacc997b4a82971584ca608ea33bf612312f6d56011e2681dd04ce2ff4271b59daffcf01f928dc232900600b0e7bdc47a2d55ab43d00e304cd23b2ac8f080ed1c24181b733c54485f5a976f8dc94e4709751167be2b73f1d37cf07568be32d36ca0c970d339e703e7e7f92f0a0de049838f4b714d7cee314259c9d63d9124fc77eace4c351aeabc67b175ac5826e0330d7fe23c79823494e96a3fb1ebb29702302ef9b12c536a0dbcc673299783334e74ef93ae07a9baa466ac6c7bff74e204ace0177b1e21d114fe078cec786680a3c3dbb8132c9fc5849dd975d3c3c9c4d501f17d6baddb7f5901cdbfa8d5f0e303413de857ffee0a34c7b3b4e0b3fb3a5a53ae9f3e9c40ae4649fbfcd73ee11fd450e72ef72edf1ecfbb1769a59b58e5be560ae25142bb4be998c5b77ef4ccb093fc571c16c7df6f06446e5141cc12e4f5b475aeb0111108e0fe7e8ba36a90a9fb29bd6e8d4ae9deef21d3b0ef76c2cbe6b93c01f66e65126b9f4c6b930d3897f239ebfb0d08d5f61c8951bf164d2572232236ad4048c1dbc4a504039362aa9f681670bda9c16e82be61d8f9465810fdac753a3f0e0b7ce3617bf96e2b80463bafc2ccf5602a048863128826628e836b9fa4c8a72c615c4f730d727344f227699965d2bd343aed2eb592745cfc50205be4833150f842fb9557c47bf57cc9f81b16b0422485a922f40b2d444b3f3e5fb093105567f496d140a007792c2ec50225f733e48eb5a6b142d9e41015bfa519a81a4a12229d860ee32812fced7b577d32be09daef026664948b86cf4abfda6fc66ad654563571e3d37263edb58c6bd3b44bb5f2e3a4267c8f4ab18e67b38c917dbdaa465db5da35ae36d5f6a9264ee2178f209053d4e366b59d7329fe9b8ed17cee188d5cbf55378efae4fc388c6f6824dc014acfbea37ed5b8c5af5314c976f133e9857b12a041b4d9cfaccbbb97ab96a8c608e940e99620e01509fe2c11ad7b7cf2963f60724ac9104c8bc0cfa2f20bc8c8652e03768a3d32d4369aa0b4f157adcff185b8e24a65de167bfc39904a7993e6cfb7db692b438ccecb33b66cfe3dd457c8c4ef9d4c886d9a45135ea14b5c885b2f232852a3defb869543aab0d7f94922b863f77ffdd13448817df81c491603f25c07f9a09a55115323285590ad2d9ba444b61466c0994a97a03247f9cd8b475fcf475d67e4f09312f865fd29de3a3d809c7de8b66d21207798235e838b41aebfc36662f5976b2e553286845d0f52ce82f585fdc663789f1eb804f4df77afc395a3e9c04a96d75ab8b814e638bec5c2cd1623625e371e195854bab2f6da713b1af9136746d50c232ab413b7220ff23577a68f54578fad293c968d4aaa4b2996053158c0cc0025972fcaaea4aa85601dcdcbcf58d4a7ff6b175142c999278b45c1e0070445233137b486c39769a3eb59c34bdff7d51bb6a58329cd0953f53133b010816286aee9ae97c2c2189244bdf0cae339a719c7cb5ba07dae6b3ead0f14220b4df20039fe7598989794284080134da7a9c2835429bce9e6103abee2d2d8456b92b314fbac74de0cba66fc24f77376fd680fd24931fdbd5781f9c4128b0f40d5b74807b8dd8359cbdf76f4a63963240c8070dd6cee82e5536fad99ef97a4e19814c02279ab2efce2e3cf7967a58f7666f4227e20b515f9f3ed22724e316c22578d61b5a15a8fa59764ebb996ab7464639bafae731e8dad91553597780c436b319bc65cb4353b983faba2d927ba9264a5229277cf42970491d719a23e75a6adb801a631272aa15a081e4c7833fb677d1af729c9a07bd71456c2683db38c031484acb24f75c4d0c4593b3eae0836454ee258126d4708b182da76bcc2c510e80e2777ca330c3688377356353feab245ccfbd2f7d3f87e811247255df7110042ff363112c1ab47cbaa5b96af4523944a1564489257c10aba1150f44deab0e7a2067b2f85e8de108839c383609f77e0c11f9c17c03a880c34c6ed7925896fa7022403be937961e6132c7565223f4ab3723faacc75bbb0eb2359684e8432f94382c2bab5181804259d9aa7f94158e6eee98e7e4198e91145e2d66a4c54ae789c68f6896f8e27e9c7f13819c3d59fe9a66a4ec11f5876190e7a1cbe41a2b019a9db4da8ced3268856fd6dd6bd3b704738a15f86e00d566f70e77aff661e37970855300018963a8f9b3164c8f312bfb465f371c1feae6b5b43620fd3fa79c8b45a76245ea6ccdd40f0e76200dd1b8b2eccfd887e4073b852c8f30a01239c3def2b846b2fd395af84e39cd160015542a2481d99600c7153aef0ad7f9befa82f696653236ea63eb995d1fd1c6c48565417088177edcbdf1b4b770ecd29c5e7fc1b7dcfb363ea440114e876306ae19a0ba2f91c0eb7c7f808f0541e92a5ecd23d20a0b71a18e64e8bbfe3d39ddc826284e1e36a971ac250297bb849635c689dcc3cc23267b7648c27310acdc41329ffd8c0085d646107d14418c34f60c6b453549b07188e010bb3ef648f4ddb6418de37f9b68e35a079d8ed4da5f0b7b945ea2e0c22220f58c2a7cde9092d8941d06e757d7cdd1968c29eaeb9a114db17b4e4108ffdb675c48699df3e1f9bce3b36f79f6e69a0daa25b7935898894f53f532f782f196cafba4b5fe87afbb8b73a57482d72e29251360a031186d767d4f91710c18db7de69ad84e02fbe9e5b935279a06e1a9e358d678372866b51b93bca9bb33a4db52bfd5ac57b3ca3a90361518bfe8d03884ebdde310bad05d3f7c89d2f5987347f3f74d45e67386be44f38c6d916676cdc0da7d1b42e1de6632e4ec91c90b09a34a6db8701d3466a1ca2ed798d6e6eda2310179797437804f95f722d359bde55e097be7dce2639b7c4478653c0ef95e787d8f127824f73f6649b94f9698a541741df570da72f2290286bbd61a3c6ecb02f09f18c6ee9565f6ca66b61dba27909cee1ec3b9df131f350f866793139c559b7bbb37e2510bc2f0db7d53a86ef777c9ea63104fe0c370c53181e97c0b5a93ff1d7a039afd306271c0ae4c46f3105475f1069ca8992b565899b4ad8d817bc33395faf7f1104b4afebce083655f08e98dc903700b559f3162461e08326f146db745a450f9df5b3072090ae52ec1a1a4c773363114778cf24762252545d1efc1a79f0b9a9d1d2a795b5702c774876e230752219c1adc47fdb47bcb78e1fcd4dc7806299d61bbc558984a0fc741683a7d31cf8b969bdc5a1d7c367eab60cac5c52089dcecd43db81e227a3915d9077f8fdf4472b466ea8a6a7dbe1a6ac20ac479526fea7e56018530d3327efe4e5b202fe2bfe7acebe9ea0086ec0cb584406200653c00253aed6538004e9b6e350bb1f064cab4e327f7879093c275feae428dbc4ed21960ca2907272435f1c48f1179ab7642f6b073c424e14d88d502a9ae858bdd5afdcbd0566b2419c7477574e8e88e8e8130ffa5a5e02742e639935795d07c4516d13a4793cec20d7b086b0b903073261196fbec603e5820be219e2a7a4cd7923ce3ac0032d8457de80881e6f0b254a8ed2e3184de0fb20dec30521cfb339112bf9af26f0b55f679ab684987debf171fa4e48e98f4242a47156b00b69b7537b1f5ba691112af4adb0003841024adc06ac658702372a885f723ae55c0d3d2d51ecf9cd5de3ed0f423fcb2a46899546af0eeab7e31cc0d0976d61f9d69e1113d719ada48b09cbc5e456e7d4af15504ded6ecfde877662a050fdd0548b81dbde04dd573b0f4759227ce94d188826cdc6d64c46d0ff5cb7d3d2baa44798b4370c962dd2ac8f9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
