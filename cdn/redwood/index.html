<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a8bd08963b29f2c153dc53454265de529ee7733861331b58d9f5d600b0ba42ce0286c01984d0a511506ab67ac0a0ced7a5e027f6af1873bfe4d3117177151247b289b4dc545caca910e76ebf001c096aafdcbeb3ee4be870e9884512f1e84817767583e44c802cf933593ded073d5aa64e75c4844ae0a476243652b430203af47950a4095bd370697dec9bfa95f495c5ce7c30b096db3f70a7f0a150b52aac9fabcf8d04a17266fbbee838c6c6a4a03adb75c73b23f8666cf0ef9653c81d2b05ea3a33cae497e53cac8e7823851fd258b1f537b4c24e96ca2464be4ff629bbba5c8ff87b391b5f453a9b16d981c2c57f6e499a079423bf79e271d3f4afb70ac875cb95d84e53019c22fb0b4f951b953ff936f0656c2e2948fe71c16f18ed42be75471e9fba4472aa55550e95839e3d95e20ef9868d23f057a13a76a0c72de2509ab7f781eccdadfcda14140135bcaa821f07369094848f23d2ff6c78c483998e850173e767e152003c975c04b8153a9db2cf193c8db968c9da20ebd11e930b334c8af01b94e3d7798100dd1bf613eedc812807be056e28c8261963efb81f35bf2a16a3b8522637c655dbf81aa4e3d39d0d1b276e1fba1a62d6e9c709d751990407a06e48cfa23238e8afd088fde79f6a7ca842aeef0da63701cb51e61399d4fb8f538949b7de1ef89a93dc78320953f31ce405bf4a5bf18ef40ef32d30b5310201f373b9d5be0db234da1391ceaaaabee5e52dd1b075fd74ce09b28422c29030b453a6e0b18edde5286db439f51970975f0967dcb9d0719026dfd3eee545fed4775717e26727b12c9600d72be124f48280cfb0a3a2f88aa1d312562cc3e5e1e1dda82f2f8a5bee9f25b354c20a071e5b07afb98bc2ecd9c08c8f74ab117d2198cbd7ab8d255ccc7a2e59166878c0f0d592cb80b566f832d689a49630d60510d8bc4e0125e930a98f613c653334835782893f725ee2a36e4ef0d35caba44c1ec0d8ec82e91f5abac1d75bc895c3594912fe0033d77a1c2dcc3b379340690d90c3112e070e021d32e4dc00cdfbff2d29c700ab048778ce85ec358f437d10232ea38a0b5a80e27d2f96eece85c8f450821ad338b276fbeebd8d1e3a81559efe5562fa7d3a1d4bbf9eea62c0ecb27e048cc20e91ee756b20883131b352ec3c67f57a07f3db00743daf9aa0b258aacf3ed74fd40940d4c63ca287916b42b1cb37cbd3aa17d40897d8dcdc3ff469b5864452e6fd41e21447ef5cc20166a200c3b1fefd1742d747fb158d66d728c7677866d55efa70ca64819dcb94a13465d46b0eee63edad4ababfcebe45290cd031df0bba7941f58bd434d12c19e3ffd440d72d6e855d2b308bc55da5a23180e295b96356179ac3f1acd3ea95d16e70d59a4ebf5765d5aa59946f3ac631b97ef928c9ceb8ee16702ba5d095f33104e3d65892b50580773366dbe1236b095dbd2066441da137ae3da45f55efdc9ee2b650edddae13f1f3c75b370b56f1447d79d465ab6d657420ecc300cc6daa5a5f1d9d6da43b2942e396bb335a2e6f93906e83e41e2af1ebf6197fff496400e0f8ecf7c85f2cfa11ad3155932ed62e129a4f161608da9f96d6b37fb1d930b38a0812dc337e2c373b3016be858f38130c50164918daf33a92e3d607601117430703c3e8eb1d03b5e8c1c697848452c969231a7bfd119e3b9961e4a5a85d3214d9a6edab4385f88e0b06e51c6c0948aacec835ee081a3d4d6f760b290064919234b153b1b26452ddb0635cf88b0d5d073b20d547c5dd92b1ec761c22ddd560ea6200d3f748ff8fc1da8e9914ad9c9cffd45b146afaba039ab830bdb459546a08b982a16b826676ccf1dd4188393b29f26d3c4c1d631e5ea74bb93e2ae33217bfc685be0462254034e88e82b0cf54eeb185c9efa12a6c02c1c576a90958c47218d7f6de5a5240c5fef5d83331ea9270282b231b22cb4fce0ec2435044aae8a9595e8e19f8958b2973bb7ae4ca40b57f8cc92ed85878219bb7561faa0ac34c8e346049b960ed2993a4d085d02af01d88b976e8378308e86cf3465619a1494f49e20725110c993cc059bd06c642674502d8503c13efaaf34a7dcb5ac0427c17a46d656ae90c10dd9aba4011d8b9396f152d7f6b8ef715bdfd244e7df6b37af92a2cd6816173807ffe58bb13f7399a94b04467c4e7d1b2322359f9e44173c52394bcb4cd88a7581542ea1617d49c9ff061bf24ee2fd113935ddbe05c687e4a4464567902a5354cb655520ba954cc001cc39c320e9ed416e5a37f70d522271b346ae2e03f54664a76b5ddb3cdb692d6924ccc724a68b07359fcf0ea497713b9575943e46c3db3570c94ce576b347d2258406a41c914db9dc876942f008c094390f048f8570f89905fb67e7d8d5b7a0eab362c0387e1e09abdc945ae05374d53d85cc2dcf21302d7f934139b7bbd398de53a55e8de5b2604c163ba6b8d40ef426ef04110144115f04e4eafcc3fc8fd889a9abbb2a5e0cac8da705fb2293322061c2e9af02b70613c255df0969a91dbb0b3b11ee79183e8e3213bccdbf1fd87d8ed9d0e5cd1fce5d9efba295cf0468b7a3e392117447a6ac40c1f9086e428fdc589d1484d7a8cdd2b35d324e3a05f290ebd673d98f89abb157219e954e644a1099e1987f56b714847b66a4bdaae7783cca14b7a9561466eea3cf0f1b275efc8e327d67e7b9c211898e8a4e330d79b4465f7775ddbc44303f3b7a667f8ab38b8b3a2f2a37216dfd19f2ae72a642462b56618a26963aab2de71d3c3ccb2272d425d58ee86f02cbc750474af34c1202b722c12987c43fbb9aa1b2a5163a38a45deb517a48cd9c149a1c491a88755ed371a6e5e2a12c105156c88a2f01e255a24a0895b38acf17c9147a6e6a10bf270ad0af38b9286cb2115661f1659a560dcede15f603007d7fecb08059ae4e4e3dd88c10c78fe82f4501c3e0cbd6edabe57add035ef669e0bfbcfb14e2361da7c7c0aa5ca872670b91f1bb744f8c872a87d13669aae7e4c3727d4379a1e76e32d1160f17004b5db74eb1aa0939bfa7a069d9336a9ab7548195099c6e0cca9d1bfe1f26b822d1bbe363028cf07431ac70b1e322b57c26ae250a9090429fdc9401df19e5f33c7c22a9c3b396a1f85fd4a024890b62c8de5faa0373d1dccb5d943ed39b7e2e4856dccadd9eaa5cfbdbb710f9e291ab9ad00c64f023b6405ce68a65ad8a1e58604db4b294b926a886f979e787309876c381eff16f63e8dac66828fc1232259c9beaa51946994abcf308f76a4945827e1e27ac7a1aabc2c283502e61e5f08c4fad84a4b9096f14c3ee96565107c26db9681e36db7ac2e5870021c24ce54ab20860bffc1bf4bb05bba2e8c2b6387387ffb8d022599023895e141b37a6047273356f7eafb96e993d4f49c26ec1de6783c93c654322a5c9a60257eb21b6de591dc362c76c748359456e1826520de93f774fc9caa509e920156ff05ca59d253107ad6b5847b091b92bcb03f89902e91be32dcb70e2179ea87dfb4a9359b7dd4d853d06d5eed073092d0b1c0eb27b0ff7dd297ef7e2e4e244ecca373c1b7733790db9ad5cc2d80c860ea94e296c41b54e56c2761f8aa9b910a48d8d1f59f1ccc3f8bc9820c010b523ef1592ba38d4f0d8dad098897ddebf09de548210372911e99c934b8916088446d10aa8aeff62d1652ad7ffdb902f6af6d857d486503eae7593e7966a001cc80e0077cf9359fcf38a3583964c2c388200e5c422d66760ddfc0b571d76226344e51884e9acd6654c413fd9bf64d1f963f1ead9f6e4a187659e2949fc847e06ca0c06c9bf8ecb86fa29503e1926692577e2abaadbc3a46ecc969f48367ecb3ae83c3b8e2529615afcb4cc4819d8657980b54ede7ddd7b6bc3f9dd16dc9b741b7ee6b472efc78c9c506bc15fd2994ad8f50497f229dfca2111a340e4e1f94277b3939cb94f280835ef38e4ec1854386477578247b8924671b78b4013f3b168f9be3002a18f78316287d4353abb0bce0da72c06b7e16f9bd342969db6beff5407610f108ff57dca665ca63f34c264e375c45fcbb8e4b2c96f3fe182bbb636a01439438ac3fe7f9d5ac71965fe813588b08c77701733ec752a40d987e6832d1f7285dc0755590a2355aaf2a283fc80f4e4510c656f2cecc97d401c11130290d475dcd0e3f6db5876ebf50918bcc15e15ffd4464b1cf4a1378f0ded8b8d9c1a5370b42e2a86c8473d30758d85b69b45260af85a9268aa9f56a51e9ac80ac861343a159f233dd907a804a476419bd77281cf83e0752e033d8478f8e9014ef4b7e70ea20986204b37e42dff1797328351be97b8d2409a60b68459b8653f2c16d5d0d07b5776c9ca644a074b44bb59874c806c38cbb473c0e24ac76b889477f71c175a6d0769e87bd73be42330e57fc9a0468e7d241a27898ab418584cc1563d846863c3d284148dcda977c449b7db8b57d753373e24edcd20c43b2021423387614511678bf7710ae31ef5a67661fe1d596aa352cd214d760915479d3da2188017e80039eb558664618db63e261909ae477d333b2ad126a3f62e9ceec8ee448318d9a8224b88116c310eebc72a88470ec720c954aa9f13cd516e0eb7451ba055995ca045bd8da6e9eccb214492587d3cf5a0c7644f975f876a0525f98111739560c7fe54ef705caa21e0a9b0fe16f370f5979f005db535c54b2c2ffb4bc98354e8c1b1c3ea27242d24db0e5f6c889503598918baed7ddf84e1dde68919f81a674707038730f83f3c94a86be5ac7d105aace43ddebb08c593e32da1a93aef1250e37f4d4c0b37f710813450ef44cc40db64a3b1569e85e6a11879cdc5cff142b8dc99d72a15adc7170586dec0b94a4bfb2e87ed87df729dc39cf6ddb734b68f40e1f47e17d56186f8880ad1fd028a8dc894be08bc89595cdb24483709276b7d637a93d27be498bbb26f6f5010d95b52a07a4efa4c991a27179ae31f6a1b7231c8205f49687785543b88528a2db27934d7799e8e9f7e7cf6eace69c2b1a86310591510aba771e45c098f3243750de04cd146cc4e5e438d045109dad3fa748f1d218856a71762fe3db462f9ad87c2c9c15665b620c112db70f0da4520fa23debdb597548e082deb62fe0ebbb9778c98d8d130646ff2a935e11a6eb855ae869089007c02e4a8946e2625aa6b7e38b4eaaa678718aff86b1c6c543fa363d35a1bb8e3dc2014d0204d79a7ac730e5024d754ee07d41ca30c721bf5651cb9341e95ebc7422b23c6cb2a328ff48599158c2ad51b7429bd539e49a725bd54fdbadeece82a9da28ae4aedbae35d4064001b5f31814395d997fc879e058d834b23437674ad14f2ce31b0db208022a468c8783e8ec8fa0d0f0f6efd7d69cbef23b8debcab5f9956351ca26ecb085a8c0b7becadb133b7c6a102f3dc9222914f5d255354df850d83fb7922d0a771e610312dab7309b5d2fef1635ebc6876aafdc10dfe34965513b5d561e4bffcfd81a095ddd10fd01da66e56d6cf6240662caaa92e11f734bc9c2bb329a74b4de4a5b7bdf7cf4def437b5e0601cbe265cd14cb84820b1faccbb17828f57371468f8cc50fbd792ad5c15b3605cb66182a313484ca19cf7858abdd5acbc4e37b112fd8fc6e96eba4c76e1e008f5d4e973ab0c219b66f71ed347f25c1271f5c1156cee211ff6feeec20ae04580a9727e30553016dcc8a223a38d99ed1596ddcaf23906db89d0809d5683f3d4bdedd9e56983b27f69f91691645058bf0d66ccbad1488115c958d3f98868a0869a51f7169a406c82d48ed49cfb49daa884fa2c5459a2acb3a4da0883e3a59d2e6a6fdd28bb2482b3417064104325d8cda3c0c42546fc1e19faa87d38f7e936c866d763f71d4702f740bde10cc5c15490d8114fa341b953b8d628c869b7e7d2dc5a2dd949df3210997bcdc079671c9898cdcc25e97ec132cdf5d77045381e45161ddefcab4d730c9b5f9db407e0863977eace3ffa83832f7e94d594bd3960aa05952edf1ac38373539b4fe7c7118695d76b02b3da06e123bc2c6590e6c2bf1692c053365ef16a6e53745c90bd604e45d830e50c3d34edcc1f98d7bd4998df13ae526cf26251436d5315350cfad9fac9305b6c6b9d91a29998d6945bd8a808d94875e4c7017a491878af62332014f4a079f04d51765ba4ad82c1e13166c97e65eef4bc1de66df696204402caf106e641539c5ce21f1668ac4483c9749ed67029d05f9c6ef75e37c6d86f61dc91f89f93e69a4eba4e51256ed9cd8c360b13323467b83dc26eb277f6d1c05704242fdfa8c797f1de8eb0a8ba5a95150ba2e0e0dbc63807d5ef1d542367e20f41ea2d24088948c52c438c584347c0c7a20ee785796736a4b0f29af65ba7bccec33570c1a3c585e31f115df3980c7721a531aaf4e5f255c4f8e2fbd58f02914592ce82e741ced0edb9e06781642a07e7e17764ab2c764308c0ab0b521da8faf2f67a70edf6e959efd2c65fc7ba3450f2751fd0d5007e6911061e7f24578c38adc26cccced0a9bd13b642405c2b6035d6f7e28f7ba0740bc2640c55a99937608cbda45a9d1a9c6120136234800987d9e6d8b06183ec82f97b8d86de4412a94f5e444aebaa615e0f05210598824008e2088553d3e2f6fa0f3f169b34c560db5e57224c46e44d5ac97ea31981b4de11478ba499bc002114a6531b6d3f760ccbe727d427ecad7eff1f3c781dc741deb407212a1884e57d9951189b0fbc9ae53e489e9d53e622ef7085d4fafed6ad334b0a0dcbd71f6b7a07e16d0ad56f9d1b059ae2241f1d93580dd22ac527c04a98df4ffd3f20622c24a9ee238a58c7add059f0658b69a2cceb9b0a380a5a78f2b493411d8e4783f4a49ecd7de395245e4e2a3eab0f6b88d053c780cdf08da0321b4a7ce52abc1cbd4560625c9bb184454b7e10524d95d6c69f9a028e2e4fd9d5e3c7b65c07dc296f99252d9b89a9c6c80c71002168cd7981d5e9b7082e21d51e33b7826a85dda20013f837c904b9509c62329c8a196ac9dbacc3e66ba462e6431f2e182a67c65b7bed216af5d52e480dfad54a1baa2da91b944ec4b8699e9a7fed0203640abe0fe96bcb1378c2fb2f0d21a75b1ab844832f2e8f8751b23fef4657132f9df6bda1ed20ae65039ad8fb8c1fef86a60bfe401a656cd082b32d884b6a1489c2a890ff2250d2b6c8d33636b1f3a0e06510f9f03aad55b6228a3b4e272e5b16a0b8b5cfc46c7e962521b03a4e7a6c42ba1ddc9010025ecc1000f97a3217d328513d1a07eaccebdb340de51dec74e45adb1c2533b85f5c6f70d0a37dd40fd46190d451e4874fe36277b5ba7432656c4fbf3e7537562cb45a6134d956ad5aa9279dd4e3cb95d3f94af402005ad0ba4564119d2d716bd63a907c1e4ad99e67eb990341c0318b425e1ec4f35009403f4b2acd930aa537b3120157447112e15f0a1b7c72d7fbe0d93d8e500aceb7f20031922754a4bea0063c27cc10ceb5d0735255a38143255df9dfd5fc2d88628277e66d611d82268ad4482ba5e67012621ce92b14a2386e36ef13bb564bfed2cf78240ccd7d9f224b6c625be8861e3377a402730634ddeaa2b214bedcc1a11b558a535cca560ec024be572a1da46c1545f9a79485d0ab0e29b5d35d15ab7d5b1f6312b085f5c1fc5124558a56dcdf4b5c2eab8e89a1079d20c4bb833343e7f4e5326870fb39555873d885881dde92420ab2484cdbf9bcbf3c78cb5694bf989ef57fde0f8f826c5dedd4f35609e3e68d85197d95831f01dc46ef8a5b7baaf5a65466f57b1683a540c5906471d967c864721e3234a713c46d5597dbc2f054ba1bfb7c7b76fbaae2a423e145ba3f2bc9cbe3bb25d87956875023b6f929561ff522bcc5a1b4513bfd8c7e7e6b76e6946d2061ca948a4cb00e1dda3140d5c9e3f4dc383245c39eade9e6e91a3e9a5b8f5bd620c4e95f6f6d6db5928ad5cd707c4a8bf7aa5b6903709ee1835beb174625de59d36875f8938509ffc6992029bb7560c038d08c8576013b7e1c389da3454338a1505bca2d6021e5c1ad427e5f36907a1cd9bd1df824f84635d381a63573b42dd9436e7ace28560af4051e6ccdfd1028ced0531c1f7d8966225e749cec6c01ef8565cab6dabdf5a37025c883929304349a71f0ede86c0f131570931e1fb586ed442134cccae09caffa45ca79d30c6908415dee3059815c52707775c28d8d061d9648c0a80ff7a3c421b88665a9c2d6de10335e8cf9a202c2cda032e217f4a58abb6f8a2c6c4a0a40818e3ddb93e250bf191b084d08ce4a23d4b781efb7ac23571a1fd1bd1884891bdf1423035c011f8370a36a2bf5cdd8f38f5ee4e6a198d092a2ffd0469cadcb77657b137dd23261da3ad1668c216e840d1503e25c0acc45a4cdfc349fec35cbe49ef0b1aff2f33118c75922b7473a575f9991c20de6c664679fe5aabfdc9a7fe6148e752ca6761318556d85cc73440c9547a3cdb579a9f79be5386d379f22b8fabd2e277c9fe9c50e0bbfa30a44c0b4a421efb7bf2a933b3985fda04320d83ddd04d035f41fb16c4f1014bf609d77d2ef0138462ade9b2edd687af1d89f84f83c83fa1748d212e8e99e336d3f579e941f3e12f07c07ff8aeab4312f15232d496b437c9c7e9f184229b98915822bbbe693c2ec66d222d3f903987881ec9cf91889f77453935daaeb32dad3cf6dadf1f6dbff2c0fb6a067136eef82abe11cc4ed8dd1edc75b9b7a81d8093a5d4f7e9526f05dad9c0b17968a59ee95082a43a7c6320b0df3f2bee93acbee059f7ec961cc46d18f55c394fd70e5b780ef870740398197cad41317e764aafed711f1ee8c1aa8200f7aea0bdbbc4feef8382eeafb37fb3d2c7eb62c18a90ef33664dfcded94d5c0eac3310dd3d3e142a6442aa76b68fb309ba3f1cb59f616e4289082f4c81bee1b502eea896aa68e2e29671b3b14a675f8f6a6e67119c1f3900dceff32582c9554488d188dd7693e2406b517a0d40ce715a13dd7b01ef0d3b3700dfa686916d6bca9f067f67f8d756049b81c0a9d2cf96da635f96f84b96eadfe028d255ff4af418be811d925673928fa1708924d6c91ac4553a01136aa4c3ed0a7affab595c85d02d0f1b96af860822cdbc58d3af4accfc162ab08823785a3d2cc69fe3907a12decfc7df88d37bb78839389df5a7f899f9d6a3b2d2be8e30085fd6ad49435331dd77adcf9ad5ef17b3ac486956bd82818ac2fb9395603e4dcb027dae59016e8696b2603e8627f5c4e1b32f12d778dc32adf3a5da402651821842611272c630a3c3774969b68a3936d84c668ee7fab9199ec2c7601288bced96a7432c660a27cb1460c9ef730c70741c3534e7ea901243a5c0681437fd189c4f3aa2aa70bcab6942bc87a62c520671dad553d61c94c85e288f36e7d7c20b01b624355b71d9f62b42cc68fe3122e8524015ba6d47203831d444c31e2e79070fdf0127541439f5cc9a3683dba5e0cfcc2cc3e92c3aaeb80df1f2f4cb8c3d26b10c705301772ca2860ee51869b8d9a6eb9b33c7a9756efa8bd87359df77807632f42bbd915f87c9d921dd8d28d4730857fbe14d492ece5f437f3fa6e4ccb75294aba982111e594c039a2163eba4e3d858c35c45b9647c2eb6b01337accb3567ac6ed7aeb41c98327112d2945f1bdd2710d2a3611c8f3564e9c75c1e849200b9a331c91997d3aa4e7d6844bc09ad543749c6cf490091352bb1973d49aeb735cfbe42243e7300a1172d60e4e205463338341dbd02fcc28bffb374283d9aab9302119338390937f19ceabcb791213792d37c4b764588d2048a99c2007732c808c4e98a67d7714a9c5f0d57276582296be329a0552cce285368cf1fba03928b419c14398e6d67b89d5da551bb42c8794d639f01dacbba8b3e7b4f1a2ab6a1b23ac952fbe03936f3143607a19f8c04162e6b955f651bde6d2df3e95227c24b694a6a9d226972b6aec69e058ebacfd73cd9028052176d13f1db7528ea8a30e1769cb62c3aeb9cad61242577e4d8ad98373e2aab28ec98b3321a593ed0c23d398aca72f71b3171bc3e7ef93adf47536f2262775e3793a17f45fd343868282bed715d06d65658d6be4f131152a27217e0b3f1d9ae7f9566cfe6f4e8aa82cfc0f7ae9033ce9d09fc8ed1a24483fef25096e15e2e6d1d19da2043238f9d5435cc2867ce9d75d93c40d2cb61fc222036161e73ba245f31f2de2fe515b47084308eda5267a1971b1204abf9b1b065e0ecb33051c70bd70f080f834371bb161721dc2f6157c66f79d3d4bd21a28553c97c967d4306d1b71bd0181ea00045e70243e40ea627963a2f9fadf7835f268eebfae71d4837e8dd1e2f478ee82ce3ac01ea90b6aa4a301340cff2869c572f7802a4d4639570eba0ba067a1c2039e8b77097bb20d59e47a7996a703f2b5343fe441a746012cfd167e28acec3a5dbe2f43859f9e4423074dd1398586f7190ab928316f12c0e0d034acc79c48095324630b1eb9b4e57bbe9787139b4b3731f4308738eb3746ad556904a6e03922e9849b1361fa19f20ac9f420ef50a4c15af7fa8c9aee191fb38c5af6e8bdc12108e0204fbe63b9293d3fb97ebecac0556c31247d42802b48a72a7a04469dee9a13b62b91099665d5ba5cf057d9af3c1f24a2722a19dd01338b7ff2e33214e353ccac963db60166b04922c6bcc29303bbe2c51d08491711c53078e60ebaa8b24f1ab8c256f927d13657ae9cf270b6e3ffe501e7f1b06605961e2775161b37b96a45226cd39bf24fd43e08509e06e0e10d2818ec575b249d908e7cdf74b70793a27d64d4e896fe746888670586b482a113143a5d59e7de400ee6ddeff5c15fd2e575d6d3eec6141cf6f3a6fec094bfad5b0c07dbe7b2ab43c0f5eeacf5ac802b9c522874e8133e37bbd33fce4214fb91cfc3ab024fcbdab5ed5370be6f7ff960b0dd92bd1a0cea0035cf0b19b30ba5fd51276fbf72f48dc7970e28910ce55bf73912f1c5c526592d76d9e938369bebd6073c96a8a559fea214eb3afd01ca0aa0bab51fc8014b28ae717f0f93378d8f71b7d09954c21de423afa6f585d060aa51b6bccaee5a4307036681fe7384f2963c4a5cb169f6950cc7fc91dab5c4c7e778d40e7d214e2774704b9189a64f21675dbb53c8107390ec8fad46aa97c9d63619400d3f59678f3f29c799523ba84a14c5b9e20b16647b905499bb86ee15329e691916ed6ae5fef4a835378876488a9e183b103e48c7659948881fc886d79c18d7b368738023dc16d842a24033fde3534fe11cffd24e392ac0c7652daf30e970ec2f5c4afd1c9591b8dc148ca6656418d2ca2bc1605a3619e8f6c85263ed0c2b63ed3228ac9a1ada00640de4faead7084ea259997e9b68eb0577d719d921917a557d416f2e616fa1df83eab151ba8e7026ac7a022b2ad07e2b79b7c5b6bf505d29f923af9068aa7c49479a4c45d0079bf9990278cb38d33b79f993ea4c14b2aed95f37139f0be448ec43b9f7a6e38bc8d45cd8dcd2c80945cc8cf1827f6e73729ac6a3788c03407b564875b4102e6fa0542282090c208de3aecac64591b24273729903624783fa6d7af05f635b6ce6d3a3c38eceac3199ecee7dbf3f62c16e73b0b266bacccf553c375850a84282e89304e237740ded1f98cd97230d376643f02edb30668887f14b8e800a089f22f3cc569c3085e0e3fe78b9592606b2d11333073b349a26cacb12a8da465f1383a9632a9242daf2253ed620948b50743735aaf5cbceaffa0357135ab471489de43831580497f0aaf4a5d28d7c43d93690baeb5026d4802eb03747acd7c96e13b912cb942dbe547f79f89e86230e12cb2be1d12b5c65ae720d5160b1d30814363707ba61e6178f5bda9f5d575bd8b53f330043f2e8cededa356856774ea598d367ceb2f35208cbe05de9416a6bed9b2fb982026faaa212a97ea8732bf8a947c9444d8d8eaf60dd80acf3833328098e618dca03b1b949c799f15a3849bf3569187cedaaea69485587437ce6434701fc4d920e4662a4d73dd62696a92feb601750b3e8cd821bb63a327209415d2ee1faea16cc76f73810092a0d159797f959310e1c1c8fd8a7a17af22ad731af242e0fd711cf2fa2a71ccb05b0274dc0e95bb3a00586185894ad13325f794a4db1990f78476c66326fe7229f29004fd8f08c8fc15006daf6a557f3dd17e52e9370679fcda9bf5732fcfab79c98f9f8eb1ef95c60626ea9bfc88c1dcc9ceddb0f87b044a1fa4f573a532fdc8cf2fb08515413b8018484d54b3d6e137db5c2dd3d050a7faf18fe866a37457f0306efe8b08d0681f7a683d0cdc118c8b8f7d44590f1862f9c649e41855aa6e48bee0fb3504d3b21f03e12a70e3ce107f54b9eb2dc4db7ad228a0feb7083baed3cba719d502fdc78b72298cd9eaa09fb867ec366c56589292485f72ada2f22383693914d10dd01d4b005c4516e5818f5c83d8b7bf5a79fb973e58972b29b88f6eefe8f226bde6e4bdd0a030c7e9911012412ca3621c53fe6a91458a4a3368298d33819b53962fee74d0aaf9b40e37e1095c416dbd719ca5c494a11424d08b62dd535c94816bb5e6b81beec3d0c25bb9e2c8f868a32b0069168a778d36385e76139c6bb083485b6e6ca4d740e72be25c1e4ad11dfa9f57a3db70acf6c0315c4b9d52d34f124277e07a7ee9c5338935e4c383f964cbe617cee22d5f56ef85d3d38e8e44b0d0c50edf98ed83fb33f696b804d40cc7e2b0a167876546043f046ddce6eac1fa6d68fe4e1a21e9c47f93039316138154047a365b6e472f6a6ed2fc92860bfbada0ed0404f8ff8046078ce011d5b9598bf1c9a7b67fa6d7b370159db5acb3e5e94be0d36dfd4e00fcdd1a6aa96f2172ee1e89001445174ee37f69d70de7fe222afaf89e67a2d157b4dce676c9b7e9bc66f23af1651b63a52527221e891262235b1e9d5d9223b6fd76aba3ac3c3f19df07e82ee0b0a28efb4cc90aec788adaffc714ec10c7cbb6efa4939e80724d4522d4e1486dab6bf68a3cdadc88b2f7e7d69bf08dd42c67d7ee509a9dc91445fcb3ea7e5abf05c10fb83fac11f206878b8e7a62c47805fa467fb4307df83004888754a56ac97e75460171c85acd92b09045a29e907b85ea77699e546cae812ce7332705779543acde3a58dced31bd4d47c8f47297147696dd7dc0d3a61b4b6101a59f3ddb65c22e7bbf8e09af168adf402f3418ecf6dd0581c3392e2033ea07a056f4eda10ac763bae13c980673b515c46f3f2184106b4389ab8a944b84914a5b87c185b9ffea29c390abdcc8cef6d4cb79f88978eb93712f7b16790f860360bda12500ab1075d92c65e6f5f3787ca11839aff0a53646a2642ba86d2ededd34c0ae7d85550861114653cbff22695dff7cbd0be6c641e83214384f326dd9f3201a1ec1017c440fa7887119b8aa796a7aa1fa957619093440b9e35431fd8604a3588ec6960fa7f7f3047862963c43bb85c0afc5a0aab8260faee243245366393238589880ecea76110535b562174e7cfc8ef5190ec44256127f8ae1bb3b039586ef4cd017275bbe203147317139ba37e5c7976c324b9a246a3c0938dca8e60ba77539f664aefa011333b2e7b43c99a4839b4fa00dc9f1aeda00bdebe0fbcf08c055a957d19af24475ac6c6d3813f1b42b31d15ce941a95a0809d4f374f86bde6d0792dddfaa2ea164a0c0b9b265f17308d43a9c178cd92f1f8b52333089314945e1441bfc39dcaca6058d8733deef4bc07e61fcaa2fa87fc0a18aca54e86032a49a12464a5adb1602b1876c0cb29f836ddea01e12a0b3755b71fcbc92c6492ab650d9fd6862f78f91f76fc0abc611cbf039806366119d35ce297cdb7c17f5fed9d7d10a02c388023d622f32961c43685532ce32884387932e7156966040c386fc4224b609790cb9a658cc0bce2205186706a471ac8c040afc343ec06b6ff5735113b676099b88ee204720299e1af3aa71f2a5c9f2b1ceec45dbc6b6f70d6522de611e17f7ebb6b311a950b479092a5911b808d283487f14ff1cbef6cf64444df5c87f6ceef8dca505d09b9c75161eae553f8083acc8ac04726058af49b80c08fb3256ab8a5792bf9f4e84489c36cd5b72f9b95872f75c2a922582a32516e33bd68b53245047fa050d4c7b1a7372549dace1fef86c3f18f0666b38297bd817f14e86dd0a31b9c9f0ee7d43fa71324929a110b741d176c69ca4d343b456b79bf6e8d9d0591e94052866fea0f017c8232f95ff0b72dc3962e7fc64c021fb77cf363e8f4a454ece32a104e1c351b21414eeda62e8b5b9b1e190494e8d7c3264a175bb0e204b859f544c9ff7ceeed8b32ec2a416f962910b7496305ad9c022bc7a5bec1dd9aa923d2375208e0fd9cc2067e694c96452db3d34df780da34e9a5180247d008e92f681a02ce8288eb2743f71c3f920413a69ea2ff039de31219215349a260d8c70be3083396fb38ddb16335f6a79671f0c3c713c258e28e0d6c219149814273bce2620b22e7ba16bd3081ad3eb6f0356fe1ab54ea01d2137837c9f67e5a3951a16ed071c4ce65113404f751bc0b3e0b006eb716c611151f1f363727d523b08e322420993ac3b46ce497de51e96656de4985375e369c3d97ccf7dbf628c8c5ee99be05b6e5e8c3cd020390ec5c11568ed7329201a3f80a14e90d32b2ef0e70d3173e17b79aa3d21bc52a32e26b969838ae8557226594594f8c04b35ae9c7b53c7e56d9118f36f276d632f6b35a73feb877cc065f264c88406a29947ab8f1a8e0ff7c78431d75b26f645a1408633af1bfcf77606c0ebdaaf789bb44254f33561a292e6be08999c69ec1f4020e929d82b871b1b987887ca5fea06eb3eb6b7a406da3e6c8f1366ed357306d0309c67459dab41bb8400a012ee55b8c2ec2556177bedeaf141d076667e0536cb168e52f9046303015235f3c26c1901681defbb9f714780540fd04422f29b65dbfe757d6b4bdaa41f2e8ff48b740316c93386e1639da30c7364c345847ef2402a2c812f1b265f8636512b195014e0e8f40d95e50a77f0efea972725fcb5afaeace361a20ebc4e5bbe10798b3ea39ede6df8d529c3f9782b16708eaf586d5fb287d50be7829dd71e2d3ebe5344f1a4b696498fb5e8db82712257d03c07930846077cc29537570cb46fae85cdbb0060ae21cd0d73cdba9f0baf8cb0edfe30e8caccaae35599ab7af7b2ad68eaf7af6a2d754912f4939e933ddeb21243e196166802cd1979c45437d0190475af3c126d9af2fa2748f63703a1eb9120287f8097b60027c4268e45594bc6568511bbc34041fb3fc52e62a2ccae55f0986d0729ea550e038db552c8e1885a67d679e82aa11b4f30700da55015370234798e7beb12d754f67c4ad411be351e70f0d9881136560213789ab82a101844b0a74c28b0ed5dcd33bdee70a1750baf5ebb224d5a712df5c00e54ecb19cb803f9c7f695c6e7a4f007d8e3f6f1e152c1f023e27d854216d80d31044f78d9353d5d80999a57141722622594cef27748025a485e9a7c3f9f271e38671729abf708e745f32c94954b4e61bba796bd255113599177086a0e753c5596dd7e166a1ebebc683d335aa3a14d0db8785d25d09dc8a9b4f56e2ac5d9468648bdea01796370585b61c183717d1229f2bbacb50e00993c1f396090c0eed3aa76983dd9fbe65a369aa9d09107ab87e8757e6a3cf15fd620347cf5e69f0f5d8cd0f030f82279ab7022c42a0b937c67e9061a2ca71d2ac63aafe30fe59455d1a50239a82734824d6dc30cc966570264e87dc1c940fab98088af5934d18a02d21fb0833adfcac4d8260f630e6f1f1a9ef119be02d208bcf832a5b971b8d0557538ad8d73ff3823459fc68fea67592bfd48871412989cf24d0b41859f87b84928f56729272df1b9a3f2b8047bd98d6656d64ae99e5da932857771606958a6922cb87c9e3692ab55acce16d710b2050950efab2f3a25d5c20caa9997019033d6853c073ffa3094263ed49b8031f7c2da783d9d249d3b90811469fec1c6aa317577c1f50650888485821e40ba3fe71c9448b31459a3282f715607ab7fd284a0bc70e3c90d60443cac70eddda765d26f5c67de386d10b95624f183941a9e9190c8c7314ed5715bdeff33817c4b914cf9f80a3e10e5878cdd1e36879f7279c95e9b556690b88f48f6b370206cd8abdce3eb215bf3c688773e4972926085a10705b9cd4706e326e5550455e19e75f73163641d61daf9bf737bfa01c59b2486148d53b0e3136895d8209b29b6f80d516f08798a264163caed4fef39fab96fb2613b78f577856a2a9f0c9af9aa0d961fd83771e41d0e886683980025f8113f4faa52fc4f80f582b465924c97ff5030da3151c74d904f74df12015d3f053f609f181f5f3d61fb6966b479f8334a6e2090c329285c00e10126f7a420ce8396234480efc7c10f9fd2b8aa00552ab5a58af567b9631f625f9710405ee944b51c941c2723ea7723eac7c37cf2db1e0e4bba171d2b960dc709c18d94b0034aa0bb084fd7c01e7e11186e610d68907493dcdae6e4ec49d771b8e80e7612c8b578b1a7b77ad8dc01037c3d64bb85485b992b2a74f7785cb96d536f58f882f8c9ad6ea41ab7d88c3c4f755f65ea268f6716ed83e940317f7eba2cc2e0ab442a90b4d1dbcb5972a1136899fb8ddf4e3a06d14edb7e46cf870f2c909b29dca63456a245b19281502abc850ee4fc8bea564f2f09ff7ea743b35392f237d3310ed0dae8722ee0cd6f5d70a8b347d9139c995d5c9fc6af0145a032d3832087de96ceb744fc9d53313f2ecfcddc245a19818a9e2f645e84f9bc4a3b3383394d9ccfbe87f3ce475c8ccebacfdd2424e53b9abd180b5fc6e58ca3f10ebe36baf051403f998e62b901b944197c59aa8d35a51f4a4537cdd29f99bcbbd2bcdaab9730782b3b91d4ca508f1663538c4b0745d648f1f363c43427492410fa169dc7c33d67ffc7d9c72567474764538288bb84ecb72f1fb124e5e1489016d5008f9ab92271e3c719bd077ec27740c8c12f5bb2ecda947290e55133a9d30c27f37f56a3ece171e6acca424a9ebf36440f1ea2330c0bf9e87e499bb8b319c397d3295aee3e7905387b67efc0dfa576c97c4f76e416f1bbc15918e5c83a7af3c0c1ec4cd80cfa8b540f3160efe3386f638e18ff62904404f31e7ea67856d0a6d2a2ced3268eeee9e3a990c5fc2cd38bda223d359cd80b780da9a61c73bc9ec94ea57dfc275cbc9213ef19f48b9004aa34ad4acff85e411ad59e581739cbfc3864ac643478c43a80652f64187a38d02205e3bf58870442733f3cd06dcbde55fde8b26937f466f4eafc31c26ab999438de24268e4d2b0b9921b0326d6460ec8e288fbace7bbf94d9ca76b83fc98e2b5878a1b468fa72b06d5986ade3687411c6cccc783f5db30ee5b5b4b48778436398e78df6bd77835780e27a48bf9f93d32a9e1eb3e9c8b23720a8190ed744935aa557d38f3a80de71da8fee5bea0157d5fa75668f132107bd8da26fb57a5f125063ac2befb1a6bd441579575f4398b118155e89e2f3f7eebb35e571cd82c057c15980f5d938b24c45c8545a863e8a732d4e62d4d5418ae173cc6007f7a15b586c952bd4e8c54efe677c88a28c9e47d86e43ba040d21ba15543c2f2a170407e66cb0c194cb01c3d3a7015055d42294356f0684f793f733dda2bea2defba0f2ee11a82abab7a3bb13c63915760b3ba777ea05749cc29c835326cc217a781a9aade5c8b39854b46caa244515ff5483e9504cc3cb56a4089f35ad69e296b883ddcaf9882e3db8987113b6cdd1c2806a5b2a37da58872f7db6ac4cf5f7172d5c7f385e9e4fcced303975e1332a41614da6a31ada735d9481956a0ffccfd246ffa3d7178c1650103f386afafd9e244f62687be9f41a88ad13ad88d45cec275e96d834aebb02d72648c0704fb7015b81cd22f4843924a671b56bc1c4bd23ce3e780bda1062fece9b2d41c2359ddcff01cc31e04a6891b8e78517dcd5c2d355ab7e6f22bfd8367ec430","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
