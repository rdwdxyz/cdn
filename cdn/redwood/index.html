<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"145bb13afb800fc5456008c3e372b1041fdd7e87e86788fcfb4dbbd43396decbb07c9a7726593e8ab27054dd1c33bfd3da932294688b45f42c5e93bd5c06c185cb65f5bc3d1d5401d410bf02af5f3c28fba03dd94ed281880dfbbdd6e67d5a330520f5346965de1711dbacf3e1a08b33fbce98726d9c0982030ede27d1bf8d91420d5d7d14336091ab9f4e2c1cd9802c2992187cb366adf56d3c135579000d91cd834619b37ae1c0d95a242fae9612826ca31a57029ec73d58f4cd9afc135ebfc417d2cf5abbf9923c2d770915159000c26e57881b19145e77190a63236f70dd077cec755879f9b62a51df6e2ed1a438c6130ac86ff3aa8bcae7f7690d51c3d2041887290a5eddaffff9b438f170ea208bd16c924fc70c98745a837f767660b7afc312e7d737c5a493563dca0758e8fc4bed626064c399bc5f148c70c80550a0cff8040cca3b4486c634d76d93052524e27d6d8233816a047a31ca5ac469bf07b457ace2ce5163e061a702ae8923a6e6a2ee64560afeaf884f098c87647eeed8e9de7f12188ac6a621cb23ddc3e5e8753dd3b98eddfe007fca15b5e1674ba95317a6504682019a6b116b4547808cd5b7864df3644fa9b6a92e3603a8bf9dbe240e22c018b553bbe14d8cc241e8700bd38ef5870104529061a8324f040b5a3013ad099608d8ffeaf03b49300898ca0a6c6d19b325692f79edadea5bb014914e7ac23228e695f97ae5ac6747b3f010454ab2aefca19e4869e1eb1ca7f7cdc0c5242b72a7e26021b93b0b0895b531703eca593823787ce2ea86650676feb494ad16410a4e4f4c90bf0147e6b2a921ff49e19a18109f732b8b27e13aa3bcb6a541256051dd62ea4a8958a95b4832e75ecb6274796a8acf6c10006807acb24d276fef2170ccffcfeac932a3cdcf51f08de182508928ad40996efe91e1ed34a4e393aae79918aabd2d2b912bc6c12ca5e0637356284da7d448e08cf0fcbd547e6273f2541a143fed3b41d49a66d365eccea206d7796bd7058865c63d9ffd3440d5a8530fd9479119f5a14ff950f4fb283c92a28549a35bfdff9b46c9f926f1ad5a8a9c070fb5557920435c08a30e6f95e5d85fc7ef57f3ea0e2f7006fed235dfdeefd8e1499119e6331f3bddb310dbb21e2fb5ea790dab51f138abbec70b41b5770ce692d1270b0e93bef474e3ca15c098142ae7cb710445e24b0133d60abb97e446166bf1c135cbe55c9196cb40de0424ca342a3437a981f6101fa855c34fb7a2e10313a15dcd562032bd767c912f73eab16ce99204d1fd57deec30eba929b1172ae0e0b5c6eef381814cc26712dae3523c3e5725366bf09e27fed9178ef24a69755224851f363d699a540cf0757dc76b4184cd46bedd86579e5696a577bdbf6328765cd4001c0f958d6f57c888cc8cfbb461688aab9c76fb62cc0a7c3af614e778a2dee6546c33192308fed5e142ee6c700dce3a65b7e2efa968c48c6a9c7451658c3360355720ce8d8169f03d95e5cf592ced8d960d688886e48368b7b5b8f58776a7f59cd5c9a0493692f6b4a8c1c492d3041f961d9cfd556b3fde957205fc5ea3e790656a2885558dd7abead3aa44fae4a36464c54602034aec3cbf139d79cfb0bc7e8edef14bf5bdad58eab631a5009f3a15e4139c722a2cb79c760d328364d9198f9ce6b4f096a77f3839ac7b5951a113aba3b7334b02daa6ccf598b89388660d99848836c7b534b502d719fc2097dd5b2d546c8dbbc590c3ec155755bb47daac63d7fd2564c9cc1c49dd019acd32d326103549552d1cd3b5ae330e7856e0be7c7b09ccf8abed12802539acf47c17c1992c5d26281ac7c57d8e17b0e0ace9c0eba3dc6a2f05af8983ceee9cd642bb776b74a5365a5d569bfeb110f5b5014655a11573da196d45796724065e056f9eacd8f5146a87e47f07ab47e9081f4ecf84bc76d7a60dc78e41dd183679519d770f9510800e50144524c11be9920940a30adae6e2e4e2bb3be492d598b2e3b24895e9842f0d1f4b92b61c18f4658e415ae3979956768620b5deedb846d86d62dc78164601bd7dd50745ca69ebc6f3018e14164127b2b062309c86c1a3c281d66788c013ae97ee6526d2e621d13c101b937cb491cb3e0f777b0640ff93a5965c08630fa4bbbda9a3945cc2c2eac2a8f93d63e3dec5fd072b4e4709e40639031a130a4081c6d810154d399490e92b411c6513a290e62c1a8c5d93a4ee262ffe09cb39f58bf65579892bee1e2379094a1b4b760e1f592a2f1b3c573d44413a326562dd37a89ed50794e30b8dd0ca1736360306dec3712a56312aebf3a1ae17c2a5c894e057dd06eabcd008379057aba39aad222182fa932423423273a65331ac0cf64abc0f0431b539a660da7524b5934edb4a215d24aa89e21d0d7109e7de0c264406f76647f193ddc96c384ddbf933496db99d5ebf2bf55e1b25e1d4d77909275db6b2351943aca92fb3cb65bbd0125f2e1ca88dc169d696e053931d81e55f01de34772be833f6c60aa675081e261d7eb94f596c313d8d6fe60d153d4a50749060a6e22c48af061bfbc2838df42658ba2787ce4e6d992f8b8cf4e405275c7dffa5bbd69684e4fea89289696e96bc4c8d8510897c07d4492de5bf1a039a2df8c3f4204d2d2074b3b3ad64a6072a082d87340b325df48e0971697ea2cb93916fa08c1184a4c2fd3ef3268107fa1f7d095819f1bc80fede6b89ab811e297a35815ae36ca559c8c8a010803cf57e2f204a1f607ee3b33abb89a3d1bfbde545cc4a78799f962554a7bce8ee69edce9d7fe608e675fa6f184c2f72306f892dd66d1aa863b019375e1378d8481bdf91bcb40f377db585ff070a018b71f21e2a9ef4bb5ab2af157158d58da2eced8c38231197e2cf34dd484e0a0505c0cd17b3d56636fbb6b0408eb598032f8aaddc2ff1b3dacfd94a3ee3788090775e9141e2ce82950911db97c58301f004e4e43baf8312ba83503289a22088d10e880feedcb68656bb7c248b85c5cb15c8f5a9fbd7d26c99b8fea8041e5df234c37b7ddd81de55d9596bee4a064321e15055382bba5701dd7f6c46ed9c7958d248089dcad36498bdcfc4fd510683cebc8247df423c7360a6defc355737d1292e7336f359e67afc94734fd16a24d11295775283109fded9c50d0f843bea817780db9f69c1c5280a1a1794fccb2d03724f19557fa3794b4017ef5952ac1d12679f42b4efbe1b94b552ccc73c2a82cae3066d9cd554d6bf8cd0a4f20f9f26838be9fa304c8be55e285aef12c0f4d15262d040e2a9a18d54a864d8c3cfef9a55a74d622e30377bdab622064953dce5781dc23433813161a3c8b2fe77235842361b0e617acec55bebaadb89640e6f9f64c34980071481aa2531ad51b5b603b4b2acca4e5f8333158aa33b17dac27ee68328daf310d719a4e055663795c5aa1379346afe24058ed7152d39310cc3d497c7eee974883488453ab8217162f0b5975c595ee8321af1d6ea1d4869b32dd886e413b7ba85d3ecc61a8d3e751a81937d43666e2202c80dc4a615a1eb005c20d9c07f16a14b5e7ef2b08106a44162ab6551d566b484dc0a3bab6d7c48ee56505ce34bc30be6d108213818351522950af079e4bc282a97a9099e5f0efd0039219a4f70c9ed098bed0d9c16f05299ade376f328dc73a36ba3c954a85554470dea1cfa5f9aadd730a16e29afbacb28b9ee6654847ae1630e8bed588a63ab9a7bbd03c16a78c3796565e14356f3c2cd71501a4c1595317d7376bfd42d71a510d1627130b7471e6e2d51ae90be4b84ba4caa62caea62a3da3f879ef60632a0e6e5975c4174b66371b4cade52691e0d1550c7918312b88fd40e8ce0e2bd0ab0866b20d518bf5d7c93cea6cf9fdcd1693736b42c53e7f0e379ae9feb7fb9a9a3af736a0fddb2bca1d27cf034f0bbdea5071bd22fbffaf830f1c3cffa99daedb13660ca1256a8b3473e9d75f6e12a96170de771cb656757110924e42eed7632ffb21390e1c239d7542c2a92863395200fce234041de32023e495b8dac5fed3793901ffbd2dbe988580a0483d4a86a09e029f5d3a4aadb299f8750f7f619ec4a27541b745dfb53bda3cd06692bb1222746e24e900fbb631fbb0fa54612e2e17319dd62db54dcaca18877ce3f7ade9374fdb5b7e6791be69f7f2999514a41d0a9f24e6146050601c5ab54721f599a4ff84501e83c6bca207f4187808bb4073e628d5854e7d032a0dfdf42b3ab4f2465feb6d712d3ca14cb8a0401d7f70569dcc9e0aef341194de64c41395739612a201e2f3bed5770fd8bc2c261db48236403eeb776c9e6b809e6767263d3b5b5d2abbc8d1b943921cbabd2f4aa6090104b9d83798784075052c409093a6345af8840b9b1b4cc09fe85b19efb4922d7265fbbe49916fcea17b9be75d7d0bd9bfb1420146b4e9a3d944cb00a914d88eda4aa3dcb7a383f26f91e0f37c913340b473caf3279a9e2ef8d623e843c7f2bc860dbb4f05ec2bf373ad4c6288714e90cdc671d9a543e735490bbf3a0c9423c634add2593b579af17decfa373c8ca2e262f15f05dad0020a4e0c62f4196615a92160c9ed7588e6052d80ee18f574cdf9f2135124d794d2faa26a2c22e8b8318099a5efed7e94a78f4addebfe731a3fb7d9209c373784c3c013ad7a000da7ff7177dcddcf12746d385fd10de7a77471c1b5a2d2d9fbc1769f78f48be3f013195bdacc56c034d11e1151473ab59c2562c7a2d1c07bcc42a91eb605fc6bb6d8afa4b5af7b115b83ca526aacabfea1df151f8c8fe45947aade4aae5d8bfcb75700dc6aae790aafd798ec5829355342544814aafdfe747994d22a4e367ff58f5def975c70684a54c230f34b9c6f6aee5f0483df50b95ef2534000813b605b4e9e2a63764f5bc92a04e4b4c2bdd1bd103b535a02a8f816ed54ca1584d087a31c8f2743e23612b38f3afc3d9d4177b409e6ef48a15ece8743508889edab661259b60652724d3f14f4c5a610868488b87685091eee7d2f53920a28624c0bbebddff3efd9559541a5294ed4b074c5ce8ffebd7087b3cbe6a8519fed2fe0ed5e25ef227eeaef73d0b0fe383efe46cf63eec0261dc9d7d3698a4b9ef87ef9442c75c30464174bf10bb47d577482a0c70f416ec8daa90d3435d4fbf17705292daecc34aa703e1c1a3e7ab161a2608535fa9374408392e042b4eee0ecf4db0519326c7dd582cda86805a54680e40a57ec3fb4f87f5425c65595859a8a0bab6730fb2b69f7a1865e50eb0322a38bef5ae312ac246277ddb7838dd8182ef8a656ce1c887c011c47b3ec9e01bf5c684597f8e0dccf42799fa3a743adaf3807cea65f4708573907c57f758ca9c53bfb729bf036b7993e02cb378845f4f5b5b63bba6c2c066af91bfcb4fc7c16f52295ea757ebe4880ed8ed3d8cc1c5a8cc286e058d8ac5dd586b77fe3b44dc97124f1cf8650172ac76ccfa5af4d1eaa3488532220043100ec1151ad0264355f03b697071446702aacad9bc35ab8a59a12ca1762296c6a4989e9f2d584d1c43a5f2d7dd0f708d10bea0a9d5b86f39d24bc86f4f869102e2eb19cea5b8b661fa5af96056594fe24a63d19038b9c1fc3f9c9f05a5fb62e0b5987468d0969a3c5ce5c516d4e09f2683644981756260391b8da772e047fe57d61018365913651c0b4c60dd948e3c4031ba551280e302b9448d628961a2a42fcfd0da5224682800498d964fad5fef7e699a9e692b0e56ce90839cae862b59fd903be17c0d03edcd6b7b7623b041d9df3d1ef6323be9b79d44b5fb052ddef294868505a90af8920e2572eefa4a7bb1381791a3836f5a3af11dd8f3683a2c37abef3c213ce222a96a124405c1cb06633f13a3ed745b99ef76739e81bdcd9e8e93d698c3f1fed225599cf4c358053d75721cb7d62329f881f72e9e3e6aa279f4223b31c464c2468af48521f6dbffbc9d6981c480c933354879a541eddb87341f4ef698dd214e529ea6a4f881c421a0f2a31f4d69e66e2997be513e610df5f9594877190b6753ec141388d701c986e27a9e4f600f28dde4fe8f8d4ba81abdaf3525bf78af53be91e61e16d182a8d2b394ca3a2ea38719cedc84349627c0bf048961ac1e1ca306cbcfb4699d771606c439a470c9ede87a7659be12a10ee365c4015622ba083b3ac7f10adc643c91e9ef2d3780b084d24438f3531faf3f2d31bc7e88275f1096b67a52d18416d7cefb32f096983c832292b12e482ab52f2c747ede556b6a3ce8a07983f755194cccbedf83b3a8d4b8745cda95edfb54f434c41b395eb250277833dba66adf5a5c0c6c1bd1e194b3bacdab3293b321adf463c7c89839552c20ac8158827ff54d623ae36b388663513369d0002fb63b7c806095413564706aba67102c09998b7f5ec5ac7121511b75827b85b43cd2404284f9aa1f0ff6dc8e707c982ab496ba69ef28b9c7d234e00257aac9c55020041a812f77238e1a6c3b4dbae8cda060bba0b23c8bf847dfa56a3c3e3513142d3f720738880db6278bba808831e6b63513226dfd06e3c5e8dede49cb0cb68e20507a3305edd10246aa90c4336b757f7994e7bc83657e1170445dfec1a0f6761b3f1c4950009cf3b28ffa58b6cfae90534e39a52356ac3e068c9a3fdb6fed315dd8e10e273afbe6ca9ee2db2ea8e10d831f5fbf08b786d9959ee6f9b97da17110ff679b23d9a113c452a134bf8b5a6dec2f906dcca88aeed36c027f1268130536a41d21e86d00e70ec46759ff961b93204286f45d4432e00c651a4ffbbcbbbdfda94d22904b876658105b0acbadf37ed99a458242c0dd930debff5a015994d0fb79c2d6ecf87aa2b0f2da0ce017bf94d21ddaabe90e9e511ffcadf436cbd225df89c222e393c695d83e1f41497ef3db48c6b0473fc368b8015d9b60c0b41341149a20b0e649fa2ada843a9cb6adc776471b4ec233175f74211a002454db293dd5b9b12a87dd7f0be475fe26de52f14a41444cc6469341bc2163e1d0a761f149f572ff937b653c95c6992b420f79822fa3b08d24720865f3e863e468d37d3b0b66c823d4b19f132046d4b1f787ef57b41ab7a888c21572a9fc6bb9fe274e4b3c01641f4174193f6cde85e12fc4bf73d2fe6ec23477b402d6993e6f07c1265585d3a3d84a98527f4be764421586900fafcd0bf58f9345974a272005afd945c91bf2b6046cae0f84987ba24e08e03a22a4437ee8c067f2791c9d178062d8c2aa25869b0cd83e1b3cb8d3feb9bd681ccbf848ce44216b5d4219e48dbf5471ca388b80e39282bfaf873a4b200d875df64e7650367e1b8afd0e7e40e16ee7b5706ff32468ff314517a4040baef34038f27964f1969f80bfcd797d72a0e99efab895ef9284806a1e462cabc3272ece9addc44ababaeee74d6efc23c58b497ed6a5b54f36f90064023b73f88730fca346a532c1f388ccf292f8f8dd3e1e5887813642913a8681bda71f998aaf14e94be215de8473c7375cfd7b02b8a3495d3d173dba26f0fcd1f871925819400d8925d53d199eb92d786645737557e94b4826187625dca8e77d10cb67dccb148cae255d0d87f0db108a0c5922ce9456e69be1711c357b0c7dada935af1b0facd3c9d2092f5e91f24c966da7e16983ac45a0ea978eb672f3870213de622fbf50761bd4d40cee0c65a2164dde43cd0ba1a1f3a239d506e034b24006282ea4cbe5bee5a9bcac80ea14c6a3704ae3ac3e160d1cbe2bd28f4da6131eeed2f3af8df844aad5c0bb59fd4a8028bd1a81cce146bd7010a6529d2e3da3ec068a8224eb35886060e09011f9c6610ed83dfe26a8fffcd9d6e3513dcdf95bfcb8f1da34e8abf26dd162c16cd026bac0d51aafdca2a14408ced7c88226a1098e745ed101d97e9a58375de651409e30bc4bb340b45fb7e93074aa9ac39a6e9cf4b894cf4838d7eed70445c7e5e16465eecdd82acc074b8b1caca11c864092f4ba21755d5e39406fb45538feed7dce644a35dfa9a4b7ccab1b8c247874814db9db762946a461636020e8a270f9226fcc14133c5da423b2e83b36252fbeb26e9796618e0c90bc3ff4c01a305f2a6967f126cc98035c6ae6d8201754e70c5075377e9f78f9c4ad94202ece9a7c77398ec4f345f0c1cd2813d477c5515f73ffc494d4fae3e47566928787f2ec08c31c4bd2580222b37454ae039d70f5214b963b5d81465e5994ccdaf62475e1e1507f7771e6ce82f9198c76b08791afc996a6fe550955a02363dd85b0139d6f2f257947fe34ea91bc869bf9e54ef1ee10dcb380fb75d190bcbbefd3e472168b26c517e7d821667bf50fcd6abd873c4e0d1c44395f44337baadcd8011086a6dd27bf95860040b2ce4bfbd92d772abba397e8f4c992a640fccdb8b9f5b09d22df3c6ce9e9c1d6b900144cbb424aa0f0099f189687c075252e8c6e7fd35614f61da1a93dfd4f68db14ee0a327f171e3357956aa84d615d5287eeff6aedce8114a240eda31050dd43174bf29ba834c1c98f92d2a75479c5154efe7336abf9dd4576cb49b611602e8755e301f887eae35d504e9671ffdef0a56798f313e989e6267779736bd3d5ed1025a84c38720f7d7ac08507b22cf26490153cc604e64354fc75ba2bfd7e32152e2506f81de6f4f2c2b84132b3ae9f65bccbb4b5945df636f3da94c8acf89468780bfcccf642e6dcb4666392900845a9f7bbb872a5e75411176800a9ccb6bbbd829ccda5423d2bf795fc99c18058da303f949a87b3ea78f964eecb9f4ec292d3a7cb7dd084dfdd054aeec68728c176389456c7c6d9728878b97854493d0a9022e35c7ef847dee6f9f9b440cda15cdc1873aeb2fb7a7f39d3ae5b10bb386250f6f38d6d9c9ce2ffe8427476a7c8bf25c2f9f12cf3257d69b4b00dc4b825576c43aa5d7c9b7339bc80727c768078e57d0bc4d0c0c1ca6dd05a8818af9beb3d15553ab9e06b8dbda52c87822f07d885f4c3d7f6f4a688ddc1e50251aaaf835c8dfd69ef69bff137312f7732321158154aed7e567dbd693b56a9396b21cf11c1ce547b8b785a42e2cff5157b9352d352af201f3e44c1888c611ae36ca3e2c24d6ef4326f4b6059860d979129ad791efe56ec0801d2af3d02ffe8ed0d9c48e473f051098b21d3d897861b04fe0ddf27783c98b429d1f924ecd3a0a7c0ae114ef4f813e7de0fd4f75d56cf8dd468de2094f36da1c7fc5744b8414dba18bac1e0e748f8632cedc7a227cd17931729e2ff5a5b667f30ca6eeae3f6b4d4cb2fd85e1b1610aef5cda86db7dda0c58b2427b6ce8385de87abec9ff39cdca3cb446d2e3512e11182e6e0d235167050a800e9c45b46d94d6691458f4d4f5c44fcb89afb07149cbfd836c9c9bdba83d97ec9bfc36a0ab44d89fa002cd2d747044db35afec58f0d3aa032ed8dc4bc1a18ba20503a0279f773b60041c5cb11776ffacdecea43f68413e06ce2a70e5ad9b81537a7b99a55e9c16b0822fab7c3eb5a528d821ea8e68e81755373de90d8110a224a0a0d615ae2f76de02c30f9b74523f41055c6fd8aa9e457b967d8a281e18a046aa6348a86ca70f29b9e90f26e050d45c926f3a65a83217894b34d249920290712f06a032fa1743b54ce41788d12a9ae67ac988639b3840a2b512f586f927ff1547febb43182ac1fce2bf2b8a3720d72102283a2d88d1e97efeba5b89bae0f7ba178526889b72c9a1e68580a74b7e44a7b4e03d0556da3fd10a57921133daa6e569f8091cdcac82d06a1316db36ea164a40213297ffab58334172c5c6888c565d788d681adde74cc82eb5be4af5d4900c7503cbb1b3b646d7c69faa98a9682a1a46bffed386b5c99949640ad8a38da7d49dc9bec19397076dc3d48832ee244bdcbbcdea90be9e7ec8c46c211d89c480e7d745a750db06986c7b55e19f0600b239914656f03b89c59f03b6777e038194bc98a109f4af5adf94e1ce09c20c694e4ae30a048db952172414d114ea6f67db5220a5858f5e30c3f6354d9f24aaf1a04a6476c97acccf1f64539cb8a9489def76a1773419438e0b15958f1bfc257bb132873db5d49fd35464628e2f9f20b5095e78c61fb0e93f18ad8d81861600ececb1e68912825bfc859e87a19b87283490ff56153ef86a6d5a2fe803da7f9f4e827634b49afe191a2bc255e743996a5c23ac2341070b41b7c500c4d9bfc340d8181832dddaa484d53b38c80a8a4cdbdacd21d92243db5c56e6c4f442114c11784bd8541e4440a2f16b3e2f8c51d11222899f41cf324298ae55e1f73d60d90429ef2eb1589d3bb7869c295c55bfed99f07899ad10ebfe7746bcadeee5486d872504ed989f48da9486838e859db9ed34c7484f509d3459cd70a3a6aad9dbc55b85c91c1bc6fd5a654393e2e26a3b1e3f987b682633cac421c5d3ff9113adb49f41d99427e51319c1206f24d42685466bc42a5df985257ef452cb79be5c810429197b8234a18b836dad5ff5b63dc74a131891bbde347bf0f5351357de9f2f836803fcd711f6b138321c0a62911174465badfe91fae3d1e79d6220ebb177f91284a207cf5767eb02f5bfe3d2a9420844611b3eb21b458d79390aeee32a09bd68797361d5dced66ece26d5805da88acbadec05fc619f9fd03479e131aa35a321bbacc2bdd2e6c467b3687c4a1cfebf502c437dd420424c1c719fd9f53c43ccfcad9d733692fcaaf90026ed33a001ad68533dc81f87a3bb25b9b226557610cac199b3b7013daf5000e0d0e945970b3c53453b350019605c620793339339c3671cd5c8a5f18a7488a7784bf926e308c1abeac1325b2708bbacf1e7fc7edb4e9e61c9d4f1eefbd52d7dcc118849f2ef7a1a8fc593ab6591660b9a54ac4ccea2a785cf1d648092685133bf344b4573d039c6bf8ca4609cbec66ada4009a8942de5b68265dee9d703ddcb8691b74003e1b80557ff1d3d21ca51a18138f5e55b1f2a0a176c1dc0876b22b224353561f8e9119b965b702758568e9a6d66829ded46f82889110f17d31ee532a470df9a2a5505b38200bb39bc4b6cfb3e406a511aae703b8e130dcf74bbce0b43d66221e45d7fab3c8f70da19c72749132ce8d0c17f4828a7e5828e7c7e2bad0fa399f761d8347939a3c3af74b00705fb5d9a8a3938cfa526ee6ff91fb9c3f300b2cb8a0a0ed511f589f8afc027cda330298a3be8d4095c4518e66e9ca4099802ae8b6a9be92d91166277b0d50429400edb9350d5cf6aef7a4468bd9f07820569f31b08a53e1bd33e4896011960ba32caae26dfd91de82f65c5700fc02e054303823d5d2f448b01002d832edb3e570e7b70da2d5a163eb0cd5ef714da1b0f9a814c572c4f9a27fba136473cb1648819f8f775546ba2b299c930745db61266d732734b1680c2faa97c13d0474844983cb3a75b27be4b4adf697c07bc5f932b5155c0ec70fe3660ab573bec1d273d0af4e69255ca8ceb81effb84c247621917a31d6909248c33339a4da10e39e2596fcedf2e9ac839c62a7cbae2e03a9c0a463cbe475d3c98874ef5ec1c38f9ee8a015326f3020bf1075817b7dde4136965dfc34abbda80a7d4015990026cb809f395f411e47b737b019ab1b8b163835730067fc14643548972deb941c4dd05dc60987ec59547d2867f7652184aab9e579255bdf82ee028bd1682a9e4fd033f09f27d14f0f6fb5178828b5d5c17835e88ff3d66ae7e40c7e575a02b45a89c2dd4e61951890121fb881fe1fcc0a6377d71c1e3ae470b54a659386e42cb684299e7431243e6dc3712f6488957c13ca8f7a308ef2aae6d99c3a13180dd8dc9256cd5d9e420dc3e2ef4853ec88812b2c1cc9c7abf9bc6446467ad240ed585a828c3d492b915253c91e34f39b8ebe90e6cee9c9a5ca5a63892fcf63b149e8032bac562829a1442f1309e26c31254751985004753484b54dd6bbb7cc7fd260792da3dea1604cba34344cea3a59965bab0f1e12fba8e4b50081c5684806ae98e40d5716e4a2c5aa095cb37225dfa908561a6856e1fa83bc91b1449e93455747c7e194990e002680dffe696c7c145ff64cf4aa7f168d9c44aa8bea99ffeb3688eb4f1c28ed8f71ecf32b3b184febf705fff0afe23b012e9b287c048276a27a51ead15c1016bd9dbbc7650ba3e7295162cab63b7312c475b9bb1fd86ada6fd0b8ce998bca5b2c75575926e26be369c0400aa4111b0268f5c49cf0d1dae332a7d50932f18e0f79f83e55a747c9bdeb32de5da9ab196d8cc0d8ad73f8e9db6f13f22e8c0719b0555e9c30a9c60ba7aea7d70d0ea926b2299ec10f3259c99c29c47b9ba260165d0b8e56f3e497527739618227197334757bb3433c23e1ea50f601176dc970275fa038b05380aee4e8b7389babb515884d71e8b4b18ae3fde9ab451829b49064f01e293d59eb157aca764e56970b2bb7c06199f1b650b920312f0734053b68feb93d5421a03f590a746734d4a511b28e1b41e0203c28da26a8dc102e54fbb6d9ce2d67c9fd50cf7d895cc9081be2079b138ab686b9e20e9a81008783892336b57304690f1dac44da853976784057f401f4ea67983822fb4b6e63d7590eb81a2efea375192e2f8ecb94a67fec49a07f7d3b9e7105b9eff09766e543b7cc003a094a7bacedcc580cafcba89ff0c068fcc7ff41a27641bcfa72f555b7c8be538552d8e928b939260d3b8312d1dd71373ca1f6f29311371b21ce6cab4660c7e74baa0dddaf74db967eff2560bec2e543dc34dcd63447bfa5eeb3133e1bc8007c32bd8a697e72e1717d9acae2084fb22f9eb1b0a0bcd085030ec368d158898270bfd14f06941013242f4e3aca99a72fc5a29d8c91855ff292c8c6ed0ab249c6a8abe50b3d6dd6f48397fcf7286ee553a50fa3a427524fd39f964fe509f3d74140d83a12c7ec8d2aea232c2e30901cc9cba831c50b26c6b478b69239cb2b8803b6b993ed635f2669e7265626f4a15f7c72f19f0fa51cc88c1550b14d5d3d7425081cab94073b4cbcb249beb09e42f55e739ec0d3ddefba851dedbfa5a6a70187ce16488b5fe76d1b724c568788843c73e36377d6420c6d89935aceb88415258cadaf282c69b91dddb94f16dd0ceea0d35caa772920dd7f6ad93e406e618647be69a72bc8d36b89535f7832ba4e7711f29a772de0912f6bdbcd443b61c3a9f9f65273da145ef1191c7e93beb1d2d98ef8f39e67a9aa62c115dd0f4d5a36398354201819982e24c298847bbf852f76539a7f6c036b0a84f60d7436548764eaffa066baab1d6713acca3f07b34e56d3dfca7a685ccff1a89162cc45ef328234d5bb8d761ffa1dff39220e3b471ff4a6a9c08cacbc879a20b16274049ab29bc5a83a98476f0e7b33a7b40b0da070abaf50ba6723b8b8cc86321be635d6574082c7f992a44f3ccbff26750205f347cf84758eb2d3a80a9382f78cb0974933c3c9276c22a74bd50d3cf2d137c539ef6411ffbf63fdbbad87f101a069480800c5350ba8a5cbb213b83a2f20ac0e3f1ca87c38b0d3315df475bbb355a20c04aad158d7b835e0b821912c00aa2f691aed00397fb9c7af49c57e497ad1563a1b671a5743beacd64850d820102c71fdd4aa161680455ee9e61ef0c32b405515421dc3c0627bfa33569b37c5cde63db9af714293210ec423691a048e231d275b489a3e23acefb99682b43d9bf9f3b1f904981da05ed84ad9f08a5e38f93b871d707a9213213c43c15162536ba4e6d84418ead743b7e2db88bb1997be3a89e8bed3ec3728025deb941ddf4fc8b0affcbe283b4b9c488d485d3302a77787cbd749aeabf456191168580f692c62edacba187c7f25af7a5d3ac7693d52d39c9be47ec4974d99e293a53f8a4d1f6afe604c045b1c05f6787e5de75fe4a50215ced6aad2b5e2a9bb34548fbbb6058f75653119db57030ccd4803fd756ebd5cbaa8a6489ef745710729fd2f1ff3c099a7a09e34e726a1a5d1437262cd12afb0d904f48ba71e1bdbb3d9b8048aa8c6ddd5929603881257a977cc74964cdc88b01de8ce763fce0aa215e38caab3a0ab06fd2b5587fd61e0aeb9ceb0db013c607e2688b14cc67e79a9f0da9e66eb4751b1a0f9f7a8e3545c2f2ae3127d88ccb0771b02b2dbcd2a6f2d4c03bd3878ac5744acdcfbd95600660bebd969567612fdcea168c317e4fd1a02224391b93806135ba9a7a2a60c05b14d8616fbee8bb585a026abf395efe2c47270ab8f2950379bddb0c6189555fb796603732b9bdce7ef867ff8bf052e380b909f7819b789ec5e850cdf6edf3b22cc8275e64e08a2260ae2d5d2401ce50a255660f24dd31fe0901a6be47c980c077b2b8d56b7c9d086aaf870ceedf20ce7b3963d4be534599537428bc21e8b66e81d8e27c9264311d6aab90cd49c78f56d5c2bdcc5bdeb44b4a135a1ade521eeaae89849ec32cacde59d112395164f32e93860a821142e0c2e37989e95108ff38fba8d4a787b2d130cfd89581079fc7288f85aa4fd4578329eefbb8d04dfeacd9241e5e89176cd4c298114c17c747df038ced730fb27391c9f4c923fd06942abc737724ae169d8b92ebd96606be2e61f9983b901cc5e9021d228040aa0578df683c3abc32f1569785c1122770a2083c5d99525a3e0920e4daf7f96f26153d26f305d94930d289febdfe33c859f0508968a164ed73f35c3c62ed3eabde4af1aa2a86226376582ebbb55926c8f3194d6cee6cfe9f24d8aa2ee3a1c8da2e867ad51fbc1f4e9b9585eeafb5389b36028d322e7420d383deb6e34d4293eacb50bbc03bf842d82bff01a1c6f95928ef956b30b38d5c721a759e703c83a21af3e89e8f97d19aebeb86ad881e67c3ba38a968e5bbd93772d1f918a772ea7e14765effb4070cb277602cd5769d2e49dd92967d4c17f87e2d6b31174446c6a6561e8cfc5a57fb043c12aa7aa3f9dd36d0e7de0947d1197adea739a24b20c331ddcf23133732a9fde624b21fecf3abe07ce6ce80ff7fed96194137c5c0c67888fd2cf91a307ff6f67bba267c9ddaaf41810ef080b4b48acdc847af51e966669615dbdb9d0b15edbc3e0dfd820e61a43c9f9fadb07562f6f8c775d3faa357d9c19f49e099afc14a59eb1156f7636f9296dd196165ef48659ae7903b49f3be7632195abf0a1161e892bdddea87ea5c473216cceaf196966757d9ed8143bab1cf544783d94de568fdeb107b325d48c35558af0e6e855bea3943e454e2dfb32cb728ec6deb2c95cd95249dc61db76670a759c983ea1a0e7ecaabac6a49605fd49a2ce011462f6284469589b6b82b92f52e07abbbf2e6f4e23f2a3ae9052aaf71153aa57d733c332ca333c028a62d14fb2e6f3ad4ba90b5f89cb5d803ac72cb9d1afc23f2f90819f8f65a88dda2f85c0b9562c85b02a9e75a6f159c2a4b237a0575ad148d5675d6a5eb15370fba7ed1668ac8412fc692eae83203856f4023a6d8d7cdb50bd1232a6fde750862aa498d1c30c5ac25b49ab1d213328ebb599009652dead53b1b7d0933b6faa427c246d9c192bc4968fa5c22af7e23ffc0ebe1309e5a04317cd3f7e6d6d11f74a901858e074fdb3364359850a9abae08bce1effd8c8497254b00387b9302ee22e0e0a52751ec8e05d4dc92d9d30a4e1a14d6010947f4064428b5743643664f3a8968ce25d2b02bde875d785fadfc77e653fdd34a8d84979aa1c237bb7bd048e4c49e7a3a13c65bccf1f7e708f30d73371d920e4f77d6f01f729a7bdb7b4e21f2b2262643c462c854ca1877d9ec65987760242f0a3ac5fc3d0b0c1e5003af3d22dca92c4604bf9cf8f1602d8c961e91911705fee1901cf4f95701cd31dc7cdba7ffd3e9f59f7be963f34bc2a78eead602972c11b4995af4dfbcf9010b002d863e41b7d1bb579ac8ed54225d464f68dbcea0047fb1bc79562c8df034c1918ac53d333e71005631243f06b7fd4d12d7861e7dd21cd6b0c26216a5291fc814f45ff2e1ab54a8bf72f06b484499335e16d9019913a918cbf5e39e15147d6f171016d24a4fc18936ee32a1225fec8d59b6573bc733a08f1e87da865e83c76083560db11f1f41507ee04daebc33aaa9d71d8fd754d9a554575b45df6e22148e765fc3e7fd49fe4b577865051ca8cb7baab92b88f0e69da50c86d4a165a8c18ddcf966160774941b5d80822b644f57313ac54e635c351642cd10b14ac6ae5515cf5458959a829a2f4bee6c83e0956ba8a7a79649753e8a81b521e84ad3307018837e1c301261bb6e4f8ad22dad6255074fcad8d22f03f708050b2a11556d861cfaef2d46fd0a49cf52b3f8fde8790599063aec6542b66d989ce189af57d32fb6bd24d3e53e6b273cf3c450cd6fa36107352a711dd3edabaee02df15faf917787fae2ebc94b6b388b861b93f261bc339fd451458df6fdb065bb580189919786e8c5eb365f6b7c2d7de9e6cc556d6a5636bddf8eca766c3a3eaf039cdf52d6759d0368d929ce7b8845be0a264f2885ae29fa461386b8fe8484fa04f9686172197940bd28e2717fa6d847272c59538013bc2ff6851382c3df0beb6a154b484973463490092f8689f07e03c8d3a24ef001e178086c20dd866048e2eaa4c25d56646b3ce38b6164eae2581c54151b0c351bd848f5fdd9a003df5d706d6b6ced27e4a014d7e795af9180eb895f200b82bc7e4d09ee6ac4c65dcaadcb4aeb285fffb81aea57e40841f6520ff80ab2c85586b90dc22bb8516cbd7ef1941a199f1a879c6647d887b37a0ab076e62ee9154fd69d0546383a5e91250ee718ce38322d9ce2add1e5f15015e04ebc7a2a579732375d50d5e5288628108f1fb408cb93184ba02dfc3f77e2f72207ed4c7538ebacca6bf1ab45cf0dda1b34a07cd7712cb39dc84d89665553c768ff198dac7d9755d576498b80c1eae6607a938316d45d55ade15c0a9516d7748a4dabcf7f2c7a4d2a1b52e74e42464498c23723575740712d6074c7f46b94c053b47364e6ffc253792d24d3f7c10a88d85e75fbd5d7c3a36dc232c273d507a95ccd31baf1c6fcbef281ad9e461eebb803c94f7c53e9169cce15d2ef36bbba24616686b569c766d674c3dbad8b046603b357d9efedde15deb34e1d9966d3f3370f66e2cde017f1db5809d1a7e7cc489f96acabaf3cfc40dd0d77012b90ed18c5cb2d76b447a58f64fc3058a110a5e73f5225f98393c2f97cda153b361ad4804360b688c91a300a7894af4acf45560029996255d2bf9a5a31f0cc0355edab7c7e2c881fde2ced6e0f04e27cdcf81dfededb354837fabcc9976f92de7102569832a0c8788c0730af0cc11826ee53f18bee1622096c075311d2f7396f1e4beff49881edd334f1ac38ace13f30b1b56707e3b5fb275e489485ee5523a6e8cdd996077b476058bb0dc8a95f6b4c6afc610739c69be56c6e098f9e6164c4e138f6737b0511ab6d62752cadf5f7c36ef582eac525e9c3d939739855d230325336a302e55318e2d79404e5e31746979df4d4785094f5c34c4669587bbb1c9a536b832d2537cb8a7844b72a8d93c6f359bcbd7af6f2c6e1c13fa395d2e8902e39f4e4bcf2865e1fb7ff0ca811c99315847f91218e0b03fe3f43e6adf19377bbedd183ad86c32348b408d1fe1dccc8721878d4c7d67928d0f2ad3f5979d24c8a96b46394597f22ad20693fd472363073a148ad28eeef52ba41645ef5aee3c2e22019f816e3295273df6125db561c68359beb4cf1f618c4b30944646fa5100d6914848bb94b1b9b5589f921f23b166c82d68f0744904b256a766ae4bbd622476499d7e5058339881714c2a9c0650c3236d645b943b5c1e786eae089279bd8a5acac25e2cb89bbc132998beab39108efb43351e6593952ac8f153fee5067e4359e67956470fe9cc82329079b0760414475b5477a597416a15ae6036247de89914f62fff622760343c3ef0fe272c46ca25bf854fbb8af1b7f3d480f06973c4b919f8111a472957cf6830fa8b3dda9885fedcd9075633dccf18c60c463a2d2a28d0745e115e33c093c305218a5cae7acfab0a2c3e737743fdbeae33bda1ad53c5d68b2042a6bc7960f2cc9f191ebb4c486e54e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
