<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7f57936723b2544f013ad36b12bf33d77047a6f59ffe64f15330fad9da3464f22c12e22f489739bb4c3524261623178df255fa52160bcadd0477cc91ddf2e0e298302d32fe9134fccf608c17a2ab8cafb14421b05cbbe43ed696cf40f54d1f41b0b1bf3b31654b09f5f1cf33897d067d0d97fea0199194ab51307f3613be7e801a50094918d60ce31282a2f79726486e7bdf3fee247972b23637e517c8bae55b1b91f9e90ec2648fe4a053c21a4476e4f7ad3c265df16afb3671ab8e09ccd119bd234a6c4316a40ba5b82839ee634360f9951e42dad35a8d6fabd9e1ccc1223d06baa0c597773594c474e2265bc42208625f9dbdcaddf0ed7fd6316c5681e32286eccc9355ebee30a942b68517dccf0c6700c76cdee702c53645ca009250150536839a15e320c672c7f9d4b961705d47b292d29f9fc8980ffd3acdb1fe2afcf8a6ee8824fbabf5925da53d6dbe199ba92170661334f8a3fa94d06f5459eb10ef78c90968e1561ff1e7bd9a4824ea17af0739135a162fa71adcfd84b28798b43def1c5cdadb23d57584cd637b07236856efe415198cc28d0b3905331ecb86e8adc909896b5256f0dc56348220a5a102608679da63f01981cfafde78a0a7a1a011a8754a881246f1d13a9b1a9fef7a804432ca7bc9a3086c43e25f7f2c2f395c83020c3d67d8da5115592016127323c5a85037b29c72a1e54d6f9075f474b21b29a0ff25c6f1421b24bfc670f7c6eafb8601a3c79957a9955a8518f1f9990a6a3edb1d7f70cabbddc436baac31cd11a6f090f5b0e4f420ccc3d285159a470252d85415d3edd5b4442cc89fb4d5117aca31fa0ee1f492ae732c3da4a84b3530dc858dafb3a0e7cc2887191af8492d6defa2884652fed1608627878b4d05b43271b6441fa923a0050fee7942bf3d5e01da9a140e1d30a38086648fb92eae071bac21ac37ddec7f3da72995be92bea7fa6fa75dd0c7eaf5dd398e6c639fbce90e9877bfe657537c8c57dc568c0dcb3430c77b58c6cd49aa3f63b78147f8b183d588aba5b818a1c93705caf4378e6e56a415199f831e1358907a7abcc5aeb96c34e96c05967c0321953343da55729f6a7081ca65812f299faf9953ad316d6466f7cde8091bfefb3b7639d804442a6a13181bee1afe5d5a77f3d53eff5f9e75e605f8a311513e1d6c561744bd3d10d7f5955ff22ed86bc1c332e67ce7f203923cb204e19fa8b8a79eae1bf846d247ecb50133f785cda7dead526f3eeb3c00125c3a9546d5c1746285ed776f50993bdc115c84b82525a030dc3ca1fe21d2e2f76ee5de480145ae3ed22183dc9171714e6ab8a84f60f537b145edf6a78672f484e5eae3cfbb26f4c8ddad9a5310403ea4ce44ee844b18e9cf89219204bd3ee22a973ea2c1be41522f3bf6d7e2e810595542447ac08a438e75de3b0a2cda010cc9f4f846d7eac7941fb047ea2cfcae9f5b6687dc70b31226c912eb6059a95183b6fd5048ed5f0185848bd153e7f0f28a5717e1547fc8c9e917303a8143e1f9a68385fdd0a9d7114a81f7b426f13710eb463a6ddd9619f8cbeb476f397fa0d16105996a40fbf5f61660e03c6e758e14bcf3e2166bf82b7a36953d02aab73751e51438dc8616ea79bebe235b2373d058f969f1f4a953e218cb58fa91c1255ef9e3153b6a4667d0de33ff45e7b2f3e7f55d5ec6cb8a659ec78ab846c53ad088866ca2d480f3a2ff185ee65a5b56738d62856082ca1a6fcb747582c656b65068dacedc2837a9c815bd0d0fb3c20e43e172e4b36647205d1f66cb82103d8d9ee4c54cca2fdbe4798aa8bbe0755fdda56cde5e718bfdfb35e7014378db8a9c394b25e19e4e19c98b929c0cf72fe5d4ab9f0bbee13ab731e5a43fea3f3814930216087f72f8b1cbe256ac7defc21f3ea1ad2bc32b6c5789b91b32f5ba7d994a98a3ea01b85a2b65b9b665aa5a0dfb2773f39b8d60d5a84bb55f31fcc448568f0e791e3408781edecb9d4bc4213c515c0205a6479742158e505629d3a296cfdb72eec7ef2de63b10ae4bbea695282f38410107017ff174f944e838bd901e30c77955751e0c0e9524fc186a9eebc31220c1265f5a52175d79e3a800b223eb945b0f046bb08af92361b52cc19312289d2a749da11b95200e03c7f69374c52f80c5f8d37c78174b455a9c5f135a220de49d6454bcc29264ad9b6d1b8095af4c196a93bad6a406350d398bccf0f9dffaae2ea55c4923d0861ba98e580729396cde8954b7cae33d24219100837191d07f395a51591ec766d88304e6b8abe336359a3d19f88742d3bf73bfdf50d70cd857af8098f6a5bb6ef97bc99df0997c4dcb2b58bc2eb7f859e5bcaf7403e12bc638a79181b605ada4c69be4fa78ec75d8e8764ec51b1b8f64f21226ac8443719f60775af39b4f36e2839bfb42112a8cc2a3eab0dfa8a1f8d464db402806186aaeb3b0b017825ee6719815ae8e1f6d4a601dc2e4025fde715c274023d54f6eb1ae0b52df8f3df42b0c220f6cb73a22139464f10f6c49b78204ed0f155ee267dc5602ab07ab1a3355ca184f56056b2516b4e014131e668a48ab8c52620869d55848d84191e50aee56d5dd65cc6356e298cda531a141cc2ceedf184e199e4ea004f0fcd768ba943d4246eeca3f96ee11c7395d61a9418d2fb24af4a4eaddb1be7d08740bcb771330f25098e06869f731c9afe2bb0061e919d47b9f55837ddeeef83a1b68265e4a7f8ac955aa63bc6d2588a78d2c0c850168a90486bbe84fce3a4f693b3e5c41109602ac1557d9f7366a6e8c98c3a184839cea4171edcb583529c2000f0b8a3ab98e5090631bfe6339e543e02f187ef55b1474de2625090f8933b379b53e9f386c59a6c823e52550b484092ed54233d3fe5f57495afb0bb8ada30731b5bc24aa8e8586216c0fad265c7cf6ec5cde0fb5890640061c87a68c0f56fc770785d77838168da5ba3f48ed11cce56a3724c4e61dc3b7e1b687f80a90d88748142f80288a5cf9bbff0cc5b059c558980cf7e444a6903cdacdd903424e343a18d83256364aace9ee7a47bd51dfcb3a75e09bc866da01a953840c6ec0361b59d7ba5d5b08d0091a83ec8b95e921eef3876236f5f1bae7fff6d7093e9e6a9dcb58cd796e03fcc9157eff03c1b486023ef1d06210a81eeec204e9e1c2984820e2495eb5fbf7e34702bb37832b3f496f024e52a7c7f10152b882de646aa12e8091b979db61f04cc74b9d5ded459d6382f21df6ac3366d3f00d3b7c57a590ce7f489f4b0cfee9c1f6aa355c72c0793bc11687ee054fa24a5905377072cdbcc16ee9409619905de5c8e051f4f6944c2765b1f4708524c8d5923aaf28e2a841c4b4ce0a6c08b5002afe5f96520bc8ffb09bab3743bcbba4902c0d4deddaf8ad260843506224c64cd7e41d43a2fa2160ff90d086a0c0d7099a5ded9831a44fa1c0377abd309ae9d6fa1a3ce6e68abe92739363a7115d77ecf81a8d91f32422af42f6a32bff6fbc433562c9e09653000b58d97655406d59db07635568d9ce204303f54d78f775b3242fc264e24a6a2e639203524a4250911a373d73a2bce41f8edd3c679ebb14b17ab3d5ce02d7b0822fc58461cc1e99b30ae141811f1d2205e015b27fd2d304cf7c791ac715cd15d7eebd67490252e55c9594850232041e176fabccf687a615d8ea0f545e5c7473df19db17a520d138bf2bec1c64adcbdaac5cb7d644c1f93d429b0eeb0f4ca756ce5b9fffba7d43741503e4d64dd640ac639b8d4798f90e7714b8dafeac3affe12f7cdab97a69382a64f0201d1db257f070cf8cab9f6cc0ac2d273c96f488d48a70fbf25d66704871425a89412e0cc08ebbf65ddb9cc0d7350c4fef53f9b83ae950ce39d1688f49fefaa497638ae32a071f118ed430653f5be5bdc05e15866dc3f97d916e6eb2fe02619586b8916390bc1cd0863d9ea483ea730b967525551f28bab3b250d73ba7c088cd1df3ff43da32dfd6557c1ff3bb6bc260667349b0bfafc30c25eb99cbb0cc7637fb9769077bc7edd8ff389d4deb9d38e10c0170ecbd668c3a39972513fabf824ea980fe04b8ddca247f4a97447dfbf8d1ae4154a3de4b6149943fed9485c1eb48fca00225cc7ea4315d2695fc6384e74e76e8d52c60f1faa5b248e49904bb7a359f459e78e60182fec3c1137fc3cc0a4aac64bcc7a1ab1d8900af09090948098c82ecd390ddfed0731d53341508825dfa0a8147f8d3974ae61821f7043fc9b9a71a405e68ff268e3df440d719197d149346b6691d4bcbbaa342c95d45d6bcffeb67524aaa41d031bdf721699915bde30cd633b5f141d2fefcf5eba5698520bdb75cd5f1c65c5ebca34d4a60691c4defc4f24f4a8f463f7bfed11287e675c4364c0c49030055090413f68dac0101e685f38ae14526cce39eb7826b0cd962c4492041ba2442fa23c70225855dd43c7d070b47d5645413d4d6e7bb36cc7e6ad1f2675aa33410bae6486e166be94941709c7cbf573c374a3a60f15ef107e7defd76a72da78488288c23268d2d40b241c9a39fa1f1da0ebfb1002f635c3f9ea8329352a73bff91638694388caafcdbf8f933eb26e0e7b1b77c842f6f8d4967f3c2fe149b594314cd89d17600122d8b9e5bb826dc7351b9698dc29e30386f09cef02ec47950d7e1ae87d5b4cf0e1750becd68463fd70091bb31ae893a53e17c755b8ea30ea392a3b7d4df0074c9e901621f5f550e414ffb52b838f175fefe68e84f2bf39345fe57a03961af0ecbff0e390a59f5a09bb4b997167e05573db79b617f5af47a825ae281bbbfb6791cb271a85b235327e7fca91ef92b124d11a8dbc2b6f33c0a1439fd34eabca66458dca66c17cf6c23e619fc257820e0de5340d838f77b2419f3c740042d1022ad3b428219aafb4dde4697750c6a90519c540e6eee25065e79670105f635191c44445ca0ba378773b9dda33696d7676aa1f408d0760e028f5f4cd37de3a6efc6d3070ab16984dea48335cf4438571fca7729ac25ed618b5a6104c521ddd1d8ddc5bf2ab7e12d0c316ebe26cf25be2756f0c1311e2d982e343a3aecebd098a86e7d12968c9e9397f0921490e71dca9482f9a43fb3a66007a7b1702a6a65b4cf002c61b04bac992b7b809070888d49ee0339b050b5106d6a4cba4f364d51c8b0d395585f094e56ea616d3e1c588ecd468d8eee212c38d1156fbb31dce900a6a57974b57901de69af9e7e3a470c3b8cf34910e6b80414980f07fa1137e3d355b7f5430c2ad9238a367f06e3af7caa43f260902f97c7db1403db34775d4df16674e8d8ec25b09b0b6453d47b33661c998f0503fc58b54de17e00a3f844e6e0b3ab0637ea36237942bbba6e567085f6142f5735faeb3d95cb1dd3cb256e3b23bcf3e28befd07c1a14788209e7baf01c4e2a6c0fbe3a690eea7d8ace2099a3e1dc552e767781cc7e272765ce9597635cb4c8b8f6da814de363d88dda827e45ed8d8a6610e43e2a9ede455d19ed726edc46b5c353ed754bf3a50e48e466f3e78fe0a631810ad67d676cce5ec25a2396a40c688ec6952220ba7e8d4170830b6bb1a1e7d993cdede0f3a74f41e6767f1dd55b3049ca5c6628d1949afe7b83ea23d8dd82ce8139e117200b2564029b781c2e67758343260c38d0532f468c8ec5be536c3aeecfa0da8a9e049a6d081b6589ec0e3dcb0c1a1907ded6f33be384a25a7e85f3af6c21d18529c79cce2c0fec253378bb87796ce963d3d7f7003ea0c64389f6d653f47ecc39d20d1bfa2874d457e3479d0eb237bc69e6ce29bf0ff4ee549736cd47426250f099e568d0198f15752553b58466b1f1117aeaad9b2d7d17ca79971f0fb8939466f157716696dc2ca0d79c0dd169705dbb7f40082e0ff659e06c828f79d3115817e80f6758710940bb9a2e27a368a98c41242de0d8a0348b0917c6bf4da49a4f15a7956e89e0877ab6b25bccde9642b2b49c63dd7a70dd6b0b346332e93f8a16ee5ebfc44b12a0ee6f7a3d17bb23de6867a56cf8956d91c8a3778d9375f3e23c31f151b6d9d1b9f6ab7cc2f67dd95f1cab08c694d60a67c464ff3a0851baf7f2354305d0219542344eb61c4937b9aa1a0b1832fdf953efb9c01327af79ac1a6f3a92cdc0da6eb18e6b769a1f0a47651c9b2560687013e1532c7a14e2b716305fe067cfe9483090add7ea7edffcc20b7994b16a7b36f52177fcb92ee66b74b5ceb9ea646da24335eb88aa6f9d16e1e650999b4a915f71eebafe47a00d005d40b34950a0b71d668bf0d01600a72a5a6be05d1a7e833e41cadf25fddb324e444cb8181c0ae7a120bfaa14dd0cb966cc7727d402f402d3f658272380990c8eeaaaeedbe7103bbeb9758c941f5c9450b82f4c31033ea81c848373925935a3421f59db4f68fdb34a8e7a4674d93940cf8807e0b6509e245724739a8ac3301c5521717f80c264c981065abfe88a1effe7b345a09ced96f09629da6361ee55af028812dc5f69313ee9ed459b854aef90ddf0139f53f3bbd4a771b8e69fe8282e2a848720b94dbdbf66f63f89d619f0ed92716f97d4d84186d4b06e407e30936e3455a36bf17c2d22db3e8fff31ce9c41f8b350026ea72d9cb5740080fd40bb5c9f9140818636e48b54c794e2e7b49509900c1317b3cdd7d8e0671f5e2b6bed4dc2b0dffb8345a081c20f97d49d88a44bfeba74b04a29801f7b86e35f664fc693f1f0864dd72580ecbff575d62eb92f618858ce3cbf709d145bb5fac769b71c6f9a2147015a3b3c8b72a0ea12bb6c4da1a07b846ddbff380611f7c5b1f13359fc4910c538f8b94085bb0420d1f2e9b33f4a496738b0ddc7db24fee82582cb382c97388d958e82f7be0805d9c1923a9853113eb52bf07ef084b96ecbf8d4ee5fea1371f335c229e70f081faeb3b309395ad500db897897db487b1924b15d7c38e33781c59bfaf27b9b5dcdd6d268550cef42ae2244f7ebd846b3ef4776e19bb17eee8e90cdc664319fc84f98c8fe9df57b14b28588a862f34a65ae470788738e856bab407eeceeb39fe2f9a446909f43058785858cd6409734aa04c28789aafee26ce6e981f765c4183dfc49552ad3eadcb7935c215b89de758df28a6a1ed2c1f23c8c41b6e5fd7d739b63a4cb368bd7d117c3ad507312105012ef975e816d7a4902802fbdfa210fee8d1b4f1ce5069691578311c95245e869a444ec0a9c60ce4f793e6642c2893d6260ceed163fe47e7dcadd717b072b8255d38ed141e7c19b4eb81be44172c0d4d5496702ce59ef190f5174982e07bc8f2d5660700938a67b6a6c083df0b60e75b1e3a5b604b420b8c79f5afe4d667c7f1f267558572f3dac360b88e43fd3e0108b52c28d907f1dfddf546d72e93294900f3207676c9685320f2e6ac15602fe8569f111345edbcbb2a0ad51e0a92ecb2fb553f855a2614bdd498b8eca30d25c85f966b0b5d1dc022ce09b424dfa9a760c80adaae71e05c3b251388a352b490b1b9c4240d19a49aa3403afcfc928660ce5cc76c8d4cf5cbad4e0cb3edfce22e74528c7d5f8ae95e8529bc4df2a11ebc199062888802afee4ea8f6c9de032c091e72b64240d93fc8a3c6d3870b8e9e6a6fbadd9a43c0bbc7e5ae0bb291341959998553d2b967b16c72809d7d8615cf5b4eaa5709f7ef3fd2c1de21151ddc4a43cc86059f4468e0318b686e68993251809432b1545048f859b817ce78af0f94e01ce215a5fc746f54fa897b6dfb5d2c942a7106cbb4aac9bc18fc0825b09a91e50e85dac57383d33b8d1f317b5469014db072b7877f96fc791f7b930c8b9624de379ae9fb9815d6d1eaad8849401c561c23a4b6f5ab1fb8afd6c8c2ec868f3b9abd9b31c950fea5b0a39299ba7c501241201891dfe4d34ab8f01fc7974e0bec602c17122f6713aded621709e5dd369e072c7ee8d46980fe69c0625acea15127e322b4a72b053ad7708c6a6d3f89a1909f2a1c1e342d235f1da9b149e6359861ee9b55da2ca4674ac521e3568b701d571253928896b2ac5b940afc6361505d857775a6f815a9ec9293b0a62beb64bf2ca13c212e77bcb0d23a2255581f44fd22f974069de0107a6d0b78ba6d84c55c3ae6498785aa68fc380d5d54ceba5e3e3fb566ea4ac202396a2a6bf7181667080cbb706fa885c0693bd8d68ab3c6d0a9e4c7ca624e047c827f20e3d8821b9ea1da39c48941e378870818908b8ad72eaf8ee346f62d36fa06f0f89785389d0904c6e66c5019faa3647a9d23028d8bb2956e82b2e4bbb410570d02e2fe72a69caa5b98f4cd37ec0f95b6f167d7fba537a69de2cd608afc4bd51e87e16d890d806bbc3b5584f0d59fa3d0946d298cacfdfbb634626d2f24c30fdfaf27c46e24ffaacdc1d54d7a5a95cb0ff028c6ba1a6f6b46cbff2ad1378e99b35110c42b18521b3621a79bcc342af49f98729802647d849424f9768dc7147e34b6e6d4c2be14ec804693ff5ae2d872d451e7234d7f69a49c9974a77939f0eceed538d18db89ec167493b67a711dce8c4470adcd97e7cea557fb6cbcacdeddddb7d492a8361b1029b0a5f0b6c5a12707a487fcac3ea9f1604ebe4ed143ab48ee666ee6bb7797ce103c7c1d38e30b06c8984202e50e3340b91868d9183b2ee576ce0c8ca6e61535ef57e89b4fca79d350a9cf4a4c84acbf832f78cdc35c406530cf8d97043138398ece2538c580cd5865f18f6ad502c1194deefd993301deba52194eafc912a6552732230723ce46513dc33829d878ce2919c16d3a0a892109eb8526b0411ec6c955f08f9552ec9933968c0f495f02a5eae3f99ff6501f527b6fef3a45d1545ff9a4703cc8cf74a1704d34b1fd93d6ca0a45b76ae77492dd4ba5bd26138d790af25e59808eec5dd4ec298505baa1e1de86d2893b4075c4f8228c9838ad2257ca198e0829957170e3c839b15b0a44fc6d5d9abe4ae09a13cad858fe6a582b0bb1a65efb71117337ff3491ae6a5ce5122e956d0ee2369e585d98e5b88907955bb1f385d242945a739e26510b7e62976a1f438b66040d826e462593d0fbadb1120bf997e4522dbc4ec495d967a4aa74228f7fdae3737879dbef6548c99083285b0a4b2675bee9bb521ab881b874e60b20eab7e959ec6604fdef9540c44a8b69ff5fc01bff4197c04b078d50ad3f79c3f51699efc2cf7060ae019166ac48f2efeb6cec27d1207029a6a09757d3f46a774c7c8d969c06f93a265d01a37aa4c1bc61d4e2fed82828169b097bab0d8c0d7354e125414e9852756d9150a3a5aea56ebb136432dc83c8eba9c0e9d5df4390cccea39d2c44cb2d2f274be0e6bb681044fa06bce9ddcada3bc935e7e233178972b054eea78db10ebe54e84f3181825259ab361e23344e94841abaf7aece8b01bcda5cb274ed2c5ad664ee48a581f40f79e2b6fcde9365bd6077b18191afa96d2c1518c1d87fc9c782f7af8a09393fd060334549696d183efbf97cde5a3c2403d74e2d6bfc102baeb47f324e1fd9776c85933e406d43c363ed2d34cce6b195d9caa3e56129e9da4fa9a908c9098c66022747f54b75df361ac70956e93187ea0b225899010ed3ea8ba64563a1753f5345cc3856b294edaf97ba36d49ed6c992c324160e0f12de5b2a4a851f925820b69d26b1e69c59a7cac2832793862500718520348ea667f7279de2e3f2f0c71dd2152398eb4a095ac1f235bdb1b1ef4408f50ada4e0051a7baa78f740b6844d87fa07c7c6c37a4f9e055786c297b172c9498c3b7d8226dc57d9c46b6f5a405d55baa20ce07953c0f88ea7f686c79e71aebef6e317717870487a411fc54745ae6944fa313be8c934b5697fe8549e34d34032f4f639ffce78c14446af1942df0afe8257c07f420d60d5f8e7d24157e2cee259ef73d9e1231bd367850572372b2be7239d8215db8455f607824e964f1798acca00fa71a93f7c5aabc250e90f843331a490eaa517d25878a7b067977cf6c96baed40cb47c4fc32dd4d9a927f8d13d47c3a6d537c4309a3e976e5a9dfb68bd7158e99a834e6f27ef1c4ba37fe7a85ada1172954abe7f3a8b3f50081c396f979d11a7fc3c1198d54f6adab79b7ad1307e98f9b7434ef4db2c68055f027a59e457e6e0965434f301cd303a8e99197b8b3a75c84f9e73c75ec60a7bf84e3e24b8a20515c69b96c8f5962845a611603776c251d7c9bece0454cb45d68dd1f3acd1c1c236c6b48c8edda9f2f1808547d7c988d5f863821b300606b4c61cc4e30d7f9e11c2aa87365684e1fb9f943e5d2eb257da298aeae93ae50c7c6eac7940aca9faaea528cc00ce75d43bfe4d708122256886c5ac9702afe6c5546802133b3987325d7f43db30715326485f1186f310793bb143bcbf7d9a1eebcd403cda8c6317cd0ee78ea0383cec8059f952984a9d50c72951363024ddb32f02e6439c0842a1b5ecd3bbdcdca068ab386cc6ac99691edff5d8296f402143594db3b76bb07ea2496e12ef07c80685cb3e06e4e17d30497154d8095c62694a2c32a0c2796aef587ae5601f8ba536fd74be80afa2e51e372ebfe59458fa63a2303e0684e513ddb991e853a44f74d7d605b62084301bcd629feb4a12d0f7d96dcd790968f00ea904135b98253e3fb0c1288e29ab3ae68ccfd3475597e7eed9c48ea57c5ee625455a240b16afa2904eee260c06eba4a23f97c7c948b24c494a280ad5a57dd1c7d6483adc4adeb9aefef66d209709be075fe4f223eeecab4af6a9770037e3a3e5b5a08c8f78c7259dff6a4de3b38b22d12e3b6b8abb1dba128a7e199839ebd87c73dc74de3b549709e056fcabb5d149f94cace1a721b5df41aecce8615a810412c4f3d69d36f8784e9c58f6c50fa12413e8fe3b0ba8ef9a674b708e6ac5855d83afedf4c30faa5d357e0994a8ecf91e6cf60149d3b474856ee4a194e9d033389e6d4069995bc8ddd2bb09b848d1fa5e20c02c990afa72a3961ddc739ab881ef3f526e4d4a7c0e2043f39ce0fd2c2d0f3b689fb14421397787d0d0696b9c4cec5e651b2f7d0e2b71ef188f8f74221d9a2efeba920f38f5fe9b891d13fc12b425dd00c192dbbba35a1018debc91d40336a308f70fcd66de75ffa961ae7d6bb0943fb41eb63b039633dfce96902dadf90c531f907166fc922f7c3a282f45cd59b8891847efebc8fb09cd5af22ef7d90ce220a781bdee0d648d1031d59dbb8f11011b21e03561b4c257ba71c96d75bf5ac20fc54bab85d0de49d8f436ad563a3a494f79b9d5febc26a919c4b68f36382ca800d03b14bd517c1240f43e4e87e3deff40d7e1515b7de9c0c9d43952651c7155fa492a0c09b7f6ec8c0e69310ac9ceb0afb252fc00772c79855bd861213d6e89d40c7a17f7cb27d0137e346fad3e30ca61af3def818a8f739d386d647fbd764f95f43bb40f707a5b3ddc1998255fed2f0fa8a151e348d19713c86566ecc72360c21ec82bdb825ef63d5c0c76b170b2221865c98d2c4fb57067e40a7d2cfe82a4f9c156365c8f844917cdd23ff6b8c6d0c7731d822674f6979f5eb59a6ea1cd89a500c211ff7653367e7a12dbc8a324fcf286c33798cfe112db18c82bb3992b003ca462835f5405e096dc6f959bdb3f99c59cede08758ca716460044ebfd86f1f89a16af52f1e38774d77074d654b518d3eb48288bd17c4bdd7daf5fe75bfc46da41c110f9bc46632b73d9c28124ce25c3583fbb473c7bad46e48ddf3d2ae480b6b16ffba3a75213104b353597bed6958c3852bf7fc31dc1951084dc94a9e99c8f0c8961da7eade7a9a7fe2f8d412bc9989783a358102953ea452cbbcc4196010d30492c9320ff0b003f560bab2e79be3003b711dec15e4461c45640fcafc70ee5b44a650e14490e8f29cbd3c27165e379ca6043d3fca96c2ea4be8c6a103c16628af858465969de33a4d61e3b9dc26f034f16be9bb2114ea3d1b390af36b98078c625470d2f7f366562aaa7eb68de2da921746275b4010aec18d2db8e662aeec453359e7ed2d1627d99fa39c0a00a7944ccb7b23f89bb844922ad4dcc2d9fed794b86b29bf6c59a260960b65ed5223922b8ab0fb4f9fdf86c9d807a64a57805c7db431383aa1bcb6b507675f8fd65692341e6cc5513ecc645a8ea4074945c1d2b32219ae577bc12f43fef8b96524b83d161e2655f6134399131cce0b854312f000f76c2bb6f282786ae6a3cbfb42fa70bb776d9547ec3b86660847accbe788a29313c31be7791e0ecd4ed923f880efa5433ac0a72ce383162637da9cf9841e2116e479a94ade369fec23f5fc338eb5fe5ca768b216f3c9443947726dd0a6007be8030bf9484a0f8d2d74f9b024ce49a5a0ff778f245ebc4c0fe69f0b32184334f1c9e2faa6e75e304c00258151e4cc739f8730328ad0f866a2f343284139f68d282d55468135f7a6e798bf1d618ebcc16120ad5c0c669c961031719c7377697080f5e9e1bc0900ab0f64b712bdc615d1a83450fdcf15c28a69b826843fd8d89580dc46d4fbbbc2989b59ad9d9c83c8114e77bfe9ae34005a8dfc3ad2e6dadd2794df6cddceb8153ae01b93d0a2a421d02e4e45c0d7d4aa5baa749ee96ad17248dff465a1cc7e34c17b869f0c8e9a315f7a186b8548080e3ebcaa7e0204b8ce9ac2359019aa868091b6fb87cb78daac3dabe2b27500d39dd79076996ce562b2b18880ea818360df5c02b500aceb6a7f513cbf1ab7eef80126cb72edc72721e25abcbe1caac8e0228b40c6b12c6ed8ecf3b773574ae7d770164d354d1b033ea6a0612148696a20595fa6ab415bbe8e5b05fdda9ef7425b75b46062410cbef0f321829030651380b921bd80065893db85a121349b79eba51e54b0aa357c5a1b217ff1967539a0a9380b5d77daa60b84be34047d407ecb51c6936796043bac7c326bd5e471cdf4b52651a34f5a350a4df8a96a9384f5984a387faf81b77189839bd13d8de61324aea599cb5e8edd0c41276a1b990e85dbf4c09cdefe3e2b1f42c32bdf25a75b2a0d5d806f8ec08eadb1105079f78be6bb4ae82eb71886bd40b83c0cc0a8c5b136262c61cc4ecba381364bfb4fd0d27d9ff12d5ba283fc2df705aa323bf2085202bbf0f77dd92dd77272529d271e26d3c351bee3d282d3ffadf091ebd7c79dc62c725f94ea5fb6c111d88375fc52eafa1726cc057d79d7f0dc1fd557e7353b062ffea96446d981706f2423efa1d19dcb4a3d9333879d073c2e8da183ee2e949fdffd20b517a76f00e78145c147860f0dd2b80174fae7b98a649cae26edf9ef7390eaa0b31032e6efc2b47e31615691e982195f65c09b63729cb45d82b6fe7259ec1004f531f2d03e79c041f285359405029a332ef8079a7fc116973d5a33520a6431277c414232f5d7433e3131105f69ea15f9b6a171b1618311793e8bfd041303a0e17e21b22c8043a3b0e25f1f4d23f30b1677a0879169057001fe41f282b6ce3f9ffac24a0236189d1ff2df0fefe1eb194ff91aeff817cfb261d05f9f9cd44e4893160471d79bfc4079e91d0ebece1355b0b4ce49e150dd6eacf644349a398cd46f1b0beaacab4d0120bb6e6b843e6a16290652e35d9779cb23bb7e55bedff939ae0765461fc76b46db37622511deb578ce41df0f277f15eef66a5f6c0514c1c6cfa8768f3ea6c8cea5e65665eb2b63457b2c44d6fcb34937b4f67eb31e5fc9d725e94cb5e221ccc567b2bfd27d9576a87cb7368bac4f3fe3375980f020b272dfc80bb0345791847aeca13ecd74fc58be5dad43c476048c7445262319d357f57f4c21b77975b731d6a07953c72dd0c3b47e80a21df82d63733ca18b4700d6578c1303155bd31dc0e01f8215671d6f14e9541f59bf34bebf3bf0aa95262951bd33255679c8fd7af59ea2831baddcafc628dfe7034172bc595e4bed8ef7b7834c7b07450c20514b3d54f44647134b74bab914702b8a5b6432bb372b05a4b4ec3c2ae1b4735ad5c1b1fcc2e1d78a83607cd9f6c7a76a40dff8223984579f322ef03c9fd4247ac4305768e41323b00cdaaf9167cb21415ba44ed951a8dee58686c0e88163c19e39a7c11cc2b2cde66e6f3742ea96619dd577cf90866feb676ee05babf1fc15c301e1567d935db2bc8d9a0c02ab5ca97746a9e0251977037b398a5419c4515ac83961bb2da5062438df50cf24f56f98a41dad5ea43e85929b52eeeb242fc25bc93cc2aa75fd33ef2f8be7e18af204b75cdfe7694475ccd58c46a22c81c7e941bf90e4b3b536da96382fd3be5fee056b5f5166b1c7064dad9d1b786a3a234d75fa1ece1d71e0d1ecaba44afeda628f81a4243862b5fb83c22f89e9939548a812f818b9230d6b9c22f08db21815449421ce39b19ef84a71307a0d10313cee0fe61bda034dbba68496e950d6f3071c8c6499563129fe89b04b5faa4428bb14594a7e5aef2cf10c42900303993fb37d47d165dad9a8e4ecf57cadd93dc4a102f565b683008e232a30b10787f23275bf15348cb966e37e8834d0b0c33ade63df6842d1a5795c646df008ebba80413713b95ddd9e8ccff59aac20c3e10d6abeeadb08460a75aa10772b2463033411ac9ee33375cd4ba4612838e00e2485ec3e6ffb22e853c6f18d1d62de4cb8ed104328aff7265374171f5ac050a7d2f91b8166f0f6e87a45c81003c3fa8a9e6c421c74f4715b1149ed4d46e9cb4a3c7daf5cab877b4445a3c63931dd2c9168a841ea7beda2107c24a495ca5e104ce84af2f9ce76bf805c2382e78ae413e0bbc3cff52bce26cd51ec2a4afd0a1cd872bc97e0d283e8e8ecfaa2ea4f62885b7c8688e759b457670f15930e5ba915ee8b91564e1d170da60a1ec5b5166723573abb54258f9aee5f88358de207e0f4c755b2dbe891ab9de3b5ab518776352b9b34c8501d6922588337859ef7c77342337de2c46d94197dfa208fa1678cab2bb25ddabc4bc029a73159053897ec0fca7654eb13357745a4fc6977625ef112d3349d1cd12de905ce2efffb49a2e0408b17763370a282a8aa6f1407b4decd1d8f4f6f8ca450f2cce752fd74258c8d5fbc147a8cff1c16186b02ac68173555724d5318184979e013425de00f076b31c04abc8628626c697210c76073751a802702f52656545223a509b7f30dff7a7d782cdc594fd3c2287","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
