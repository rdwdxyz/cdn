<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"87bd185caae7f01e98dfff540b2d1cf2b23fe0c37a64af112d735fb4e2709c3fba98bac5c91de27a9acec55a146728b7b1f85e8c09e8a676b2bcc6fb62029a6dc2d05e5d55fc5e541da82112fe659cabf10baca04d1e563541d6da6285f179ad9ba49fbfa0347980fd3a9a5d574f2d73357054d0c7c942a56a07e28475402aeb736f29e796be2e4879f64e9f1a16b87852dc529a00e69ce8ab2438ad9f466c41bb56d0f8c6ddcc0db1a01b24e17242b2fd29d9d9d9af95adfc64d20575a1a646c9d74db6d0a30faa32d310518c463b65bd258c2fce5598d1cbc2f4e5527ff2bac1c2d296e39b6e4bb7b7720b33c7ffbe407056935941ed763347491681b33148825f328ebf88526fb2d4609fccc34365dc660085a1753aa46a9bf0226a60f36a3067ac0fb6f1e55f5714bd5f6cdb8915f61a8561b87c5497184433f7b3e4941a7ee8d4f0e938f0fdcf272cb40eccd7737fad4278283d38b50a7e12ffe24402c1970e53a7cc38cc58ed33f7a979a219db04cdaf8e0c630bb9823c028214a8a0860b5580dab8f6c339894dd0ab3871ab394235bb8ecb35e2eae667db660894dfd008d9eaf6508b54d8ff56a044c0348c2ad9e2bf08433df66b9c988b9ea0064277fddb013d3b059bf248c38f251a93fd81249b49788a8d9d92e67370e4fd98f5fcdd80ab08c44d63fb5575cb7447878794fedfd5cf4e2481db06a1030a8b2784d39e3c38a4225608961feb98ff5198bd4cf70012c949c3876fcf6dc8127a8dce9d60bbf2e3d91dff3abfae6f6b9a307b9d6dda8da590cea9914ea9dd4fc453cb0eff497441b53b8e08cad473494d54e22992828c173af208238447f4d5e8b80ca4ad64e91beda7344e03e63d66ad3f61cf0b04a82f54e0b8a78e1d11072e1d16f0cb0c86454472ae644a0a12a2f2b2c3847295c7bc02be7ffd83d158d9a79b8a5c52de6d4b9798ac5cef07e7f3f641955c9589802760f6581f1145e2bc08dbad0dc31245414e9678bafc4550594355dd731c8bf2db52aea6319e910f01f933ad63dd10362eb1c3b1433a02ddc638b609c3818c444bc928954a829e6211f693b68697b54eb366954ec9df48c9e9711052d693f65a23ec346952b76e53217914d76ffce74f01553c3ffaa932619de3a972e44829e3a671de9cdbec607ba94df6956bcdb655e746143eab505a63ad59f1f64da078074dc598a7eb057b842eaf96a282d0e02d81fd1cc49cf194652f3026b7bf8f8df0890b4569271c9964926570ff2efd00f32c54cdea4e05d0d95c5e4756631c1db6933dbb502efb777e30e51c62c63b6338688679fb434485eab4171249d4a29f294b210222788b1f436f54b1faeb9805dc66effaf4a71c0e62a009c223635cee3305afaf35ea64f9b5d1c4e60ae0020ea0ba08974432b6317474c77a39878a1897622329423a8a459ecec2cbf29d0304e3362a3975052317774e89721a68ca16df0a8c6ddc9f6365e34cd75bc6693d2c1743c5a9d1f0a02f152e76c6518f76542bd3e7a6824d70cb6c10fc7962b57324938c91166f489dfee74ecaf00118d418a21bce12395b09ca526595bd4c6ddb2e0f98057e656316e816353c503026a1fc321e1ded31361e3487fcf1cfde56ad00e38effa334ea62af7115ffd687d35543b49b7e7ae25dd1e5bd57b687bae5427cb019fc3d4557d7466aa1f426726ef63702c7d5f1c4f12bd3cf83b01ac40b53b07f10f863d8f5342328a015047005d2b69e735eb8244f69a1a761619df094514ae07611a79c1cc23c7edf98baccf06377f7a4245629acdcbe172428bc335429cc14cbb3f2efc68f926acfe9ed5662d004e816c6fda7fda559c50df59bceac1c7970504dd33d536d02b7f1976a442ab233e8c781ce220a932942bd3b4cb065a85bb8c55526d27f2300c9d026d206d3d3363f4b82eea9e77a69b56dfa2b78c0cba501b14d1e4c80fde44123ad837f64b97632d3c659393cb5f1309a5227e49b52818d537e2099ce7156a6252e66a31da2e3eb04793bf603e93e7f27d7e51af8790981894b78bff15b0eb6fecd1f28ebafe4f9886be848689b46bc960fd3f5be6392c666f604096f78521a781c4233e3d2e72663f53251f9b63cd2f188aa4a39b07fe132e8f5d0ca52e36899602fc9cb7120fd499459113e0f113e40eea31b9a02deee203899bc60edd77bff6dbcbaa86ff1a1944c87b266a022e532279fc7c1067cad6208f70391721701e824dec54e6bb2fd781fcfeb9170002c1be5d2be98c06706054bdc00e0a16f67d831fe31e87d270534dafb923588eb86c979a91317f87d3264478bec5d038ca6a79c36ad9a753d2e08565eca4bb1e85fd3cdf6fe5c29a7d8a2d743cf72d09007f6d9cf337afb4663db9ebc7c7716725cdb28366140cb8763fdeb954239d07eb2b9f055494956a8031deaf7287ba0519b7b5f3017f3d5a0b897a158d42f68fcae525b7feef3de3572e37c4ee50c999e51c3d87de1da409352528adf2ce8ed0c614524163c9fc7046a81ff4e91f170740ee945dcd50ad7cef27707ac44572f8a9c46aabde0bf50b85c70f2c8e09f64ea7dda668e945f2545f3a51ddeb8e9e579de5703bbfc65f9c7ac88587754c3d3e6accc488d26602a0d5d449f553d03663e3878b8905787dbe72166654916e3f574e23d3192e4069bdf12f8180983472033eacf750f1cc30f6b730ad99d09842e848d4d8144cbb7b41b38560cdf68ea3eb1d3261186ef3f7bfa30029bc8552be060224d9f3879899e2bbb031c5c86bc3155c3720c4dcb6400c42f1d0aa1dd1a182ab6d277ca99b9707f45f260c78591803e208d9e93f818b21c7ea89c352e270cfc8494a2474f6917adafdde00bb678245ecb0a2247a38b83a21a583a420f8c89f63fc35c871c48155b830c7b651c87fd264ca72242d855d34f248718abeb31eab757314388a8ee63bd1995a4f86c1be974b3e1163bb25f3540fd606aee691714b2409277a7ec30032d886ee833e9160d2f0ccbbde4d541775ef3e0a7bd72e348885c53923695ebe85aba6134d3519be3a50e5a58519ad8d9669579d6d04e463cf94d646e0a5e01125e83137c84fb96f1ee6d77f55ece21e06eccc6381a569f7fb8caac2b6409fea47ec5dad1be0bb307a5d9e78be9794122fde82650fc1a091790cf485a48a4f4ab5d473920b647dad5a38fc063355a403dfd1385b347ae86fe8c62ce799eaed6656b19a5af63b305e9b71f0d47a53ed48f4b4d9954ad44bd91ed17be5b767a459ccc020fed423ca53b0ca38a91cccb42967d84daf3c21f88476f82df84a212bb9ecac9287f1e7bdff342523324e08961cadc7f041b908b1b178bc907203a2103f0e1ee9c699793946e154cb15d73e5d0762ab24a90cf21dcefefdcfef8809d46c7f1989504aedd1fba610920f6b06f2aeed7a8b0ac754b725ee1fa09616d8027c3b30538d68657c87790b0213975cee41fc437e835a893fd61cc3e432702a107c5b19cb9a0d8a9ca26876d27cef3d12caae248921a2b47d18a58b813d744c6986e12a6f561266082d9dd511923ae6079254a668a31b3eaacd674831a1d7bdb69f0b9533ec9dade4219b103c41cfae3d57739ced972314cc84ccabe4156477b45cb0eaf1afef7c12efbf7ccf2ecd928b0ea9709afd4626d2c0fba01ab4bac604ce85d24ce3534e2f982cbdd7cb90278f3236fc9144e0dae0c3bd590ea352ef23b28b7f76b61b719f78f9078bcae54adf344ccff9c83fca52c8f32600ff2c86c2948b783f1ddf3dec33b28f56ab570062020e78617d55ca5ec66f4d910648676b24a99cbacc1416e66cca2b41508822b7e8ab0b7e306da9d5da5b2694bb079e9c1f9893aff02f62a4737f073358a6af070fbe6e5087b4a143141d9ff97938663aadff0c9e5a624370266c7f094554d5555bb19183b432f91c315956c63467b059bf19c146e3a350d44e67196a4b516cef98bad8689f279e48d513e3851bbf03d0feb24b7689c3c38fd1c4746a2b412a2a30826a8622b10e4a5f977072c6f4d50dca2032441e98df0250e33d0671bd2e7641b9459cb33dad59e3f6ada08b35977db4fd61908017bda3ec0742bf3a281ca92dd7aad87d280d7fcb89a4e00c41fa29b134e9d75fc869bd7de64ee533da72f55c3d1066c71d8ac4fb75a7b994dacb4bf52ce37a34e85a135dced3f19bcc6632722668a16d90c2f1d39551bd7ce7caf9db678ad13f53a8428c97f42723de05d1694fdb7d8a75af5854cd8655c0f61c47a15bfffa93054ecd23ee386924d0aed38ddb37995f927f738451b1d6e2ce3300d97eecd739e9cb096845bc4b35f9fff622ba99fb0127ee0fcbb87b8f21ced429803f573d8581a27591addc8b61ab5db729748dcd79c279eae45e4ffc60b4564cb83ae4ca3c091020a84e25dc2730f50e29c4ab78ecd20a81507f74f06272dfffb9b8279b4fbb32e7085184452525414a64505bb11375f7e881d1ccdc1652a20da5ceeb07457e513756c33097658393fab15646e0dfb5ee08c8f9919da291f2e29ce07b33ad3ca7bfe8ce0d4582a070f4b0371eb8d233f28b09632dc123ea695114d824896c815be45979cea9ad125b9a446f310a9b5f7ed56e02eb0efffd2574b26e06a163e32d489366f7ef7b7fcccb2e940ada6cc5260dac7d676645b416351bcd0c5a68c5e8f41bf09cc19937b4bc7d8ad834970b223b8daf7c439ecb0804db2f364d62871545025d9efc62aa7ce8161e9d3849529a7e65201fb961760113008b210d87b163501c3809d6d90d6798f44a1524f19bfeacb07ee6c641262b3610ea634ebaf29f086071fc235ff6c28c77ba53b5f30bb71519d701089fca7b6e176579315ec12df5089aeb376c5be3f3ce18e30ceabc81c09cde999ee2970605d83dc07a353a88fa0ce677623467abcad1d3ba613d9bb42f822bd0a3754baf0d6398852bcf462b918aa41cdc5925b6a9f9dde753989b73fbd6de9daf7fd514aaaf405e3dcb3c6e539a79ea15418c7d3c8c4c229216dc907fe453b7744de00a58c1cb461616571f925f18f0aee80d09c0430ea11af926cc140955c96ed88b27d624696a6fb8f2d18e765f2f908300a081d015fc045f016ee89cd51773815bdb2525fd792e776f8342cb6234622cfc09d50f425ed4c0e8638e1e36dcb519c443a607eea89b7c164eafe12d1561742afb8e21fe008b116342243873e380b426b14cae4047f8556357695e9505901bbef0ffec70763d968cb075cfce190fccaf23ce3009076188d7678f680ffd648238d86604027b5ea8e79244dfb3acbfd43f16015efff83abac3b8e1f0995014ebfb8c6ab5114028cfe19b2c1199f261a6e70fed5329e3047c793040be913e10a1f6aefed8c2d84613428b3195491fbe395237d298b40df11d6f41bea8c0f4488435512aae941f176ba84b867428b1d2cb1d46a650051def9a881c4e7d399ed154eccb0f2ae2e8e0baebb0a541a5e7a200fd4d1627fde01ee42f98f9747221c6f6375f236306705fe48e00bf15a7f28226d72115c3d5300ada959129d57592c678f9a7924595dc00f773375b291a1cadc62cbe27633c84bc1e6fbc6c8c7882b0c257c59ee96caff5f48b279a68317bb049296df3b8e3e0d95db932048d830c24326efa543d1c41cfd9f193a358ceab17d3c5b57f643cdbd1623c492b4472baefa6678860656f9443fd27a87142939abc8030e72e857f85b8072bee0fec5fddbd7051b5669b4221884ea8c33fc534e98e39a54eca07aea30c68d5268aefd7b4c69483c59e806677a5950a2ad5e1b89e265869007fc0c0e641f8459a8179c10f7b9aab4121deb168a28012a48ce8f773a47a9da0022b7b3c0f147a5667c4020a1624045df80a3bfacf99e47d2234ece801a1a273a634dfc83f045980b5703b27d3107a8c6f966d317dc2fbb5f3b63855df23be28774eea2d0deaf399f98d2e6502347194e07e03c599db73d461fe7815e04a9dcdae96964ac6253beb64e0dd5b3ec192e48af53f55ef57dcdefd7946cb28eaf9209cbf1e712deacf778b4896b1243f210121125c7df7bcad475bb2248ce9d6f0494395b5a103de83d6c4c92dbd31058a9cfa27e5a019b897dae2abf00dd4d3567537d38360c59826081b4b91b7d3eadff02646be19cbfa0011e8861eef59fb427042c5b6cac11e075bca1378f7b80d7b7d67f991442c36cee0b43196e6ba65970b1467356ec8262032f25c72db1ac2248095e50a2926de0c2b1b9503d44a98853c78c19eb5f593b314a9b516a4d53dd272d4c4be304b50d3be5cf79d2fa72350482daa75c2a0554d0e0322b9115c3d67b10e2584841603c55a9db782f4a0832ea5f10d448eaead9abf04baa87a951b1dd86bd814522641db9478447255ff7bffbd53beecdeb81bd3a05c01963e1ab25ea7707b27b66958622e267a2dfad0af7bd7493ea828192280a9e81ce3d767b98ea2dc48f049656944d7341744068ba09459f80099c2fc477e57905300f2d0b69d4086de28d45d4f1f5e85e75991b655198c2907203c3679645c4f6c70b025316d2120bcc6579a29c36421c597b489eb92a01279c6d9c3fdca82c46f66efa0d3e36a269c9787ff8e91a83018abecd5d11faea1e5d6273e3ff578f0d7c0399fc79c72d72ac49ec042128891147b84179e26660f71c4d3544bcadacf12474f72ca92051dc37808ff86ce59bfd66d208de92ad384ed8fd807bea433bee6ae00a44fb409521d89c5cdd33be46a0192c430ae187bb55b604f005f618c234db26e3eca8df69d5290d0404fe41b2b8753b181db6249968112408a18decef5e5806c697bb338ba1a781893f64c1c0f24ab5bb958ccd49a9027c315dfee6296d8b8c75ae0ba717e60e42785086eb4e101c3395fcdb8aa7bf1204fa2261080a371d4bada23caaf1e0dda2e7edaf2f02cb6abfb6f5f16d14b0b6fc246fe51a6e4c6f8239474a85ea973d93bbf93804f01241b7e3b503ba73d8d994e9dc2fe4c5dbae4c76845c7e33943f349cf3b27e28c0203f142b73aedd77f5fd03268c182442370c6b7cf8d907821db103afbb73fdc03dc76a4654160c8460b7e1b14822084953681a890ab985bfea94505a415c714ce61b365dde79ae12799fa9cbdb402b201d31bc8539e499735513e26dd109a084d69d7110039146f42b8053183f55b6b552662fa91db5492199acfb64102e8a2a66d79b02745b61f8346d36cd7caae271f86915ad39ed983a4449ff5ee3953b5e58bb5dbc188c4322b31a994ed5b16e9075b9c3aeea8d022c93c01231598bcb3b6eb488583e7870da9f1302a360fb47a555d103363ca7b7edb9f06720e0dec78180323919534ceb874644492c270d6050fe42e50023e07155f1c5fe3dc4bf95080c9732fa6460cb4a199c11f84b30cf805ad306bc9eeeb816f4b583c5ec9c1eec521cc74e764afed6312632ecfa8f607fc05c4508adaeff97d4ff9aa9391d97ab46f001f5b8a53cbc3197411856a108e3a5d6df840a8417ff3cbaf285b191bbd71ab7e03ecff4f3b1d4964ac75f5b817f38d07c3f22b6026b98ecc128a854a054d64c1f96a6804cd1fa438e076e40aaf159805c837bd3e9b2c29b61f338629881810473d829c482ae30c01b9226760104e33f9c8a95108935efe32a9b843b0f1d65d3f34a4edeaf12ffc5a9e4450600a00ee9cb7211689b167baef3abdd4cfcaf1c0397e6cc4dba3601e3ae954de205dc2d8a1d710fd858b61bf8c367994cac3087c27965716fb3e913d986c15359bcc2b672772392cb544733b11d4e89005729c41ca357674926ea1bf62761bad4004ec39d5a6d82224d64e6094e5ec5b588bd1bed45f9cd5d2bec1e3eb3f480df6312327d47e42a0fc3fb46756f06a6e9b93f401f6718002e7248c62645a56e229b7552a3b8b670c51c36e35a085eb0cd3cf724f9f0597eb3511dd652a7b2b86f556800117e96f71592dd23fe8d577d2042a3e93db71172af59ae2b422be2778937c15f88e672776477178dc1e3c774ea953dc5c94c434fbb4bbfe5ba84426c8cb54610a7d559ceb9f82d7447a2deac0be22afaec80006f74cbf57271279c42fbee55826f2410a7f61fe801e315b65f80a443b8957234f830ab06fa3abcd60b106c237eb193ba581e3b9f22fd7ea92faf5476638cb1c71f5bc9edf61652ff6ec0c4c99929800884396ea0437199d498df34ae94e067f5bfdbe70e21614525591336e28a6773a3c227b9072c5930b5084bc92750dc71c685e1b9330710a5d87429b3973367ec85e827c37b2ed3d6f8cfeddaa1c8e934324e33ab013d2d735b3be39bdf5e5a7bc6e81b439bc8f72ff9e7b393c495d8c4cdc622fea4f6a64083aa5c17775cf283502e884f850bb33b372ca80d4c5a4413c2632c7074ca6c3666fc7b234880f6e86cdb6df9d7c0a253d2f7cfa45c60c4a1d01c3e568d887e9c5b08fd566d55c9c3fcb6c6a444c9ef8db5958d9388a15419a5e87a7c3751fbec20e364461d52a52603e8df6771d6c6cc4d55a4fb79f39f3e931cfeb24805d21bcc96c5a23b08b79f83d7f39c55aeff04b345580c85e4472885fe719fdb57f701b3fa437f04f6e858d7edd5a833ce87570186b64845edb4a4f66a252eaaee334b544e3d272a6c38eba4ae64bf9c82c3b177367a77f035af4e39cbaa652a21dab451db0c355e19a7aed704500f897fb6762aebc63a8b26ab5b1259f7c7a3557a46951f48ff461a136cc4328ada3af8a9c153c6c33f3d2b88b6f3e00e2960b92b133b3e7316d0589e2ecf7e5225c112bec4153cf451d0efc2bb1aac2317dc43fe34248b27a5a074e089aae5d4cee66506bdd8696378bc3dff8d874d2ecac27c62429a6f5d9939b101dc54eef6d7d26bf050e954c25a442174d6694f6ebb0410fd11c2a7c6fb4029b7b69715350d31614499e7407494aa5685c121b7af400d44f6ae0240064f58982ff16d8165f36ce2610510a0b5e6504cd3dcbb96e8db119ad1e9d7ea2332bac27cd47b74d90376e27be7d4ee307f8d81a8a25809d439ec375465bb3975adeafa86ead808228e2873c7cb35fca943acc7c1932bf89ea14d1f75eb37884212fa2531c66849cf0682e39382ad9809fbc37f1a7f3422118e779784f03a7a8d1082c43514caf28c6c7f92c9b704f944b14a3a29137b034c297fd772890fbc32f15f7b871a2bd3efab48b09724308637ad012d000fd58dfe0b6455e6b7924994c4f65abba7e5c4605fda5d6d5258be5545f106056d6aeef83e84c5d09e9f9ce373140d472a1691bb18521889bf91b9e106a55e1bf942811000a56a45dc3ad9633811ef04eecbde0e0bf78cfa240a9bf8e87f75b32f129edffd07f9fa4c8c2f503fa325e7ab641dd962349e7eb1504199b1beaf0988613fe5e1ef07c431ca5da7b5fd897c781da301b1b19518d1c6d0ade6cb58e9d4b891a1bc0d917c19a0850bf7b9b77d758ce54bb5a764ca2c4f662496cbc6a967d3e8f7c589e61d687256c03f6e263cd7d7cec68a09de8e708242d2d11cb19e3e73f635230e9c90877cec280f44412ea3190598a98bf6d7a10cce7cea5f97e2e532476096b521fd58fb12acc04a507c1ce8433553548ea1911745a98ce3d44017dbab05e2c3615a078be9683f143f18acff3bcc4db8cbfe5b9cb10c425bfc9c29cf7cb267c7034fb4974347fc8c15e25e30746f50bd6e057cbc088f636236ffe181fb5144eff2accb04348e9bf505de710bded332947bc3a4ed5cb80ae26fe7c02032ecca8defc1aae897b0c91e0c6bbb2f2b7d3e49845b0613aa62bef8003a48ec94e617b7688c22ee6fd9cef7a2399f076152d399f4573f3158edf18d0eb4fad4a06d88c84b3b9969f1fd1d073464174e7d5098c587da492003900c849dff02bb51f9b622cd9c678459057c32e23c0697ae00e55e0cfd69036a84a110ba1a770374f486a49ba2a4dcd453d5aedd411e3861877d27b3657002ec8215b18d9030451a8e355759f95a33f0d673d3e7b2519f0731feb9d757a022af855ee61cdf10d1fe58a378d56287d24d23ef237955af2271f70c9d404fd38a30554f81de7eaca17f57f904fe2e2821428851d5af924ebf496f9ee14f2cb92ca075a69e422e7c206b251934459f3a63a3e84a0dceedc6400c66ad445d8ff441f722c3e1f617851f7f7a7e4114c764cd1a97d6897fec65f8eaef4a42b29a8e9b50affdf662be2fd926fcf3126305fc34608b2c5e193c18fe334c0e39c1c7ce538e9669c4fd9149f8155a771d377c7863f49eea618cb6b3e8783d50ff07a0ad61ae8ead1f9dab4ea08d7d531ac6bca69dfa9f83a9cac88ea51103ee55a523262a292e5e2d1fad2c3529a4e83f080129d8bd20e630c07ff15da3b73ad0f5139110dea25cca0576e0fc3e78afb50652d39845e0902950d7133e54446bb584a2b1d78d6aa14da681a8b18be776d02ff45bf76d4b4da7e743d5080f5b5129b49cbe7445a667b3904c66fd7bda487b025eaa5078646a767c73e6906189a62e4d24e5bfee95400c7f4c843b45a132e9f0ac88601350d92d172914666f74db46793092fdebc004036f93ae897b143dab4fb829311972822c58f2c752554f4a79946238589384b4915223c861c719d231986a140fd0feac1e288d26f3e7e9c0aa15db4a0a9c73374276a20c9b54bc4321ff793c76b21715a66e6f0a573e5d08793eb3fea4e3fdb76527984d86c57fc296c250896cdb455652817c5c201e914dcae6f54be7f44b965293357eecc5f6cc76933cdb3c109a2c35d7229ac3940eb55b46a5aa9779be9314c8de363c3905d765c7b4a1cdb99ac82bdc43e4c2d149c225b24e808b12dcc799eece3e40eb54acca0a24211dc22e66de7e725ce8bedb9a42f90192ffa2b73c792315d8f8aea8bd8a9465198bb6daa7205c59033eeb33908a0dea6ee3e3af10c9142b0502dff490c7234b3ecc7121823186539c13f0f131d432472624cd3eac9c3e17c87bbc81d3a0c56929bf297e3b9a8bd9ceb490978edd6cdce09812eb07227855f8d85322baae8dade7ed2a9bd49b9e04871aacd19fd57280641c9ad373f57178c17e30b68fbc52a2c3c362fa2fd33f68b7c92221dd00f979b53f18642be0edce29b24127f7aa8d99b576071ed879388116297bfb6eba091fc20b590c12f415fcb6017166dd92b08ca39559a2d85f56076a22fdb207b6ee75e764c97fc6ab5716bffc649757d24f832f736b5e7480a9b62891723b8210e5de0bb38491eb5010f8d69e5ee38d280bf1874f6146dc2f9fc0559933dc0df3e1cfde22358a5a2f126e70661abdde63855aee03566a2280f4ea7f85a2411edcb87aec78cebbcd7088741330840053ce0a96ceabd51f78fa18d8048ce552b83a9782746a807525c26890d5463b9b2efd51a2df87e40164f4362e688348ba6aebe7d2fe5fd8668496df69a6d5a6c95c24be324586096aa811831d7f5aa57191163f8a0c90ffd15d634e17f079184eaac701e705e405abe8c093f9f287e50cfd12fe7c7a7ebb82ae48fb5e8587ea7650e318e87c18847ddf71a2d4bf4f25276cc223a738987ca5f8e61b7d04f370a8c534e80473db7c10a1e8225aea3c7be12cd69bccbabbf3fe89a00f5c29b7c1d54ef7ad7696f326e2f1bfe7688a13b7106cec01b1168e16adca6cd0d00130325d3ca3f46ae2941347b3d3b574cc3ada9bb8b459ac37b8fb5987dff5fac05d6aa55c6ad9261fd289533b12897b7599de002477fca58dafdf0969dfca1d699698e2e564319d710d91eb46ecc4dd197d94d5cceec7108e4307f3fbde77d768d612282a829548774306e3435744f45366f7cad2456008286474d040ab92de48013fd75282091c0ba6222b841aa8207e980292fad08235acf2fe065af4b8abcd8cc9f781ebd47bb886821454d89f493d4c3cd4078d388ba1b98fdf5ff2706e18ef448741a1ab7b8a5817f6f90ddc8e5467c442620ea36b2fbdb082988839d20fca2e66db86f2d6864bac92f9c572a3a054fda53711d41af9e53263d6fad65cfd809045333a13468c2a13de46dfa34d2ecb1c52da613c4f51f727da7f4a5bec34e13397aae1ed3b5c27ea2549cf0d7eded69898a6e656d45bdd1132d96f71f01e7e68a02c706f2bd681f753ae7e33688fa43d043d88ce122b315493941f0734442f6e7652a77ed85f0b301025b9986c0a0902cca46911efa9cd19fe255bc0dcbda4d3806b8bb7811b147b285875ba9db4cb5f0e757386e9065204a9267d792b095f83f9a52daf8822a69c369d3dd9ecb61a9ee4e4d07f239f75a1b1dc60432240ead10d63e56172bf1b34106ae49ccd92cecf0a1a2f509e49d54e434d394134d2a84359a36583568c7fbe92a7820b773186ba1689029a0497e50e8f95cc3eeb184af1bc753a266e0b73495a93fa8c2be724b8b3bcb5c93e2a83339d7391b91aa1b734264659aaf6a4e0e55659ee8358adf052e235a16c2931e9813731fe401467fa5ebfc599b52101b8ed338f615adfe6b998b3aea07482fd9c7604b7a388d07026caf006008a366057dd53e337b7bcc8c1385efa1de2d754b35254a659c13e205cbd37211e1a9215ff95c5c8f4b3bc51276f8052a38f59dda8318dcd3deab9c6be0f9ae0b94e5cb5298305daf9d84602aad6b78777c63d483867ca4ab20f3976309b10cb8d3b40bb04ddaa61ecbf42a800de3928b1c625ce7a000136c89ac8e3a987a9e5cd0bebeaeea8bda0e31ce82f7f702084aea1f91e369cad04f29e4ced3091035fe0651686ddf748f3161b8991efa509ef7c073bd8e1a38e7917a219812688e86f9ba5e0b17147145fedf387e965c86c5a113e14f7a00850d764557eda53ceeb5e3e5365a345d4c23b63dcc54b4d7bbcd0b4d646c7dd776cbccc6fe63465d5b6ab4ad26dc3e0329f476bfa163a3087bca6e8001ea46fe442cf8208ac28fd9e07e3b0b348c9f49ebdcf62c4d0e444dfe118693ad1683218537c656012cffa356ae8827b2b864859298e039dde993c14257e260f9a512ca5ce417c4d5d875d948ab9ccd8dd4c397f79ab2affecaf68ca89f52255db81d45fbd900f648d6254074c7982dda45a28bfba6997bff53e0a90307a2be7d712f46f7a0cf14e82b482be20fcfb165cc0527a22f70f7a74279a2e508456c8445dd93041facbd4344a60f8105244c6c55d0a07b71c2e8f6689bd0fbe038943e9d898096fe9c3b64c8a9912a7bb943307084963d940f98c77221433b2efb2dc27859f485b5b0e19fdae2a8c12a1351320d9cadff4951de386eb847921865f49a9cb293b037dd129f9510cf0785aab30770ff5805fdb8a846d12868262208818050066e579f996b1c93e829f929399dbb2a31257e9fc93eadc6801e64013900c2deeadb02f181dc54dc314159c8d0ddd1c1705d34deef810b9d56df84ba2cd704a84f2c638015b97d9fc5d88402b590d3ce02145beaf4979a07a622c754d064029a0f5db38aec6a46d5d896003b72f2db984cd0d8ba230cde04c8faa3a886a080962aa23d57d2e0ad4edc61a1f862094689e7575ad26f188c46b9a3c777ca98b4afb45d2fe91c7d403a6fb9314c739b12531eeadc656d49c775e78af77dab66a3c5c5f9538a63c9f7b15e77a3d0d30b1a0cad82c6c06076c53cbac635aabac590b9a0e3b1e4238103faae7c2ade107106a1e1023c046a6d08f0a2603e82578da94e1e619c564d81dc9017f9f505861697609750d49a1a5089dc3a21f1d393c02b949bfd0a04f1e367ace8ed06df0d9a9ec1273150b8bbb15c9a0d798931f9ae47951112b301146cd698eeda04be15e1c20698b4dc391da23a3cd1250e14ba40c1f39773ec3443a05e95d01c4bd68b43f76933efd5b7dd6c5b3fcfbaa81249b1585627a1846c528b040768a90e57ae1edafdbd3d533534b78657b7ad345ab000434b21d3facae1ee50f03506dd59df892f1f753a7017a29ef8968b51d25ca0f3fc4c1e5a993922a121da493982e4faba81513a6d65b41c99466f1d603c7716e337c45ff3b36aba3d327c463f6f8efd2d39480f79a4d193cca2980b2e4319541c7402f6c1a11cf10bf6064aa5d1eeddaa41901b2395f9dac8323e1867e6c39db868db52c0f3b8468b150dc96238628e5e687449f671e453c1939e3d796e64292ee4e4ba29b692df54ab78a75b7301b30b5e4b64ef7a35053da35cc1789b0788565089350268c08a8590c35800609456027fdf6cfd0e4c551d971a9f7fdf98d5b30e3f8de15094f36e911dcda2b46f481688434ad78a7ef01d4a451b008855807334c11b9cf5163d30894fa0b9a2e401b45665333e681c9d7a1d1bfd55a1546d7cb844a4c100e683fed1ef7e0cf52309d1ae34a140fa3e5ca0724114fa0c08f5d9a114d2d61c318c53a3ddbf91bcee979b32ce4b9f7da7322f1a4eeee21fecf315161cfd79bfa5bc8555af0e3395175e91b78d375044939358a678cf1c0af4f192d1ccdd73b5e4f8d89c56626ebac7e2f9ff53581ad2ad4c59ea428d2bd6c0b4d1f05783fd3ae2e9daf0c80ec6fe5357f61c212f5bf68695aee6adb06cd64f15ae07bed2528b2bba5cee967e62d48c27b932bcdcee70cc13c210cde3539d7d8903e3e383c48ec62bf5fb2293d67549b75a0abd366cc872ba69d3943e62d612945752c92096c15134e973290fa65a6ee1db07ad701715b3e07cf4d773a61679cef3031f8c7c9e6f6fdbd4fe3bbd67557deb4ea5ae659aa7a2a8d00c7225cd0de70a5f65407ab7f5837afe7fcddc0b50e69a43d817472f357fed9f8cc16085fe8f3e04e6111976d613d28ff73542473b3ea03c593e350fb27e6dcfc72c1ff6c89e6e7f9207997e3b5c31d64bff83aadc91c622415b3041d5e7fade4f120349d3d2f8605be7e55077ddc4297aa47839f74e474392ba0c13d98ca74c281032b03a39f4c77d921d024cb9d3add64c8490cae0f832b6cc34612f3bdc9aac478cef66a61115db01507dbd0606c316a6ff429a2f4c61225cd4d164ef7a5a3e60d805ff620fb1f342816b0dfb5eea40687a934f46504f3078749f0ef51422d0a8dc499413f8d8e25a3a7e4df63f1499fb00cbb79179f4367bc7b55f4810f0654aa327cf6d9b73a88a792ec3657198b43710c281c576bc50ea66b9470f8ebb6159a1e8c4f66551488f6d367bce87e0f72df36de097a9e7c621958de3ec0c7401ca1347261def60d1225c7012ae1dc82da50801248fe043064cd8bd77e13db60f75632b6c198d627933cb740358dd37aa78944150aab3af9d6a158dee1a6e0120d6d3c6f6ed3ba2092d1e7d918a3cc24ce24b6ed781b06bcf42307f2753ac50ad7301857d722a6e7524682df64992b0ac91765fa333f5f1c397cee2a03f8d09c24a0709974f9c022f655a9ce9911900d518821b636c6900224e4f2ba94f202184d631bf02870810a1df36ec62dfa2e57891f4578681c5ff8a3228ef69f9d1f06a9478f6d37d3045ef4d20fcb685d5c04723908ea4230422296be399a7cfbf5fc1a00e297e00929e8e7fa661238babcb2b3ebad00a69b6da6d16eda7c2443fc4b0c247aa1b1dd0043975c7396edfa4efa3ae6bf068f156fad20c9c05df34a0690aff7d7adfa37b1e7feeeaee0051a3537bb46a78874ce3fdeb59f09f62c8f00dae6b2b663a5023ce29e0b4543696018e464dd8e15cf33fad37c54def910e9a81edee613bb1a7e47ddbb6d1a1b910094e3de237125efcd4fa5d5da7717c9c9002000f6665cda6fa0fab098fafbd4f540962f10dacf992267fc2467fdd09dfb4da07ecc5b4f6225dc918099b77722ee58c44d3de068b85fe7a443d44c549c91645ffc62969f790ef61ac9fbf5ecbb0ed777fb7b60776d91584ecd5cdee440d5bbf1dae26c130148a73ec40c5e978001d0589c17fa062dea6d0fe43441021661dfed78102d4807f0bcb4f4bc73d9d19a2679fc7cd3ed893d704204c58e7d509088069eb3d7aff2d8c21c1e6b41646eaa1afe31b935d194c894a098a639642674ad2ab046ad52923d2fb2360a2bf7f24292ccf0afe1acb8edd3c97dcce915cee8676b8969380a617086c05d570bfa86247e44cf6679a906867d7aeef48f3937b1698c570b2f2b2e998d02c7d96c4cf849d0134d491320fdfdc017f5bf33b653031b243ad412a6864092295e087ac529f0a1e5506fa088fc931d291da2fe3e5f091a60a425e2bce45c00b4fcbc932d271915b65c13efd36c295994a297e860adc631d226c614c5f8bdaad4bd3c96a55dd86e26981621bec380c0bcdc35209f4e62eae75b88342563e6071c9af3e0779b064eebabdeb64a147a073fe1b5b19a09243b786a6972d939b924302ffd1d2b104eb274495b4fb79622c974116535c6bda4f7a7f5ea6cd420f271353f47313db842a8460ac92f059bae39d7b6281b8cbf93b1bee26b052e9bec3b8cd63cb7b0a3dea915024d2546fd64c18327542182a6927ebe329eeade274989cf041dd3c324dbb4e7ba2e1dcd2aa0454c62471c6dbeb2b4d36b8993a3c143c25861d66a7f79eeef736501561f788fa85526de375ff08c0cef9e9a49429ff8b8a9eb60d502080c12a2b4a8d662515d9d43a3c821001d56f433b9d85f42853884bcab9b420afbc1832cac1b28409941ea3377ffbadd9b8df833d1c88d4f659f60918b4b17990cb0fe58a758915324be0948af0dce2f1bf5137007571ad14c3561db86851db6b38d1d1a5debc8e1563a727b6e6157c618365bf3f216556f2c812079ca084e0345b30ea765360213c90a7c69915753f9770427bc2e24250835901095303c0e952d2d85b5be348abce7af14dd461d5577c428350c67e746157a2628b03af15ff18fe6689184a0c22f7324f74737132e931094cb0b1c1a1d8046da16a83a40f868557a7259561d0994cf65b73c8452761db0515984624bcecc35c787773a99af7a25f3d04b04aa91de17811bfc2e542d50a9dcb9f2a080251eee1dcd26c874a05742acdb344cbc9b9fd7ed1762ad278abcde20a24e1b5d162ae7d75277ff40b4d66023784917d0e19f2ece9795491535d55ae1dc037891736f73a658ffcd0f21228eba47a3e9df2df847a37334511c2a4f938021feebe903eb1b40c63ad221b61369c0e2422cb131e15045afd1ed396d55449ea06dadc919de98798e3f604e6e72450279eb8d1631c33e5d0a4e45a39543d1c157b12be3f7571bb34298e87adcbd892094025fcd6ce94ac252e7b6b9c182ff06010a2781dc5f44288d6a1aa6f5f2b6fbb5c4eed990f90a72cfb3cc68bda0c7092c2ef99c46c8600c0a7b75c57d4c2f7a7c6d5b084b57ed77e22a7361a4c8b57289a609801fcbc8033aab8732b673b0db3ac9169d8e695d9ac1295c00d29b6e3aa6805355d0403e10d927e731cf11a5114547e5710c0930eafab6630d8a5d27adb42a650ad855f56a8460bd33a0132f5244778960411b22466b52f08403e4062b8191e9d419d7f01bfbcac8fb247b21b9d960291c2490fe083ceb393006c50ba900d3a2340404ced272085940d1d000763386d1751a7c8e13c3fa2ebc4d4fe315a8da5160f3355b6667ba707fbdfae75dfe886bed07bdc5747eb8528d9f5761969659f235adb5df9ad4b1e7516b27ce2c89cb394749b006508fbde219fabcd7f245475ebf26aa9119784e24b5286665fe9f94a3689dfce2ad35a824f244103b53c060d7ac63ce027aecff881369424fb147ee2e07ff63507b6eb8a752ca9c33b729e3f675cf3430e5e5a942dba25b98354eeb9368f55c14fc112e1f2eb3387d993265547de297848480c115fef6d44d70472f7e5a4e86ee960b123cff32b256ca94e39fb79ab0a2f7990e0e02f5e6f94394d7e746ec79a7317bd2b4d6ff5e631db3fd17244a3a2ab4aea250325a10e393182a8832b3508c0a7909b73b3d96074eeb8d3c9ab6e0922342fe226aaa0b0643330c613357f9756caff68ca9d7774e304819b328b6d8a2a1770cd8b4e1bec93326d72e0510061cfc0976f28b933f8ac8cf14ec688a435736b77f0bc27011871424646d9db8da5f48445a9680d6c7b40a32354ac715b935be70f0355eb9a2789d47aa52eed5e4b02f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
