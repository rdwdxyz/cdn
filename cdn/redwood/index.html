<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a0e32ad7c70b7d60193bfe0673db2174a42038102e3960496030aa5a21a31dab4f236abf5e02f51535282de800b09c1da8fdb923132f545b59a4bf12fd6b99739f8e3c7ac1adf73e1a130799b46f68e5845204676d4a412d4d2d5aaf8ad82672f6cd452d1b041696ac575b599c1087014a0a1c033a0eb094c56b375f32bc8bbec53fe97df9d6ef9762f63c77b36949858b0b071b859f20a5f3af290b41c2afd04a85fc7adce6a877255e5bde92966588414669b17df5057edb65876e2c5dd2671518bc797613561a6bfddde9c6242f3d4f641494a41d750b270af560aec425caaec221a3e1934c64923f3dddb8e5ffb9820d23173646daf824ee84023ab8c55225e7f7625d287751c5ce112dd554d880a4ed44d7005b0b61461ec80c180f7ca4709b809a7ba3661fa0193d2e1a99636bad0066f1d15e44f6ae0ec962d6bc5352181946d97f315d85bd7d57968d0cb4d8d51600d91e01fb6ff6b137a5b017606560b55adb6507ff758c77c311e9f9a1aa042ff910ec136863609d91e8870e1a5665b236f5e08a8ae58fdb50e5222ed29f4df25830b44f50e23e5729299808735c276c60af94b2933f15535876041543786c5a8e93be048c44ba058b67f556d97b159bc13f2832447387b9931fdca11a8286cdcdd0d2e8ac3e6f458dee1c0068efed76551549d4021a8cd696fff7d5fc4b9b900a8364f31040912eb49bf3116ff94c257a0385ef293637148ce5553b16b72047ed25a658f45bceca953487790056463511714e6248761ef7952eb23132a4e2c3f1df0f97532efd00f9b3e506811d64a782abc3ed07181f36827e464c658bf5c48d3eb7fe204fd00f58ea13987c475f3d1cfe1e6286056ef977240ce8b2ad4d8e4929afc81c7278779b1b89bcbf3b85ac912d63127e63bab7e017671be838c136605bca44f3f80efc433b66330ab877e94d77cccc10b9292463b20f524e181804293e98bc8de40918fa1bd559457ab89451ce82b25ba2080d635711d0869ed5a22537778d59d89bdf16b79533ce128cd23f66f394d01b76eeca673ecd7f3e23ca63f14f0784dd1176df3761887b7aacb33eafe5c89fd02b1fddb9ca7160549d679ad7c35af2fbf03eca24f232a962ed695233148b7761c66e159cecea0eff0d6a40cf8fc0e24557b498bd00d6b8c25fa60d57e83472c3c9a55d933794abba175759506a6f3bd2480596e8678ac53bc05a6584a46598f9ace6e38c3acf2ac4ff84710ba403b4366a70b781bb6ffea0062d722d635868ce61b5e7c64c69930cfdba2cbed4ff0c71ba5713b6f57056378335476aed3803b1ff52d4d5aed9222862ef148f52a5d01dff2fa71461e5ac0dd65c7383cd1364bc028343112cc2749ee02a8c0c0de25c86da276b2b6aabf06f32fd5c0e23ab274559840c9bc8f2bf26276f2ecbf9efc43199e2cd078a4d283c19095563f1630f198d257860280079ff47b3fb8f224525222fcb2b59b69f27d4f3d73109aca367355ada0582d84f21c2211fb96e1cac43449f5eb1d52989f97924a3bd316edfc04f4f38f003b836c2920d5b1b1ac0e15d4f591642929be8bd98937d5ab4c50b87e551034dd8253d7faf723d5ea49ae2b2c97b8d0f9040fdfdd329c476646c5984b379f356331362e4f048c1d6cd5a53d1609adfd6ead8ee6010798fa8883aaf0916da4421a9a17b7b080ca38722c8d1f4a403803d88c60b636ae519c9cefd836ba985b7d63cd86ea613af45e4a0d51def5bc23b7a10a2fdccbbeb17d82da1522e2f085ab3241b683c8e483bfafeb18f1ec20b2e3bf489bb9bd744de510127c22f121927ad00e6a5da2771dd0caedd39881754e804b22a07e35923770a14c24b493d809a56615e13345a59f364c1b6f3b1d67511641ddf21eba5c7c5c1b1f51a8d13b59e4c47acd3756213aa72a81ef72d43c8d9ef25991af80ebf692a77ff4eece27174e662855d8ede4e0b5c50da7cf4ad7fc133a7eeaab123dac5689e75aa5f9cd9d9cc9126c4df5d6bc577e829ac8d50ade7fbeea31ceebb7bb279cd2652cf07cf3b146ff8e7ccc2d378126108442fe7ec66c33ed037e7b59df566e9af384d78cbd5709085a5ef70fa61805803d075cd57b1b64e0d30806942f6b5cdd3599b7c4d7b1cd2e4bf7b88846daf4bd13b4537a91a404eee5d59b8f7bbd7cefa0a168a66e80bd73c499695e0a634fef3afc58a6efe3c9c95fc10351ec2a25477aae058ca9a48c2c037fcff6413109c0f513f241667d7f5d107fc66792f38d5cec1703feab8be2be511cbf74377fd1c3ec1078152ede660e6f37ee6901745f77063e75d35a100eeb6f9d5787feb681389ab2bb07a7f86d5cd10e7ab6b2fd97b7bb56a5145bce2f6f042ed3bdd6289d4d88212a5275160013a50c4005383a05b339bffbcfa7293a43a22c8ec85fa618e2529aa153daaeedee15c96694ceb949699211f27b1530360f848fe193ec4cc3dfc40a497d1018f7503da6a619f08a864c50404740a261d58a90f5f31d29dc036da287734200a3cd79710978b45754f85d812ca6f5571413233a34f3eb8af4b23c129c969564e9eaecf7617ee24c38f075dcb0dd2a68db8080a9d7da31d4044cfbf8c9db9cd998ccbd9be71f4c5b0c6c08f27f254f8b5f65c959246c6112a0a0c24ccf56992b6e9e9580ec5ecd17d7d252f7d50fe28ce5365b6c3500105fd9e96fc24895d72659b2e5760f8d3456c94044a8f408752e284becfb6f8f139987677cd0622fefefb745958cf65b67f8effe81cd9cf23b5276f4a14ef90b5863b77926c26c42b00c983cc7d4d8c611aa9dc94b8cccb89fb7df9bf8d2db70f5ec21820576e3fe33d07da86ecae12929f78bff220f9dc39bbac20a21b659e4fff206c98253d3238d66f9a7fd184d0733562e612cca6af9802a0275a8851adcc880ce9363f7a068e7f75af4cbd6d046e1039562d48de51a7f2cdd53fbdd01a469476a809be21d0bc24d030f0e3d6c3431c2e1d841fbb4ed56adb03e382cb3c7a71247a82debeb3d0b04c3e8e28edef61815fa2b1548c5fd6b6c4c81050255b92477c723e895fbc79a6e6b19d68e6cf19cd09d475a99581edd16b5462f1ab1372f96614cdfd85094c0720b35ac85f71052893516d95eaffd49981897843fd64f4f8a36b91147601ecd85aae9b033c91d1388ddc01ebb40fa920f8ae89189dc82dc3af59ea02bc593797b879aba83a630414edc605e87bd2a390fefd162b517f27c83632e5b7c6f9fd965604bed6a4e2c3e81f353417baf928ccceee4e78576c2c1be697497bacd7666edc675c9ed9878440556e0f0e52dfa6b47512ffb475522513c3a96d93a39610a4610d17a318576182df8ef484b94c54158e7078fc1da0863546e3c85520a062ed072f616f464533fcbc5de597147ea84fb183e3174fe853c54917dd6d4c9c21ecd5ef94037fcd3e1c3f72f6f224c7f31afe06808d64a33d688f78fd220d12ed2de4284972cd555d8f8057af73561e1f36a074aa965ce1fcbac3fe9f5b555ffa137fb946c689a1ca98cb1ba4d7590ef0bd1cadea59692c7390501324d7e74871cdc7782a05d7ac9b9aa350f4fa7c4e1da25fc8970317d08bfd0b6063ce7bfea9056f064e42f7d4766f2bafd116285daa8d3037072ce96955ee23c72456d63e4aaf64a672b0cab3ee35fe5c87b630da59540f7f5474afc141c3a8e1755c2dba669ec373f7f4327a07d471a3e15275c5abda59a6941301f30df3c01c9ec62beec9a29d32f6867f51df11c77a8af1b3141c72e7db32fec0a4dbffdee651e91d0f84cee92fd445890eae032c02853c29cca5d24ac9f61513f96e976a03ae5900145be9e413fc421eb7ae26864432fcff89f4dd0e27fa6a14b21c13f9773798c8c7b1fc484127a9a60d0377d3627873674c6dc7675d29be17463fc1b7d7d226a27c560df3ac801188191ea528859dd6d275fc8a338d09819169b8f3a8dd8c2bd1a41f8f47baae811d0e9eb3dd7d2688a671f74cc63e9aa8630af61948285a1be432c88f04ac912e1b700603cba2db973f464582a16dbec9d3d7a8c4082316c429f38dad3da0b087f82279fbd3369a4dfa41d1268717292d0817d7970b834927f7d3398a29283a5179c2765ad47e105e17f4289c258d1100d0da4416ea8c7970ec61c77ccf5d637f5d49d48ba3c420c0a3886fa49a70cbe2a81cfddba9f357fd4fff7a701566f32f535c29baec527699cd21219ffcffba876d2f7d68ed343342348a2bc3aff158e9d571b8b00629a6d56bee34198f6f5f95b8ce83c6023cec8134ae15fbc2a55ccaec13acc1b1965fd75476abc4ff45c41a88fd98c80b05d776e10231c483f420625652d3c42f25a4f0722ebc3cc5d93cb5154e22a65aa6ed15e9e873e5b78ff7cdb1ddee4ccf4f1568e7f9ed154eef1dca18b9bcaecc8dc6cb04f58105bb5fb20ee6175e32cc5f59a4d65398e23313be7c1a8fa2e805d2e75a5ada2689a7809b25a13a6dbf7aafa75825492d0bcf2a80cc3a447a349066ba565afe324916629e7691ac58cbb848b46c41aa38c50e7a2fa2ecc427c1360529c1181d167506ee286b3efdc934ce73cb8cb5ad7f19390bc2073a35dc2664a0ec173efea8f473b440019bfdc65c5fb215545946c87fd4dd6029c35bac2092f2150780e8630a79dcfc014909f7bec6b1b8a363a26e21e8536f561c1891d700bd1b965f8445af0ac3776a71d7a9c0bf467fccae89479ea6e4d16acf3b95ba020638560dd05c15ee92e41609f8b63d9d5d61500f69e4356a76d5a902e1d93239d82a354c76b6910b38dade6b238740547fafb6d1886d3a5d86248733075fe0abab9165092cef589b35c13e01753087b2325be2687d5f5f2c5e0684894c191fe5c8709647545dc9e9ffdd189cac36c55407211c7c823f2bff4ba814d2187ce8bf661d684a8013df602ff5b7302c76cf6598b77e8bc33c23b963ebc56980b63bf0c9e7038b81cdee9cd504e4c0f294d99a1560212ecbbde956c5b01e974fbac1bf2a55c76b602710d8b6626b1c58b11fc8baea010eb24f0c67a43d1cadc93f9136da85c1a96ef171f6c77401fa9e1fed770937c9cb171eb4f0313e46a1a34042a9060a5e9f63f84935ce797627008d9240887b9fa4889e285e64bff43fe6c8d3c0e8276e7508bdf16424be940983853aeee08e9ae0122c40be576bb7c29f62385c1d7af4152e3777fffa9ef4c2e67dcc611c01770fa3a05be81ef195c20fcec12b839fc1e91040687148a9a2ae7f6095b2a4156c0f0c77b272ef796667ed244adec86d1cb9f1cbdfe89ab5b382531e63052946889c300216957327106a41659846431d57051078af8d536111c882421b593530605c0f94c3422abe3631b1f86904d61e0034a830b22f55698bee003ee4aa117f2c1734b44534e8cbb332ba78fa8579a018b9cc7c39df6924fa048119c2cef8f7a91deb964a857b5fabf2a859e01c9b72ea7365d7849dec3b945f5022d37199b1625662f312e0290c1f28e83b36f6a6d0e91cf7b47442aa1f24f422aee422726ffff3e4d80f720ca477e78a0f13dc3226be2f51fd799218dbc74ef41ebd1f7b3c0acac9207f388d4fedf73c15f447706f690600cc443d4660c673f05aefa2d562a6591412b7ed90d13511b54acd7c3896295ab6ae4bc88664bb227f7c36e5b671096f9cd47784a741dba8ed2f90db60c5969274e2c557ac34e616c3a9f2af4b530cde28e99ae4b3b4d45015615d852453d458004c3730a948dc12f213598e94d238fdd85ce391ffdbe27d05df26c78615743c1d00bfec12cc761688d769f474f38e2d97635cf1b8ad3dc7ec60e306b8aa0b4cb09933bd8297d3d01d4339ae61d1c9a8c1b5d936e37544c5e5aa3b68f1443ec2121d075ba92448c002f981f356cc4e4cfc7f5db2be9b56d091518e9b877e5724b3f3ce443df14801610036844c53709f503c1d834dee8e9b2b3b36c68b3db1e3de44014ac5e464927daa0e50417acac67cacb58ce63572f6e87d24468eb0f0dfd55c687eb624a27a5946fb8fc8a1198fa0d334d0a9b46760b1ee29085e67980590d6604b64dd025f584001a3b2a25a04a9e55303234bfd7e071308574fadc5cc5c9f30da7f8d884838d47dab051b79136a78a1145016dab7347c57b2afb47a74944d977631e96905b24da244e443688e988cf72a041f5b70bf52614aa0f2fbf9a9fc54bd95d1f68fa0f920c67f030f43f61ccab54b65cfe0423c36923d2d5bbe7d14bbd6276627c0cd6ac115549dfe567752e4db9d956f9a40d9b327f60891ea42bcc967756d2d8aef575cd672b34e48ee931370add55762dc3e8350b220223339250cf0f6617b5da75a3fa3e22f337dbe3c30ff16bc89417db640b3a8ce1ed10a0ef7173cac3b533e00497019cffa6f06a63cff61c0f976a0876104b9f62484665e33aff547fe0fbef59f98a1f1b7a3572473617cf8886214874c720f6abe7d144ab56a0360a6d037da0562ae70ca479737569dc5a7f5613eff8435191265220d69a86ee4f3ef6ec4e4bea1977cd1c2d4e3cf73637fe1643efc810f3833a5e7d84132f2446e89bef6d96e58353e45a39d517d50d5686c4e85cb7581ed881569a358e66f8bdcdc48e556243b231896d1b92a0e9317f43aa2e0dd5aeab1aa78b2a81ae59f42776edeb9e4508b1bf9efe3cc7be98d16ce041db53bbac05789b2c5e730fa308a8e84aff932a357978254fceb938687ec7f368d1caf3460c82b17a85e5296610ae3d9294a8c465b464858daa1eec6628579090c2ab05174471382ef95db63be84be249908af45e204ec9cc78f4704736a0608fd87a2b3941ec143dd68cfdedc95948128532053a71afed64912ecb15acc9f140d704f38e2701a3afa27549f3b06a01532b1acf27e7aff81f07c898ed0111dae02061656b497c4ff951a24482c1417a4971ba68a62f0650f6aa6bf3adffa7b56cb1242cf5c15d09008f80f0e0a017b1cbc42324a632b9a25d54da6ccd348eb1290ed93a8a2255fb75b60909d4311c131d12acbb7395558c3d05451960d3af385d7c0e19c4da0328ba541fa855d41cf4efd4ae9b5b298b1cb47a9e0ad3aaad7be507f428249f6702f059bc692a6b7d244b85f2927a833607853726858727065e93553b612975615644d690b0e360a9b94f2d8fc101439c0bbde394295aa418e39505c404ca53041af657b44c7a2fe6ed003feb25566be467f8ca3a48dff147e0f5ff7e517990a085b98bb18e106d3c327808a70461f8cc3c2a47b213053e455a0f660a4cd89f5e3715319131ee3b09242d48e1d7a196694837472818c59287d47b68dd2ba80fa6bc8c221975f29e9f6acbc4ca6890f47105917a09c8902d581af15414c9f231543f3fe0400e3036b6ecd10daec7ee0d6ab0ff6575379b5b1be55455d3f210fc2154f23951f8d365fc84589e20d3ceb894fac54c7c661130bdaf0e5d94d0d6aa3d9cfee9db1bc0c76a150479262839bd665b44e39e8b2cda33d6281ab684783dce1e298e8ee470059801fb62fe856505ae76f95a4c17de2278c31218895bc0e960ef941d3c235d98f719ea6026c0e8dafc76e33fb1ccc1ab3ec4d55d3daa3d5d6f66b8c646f2d36d1260599e713c96c69478fa9a53bf701b54b540573590f4f11830bb87d640cba6c2ed22ce96946fd2ea37ec6c287623c3afe4011387655e83685e51e7ef9c92c074c93133a6ba4967c1dbc0e821b4adf96efcdafea2d4ed1dd3f66cc90606de8802e5dbdb936482457092ffb5b65a828ce39304f163bd5352111c71c3b11adb27d0982150d7df51122a809ab381bc7ce8cdfde6b928188a934bb7a522c05e549ab990ae24805d0bc1f505bf762ff97921f9b11309ef562c30a2788c900e3918308b68c5e6f90f3b120f2b8e8f268051bc80b4f1fb806a9e3d0922f98eb1262d6163501652195c58bd9fb124391380a40297cee508db1a8d6ad36bea2b93f76496bb2d0579e68d7103e4146a607db31cc2a98765f37f61ed8997b6c0a34e750d9f4e4d8b5e284791179c66b5b61e0c6e7621e8d27af19049ee296215248b6712d0a1eaf4ded1c5bf93a0dc97998e1c40ec819de5d6334cfc498086c7f24a2b9c5a0ba5659319fc7274602757d7a0e91d79fe7a0bc3e6ca624811a5b30f64cbc4b8979cd8425c61b50aa6bdeb7bf5c8238ed89769acf52243a927e42a91a67c7982f87467dceca0abff126459e9b043f45fce061dcdc36e46949e587740446a940f29ec5cd7256ae7bac3f415c5112d9af7796b2786fac07f7b2e89cfa1a5981d918718296181401b1f4d775dff095660f40090ec3cc4be5268322788349a9e548703b24815be68c39cd96c27aff2c391806c1edc74de6f4c3dacb86c678cb10800d830beb2fffef9c344d44c0ad3de065797eb23625517790e45f92fef854e5cdab5523ff353bc826e691e6f9bda8ea4d047d29dd63784a0bcabe57cbc8b1182374a0ced93624b7cd30736f7d9b138ad995dccb62f5ae9493fd596ba8980ad509b6442c619da736344e012901f8a5d76b62791e78a8146d32c1dc020363a9648e6c02ea34b497f4b61c0ee8436e679785eb202bcb8e1b1297b55eb5140de37f764805225f0a165f76c815c7a5fe718c8599122704f770a302c37c1702278abe1d3390dd8dc017b898571aec00408900712f53ab5cb48d19d5edad0937abe94e07a3f0f58a557d065dcb6d28071f6c17d8226929ecf9ee514d5d04100bcae1f63f838df0794645640a24c2f52c4fee43057cce60445c8acb751226bca5e6cbce81d8b05171c98481b1f51265343a0b1e830411acfdc01ec8a263a788f3a0b05fbec3ea6512d57383fea299eb16c9de828c1fff78a7fb3fdfbf049ed16f289377d8dec485fa1c6052d47866c6f9294c8276afbfff1cb3428ff16cc68d7e5a3b5c2af228bf4b085d89cdcb5d476cc23ef9606bbe2df144732228db95d08ca5e1b86f8ffb47ed3b72340013b880229a37874aadefda4994b092e5c006a431d7f2f1916950523797abb4a9178571a0d767a1f74b689a75ac1dca10fa0da24042f433341dc2bcf0fa1e5f20edc2c0b044841a735905f1742de50a573407adbeda1a8c7666eda87a98efacfea043413540c7841c58ae99264f412993513795cd028d0979e7c4023d7982f82fc8fcc57e5b1a4b84b30f5c9ad52f5f1dd13eecaa7d10a4dd7d27fc96f6e29d6f00cae9246b510e029d840214617563219d68fc8bf0106dbaed723ae82a9d2a3f174192679063a4bd58daf4fea73d4593880dafe4893bbe18b78dccc2f8baef31d4798b6a610947a26b869abf1c5492388b6e4dc3d62f58d400a59acc4c00f5f8fb0369d62d5e863c63e21887b4e461bc5dd8c5e4368892ccf66358123c4c1ab03e9a8ce4b61055032a2dcabf6f804a9eb53c7d500dd59512a08181a4b532a8ae8e4aad95b4688edb91c2001d66d3edb25bad83b7d399dfd529e67785025bc46a186a8a0ffbe509368aa0fe0ff39f9e3fd3467a674aaa9b53128077fc4058aafa09ad96046740a717d7386ff81c6f6881b85517a64345f89a5c0054dfe073bbcb774f39f4d504932a6d118a7a426ad3505fe3cb8d1c00acf2a9c2f1a6e880693180141734af5856a1ec6ee118ead8090b5d76d74cd2756a238ef830bb4b1594be1726c2a9accff71a9b9737dd5e4fb2182ab0de1ca8f6717e195e81ce1270e63de7ce4693d8b1c6ff5562d35caa6c7f1e744829e71247f57d429281863c5ad4b078a1a45d8af32866e4cdafe207051e77c88dda27f5cd2c0eb6d86fe046d132497d8fecab552daa6b7c0e4e34f8c835b26cdd42b3427bc8db7eb76f19f2ca7e1bc3d612539257475491ef71cda15b48c8cd77896fba2edc02c4f64759c6aa5a02ca4413be5ffdacf0b9e9cab51e3ae31555a41e1f0867e438b79ae9c348763b165b10b47626318ae71b520710612fe425ab9b22048cf20c5d9648eae57a758272b5606e58059f1633a6ac3df51e05fdedf68f979b9371340a735d8cb048662147f9c9cbbb4f5cb106d8399c85bdf658c1a2277ae12e0b6f36a0ea75beb788162976d9f16b93e79ab5e4d9f9f7459c3ed8ba320936890f53c5b3acb04fc706369b82c0221eadda80a0d6d0cc1fa2d48de09b55a907c938b48ea22b293d2aeb95431469f2bc9d12a4aaf482653598e288a71e69c72c24763fa9253ab6acd5e69210e938bc5ed0d3919cb86b0f75056ca83176dbb88ba080179ba3a6ca142a61ee15fa0c2e87374c685003b8af7037d4558fdc440a43a9669b397680383f626eda8dde8bab75eecc430492cad24aa01293a0acc5c2f60f6b4c0bfb1e8770284106a97ecdbb5891e6ef17a54386f5cfd767dc8c87214a32d7e6f71a13d25fb366338bcd42ab2a27e0c5d76cdc736942992ebc3b064e8a1993a6c94170c9fcf6a5aaf2b7daae626fafb8784f5ba87fb76656d82e26e0289f0562ad4e764dad52548ed505b9fa854329902f68a93fdb55be81bade2e60b5fa43ab843df4876bf6c5bcb8f6b4ef6c4f5150ebb87913185611dc65e743f4ad2f6549737809f5206ef71feaa47a1557179629e34f4b0a46789e5f4c8e83024cb2a046bf83bcb91b4a892f3141c066233880712b5f8b090b5f41ba98e08eef23db72cd0df94413a680ab57b942ae51a7fc066854320e642be7040b9604afc8373290a840218054d7e6463cfbf0c06a6929ff17b34e8d97e3149f9d492a660b6d35ed5fcf500cd084fb2bef550f00fa509be57a0c6c4d379bfef311acf0697177d101f1a3d6c8610eee2c096b843cb73bae3164a226340b1c0d887e966a5aded17f019d796fe3a50d65c182d0c944ee97b49fc8de2f2e3fe34946a032690c60516836f97ffaded1bf032160e421cde2495afaf62694e5b2961dd3724a31ecc56298cfdbd5cca8210a6498f72dbff8be28b7ed80e0b10efd524ac9069c0cbe931a82417c8df47c45cce8abc0ddccae5fca24f3335c698e08bef874b09f8b1636d095008d64ab6da31e9a113d2ec8b5d91dd9a6a957eeb2951d5cd770145e129aa1ac2d8f366d1f9562b81b131b26121ce61f4241c6dbf8504f71fd73f68d6c337a0ba62d0f6aeebde16655e457fb4c54e053bdbdff4604972829398a1bb557b2a631efe2e42b311fc6c4c32ac3c6056e2950ce4a558885544d12a2a870ad2efacaf2093a083c7e443ea05bb0c84b4eccbbaebef80140fd140e54faa4ff0168b9f6ad4cd47e35092f4a7c8f9c5d2d1a48973b3a1535ea5d7138f51f86019f71d3b3431a1df131b8ef81967a6fad9161642ad154fbd6054ca915234977ee78bdc5e6826eda895aecdbf86e257665a377a207e15f884cfe00fc61e094be8135c527d7e85fdac1a159f9813fc4a2562856a32389c7d619ca673a4841736526004a8bcd37aa88a47326cbc4aac5cb8aa7ff084a11335197977ee8d69d93049d889eb0d097ba33a5ef8693947ac78c270bd5199062441e86d3aec5bf78c13c79436ea9099f004c1b6277e0ac3ad026c12209c0f88cb034ff5188e25a5ff5fe992803d5ba2152d15855bce1cd45dfc0411e92bfbd1a7c06af6dd444ea3d13faf93701df3c4838facf034835fb30c28d8e92355db22b5d2a91cb2bcd50e7d30c88fb377ac0413ed3ac8eb3bdf894dc5f9afbcc12705a5370230022edbab5f66878cc3f2ac71e4bd4fb0c1336ccfe6448cee41c583338695d8532f1c668983b060e7f9ca8cbf5e8f03d8b820709a78613e4547f31847864a25adc930fba310a400073474b04b4c45d64b76ff15212b27621da4b8164fdee0b1350b650c5af0160a058f40f3b695097ea7c306a9a94b64f03c47bbad224a6d6e88391b78dfe7e346d2f43d27afbde123ebb146bf6922fc63eaf7738e895719eae04751cddda306f309d0a91253e296a6a2938d06203ac5d247f06747cd25b2da6e3e6178bf3cc8b997fa94e5053bc8982e5c08fa56fbd98110272c373eb0f56eff39c878c41a6bd49e5a74e46ad71f2663eebdc390f9303def7f6614a47d8fff80e7c689095b997b4e29f04c665f0885887942ad095ec314ab6ee4f34b134deb119ec203ad75cf67769b3c2fabc38f869bac5f680c13d4d1cb8432b6dfba6cb4c236d5e0af2cf9a83d0213380db6b90a0f061254c3a4cb8681b702bb08333285b0d36554c5fadd7ed95483670991c22a4873abd0ee442faf5d3144fff6ec143ae5797b5e10ebe65ee6f15d46310ead77223de1d157ffa863dce138c8c1240815843f6a4dd7e87b754863f64905f9216d4337d034327be3734144617ec897eca09def086595300781a74f07f3b0d37f06f5a54610f971985bfa76d42f18b45f6341c0f0d140b76d94982259dd0c1945384415e4b429522e15b5d4b3b3fabe1dbe22c23ba052e112d864d01926c28526e984394ab99a2e3c348f125e5fead56363d5946a28ca6fe13403bb1fef549531c6b212f63853c5320127c61c36e6863a96d959fbb25a99468864892dc620e196801a9bf28fd11982e464dfa74f15a94abdd056a23881f7894eccc5fe287b5be61c41c8bcf17390730405fc38da9e4e75a000fc41ac00247411fa9ff7dd6c5880e8ac22876a7cef0d5d3f4c3f30ca710347d961b465f8ae4406058628b335fc690b03a0daf97096ed9166585f7afcc413ca8c30d139160a6421cfedd13162ebf05ec0f0c893c751815721c56f94211eb5bed0182ca0ce144f9fdeaf53ff3fe2ac0815d5f5fecd6af98fe9e65ec225f9f7792f7a50081628d24dc2b20e21534c39feb0ec162642a65842d150e51304668d42c71a9581fdbee46ce13f83c391fc01f6027bdf52434f1223385ce5512b53d604f0966f20023bcc8b1d15710ae8823766261a0c7eee9cef8c8ce1a6afa2ef71b638675bd583be6ec3bc59d342153a6067bae0f38dfac3039ccecd76c74a0fa984f01f1b4d360e6a6d134c81b801f76b2c14445bc01cef4c090644af40d0f82e59331b00976d9b5b3a4b62777ffbbd079bc572c0f4f941081eb2bfcd63fed7af186630be776dca11aba51387c474e3ed023732b7b0512e666384441529e4c9d567b2143e7a6fb444e93b0f5e1b861aba719e2fff79dc4f2a45d3fa36237551431b5fc75666917ecf155112daef8f9a3c7e2df817d55380adfd6a0fc59da876dcc75e6666bc0a4f4c506cf2f1ef2cfb5353c94ce054ce03bb87fa93d78266b9f8d7c4884fa61f8e241e031c6f7d68f391dc84c054cbbb4db497247470dc5a14daaf2fca0691305abcb85718ff5aa5d0a8435af2f12622eb90eaf4865703d6628e18b9e35fa061f60bdd88dbcbb9c554dad4b6a35708077788d77642d6ba00299ed466dcc314901d07935898495e1aa25238db810832395b4156757d634961a8ff5371ee98efed202ceae5937a671eb70ade16cdbcf51af423fdd71a38d9f08e074795256947ee55f3597e53daf676f114d4d0cbd36551c8f2234601130b98b055a27ad18660943fb98523ef5395a209863bb1c4fe42c7ba4115fe05227bdd74992e64d8f38432fa686ec7a07eb11821aa4f757ac76b529372399ce663fa1522560a754c5de0389acffad0bedf4a418288bd893df2a871aa4f1dec38a8cf50d5badb01e4bb03d708fda8af1dcfbd2b5fa576f29aac2d5b8bfcc2ab9bbec30542af30d8b523d0c37f981707e55cf7f05ae2450c7fa75cb0e3f1d0692e560160bb86bb7eb51c08e455695bde14937ffc26f2274d06c156536e41989e285e615f7b504c3a8fcb2d0a247881d7cd1eaba1c92195e05297af121248465e397e2d4a2d7a9e6233477c00e5b60466959de470caf318e2d5a17e9ba36f929c26e5c3a4c1c40a47ac6d2fcbd2e128ee76e8850e42d1a961e7b94ead4228ca07597c14f38f56ede1cd92d39ef16f4441002c4925915d2066483431da93e633fdee0514244bc3f6cf7da8b0a4c42f50a7468901cdff362c936d78fd4b364636f59e28c9c8abfed9d79a90497ad3d2b0ffb01d53eee13f5b53bd92fbede62b9a82c63e17ca9c8a5ed2a4104b21a24fd2c0137569367fe61a1d371021974d9944d85f11e16c8e5b6722da351fd33e42068673c562f1c074aae4fe909ae3e148a9f5bae156fc5a8ba2197267114dfab2f411e2ec1e7ba953b3bad839b3e3e75720c6bc287ca1f84264df2c4afaf98a314cf3c1d1ce0cd7f575c52b9c03c820df39f883ec713e8e4cae60f5ba820dcf366bc0f45722dd45b6e6ce3cb841c71c3be88963feea6bfc66a96565d7673d1fc1cb2cd6d593e8d074baf02e9e4fc78cf45095faa33fd1dc38a75df4d610110bd65929bcf44d004d020de5eaff5c8cc5d2da843f886f13a4a2a63ce5989795edcedc1acc2a69e64dbfb5662fb7a4bbb5cc418eb21e4c34a233fa613d37279309eb8298347ed24afbf4229abe96fb5f7e5dc8476f5d4e70436ee97e378afb48a7ab2078c813ac1b9267cf4edbde72410a7edbc841f3e7139ab61a617266693a64f7521dfdaa7dff15cf23fafdf64385f75bed93d45d7e894730688ba97a00ca1bc9de6929c2202730f70650c1059f65af56c99f9a9954f7496d3e59329b3139c60b8103c231df53eaa69ff72d7b24d9ffbcca6ce1ffe75afbb25af73fa10804ae43f30377406d786b7b37fc42f4572c5db863c25d0857908f8e9635ed48f3c983338356147eb7513781e1677893ad8036e499d66674415e429b70ff58b367756c6dc71e450eebcf2a91ee66511df21cc512630159b412f5f69c6c77f90b2511fcdb54e3afbaf33554284c1b5ebc10298a4fee30e12f1a4fa2fa19d5f81ee9fee2d06ebe53a951b2b2d46911444e632ba0d83308d73e67d43b71a5f07a0533ff4d4d99d08dc52654a244c20b2b6d70800440a4dca14fce2925e0971efe0ae9d133057b3dc245c3e451cf03c9429abd3bfa4bfdce048312344faddb78b6fa21e52652a2e9b88112be1d5e77b2310fba951383955bbedcf8f0d09c4247a40fb9f3511299edc3d730fdaa200ca986f29654714f76346218072a94dc54f2fb69081ac9aaeb4f44c9414632c13080c1339de0433ef563069b227f99f58b07d9ba232e923ba47ef642b90d1f31ffa76bbf9e59a03c308572c6252ad7c7171305039a0446fda31c49923c89a25633da45e68b38fec9a657973ee7d03f66d9b4f4f9561d6da8cf5d7c41b2054bc44de3f8b5d5a1f881dd8b2f0e1698a3b0b22c701654c9317268bd525088459d36d49398750a4fe155e3b0bfcb4e154cbb134ba6526862250785becffb6f37bfcbe6b7370f1ff2384138b3437be3ce96395770db0ca929e1feb563029f74b02c41df3d7b6d7c724e10e26d9f050b29687221f68a1f6ab1670beed626cf45cb89ea4f19e087043d1dbe01b9278797f547d280ed7a81d3efba50b5e108f0d13f79fc7b572ad673acb4e5db0d224a68179a8a36dda0257855d8f4b2b5d18ed1e467bd8ed2ac744b0feed4feead3700c6e4f615a0ea39514c2257a0a9d64b2d8f317ed9c09cfe2b072f9a4a21a3143c80d4684452cc24ffe674cdd5be1fbd8abfd94da5442e6d28b40efe097e3ce9c1d5ae331910fd47048d7104ba9d1752550d9a8a6d47d5c94215161fc1337aa56fd9bcac2260f1377b3ca8de2acd5a1cc62f9ea97236135e54d56f7198db728ecf664b56cc629cdb02a8e7d371dda452a6024ecafcb573e3d6a6eacfb14bd9e467c43693115526f2a71c8352efe20369b316e124b7213c7b789bf7620181d13807cd3fd4ee5a94a954527773159bf1bd4c712083a1781117fbc402f8e2d774181e5914caf9c7a91e74fc3639d336cabefd42983904b8bc543596cce2799ecd60cf9886f5a4e443ae8c60cb362fad32e6e8a8a24791dd685966992f8314a27d438da596feeaa793af1d57d42bb50bd95f27f2a1d635b81dc7b8f653ff0cf09a68bb3d01111ea939072fa8624b323d2dff7cfae9734a0d12795b937834e3ca65210281a597f8aed972ced7ce1208b978f531e4fd40d0323883ecd2d491b438af11d1b93f2cd7ad0f6c53b48f255e21ee184138a803f458e5b34ee9eae1a12eb179f14225b95aa2f3cf385a093416c2ccb77c712402aeadb3ca186f2f7cecff2c89b9f869fcc4cc254a9d263449a6ccc57603cba3fc696b3b4079248ca8063b1acbf4a9573a98e430287b9cc585bd47bc5ab42f08d5c6e42d5e516d7b233e57a7e23c9a1f3cef54f914ab8a63fb8f8b6d56c0d0916cd9fbc13364068f9d0d961b1eb055d0cb101b7bdafea36efa3ea10b8b13c691971ce04774b89d2573b5f5ccc17d86ee079bddef916b4e971d1c5fbeb8ca1061f5dee67a8a4ff81dc854578d9a8c149cc6b940b67c2826003698ae73a5541da2c6f968892f41d3bcdf3d9aa4e00d195f45ee1950e54f3ffeac0372e940c10f5ce7ccb6d46bbf5a2abb55d72a42c8c053ede3481a06608ebcd5ef9ace594074928d29dd51488b10573cba6f0a0cc247730682613944476fab7f0a06da3bd4558b6bd624e8940a0dc297ec4013f1ec4b170d9d13ad5839cb0863563ccbad2eeaa86ab28b0bf7acf651f07d0b405c9aa75a136cf997c5ed2f53cb3269bcd42950c03f0c45d88eb61ed3c12540196df64583c5a9c78c4d709f1d38bcbfc66e8b128303de33bc34893b86fcad7a4cf7bfe707970db0129ab93e2b6f988cce1c4dfe0ee6a542b7ef9489ca5d6631a7a7fb2b94d3909c898d677958ccf21de0faf36e1ca2078ba2e11d3fc29c328dc79f129000fe4bfbf115b1552ae0605a452a3e0f4015961a4a52da268b8857a01d5af77affb69c7133be7b230941a357649d8e2593c94add330cf9a16fc24f341549e5d189aca9da1a5fe6fb96d34a12c4eadd9d86c3b07a8a5d11a834364bfb70eed239768e203dbbf9bf75c77b765d70c1cfadf590b4985f0fd1a0bbb9e093c37455f687915b1c36c6718205982a8fa6341f16a69abd64ecee35cd2abf6dbe0fadc8c495b7d8b583fb86f89bde9474747b6b7fed8e612fca147d03759d9ee7e45af1c1f9ac82ba6a655bc0fd56e5c05510ec5debea079b9126ea8a979d0840b2429a39d6730a414c2bf3f830f6884543681d500e4b40ab0b8d483526f9fc6a4441a8e099be019046044550facf0ab0da626e616b33b2845a47cecb698a343ec38c578491e947d9ea95f2031db23090f7dc386ace8dad26c25582e82dc73f45cd92a898a20c7de3dbcec302d0b329ceaaa1ce0d3a183ad3dc1eaed9cd70e58d3cd76f7a04ce3f7d9419ed9c0495c294d4fe1616068d57806fbb68f8bf90209a38f9f7defd60212d4d6d9d49c9f623625455708c0de6e99f9891d8513e7145796d36dab0aeddfd85b8ad2b1fdfae98974a2ba43f20e7f1074d77eb511ef4eba27e05638927302699e991cbbadb2167c2bd7ea4cc82c799bc9678f486ae9b1f78dc54d8598ca860c7990725ac3fbfecf2af27880f331dc1d14f1f9e1f751907a2cce921e8c6efb4a6555fc832a7805ef7f6e50453beed80562f64ee615bb000658fd2f582d72174ea73b395ad5c699bf5f5f66eacf2ab3316fd4eb1f010a3b94ccef800ad9040878f864e60d0e2ec8409f22079a6ade66091b47ed54e92e0557b05302937063df4427dced8a97825e24980da8f8fac167d8d17c6001521191e1a857932911fb474a4a407ac2edafbb1b4a8ea4278ea24fb29941793923bc416ab08e45bdc701219bd20cf90d1fbe399d3a434d37632ba8f62a3dec313b7febc0f4c835e687123a03d2b4fff9782e22b0bcb4cc32c642ae2c90d235399403d6a2e57778e54681152bcc6852f6812fb78907e1a7439aade96b9ada9ce122aa183cda07aac5aa950865ddc24b8f4eaef552427bf3d5ff843372b5d10789ab62a66bf37ee0225b5a4859a37e9e2ba2d5994a80fb6dc9ee892482374ef33548820839d650874ad8562614215282b3eedfb90e62e02a048f8337d834b91847f242d80094bdd0648088f5030b943d9addc5611ed1665d941faefd4fc3bd01edb72b6eba97f400d5e89c8071a112b4e8b78c9a0b858ac652f1aedb61ed86e2944906","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
