<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"459aa7d90781292701fe63f4abf789bbe8f53365b1e79ae4ed959b1f671274a3e24fa136eb7996721c315c2443fd56e5ee54de486692842172720f9546ccc6a1fcbd33e2a50b8bccb0116d922ac2a4c6d6f32c9ee7a8b19666147dc8ba9c1f6dad183b7b1b871ff6e0f5df1cf41277d05da84d6e02947c0df18a9993d96cca591ad8482ed7b981910f1d72607602763e8285f230a93579425d66a0bc3d9c34903ba40e8ea374221510a8cbcb9e5e69232a1be75bf12e75509be71cca850e9126da032f829b75056b2c83383afe6bea5c63a55299081ab6ae58700f30da2e26dd68aea599337d85429dfbb14d0fbbcc094fb7868497f81c1b09d1d9ce133c7fe212775cf710aa19dbd9b13620d5260aaadaefaf10c243010376cfabf0ccfa66861d358d3fd389d4fdfce4c602bae705756e32d5c0f8bbe2194b5e2e7505c667ad2856447ba8cfa3231315cc65d98cf5cef6aa185aac435416d6d128255c0b70b59c54eeac5a6adcd424cfe9e02e5a49b9c84df6aae8acb2f695658be6e2244ccf194496093aa0549741d7ddd29b6fbc88c09d2c555cd2c2e992e8af9e909ec95732fd8334c0a460a43c80874346673e945eb84c42a7fdeeae28efa76df9f14fea2131756a9eea7c04bda3352ee836a6b13eef3f1e44862039c3a2fcaac366466966c5f2333b412dfa351398397ae3438e8df99e60eafaec91ecc9cbc709aa9b5bd1a12d81367d5eb9c26473c338497bd3ff0a697c0ab9d65a1bbb0ede4a36e2b0713f94edd08515ffb7ff1af2d2e5174bdbf9bb3f9c68dea2fb8d7a412abf50fd0b6ecc76b83d91ba7a5b8de5b70ecf5dddf26aa215dd16da21dfbecc64594d82281a65a7cfa7698724abc5b75717b4a41f82fe08c61621d954e48af6c7e2f545659dcd0b2c25a4acd44ba5bd51cd1461414b832c9acd2b1b7666af0601d77c34bdf05cbb66b11cff3729106d34446b869950aaa40930f89072f98fc4420dfb7963e719ed86bfae9861ccd3f32d27af361606a22779de9e2ecd18bb59c9d3f152518cb4ae3b93b2551c0173b50a1a84795af05a78caa74035dc3274cbb62765ec1cef844c5989734e4a34284b1bda0c1e204f73106cdfd38dba803da85c031d3c16ebbbaa24ef1e894cacfe0fd25791ed4d9983cef26e98254a29c295e23b02b319fbe5a1ff913380ea430f9eaa217c7de33b208962b999abe04ae5dc499c747a7755bcdaec55744acf202344f85215f8d5cee2989575c6c0c2389c72689054203b238c8f466e3ded9c0aede0c70b32bd1df5b31a81df5d3975f8a061eff56240680f623efbbebdc88f45e409b5314f458d5b202647d6763c143e376fa1bc9095068043bc888cd26a179ea92b49ad53cdc7476a3cb2c90742375bb30c828227c5c3593d63b2e271057fb23f5b0cb8b46457a4b43a2e870d17213e878cce9d582348feaf31d52f40ded9f5fb7a539e238f15f320cc7b4c551a7249d064d3ed5bd8535d238fd1bcb941de9037c928a85147501e91236c7199672fb782db5a755f6e643f6194438a3cfbaa02fa330fc66902e0a17f9f9ef64a112597647ecf047cf578cfbe7d04dbfb12f43288aeab7a818357886520084389ab6b5f7e11de563d754437a288ace46d95f62e9c0d7b4f1b362c5e68025ae7e1e774efe91512765968e00d7e759dfd6fa9efa68df1fa9034fa11fb1b99a6afbdce9f873195398f82a8fe46dd900649f06cfe4bac0b88580ae6adcf6cf4dc5fc49cc54f50151c475de91df4a423d8b1c2039456983a6fec670693c149b9bb38fdbb80cb921eb358ec186f8c0ee2e00989be7c4cf6d437af7342789befe667be352dfbd90b19e4e683806f6330979bb547eb23bce61064246dca980006547363b58c13ea8c7b21eb32f13dbac3b7ae9fc0fd020cfe1eb71a8d01501f72e5179ec4c6d174b3b6e8013cdc81863638b5a5e0744b053a8c389693ca04f7170959baf63d8ebef5215134b9c6502959238250deeb5cf383f14416380c462a2fc4d7bdbcccac68d4fb60f471cd0de67a2b0eb972125bb50665e2036fcde19745658d23f522b58c1a6b09b9de92d286ae8fb66d1eca1bf48c04ac9fe967eef2e460b09034cb4dcc632e17afdbad683d4e514a959830d119bc0d90844985d0105ab16b564128c2197372aab8f60a27bb4c60ec8a63b5227201e14335396345918f12b8f936c32968a5a39c5cb098e59cf2a3bb999fd4b45c980fcf5d0fde93b4cc5d446712c575689a3cf6b7524d17720eefa4969d1a83c044f0800885fa19f7a1d639b6f5705cce35d8dbdf838c353987cc8dda5e4d82cb55501f9fc4f9aea3d7dd6db2fac3650bd54ae99ca11f48a093f1a0ac4f09dc1632767b479a1e76180e22968ce81c172317ef232f6b30e44720491f4a79c052c1bdb96d9a65bf29b4602c62edac721bf561442270a189bd0e001e04d516e2b71ebf108bdaf74a90a09872ffbdc4668d56b67d425a02a3ec0edd583a998849b468c821f07f868f8c1aedd7baaafb90a63e307bd10bd44e152466097a1c45b7a91cfe1b9ab267247244bbe204903ecd4793f92eb2983d2132632e991be1175558c39618324a6ce5b5470dc589bc093bea338b89555bb1cfe628d2309b2db788adb30b1eb5a5042eb1e37c38ee9b702968cd62f75fd600b2ec4157db1eb88d25f564f1062cb23e0d95aa486a28b5ef10ab7aa8e0cfbb1937994dafcbfd90f7f88111d350f7cc84ffeffb6a31a786bd10a1af24af614f5155273552be3d203f22ed2e1ac62ab0730c5684272e203f2aee214fe9533833f47631716cea06fb5ca1ca1ddf7f1332332da457c1034582148e066c87341e13f50dcfccb26782238efa3dd3d4a6a5ddce38fa567824afc4a5aeb4fc76796966a920d50ef69aeeed1e2aa800ca0692def12f9ba0dafc826789ab50223c6ecf60486c787803d08731d191326f13a365db811f95e28409940afc35f39f68ad6061d761804d4c0e5f087685336d227e566b62e4b8fcb066b0bc49d2448573362f3acd2bd54d09d69ca7b6370cc07ad6f50a080d17395575aaee5c6837012dae9188c0892964bcc38c96f69c660d4be84776331e82adc2287892abb2e6a5a990f3170dd86188027d95f6d9bc505a711277b81294da63131a7ae9201ff7d35cb2542564bf191ba82a4c33aedaaaaf6ad43c482e5b36487421df500e4e6e7005632c9b6499bde672c5275955c121e0ad2d89595945e18c8ec87cefb84f122ec48239d2fecd4c75b119ba3760bcfc4febaca0a20619d501ee8f980745ca31f0613682e3edf0d2e84c5cc18d36b0113b40a94eb680a82800921e5da053109bb15173d14ff414e74c2c379d17c88d94ee01f698f7d8b9c7b6feca504a5e9fe9837c30c3a4369bd42b7c23edbf2a7d189bee6cec91fa373c1b5eecf693ef2f85de33cdf68656f94fc890c16269b4958f3aa16eda04757dc3dfdac3c95c664bca3fcfab236c6743d72411faec65a333326b3bc13e03aa22b7635b54634d3e706230cf566f9ccb539478e2d0e293ba96254640616333b10e88f837ff75fcc77f2755d3d5ee0e918ed17f7d20951f2b34fac6af91fce8f33770c4d2b75f40b088f631212bb92aabf2e74fcf391df649115c4a61ec001a427fcef88c6366f79b9b74787b39d977e40a7647e2b14d13a23ff6d8c1f0603bbdcd8205a262f41815663f65aae1044c2c16ebe943a3b7421dc2af4cad769dfbec49650f79ced25fc79966264f4199cf037321321798ccb87ca597dcfaf505f073974df33e37e472c9ad14ec7bbbc35a834bd0029381903b0ddf16ec8f960413b231506f3e1f49755238fd44c5df20acb1584ddbc4adacd10d2569fbba37e109d2e270b45ad27903eb1b5f5ac5813b356c025e415887339ea225a8552594d1739297d8fc8db8ff2c3cf05968e86c787f1eaa2abb09a8a12d3f4d93ff2622c9aa7b87a3cccf49ca700f984e732c6bc8a526ac119bb3c3ec5f712415b034dfc3b9116f49fb200b87325042ff4f43d58f771a522e2447290aa7caac45f624ca0c17df20ccbff18faf971b27abea692c8448f1673467d270f990c2e5ad6063cf2b4969dd7601b4ed820df2dbbdb61526b06d399c9e6c13f4dc41b917983d88f6b112d0b9fe5a4e9a59f7ed928133092222e76aed0e7d5b6398b71708a45c352ea6968d7bf6252130ceecf8ad69eca0205f50b7aaf8194341d8ed9bdfa981a7538ba7374a26e7290645b76dffcc7b9da2fa12c523c7ac4a01637268197c68461dfb9981ae8e732cbcb16de2d020587d46f668576a0cb934b3952523f705270530095e8eed460b08506059e4eeeaf36315858bbcbe9749d0ab608032088ced5cb9f15d7f5d62de3833e9d6d61278c4fc7dc3182e8b6b856760dfc8b0cbb2e93a47946f78bfd57d42ea29ae29450d27fb1cbf5c9f14645fcaf5586ae15fa02e97a1902005686dc0af8c02bf06c1ec8a95c8cc78fcbb882b16c4d8371434ade39be98e7d5eff668ddf1cf0dade985853a75c5df8c85122fb82569b77959b3de1f41d7a43e1c6d1bdff58dacf004f34a422ab7a9ce14294f7a44426e6b36752deb924aa94759e6e1d01fe5cf442199c95bbc67544fc899fe7da91a619f1c1cc28166ac10762544f0fa74cb09e865e5ad0948ac74fc2155ae035865a5cda9f4396f23cbb4bc7c97b6bba8dad983e3f7763e773c1ff7cdc311fb2a5b3c0bb2a717fbbb030694894e2d005073fb5f6d104b4fa20b662a52163e1f9f8544deed758b346fd515f6ec8698fea6b46e59b9ac03e4b7324cb69133d71f870215da87a5ab43420eb0a1be60852533151994846b0cd4f3c32fbbaa441326e73caeb50c285ba5219e557e4771d0bfe4c592ff5a3293e6fdd988b8241df1e4486837058d37325dbf4d58ae5c7967a36d7c81c83ce9b4c02e8be8331320abf352fa17e1cd0d68ebfa371dc15ec3c044ed6c95558574cccd458a653b451368829fc828ef58b206d5f16c21f652ce1dcdb7f46daaa1c88adb94a0faa47b57949232de719f6dc5ca18e09c23164f1c9aabe0c8940d83ebb1e4471b64b91c12e9a8d76665cbd744b924f8e6c366582e99702abf4752a3ed77d10ce000091c0d18fcffa9f6420ff02424a4c84b9fbacb5c597b489a631f6fc5dc4328e30b849db6e1c7138fd7fda33a42df554a6895933dc306f33d2fbb3f86b5e74e0af3988e4df51613cd14c6fd680940d7cf9699ba25359474b73ed70727e1551fc6652b55a4e8eb94df2f23695f0bf09606a0cf1c87f8747e017e941073f3d5aad1ca6d2e033e007363a8af158f13d941ae59cc406e06d6398e75a87301984353bd267e720bf8b57fb6acc4174e65417335497398b260f511799696a72d5b300a5698e90b8b2b5b0d7bcd097bdb23c3a995169af228bad5cb3a09487cf134607fbbfff4c3f2c2a7aad519372d41746e700d50a797e5896bfaabb37d45ff832b07ef99a9cff475e15fbdda9592f37c42d4685649d24be4a1a08834b4fff07a4ad3443a9883d7f8ae5900d42cc5668ab2bff731933a8b2a0c46a4611cb54639464ca98f8d44a25a257f2844f3fc203a7d4c5f338404feeedd680cc1f01ab011f7cdea0e7044a4ac1c40fe57827cf0c4d2b62cd18e238785d1383bb767d585cdeae9c8eaa8e73acf8c29fde4efca460e038f087ddcf6b8af19319a770af818e851ee1f770f375fa7e5afc88301da7831adf002882cb6a4522b001a3fe23600c088632117cad605ee241c68f7d6f93bee28e1967d753aa69d006f253a9acfed1302292c2c7ef83a93dcfad2f8ea5b7d4a536611a9df97ccac67dbc59f517d6f897ec37aa9c76796e6c442119f41881531572e9296480a74bbe5909dfb4677bb970b67362d3fd7b02c17564e2660195490079a32a8bd4c39c1ee71a84996553593d92bc7cfa72b9a93e1aa76ad59af48a35fc86c3c547ad13a3e58017cf8e527a3861785a6ea5721891d1e81c883e415156bec82efe443a033b7e55af5ea4f9586841d02bd0bd50077fa4ed1d30d4ae9f9876715d991cacdb685e6d356ef427577f931a1872375a0a429234570a4149a4106b644f1d5699562b26b7861ce17ef6481e3b7bd9d9d528c4b95be8a64c81ee38d4460acc24ff2e7608cf965168299e0dbf078a92bc5fd639f091240070c8875f0104f67f7ed4b0f5cf107cc9e94fe6e6a2272dcff7e17bd9a969e701798768090bdf9436fb6ec5029c0ef999cc9a6f7d4dea8f3524ee0037031193a675ef352ab01a28148571b91f16a41eaca48399c1addc40bbb884a37c5c629f1f76726444930a2505b6b8c463356561bb0f52a3b418f29d449fc8d1ffc4c4b15933a08a7e22c2844a34ff42bcb7cdd34cba49ffc31f6b2549224a4dd3de8bbdeaf3601265e780efe29105e41140a9b2cc2db633a811304dbca0e6fd96ef4fa0b241ef7cfb7fcecd0cc90212bc5885186fb5cf0c6dff0fec9c6189aea1d66b9d0df3e4249e2dba6747305c0a7451ef4a76ff5c59f7d4de4daaa0b56174e4bece8a41a23075ffbd8ca0e89bc8ad518c18541ff2e9a3b9b40fabbbb82387266a946d2876f658d9ccd00cb3d810b1e9ae45e50009627c02902456af0cac9c2419eeb6ccb4977580fdb28aa93ce35c8a065c06a73a579a2f68673dfb52e0f8bb41ae404683a5f30b49423760ef6561c221c3b25d928e5c3fa1ec9535354ab0d3cf59d17550e7e9175bd6f5dbd2913b53301655fcf30828f57d7f9af397f1131e622fef5ab34aab7c72b234ad1cd2c8db9ee012ee4558676254448df290c5ac1d498a3a6ec31e4f474fdbbd38141f055b6ea87eeff550dc8fd039590618b48c89bbfd0a65b73c197ed95a33ba339989d462f56794845029534a503eba111ff2e5e40ad0032ba9960be25ccbe6d69c810465c23081bd575e2efd1dbd132c8eca96c8d02720c6854e5d25ff5d4fb7f66ace5bf66b01386d0096305f5c216b34a78476664dfc675ff74870e76ad55d9721dcc8ca969fcca0dd478f56d9c5843daac86d04d60c50a4fce4fa0fb01442f9f248614aa67954ad24438be7563a0bdde05178b18bc83250fdcb695b881776f5391d687f5115639ab073aac4e2035aa77848e8412525e9f177b919371ebcda5b65e1997cea2088f4bf63a4c1a3bc3bceac82c6bccb570671b3488ae21048fabf7639fc615994c02aa8df7b9e9b7570029313e23b1bfd72761470c4d5c0b65b3b9a838b4e7bd1912d353b5759dee332e4957700dce316279e7c079f4e79e31bc26f1411faeee783e540ada095096408900e4230805c4bdab7c08da3056b508f9e4836a2b701a2f28fecd7bb8679eb9c79c7dd55b17f235f77f74459233d0cc5520355953405594fa274cba0fa3b4fc231245a1754da65c3c0f47e107bfc047a0fb6ed5d4cead836b2f1d3260523c3bc81d0972b78a08fc7920ca87f5214acd8f7671ecfda1de17a812e025c9ea4f4a3ce88d0ebf2c87d39589184543c80d2c915bff411aab77b41db8107f1079ab74f8460a3ef2b8edcb3555c62146edfd5f875f364149b513fedee577df7be80bc86244f732a4219e9941e044729df2dc6dc63718985da1070a43bfeb6e6ed1208b82865faab3c356a29a41a1b2eeb51038ec5add530f687fa38add825e919e557055525c7d6fb3cce5e5c2d3278dfe0f8b21e84b0d7b0dfbe8100cedde4d7ba029ba2890ed1e50df6b8f2106e053a564d5f635407bfd98f367ec70492a81e85d6426d23d332e54896e4464b4833e0b0faafbbeb4059be2cd54b4c011d95979636ad67762787ff023fed0c4b63b03f804a5fea3e0a84b31a04a8f27063e6542d41a43a2dd83003f81e77b000f2626ef161fbb897a9466f8333904dae1c9dc33a367279542c3b4ce0bc71c7440d6ea8b0850e7fbc1c8ea7fd050a6b2463049e5e6705fe3d38313b749588f9a860d8c315fe4fe9d9a4aa71cef362741f7076ddc5ff59a8d0924c9260333f25eebe0fdddcd2cc873738810538db95cbad6dfe47fbdd21bec0ef7bd416db8fb76102b3ba605e9db38c55b39184c02636e99f30a6cc1110fe58514b9930c494ba60745fd6e8a33b660dc5cba49a492375227c4c8d0a6b5ef1c7fa1c8646b0fdc2ea72258679d13d14fbfc8ccbc9fdec85c58b564df5640d284db1259b1db4e5afafb510b6992401d9d83efb6cf51cea5110b25bc5bac03c6e4a44577dba986ab6c4176a86dc2cf3026b7d16e0f52a93095c2c311bcd7f9bcccf6c4f8367058dd4191f1aa8f6efbffb3b2a660ae27f13c060e06de7e56492d11169ad12d371df2ac50050dd7907979d4f2cb29db67cf46402f5f24595340ebc6aa5976f791291aa094882c86db82c1c5d175eb8472ee996001dca94945b72b27b16d483d2a0de9f1d74c7ac738e17114c6641c077d2c5d653a39ee8d25f038cf1a02911eb9ff0479ccc3e25d93e70f8a98031809a08c1a88e6f7d8b946e86a69d412d5d8533fcba6ea0c042ec22ea1a5430921aeb6475b2411b3d1047f4a6a1fc8be9c146b6dd33a74b9954217ce31f6fba9265df583c0781bab55ee2730c8f77210e262afea65f234a54cb904a8e629221bfb124d5615c47b1758b7bd081d5dd1e8f4880769a08aae44e55a1a569b0f43eb63bc430dc4f3b13b742cd342c5cb561c9872f5db9981d3848d91fac10c537707c1fad9976a583cf0b3cbce3d7af6113c978e530290e00ade17646388bd169433bae176ba42a3cd68dc2ad150c8041c2f7380aa84e9a90184b7f2e9a26cb659a3982836cf1caa3f148e83b186106890681a43a8a58a779c3c93955e073fea76d71c3a66a7718f88d311b86161bba0872f8eecaddd4ece14d2f95055aa48bed3129453659eb5751cb34ca3a680f6dfe7a5981a1d7da8837cdba51e2db6f21c8ad52157be83b26adcb741edbb2606ebf7effac13984e14334f4b10f37ded24e30adcaa41f615a1838e1bd7e6dd7ed45dbc640eb998c821bb1590798b554b724b606c9bdef89fd9ee57700e609d8ce4b89dbbd44c930b0c8e9a2091ffeea414e6d9ea44dca31e8aa308945f70a2426aff754fab09bfdfd356466b5d673895195ed4d1cd2494b0ff6c7a328c01a5462e7b136a15ecab1ed7c5e27e56c6d520390ea4b807e1b60490d0cd4aff21f9f92438ed02952e0c88ea1b2c9f6f73683d7de6b052968310a88e6440d73a08c9819625344e1730b60e49e8f2630552ff46d768780c567b57a1f62349d00c61ce36a54f51eeb87ae4acdc6700a7c316b0956b869f26ac2501065e2f2f83bb800f0e01532d7b1c6b05707f1a6b433d07c8162fc5d950aa1edfeb01272dc76fcf57316bb237730f229a4074e54687eba8843a2b8ca8f83f204089f828f8c79a78c6c9a3a9a21eceb179a9a22a0c8b032668ead5cd0c52379c881b7abb784cc67e3343a9b84cb81790c93a33afd47aef8343267aba01b5593a34a508302a1aae0f322587d8e9c495f8cc1501734a85e21d5603884cdd6444668039bf3aca795cc07764849403b9defb19b71c7ecc4439319969a1b206d6b72ebdf5408d89e7dc4aa0a36d09eba81c48f1f885eb1e8201cab1b1e43a037d687a76ba48e49dcf9bf9d8296a5ce9a197ad02defea41e5c4b6250329f7e5d249f3a94b009692e2932019c9229650d2b1809ced45b9dd6bed5bb2e2320aac6125614a799869f7acd39e7e212df0a07a8423e1dea053f9ab4f920332f508e757391e1b8f23f008356fb74c2432c496e130139994a906f9d1472a86bd21fbab841bddca662528b2ae49d1eebe140a189613adc99af266989971a86ff3f3ef1d671080c8448f31542374df8bf7937eb1640caf32de603df8e9c081347cb505af95e8fc28371a9754d922729630621117708bc3f0f85774106094a1dcfbe6bb2a7dbfc1e15cea1ddd678c81baae9173480bab1b637044ac134c2e025aa3e0e033c3a5e32956063c2cf71851081623c568fc7fa01ec97ae678508c290bfa788ab51ce03e8cd2463693c067ace77b03479c7459ab53c5d49707326ecadf2b0c2687ea58b711a12253963f3ea09822f8e96271c4e086ee6c74f53cb24281f21387dd48b59e4e62c176d656d4c95df98a9d8e3ffd3172c8a188d92471459427517442b71ce82c165eaa0f95da2ec1cbb60ead6be596bdeda7ab152359ca8bc8459b208bd30ae24b95421fe48072de31419a8e03f644cbc662838a2a652aa21057e1bbe1cea8809c3856f0758b25b2ab677b5ea4864acedfeb094f3cc61f9278c50313a69672774163dccf389539587d58626551e939c6143ea5bc88bff5e73b4557c62614439c9e27d4bf0ed86db93e812c983b571fb2f517318c915b819cfa0f52142f1c49cba47c9c17a9198bd02bb21d2c48d4ae151ee2f0041ac5a9270fabf57cbeb9296c189b3dbe38d836b74d5e9d09c2832a88f1882194eb72f54e3dd8097c1691d82e90c901198a02fd0a99b1deaf003d998fc54fcc07112dd032f78d20fd78cd0c060622ef746fb9d03cf0fefa7a7afae51385f8e869c2477e7a951d1ef4485e7ce13f57752967f29f704b2447d96d506711124332c2bd8a52d396ff83441c0b9116f1fd8d61035c654e74ee9b5eb452564088fbc883dfbd204364e3a2330fcf53d9bdebb3880b1b05912fc09f1961143b50ca88d28610ef8838d6e625008ed0449b06406aec2b07fbf3439b346d4c91161422af68e1f18c5bb41215a073ccdb29aacb9585399de545c64836155b5a3ef778537b9c22e60fa59dfa57a84ae4a2873c41c697a27fcc16a9c0fbd04a17cc1ba39fadbed78ddb9d37986ae1b82510eb5aa2c2b99661ecd90001439a06b4b6321f8ca983cbd096fb948838037d1e8aa6c894cbe9c8cc369913843f989e2f96ce87af27b7e55c3c4ba11946a587934e2928713b772241e67beb9bf02822d5f3728c7bd69da8ea7190c9e456120b1dac545f8f2fc08fb819621231535748c5713e07aef3f85bdf1fed247cfd749afc368721e3ba89995e079008a45977080b7a6cd8d45aacc6bdada8419a458221d1a909250260817ae1a05d2c700b34fbdead1ca52c9a95ca7db56124244f848b29230b72b4f788af34399a4a516de02ec3e53a237925e5ecfd0da70252e35d62c888b9b0f64be5bdff7872a5365ca0637012e919391e2b12983400deef7aabf1954ffc5027b92423e33465a43bbabc49a7ee482a006456f7a28c52ad04b5ff39575bdf44b274cbcd1a965b77333569c2259468059d18d4c72f8fed2e224a519cb0073c2dbfa7161725049dbcd871e2955c05e22e26d93031e584f940fdaefccf0cf4587c1d9a380cb4694b9f61257da5de15138df7627513050f5eff0e2dbce17a284926fa98b0fac27c8e0cfe153167da17390cce30ec8efea4aecf4c789275e170ae2a3470618782bd6ebc9eb4d14715af545c979dcb8956ea9ae1edcd9b57a8e272bd81b182c932693466821e2effce4aaae1f4cb85dac46a82ee816acbd4bf367e4df190a1f4caf65d34f3a3b99f2e0777e7f496d10be49652418c17417d8d2d06a30ddd3e45dbcb4722da1bb0f6851841b7761cc58a5ebe5418a2cd81222d67dd036bf9c39954f6af2d257ed2e3006086ffb6e268532380a9a23b225cd006d329ccd80106029a5c8be087955f54ff927a6c96955aab83de511c047a174c02239b1d16470079286962bda3a2da221f3123cc1047aefb043ae3677332ae536bc3db60653aef2b7a4f61bdfb5aea4ca17f41687a1da8c3d0a1f860ec27298c2b666a2dac947d0f0a2c868ebac68716e821a9e67cb32ba8202ffba284f40bf4bb92d355562819cc6a6f5d50cd26416a73716d17f7ec505942b88e3a749522b554aee97aa4b24736d809a606313264a8121bc26481810e372560c9c54bc1008e4de18a5029986b893b4e3e55408179b0af043afce8f8f5340b3c775843dc98b5d5545b0ad8ec4a35722dfcf8821b441df5e5650fa7bb522568e53b16992670249c74a169e019fd0cd256d9b421b656ba8fd0d69a670b7417fa04aad95e83c4f4a28dc42e505d9efe3642c1216e08fc056a2891e7f822d1f2534d67f1f8890d67b58408fc827ac7abf95d55518728f768ed5da485e4534df053517d06295ef92e7975d1cfb9de9fd68dffd26d44a5e8a48b0cacd7e1641b78c8612c82bfe4b7ed5949ba4f441650e901a1bbb1a0b50511ecaba0d2d3ca77652c6f2ed3bce13fcd9ca943e17ae6ad2e8df8b330d9dae2a959a71e9f80b88097cc33a593f1a9380070e934fcd597d9fe37f241b738faf4cfdb463699735ababfb81c68078ac44f91a80180a29861cc97f957c492e9fa20c6712b2f3c0c2ff8b8950e14f9c8e6548ea4134b18ead2a8a997ad311e3b2492f5939039043725d80698dcc2bd01bac69e4fbfd8072580b3ba5c596a804e15a411e5319c2e7deb0d34b104dba0a913db6eb8fe282e52c9b5328773e19cff0d5217b81caf6848800d87ad1b09ccc617a73b5c8e432f1e45ee5d4d935f63d4c4b9a3c726859afad7c2ace85f017f64209a56bb0ea7fdacb538054cc8272ae4e4f9a621b2ffc5c377a42b1c11035f33c957a26de438d917a545991684c2bc028159e6b57bea0edb0c29f344f83ab08454e45c09e515fdd7f9091a3793915caa1b116f104a5d7391f71e9ce7c66870273fca0e3dd9ff831a9ed2c71011c6af54a49893ea47ecd5269e3cc8621bc75be237adfdb8d6924cdd4f21b35e43cb11f13f1309094f866493b45d733baf48e16e7f8a9153b851636678c9f83e6ee03fd68549f2816876eda626c5d707127772419e1133031ba264216e553a32fc4c9a9637a1dc694bc11c6150386fe756d1937980e08e648ee5e7b6d6b4cd45d17a64db38b92c99db9ff007153bef838dbd483baf0cc9f3a1c8b7063bf6d78e9c55ced59187b9de0f7b176a2231070e18c0f511575140766cac85a1a1dfdc91c7d18088320579e463d7ded095209d89bedb689a0ce35dc1609dfad8aee8b21cc69bc63d25765c750023f83fc019fecd7aeea61011bf02180d9b5938d7e029a700c78f49285905b2bcd6a6863b30b02c140000c792097040fc81b27f44ca8c2f7005b91364c33f493e6eae2291cccadb2d57fdf83236782ae24a147fd86f22c5c66efebba403bdb459db55c8fb1240ba5fbb8a7caf86be5a3e39ce02d8612ed4b442a79a1a62a74f1fa0eb23afffca844f132db9876131b1845b2f0dfbc67d5e8327c6a9e96ee90d48eba6451829f2a460358392f375e9a8c1a879f8713bab010c91067ff92ba8f0d94db06aad40f2d2b50e9222156349772365856b27bac4349e9b28c3c74912678903e54f8f262ea0a614d9d66f4122f06794a8e2fd8a8ec9595403c8cf5ba228ffc17dd0a313dacee01015187286f0de7f83d58afa077601777513ef1f0804227f0999afa043d99e63e2dac9051eb4bb6cf0ab765a56306d48c2487ef85d03f9f34481fe2762b03713364f73fcca55b39b584b6f539a4496abf53197c2476c58ff63874e6f39aeec00988d624f5fa251f0eca4ab9ca432c20ff89cb2c393d99a25731830e14de5bef9e17992e1169f693909ed1511a3e2c9fe7e45fe1e57544092776da38256389219a49955c829741f1bbd001d812c07f9ad473392583dec37ba002e051f67d4447330d7b87b44f27ac2e59e8bd32348d55810a26f41b454bb9ae607830ca5606eb85f750b41cdd4bc812162b048b805d19c770bead285d6bcbe4acce9019213945c8ae9bcd261a20550bb14f6b0ead5c30be9a36b415631a1ab54389208c16c5286623e3f25009b050c175641069d87be9fd276a1c52fb3200ae5a92e5e3bbd22cb0cfe0d4693842d36e54435a3aeb3fa52c65bed3462e43cb4ad7ef53d6cfe884ea8120e3821725f8530ac6b7f559d0669b61c7dfa8119308316b642329d6e71e2f7ad921187da0b0e1099933651080611e52a9409a3880fcd276c3b1293a716943da7b7ba0377c341bc542d4f224a640e1ea87f6a6466dd2b4911a5d9478c596f1be7f182e43989ce1ca45d6b6eaf9af51fcfbb505489c7ed882fc3080a5d491948f2d82f3ce44b86b9cec58c97f7d3073024c84e303833221c4ae8c11b7e008822a66f7606bee191def2bdd019b06d6d7fb3561798a96d5e7a4b36c78604dc2cf2f640c303beb4a1b51e482d10c7a781c3a922b78099d7c82218b6e9f7327a21a64606e51add59901ec406a7b2359e84291ce4f86a9a1d76d69dbfa71eb9e61bf7709c5a4bace7ccbb881ff48f0c743c20e3e36c7e1fbfed37709e9baddf1b6614c96a15ebe2b02ceee8df11fb88958bf4e05c90446984d3bddf305fbd38032f9db511d157287c4cef78721993d41e278e913b73b142cc9b5f0c55572c5a1a1a93a9ecf6cb8968eab590b0e35518888a346c463add227d0929965f80680ab459674ff8cb17d0e5c7b37a0b2aead99f3df0041a5f7875b05deeab8cad840d3360cd3c8112d475b831b2f8c07aa4631ed87911cb722e97681b4e4dfc9184a9b1bbd515980a466146aa244d7594063ff020a430a46c2b47d57133d5397258443b4eeec6ddc0731c04693b7a0a2f7a261d890638aa4974696ee8f57168b2203a55281baf8b66f2538e4e2dcda2319ac40bed44ce57492b39ce74ae8084cf217fe234be3c6bce109cce81f7d23abd528ef5ffc9682c2c83d35f6600b102e13b5dd0facc26c85edae294c25668d4f5e63ce7ab60e28de72d2c41455b2efebb48344fbf571ad80faf7e7eb05aa14da982f3da97f4f00f3861f02502904d4f600744131a5a0e19154ee1b3a9ea20d8795929dc9fa4a4f4f19e293a789105bd990d00800e09cfb3e3bb330159e3a58b25121c07ecd380c24af5874d005d315577ae951041cec1407a6e2eacf0273dc0d0c37a2133c6ac80f136a2b923e2422172580171bb5cac4040b8abb63b918bdd6e4a50e2c093ed92e1ffe460f6fae85d0b3eeb305e27390b0307707e5856fbac0a8a4cdfdc0e827e37f16f3fd5beab6f63758379a397ace6e2fe25220297dac02b507f384caf927b546ba1871380292fdbb49b026e969539c62846f18a61f7a703b1710d5e844c5958d5a13b97f3731544621fe4754a0ab9af740ec9e306ad736a8f83bdcce0764229149f2b6fcdc1a0ad8e5e36391cf92eb2979e7e867fe7fb7a4983d3f9c0bb51245e3a38e8ae97481de0141ae1f1e5c4f36e35e7e570d08aa6c2f8bfb269bf41ef478a82cf313b4731264b9a9f3d4cf27794ae4ab6ceda3d5d93dd2792d6157543a2e5b77ef17536e04c94bb99f3ea5c1d6ce56fec89061a2b756cbf2b70f7b435ce31201b5324770bf77d073428d1c7811720aa708d62ed6f205242852cf64433a5318900ff87afc21eb2c97db3d986e82f4a509709816eccb3d1a998d75991759b0b437afa6f80d945e4243299e8ca4a6d24c6fa4d67053b16a2014c7cb4a47cea40345d559433fae65395656df53a5ec7ed6c818a095596af71163cbfab413b6833a0ba90a3d6828555bcea45b9581d7d35cec7175ac29f6efd749d120e8c0c7d8faf1252369228d2eae38abcfb5f3867259940867166c62a0c0a082b751d1ba5df65dd2bc1ffe841a1bd90de1ee461258c6066759951d3e90449be8cffb63376b842798fa20fc80736e3aaa9e34582154ac4388d1ea3c4d8105dc34e60ddd0a07b90ed7c85eb22fa610ad3c4eae90619e57cb19e2e9b464c00277333284192ed8e445ca0c1fabc548f3006c52cad3fe6783429ad8f0a052e7f08a735bd8ae01b1cb6a824c0d8c8f2a9d1266bf530c7d9f70e016f202353dbc3f1d264ae7f9aad15febfdde8e5e1d5676d0aaa3ed9965c3ada2ce85ea2e1cde00255000150c8e8ad3b137f745ff06f8d00e0a9a34c9d4bc8106a6aa7820b0c74a882a30705cf08c4ca512a3a5325af5c2746b447aa3a91bf1e4e71e1fdd6d38570210c27218de6696a8532f65a2998adf5f87b95028c9f82e090a8b7720ec64f3abe95691e5d6b680ea67c8aa47c8d50b0de2905a8664b6610474edfce9e3a0b2067ce2fa15cf012273cd6013339beea4ba70348c4a4a30534bb465c69f96f3603c6081b51a1638158c981392cab6b4e8691ad64fb1c360bc4ebf568d762b117898a30ca4a0f6919584565425c0cae01b8597410393c0e2d773f52325a93ab5f64c0c2915b118d01c64e74d5e98c7ae6af5743397e4c571c217261218180fda3fff02b44f63b79499d5d8a74898d4d060122417d94bd491e61dd5294d7fea1f7a9cc27faecab1b37bdbb24a833481b96d90c16f0a87d44fad67270d4d5868cfdc181bb92f61c2ceecb85f08cce958df3a9cc46d2c130e0ef6e17c28a8ac48fa8fb3d98b774175e0ea4d3d4222de443f07f15dc40b62d75b43a3d287a8c4477865cecce8964d3d326a2efa5dd3f5eae191d9e98c4142f044ada89b4f922adf2c106d9e64a444200d67bbafb517bb02f31e9cc20a7c2ed07aa7bca934aa2556e6b3c4f46bc6d5e982b0ccf6d9bb3a52d7f2c9a8817cb3d36d1464c1c7762672e9bdcc7151d182f3a429fa46c02e17392df0df6beb552cbb2755d011741c93b7a7a2df4f24b062ef47905e695a77dd51b5882a538be787facd3c0249ef1972914eb1b43ee4085885831a81c23cedbd0b81038bee21e469820d2e16ce150a3e0c82f55ab8ebd67fe9934e89600e364fd92271d969913643fd5d930ec560fea2bafd5bce10f38f807f22a7263712938b9988ffca7e73697803ba6643790ba37bf0037595b88ebd45aba21922eb00daa4c8de1dde68126d94c18cd5853e34aea1c4894712368113f06309394de9682caa66ade0ff3166f87d7e23d0591c4985ae544c555e1ea4f8412d67d894c990ca51457362263326da35565e98e550c26350c5ee24be7260939d42d9f9e670ed3174af431a1844c82a636f725f925729290e908f48aa82a63a0860f2ee77721746f271ddddc9c2e0c0c37e5ab039a4349feed2af27659c194f2bd28692d050286ffca120474285680a459b364e8675d812ad4785b8c630c33720d71380f5fb07cfae7a4d2e38bdf45d3f0c3e8061b52846e6ba308432b01b99d1506601fed47b191f521388f8ae947994d67160cea54e6416ac4e6801b6903c5f0b13ca0b08fca2730b8111ab5a62cd623be972c6f6608e9cf9d3aeb9da880f7c5b1ae6a52bc999b8b45a0c2c0f071f4c14694d0df40614cbcd38f98515e0351b58376dc6c9440ab1308e8623fa3a8c8db1fbbaa4d09d236251e5a4eea6660950b7abd7580f123af035cbe6ad1358ac5e89f2181d56b0985186182223d04dab9aee552ce154a954d5f23ee1d3590e7d9b80e60f9542aff8d5f642cb34b415039dea87b80a4938bacb92bb42bc8d278c5ecd49505a7b3bdd34175fbd44f8ed35e60933f6734aff1b00bc49aea6092b23336b2f8f81c0f7c5cf0b9c9b76c6f90254faa50cc573e7d28226ec83385872e44a2e84d5dfa247689df53646c0bf083c6f43f6628f7089a74245c7c91606ba8618bebfc9ff35d1a42b8bf1662c544f987bd056b89a3d04c644f8cc8e4936fe0fca98e8e54488c725e1c9fd4ed57e49f896ad1024590e22c218edea598356dd620dececbc22d054ce6e25cbab904ffa40201d0e76f7e167b7ce6bb51f04b72cc9f0ca258fddb31f9dbfa9c08cc3da5ae48c90a20824c4d4103f37a8d5c846bc5d7a047482f4c47dc80e57b6c6832ee608472ed9d697d51f3d8b54065a33c9e1a3c86ce130adc9cfd20a4ef29b79a1f771f186db89565e89238c7243d7c8fec5adf3cb99182249218211c459cced46e618bb9762cc05dc77ee574d3558fe5a340fbc2444b431f9f26f5be03f8abee33970a6783f507d0bc2b614f0ff191c345d96fb26d63ac425f50142d15ab8dba2df3159052917507e4a71b0b2b573bc25358c3bde3e894bf1779f3a7b36b0a5bc985564e575a84f4f06ec02ac48b8351fa22350095cda3ff082ccdca1e3dca7e57fbe55e2a92c6965a503b6ace5bb6d039ab345aae1c41a5df0a376bbfae132b83ac6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
