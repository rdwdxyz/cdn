<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a5a8e088456c755881843deb4c132f8048ef1315e3b7e1cd6dac5796a543aeb5bc849a6c23926538770d5312326ce72694942edb3f285bbd4c40f5a723d567240469111e01def394771e64f2a96f97d7f6ecb6de46371c3705eb25d22566d5d4dea39e0c41e9566ac274334b43e986760f6df695b50e6f738ade058f76dfe3590c29a90430447e4bb56cb30f44b24028ef86fd30808a044ccc62e1a885d106c584e959f28552b623c9c6fc037992bdd9a92648f9c8ced973c85668657f1acc5a69197b8228c4844bd0698e2fd2db6597e3608f4a4622c324722a2593855f341f7d8c235cc4529ade6987a3d45fd88245ef0f897f555a2e5d1b90d9b9819978bd573b80b7d303be33952784035f3ca5424b506a144bdc7c0883dd674b621426dfd0efc5680acaa36f9353b70bb6215788f501944c2e5e52db5db109522b3f808fe08538d120f1b34c4e334f82c0c52e95707ed32d380bfe00f3585f2b34ae1cfd09975ead8811f58c4f8e85d54c996b1d0a138c8b648e202bbf878b6fa88657f537330dc414f5bec3192276106ba0df6bdc9926fb333932373dcffc9b0632311c1c81ea990554b97b67f88e2dcb378a675e4201f5b3201c67ad1f481f592ad82d2b7e98ef7f7e897a8479910770eedb9cee1845ae877c35f5d651885e1b81d5f37ac2058e6e4b6d4f6127c6d7573ad1d3397fddc2e3f513e1757819568f5bae81ebd2422b73bc90beda3f536853ed8004e07ec149a23fb4b64513f97563f9d9b8254b68dfdff122ed9091da07f5a015b850c50dd46e907323bedce2e56a810b4926229ffda5991527654e74a54ee4a5b914c943cbbac10ad0f455349909ae135bf693d1047f558ee1b3400989092657c3470a2c05f80c7322c0f79b5fc946e32e130d52e43696ec2b5a2aaa37a24e4d2dfbc9fb5ec70e67eea011f067699e84421ea1ed5b0c1e8989774c6a9bcc7f902fd7468c9dd487d6b5c1ccaa1bfeeb81f32c954fa099979d3ddc48b0bc9a906f2f50ae501a594922be62f61d8838f0a55f4b7043903de81f3d5fa97a40cf461848e94ba9b95da34b9157dc8c7a1f48c8f27cdd4a3d055ac99f1734e6bb9a1f4ea349e21e788b17c506129f89e95ed6888f774728e668cbcc8bb5f25d461648630a8a02ce53eaeaeda3b8e507497e3307fcec63963ab68d437ee5345e9a79297db2c07990338013431c801fde3e74f8461ff4488ea1d4bfd25aede9d9d4a166919e1ee7a1d4465512942d70a9b20c633eb65c1035f9812254c9f2be049ee86193b5005e5abcb5ed9fbef041fadea0d7ddfb0952cf0cec2890b4c16b9be433f28e220de3a04e0e437e3af783fa9367b514f8e3af3c4d2a52462ca995fa729116025efb0f39112960ee692082d7c0672f6fcd718f8c4879fcfb3b6b9211330ad0045f6d798a9f794e6cf1f0187db8df04600ecf8c350bf436b03749cf6c90393fcd7985d698ef0d1a0693dc35d0ac6b642aa9d8089bd792cdd9593603509baf6d31c198321db141e5726596d3e887ee50b6583e6bd7f370bf491497deee115c518401aadfa28afed8a75e06c8ef127bfd54ee8332b0506b29f661738975298a5105a0d3730dc5234e7190ca6da8f3cb08b630295e95249dfa6a0b5ff03ff0bd110d5a74da12cf7a519c441ba639020151301ae1378ae2022b7594bc41a4b4a74b2ef1d7122ad7a5e24c944e255a8b43ae5f1aef70748990c2e926e4aece44bb7168884d395217f7ae316ddd34172c46d0e2440353191c725a445cc1c3d5bec688632371fdc50d8d86363a3830a447bd3e8ac4f9faee7c45230eab6b6e3d364c2069801c1c4346cd7f16468ad617f84bbabc9098c9b05400a220c5d02683985dca2728f567dc164bd8e194a24e37b8e9628bc47aff0bd154b26a0453eb1d4a4375635e2bdeaf83c5030e0463519fba694d6c72cf0a41736630cda3ff9d99e82c58ef8b89673c84ee7ae389c29f829f56d91db3fb7802f6f0a61fc888d3929e9c58fa5b3d1226f2d7c15cd6e0608d386dbe560e0004b13c5b39d0723e89b4fc9ea03e8c4745e3aff0bcef4c0ac092d2bdc28d71c5980ba798e4f686b6af881153184dd02ffdc5bc348ff8303019fa6b71f9fd4fd452b8ae12eac371c583d549ea195feae8a3c4e46dd7562de99f3f308040238520025d6227a38cb6874958561e6e7e9ebd403971846d472dd51ac26758aa5d3fd4049d81fbad58d3cb9834e2a7deaa63c46cf8d8ca1e5ffb01895089038a064a999d7612454c077f492f500e81a3d1efb28b8142405cba1a541521ba2bc4a578d88ce4147f8918613ad20cc66908ae2e31ba95a040911cb18c14f6e42651919d005a0f262d1849877d0a9b56a1dc4749433a07417915cc48cef75cf9246d6c51955768bbc107f6bab8ff56e0e0f3194241f994d7e89e8f7a9c54fa4e60e44f46af6d663aa8b7896ba711587990552d3e81581060065db123659fdf62c046fa00e925dc14beff69e906e7394faa27af4843a039be6e7be1cc5ab6ca3223ee6940d82fa6452c23f32d72c86e2806a23641983d758cde25ccc2e8384c6c3bb1a7bb0bbddde6cde85d748e28450897a16e71705343849abb4bb0bf1d4086a735e59f1881433d1f61de646bc28f3fa82f97376cbd3b4751f3c15e43fca0ff442543e17ad716798ece7ac873fc463cc5e2e0b061e88ee259cb581bc0f828e56c2208b5c74ddde7fc387d0ee5acaff7707c344dc28a0adc5f10f874c25c215508cf4861ef5646fd247fa7cb0989e16a2d1a52cacd569271b0c9118a87bdf06fc793cfe735d301acd864a5b46b7f10ee72ef8bd520bea50264784d82331322b907d4cda7136eefc1274b1ea626b2c90d93e7386b78009d1ed6f20c4ac61878395e3a922b7212fa0658fed5dcfd99c732b6b0df66fa888370a0abcc0e049b1042db52b95e08b00bd9c6f892a3d16ea3d427e19e7ebe2376c5e81b8ca8f2873f781a2a2ce3cc4f04d863f765a240e27d62296ff77ea93c9963068acff7ccae851dbaae9c8fd9fc2bef900869d33bdf2b9e2f8dc970ebd936d4a61de586070ea46ffaa476a4658b7b5bdf7fc70d6ccdb8d6e10d999aa28a849686c74a5ac73314ef67bcea49cad999c555c7f6c10a5e923307551ccf7fcb5634760121aea8c0ea4aeee9b657b6516a848a6dc16f1b3439f698e6b89dddf650387ffc22c092cd7798c977c7e0de76aa5b3fcaf9c5265a87ee762bfc4364931c2c33db994ea5c3116efa0ed9d61331e07ad0127843f17ab5d6a76de5f2fed2170923eaa92111419282602e2f9c496fce81bcc1a5f33ea34503e616b4dc3765e66c5c2be335f5a346fb169fcac37396c985785821510e2fc3dc5273740cee5a931a865c52675d23133c47f70a9901ae31c8920cb72237e62d21791b7f5c32e5a486fa3bbf96c80ad418320ea65f0f14415dd3589b8307dfed5b3375e10cd39dd8eed9715affbb54e0db6417edae42d7e8523aec17328cd88f0bf698b6d1ef3e38b9ebc65f285ff6b4fa76bc2e8898cb1c83a52bdda2787de54d6672fde4599f88fc919965edfaa5e7388006f97bc7036161ddbdde2f5a65a64571b849272085d5e04154a75e30e05cac14367af993bef9c2b681c5a3d166a8474f0a4a38dc662b4b37f4797ac16a4007ff12139c4a47801d4b17708c5b8e8f588af84f2fae6b3d2c15743c891bb05f8e5c2362d3704a4727b51a4dce73a1038ad057ffb43d04df628139ade346c813af7fa8e941e205f67d535a8e21d0cd9f4b5d2c0cbd080a9c53c6038507399ace697c77203051bec48a27404be224b5b9fbd18eac5ff1938335e6ec4a36a2d1bdeced72b5551273eab5a7dacc6599b20eaee9288372b00e1433d5b13d7107feb2a620aca5c758b45954b676294688aa4b291f2b1af252ad968d027c868d0124ae33b25f296a0ef35514d2c4230ba730d7d81db11de3dd06330d1add2980397338d719a58bb1edce3d5b3df7cb1ba2d09a40231b9bd66344f98b8702c230376e52be51977b86f13761b279920ea3cc190c8781cde10b709f9f376f64407e5cfe49b739970cdb35266006b03cce9be4baf96c7e9512429783733e401f60f57b258aa8264e64c12c877eacc2cb0157c49be291e62ba2f4dc6af9625c3a4dd8badee9daedd6bce63ba78e832fd5e4afff4fa636608072dbd4d2af4f71fc8e32fb60c901fab86f02f6b5d649d90279d2243541d0eb8f88a5247997b44ce5c8e21f71af86d42b68800cdaad17b135ff2542a6ab9f0bbaa70be2e39a34a3aa30134aaf126b43c8cf85bff2b4aea1f6263378c3eae589ee7b68ea9a3e8ab1131a0b459db2c8ad6d34929208ae801b76f46107165baff38e55ee59b0ff77596850cfe398aed7b53eb3003406bd8e5eb1611043ae2a97362401a00633d1e692ffe712d966a3b8b1375d2d8d9a9efcedaf134b44e8d20ce8167672acdeab07419adcd760475d66ee9fa549749d3e16c4567c9dc591f6d62cdc161582a5245c577c342fa94cb03ed628b8a4d242d79aad68390d9db524a949f182f869bec83f51185c6bd9f6ec549b67c0f532156ce57ab1aeeb3b281fbd3affa67aec80c75f246adf9794866aa75a87e54174bd74a0894c104c2074d5e8279d8f5544c50f409a436f23cde1840deb7aa084e57250e917f7f383d63dd7b33aae855212a64f1a4c7cd654f453022ce0d6ccf7cd91882c9b821ba6cd8edf946f98763642d89d1143c1ead69f895c1629545754e76a4220150c8413ece5550272bcd5962ea7416e0ed7decd06f5f69d1690fd1345524c8365e971b0a5d058c208ea5a9b076db514b68282a9dc6aa9cc4c4b7f5d8c5a174f4f751efbae9a08fc03292a8a4d5ac5648c5985fdc799fa6e0abf3a5e028812f9cb387198b4fd5e3f9ccd4d7237327defd1fcda635b00d1b1eac676d31d1f59ec565b66d11448ef9fdc6efd134e50011b85b997c7160a7b0c8251c525d7bccdf3782c3abfc342f94d58abd935ace8310128f1e5e2e6df411110f08124771f9fa336c0ccc93ad33436a5d9e0191e5b105f044a05ac0c9049ae810def440865c55ffb5a9f7a217f449a60655551776068c1a62268b4895303b6f9d90d665cb0cde2e7dee5a67a2ef4c8af9f852a3af8d29f072ec1d30a882b3b1cb0f14074802749a5024ad2c5617fd26daa15c7c5a580ede4d7c85713a9ce49672cd8f00a224285f68c24d4cfd7fe930ec172eee1631c5678ac6b86e34248adb50a6a7598ec56d4e27e73351ddd322d359a919fd8492963102227db029fa0b05bbc1b602db6cd5af91202befe98e54eaf9243e03079cc2f34f76e91f27faa7f0974343d9e81b4fcc49f13373c7375939a90506df050f9c96989d00c1cc28323c4f567591c68b9fee3f3087ecf1ee003ea7b62ebcb8a2d4e2f0b9d53baaba51700a44f8c0b0eba531a90e5e6643387f9d0043ea1bf5190a4f0b1f90f4fbd455beaa45f0f153ed662e5bbb980555fad533597c5ab18d6547d8c27b34169f79332446e6e58f8b8185279383ba7244cc373842436fa4aa51682fedd8c2f2866e8ff914a801ebf621b2c1ca82119b0e26ac12ff3b45bea27902cf0295f608459dc4b8145e1a4a244d0e05b22557f3b0fd7fcd08f6aa97293cf217b7d7405df2ac06a76315f30e7fc357c1edfc0d518f14c093036b66c0aa3fa0e682bd9e36a87bab2ddb5e1ae7dd2bc1b61b098ea238fffd3221428b5fad24af543ee10562ede92e83c2d309c8bbd965d05161b725718a296420d2e4e87066ed33a334262a553078ec95196d9ba05131865b4c27adb84e3d93098904fbd483d57e3476818aa36e533359a5e0304aee66f5880e140afa503e5174a3c6531bfa5fa506d2eaf2a666861c48dde1f5e758a5203ac08cc8007282c85865bd8cdc5fb0cb0c563e4627c0b3b7ca1ee3e4f18b3b198da18485513063eca8ba719fb792c40d624755c2e3f6b2fd47671b32ac814e2cfbe4dbda0b819727dd7403df4beca7bda2454a1c94301961b511d51dc9408246a0f0c04303b9bc8a97a885dc6f9131fe973d99c7054c93b2a48bf4c1472d37ccf02c6bed61783485e5defb8787985811f990ae9adbfcfa7e4bb216e6079ea5ffb558ed21f42a9d527485d980322d42a2426c93d9bfa1216be3a4fd8d672e461579261f90ee8bf1f6b65f599acbaa8fb484368051eb6e33313c129aed00a4df85fd8fb5776935c9447446e3e97862b821362405ad0aaf051881c1bf53177f461b8bad3c0bd839be8bccd5c4d58818bfb6bfc79ec54164c41c829f7ab7d89e9ddf5d6ed7bec7ffe8f2d483ac371675ed0004ef7d6eb574ff340585149479600173e1a23587edbea039062b278ecf83bf96b79377a059f4ffbd54ec9900d745683ab0a219cdf3fc44400c9a6e7ffd85b80dc719b3b96b9a4c9129467132dcf5c3220ec4b3bcaaafb0498dbbc495573a4577e9adb4de5350e5d4cd917bc9d2e7811d54b3e2eec1c9a55097e6610318e9290caeaa846d7840ad74a8ab160bbe11562c4aa284ca7326e73ace3173c361bf54a50c68610b9814aee48146449ca8747caea2148674c6f082fce06cf50537aadf333b3f20a1fd3fcb1ba212a2084f23a199912c9a28c0b665716c46c8ee10fe97d3e8ac51dc63d212f9736595616a164b84a54a72d06c93c48a11bde1a1255b32cd80aaa7fcc557e354e99c4238021e531cbda238897ce5d535722e6f465d17cda1e54b39986cb7e5064f71902cd92606eafb303b564e2ebf32b057da9a86835cc3974c36469bb67c077e9dda154d65d13bc584f4d5042740f6e924e6ce437bce4b0c4b0c745f91e04b6380800ef57cf3a9e2263c3c06a1eac105204f3eeed0fa173b9044cf04283b34c47448d7ba8c2a6a9ddf6f2583a0f053c2e294f5f50cedced2ff5e8c372b95beeb8ac47d065700c724ae42a1dc65a429838ce2c9bc8181f3dbada528d2deb451cfa75edd9b956eb9c25304fd63de6e47c07be96042e53f78a10a9027e5b7733d3c1a987cdc3ca54c125ca655420c740705043349e89956155e8ed8b67199392e4e345128c1af9986327b9dadf155c33eabd4593e6aa33026181a15ce55f67c80f57dbeb31ac40be57b3e4644829557d54545cb08765182e2c9f9aeea0e695c4e0320538091b5e449c3aadf3c505bd64bd717e95dad2b638f6b8b15170d54c75903771cd59a423631efff9825979f2246ac3642c9efde04d9f44f7c1446c717f8d3d0cb80b73167562d6de74b4cd1226c738a6b59bb2f265ab667f36640cc8948c4f1cd4475223ce871786b8e0c90903c539a9605b47e3cb442aa21995c20e5964e5fdc69e777a08ac309b86b983c3d6b241fd1caf6b726563f49cb107de600f5102ea57538380b3adb4ade3ed9be6cf07f7193fa45261c50d39187f4310708b7cf8a1b485868e670147ef3e29e7456530786724d344c2efd959dd33970d93dcf54e6f2c98d8cecc9fd2f40b3cfec07221133f8524416c2530716a3ae003d12f84a1554a10fb82a431ad35aaa55222e2002c6758035fd3f05740ce1e0a337dac3a95eae7b7467d59eb246749f097206db184365ed1ed40134dc771974647199d2db8219ce6bd7b8551e1ed6f6f23dc07c9410d3f327bf76265e37ebaaf49f6fa82433b20bb0001789de5d61a2994fd024ea36a3ad0692ce8bae2a27d197359d1ff3ed201a3f4fc307bce90f79c9d0b5d70d8585ab0a2c77ca877eafdc64f28e4902e915e66acd07e8d62d5ef5dd528f3bb7cca2d6f37bef63050783a67f6dfb92c5dd6abd7b2c77a21db65d4044e1851bea5748ee637d071f6ba677097f5427b5e5a3ac14fad99942907456d5bf4cd1f031c02407eacffe5841cae6d062b77bdbaedb5e9b3bfee3fc5caac2039fb92eef6bbf2515d528f1c9ed87716d6588b7324738a6deabbfcde244b6d192cf24a927c81bbed332037b3602acb5f5af11c880f98b2655baa09fe4df5a8e9e3245fec058cd700990a88a49a892ff8345852cef6472e956c862a94e3a9c108f3d0cc4b724c4030bc79812cd6ffc5bce3e05b6e9a0c655097961363dc82e1628206e762dcb3b3f70f1f688fbfc1663d7cdc7d7612d7d136ba27000c5fd642957aa9a9783ae777f7c4ed7f143f36b7c1eaa8199102d550fe8e707eced6909bbeaf553a2d583fbb0e145a5bd208e21fb2cdecc04524934ccbae80962354126274a7031fdb9faadb1e4b62ba229141e31bf5ec9166cdb12fd1eb61f789406990e45a6dc996fb786661b3b6bd24f3a8a2d6d5bafb889ac1247b4f16091967bacba7d5946cad6ec2150cff8182070bfb94f6ac8d26a8b960a57d3e63f12519d856268b60b2aed688f749a3fa4f2ee5788668e807b2b42095187d5585dc3bd43f951aed9ae527a3688559c92e5a5225a304b7e62d5b11b0cf09513b6f3f99e6549cc846f276f0d49ac95d5d7019e2ff9b3f436b845620c64727ba1a7075c734cc319805fe278e3f9b2c2c1bd16eeb973ece1ae985aab7e9555bfb73923e32ed46aafa008333f0eeaad274f02a2aa3be51c67322b3e2d30ac34d28f0dad6973d8d4afb9016277a4e1c3d10689529c77e92c858c7fa5322fbf3eac39264f3fe717ff2142a1123840a98cf5f4f3520f1016475747ee934a4e5293dbfc7f1777a1f5456653ebb2cc32e43a8ead5cba0a29e011a039932f00cfa2643296042c89a0f3ae01dc755832100f6450d87730fcfe2c880b47f8e176cce14b85d1b8954461e3cd8569d55740d0b67bd01dab8086d51d10b4745f4955ccecee843668efb1f7f838ca83cff5cb0611b2f3fad473d00e7999a58dbef1eac3c7b268227b46713b7bf5618cabbf0dc744a4e9c0c6f47257304e7a2e5256c588d6686f26ff95e564335c3ad0a36fae12abe7fd6ecc13458fc743b9457e6dc5c2215f82e789212b37e9260c7aaca65c49f3c4074a165bc5107f6c4016669f8b5dbb37272ebf22ee02267e0a2a725cdf833b65caac6088bd014a91a4ee917e604cc9a6a7942ca1cbcfb6f28e1b85720344040ac7ad9e685ac85ec61c6fc07a8bf1b0b4e3848172b80bbd454754e54af5a9ac4518f3f3b0e8ca434ee915935d1ae11c2f3512beddfe8a7e2f27f3bd0af6410f309782a58043bc11e2402416e67d1ff29e086e27be13e958108e9b69a4276f8a9b0152115cd805c8da25f6d8854308e5ea8f1b6abf94404502c69aa9ca44f2343654ca5ac9f01448c527d3711aabfcbb2463e711f991b442fa36f5098ee0fd43e693ffec1e0d2da9a98571ce474c1a0d0fa16d147b5f209bdeba592a8527b335c18d55c823706bbf1e45aafe37a1d8d26e3934cdb9c605dcc51f8cfd4d174aae2984d3428fb0bce2cfe42a9cc30a11a3948414bab2abbc70cf4d9f3d8e30b7883b75473dee92bb89c58e75578e1f236228d2790aa397eb3407f887c4e0b9ffe735df42f06ff5854da5c21804ee4661a3014e67d53942e86cc414cf6951913095e55e57676d3d035af3367f77f0e273e6657cd6128147a498373d912c118fdfe07c62d9e4bc928b06bf6d1cca3fe60c516e7511394a39bb9501a95d96e64e0e8b716d9343489f14157d934d62a6df986c4d7e127bbfadaddf622a2c0e8768484eac30b6b008ecb6cb2256e4ea8ebca5bb7a7a59f9eaef7374af5f7059480c72379227f399320f703205c9d92215eeeab8746791f3cec70569f151937d5ac03221fab8825f42b03bebe2df75a93602c6b7fa6ba54c0f80318e3dbc995f73f12834690337773d229319d33cc1ca6e13d823e38af91c97c613f7660d0bbbe17c0a9f29ffd2962d5128cb01efb46ffcb2f3402ce9cedb07d6cd911b2ed60da51d63dfa6b97ce8c3e8d08bc0051a26b2619b010f7731e3f779adbcf424ef2ddbc725b56bbf0a504a5938b40ce275deade0e4c0c9a79ee8e13cf1dc65b678e31f00f949fdee3a43473af1d8f8ef6217196874f28d9496d72c25b3dc9c717658951a97ac25c738719e876298caa1496ac97d1e63c39aa6d0bd8fa6d2f5944715ecf3f94fa72803fa7071099a17a4060f2ddc024d1aabd9c984b6cc4f5eb7bce88b7dd9f372632b217e3eecb01ed2bcd09238511c3c6e6c8eb916248bc493d05cab947bf7e4e2344ba2a8d88bc7a39daff2f503c16dfe3a6ce0d5825cc79f9756c705965a0a2793ceb74fb7781956a6575e581c4ca54d0d1c81dc50ac0532648bde230d8799bbd19aa12ff4aaf1c66e097224302a40255910e3965e5df6575b28d23fa6ba2c5f5b7567fa218dd8d3861d67e3c125407c989f087924a654a7ee1f2c04f6fd0f5ae0b559c26c1210e3cc3416ea71c8034ac619f58412bdd64332e8440793b0553ab1314a9a9c64042ecd05331fc2d954beff48daa0f015ff3b4c93d2336d30773a35a4fbc2f3b93026451b30695a32557b02688e3c1320d83f7c3c3bd501c36da53eaf446cf4a2387ecb672b16c9aa2797becda9dc3275465a6f688d33eebcc3a7eab7dccfbf0b27f405f573a57731b267878a93202e2d7c2d105079d1ac409977553c250661bfa7a8a44aee8e2f3be55978c45b018b731fab93690670d8494c7e5515242fdf86329114f59c76d637a47d67a92f7adef8bd6513b50f96c131f07a113d99c04bd11de677f2d341f6ad9e92dd22ea95559a2271827780255aebb72d766193c1647874d5a3a101099600d86a0140fcd9b9e48cfa05b07f86ce45b3bf0e7c4493edca13a3e8c3dc4a6082f1bd5f028049e21f32fcb5737009db6391b3d4c93196a07ae1fced2a68bdf7a0ee51d1f517957fb42ff3197cdf0b4fa828cae9f22157c483eee9eb575de3b43733b05d166aefdec52a2ddc6bdaa93a2167d00a86265232ff36393fb3ee5960455944632593febf65d31156ef2d1cd7029e333d3f6c4cda564095aad73f0175fc286eedfcf48f0a778bb0127328f92a289f869f43e1a7b5db90693ee8b5a1a295e97799ad727e0aee9d1baea746128205522f76ccea2464dfbbf2bb207fc3dd22b245202c47e80cd258c914070200567f1bf118e27dab565f90d1d7f40e5e04bb0cf8627f9d4063441467c696d45ba4e8da0f4ab2a879923dde10be8a9e2067904c951e5ba03b770fd7ae605b32d23710919d5a8dabd4944234d58aab1e36a9d1bee0a5e4d3ba744c90657b5a5bebfdfabdeac70882a7cacbcd3d57441512fb431a090c305e49625f0e189ee432165c6bb7fa233c95a2eed533b56b12f1986bf2ec2e0006f69a7fc9fb839d5a173e91c1469b8d21845d1395ce9efb22eeed4b097a771b78b8ee4eaa785040af1d4a60137209343021fb3bac3a2c58ccf9eea20af62097b2dd0f5c67e005a0d3fa2c0f17f38a2ccda9e6fecacf7022c1ac74e019dc502a4f2e63f2dfe0d28ac986e4c1a89dc626d20bd1348a5faa9e58b91c681607c31e15e3f1b66dadef64709392bf4323456e328cca44bfb56a059bc6da219171105d217d2b465ec89c9eaf1ae241b11048161d107499d7015cafedfa6a1e22fb3fd6e2f74c6c5ab82d5bafd47a7fb12fa61e65b925e812a59fe114a686447c85064842edc36f93880539f87217891cae0291d4108a27f80be7508f6b84ad1de28b06f07ae038f746861cbdd11932ed535f2a947e48ffd4b799152639e674fbfde702ea3ab50da934693ce8163624c7d797eba9f8b569e125c5ac77de68fab4745d025c064ab0e6e838d3db3ad4b77f55432b74d73bca6c22f6f2bd30d1fc4c2642953d95e8d963c9cf9fe6480f98d1c72a7ba5cf311603aeb78497821361310a9304929d1ddc0e28989712d2c251bf5a3888d9f533378d114175f4ddbc6c5a84485626b5e377f2315a8d78dd09b2f5f8daf3e63d762f137a120fb9bad7fd8dcac4b4b1cc2eefe05fc96f3dc005dfa69f171e02da333a4bee68a4740522bb207c0177609943803772a0ba2d53131ed0362ce2dea141a7b598e711b20644c916038eaf9c07c5e273b269ad1238291f3afc6ed3154fffb080f5d00d5a99dc58e1cbe62ad4d06b6f060595c01d86ad3ca81cc3c81635db2e1f83a80560c81396f830c81b87c4e7ddd98c1c17da25011b4f63c6f8df9e6db8d95a0b6c2ac252eb3f86efb39ef88f420465e8107cda921d1b016bd46f406c00a28b71be2174ce6f30fae02fc9b300569facac9eaa7b29fa90af6cbe947576d587978f84cfdf8e08dc07dee136cab18b7081e333de76a001486fae4ba0001ffd75661eb980c4157de30c34bd7f263d7c0ee7cc757fcbb405ddb75df481d1b2568cb0b1f1f8272ac880ed1172267d178921173f19eafd2276fe4ba3907754162a3e9c5c9a71f27ce9b5e34bc2211a5453f77f68d4d440a894180cd2e84e38cb03d8cb6272bce451e95141c6088e33c1aaccdf497208f5a415546c53b66816222179150e41374219dcc84d917d87739dba38e3bceadb5928a890dca7be63d62dab346e3d44d4b8d15e806144a5b16ba62693f7cb71a90e049c1a3df581e6aae8af1a2b62fcbdb703cb71c1eecc2bb10a14f3054e887755167ecb1fef8e68d3ea81cced2bbf79f6f649e0837434c41fcef5c6df7fff5261d956c1607fbfb656413507f3225082e5f6d3aa21192bfa59df2d7a38da500869a404203f254d45dd8f250a177b2bd14efb9b1dde814e82b01fcc4db83b0c6e00ca86618e82d1499ddb3b09a3394e9149ceeb1e01e36a7689a43b04646621a9f207955d31563b70b92f39728468b381f546e355dca2cd09ba0d723670fc5aec4d5935aa4c2e9e4ce4e4ff6c8d1b6996d648a6273b11f1862a728603eb3bab79aab416b594a949386d54a61bb5be433c8677be4e820f2f0c402c0c59d1b6c56b200e05e4ec240f8d2bd2c6896b03ec9dd43700ba5d675b5818d3902080274abf8e934fa7233e6487c02a06ce886ed3b89cf694abdaf5c8f1972b96f8d4e87caf2a71ffc428b77fe4c2b7a6fe8d7b662583d15a1d8319b038408a3ef783fcdd39f2d982334c3e2f12ad3930d31dfe4966c9ca9d5045985f6b1d2ab03cb6d03efd7235ecc75e12bc25608ef19c14c31506d709bfe0227d69bc4f3ca84d9a014ecc1a23e2eb0cc2fed71a6c0417f05c92f0367e31701d3f6ec582fd2939a6f48bfad8be8034a6e59ff0898c896dd3e9811b5fe483ee8af7c61a0a7a368f1e0374eee57e84608c625e8d6a4535c8fbd6c5c7f7555186c0bcbd198d2184eb52c0334b2672889183eb6ec586dfef651bede58910d950b3af83297e96ffa55993ecdd79d9519f8d871bad252436cd1e87c1790b9d490095d5cfb58c3d840514e8b583461e2556e79ba0fecbe52b01ad610f52c41e9234a8c01a1cd44a8ba3506a653f7adb777c001657d1a3e135c325cb97362b272c5f07d0278754f46d3399f27cbfe152e9894f050fc3678e850f76baae18ab34bb98dcba73174365f8f274c4b7b08f2af412abd4690b8792f6a9e8198083ffc3f7bac4ac2a265c669557692a387f61c08f534c5d83f70e6c19f8b116a5f1ba5513be7e98b8b169dbfb07504824decb9726cb7d452beb22749d1482dbd3ddc9650c8dba574aca9bb982862f1e1d9e0bbfc9f40bdace7c017ed52836f4e16aee9c75e1d8e062e810ff4472edda002a1a8263f09f90c0f454221a41d9a18738718c1dd7de8f0e50a852d7caafaf6d91f4797bce474b3f8b4a980f6e2acca85f8bad6b1a1c8014a7b316aebbbe61899612dfdf906270d881cd881daf26a65e3582f77c50ef18d415afcea757778be61a24ea00b4adbfdcf78f140b2224ac5588b27ecaadcdde67f7436e6231a84e8687a44f2a0752f6158a143707c10159a8d2b3535edd9131c148991cbf139c71599a38c29027228c580c04f49cddbb2513836460fd2ee4d29e549c2012c61870f859e972733c36acb1093078a84d6e675e9866c74a5e6f944e659566cd6b1d99046d59040aec8c40fced21b1b738c90ac48dd956702f22248a6be84f34a56268b6b064ca661200f864bfc9f0293207a2171eb6898cb724734dcff82c9702831fab29b14b1feb25ef2c86d8877fa30cdfc7c55d89ecb659d00cb477112f77b8763f84f52ef24fc637400b96843494c0145c4873cbe7140c8770fe8e99b778c1a73308c55a0ba3ace145fc75c5d10664a2276b415033cdeced38136c3358518ab668b50cf461b5b1562960b8600e8e2697bbe5039399022cbd6da720edb63282818c94dd23cac99e364545a78d20860f8e99205cc505116eea1cc3d2d551c1891379e4629167bc1f1d0fc4e10860215d4cff18ae021bb1aef1c6ef26df0809236d788690f24239fc4c76526c69b3f2da8229a18c0e90fcd7db4d981811605ca07e86ab82675935560d263053056020cd6ab4a792546cda62a5a01c1b5e459014aa00f6fa52319278a768f94f8361adb5297670acab4e09d2884a872101dd3e5d7134de1e85e84fb20893636c6d8bf0992d8367423a5dea74a85700b0f3d8149d678c0e957032b0ef0dc796351345f8fa452aeaeb826da23c1ae462433a5e1d81fe79437c6eee2a235fe8b38068cc40638d3233a1def39a1665b10432319cfe5d1d9508592251936baf08666a03902f5f3fe2adc49deac48bc7c669c691dfe5805244576ac4ffc44b67cde7d9f891432740ce2c5a791cecb632d99f425cffa1f9df84fa1e48c0c9758fbcb69491023872deab4ef3008c4950d8fa113b5afabfca26fecb1e037df92dc7bc88d23ec9a2e29604c156d40ff0c55e739d847a6148a384aefdc9cacb63d0b92cdfc9ef370c837deff6d3e52b51b58d825b680f56f33ea5feca12585c8d3c3b8fbdab8fd70a9a0f08177e7b883d01a5f4223f5f19a47e9a7299e3d35ec5764b43930fcdd28ef92d1200ebd8964e5ef6eca764d30ed5aa50a79a03c72995b89181d7fe46e873a0e43ae178e352138779b2aa4767cd8434aa36cee38166ba2bc2022820a14b4d74f25982f9229c77d35e4dd61184f36bd2c0a81a5e07dea6aab1f17a0d93a39691949d810961fcc5536bf06d05de6b8e7f184082d405eddd60aa0708542c749c682623bf82b28a4e37bb3b496bf34669a4ce197cbb069b44ad05547bd2d291052ae5f847c264c7cf3cb17980da9fd7bc9f1ee81f67efa05cae42afbe5c4558475f9b4e4d49a4dcce6e2c73460d47baa72de87db81c3a0dea1d30f535f22f8bd99a141987f8e0481c07d82081de5aa5130ec9a8599bddb4b0be5f4c214056b57570acae819fcc0848296334b82b90052ae93afdf27c61d1a8631439be8315bd9b113a27005e4e5d6dd9a14fccffc5bf540820e4fa9176f9919ffb6eef08204279ed4cbb5c48f41ebcb7c67a3e7f0899db27f61e7b719f7c5c3be62904727caa7d479e65791078c211733ba246ac53835f77235661eba876298de53d116fd6b00ada052cd5daa9282b1dbf36d2e3f90e0907e42ee3bae7a389de05025fcac8c1181e290108c9a1367dc65b6ecbfce55b98b0f813a1aa6ce292a93ad53576d40f90e557f34899f87dcbc0fc4bbeed6df5881a74575354eb2d884669c36a688535303e2986928acad48a5f50ccc16712c59bf2f8372f4790244ed14504cfe381ac31d295440efaac11bbd8d304b08759f2e769fe06711648e2a95cbf04bacdff0cd4b20a11173069e22b93940305a0b1f1413177e5ea553cf66b8be0aa59c276f5dd6094d530169c857ae551d37b03cc903fafe6efdaf2e419b4aacc0e77b3f15784182a4d54a92dda16e735d482aab9374ca994510af43708cfab66261c82996bc809653db67599214f33206adb9a121f086593b7cbdc33aeeb2ee0c0b01f9322c585f438067c396f5117f09e1e2d1909fcada740f78963047a3b76170a8550b103d0bb6526e605edd6373eee683a3a3299d7a46efa107e5c773f834c79fb19d3f48264d4fd05e9591e28e00d8f338ddbb79c9f74c08bfcd2f3fe9705962b2ead361c7ea0943153f8af20d24449639c127bc5f219eba1792519fc2ab65d6d9e21a257da4b3609666d34ac48ebe5f9a21dcf3add317b36c4b7deb47f6fd337aca9144786e6e5dfbeb371768008be493b768c45c9bd62bfa4ba813e22b2c1ca3092526afddebaa44b595458777f0314b1446acaf789bd07517520a9924af5e6f98df438ceab2a23b197715b8b766cc3c327d7c04a3e016a09474439cc0a5bfb634a3e4f52d396e86ae56176a070a9305e2f891ba933e04a54ce0cc15ac843dd487629214c6efc8250f179341d1a168697d0edb066882d6117310b86d4e5cf722f8f77a09343d42c6c38eec776263c08c7c36e6ea51168064d4b82d32e93b79b9e0f85933a2737c4d9ab2dd9d9855d297079df72a418227b2ad619d3fad9f1bee11fefa2c7003a9e14df4e412f2ee4bf688467c309b19a1feda38af929e3cc3554d92c317037028937ac55ed1f1b420209657b9dc7e37f93f050327b935f13b76b7358b7c5b6551e6b254972d5615a557fb7d2bf2aa7ebe4825d48fdd0af3ce41471fb26fe76a4a73b02f3da076608d19b7c459d7f0b150a8a117012e7e8576449950f7e34e5a04e68d7ad35fc1ef5e60b3e982fbc9d8b3071eca381fd70b944e2a97695fba8acd5d35b26ace85d98fa084422ba058d30e81803194bd9bbb88a9122cb41385629061afb87dd38aae61502ceba8e062455801e96acae932ca0c45117f7495dad3e36fa2f5facb8b7b72c2e0e46f6815c4d2523bf062d01ff8094b1080d0116c23a5ae87a4d85f08df30abb339b3e5f1ed59326b299c56dc2ef413439299c2fc88952e848b0f6a4cb890c2b0fbf57586cc5afa84396100751ceef7c990e322480c42f5e61209993a1a7c9fb6fed0adc09a65d2886ad98b49b1d7be96ea7d4fd6282ec1401bd9e334f23405ecec30e7d4e03f538e1a2805d12ee7447d08549564ddb7e5903e0687b35a5db79f546d2bc24c7d9f33c492501377f66b8d5306c6e4b2c5433fbe5179c115ba0d14df830cfed8b99bcd7caddd5334bf3d2b50637a2fcc755b6d9751e37743456329b1dfc289f2a49576eb36b763aae2db8a25dddf44cc2fbdcdead812b873ea5515a54634ab624ee2ef419832b47386cc08c1742141da2864a01fbc207d63b2ed443864cf74f35b52df7d08a14cb62f4d58403866acb9261de2179399d425137ff7477b03758f0040e23ff1d207c6cf348c7a7fd6fd0674fe4df07dc5933bd6e3b34997c18bfcb1b2b84b1c2b40bee02ee7406e06ff1978f372ac8ee55eeff7b340c10b88cf02094e92b6d72925dc0290c5455cb8c81703f55cf69d36708eac671f7bdd858cf6f2d3873b2686675b429c7211180ec1ecfe4a0e8a71178c5a89880c5d29f03ac04abe486e9e3e342be5b66f2b56a3b20b1f6f4a57664845875c13b83c26cc349eb3af0bee877c547645cf42b8df7b9cf64ad9ac6387775a93212ccaa8a7d30cffbac4b7ac2ffd74cfa7ef561871f67c9b81eacbbb1b626bb36ea6b982c6736783155f539512ac80cc98d194794a4bf4b98266d77fff5aa7f65b4d5123e0a9bfe63a6573957cd2225159861e2cb932b816ed3e92905dc5825268b6110bddce8b71c548c9e27c758fd64c539cffc87162cfbe698460e3ef381a96fd45513e13e026625574b1f42a5998e8e1f0c9bbf8d7b5252fac7343cc8b9480ac7144fa0aa21ccb2d801314df12aeb8724edd18590633fe7f44546c82a407340abd15f3930a568d8b44621d2f3db19666a3ab4509267c9e8693cea94e1e668de501abe649d132902476a6e353be660540a185d6321b2c37d733d8333bf369d82cf3c03a7f7a3e27c35d9b5a65bbb6fa3fc3a0ef327bb1249dd07c3b432ca8eb4dfb2f123e7d9a837a44c0316b9014a64290dee78e8bcf6344120dc59bd2cf51f9d54c4e25bf5efbe86d0457c8794e76af4bd230902798e5e8eb76711d977cc34a15e78193ff48300c4aea19c03d6a5848f5b6c56ed1f002323495db439763215a8e126d936b1c91710d40019b0d1ceb927d4f7965eea0d0c3a18a08a7375f4984e41f1f87a8b229ee4b1360ba79c81a0801e65a3ddfccb38e5bd891b8844","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
