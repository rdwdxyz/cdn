<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9caf46b8b7d7d1db56002fef5a04e37136ee919e9b487e8ec8fd1bcf2407894fe9d14dc4f571555f06d33539a6f719d4cf0a6e102cda9038b6e2713805fd488afaf15e578919bafa5f9f939764eceb2add54097b9f512633a44cc8468b235fcc685e57ea2abe98bbf6e9c41bfb806255331565f2b778fa0f6ed9eee061221a3b56497bc86f521b247a44196676c3f53bc97c96b7ea5c8e53b75e2e7dbad1d2eec7e30e6d86512bc572d48b2f48ccf6294254e0569404fb7982424106c8344ec158bf6ec728bb1bd2576be2f46ec8632fa896ec424592c65e4b0dadcf3f0a9080065ed7828be7ca72ba80f4873c0320af6cc6f27b9c395be9a33ce94c9b8ed0fd92e159273625a3d3b7a543fde5f15e8bfc1a6406ffd164f8a94dbd373c64cc7e211eb31dcc4a736953b6f2bc0633cb0e4a6a227761ae69272bfb87849cf43f27dc5c3c2d380e0c1bb705f0844c82fe06b94192a01ce96c2091295c79e598cc47c5ec910a789b8a20f80373d6d0d2d270c2cf164c5c8f533198995261d9aa2feaf9d99a725e1c4bdd8ed258a65b4522a5ef2ab527116cb8f7ede8874ac6db59fcc77eb48e635e77c081632db68a454042b5b08e152aa04270d5c63f0d9ef99afd5b002ff05eb80b2d30bf483c2684a3fce87e897c10deb33a7e5eeb7ccaf4585f3fed7463c926998f30380d953022eb3b2d0db57e22f38a2406303907938facafcc96a56279c0ef15eb2412a56a69a5b1c9012102193a004fb7edf7a70c5e98b650891f26747ffb8cec2176c9c57fee33aed9fb06cbe41eeb41510308e3fc29b79c4ebb36049df52292753282c04b5d755c249a86f221d0ab7776054cb2a2696d560e14b761f9094e92b312483a98cbd731feb354d6d187073ed1952baf2f3fee702f153bf2d258d737a376c968ba85c04f791ebcea3be8e5141ce147583d4b0901b566fbbf7cb4579a4a217d82410ab678ddc4e672eba94ea6834a8a5d8aba829a4fa0bea6fc97ca7032240e73312b057595ec3b0470966d2fd6a472f63a0953e04e9c91653a5d4f2e941530276faaec07a6f93cc89c7a0c065dc1d6d7d210e032bb08bb217904d9cbe96dcaafadf55dbf0abe07fcfcd72409e52c91b727670d75977397c6e34a5185af7b9ae1080f60d6a6f5364a13b25ff98cc9d628ae5205d22c34ba452b6531e90f002c945326c128d611f7908715b61e8e43c8af2f67026c0e9d383171d0a5192d3eb5804bed3f58d59830b55cbc8465eef65317dba7372492b435fe1bb998651b380189e7a58ab40501bf87ba422071bb44d3e946b4dd4b72a1ff934da29e4d5a138f94bd96f16d4fba4a7898435f598133969553c075e028d03cdbf58f2e8e13ce975b02eeb821a200cfd9838215b83f71e659ce449a0dccc817c95dbed973305ce75c6437307aca904e9332660cb41312744830b10f9b943c57b35db7a29b0e499480e2772e6c88d384ba4fe5407c2b4198be096c5f992b793b525d043d01fd87ed0c0234f656ff553ef3675b6bb0b2f1fc508feae6ad9939f3217440304f30d8d2da22a80953cb341e24fb2bb879484aba7a73ff8774ea4d5ca4a0eec06994260fb48e73a1a3005a9e28614bae1d9ee5fb41fe3639b8837dffc62690e2d71f2e924dd57ce18393f64b1388ecd432ad7916a2dcd5fcc85c70fa9ea5f7593f82bcc7bb01b83306cd1298a3869b67ead93f61cbbd8bd4bb093d001e81a4cac4226e4b965a7931f10c2e064e90e92743d329983ad11f5c451eb31258a57cf3654a8c77b12b769964fd4db47cc65a9cfdb87c79e0fb2fce1aa66b521ca3dd0d86d6459c3b3967021ef415202ef008784502ae9af3e336d69f73d7bfa652f0a03e1cd6ec70318f390ba72a94440001cb12e61df5be8dece4471ac5bc529cd88542c94b191bb187c78908c7d97d099e7ed70f529eb4959024b5a689da4ca1b78be5569f73ca46d1f9f4cf8dee33e9102af53f0aebf7374bee25e8f1392bc39171452c3c1559406e09229321a30d320f2dc0396c8bf80ee5c446d326abcbcbc1028da45a2453edc62f550b7f7191eaf0b850b745400740e2ddea5523cbd585a59727dbc98de84b8fef717382ced7e65af640c203a6a2cb4b5c139866b3304fabd3ae53dad9c156d1b93cefb7e8f019bf0b744ba0e8f8d3e79166f34e207b930f5d387378e3ffe78ebac8e0ae0e406448371a8795af9d130cab6f04b9328bc31c0938c7123ecd4d785fb2ed270005be6a069bc1634584b0c2add2f4ef713821dce410d0dea3453fad7d59f28c2928c380c10652fd6bcc68f5956263d5ae1ecd5070a546f34c9f40a3400b3e67d494e9781e4fb9a5a21290e5e0b81ea8fc6bcc5f315f05879a10402311c28725a0a3c3828620e808935f9c19fa8ed8cc28a2e1e9c0157514bcc6953dc979bc6eef8d6e69c0a9886e52dab4dc39aa91ecd712ccc71e57ff067a2f72d2bb4846016e0cd27a6ba1585fed4984815097ceafe09d3b450f3386b96922c3833b118f69c4d4f4b2a8f43a2986156eb99648cdf9e19613a735fa0b6d79718f65d950b59a10567a7af37c1ed3218df32519c77e4dc0d0c9e1a60a12eb53eaca2ae75289078897333f8ca42fa4963c055d73fa283ecae10a036a75455cf5747d2869cfe83dd4db9431bc8e8a896313b91b416f88d0953f35a65963f82112b5edd80b8b8f080a5673224ffe9a9e5c748ba586c24e27fb57838b9a7f0d6fa3d2077186b80e2535880c09ef59add6a01027ac03e98a0afaf0a5da6284cdfe1e6d27c7bf899c0447b5255e9357a9bca4cf22f8c33296513bd63bb090baa20f2acac26d9b16c6c08a65e3e0a28b33b6a2d4542cfbbdef01c688731b08f1027a455893674fa5ee0be8e343171fb4ee5c3bfc00220d109f61fe4a6be16a4bb08ec07e97fab2c257993c9d3afefa6a3d87102d411d7c817d4101413cc1792162035a385214711d949057360570190b6949951d9545057f7a96a1bf39eae10ccb0bd6308709474313690048a88d2fa9f57f3f0087c2ce16265c75a0a1f340cc66ce838c6c810ad7c73794cf40add4fb18332ed9e083630edff8f2dc0712f923548a537e8ed54136aff38199a06c61856d4dafac27395db2c5bac32959aa08f351b3d0123d069252cf11292161d7474229f98bdf4ed774c74f3894ccf3013fed15af680d135b8a2bffc94f9c0bf9a9b841c2b9919f9822d14175419be3ee05812b76c7171569cf79610dee90eef06df609d825b283a9704ab15fd18defe56fa93aef20b15760f03fff1cd162413fa2c79ecd8f19e5ac1afb6ba03810f27a613a90b414758d4812f8a8ce3ccccbf0d7df3f325e44dd14277a5c3813bd9aa2a655bd03739030fb40fe74228645726cbfd0a39c9579c7d9018b62d35dee02ae14bc6148ed36ad7614ee702fda4181a96e780c9d9ffc27c5a3050b0976852c64a0c3439282b6d7edb19471fc03427327497204167a5a95911a7446721ff9451cda5a8ce2259e815d874eb9ae62222763e003ea04960787c783b0fcd59ab80142f040ee841428ba19082e66ebf559db0948af3e1fdca96e202d07404720dc07da82ee255c424ff63f4b44b92e268fdc5f8e1de37975b68ca4145bf626e13da5b7f88afce5721fcbd5d542b1caf67a4863d220fb1c62a2569c1659560b0a14b4a3908b78c8646e8bab16b601becb299332516820075ccfd32a1e2c572acdc3b338ce2fa080a5a4a31b488ff99732b3e08c86e3d1e80b2a4606c254483ad5421cafd222dfeb97cd039f2a666229bdcdd5839648e4448b97cc258d4ed04b4e1063bbf62df00ccadc6dbd7aae32e3ca085c80505c3467458ef186a39a8edc3c8e9f00d7709ffb7855113af6a78477ce16fe0c2ac85aa8016c43ac02974ffdf6d71dbabe362f1b7fa23d2bc9986958690a78860c06227a2c3fd5a0c6afc32e1d45cb389c4e9070b243d7168fe5fcb45e683139d78da7a08590246bca24ce2040dd91ed12c03681b6dfa10b53d48a98c75b8357eab2adfb3c6521586511db72d06e96571b0990324e910ccd954c1fdda05bbbc9a88859e6f3c857618e1a601b50bd25fe34679d2c6127fa6c2fadd71bd2876d6d90df0b03354b1151d66964fc555e42376bb83d394a89da50cf8df2c63634d7753564a831f173eacc5fa62dedeb02cbf19fdd8ba0049d4812a22522df351d5dcaf0c551496c79b88c0623a4389ff1d7f793b4d976a10f33cf9c824d91b4622b5b19f50349dc30fc381370a78069a899344ec261c405dcf28480220a53bf2727bcc173b1e63e31373c407dfb918ce294221428300e61226dd86bce0c76e8c8a80bc2d8e9c942c369321eac898d8c1b58b679c45fbb534a63fa8ea276dcbe8f0f6487fb6791760f44d7008276f1697498c57add3fe1090dc281f27682e46789c7f3cb5cb7a470ceaf97396ebe27f619412fb58e3d6bb42562fbc9519e363be8aa9391c11aba60a432320bd4016b6f2bbede60d3d4e5264e1d5b029c645b232724da65ab75d4f3bb39aa3244067310f1ebd52b5b41465f9e08d44e5922f1fade4aa5b369229af26ba3628b27bb27b4c9de315e5f089587b686591b60e8ffa57b6ddc3c2b2bdd4dc31228d16c258669004f7b18cce0f848de1e6c189d5e93935bb9c3012db5b402828aff650389c125e11f9b3a0a7c4bc104c9c97ce74bf29195ad7c8839ec5b8213d4be008a17edd816956f573a90dedbd88fcc06752d1b8e5a80e9975c63db2ee1170574e583bf9344efcd6d56b79629d8a20774e45cbf34bff1d3268b5f23b6d50f984900d531530272d33c8c9858ce0cba90da8197644a09ca9543242d6d5aaa0ac913cecfce65d33107440b22702ba62f5aa9465ead34bf808d164d25545758c1ab50eb750ea9ddb612b1cbf826d6b8d95407e079389a909ee9bbd4d232c855acd5b98b233b99f1b56301f6125c6bfe909332f80852b3b85ecc852b7f6cf0aae90128d0c8184fa5d039687fc9e25a313972f9d6f278f791ba7d27481bee3f5f6d06da29d98e71ba2cd793f4b28c7ddba67f4effedb95bf7b118bd75cf789110a47605088affb2f0098d78f4dcbc9cf87721ab6e7cb4f2b3a3499c8b85761fa8cb242871eb9fc78c30bb8869782af7a92979159f2ee981b54547d0f4bf70b00db27014c0dbe3e3379159b8cf359cc70bd2b63769d27ba8626b8922684e260a15160b93caac97966e5f0582ff19c11de45373907758601e81433a90b4bcb2a897faee141d34cd221d34eca0e31fa120266911c5285387a3584dbe1ec011ccd16cfaa2317b5926af11eedc6fcd0b85de5a3a51e6fe8e7906938a220eb94431ca5adc6271e0a428c36706dd1bcf738c0d7c77ae5f05e2dec8f80525642cd95498f00440f4ec651a5166968367fbf80314a2d5a6de8ebd97a0958caa61a13b8dc407b4d222ce8d1d82210cc9fe24908ee3c86b86941b6be6a06ee99afcd4f81376ab4018f66bed8a1ef10c9ac1d58cb4a98c6ae6c8e8fc9654d63ed172f1ab4e72df0fb0b59a0a14b6123ea61c5b84ed6ef1b5b9927425eac2491a46fa8ac0290c2f0f6cb1229985a04d4be640f65af1e3c68d9ec2b68dbb899acde7d61e0d22e6e3ccbd503c7fd37239232f607a41c728dfe5b6fc3c2bf85a0c0485573da7fe8220e2cd58b450c0d8177e34be592ba96cd9547efb1fe2a9487f50c6ee90e29e2f3ec87989dc3e68e3c794d2ea50bc2cc2e3fe47b74879268ea00ae830c57289aef25c7e49e808222d603ba0f0d9d1ab8a07acb6a9b215d895eb6062a7d7e5fe86dd20db93b7b1551081243dda110846a1df8c736f79c8e3175aac81115302820b9b1111dfa8c435928a9025ac97277dc24fede13e5d7f102a76e2fcc0bd4441c535744ae38149a5eda0debc8dc3ab27dee7d58b77d280a43cf99d133ae5cb9fb8d012a7109b526eae3ef667ffc9d5f9752fdf8de0a68dea0ae70c3215dce8baee648b311176d0d1364fde479d52e3a6b85fe650bd8d22f41e225d39238c3f0f83de8b51f97def2a23d62334059b1d5a71b15a38903445e0f529a98534b6e74e385c994f4000629b6bb1bc6e533e5f0067f9a201a6634cf23ade8866f1205865c20d1e795cb170e9b4fa56599df14d4b58f097b97c893424823ed0b9c8ae7c130e36d7aabc0e8cb2c4eadde521f4cf6870d3806834383de27d4a807a3fa6f36115a61833cc8d1596c05f5fe98b39b7a22557624b93ce983bf5c2df4d74bd33067aeb1139f6fcb06c3363fe59ba1b99cdcf00629991819a719916d1cd04ae1c2dce4cbf4c91620d721bf844a5c5b1bb9771f19af5ea5b68bd99de020ba81dec8fce045c93dce8d24330510c8b0a9451c9d95d5af63ae42abcdbc686bb49a22c3246f474d1bc7e394dd522674b54ee373b735415e25e3642d8e2ea9174c867c4435cc7951e0fbd7624531caf97dc9a5928eb3faae662a62fef80c0d37905d063664799c0fe3a644eec9cf6acc6b0184df61714565031f3dbe3c1b48eb8d302f881e874ecaa8cd26641dfb16b8a52c0f346cafde594b2fb7163abd1c599b805c6c330b34e982dd9d46477bec719412f75f9e2041014ece1616191ce518ed5c8667a8f0de4d50b66ebc3a50e460324878899b6d11a8c40fa60018a3e8a1456257b99d6e32fc141e8a08a5879f8c1f99ab0ecc17809794a517a209cbf38a2ed955c936017cec9dc596586bc747274d2bf50a8d105a0ab814ff7ea8be90cac5099d469dc3725745ab108ab336bbff395735b014f0f9157eaca360c59d826eeb88bab4adfc458964625bc60a5258ca542265cd645718727f906b9fa35805faec9d6157515433e9e04721b50cf1c6ab3149b3fcda663bffd636e3dd587db74ae9dc69a3b6e4e6d6131afef573397df3082137d6cf2abfc7395a874d55990a80c7bcd1270230d12f3b2a18bc99120f67300e5591b529a25fca4d7a5fa2a01526988ded1db5e65af6e440293c7479cb6961315049bf195b341be7326c1d9aade7f3bd5f6901a59e31300efe80a38d6113873537c180063df69df1beb9eef5827e126880c2d139a08456b261dd8b4c1ed89e5a287ac6090e9349398e4380965970c75b4a872c7478814d62e7ea8a732f135474aa20f1ababfcb878f6fc94ffe7cca5138fc35703705eff72ffeb119733c0a444bc24d369e0f99122a324bfae6efedfe6dc4acef4b79d389eef023f1da61e8ce2bfab584d65fb8732c2c839bc45cc43865b909fde8bb4e6f053f60464b94f0de2b0a59dca77668876db08eef0f47f565c67ba26cc42288349ced60c5ea3484f26fb7c2ecb06440cb97880b261a2b1d9c18adf1623491ebc35fb885ae165de9e5fb6d8931aecaea71a60eefa19f9b77f0952d67fcb83d6b7381c716579c12b2f8a755af13d8f869804a34fdc7377f0ae554cfb7f178746d6334e82842a324759aacd2c87446325b1400f24342a0b476fc2ac167e7aec413af55ac5e58efb78546d6cf149f62aa6f64b3f5af6bfd1bfcffdb15b9042b94d6337ba6d3ebd80c7e84ac2c488b14e7d73ad58f4972ba9fadd9467c5739484db927900d87503c66d00a02e28e1c5f47822d748e55f01b1d342b2f0473da2aaa0137bcd1df9c94bb041a110541253326c39cd73c7ac8a00edb6b4e6f612f0a241936c61fa5d0b7e7dd22e42e42910f14f48398f7eb73e8dce95e03544c4354ab91a5658cd90ea365f829994aa9a9af63d67cc216b867b8cb0448e5b05c6dd1c9a71c46c10b05e2d3b78183fc7ca1ed705d141d669bfb76b9420091adbd08a30d2d0f418e905037a61c5a76b2710a0f2d2221536c69e071514c9ebafe674c9835bbbb47ce67c71cfd51b6581ae3c4a015745acde1c0b0d126332d80b6d8b8e09fb794b1d0b807d2b4fbea0da738694865613c5bc3d50a6656f59a9ffe7736a28b18de1416afc0e96b3778ef26e4a7db5c22280020b1227b404dee97c8439f0398cd4c22ad371aabc16ce976711e3c127e0013d8a24560f80ed39b2b0de2a0494be6ec7b218cd7cb1ec35b0b2ccdc8151a812009a4be14e2dac3703a8097bc68de8504d6c9715cea8b128d0c0799587aeed196d5e80ebba6df7b35e24782df1dfbeae61137340a5b206c05832e0f0d7589182ae7be57df57053e627eb588fd5418894e66fd72d321b55db7aa31e7e2a1a1a0b2416c016d0b264c757f641d4cead89329316e9f46e4ae64fd53ae8145e669621c793a1acbbf4b7e1e09057e7c7141af499575e11fbe7d8e1e68bf55adff01c1fa39353b778ff693892e3f5701b9f86818d7d099112c5bd180b5299024e7d7c2f53e36ee8f75f2bb836b962024ea215e39baaa811a8e2144ba85392d237ac2f33841faae7be8a2cae49c3bede0568ad2ba547a34b92c18bef1eb56b1cc0bef3add61bd60d354b79a148e336c0486a2abf5e3094c43e5bab934e239a56c0006901b9cc495118f857ea2aef7bd6811adb01ebea5f45c1129a0a35e73299045bc8c18146c55e3ad763ae4dce347dfec6e8c50b26c16f49ba939192c994dbcd403bb9713844afd0e97de0cddfda37ff54ae3093e255d4d1232d2016c89cd2403259b279b66336fddf69613b632f08f7315dcc7e66269fd6c42ee7638c990f25db6027390de863d9b2d6f2e63f352f48529d8ba842460c31017772ee8c5383a46bdeef5693b8abe59a18518b92eff635ed3d027007ffbfbce0da2746a2e623727abf80fba916eb46b21e883f8b6e3202091decb8671debfb7f14a354879988e31b602f7be331267e7d91b09de9afe3c4a1ab0b9c8502849c3fc05ece943e82f53ec257f2f03143fe3411c0031fc1e6df734995b64a4e10c6f7c9115c5380b447543423f40b9f29d460c3a275f6a142a413da95468e07e7201980994e1153dab3cb5de52df9aa1249ac071d9f6545c6d4e00c536db6b627d12016d376274b17fa503a651bbd8dbd5dc12897141319034f04680365f2e618c25b993b9b738c20c1b6ab61d20456d04a49752851dffd999d5d015f9032f3312844f86d33b37138b7641ced3b90ba86256e464c349b08d3e01332e7760089a76231eea6021b34a5d854462648250b983c7cb66815647e2d5abcc7e922ab1a49d18b064d156be432d83705b14e2a0b2e94c2c33f04fc2248e0f54dc8068a1e66948a16f1e6b0bd155078cd2656cd0fe96a25db3d90f57af95c7db6f1666faf7149ea3f602b067e751dbfd82680f8ba80b24b16b47c3349dc1fd30b6dbf4a5883f1bcaa8d38410a31bc79b8912b85484223710b4f574076e4f1a20bd2d678875fbc41abf96e726181d78a6af7437f1a4d0c761eef44f921d2cddc44c84cb3107e6560b1d52f99421bf5500e208d76ef45ec86223e00278d9ea4d9475e2209fe226960a2c8145a98f4e591ec6b6a6610a1367836e8fa8805c7afcc3e6e6bcebe2a3ca2986e75859989fd21bc779f16e0db2f1ccf6c6925d19adae24944343c3186aefe604b464cd374fdfb2bc4131fc660dee9b63b5afca412686d76a394c8f24ff949dda82f6bcd8ec67ab4bf8cb8bfa5a7694b8da382e2e330b616184a81cea07a249f465deacc23b26f5f3f3205dce9050c4127ffe6c1673061330c9daab3a8fd10aa1ce3f7d235263186f2e55118fb30ee97b4746a93807a304710bc2f272411dfc02d767dc6834db59217a4db1cb85899494c9fbaa2b41ed4e4f1e74a82eed4b5ff5ac21d5fd4dc0201abffc04a67e13a8ac027161b8f6410e296ab128f21818e025641fbd2def786ee2b51011ed3c84eec421d2a29094d657e16a7922246a15a37478955cf65786af603bd0f3d50cce3e19570e7b538dca8a821453abead774eccb0b2d67646246385927eb867905cdeb0d379825984bc74b287fc3456541153454dc3181a9c4728d71c14ac43a71a6089073941cffa65036f91409ddc539741815625cb1da3ce5ef4ef73018144b7906b558c982f1ab2669460f8b7f24b0d238a1f3e86a3ec2583e13499e6c26b36743102fc5d331bd32dbfc9511e9e5ee90bbbac945a78a294cf46b594ce4ece0813cd5cba01835346b65fb6ecccbb33095ba3d1a7f5c2f2b642826cba5cac9db38441b1be7e6bf47c17c0a56d8af61f6493d38ed3c6938305c5758fff5c13ab5ef2e203408fb6ce15cc3c76a5f878147b96b8bbd85eb40b26618ac20319a732163682c436b68399c872c9c0e142129d69573ff774ebd20a4d78f79ef87177012a37bcb88a2a1d982a37b7a7719086108f805e1549d7e90cd44514c664f582e4433f5f2f1d4cffd4ebf575b8585bf844435bb6f4944202a83614ae65d4f6910475fced364b50beda5832bfd5556c707d720cca0ab905f6e93bcbfd35f1ac1ad50256a494d972c993e2124590c1104404cf78abd85945ca978844769d744b8e15e1f235dd5600fd76242aa6cab9c27cd8fe9af16ddbbbad2b7179b439cd7b8f35e753610d19e1e5aec398ec9843b165bace61d9daf9a5b9ec2a02bb94e494102f68770315aa4c02083789d000582ea31ee84926ee11a98ca0ccf57251586d59cb0070e9aac519d218b3899f2270c8a8cb555c3dab16d81d23b64b4bd7cf08d412f5424fd8a0d30970a138379ae8dd60c55596c1fcc236284508a0b9dc710169f7f06320aad7425507146be1afeec20cbe1794fda9a601eabbc0663971e4a39775607bfc98982e555ed1f2698ad96ac3449e27cbb425243a07005bced790f521fa54005efc93c14cbecdfb0ce8b1ebab28f5d368f822ac3ec57b0f2f4f8cf57b81b8af2f92cb2c04185d15e5d3f88a98e291ea0aa70bdd6ed137ae36ac1a9e10d5d7e1167b8af60b0a944394da99c582bdc121f4d7ee40e2fb3d2cd1aedf538da6933570c81735a24c73d20324c4460c739563b2425f7a9a7f56e1c1bb8b0208ab0ed05adde1581fdfb1d70a3115c57ea9e615f3841a5e6d6b39c513a62de37c74b184183e49204d35240b600392cd18ff90dd8e0c3f2b0738f19d948002929b616e8e6029d73f580528ad750205a00a187b93bc2417cc1b3bb587a6a3985e3b4149209ea6341f5f02a46d8125d60f042f86cf84ba467da7543750c645d2e2029a3119a6c7f4b30374cd126cb2a74031975bdefc2146eccc2f51e5a3b90f8ccabd85ef9b667600ea489a34fd4a845f55defd97a9a6b19c768d91e633effab20405381697086c768961475015b228860712f2777862a9db40e358b3e784a1078fc37dabdd647c8c5d4a74ecb6cae389f711a4bd7ada5f25fff1d11ff2e55c98e22369c78f9b7e7e25062ee1f8fab2ac1e4553eb1f00d41e697b2f61bad9a45efdba67fe221f4c8baae9a1088a4fd0c5a2f93b63c4dfea5e7cdee6a69522051cf0589745594fd31c8d48df0516bd366c43d203ee669e16fb9ac867f1ddfbfeef83d0d8770e5529ee6074bc987ac7256a9bafdfe885e2288027d54d825089aa2fe3c06f1b73cd0d8e371cb3d1530b17bd00df74d1d174b6010527318507de85ace45f2cad3286924119e66bb1a3e4e93493ef82c57a274d137470bec8f203047e361e33bb6c63c433938285ebad94028f451f91aaa1cb55d3701be132558fa5f2aab5e78d3bc34f95a1b64698afa76509d5305c58e342f9f0dee4c5bd7b19793e02e5d12741aeb14c663df4c575a8c1cc331b30f21c56828728d7ab60c63cba1d365cbd83caed3cad3e65627855fa20f8f78f1ebb81d0a693960fddb9b3e2a01af652d3f0f230787c93db242a89bd6ca1142bcd1f505dfe4f77436cad7101310ccbd82774717d168d5d38fb24c14fc1373262679507e6e909ca1209f2eb3f93cf9b751f7ab05d10d5372a78355f7e500606acc02f63ddbaa80f863ce2524280e9dd2101e1c83829433e11efdc9809b123d7a417323514cd00c03bb240f97fb869fd92a2453279e96e5fd8fe8df7e856b6da6a1ae211b2cbd715a30a7ac7452eec8e8bc1542088a624a5bb5209cd10f9abf2dd7886e755f3fbcffe6db814de3f34356c3a5662b2e871cbbf8d8fc3434c51b24924f937e81562c48d88d035297ac79696c77a3a224c7843ce5f1ef9f4d5253bbd0d506494cc0206ceae7697ccd2ef64b98f9810ac23ad36c7a96c2e8642d78dba90d4f5f1bac8d370f1be1ded4b40626f161be492abbb37d842160f38deb92838227c8234c8cee68b41b54eed7a838c2c867327c60941145d0f87972384728ef5db0b514fb786d33672926f1ccefbe446468e6e5b11b557ab8c8649d70636b4a47ef96d33fa5d872be0f2b4656c11e3fa17e2c0dea64dcfd9aecc042708628e650d2c239ca8954e56e7936ce457f74186fcb4dae26097958f6a5252f7e565dbe07617e29d7451cb6ae048c1ad593570066ce0f91aa007d465bed02ec5f9bb76066d95da6a1bd324b0bcc6b10cac5840e2765b09b701e9e049ebda4a5812762616d5f2e7112d942d3b7363aef046c5ed755f9ffa69ea9470c6a4c13b80a3d7a04f2fada06048a9e0e514a615cee867d44b328b8fff98fe4addc4529e11185794fe7b699af69c23f2417a0048cf360de3b2d55068a8b9900313e8d979b278f26d9d674b4989cc2a5d2ab8ab08a96965548bfc535cd0f5ea683f73e2b52c21df8f9b0fe77372676a2ac51b2e57a51b4f4500476ee9cffcd17c2db34e0d71ffe193c3f1f520ff9b846c34ae3f00099eec57240028c914a0eec84a46559df52b771deabe2b540641fd9754f6f182d76d7eda1be8af3d423aa423ded84eeb26e0a1725acc95c084b8d7446dc96d3db878ff427d15a98b78dc81bfe76cae29e97cf653a978895402e27c1edc0fd2afcb7f999dfab7d7989ee2a359c5c8fc65846147fa5512a0269ce11f94a4626f3af42b2289d3902770791884891b1b29028c181b4db4d184ced4532a9824b8aacdadc51f4b773fc3d29f9afeb822bbcd332d6ba58b452f7b4fd02c526def8bc14df622f05e9d6c48545458723963a11588954aaa27512f3d85ed59c4ec88db5a1f6999e1a549e3be70dd1b94a1aba41e89ed4870a4362c89d7d7580e9599f06fa8de40570299f145ce300776518d49931e20f86dc05bfd98c95ea20ab6be6a485d2ea461ae1791e35a6dc90f3d9c86c6c792a51b6c7505dd8b1a5a7626c12914a90ab2167cb07cc9ee19b258f6794487b072ea65208fe2f1413da1cfd50757bc4899e8a84159154596a0b036511fa552dd56cd4e0f3111af326c6166bdb0ce3a02908b3f9a61ed6698e9a8c7934891596dd1759baa3c8b5a11bcca2794639823946efb1b109076251d7e530c1712dd7f2faadc97ec36338c9a6f983972a9e5cd2c85bd0d1815d03381244221105ebc68826dd3d4ce33a0c0727ac02010deef9d9e0e283139ace085f2af549ca0972d826d2a368066f8dc5b37e60adc385b8090955543d3dcfc9e0ef2c484935e986f9f21c5752cb8d6961f584e2ef3d3c8e78d9f932aa4b1c1a1a650a06e3cdd0d539ea757ca3cc19d1b08eb4f6029e8244678e372dbfcb27a2cce0237fdb5b87321a2b1de1a6eced283ed4019aec57051bd95afef3f765b0e706b061451a3e342f03174f6d8a58382503755a5a327b137d85e673a24593338cce99739760bf9a20f6a3ec8592047c41a8543bc1e4f3242882972aeffc6329a9539fb5cf2d727b8ef7fd283ccd303f4c209ea59b8faa6c770263d341c431a0a45b6695b28da1baf8b2710f7d6cb6865c78e0a0dd2cb319a62537fdaa6080f4b2f36f77424e971397619883547f009641b1482ea5c54891cc15ad322b860a33d2a68fe2ce6252c5eff64d4fe0aced11c0909d25275263327f8f64beaf7ec255a76547d790d33b4ea3c3b50f850e763ad4d23330a8524b1a9f675076c5270e54e218ed32030ba8fc459973bfb23c90934eeb7c587367fd9e09ba029c95f1d01083077a75f5f3396c881ae91d20b16473214a5ebeaad4707375f47f53710ecc8517c51259501744a6e3cd9f071468b090a77bea9c9531e77aede6f33aad45b0794b7890fd5a3078dd20bb0f187f521851f3aa852b2914096ffd4b4e9597cb6c1f579f4268e04512bfd46ee87146ef2bf2d4fedf250f94545fc24e639e082bf0ff6bac63d890e2773326182754bc6b013136b305332413962a1a473cbfbdc5bb5a1baf3439ec4c7722879e0e12f1fce1cfd5491f9819690b09c9553d45a7494a9d505e4866e95d475a017e4a8185889aba9c3ba6860c3e385e73d38fd9d816594604b4f4f824a5b162006475c9cdfb012664472f832cd9a65746dc5932f17eea0616bdd79d1fe6dbac22a373d923bfb895e30d7f9dce0a70c0db98ed3e9c2b1e77c428cb1de92f6397d0ba576dc1b49521cfc52f1cc1e55fc896e37661e46c2418ed873f0407d6cfe47fb5ca7e9750375086ca35ec537da27ccd88843964aeab9f85703c27a9f359b5cb59cc33276cc9123f6f13ffef692966b4d9c8ef63a4660f6761864ff3264796f438b3b73a4dfd38688ea3d900e7240563882904222c19adb1ffc8b191a939cabd3403bc86c223ea3aed6a19df47d4e9eaa20252a09301a3c4b943314baaebd4e7bd7ea72f9fb83b277921d2875143b425f3fa6f76014b7b15e209d89385c73a2242a1a04d03986a1b666f5a8b813e298945d3fb3ba9eb209ca9130b0cd45ae998085d340f7a25f9db047af088ca9afe25d22d7fdb70c9afae1a68b34a6b10588ed2edaf02ff31bf689d021e5c692b537ec2ecde838e38ec307a541dc60899f9ff7e314c8c7bb76ff80b49278cdf7dbb5dd58b79bd35ad444b759a9041592305097c8e96011d33559fd727ab6f48580e8e07838f5035aa610bb37262e3d841f18f417f87ee522aba16d5dc931f20f30a7a2520c7286f9c82ac04caf60dbebd8d8444c5f435b0832926e28cd8772ab2ef2cd195ab4be81254c1e0344d698a0909e5ae1c28f05536d80d4d529892880b427ceceb0353076df1b7067dbfd300eb497f784dc62c28bfedd2e6955c73de87c60569ff8c1faafedd747ad7b5b8d0cfc87a63828eea290c4a622cdc593f4d431c07ee5adcdcb5f5032fd786f44862af670f4d98e50c491e510f0f96390a3195f2850917f95edb719b20bd2b5ea1df87d6cfc38be15bd882aa7425b4bfab688a2fef04e3f6ceb166bafbc92fee07242126614744f24c37ca9194992fdbf6f4b86d6982fefec46dd5cfbce806c2cbe546e2c42cfa7c26c49e5d1192f17184b8d263c1c6cccc4f8dc723cd9ee20ed8a32a1fbfca795fccdf1c75fe2dd4c1f98f5dd639e12e9e3c8f170afa2351387dd752abd2694d10f354be3f1d7b109dde2ef03c1fd5ed57c6d47fadddfb983fe1fed799f24f12b89c8db70f8276595c45dd7db2951790b4ed4f02030c93002f1e2934d751d476ee38c7861b25c0c4ee11c219e54edb00cc7ee04d0a3bdd18800a2b9388c09bcd67395f6cb059dd8fd729f01fe85b986627533bd4010c9f7b20b1bfe2566707fad1c5f283fc7ca5b5235db390013c0bd160c1ac551d2af6a29c691405c36dc4a68c5126c69defe2182768d9d8ad0e7cbccca1617a67c5c5c8ef5974df34d66bc5f6c993087d4af7d7bd4d2121d2de6f31454b4f41f2f78ff817a293f7ba4c943c59f1b122968bd5dc03700d3ddf9f8ff619860bc7ae12b3914d6e7c86a2573e111d1f319aff071e82a23c14002ca21252531c31d6c60e62493cbd140674bf6a59ae91ab63d547a78b5dda3d4463a7ba1b7d2bf88ce3065043c98298161ce7db11d5e0ccef88d6f6be92604034f39c8b8b9780ac22fe5dd95b6253ddf2cbe67642a1f35fe221b808c19c31ce3d7ddf69d32f2d50e3e867a1ca34207fd31f0666c10a2b163a22a4f033b9fcbe4d45f16c7b374b807be1ab3b227369da1f059ceca6de8c364aa6329b276a86bd3046679030b1e240904097598f16902c06d3ff494f1b100977d3cff780eb8f3330801c50763ff1ab954a3f3d2e2252d9abe767eb17d6939fcab02af8298a7d95692b8520d5f26c4d539fd942fe760d5a1b523473995c69ba6ee9405037a1d803d8a8fcc0a42a5eac8f638073d647305c5f491a8e0ccddb31c157cb5506d7fd64cf05aa2794df493526f71b93e190577bd412a487c64b83f28c84142edb87a37d2c5c6c221b2a796ccd68ad33da4a3002cfb3d167b28f4c3a84fac4c962f22523d6eef03ef37278031cfc3b89374c3b05358f1208e536cb8921a27540daa3c468912a3f8fda1d021ee54b0aa5844337ad9c782a0cbf768713c81703e3ef8983dbea5c9a8e18e89c69a91994c9c8498b2c5987de904a637f8226018a3fc913c861800475d8d4526f22b0244549ae490bfb7ae99e591180630c81da99ba79e1f625f33de6c983da2fda8f558e30377d10710ab1aef2daf3ae934724cee9e148b02e7c1b908e3c1fcf69d16f9139f0ca25d3563b34c7c1a3f3c3ecdb4ace04dcb82af882e84be28c405135bd44fc1b0518df244acdff71f87e3b99f82bfcf15a4ea085be250ca2231711035a62f39ee5014ae7b9b1003c3a0513157ad7f72c63b11c8d3b47a1531cb608b8376bd0058b05f1fe77912352314faaf437428118170c1f08704b46824d89b6a289cc1abed9bd5b8f6105b49541543fc34f928d2f21807872825c338f29d4118c7fbeaff0ffb1728f92a138a550e95a63d91372d695d03ef8700eef2bd1499e64b83cb69357840d0bddd78cf15a6dbe7f9c56267478872525c28b1854619e8f34463659c0d2e1ad96821d6c7c18903e77e3148fb81e3f8d854c48eb8bafed05e3311befa95a37b4f6ce78477254011d5839c57e2a4ab8ed28cbac20d5cc5a6c895264791a983c82a8202af03936f15e763d0aa3b2443102632e9d79b16ee29b774791d49772045680e35077cfabd49d36e7d09e5d986ce75757136923f5ee215d992ab831969f2750cb8f7d108252c8232c5d8e7308c77ed333a6c967031215102e9ac26d5e9486f8a20d904f879917ed764d7add62df3387c365f013fb980ee69fe81358390d1c99a040060f077464408fca98120061f2860d88de31e68badb0df0d023dd1d598e24a2f1002897c16e0536240cbd3ff23b7d15223bb7dec89bec32251ed8482726b6f71302c615f5fd02b35b13f5610b118bc0b300ec6c2f3ed6bdff4ed73ba0b0e6ef91ac0950b3093ed7f308f02c824ef1ee974f75a8d37acf8040b34c25aa4fe0085d15be5b988f5c3e977a5329f7195c1dadc44d11bdfd0d4b8682fc25ef328455e7c45f385975f339a492e9e3cff31dd314f0613923b2b283f579b416fa20fb0efda3578d0b98916972e3cd31d57b316c0f3be144d096bbf7b43cf43537c6fddc6875aba2ed23e711e4daa2c25365f6f6fcf3129ddf95c877249c58e5e11339cc2d772cca46dc847f6893add87a71f5f3e0fbf4d3dab44f71b5bd0638f603528fa803f80e6cf8a92a466a0ba96586b296c0247c13b7debc2fd124eebc793f5c496391e9c4ceb078a177b7b20931c7c6b03406e747fc11077838afcc512490bd29976cd69589f30a939d0c5a254f0357f581514f7036ef918590af944378ed8b693f352b9c7fb1d613296d9615bb98a1048f289f293618b95cf6a9e5b41b88a7a53cefe09b08cc2313bd96b904d5fee6fbddff05569593874122d8d90a4e323ebb021a3dd6f1d71068e254e12c631d8c072e0c8a1c7a77cb1e71864f4cc747676643f37f29e24c7502034baeb638e15590e4855b4af0e0e8fc159f3ae8aac730ab6dadc9229da5c0d93dc7943d597d3116a8549a63531907f285ed20a998c74b8d097a8382b376f52e0ab8ffe43b81f42343484e515e02fcd5e2011f1e58ff2c5522241cff5c28ba9996455b2d86ccc3618a963db2a86ba6866ff8b05a2b29839dc45af1496c0a12a9d64195f1ee577daaf855c8427a82d067ede832f8aabd63db1194b21e2127c3cdd6ce19a0fe59fe5b0cef0c4a733aa4ff32e3f7861af57dcbd6eeea4572bb9524dea4cdec95a6451e1d1d8575339f65d8b491026f3a586c3b5aaa0f7e1fbf86cb9e2f01e52c7e4467b4f7ae3c7e602df2d875b978ba7542ef5d8208e7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
