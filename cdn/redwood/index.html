<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74f4608b797480cbaba8af040a49a1a340475a054596e16c9339332b4dfc1ed6a0b500caa30bbc8b117f73b7b76db2e6758aaa130151099400307d3e113ed7ed109b0fa97b51a4b27fa330e49e8240dce004ce545b1f8047a4e4024147701c9736e3ed6bf504ee639e3bbc5f8b43151bbfc653f7a0cbff35818d8c38f24635c04d49aa9b2fe81f64c5c07a2bb2364ff443ebdf6ce3e99e2d7ddbc1f38233dfb9aa3b5949a627397a761a9a8858288e39f098ba823aa1e0a48270e302b47f32d8c250c3024aadec365a8f15ee78423d559a621d8ec7eb48e5d18d771beedc7c4a5727f3225013f9a864d28affa60ca92ebc2df4e2da1a6ae585d67d3f9f4ea6ca68b9acee397bf9418db4ce0e36a7165848ab35d39e557ee2d65100c305deb30c5253e04562dec19f400dfb8d2110ffc8f53df8483c817e9586961db249355cb95107cb7b92ffe436dba1f5ebcadc1dec1d8dafd71f7c7526ebe9fa8a65b3b4cbbf9eb1c4d9a15ac0dc5c1caed02ec9eb35ffc0a0f3102a88a920b41e1073d033f6ce855827f31e29d5b7a0173071bcacbbdcad02b251f6e09bc0c98367cf901b721e304898ccf48259e33453fa0bd79adbf8f748673ca31f6f487d1cc4fac172e260d6377fa79f907551bf5dc89e446f90ce546c591cb3f43b8901c8e7a21964570c1f139d8171670bcde803245add27196a73b68debe6e1dd561ac444485014f004ca13da0adb0b7649cac65b533d4686ca9f778dec2ab5f232d3462a5d0a48b3e7687c3f7fb9ac12fc070a83fc400b8b302bc1fa8722eeff500271af832c630ce5ca4b429e6458edf8767a03f0b1f08bb848ab929a4c14f4b9fbfd4e5ada23e051e0e5bd785e3970eb48254e01b4e33d6b091cacec2153d93ce6deb4a837e69ed77f6c0f921d6f208ffcae1372dbcfbd512e9503f42299179fc09aef89eb417f937d82146f2cdef2765bc8ac027f007f692a0a031a300433c6700e8ca81d13bd4655ce4bb502d50d42892b38ea4c15527cbdfea35e05cdfcbe3775175d6692c0c7e6ee35001c471aca9ff59300dfe26fb025b7dcb6df1cd7a16110ee2cc29833363318f9b9d70adb15a484f6297eac9002ba1e3ef9df4c438b5f96f09ca9725698bb49eeb8765c249d2a4d8faa84a0709259fe76659a8b12342f4e43cf198574127c91dc71312116e1da59840ffa40848737d1e85322f515e8a25d15f046bb784a0fbb8e956956e08879bcb73ac361b76a4fc7d1969f23c656917fb4ad96c78dc5b7dc08f83f6089610448a2a6da55a10f38ad8a4a9ce2ca786ff9f76e7976cfb54759ea1ebe3298cdd250105f5cffbd7631a7abc38c61e63eb92ea3f7c81e6c00a9dd549dd6273ec870e52d0f1f5d46a270eb6acd54f07318ef7c95ad18651ed21b2e3a3a1ee8d7ae71ebcd4687b6eb41839b40be824ac5ff74df2bad761d1b069c0eae8ee153422972f10327fa15cb64cdbe897363ef9e25c8bf84b7be651409116b0518215e0ebca88b3a34fc89733d2f8d1f99af1afd1d30040d0d42a6c0e34c88d5ca223f1b1b307a0635fc4e11e38d5e337dbd392eb3a87c541c2a276557446d24d3d22b3d647906c33c530c8abec61f6c36861779d6883dc6d98ade39e8db6f9e3c649c3fb8bd1a904254885efe2db309b962f272d36e0fb97f4a6d8c3332570de2eb642ba9f3660bde715959e0b3be411e509ff76f389cbe2e17186918d89dee1992c6f7b39652ddae84e86983d9c2e871addeb4d1bfc89d5ba33215bc9cd238df55237aca241473256370c96b4bc476f3b068e1de8ed8959134d652ccc9ed1d1281bd66aff429c35bcb7b7637d9e0fbe1a783708d9f3c9704c0b050c19fb3938a8d5ca120dc15d8e80fce7ef84141eed3291455aafa6df58be5ae5c2273caf3769bc0b3ffa13def5088013c7f6d2835a486aa20aa947cdb75a6ef67a3e8a7012696458799df17b937c3e16c41e41adb7dcc161cf7675b559931b53ca60a173cd5462098b40a51258e4ab8daa686424a2d67555f54af88c15b1c98c10698e281ba7fba7b6bb3002dc8ff3bcdf61cbfd606ef8a7e324b36a7990eaf5b5174380bfcd949592fb81b7c0641b111f02c9dd77e7f83afd4b57de2b53ea166075f3e93b33d025ffd735d3e3a79c502167ddeecb501dcbd77ec6cc596df9590f06ae0650a4350cd9af4b75f8307afa814a77336eac812a0d454c5c09c70ebf331355cdc71dae4ff76d5f1da90585a857b10f239f12af189ee60f38f80363e9c3e44d4b9d4c29947120a25a65792f54203e96cb4737c41bdf122949f067f809922cae88e9dc80c459f947fcf593a074a5fa5db922b853c9f02ed72462dad63a3a68d92771185548814b756775a65f3204e758c4fb7935ccc7077e253a7683fa342f47be6b8b0719986988a8d87e8c8cd3d6c2cb3431765bbd6691de9b56c6085b70294e21b48e89595a3a65b58b3fdaef47fdfe6ad144cba76ee24233ead51090361e9c92ebf49a1725bf3e603b6738a9124ff2989dce2f81d5cc4922d4f30c2b0234bb9cb915eb1bd6d6f052fdd167af66fbc0e4e7c053ca9000150d325f214bb61b75d48cdd9fd310440f39eb41bb7ecd5dc514889e4cdb08e23adaecc30bf3a9e2fd192466c0ae937be917bf9b7b0ef2f06d4654e396f1604f3557aa2859e761762eb1110169e4f951f72d99d16117dadddf15b9f46f4614750f4a227800e31dedcf98579778641f16ec989455ec01d7e7228c3e0b04bf584f6fb4d021a21d2c8bc17a0ac4cdbfb72904382bdfa7f6a94923151e89b74365695c1c1a0004673d6915bf5c2db7c9c39aa7cd914d85f546b691a91b51bcf7b701d92067e52a1cbf43cc17ba03a5758c91e0d394014096872ebeec7c02fae9a8bb09ffb2e6cc05e9fa5d0291f0847044b8daa18fc90ecd7b21006c0ac2e96e91e0450db95debed9e686f9e3955b678bb85e1a49cf136692e1750c7d56470722395bf28d15df3018b618e5555ef3a4f6141cbd283b8cfeeb495d49df696164e5915bc79e6d5fd3522dd9bbfa0ee62d03ce8c8aa3f4d1a8c9f2902970a4b28b29655456ae3a296280f5ffbe21728fc5fc8928e8294e26fe53829897099a028001fe950469b9ecbc0ce5a7d1dd6f05f2634524439a0303c9311ffab8584e0f1d40a848c5a98b023b08bb3eefcd015d5dded35fb9d30454871dd4c5ad55472d99638c3b058a742e2fd66591c15d9c7e0e88ef879c9e70a05b4b7ff47810422a36cd05f7e9f44a900322d141be51f9ea1a96071a6da76662a2b1284cda8fa988205e5513b0f4f516a1df455223f60a0de8899ea982ebac6a3a306f63d545970abbe9aaa04b370edf2c3a01a2a8f63939f16a5f4f41f31ccd2c12f665b9661319c515d0d0006ee3b2bb1b8f5a8801bd78a131a78214b77c61c50d29c5ed952b6621a2ae7959e011bb12f17e7e64a10a98bea63569d519b86430155af4b9045c2eb084e7f8dcbd2b76a96bc9bfcd73801fbcae9714ed5c6e79e8217d819530af58d2cd682be790e6041b22c0202868c1433e5feb5e259122df3eddb5a66cae4bdbcdc8002d859eceaf847148437e6d48f8e19fb415f33229eac58b11caf3d0969522be4545a224423dd28e14646458179e6a938263f44b62e407a193e938ffb831882f02613132ed606b0f55c5caefe93765781c085162efe0f867f64d86068240ef916f7334fa7f0a301cba66c09c4e468545988e4ec3689b484d3eba0ea86e605f77b5ced5107a1e24398e8de77b53da4fdceb4a3e0bc14184afc92280de121983705051b042ba069c57d2b22e00c70c345660dd016afd8db43e9e5ae3a6066c53c7ebfbdecfe2bf35efabafe1fe49ebb8eeb2783821c8432faa5044f23d575239a709a75305d3465b890d2e883af631a9cc91f503225ed4451b6c1eaa0ddb6aa492d29aa3ad9ad690609920b86b8b0a642289ee32a0ef686f48c85362e4ddbfc1c83bb93fb0519b8cd4632d49c6c66c52c2fd9aa9ebaef267d0d54ea69f5ec4c74a934a990eddd13c379708fd171f101631eb52ee33e8f7c17060ba7396afeda2648e017e33ac367e30a478781abffdeb0895271e248c05cbcf5e0da4c33b49ba6b8321524b287e6e487c83f71d94352d4755dba095bd00e76471692a994fb5268fd279beecaedd8f6f02cbcb7d4e7a76878a580db7f08ab171c91aa2ddcad19e4adb1a60378bd56a20e0ca56650acc3257ce92b883c917111a43503f1bdf8e178b9bb20a8e0d3d5a39c2c8ee7f3a200b11c496baf5af713a4d4f751d445d17451b2fe2471b90aa27ee24802ba3e2d4c0b6d004bf0c2bbb0862d18f8507f2d644492383bf602c973928b2c072d73c3499ad10c3d745c7737f976ffec2cb77ec4d064fc47d6d98f4a4abecd926e9969e40e5f92919870831fe8cf76931a5abb768131c29a1b87d9997ecf4031a76c89c0cf36a20bcfef192de4a049b3c267b1f69ec0d00455d664154f0153feaeb69ad46b67fd651f0587f3704feb71b971f6f8feea307aea64225431fe9879f4a393c37410047ef7f3b7f3cbbb2cc7e79b205c970b3b04311cc4b2200768e673f584d0705820443cbd576f4eb777b82e3bf11f0c78e1a9626e39e3d4dde25694df3df3c6d2cc6ef5bdf7c3751d5b665aabe2fdcfb46896d7cbc95aed51ee64a107ceb059c3d16a60d5ce70ee89a4f4b5af659ade85fef4d3b5e57e4ded0e8f58894ce07dfb51e1bb971d39fa01ae7428f66de9ddc3cac5a12391ea544cc8cebc95b9e285fefad011242ba46f09467536e737c8f7534f422924664cc9f16a7600060406e64d897b9c04bda6ad0b980ef2fb3bd5194c72852f1f032e9ed97caf633570f9234afe744e5249344d9fbb80af607de71428b37cdc360513c11f1bc3412b55e427faba67549745cf7c5a08cea5871176059f3b079d04683b1fb767d77d65b1d27dd6fbe454d8cdbc7c535e7ea6c5a612c0546b41dd0d8b28719825680eb51581594378fea94c51c97d8db73b8d63110a21852c0a5f78cc5896730cbd04ddc722edc67378d7dc188f1224646091ef4cd87d6b454b63db95fafc8c4b7047002c7de0fad7d51e07318caa48ddb50598e31c4274b206a40badd6f1e90718b0ae9903feccf5a6b944a74f00c37052a6d21b3ee503ff9b9acf9520341d4e7b6218034534b7615d9774397e8560968b9c7b0f2d78e50284af401e466acc423416c478a8cd4f9beb1658e0d10034784a14b47d6d8a922fd1e4774c067e95c81ca56a2301771a58af2ebb6c32cacf0e6493a37e3b12e557bb4086f2634c427e02081e4670a73f74ea9ae34b820c99a6faf23e66e9f127db25ade1df4a21c0816ac8f1cc338109998742e54ea244ea43cdc957cf9cfc95b3baf2afb85f44efcadff449767517d7d660e41ec9f018cd773eebf6bd15298d255524fd858ce21b232d34ed40359514f3e6926e9f462befb28b32be420625b0867bce2e606cf32d4829d67cede458be5f7f2d9832ae7b70f1082b4bb16f67690f386bb443ad1893385495933687319e27821efb37955a83104c6e288218088317792a39ab54a8738cba5649949e0cb549be9c62a7a0cf72cee2c4d4ba57636a986d65cffecf6a655da0fff59ba5ba271fe4692e4f5fc5cc8f0416fb0b6cf8644d8f64d9e62d729cf03671699c36f241116c849175ccebdcf9da01eae25b29f3b7c4aa1caa3a90987135c3fa2089cc1224dceec01f92d88e67a574c5aa3702c05df0566730e5eba20c890a9bf281bbf146628250c834063622260e4571a8d6c363188a1bfe815a5760eaf132b098ac902c86654ad352e0986f22a5d32e2dbc2c5500656966d08790e8dd34f59cfbb0d0de40f6b173dbf523ecb3aef10346f6067cbea6bab44117519fa2aa4290ce3a22cc96987775b36c3b2f2873468850046d05644f39b784981e68fb9fa229aecfb8fc6c133a5bf8d6ce2de27129ebe3542da37d2f2ecf6933f5363f32a13bf67bc899c598e6482a6a361412db46a277b772f2fffecc58af5cf65763d1f86cbbcbd42b7353b1231982133b60088520ff55a06ed3e98f45bf031632d97255b1c6991a3743f0e0b7a31ab6c531ab4c01db9f4c7926f3ebd2842472cdf7aec963a578b43e636c1fc7b214393682bc9a81ed03d2350d35de5b4b5325557a97d88fbb4582031dfe0d59f044ea5ba7b96538fd6fa92c708b75fe320b6ed469f40a14fd1f3b3436328c58ccb2abb325e26ae389e0b98b191e30718c8081407d57567bb8d71c018fa8f82c85e6e1f3fc2b9e46b5eeadf86d2ce29925ad6712f4f62650d5ddd3137a113351d8a428af33c3f4c16d3b9f501db664858a285968f91b00dcaddb31894f28c2b4861d33a927bbf030d4ea4d57069707f8f201dedd533ed4e832ddadccb6988f2fa2ded8cd7ce3b40aef692ddc2556a950a7df0ecc01d2392020c9b8508426b3cd725b5a65b5f2c5bf5ed81df59c35fe8f18eb7cdf1849154960d224cb043a58d1d9a158ade8f5648b899bf7f8c7cb42b996682f6a3761a1ef7d87893fdc9e9b3ae7bb280c3942be06913d617b831475cc259aa0edd237ab026015f6ddefeb01769e4233699d775ce08d49cd7971df3340444b740350553a60cd39893a1f54631dc833f1811b7742162c24d8193ec5c60a21bba725cde5020323e27893f71f726bb1a6dc85abe05f3310e973641a85ac4a8ecf844f99ffe8084fc77602e384b8bfafe75217d53c758eadee200f31c3108a0838204c7936697476c1a84f52d030cf7a1085b605bca383a9340057276d60c0b27fddf5e1d3cb30ca5d9154cfbc59c350f9b67863e7edcb256fe7689307ec25a103b8d3f329ca98300b3c94a219f305d87cdddfc904e5f8202eeb882dd72047036f0c165882812dd2dce21b900b39622abfaac543214a8e57dc773ba659de81a98aef9c0eb36df45174cba45be7a93be0606205e4b0a8fe4a193e0a16ff526f532f669664edbb04f9e912b2b3ff0c8f69a3242e1e06858b3c26c1765e056769aefc32ec201a9817ecc48c9f7ad2696c75563052fb3bced06b1606de963c04877f53301f2cb5f51ef042933ff029fbf87497e916286a8a7c83804d00c774838025de0f99394d27c9df4ed6dc18075a8ce1a60493ad7ca8a61392995a5e709d4f1e794ac816c45819da51bb06feb7b0fab084598ce054896083dd3fe9200cffc47fba60ca3c2c4011b2d01a9ef6398e96573aa19586463ce1b647e7c6a32eb17216051ea94bb05b782641b893c3a1239feefefdb5bd51bc9d90c4fefb19c7a8f24f27d8e60536d1ddd8838ff99258ee2d13ec3f1a7d9db18b892278e160185cd3d5a680db40d6b935de6339856d43a5bb63afc2748ec692d85ab5103f0af53e8039da748b807a4dd07f1ba8040195a99b556966aed653989d1fc985d6503487a742ace1f7e5fd9e6958ccbd33dc86a6efb025193de64d12332b8ce2bd2c2dfa849d9daa17be6883b1a2cbb9f4ada0b98c4c3fdfc617892f9b48642d800d13d464781442c934d49014e5d985a6534e1a02fd662f67343fb41604750a0372ea94ac76848fb7debbf36e4ca8aae424a1b9b7c9b0c370fbdc0e21be4599b3dff70d92f711531b113cc6743b4cd7cfb7c35694fac2c291fb5263586f0bab9baa6057d39ff03cc3577b36ef6d087f89e92e77a22df7c638bb7832953ba068e843f2b651de7ffeb4f54ecd3af289163e2b5d559695eb256ccd97e9ef3fb4e5d73e78e0cb48b283bfc0acc311192b6cd0238f25dbb9846291ba0d0a4fa7f81a6166fa37aaef9542a84655008d79b44b9ed0123a59b92bb76c1564a92aa8e876b8deb5e68a711f74b8ef1f1fb5caeef51acd534a1db3d35c0dce735cb1676f9373b7d71e40df7505d3994972bbf02880c4096d06d1d56964737495a88f368c496f807a511913baf18cc007ebe3e2c53ee0744adb4ec7c656f75bdb7d7749613cda341cd7433c4afa225b147a9381bc4e2cbef6a7a6ed48491343e60b609684005463b0f55f0e04e3ee67c833609ee5d213b13ae8cd9437836d852adc2ce696954360e542edadcb08906cc457459be5a33ba8c5ab2d8823d6b2ac9c65b08d06fc2196a27892f4e9d13dbffad0632e9245bdf2939985704711fea54783bd595fee211dd29897aacf4547878f28e2ec43fecd522979d89e46654e70e4736bd91c88cbed96aa4c00f343430502518ac25a4eb5fb530040f60ca0ec18752a4ee4d1fb8db75fa305e3d4d147063d7fb12cfad2ec48024ec24894ce4821939ec3d435ac1610a8d75d83e86e82481e5e165b9f1bcd907c93f96d86393276480481095eabde7d0dadfd0660eff496034e861c290e979c17ac812b9058d8104a40d50ce998eeb15f0caa36558111eeadeccb2240f0350a1c128ebeda41bffd9351c77c65d8280b473a1b5179e4a78f81092c48d8b410ff556c8601608dae7d418818a3a5cfd7a360f874f26f7657f062e26e42d2cb5c69b4e59217b2e810f0c58e649bef5ff3a193d000f3363f71ea2fbc1fced3796bc61e5cc572a3868b3d351fa0301d459c5aef835213845ff8c83bcfd49418175c3ae620f833dcf9ad148dd5d277d1e2cd3d29098aaa1622008be3956b17b4aa8d5a6769e6d936eab3b70d1c5bbf49fbcc32b6d2521d355fbae6daeca121cd7db0fdd80d6780104fc3ca3d02f66e8ea018b6f53be1f84663cead6e7835029507fed6be5ebac4284477e02e45ada0b734a20a583103011d8484a07ef75ad7f3c864a79edc30362ee1ac956a0ee4cffe5c96148294724155ac998502d63aa00ef9e2228d1a1dadf6c9b170e7edc7eb9311e10688423a33b6d7d271f6d7031f7405a0af4a3fe4addb70fce45b8bc8923d6a09cb3436b02c2a2af575b69c234f60a41e942fe7d880ca3ddf18489da18335828792fd8afb081a5d231ff4be1328244416c6f23a381179fc74d394ec79ad9a1634194696b0a49f57bba10b8d3d15658d70813cc3a231de9524f9eb92f09bb6fec58ce545348242614a99e886cdbb64f83664fa406c064dacb89ff83c5bc658787de4735f356eb080b66b73609772b4e45d9f9842de434906104473afdc53fd1b16691be0acd6790037ad0f32f6c97863a314c4412e2080f92dd62efffdede02da60dbb0ea8e44dcc6d797b2a276d7fe434a1b6916d921b6083acce9d160167f82b9ff3d5948ab222c632a1599a96628e9992c6474fd98228a2fd891e2524dd595118b7c2e6f949a9000e4679c18501a8471eda69b2e0e97f5431423da46327c1542924afefc6b158a9c8aea19752823c8dcc9e5862594c6892aaa90575502c7f3543d253dabc1e81f94e55a0f129e1c85f7da4bbc34897c9b3f4ad171facb76f62d1f603ab2f0f70218000bfcd6a0dc7a9e8436b5cd931498ae56ac1c6c59dc7e99135d639c9b110b6fda095d07bc480a3077b1d9db9451ec64efda9d3bc7b52c5eef7c5800751739e2ea5775c97bbf2a4c0d0ddd9cf3d17ebcb4c873da158de5b0efb73e8a13670379f94d3d14b3e272788d849683eab0e05e255b16b550da296dd8bc7d751c24c0f98736655afc32d4bccc0c1fafad22cf8e5094daa979fcff979707776218341b2a5f45e8e4342ccba5aa3053cd0cf59a762bef491992d4c78492e7a1ef28b5873742a1bb3b24c6dce1043bfd9cd21f38c07199e6303c33b5e341ecb615f60c258959f113446a89795e3085f24bf097298423c4f85c9d92db3b815bf071427292ccc94208f29fa302dcceeb900e2ec0f05ef1bbd260f3696ac61efa9d28d3931ac1ad9c058d7b40cf4f25774a85343c052cd45f2e9269b802153646c364f4bd7f68154f4e75c89de199fbb636778d60621f2cfd8754f8be10b56fa5973b76c73f027db260ed25b9f68dde01a3bb24717e193dbb9ec0cf0bff385ddb48858d719b9b0a4cc697b8561bb317f8f5d1cf10943f1189dc030e00619c2d259adcc5e6011266850acd624870c4d9f36aa96146a5c2285a11324ff7c9ee8aeada2a10d1a8ddb282fb33d5ad89f2292c10ec5b7d5642b8b06dec513297645c3761a0acdf7735c35b6ce654cdb52991fd78921f22389802bed436a051a86f5e277df691c69ae32b61308250456f69c32ef58d21186e2015e744192bd661512a93fd79bd67128d77ed36bc140b6528d67f9692400daca4121b0a795cf24edf1a0a8418410913ba2b987819ee807cac8f032436a7ecb45b388a91a913ecbb78d0b1d11eab872c4c8f7367f346f4607e7cf6fb280f4998455d5254010b2f331622e575ead589fc6e1d52bfa4d37646237cbc09306d57e8f8499b74c7ad0335e11479b110ad97ef0f7ee4dd0262d2f60a2cd5d0ceef8d71a10c5c79333372e579fae74c6f8f4be7d2625192a19d6e179542490a7ee4a9059998f3ffa47b6232975583da4f3ca82b9bf27facdfda8de48843ff48bf212ef61647c219091391745d62268fc34596b6e7bea798f468644836bc1da2399b6f194eb27454c505c64d973d51f1277f6caf1dce88ece085c5f7261e31926ca61e9567ea0ff86856c90e0db94c13612afd43a0e38533c85174069bb8a68f26823e0e320b1470f01d9518109b79ccd4d130bcfda9401684202807c1552a017b56fe046468d684aa98f93780dbdf1cb24a50c9fe5dfc99488fb93075915aedbfffd2367d9ed2a7e38fecc808c5c40c78adc85af916a640ca99eb9732fa9980b313df41cd50615850ab6c6a1056bbf18fa878b663eb16ffe83bbac2a6a2db8870088b4ec43cec3a13b8cc5bfdaa2319c25129ab37aac1123706f67d153873e166e0267a0c8e2583a61cb5fb333aa6353427d28c42e0fdb7bc080544eeca07bbbe207537a93c96047aa7975071c90bb0bb0256a87d0a22dc6937fa8359e201669686b3917da97c1c43f28146669915f43a3ded4fd67ef8ef80d772657c1ca2a8a10ad52962d21a44e35e93882148b65081052f0fdda9d704ff909b7b9e139d1cc759e7d3b72d75706480170987f8bfd63101fc3a6e693a8970fc2dfd24b9db329dfeaed985aa67e799b3d60c22bd295586ace878a93dda05dc49f5ee05288d9da0ac58ac9ad739c273ec73ca5f1031401ea872ff17ca5c51166a7610f7df58b17e537ebff17b3a78cb5f55088b83c73643b605c75ef4c5aac588ee7912225ca1677d1e6423bd8b9a81ec7f715fd66a4ab883e4a6c14fc0547e20530239ab268772d9dfc145169ed890be90ecebb9ab3608631bea286d75f92c8e20297866fa50f414abb13d31e980655e3b2d5fc6fed71f71e952d2de736621746d9894aff6f93b36653c87b82d056fe910aabe401b08725b1945d6d4bbcc5e03153b3c8de15407108cecc75e86b37f9b11f2be76f264a16c5ef3648166a8b8661763c4f692bea2a91e7739662a37478ce59a0cdebedec8196843eea6ebb328e077a4572643c355504a70af97f60f7552f72ca7233205037acb8b0f76aa4cb75a5f14760be7bb79df2b24ec7008a24c4e396cffb32e2812a8dd813674f2476befc81a594002186aa6c7220f20f619d05a5cdfe714de6fa5e0c60ad9b0294dd843730a554884528f3081114fa44cb33f3f71b33c0a9c82265361c89acab7b928acea46ab692b33063fbb7276149475ce4218ef47de066e569457f07a1f6334c7faca7105cf2f4db4ef3bb5ce8ab8b6eb6cf3ed2509ded46b665a7c20b622195b3c0d0ba07a5fadaeafbc73e51160903af01a10c719d9a715732613fb42228cd6304d302042f4ba23965eeb21a3be65b6dcd8e04c39b954267d366d943217c01357b9405ea44f53c21f6a51edb835d72fa6cf6cf20f4d21be99c7a5bda56c72aa4a951e076129f844f5f630cbff7e36ebb21f6884a9f233b9bf4450670bb81c94f8cc26614d0639c17647dcb010e85936a82c8f43b7bffde4f2b9f5194119e23a15cfe1d6607cc8d1508cd953ab5b76095beaf23f22d4eb7ecfaf6eeb10743776e67c607862c354623b6d35be6a5845ff00b433427c94da03b31f8f84a99f8995075bd6f17008dc9292023a3dce505ca9788d82988e25601b94553182a1037280a312f73f881446667b8b6d13ba6f2a7493fd8ce42052b46957ec1913662810cf02de043f24ab5a120759d40d9ceb75380270c484eb3534e2a4559334fcd4e17b769d6a70c8045f575809e3067dd39dec46b8059b8c918d5d2a4cb0ec8a34d4c108097f4bdbea2d00127cb6a9f4361949828a33a1ea04007c8246449788e469f7ca07100d08437c4ad6c82ee5c84e5bdc28211db9636ede58d71f66f22318f7a09dc62a8c0bb9d050c531349727f840a383f8ebfcaf4144bfe9703daeb8db91de7b71559b3690b4a4380e9b184c5c985e3824219691ff4ef22ab777c8e742c74e370e11818d8a17656f55ebc35c73704c04aa679cdda996615fe664863f4fb2cc1cbb31f562790fa03f14a803daab063ed9fbd42e3fa77ec15837bb4623159dba9f5d61bf104a536d4338fa810dcbde8f28b1655b3fe7d775179ed27a3703e50982b3bad341f4ed44480501a48c09c0d84074a0fc3e9bec22eb83552f85862620d279872465d1f299f3c61e6a34e58458b754121505114d1b37b6c99d65dd9a0e38cb8b1e98eb693ff664247114ae7034b08043fc4dcdb56cfe49fed25af71f5fa51bd9bf6ca7371c52717e81bb378ff9e72395a1d8f80b9004d56b8400b7436d5883c99a46044a75899668901ff9f6cdc4c14aa389e2fccaf598b505d1ea91929c64593712c98f15e1e97c8ab1cada05682041f076329dc26c9fb25d2ebce22a5dad3fe25678bd5a2581bc934b136de479832429aefb748866f8c55f8b526e462f8ccccd21c0ef71e999e6566daa0aca0afba0fd97984f0cd37990f2a1ef24c329063a156bdab83e0d9d8d061d99d59dd24097a0ffe091d5b0426168e672ed8b65ddc9161ee35c302b722ba8943e9db32d0bab634c87ca0ff43a9ee3ed4429b88b109c4ec8c22cd01e9054e4f923f5028ac822cd0bf6878c88f559b7a6b8dde3b7c01ea938feb78813ebb2c67791aa7ebad8b6eb8d981823cbe5d60c37310bb9423454612ff808d85c9c6e8c23ed83499c5a73a9c8a73b75e5c44c992a4468dcd32da87fd833c0c19a89061b1bf3b8a28fb31388ac5c6c6675c95671c511e131f7c425f920a7f2d669d189675aacc60314873e5909dd70337df08ff4ffb11ed099e2abc83d4d9e2c2cfa21e1d1106d58978c40b71154d230addf0de93f318bf8aceda0369e6a2a7fa2e1662e1b9d2343cd1bbd1a6adc8e0b786c16d56b7abd4cc3033b6f9ea3e8bc16eafeeedc9780a4a04d3deeada151ed7b2eec48c70de8b6373efdeb1390b51cfc7551d3e490fbb0b459a1c251cba2ab58486efac9983069788633dda2ddcc388167f78bf83315bf6d9528f0e1e81b2df234575de86f4b21ccdc86958d85de2a8e35225b02620495c2005bdfb222d872b413c145b859ca0a2c88c2e3b3bf5a5849910857b5df58f331c3e4dca55c3cdab5a410083fee98d9fea01429a689f51b421b19e47b687295467a585301b8cfa9fcbb7dea914172d3dbfb147ddb76877bd254a4eae9c9e0c972e7a1554213beedb2014c4142da93a78fc8bb3ac7d13207864639a9829eda7d919bc45dceb389f77d6a41f30ad22c2846ce35da978807639964aedb1553500a6cac9079ae9b8fe83c5abe651346a2a50418ccb15ab9f2205fcae7c3150ff26a79798fdad0b7b3a7016b3b2ad317318e590a2e2ec14951f6be9d70bb38fd61b0b4aa7b8ba5b5f6f453e79c04e210bf1f86a63d0dc971b52d7c8d4325de511bb7828720d660349a0495a162c29876ab91b4b7557b366283b2712bf8575e7747a3a52bdaa840e7b93bb01044420727a511ba49c1e254992e5ef003575f054897face9189b7e3ce72ca1c73c77ac3bb40f405afdd171252e179fbf524e78291334a4466fadbe7a65c92be4103fa80a1d1040a37ef2656b14d8e2dd84567a849418e008aa5c7a9d2a4b7c10d147cd3ac336800875e51a63ba188bf8c1c9bdbed149250720f7a34661ad88240ead5d1e68263259f63fdd3884719dd1ccc1c2db7006ff0ca133b2e5117c42686dad0a025306976bacee9996e2e7bae7174c036f8dc6061b2a64c9eb5870d40025a566d17a684741d1220e8fad4692f5acc461ea605675066d8d3ff746813c801694ed7001efa4a6f2d371bce348f65d6021862d2a5081af16de97e10381cfa2e19c3508a3871fb6faa3722e746962eeca97d2648d1520f14eb9c5be41fde9c3a2e638214e4da3b9b6a97d0811bf86deee2622854351884685ff5d2d4e41fdf5b0441f9a952c7a77216776ccac26867d4a069d7d61601072323a6f9e66e362d7d3db7b062404559f4f2cac62a3badd76f971c61e6d2fce851b05e2e71ae88941fb84c3395ea31d5c5718e033ab5875240ccdaed15e56d95e770f98825455095ee5001d8d1b47af692ea3aee866ae6271946e96857d91749b34c69419698d8f63572a8dcbd8fc59b3136050ad9d45b5e6f8b7f5e5e71859831e25e55e7aec672321dfab37fa1a54876be9d64c7ffe7783ffcfc3a0b88c79ce034096ac62d9c3fe5ce9c395ecf0ccea0b3f24ce57b9e953d8dce46500dc0ec61c7e558c2b1504b24eade8395d093ec89996f8314e20ae7114d12924bdd37929682d26f44ae3946cc078df25c7122688b2f5af6398a9903f65e9601a7216bc7b60f5d18c8f6a0bf3fb48024d094131304b3f103b5132d1a8c1f1c8352df5a94e21e20b1b5ef1b94084949e22cb19cf9251991411a833b6c2f0390842d42ed246134b81cd1c2a57424291a283b1980b725fb0fac243d566b79bcf72bfbe0dee6996fcac80c8bac45c6054d7bde13fb9c678b312bf4ba6657e81e98a0fbdb4ed73fe8232230f21848999dbbfbd6a968b5d9aa2e3c6095aec473945c615cdec9fb7729e3927bc43f8a34bca7ada05bb5a8634aebf0ef4c35f7782feb64501dff0f85e79c9516cbff814e833811726f36ec6445b7f1ae3668e57b8cf09b01c3456cf84427f137be430847a39269c6d2cb0fbe3dc9e803bd8111b0fa046338d12f140a99cfc1c04ab18e08c99d6bf3586855b77dd1d98d40bd35c12fb6e2f9571bdad1489a16cc1857f21a96e4db27186968cf78eec9d03c4eda2df442290ac98ddc8321628d9fa4654e79a6c3cb91988ea53fc87f2b8c7b2b92b2f568446ecace077a07a7037daf85f4cdbad360a9e3b6c80d3f4c2cbaea4d8276834dd04b316ef412ac251daa0c8e2e5da3db434067a37fc277b602f9b2b1dbf88920a8b3bb5df3b753c264c38351d99b54f4d3041a993a6b8e9e4af3febde24b083e9882ff33d279a903182f653baa877ce85d47a49c0701c759e517bb26ddf35cf84fd2e507d953d8c6a72a76153d73e3e853eb06cf80604a2d581f3baa9d7b17319816f38d42500ada5fff8ea7d9e27e7d0dede62e129615064bb56d6acff5a38aa77b199305aa60f29eaf9002fa00b19d95518b75e21e1d54f19763dadcc8fe58da06f352756d1fee2f798dd4c5d0d42625513cf8549e4faab00f79f0b6c83dc0a6c0c526bc47ff3b9b0ee1cf70a676a61dbfa3c2d96d424a1aaeea018d3b53b557825c47bab3df2ff13bbdfe04cf990d8ae24f4ccac9c0f966805276a083585b4e7a4cdd6f6a9b5ef092c052d5ed19502cd061a65da8485bb48152b47f8e255a27a782ba2e4f2d1969a957e18af282283d82b7be402320e3e9bb9d53e646069cb1d273d39f06908ec60082f3fe42bd5320b8f542fc4d7eec49a638fc90bc15e4e5cae07f446765bf135ba3f7c523d1f73df2160a939a3c043bb9e733b1c09564e9b7c89168fa12618324099fa28df98f2b29a16ee1f62f65b4e162cdc055b8519b8c8dc8f59697da6098a35fcc6e1c70c1393c5abe5fdf6615e6a522016890317b4f09bca5412904414a8effc3bd2b8bae77594bb3358ae545ce1faa6d5e6f600029b437f47ac638d9e34700afc0caee08aee839a28f0a3b7e9d61652a57d2cb7c35e9af96bfe9d4fb96ed43e85e7077e2818523941ab2a500d3a4226d90d0f054bf83e66bfaa63fe8bb4da7294ccf873eb0c415659f349159642e2b82030e6477cc12bbfb82d2594d35f24df840c94ef57684ea66e37af5195c5561a6cbbb2cca3b407e1120ebcb9296147de857df2cdbf39afbae5aadb59e07d6c4461fb70b824d52f3790e1801c7a936dc0bd4ee9f8284d0918de981778ad98b92c5be840163180022a68145c3a3a0bc27ed970e31b606ae093758d0998c6468ad7287b843c8f2d522b0030ba3874cbcd65127d778d3ebb23ec7d86b281fbf1b4b75364142850407b1f231ab58c0383c6e7a8a861374f2eeb05a482b7568d4777c776a4b4586172233018c22bad2dab1c27deb7fc0c5ef3fc45a0b91f5760fc90b99264b8fe6f130aa0ba3d2f63e5ce3059f7be12a173e62681f147875e061f18a7845bbda35b4c2148243b7cc23ffd66a59d082a2c73d95b5ffa5d209a1b0e6648a36389912b22471a772ffbc1dcb792eb4d0255aa08ea3a41db61ec8f84e3bfbcc876ea027ce83e295a25ad6f1a9a5f0444fa1328e30ca988e13fad501e883d665041f5f574d8fc2401cb74359c0b5b58c2998aae7f5b4a6835a30c18b6b518b112b05ca30289d213b8fe844f601cdddbce4bb41fd3da0401232e6e9808d2fbf8c2d55f82cf45beeb98c71c60429bec0a3c004135be94ee7880f72978876386bab82be2f61185fb9d32c8a82312adc2d3e482817c4f97ad4e2eb0755563cf5521897340a20117b316b5a9a2d61e7381e2d05e708ef10530a48ebce35e38c6cc6bc3d462160f54d9534a6d31b29c7290daed4f7cc6c33dddaa3696ddb17ab0f2f76dd28cdc17e6a6e9d9b6730366c11d320292dd8d6f20f97d305cd56f06b50e121002ededefacaacb425c00870cc8d77a64b974d11918d9f9e09e8ea8efcab9187450705294896602c54e7a565cbe925da5d1f3859782a290311b4ed97c421f3f92b4aaa3163bb2f40aaed08160abba07331ad2e64abc860a7963bf51121c2d9bc32df78370e51571f9316c4cf6153f16b94fd1bf965d3377db89bca72c11a816fe4249276e65f5721f745be446381d5107b8e121a24549007417317db5b6404126abc15e0701a12d319012bd56788741e9e2b08b3de153ade2a69aa5db8b501b08ba101e4271e1911f81aea9804047c411455c4ff9eecccfddde473158f444133c8d351077438c00a70f545c2b22fcd23331ee55e834205ecb069a161fce1548d41a3a76ebcff6573bdd4ed8d5867a088e3d7344761264db65f71c01b1ee6a8427829af574b0e0dbf4942fca6fc487ff6e31abe8c3052bca5206c9f810b07bf1ed08a2f0e85953ae83f52c3f96f7c176e97b8587c37a52bc06dcd55d9aed98028c09e30cccbad74db7478de41702fe48916fc5685b85f24ec65097ce4f66db833977d6b9a532223667331f5c6c973dffeeb97bb4dd4190bcbebf768ada8fa2e11caab4bdf4f586e712756233ed60b22472a26b71a1483d8eca8465bd6f7652fcf53fa26390518f0551710a73655ccfffaa1c57de48040ced143fd9b10f62c24b0fbda30085735beb9754cacad746df01c6d7826fcd2fa8e71ebbfcf271db67061b4cf5ba97ea1be50088e8468574d732dc9814baa5c1ac8a2e25e7e140448b87c1a6af1e49b816e88ab0887bbaadd1904da5430de8a33f4c3f813e9d228a724d5b419a115d6ddceda9a12e691bf0928a8eb0d1f064ac54dfac67a19ba64480b9f9a96c12f0c32e8a1ab159a28c2f97d1233fabda0a91ecc10b4f2228f50e0c6bf3025f35e8e60a1f92084c34651114ea0fd9be01bb7cfbadb92d93478223c9208d7344249800a13b3a2729021b6596e516aa2dbe80dc8171994020a0a84a2ffcdc7a98c6b603009dd66662c6c0002fcce75c98e55ff5d99657c1d122bcb8013ef05777798094f65a4b54165e3434a4ddc9968c880231af3d820f8e4c106ab3c68eda522937fef5e3f08c9b50c4fbc8d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
