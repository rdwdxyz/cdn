<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9ba86a8c60db795a7258bba8224ba0affbf1bb669212a792a37ba6586499352cb85fe99893ad7b2e1bd44ec2108d1d79c09e79ada15d0ecc0970887cde4ee15d641fe384e04c2a02aa6dc3d42b2fd1f81709d9da855e32ef1f5f81e996a2c4741db05e3de9666d80a8ba5cc362ef8bb2e62dfb975b2d0badf389c05754bba82f413aa78d84d2b0242cac799a90e5afcf60511ed26084503139b5992b90874e2dc890227e8c0465c3d8e6c3dcd954e3e819c56a3b12da8b13348f58084179be65364656fbb93c3ce8b13eb84f7bdcb85d2e05ab35747cd9703504bdc7a80e0b0323b2377cdba3a66f418bcecb04dbf573c0e6e1ae82c946dfa54678133d96b4d7281c13e30bf3d30c1bbe9c04c023933a89d19b67005071cdc849b3707c6a49e6a5deec7b80c7e218229467d18b07ae6da2e0e9daddc6659aa67447f6c68f0e0c15ba84f16df9e3b2c9eaa1b68a4e171422bbf96ae60bf6fe6063686e52be3cbc866cbbf02872a41d59a08a5e8ba17e3b3bc9fbcb93abe2d6761ef6891d0b68a9ff6f68e17d6d1c9917d08640b61752af18f7e1725cf2bfe9523f0c44fea6ceb52f5d45b317058dbbed0b78703d9d2ce0d3474cf9c5bb317fedec63b4873a016cd8e9ab0835fd1c357f20ac7a1caf5986304d00c60ab4dfe9d72e5ca85bc971b7c8bc0c40ce382195ea78b18db9e500c10f99315f47b04926de7375f8ab5080e08cd91166f402bb637f5969c2728a90efc624777c84d830fab2d052bfad3aee54b2067da1595ba0152b6adfbc3fb8ea2c27bd8cf63d129ba74ecaad16e4ba505872673c67bf6177c903a33d8fd6bf12c52885ede85c0780e85fbbf57b305dd1716cdb8b0480c39fd1e7a10d49e3c61a665008d2a4164fc169473645a9a43993caeb1bde7825a7c6cd2bd2eb265ddbb495f6226022778cf538be632e26767ae85cc83a5798aec8917a16829ab84c918a5b3dad28d8eb89576c79d09964af7c2ef49aabe9ae8b0b41460c39500dc7084ef5bc6f407056db48a79dedbda1da8ff6870cfea10e8e31ceb8e1add3626f8d13d437af4d44aaea3331ec174a9d731f313344c124de93cc77aa5aaa9930e5358803b12abd31f72fff692b124a1fc9c209b50b0e7a2460656504c41820da2613065cec46d32654e14a68db8887a9610f497533061f469a66d777d6b71fce51124f7738dd9121d598baab249c700d8bc8e1952afec8145e5f592ad66fd16fd182848675114e06398c2cbfcefdc3fffae8aa5e3e204a63b6392064d167402928a4ff17ef029659e5c57ae00420b7f1558458af004ef9b930bd46b8a141ff38a8e83876888f4e4c21764d009f0646af189f50eaad6ef10cf95ca22933f41da373f1c23a401b722cf5e9bb48c4e8e55e7ff9581e7c42897b107d2e6a29fbe95717255953d484f6df4dea13122ed7719c4fad911fb480c7d5d9405f85587d89e61b7550a151ca0f893c462f9259cf7997a7b6ffc35fa672bbcbab39e744a879d1f54e06a2c127a9557a1f66e463c6ed95ed313d718ceb9337550b1e239d5c75938bf04922e683ad7743c7a54a4c0e3deb1a3807c9aa25049dc8d68bb74a393bad5ee4eb8498961a91609e3aa965218e44391c250cc5f3abf70b28e3add1ee4679dca19c2cc8324f5bd0bc4e466b8bd59a3fd1ebfa6e7618b04696fa87b11aa86a5ee55eb9685ba3fd1907ecfd0ba5579f9d6cb66f7d02a8b636373603d3187f38f818fc394e20703bc151ddb05c4c5378b54056c8ed33de1a7f1d9ec2eddaffc79c60d2d171b550964712b2f510bdd5f49ffa2f72011ee8a491ec5f32c77dd1eebccfb29d8c74328015b5143ac81bf5e849c3d70357658647c4b9b92da0f2582383ad0219da9493a752ad35e5718b96e60eb1b2cadf0f698e0457856194d8a9e5a34e8a1b579a6f93087ee78b680e31f1c37a0faf13f66ddeea65ef7ba1af1cf3441b7f6e704f62a8a80d681d74c0ff0417c732bd29d29af5893c8bd707fbd4248251ced83e747c42a83ad8b9b9d182aa7c78b19f2801ca7fb1e158e183e942be957dda5e4c9c3542fdc93150e786c50a78774d52ab37c026189e74a6a089ef1f52669a83c806e6d51dc2539df08265d76c81ef230f2a4435025b21ab5406d8cfc76d460708f9e448603c68799cc0329c5ef964c3acc45243d0b530fa34f859d218305aa66100884366efcf5d026e88dbb70912888129c32bf847c9b5ba11908b6e3dec7272d2b296298ffffa649de0689b7e1bcd4b57be9bc06de52d118ea05c79bbc6ea67669783606cdd5fcc5e8119ebd6ed51321523a4ac0350d3082f8812574d4a484a98a768fdd28ef8bc9a16e55d594f61a9da066b9a44eb49cea3113a396193f3ae228c88bf98ea410971854a27bdc78e306253dd4eb2f24c6dd1377d8768b066baed6613ac6e644fcd7daecce0f9c7eef70b26ad56d69a0ffcabb4e218c03a62ba75d2194c318488861226e737e8b4136a64a4c45ab7e06c58a5ca519125df38d11904c42d34b7867241e0f6bbb4bd0ffe1cd0156f4d35b957bc4daf81ab4e82e17eeed1ece51f54aa3802ed68f768c1fe473a671d74b42749199629509be318a6e0f70500d8de1685a17393ce0c43a97c328330b096837f4abd22136e48ea9e44b25af357d3d53caa7bb80e321ee61266a2d012db5dd06a1b4f7d1bbbdbaa24ffb5c5f446fbd7802d56778345c73d3136d5e52d95d86834b68a1a374ae5a4e045781c33502e8cd94e7699fe183dfdcb317b53a8614523ebef2ae276de7f973c8620b31f2182aa28ecdc7badbc75c4a5898b316944df04fb8e3cc174815592ddf3c21d926a4384705bb31eb83746c01bbc216bb345e1ae5c235b704caffc97bb4d0d4e4dba4bcdcf474d165578c953a9998f45d70ced11ed0b87ee6a232144560ddd9813f1ab9ac454c611475f286a9e63cc1318ae6acba9fc3981a62c926c88633a229aee8317c84ad06f6506fab7ba3a9fce93cfb3537281e8da12993d89162ed0dcd0f320ea1933a201efd439611ff5cc3dca2ce1da70383898cab7956f6cd84453e7c68cd632d664d0b0e7fd776653d3c5d42b30aa2d6eec253292ca1d6ded33f60356ef007d56238b5971b1b25f5720f0820d1899358efafa17ed0cb18f3e32b9bcc3f22ee563e6131afa16d0d680f75b569d254f1860645dc57b60f03be6efedfd14280ab29fa7f2beb904cf19f5d8ce5b99427794398559f8406c20e6ce12d0a5809018ac33a06f539af504106cd243f6e51014b4adcd923acc60bd67bcba0c073131c2ce89ce9705e9f08f0d488a738f9e299296cbfbd0827acc4429f43578ac0d46b69d2294a6eedb699e0a20aabbd16ba8ef4d4159b95255f832cfc667c8667df13f3dc053c23301ac154792e49991fe9b2bf193d4ce5230fddd98e12e3375a75f818f9bdc9991123df68e590d28c36750b47bea912b6016c2516c8c79cd4b174aa2e9cb3cbde713bf539c40b26819562784b89a22cd040d022775d8fc2c4e04193050de9745929c2deaf8d8634583b383d262dc469d83f3b71abc8f3fa9264e48900ddd647e863a0dbc16c294b39460635a0b25848da815cd8ab9a1d2a658cbfa71eb888cccb38e320f0613078bdae2cc7d9ed7d1326c44184c260ae3b195378c75987006bc1677a5e18837dabf84649879c497fc9e43e180fb6e31d65cb2628b7e7f7c2cc2a991a7293983c6efd80de53e98395b2ba5950857cd155f5edd649dc789c328ac85810090c88f361479b848d76d16b3150d800e473c64458e4dc6093b88448caa48c5cc0fb9f3116eb8d7e66e59266d896a252b39c1bc42c4937aacf1e7719d5e4b3fe657b11194153203192bfcbc6a5240944bcdb5ecf5cb964eda9cb6731c48f57ba44afefd7785ad219af4139d02d07490c55382d8d726fb5366e1623b44e1e05fab48f69324d787cc911dba76a8b19672bbcf3c5590042f388394e22abe81a8247310a25d9336703d8d88ff6cc2b5d8e83c51a661573abc7e77841020ea8d2b5df296e03455316880a8f4f25077868c7915a5f64675deefe0c63e2857a1c46f78239fea1a4ef9eb6ca1049699f2d1a06e78225e35d28b460aaea683693a98e143d7383226b16541d13501083d59a759a4b2d2b2947c587692503fb47faeb46da25b9119b5817b57bbf0899cb936c7982d827f568d802879e24525ff155344285ec8f4e9b4d45060ba4cdd3015171832e23a91d711c965c116006b9711330f3c90d13a8bb3bd3a37a51bf5e91bec7d4a853973345264b466150071489d7228d87ca1da9731ca7b2f6447b886f383f23144c4a9ab0d72423d9dc8080d0b1d82381419dc6e24b2fec5a89eeeb48745efd0f7b811d1ab3bce342ab5c89752f750bfb9229ff76cc5f8ad9d2dce70ef63414e85ff5d0296ce8f737eba8036024696a2656a63c5c70589e7dd715f101f805395131ed03a77a03b9878dd8ba765837257429b8ad21d41ffab7055751f2f0ef4ac863f0d32dc74856e541ac66f723e68846fc88025c33b1a3e6131cc0f91078df8b6fd2fd5dd3ac6fc7d591d33c90bd74b3dccd92a65eb1493b27739eab7e6a778e10655899aba7b1e2b9a51c06c0a4a68787a34c564475d50ee499a1f7fd5fb067b2ce63f8d0409e397790f3f67e27515298ba8bba4998b225aa2800d97d91f6344b9d5657fea16253f62a0e8657e917f03471076bb74f1a808e0f67798fbd3ad3578777001f18bbb0e45c47c0e49df1e93a6be1464bd1471e2170c90d344d9cb51a84e91c98c1f63cf1a4994deea65d8547f607b397beb7b0eba78d2b3f56ee1c9f456e7ab7284c8a582949077baed640f3ddfab04150441aa262e619e3dd4b19b6eb3a7d0aea1883886d17d18cc77082122cd11221c2612767e3350b246eb0af1a5cd87e62837fc7f0606930235220703526875baa4f7a9407a312de766be2a4149a1418aed888cc09c6a569244a7e7aef16f75a0ccbfada67f98cd6230857e5e19ad2e65cdcee2ba82d61f4fc03f4ef819dc7c613e60629a8bf2f3398f453cff3c1ceb44889b8f929673378c0be9d0c1e309888536000ee0e613d92cebc02e4d545abbab3a56e9b4e86292958efac8278083a6584a7656c0baf310e0a2b96b6d476f38c03a03c017f48b6cffe24422f642bb37d62b2e34258895a4e8ee151dcf9c9893208e1683f627fbc5d2b33fe234cdc3be4f5ad53be85830e2ca1188fd712f518ed47f041993aca560c21ad582434eace19c9a94621689da92d7e29a97202a5b76bf514d75d72897ead3c9a6421ac0dfe0c227aa2bbccecf34eef30fadca5d88c64f0d0105b08849d209e099d9ce8bfaa931894a7762874a1ab0582d3944f8d73f25f4bacde763101fbe73280f2e67179c3d6710366d2b92474b15d772386ebd4b57de4105f105e2fec62979d54cb8eee92450aa01b5bcb55662df79bc2fd3c931207cb442cf167f017e76616cdd6c5737f0cf76012f59fe4db92941cd5f14ddf0c5b858eae0545de063f2466465ea91adcaeb8276fd88b87d671081eb8b2532f0405c45088eacdc0f68130c7f2bc7f8b15dc80cc3dcf789f042ac1481c50d283f812d6cddafb24f85d3fcbd72d95bfe97126df6f300f3e64924903d1f1d8eec6ecf0417865e0aa284c787fb90da5ab6ea26e17be1063bac09e5667d6b1ac9e86e6b7571c48554df13095e6f63b88fba37f09787891f02179a4a80049bc39b64d145c0d427655540a7b82215be30358eff135cb5767d484676563cac62d1a7fd101f676f169513b4b87d860f8e6cf24f1cddb47719cd9b799d4a77219eb29cdab86c44c42fdec56b03fabb972f94486fead1a523d2328a657e87ed260f3d61f2169e7f2435a180aeb5f98dd21e5bff15d49be44c9a0126c88275f33224b5e58bbec77891b7072d2b92f80d80088e8e3e73c1bf20d6a97ae15a32b79cb696f7b6e8197d6c3b63b49efe777ef87a8349dcb7efbede1773faf1bcde136da4b3adfee35d2857c15d0f4f6bc0983bef864eb109f04fbc720392c31a4dbf8a95db62e4d3e9848d26f5ca6457100015e445d9ca36ef7de62ef554277715bcfb1ae3443faaea0b90aadd794271ffb6920e40fd71453ac3e879198e5cb79e55468172af4f4d5aec29c3da1f81572b69a3cd34a0272ac1583fbeb9767c3c3b44e43f6777a67ceeb486deb3388153c0bdd675c27dfa02664741d9a02b6be773469d8b227c59e39cc6cdc04cad0d665cce3f59557630616e2276c2f4a061d1826a2d8b0cb16cbd7420b140ce60c98a0fbece803e132ce0bf5501009cf1434e16ce5325d62b621e35e960a2e59401e3441ffa9ff58de8ac861588dcf2826152445d9a5c93c364b4a36ddae37a545e53ec80ce986b761ad66949bf335aa8e73742779c1ddb1ba9956133e30e5be42e6ebdc7ae4fe6c8b4519d167dbaf215b248b56e4b7b92f6c9cded272636de1d8165d81e8a0b998161affe87650206b009225285e8b97310dfd2ee0be4df99c9763efa3a7cd38ecf0d82bb74bdce0ff9f669313404913aef53c924c3b06eeb40d70b1a072724dcd661801a93ce001227a1a153308d59dee90fd838cc39925916008870e07a1e570694f4503786828b2d572d24d9e7c764cee585e3749ecf798b6299e55760093e240082d12002a5f6ee61af7559cadee4c02c68c02a0996003b0681ba1fa15f6cf595bced8d626fc515922b9a99bda5caa342bc2ff916231081a8386e962d3cdb43e1ab3e7b17e836f8954dc0d6d5fd7360c037d751714820966fac976de896abfda69fdda0c0d64f32abc0a9b2a9bc24df2fd66eee2cb95dcc0e59e960e5b1d03f52a3474eb452d1245a24a28aeaf9a05216364429c43bd4b173f56442efcd96a5d7d88c90ed4b3d50c1c1adcce4af1f9223c6857ebdce19efe979208368a098819449d8a61b4d77791b2ee294039040186d581b3b60d8100461a2e3f0c26630f8dc45b6970f1a09ea039ba956318650fa4c1463a56122629fb683a654325cba31f4853fcf375b6db233c012c06029c4959e505454c92099fd5e57c01b2966341314beef841f4917f9662702518b541b1396b7a27b2c9e101ce71245a2f01fb4a5dda67e281d95318a7656e954e8b246044f66dde6804e8d9714fd32a270f3dac5bb873e116a62fdbe214ff5691c9364addeae577e44f00c3cb57abef571819b03b75313197f35b373c9be62c8b638e75f9a5464fd6b7e0026bd4b85130e0d11998c5399d911a4323c841c7c03bc0ef1dfc384e12464959d35bd487f9ca51871d71b5351d2e79d809b918d993448814b20b090fc2b9e49149479c44c61358942e5aa9057252cc5462c8c30ab10d98336cbafb16d47dc225937c92501938be19ea05d8083eb63aff7f38b8ccfc5a97fa3dc936ccbc44273e5335dc79e1f01700a55953bdde14874015e9f4865a1b34785ed961b65c8402adbab49308577c004e7e46e4e9938397e6f62c82a730246ea7304f7f6a8d31ece30f489c11e0ac67119d45c98386c5418fe9ac113df3b2a259974c0513d2d917e9ed636062b6c98864255fb6c7e92d3c1217571dee0b21d7213b859326abbc07d1f0da7db414721a9e74198c70d404c29dac30cfcc64cc7102d075f8daf6b149a5700072a106d82eb71b79042f0e8c838ac3395204ebaae5f81dd8a319557e09c688c6bb76bb231e47198c98f9e3e2f4681925e0c45c51c6e53ee7b647e41573ef3a613cb7b1fd8bfec85b49d1ebffbee76cbdcc4f1d4b606ec05caa75e28d0ec809eb7ff8b373e9e24acb14e4a0f6c5fd1877264e2f7511fe71868fe79ca68075d0cc2aa13f42e676a3ba53217800318b7d7e8f04e33d1c1d3c71be830260d3d1b12cd9c09ab7dbc6c43f19cab17f67db342804bc71ebdebe2e266cc92d1ef2d427a67a04888811f47ec583cdca619a8f5fd36a0e01b3f42cafb31e4fa5eede23f33c74a9f3e507422040079ff931b916aa40662ba2d39a13e7125aa5748102be69065770e34ff376042c352d28f4fc03a3577cd265e91385c170eacf59474235dc829d9ba96d0109f09e80f132940a4120c15b5a8199bfc8f513d34b0702048685b9818411ddf0f801b044d1530259d5c2347e2e55e65a04484705c6f3bb60f03ee20778fac377054fe4c4f0af06ed59b300f8c3d7fda5e1f8206015b4f74390af3092a95ae15fc53ed5c26cc7398647224802792ccf83fdd57fc583d8f4fc17bdbbdf5c8c60c65f01cb3c0826492aab31f893149bc561952775b8085682dcf17eb46ce9ed9636027d862f8ad70ae033bc1472752bea585a76f28a88039c1a753dbfe4a4e1e2249168ac180e9e7869d0dd8b84e91239abd898688ed0bf3b27a5b9f9ab4d3e88b8e5a05f8295d9a6b8ef6b6c445264ccb018533ff00bc8ee930d7c787509718bdec98f6393a95448c58022ea9aba0eb496cc75dd7a7a795de3fc4c8ca59cac4938ffd5753631a3015eed9375f3cc069dbbca5d6016fb3deb9d19c34b6fee5bcbc6f0ed753a709a867eaacf48bbcccbd22913ac39fdb2bae2b14c43666c180f3d53521fd6c7a9f1e5f464c529f03cdbe815b2568f2f9bbd759e679f4118246559c3e8cdd5b786f48f9941445569399689a51b9a0cd976d1a3846ad238c803fcbb79157cca8a8dc40482edeca17eacd1acebf0762be3e4dc936df6b462d488fb8de04f32f2f41009d233008d54b493a3b6020703fc7abfab412034b0ca5f2ec6ab1511f9c541c973fc5a1fcb0237d00cc536b1749a5effc5466d1919528f04ba948076ebeedd480aaf565789650be19c6464112e02573da35035a9ed0e962e5ee4d4872f903672caf7598ed9405a9ab7a324c77e453e30a64f8ffcfbddc4264806a268a14b14466e030b66a4209b1c7fd76f296120981b80926896a7fbaa98d43f829172e994e28776a63caf6d817f16cc0a897652186e7c31feffbf6cb0cf796daa017a8382ceed5cf2e31596f76eaa3e50fe4c42d6e2d69c6c8d20b85dbb6affadc4064a4bac05cbed08190666a7503334b1902a9cacb3cfb827341d85526489c27faa786d06f4399eb6976e458093d85aeceb83b21328c5486a98367ea37080ec0cc0ef05bf529c07c91d5edd31df55d055d652f8690d7c5ca300342fa060d46adc376dd10cb3444d847f73f2dca34a87c10d96beadea8b2acc1d347ee506c4217dfc1b129a0e5d2a2c830e4bffa52520475df0bc922f4a22d9168ed7d03e8da9ca3b5d07dd3d0c1e1db39007f397b7ffbf65efcfb9bc622dacb2b8f89f0a3440f8cfdc7ace572a2322b87c0b7a88730dff196c40af78b0d90912483a7c63d815b798b4b41168698dfc5f1aefcabb9882a069aa9450c6e14c89379924edcd78546082a31c1b384746ab45fc274c387a49c6253495a60094e7d8ecbca1ea8ccbf25debf9635548374570742ab09c57482c0ce7226d308ce7de57f5537eb539efcbb5bb85df748a28cad1785f03b2617b6a5f24bb38298c9ca83e54e23a65a1e1e5e971df4a8a9936d7e36828370538b2c4116c9da1b4b5eeb45950104778af5276451c6f4d91ce07a436fc5ca648962f7d79faa4f568288eda96252e002e12711d3d6312c412604703b027b1014e467359cf496fe69ac9bdad0d8d4a69fae3bdbd17e933d4c96bc032a19ff7c1ad127191381e0bb529bae81f10871dfe560b3519da34c70d095b5ddba1b062eef30c59970c6100ed183b79ffd966903601cc6d42fc3bf412ea110349b1e05c0f3ab5b0af06d9385903861844af41c7533d89db2daa494ad557f6b67ae0d10d9010fa6217ac1f72e39c8548458202ff5a6948cdad88111191e85d7093cb60b3cdd1020ae1ef9866120f9770e2577f25624073db6e7256a6264ed40a393085a5e1583502960debe548f22fc74f1e97aeb68a73d566cddee177623a5f1ae0c342a3f8ad0a33a7c5fe88e193ea0422f292bbb78d3f6fd173150609f3f0f5ca896db44fd7ea0d842b80497d20287183a17bc627b56fc2bcd24050bafcf0059e5e2bbf63cbe886148b903ebc9105df57d8a29841edb0d90b7b81598234b3d5f1db30ba3a592ed332bfd77b02d6a3ca79ecd2793edebbf67d1bda8dfc3c9b0612222872ed0b6d49c902592a22587dca0a8320d77b68cb79f1727ccf14c39ab75b5f5d356767d227a2ff6a79dec04d3102c5016a1a646bf123d838c64f3a00a90ef2a8987730de69a4d82289726cf260f3663a809215af19a02b1799e894fc900cff45c819c51ba8ecfac4de69e0377108d2b5fb4549b14a5b91a271ed0ccbed611121b16583cee74e17b8ad9b2c0a92f9e98c7a2943a2f0d3e2f044b88a55ddc42dd86901edd9a6d74e3e297cec1227d964ddcf3c15076874a530f345114c19c507fb665cd15ba324ce5eee99bccf78b404b2b4fa28210f9d7e7aa214b39ed70eb719e184267e00e23163de487ae2d49d898f03d48b251f6c77bd53bb0a6c9f8bbd46802543438bd2609ac6010321f558f0234aaedc86229b9dc9efd9313b7180a1fc47785683bff598eefbc6bf64cc2af87350b457c1b85bfc5ffc15360c3d2ce9fe4bd61c3ae2c315991e259838be2ed69ccb3115a38f7d2019db32c57586c752c4b50e544b0a6e30ce5b9432b0e988ae123a34e5861ea566e720d498ebd0d76b92da577457d4a16d721dfeb26e1139281ab0f07676e163c392cd28f88ca8b9d94878e571292cbac28a2dccc5f1afeabd6bc05d7ed675ee988b7821105a94788c847f0add75b428434c8b337421bb2fb6e82922b9434706954a69a2279df30278b3bc38e9554f92275a957c8034929ed3135c9937c8300dd42cf024579affff45f680457dd4a45e1abdccb893e7ae7fc2ceed29cfbb22f10460afc446b9b99332636d72c5bded24be5f12c5c271b36ba9245e04e600d02774aaaa3e83b657b84b17b50f2b960d4399c0bc52530aed07aa14458e19496248c3bb831a78d6297320eded0b07c46838ccfb0a6810d56aa318925d6ce64dc7d1d762e5c7da516214aa4a435500df925961ecd243057874b01e7f8c81c7247df4751262b55c6a477347a98d029a37cc1e9914f5c4831fe063563b71b0c3c8ff407cfeb31a3cfe54e01f01b7fe754e0f4712ab50fa806101e1cec05a1328fda1904fa8e62f24e0273652f0c9099c636c16c95aaab96893bab2fc0c768e3909bcaf148c46916d0240cfd8df90d770e157adbcc1464d91a985f1178e73b13cbd33f7e1f9b8fd5be7026f630e75fd1b58dfa146b1f7b11118cf1895aecf53d30d38fdb361ea5dead90d71b394413cd60dc0d6c792ec75cfb7428028938dc01a399a88a1df4107d67b4461d6cf061abdfe713a34363dab24a85e3152c6ab0b0cd8cfae07d195ce624e4dac82a2d5567b583ac70552f857fbdce9f5b440aa72c491e6ccc4a03eb5396d61d4b594dce1b99942df75d7c513bb0975a93b4d87eb4216f90e09a9cf77f6c3e0e047da487de9f4e449d23ccc5f7d7c25f514df8923f395d7fa80c8f5b4aed1dc72d4f2f718ba60fdd4f0052385b774bb250bff85afc69381c92702de4ae6bf00fee4abe6602c31b732d6fd3005097c71b13a9b580dee82c1b1c3c8a8fb9c2b467567323e7c610bc2feb0634fdbb6035ea2742adef622bc8c5890040bf8dd649ddb67009ca5f21d6712139960e2e5a505c8b31d2cad66ef428af90b85a7253a6bd2f15973fb3e3aa06a323a6ad841471728b65656351016dca39a0e62542a6f2fd3c21db11269764c642c0675190e856b231a723968dbd234aadb93813b929c38d40f5105acf71848c3b2fcfd40d50b964f57c3a92206c2ac520424e0804cdda72d13092849fadc4cb851c7a3f46dfd5dca63c0d3c53a9492588881b891366e3f68ea641de19122ad5c72593ddaed265160b31911d38954d478519c7caeb50c01bcd3eb8b552950b54ae0511497cb541be872042a90453424ec978c63f584c9ca6ad8c1c5c993c767dc05eb258273ce014d776c9e22ab75762b81069e6f4d9ad232111ca6e03b83f3039a176cfd7b73625f75f0b0150be6ee88a972c8284792a0e4370a053aa25fe739031b861b9a46ba6cf9aa250380416b90589e7c609e05bf94150ece2a1b8dce4c73ac0ddb1e9870118a430a872393d3a117e9c65321f5f847543e58e6d7c5dc66dfc342b674667fe963cf748839192f618d8341ef23807dd89b50b0f80b1f3b75a1a01b2cc20f00f2a29af72b7e380453cefe1e62d01efea7432b5e9db5bad5de22f937a057be8350e0844e067f761025645c006cc005a284b0d24d2a26370240feae202b761fb1bd7058f9eef0455dd89069d07d1296e321e7fef9f0143dac199ec3a10013ed711a83eb48717054da3a512a1f467b9d75e01ac9d08f6fb0b33386f45dc750155ccc697a81863a576a7d7548d1c47f018ce2decd071a8a1794d7656bf1ab6a2a36fc7a1d16a383560b6bc120614294bbb13c399064d0c55ab81b0a95c29f952ea55a7df3975cad3e93e57165ef256081b1a5348b6f2a9dcc16c163d330bd9a4cbe938edbd507a1b79910a9a68353f52c4469716e4a3b957b10d5612ce894e99f3e11611d870d079d918db24c06666113e5f0cb400e3074d98c6186ea778ad58648a870cbcee62dc8b70f75377596f985a7d6fc8bcd854581603ae51e0addf4bb65ad1feea1788b4daae3b2152b31981c3db1329be92fb0d57ba18196a5a2ea19775dcd53b081adb45dc85e0b1c82fc0e2b12186706c0c5266c04570baaa4d03151261bf4c451df0b0821c91bba01c1f9e3b053418c09b38f5763ca4a85e1aa4b1f07da09e9de65048450ecb535d543d13f32d9788447cca508aeb22e4a2540a111950993748e67c2b18e654c2c647feca373d32eebf48a008318b3773e1858b4daff007fb94639ce20329bc6357c56568f83a7138c995a13bb6a13eb22708ce4af2e140a10cf2e69071308cacf0f5413faa5ed06efaaeb3945e94cb59c38e32e907d8527aac3ba947ec18069d4db3aa02f5870f1f1f48ff22ec7f2b1f7812d9e3724016392692983fcc06fdfdb4493d104a6dac792fc5ae8ed0f544237f6faf328621be0faa21e1f32406e5b294317ee938180ec30a7860c025db4217141aa5114fc2644072ee8e3fbadb6628c60e9b27f5215f71642936e61a43738e8a667f45fbf86beaa0d2e16d79b90ee385654139f44c73efb6b696d42ba879010451a48ebf267a4c0fff226298b776fb19d174a7e7f11ab14dff0735b1dae4df71ec243214b67e7bc9a98c2c5129c4746309b2cb08e266115d1c7e78405d16228bff253e75a2bd3ff3e9402362e28eca9177e62e8aff0b4686220b0ddd5887faa47b82a3bbedf6b635bbc83dd3fecaa011023f15619d4cf3b3b5e87f5f79c0bcc6b3067e931e5fa057ee465cd13dccc3d36ce5fe87db42b767fa6a054164a7d6298d8059c2c3dadf6b868353a6adb8055f44946aac30679d42fbfafcefab27499dd7a28b88cd93c84f4c288c2fe7e32533ac16f5ec651fc5d17867631950ba69035b938fb346dab77fd2f83214503c2f92aac3a930f635b0fcac8b201c259ffa1d7043872f00caf65ebb00f98222fa8f1ae3dfea2fc56392719944f02cd599ec1a14a582eb48fc765c47a9a79e2b5fe4d62b0f0676f12c847d06b182216a6e1cfcf48b15a7ea3097e4c987ace7c02452d295f40d56b4015232ab53c6855a473d66c2b997cdfeda70ba10e1a904e23ff7d8707167f707e9121743a447d28b0f3a273ee7568f4cd94c0fe640d6a8f6cccc4a9c86fa912969a006c56ef367fe8893d8734b70fa057ab85ad6c69180cbba3abcb0c17276dad1fadb238343a9b090c446910151cc42f9478f371f24c45b7fa9ee4014e88727843c859507b2b1f2e8aa5d7c549e738b1fda565f83730b496370775f42a8e2989e191dd6961e287c0ee684acfe1bc9952e733a705a58c9417512ee0e95446cd562d1d34a060f1e26a53e7a690708d47d27a72101c9621ec8c7a4afe5fc7134bb06b4ef47e9606ffc779ab2b243301fb6774a4e549b12a35427b751c7d1d8b0990642a83c32b2467b5582147e15e7051cc19b5253d5b17075f7a0ffb7d933d2dd2de3aa03cae756e05e1078cb07a7c627b53714d825719dc4f0887155c5c97fafa227c2d34c387a47a38bc0db2a9a442731050416a678e568e8aac9296c729e5ec6a56cf2da62522a5793a6c46ae65440ae638d6624051701f6f7fc16b85070dcfd5f7e9afa5006c116be24e1c05f1747bcc55a95874fe2e8fe3caf0b81c6ad2f9c8b10fed074140dff21c7e61beabdc25411ff87e751a23ca0a2d4a78437af38ab6c2a7e7fb02b360cbed95fab7554954939f4c70f0e651f217caa1decccd11e715494b4cb5a3cd573b9e0a28f1a3f0e18c5ff4206ccf84a956d81aceeb8d1674e5c5150d03703bc3d29c46cbe7a77da4a0ff131f04cda95dc6c2b0644494fa5a2f0d308691d889135ede14b2e7fe83f4448193668d9afcde037e42d954f321799a709d13f93fafa90ecdb6f4b999d35a9740a2ccdc65e42158b5c110926f4697f0e6e71da38f787738c75ed3ced158f54d5d5068a0c7b2aefdc4d8a0c48c16f8f5cb5128ffcd15e97746305b4f89bf585ea9422623ac06e9f63fc7c0559d033e436e898a3eded38b68d1d0e7daf2ded4ce63663921e443e1fd0d1d2fdfe2517f938f255f63f5c527050ff95e42ab6dd8adc1904535fccbba1571ae2248347abb112479a2a2ffd15537b4ca03b0891058721de209caa57aca8c863af0421337418258c8cebaeff74100491b736d628df5683ff8c19e033e5643c0a37e97f66297e6141ab51db9a1d79b1bbe78299938a5edb6e6ea9f489dc8835345dd2c2ecb658a468d62541956dc0fe651c9ea9cb112e273181b060a66cd80c22a5d88f90a9c2371399e9c84ee24a38576eb38f4b5c86f74a0cc7b9952f702c4ee1e5bf612acf7cc923379b2146f456a50f3f166387484cccee4ce31f785b6ab38844a83859c868992b0b77fcd0457958f66c4cae9fc705c24e32b74002d1940b5b00bb1b08b92686ab79b8fc3d838b4fb1fac2c000dcc7e7ff2e0f45b38163507755b5dc2d8b03ac4defa18970064f661c330f4eb52777165f410db6ba70f63f57b19b755b9c20c2e278c6926e3aa970475920ce54413a66c25da2e8030b91d941e3e767933189a75a8585cf9dde95c6c485f09a0773a6fcbb73cdbcdaacba4ff0d4ee5bc10ca3ee0441d4c3a40260de0c08351543780bb1796d45a07612575b7d14a71fdda9ca3cda237d42ad35c9bb8a6ba2ed481066620a9c5f9c63f4ddd634534944104f00115e4a9f23e64d998939e5c3d33e78be7a8b1e3d1d814f26dce278782c603d17ded60541e754e7541f9e95374187da44c7b2994989bc8c5de096ac04bcbe96ed4e5e9703f6f1841f596dab41e9e113b968d04a9d3a5cccb394456961d709fee5b3fded6a765043b3e7b54750de12ed0995549545aca6d0d3b024702dd9f4d6c81356396b4544dbd694c9c6f276dbe0cabb6555a39e12f30301ccbd1bff123a93d450ca19b231fa394bfedb7f1f34db496d9e6558e13aa9537db1c1b4b6022d66748f1d38b996798290a4d8b58fa55e676ca3d2a392102573ceafc3dca10c3c24c3b5d304202697ca9e2f8533052b728c6533ef7519be8e1bfddc4b58bad0892b5c441c674ebe8d56ec01615cc7d8ab8448fc0eb87f6a1132ae05faaf47e8b99fc2295ebb61995c15dec3465a8409a6b48869fca2a1c1c9dbe92f8762dfe2b6115092c1d0b1a4246a2098a435e77081fbe30e35299e7f00d25be021c5034402862d60a7e832cf33453e394f07a48a5562518325bca4b6133228303cea4b95d5a16c3b60896d362f7069ccc575f02d6111f86ec0437031d98347c0b2f9bf05372cd1809f670b7a09dbb63f38e43f3c8c6a494836f2555f2bf53eed964c69b72af4fe4306947f130384583c2439eae1d3c1282b55c056e7f0d25883043237cd765d2ab6da473099a247d4f1b1b7f7f5c46f11be698a74f2cd60c3a5fdf42e47ef4dceac7631ed96881c955f3fdf999acd7114c83a901cc28fb6e9167c5abca773193c2924f4acc54d7f785a1987a560909bb5adf5f12d469ac1736ed5641ad89d8cb9a097287cfc8c283249630fc48bae1497abeecba0771084fa611f3dcb8a51bb8f3c5fbedf9eba9c790f87b40fcbd5217a574b616d4dd71f0720da44ec48588ae0911f53e30dfb2c550f241d410be171cbb07531226993d7013adce8bcdbd55217ea53dcbd3cbc9826a6f82ee935f8259a4a7db399d317043d8819473129d9487cbb9f209eb2533d2bebe496f8fae434aa1c7f0da02c4e9f3509d7cece75b3f819488d59eb6088bc3fcd95066ee5bcf367f7c0d20131036d021ab4f394392cbe3a953496393c73f05fb6b6bae8e975d8a0600ef1e0815ded507fd473135476b8c4f45a335116f2d572426b758a3d9c61b5b23e9ee552a638f182e1038cb0c4ab2d067670b11a421eff825d8b4fcd681f7f4e8d4f02de15f08f3e7dc8e1a32ea227b29c7966a2a1192a1d0d97824ff8420cd6980b621b8479ebc2a409c6b1153bc721b53279ea4c5e4896015beb56b2d14e2417ea629228fdf8b123fa5e3f672a806d95a48970d87775c6a57eb6660f69c442d044537c59ad17d0ea0af41e4046d792a1538d91a7eb3a3861f1bdc5b972c4ebc587e8c01c40ae26c8299277667f2fcd81b65bd7b7b70948fd89276dfc0beb1348c79e3baf107b21db9dbe96af71a5bca0b91fe33090e8faab7b55b3726103d8b5e9bb0cc603941f13c157ca6b60aea3abee1bd80a588e4d78bc4dbe414752e53e18779c9d5479de7cb5f2531f3c5ec37af5d01b3906511a0298eaab2cd6e7b9cec29137d727145444c162e2143e87d5ae54ae73ee5594963c73bf782ff27283eda50cdbd70d97faab6f483cd0e1b876e7e1f6dca590bc9732ba3c79a58660e4314c4425b54ca6838e73e2a4b7c753d54f82a35f0b4ac97d4ad2178ae4a384899e5c3d1f867b5ff096a86d113298d4184b09220bd10e46ed3496a4bc0632bfa7d73535e2678ed2b798ec0f3b48e27fdff4ad1fc6e178c4da1553a00d4615bf917e8b71cad9be426d9aaf3d5b761a7c8e50ff1fd3c7a33c8642a50318ff0b99341d6a131e0bd099e82feb3d0a166f4a643b4a5ea130b394c8018734621298e98fdcec61e2a54c3fb61f8f679f19185eb6e56ee85bb4ef73f9ac976e2e40e040350b66905594cd232f3a6db67ee3866165ed18374a107039257f48f6bbc4ef083b6339401bea93dc2c92bfb429e0132fa2ce651b5415a0d298af42a2d8aabeaba2e0390a7e4aa5ea26b858022f85fbb911925f906c645a93c44d881dce16e10ff16e1b2896ccf0d932e57e09518504f63cbd849c8286bb47d9bba7492f43b655c507a10b4c0eaf15eda97cc6ec6cfa6a70431635720b67403a575ba5b1787c3072d1a1d6901f7b83e355196206f760d2e39c32a4b443105c9e6aa0615e55e5d9923d828b46ee37edd53a609b76c19c076ea1d6eaa1476a8fc685bf8687ecb7fc8f7610dd5b8a1ca355d9076485d0f2acccb1c59d79d36753ab1efa946e5c0ee975c209303a35c6b49194697388d41cfa19eb3f0a96d4b4ec7bd342e40b00716b54589846e1b4e5568e436fa95a183d4c0e3eb601f3a5a414bcff054ce68ed4daccbb2ec03f05611afbd65da9432c1dec511b731f5aa24208750ad72edd733e3d8521cafa4b9e91fd2a603bd4f682188825138a024614ce75f310b5987fafc1da6ca699b95848ec146b03b69a7b9d9273b4a4e830e1cb1dce4990827220ce080385b68f026a2bf61dca7a64033170e002c0ab0f7f7b5e22ddde768f58bf8145aba33a976300b77057cb97442810368e4e1c6077a095abf22b8da2a2451853f1d3d18736e41a7b219be45de161d0707715a363507fbe0ae28e01c532e6a6b86e9a238e39df1dccf919f6d3fef0dddc8f26f5535ccfa8c032081def00719147da26028452b46a68748","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
