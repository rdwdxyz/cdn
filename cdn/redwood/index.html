<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"058982573609a5fa1f5c1ea0a6e4285bfe14e45d96a61f8402bd22d9f78b8883ddc67e2fe3b766092f93a7c9fd30835a82c3f3cbdf1245196cb7af683686e78229e8ed4ab14e1e81b14c5a622e11400875dbfecb28b0e761bfb1fabdf8adf62f889f6f6c1a2fd4c1323011394a369e48d3f119409c6830d082620e16d77c076a313df95520ae271d9f2fb3b1aaf8a84c2af6ffd4d4b0526f1a053e14f3ef2495b99e0286f25808933ecdd9fc07b993805e979db7476934ded07e7082fee42235652332879fb81021ffed78e04990337f0fdc11912997ae74564add20892456ee16d0097cd5f0bb661d15d43597670a4107b699d0dae504717648626ba769759efb06e86535bd53f51b294b77a80f26034ebe44cfc469e718cec67de79f187c2df626f0838389d786764a575c5edc4f3b120e56361c6741cc17047744e57261104c70f45d4e01c285a480ce9949f31c7553214bcf2afdad32f2c6135d877c68db0b740b26de509a9c42c3963ab8cd09fb8e386290a605977f32e0500b613cd80fe4da05629e5501cd458b2dd3d6a32de84c8789706bd8fb8386645dc37caba36b1a3344dfbf542f7ab60e4e52da403b6d91000f5172c9b5352bcee18f50b32a47555ec50e92386e60ab7a86ca9118d7e12e2c527af3f452d09b0ae09712495e2328a74fd986cf2cd3f8cc56978e5c66c665b1651ea9aab2160d881063b673ba529d36f005c9ecca8bc1128a33f68c66e6880872022033801df6ef56dfd7805db5ac590fadd585c7808bc5bca7e6614adfb7f692624585b6a614de30fe070ac660177976c5a4c2f9df590fe23da2b2fb76629f345604a25bb28b686501f6c23065f083170a0698a9d7cbea59fff4d279c8879e49567287e8cdb1b27d15c09f85330a29a471d7be168c4823364282a3968551881de5e551a21a6a676aa3a88a40481141ded121591cb0572e62536453ca301c615e253a9c48fef2ff3d307f018936757582ff82f8cdeeac6ee60d123afe3b293ea74d5317272d7d574bbccbb3d955317ec44bb31c14cb45d4207c714978903280c9b4b489f6b02224dbd9581505d7dd0976bcbc14f312781dce9ba8254753c46a91a7715d1547219f4dd6bf1a108f91f5faaa63e4b4cd6f6acfdc9e139e31a3a7e978f8139e1a3507712e253d523a47e5dc03a2bed343d568a74e408ea257ffdefbac6539c1b95c26633f0f295f685c13277f0b43deb12de7a565160248691c5e09f4e8a266d5fd6fee28db3a6f04a27f2352220be31deaee922b756b1dc3ceafb245c0a99a957586ce95f1c4349a181dcbca22302dfb18bcd3fd322414b3426654556b26b721f6522b30898d50cbdc47033120d47d61f8b8796139e319c3a8eec83f69cea97900193ee533d8d06df25c6f25a734c905610bc1f0885251bab43254ff4050f804e10079455e459cccb3e5f4a42936bef76f8c20f5d2d51b02503acd3fe752570608459f269c1703e6c423c7da876e127bb7ed3835a2718c91ab39d715065a693d24a7dcae4533c61d76383402e4d8b4ea34e94e14669d6e00d9c7977d64879777c168cc560d1694d0b1e31c371eb09baff924ec5943083826feb9fc079f502af3da6a567719bae8ab4f8d65073ada3d0a5a6ddcc5d2a5bfeb8c4f7e11d2a842eaa165e4881a66e15c99c28f199aef494fd55b5a933645794d6f00ef0a2cebe5f6443fe14421e9f0dace46a26e1e751171eca06548b326ce7a5d7955c3869ba39a4e4e5293be19400de288309d7636d638152661414e1bdf84f05b6af18719d24021377e2cefac4b870984e34ceec756cdb74b4b736d1cb5d86cc7c82ba67fe566734d56b88e4461d3c0442de46be0a4aa9174bb83047c9d3263932f804e7a228008bdd662098716feb695602a285e99b66bf9b9af025059fe005844c6f4fab97469089a669d28b9fc9618d8f6733006ff49e8d7d333f05ba1cb52267b77b5bf54a53e986baf8efb3f489bbfd06999118085bbf93dc9eaf5500e57965ca00deccd462b45c956fc9b113d9ab373a1393a72a558cb90cf3ae8a99c64f8e639b7c48eff584ebc7fb00f0f5ad7160775dbded114e9828f12d8b41c771228a2f448e90185af46dfe57c6d42f39ce7e04a6b3c463c9239ae848f22c012788fc0c052a93008aae0ffb28873c70d92e5425fbd2cdf24390c2a413ab347318177406ce92a9461d43a46b23504846f6935ed6f699e472002a298d23f8906f3c846061a1a15d057791022dcb5bafc66a817b05404e535bb722bd38d8c3a8021dbd8c70b6e4d2ba8b24095e0101d339bd904e1c3cf5690430db0e6b874866c5cd2f32fbd2b21073abe6c7372bf57507940bcaa9d6a62db0bd911e11cf2e238f6b857456843b6cd44567c51bc4621ad79b81a0e64ea28effa268170b46d32e1ea11271cf3b2107e303ece084c7269d1714cb86f1974ad8c1ece533f0555556086651aeb53430622fe305dcd8827a4462e383f35bfc31ae640166c47aab879a8dea4be98a6ed49246c5f6330c6509512869d07dff0846a11f0e1ca225b047619efe03f89aef3a74f0394f405c76b66d992e6896e1c9f629a47d0dcf777124d9b93a81a60a23583e2ba8202da72f552fc9edd11bd76d339fe657653c21fb6673cf5d4040dc3c249e8bf0b1011a16ee04fe477d484bc026f230e914790e4dba100e1b3f608fe779436aeb7ffb68f474cc75c21dd896cfe569a940f7bfea0b61a1f4406bf7f65403c8343cc31870fc241251c61c9940619e3f0504dbb526e1eafd8ad7059c0d2442807e174b30909d5ce90070b3036383a6f7b388b88ed12c3238232019d25bfa02bc030e2945f8c41d198d2ed3a22d422f1353e84e5922b05d5ac98b0af9a7b70a9738c88ca0494ae4f2e7f47cf04a50f2e7739c1bd68cc5037f31427776190673c0db1f19e7d96bbf8b2da42271ece4173659b9cc4541a59ac46ebccb051b1e8099c2f9105c12e3a054972a4f918bd67c1da51137a90a1f0bb2875e5bf0f159cbf27a27824c61658e526da8d1213242e51ec37e8e589e7a22b472cdbfeb117376df902b2f45813e479209604f404a1c41cc43040522fa4c3ccf6dca4f1ae4f56cd974b3b9cb920fdc677f280cb40b0d03cb3e2f51d7a20a9e1ad48ca1933ac72549b7bba10328d8972d5d5057c43877753cc68e2a7ab6370ff01c6521fe6698dd3280d8574f5ccb20020308ccd858ae4901410ca206e4c90dbc092ce813ef8eaea94e1146e95ae022fc8010e41f6d972ad9b19ccf62b51f39426eb7ac93d7636bd00e935bf594ce9bceea7dd9667b4cf31954a48532d6b04d1b63ce2cef986254592793dc8e89a1f274e765413685bbf2aa7b00fc3ca2a23ce4bb072b9b5034af952592b47e435cbad2f0212da31044b19bb4602f529694ecf19ce681e04c4f49d98e984648bf3e37ec5597595ebf20436848f0b37917c5a994441399ee98d73adc40e8f2d6ddd7a12f8ea0363c91eb341e63506e1bc20eccaff90e4f8d3c5936497aa5f2bbf5e3632ddab3f2db66863ba1256ffd0ad2a6c3d7272a13a2d1e5297797fd843cdf41f687de9fea773880c67f477b8dc4460b55ccf4126e0c5a3e989eeaf1cbaafeae2cce6d1d735e2400513655713b0e73cbeb6b9649bcd3ebe67038bbccf7d1d8a9b6001cb2056d8a2e615a6ccf027c5accb5339f6918182a69d89cc0faa808a257a7a340a0aad99bbef9557f92652f6b036b162e287b67cca511be83d6cbd02cfab61b241bbbf4d9da34b48e9d8133ca1903aaabf46db0a46bb82fb94043d89fd727125d7804032d2767d87cdb366ce330763a48096a89777564b9fd4557a0e5c4f2fe188555b6719216f010e784e10fb605ba0fc725299d939b957855e0cf6f31554ee75e53e6460b8bf973218f16ce34ad12c9bf329baaa746e7e5c26a9cf3621383c3c7546ce055a1e456a04dcfc471ab7aa57d8cbebc74470a6928d3104cdc816f17b96e2d819d89f8c1edc4dc5929aefea7d7512eb67a6b66068f9210a52a63d92c4bf20689481f2519783f7d04e66a8717b56273df0e5aca42b4d13f72a575c1dea2e6a640f75a72a7baafd05f3ef4646c91a4017b7e1bd10dabc56d3bc31a39bed8804b26a846e2bf297223aa9ba1fdb94499b8a6c13ffe635c3a66572461df7fe7786c7e76c0f2f11f6fcd82ed0c9cca3c810bd4d840cbaf1b92c3304a000ae8dcf6ae6bb8e946fc78d4641dbe3fa626e5b0fb6ea0733094f1368898aa9aefc92badc21d6a598191638986c74192bb045e3da16e6a9b1b987540b14f85385b8f47c17fbd24075dd786b3a08d52c65dc45a0945ee78e044d115f6a291eff2bf5417a27423f402f0fe2eb6dd15be66999ff3e4c97a3de35b5b1a9838feeda032c658b790aa72e8b9c0cac6a742f3e35b7b08bdc9d64137bf52ebe3770f04f7594666ec4870af8d74d8d70dc11da0368753b4cff9b66c8c1ec8794e12a6f53fcd126745a61880d541e9e8e0e5a699aff010f4bce9fa6fe5f3ffc8293fc17f777fd68c21a6e86b7415610700725a0cef689ec842be4e947a12dd62582261e7aa224d98893d308b7fdc0a3d6d1b33720050ebde1fdce3eab16c2f1c38de7ea4575d816d5bd55619012daee97397bca49f28ab1f0cabf41040eb8ad03d975cad3a616a5a136cfcd73de1e18bedb6667eb8f8f10950a3a23780205cad636cb88c16624f27915bd75f5c0e329df5cc99458439aad5b98c2e6852450114faa89b9e12fddc730a5fa3c16e20d4911692e13af64ce61172c1f99508f00c0757d17bf0cf53fff2eec0b7a7999a90f880049e57884a281116ed96ba9bdec9eccf26f0158d8ae8b2eac633cd5ad8b05c5a2aabdee3da1b790fb6668a641a439afa688d3e8b74775e8fec9c1a9c496dc5b16dcbfbc69a82e01116d2031c2575d881b98cbc33ce865f5664554f172145b9b104f5d4d82385ae0642be9ab642f0c855b863a312bac13d111303f9673efe28fc635fe0abb122ebb204406a2386c50f07efbf0376c654592ead78a887731ccdf1088d0be52e1ec3fc33147b627f0e25499f0f5d3292a9881a1e55799c02f4d73dc6f5c16702d06a96fee91974fe1de4a14ebe6e6b0626318edc63b73c410fb0cdedbd68fa5b1301ee0c6c5bd13c5b75e69fc70bee35ceaebc6858df98bb3e69a5f8f9ce09835b0342984676b1056d8064e1a41ab6c52ef261a9c03f4a544e5c4a1ebb02f97c1e02c2a99296bc32aa4d3034e2a25e4220f7d7c4b19bc584e359f5aa99570d4a6c7da902b6e95d4b9e64150746ebb5711de3d013543deff0739b10a66f349c29ce4f40d69d183ba043bfcdc1029e54449882ec645c0ba3a621c8099252ad5d3f531059ed4c2abf381382f9f2d6b40cdd648e4ebceff3e022c15609b117bb6c5f136f06db06505dd401d85e08c83099cd0e828d4bf683bb3c63fa0b1504608c7cb7430148734879fd90d2a36edde8a844160ab592edd6b5ab20df71e827a49916df1aabdb3426bc335a80518eec17e9cf8bc0930b1378a85d2bb422a664bf622ea745a904de2fbc14f8c0641070ac5c8f81746ddee59ed45a8594d00d298b3eab5c5fdfb4976f5f08e65079f5eb728fa96bb676579d34b0a6102eb70db8f0415cefc53af3486ccf9a62a55f4b87018410982ae48ef9c0c1cc84083ba0e409d20eb8b94eba4c736334a7e75924dffb0ec00e337d72773c27bd4c4e937a34a358e661dba3151429d58e2484760c26517659e824035ffcee1f9e47d6c3d1d90ca8a369e019dc34795dd18d8e034c634dd63fb8112d8303163ea07e8915cbaab29d3646385b641417076c2a4ed38c9616650aeab4ca001578ddd4f5ff36d36e0755da3f4a32845f96d334e023286ceec8442abbff4849ca8a886cbeccdb06f1348a2b6262aa27b730a9d118ae388fe5e1ca1beaa2357ddd5f56e776d1a47b2c3e8307e4ccffda82cfd1d2662a91a64bb841eda64d7a664e9846a23beb61e84461b37cd85777299ba5f7aa2969d11588aa032939f2a0ecaee4867725bc35babb5e628815b733182502ebfc8ce983366d0b01fc3ce170c6cbe0f7939ba858ce791b393da1b421595659d5cc327ac398b94f7c31da3cd95d0f1ca2b21f43af646443fecdc6edae3ea288535c43f11a18066cfc51f88dd2fd25f37625e9625e014ca5025dbffff52cafaec6a4b47867efd563defc6c3aac2b97313dbd48c83a03f74eafef630b234ad8dcbc12926ba38ecd407113057c5bf919b8b1d8135b62327707d3d03eed5f9a2bff121f397326d555e72d6fe656e0127d17f6c176fc4436f69a46c2c720e025e6060b369d6127b241e2dc1cc2b821a29933f4cea8e258f2ef2bd2cb9525120f7f8d20d1422f12e453b6f99ed14e070a2bbeb1ab3118ca1bad4a4358863485835603518de0a20531f67a8f43156d649bb82cd81c9d8beabcbbb83f8eabc9649c2ce281db93d5056c1d41e07855ee0289e92bde5541e2ed3736cc6e9d18ec0e561fffd94fe92a84a78a5f94ccd1cd3701834eedc1034619a824697cb56793517cad927034e2e1fa9ebd79401a0d3aa8f496f5e9d725a1c8adcc90bd5402a5fe358a83878a9aae4298709df33edde5d90b4e7df729a929fbc6043fafcf81c1b2dd63878d244ed3b5ebfa3b54afbdc8c1d8e79165c615e97a0ed95a556b8fa3a2720c781560c6fd4de09d9856e884cb4c90f36547cbcce5f7a12b3a9b7523f7f49adb28ec787ce0813cba752794b194cb7a465098fc5d49e003336de64e28d50227c1539f47ed1ee7ca0655b20d6ad91cd69b235650240a5620debf16fdc19cd2debcf0e430f4df1adccb4292a18f0a985efc3bb8ab280fbcec8f0613d129e48a711e8769b2a9449696eb26da1d3af9797c778b5424379dd8b8f74099b12ca3ea958a928443a170d391ec1c97c0002cdecf2e33333a90f707deaa175438831f26b4babca1d8175133c633b769f8f928c26dbd7ad42d6f9dfcc773ef39e1878cedfe566de9af2b1bbdd904de7ced8ee0267c6e00298605200541641611c1c2bbae40175fbc6711d5bc334383d61d3296f0c105284975df08901f01a1d437f9e7a978c713bd428c7b7a5221bfb7b859700ece23cc132dafa16228000a75163d1b37615a7be940f9bd2d50c7bf111896f6c0c23a60b1a3632dee63dc3046b8f0c13a18e2da2f7b02fa2f9c8b2b22712120d7f36616d9684bdcb2b1bc11a881104332c128902630ae5764adfa8d0c8fdc3726c6758c8fc334a48e7e6a39148fa902fc608e006fc5e0cd497c387e9ac74083f8486f8a5a21cc8a62f3220a7ff0cd9502533672f194806e03f6307774b35fe8a64851dbd3c53a3122a88ac26987e6656e9afc7bc4e6e19dac9620d41c613273b7c1fe11aa8722394e167381256ac750dab404876147f3fb774583f3ac99e6bc2038fdc47092fad0ee2c4cd8bdfd12cbd06137779852cf5d794bc61e5bb6e830687a9d5748e0b4e879bca98bbd44cc1dd563173530b66fa9279225e22ca5f33a2ab5f157d29fef08656e2dd1f87058e6762c51d47398aee574316b1d299fc34f804e6d73e6e7121861a2abe4b95748c3425625d63fc510feddb92ee81183c37e31abc53a8e278389f649a2f70ef03538b263c392258960cfb768827b926555fc1b832ada770481aa8d9286ae5e9fdeff056eb9dfcb0727164a1a8b3cb05f259e509f33e5fec948d924d2c1919a16bee60bc564636d772ca673abbc043bc0c1269aad229b8c1474ea00cf29c9f048ac547a438ec1198601cda418ac6ddbb5e13b6eb16d9dbedbc9980a942d4c57c18716dd7f55b9ab1afb445e28d4f9319c7ed14d75bc228b98a40fc7b49b11461ff222b1e5b943fe35cff5f0ef95ba3c62a5101b67fb614519dc1bbea2de4606f21a4ff1c86a7af7c0efdc60b00485a6bb04c481367debdf91598c2a404d2e39f0efd32c4fe54d697ba07ca5f679a2a7ac64ed58c7d0ea41178a43595774cdb30664dedcde1ae47c5fd3309c17048f5bd8f23be1b459b84b5c685a277bce215365f721d69facefcacbd40d77ddbf98fbea3b7978140e6fb78ca0db8e9feb31f7eb996df86cd40b93408c9d1446f952589a3fac63579cd46928159135c35848f5dad483daa1932b3d371913965a36b20a0998049c8bc5cd5c5766ada1ae45f92ed128ac259a3ef2f0d42e80f4d6771da1d95f4bd057c6fdd36da39e3cecb7700ce034614e4e6ffb043162d66801ed9827869e8d1cf81a7fd8b07a51a1761135ba0481739a0ed43f4aef2b0dd1513432f1fd20ad84bef2d89f8a6b607190a4e451e787118d391eb77968a268fb27f774c7734b6c3a75cd71d9e58efb8f7b556b0e53ff7cccc1b5dbecbef10a5a9bb925d72a8830d1bbd1d310db71a7453a979af745cfecfb0d9b734a533e53105717bdc678795d32ef3615aca20949c1bfbc07a6d37a056030ffdeefa83277f6ce7cabbc99229bc4fb5750c1d5c2507228f0c02cd60e0cc7df05819995da178eef22576e2fea8da502fc53e1c7f31f6c28fff265e1ac2c1eeed9758a67018af6bccad3c77cb1fa855eeed44f757a9b9abe5c4a09a0601b712a8d0f3c5b4326d198d148bce0fd95ce6383b2dd3cca2d1d5342e13eac1b3297baea4de5161ca380e490da7a2c913d92aaf3a266b5ce1d652c403ca97c79e20adc27278fac9788ea50ee6ab6ea8294d6f359101484f47a8d2fef97226bbde496b992ec2f4e738dd5d2f0adbc224f40b55b7bad02a6df5dd484ddae16ba0af7b3032c5777d11020a470c18575eac9879b15094ae30558690d7c08f1cb0b9c98d34c8760b03d3ae2b2231faefd1c0d8cba8bb6bffed7cb32184859d63e51a4d270de3a59e7fed43b788be0870057ea082ee4ef7badf6bcac84c6e8e869f180cf023ae5f435d262fe213a37919c1526f342bbe311f1c933be5e412bf66c62fb73132b8097e647d1c6d10f460dc658643756d67c4bbdce1a5424578842a5c31dfd4d3cf0404fe49f4d2dcb070ea4af3aba0aebefbb7b5968051dde37741d8822ccbc1d663fb67c09278b7e42a3cfdc9f3c25b22035bd34b8c6a744ba34d95147a6103b77b7e01def907510f144aeee5caa63c367c553273a84fbef679beec1501358257810b1fce243e6d5e72b6788572009402ae8cafc93e99e72f8d732db6ba833ae17dbd189834328beacb2c54ac5ccd9bd21aca324f919efbf3e4969ad0aa18e660ca78db51850cc69a3b3c8bb7a15a6c14ac031dfb7896eacef4264b0346af77cbb49ff4e057b46ce42a55b1a38c14349fe6b8b22fb0f952c4021a2988ca377a7e56a9237350d697aaca852fd9d2c0b270ce852efa585be44ea397b400832359c32e477f960195e322b678310690696ab2c9058b293b5eb6e3e847cd697a5d7d2fc5fa4ed0f562d30e4eaa8dcc025c4a1dd3da66395232e21f362e920971e70a5160c3e7fc826b2a42c4cb7ad540de91e40cc292bbe8dc9737605e1b5dd2467df96c81e0221afa83b2028b82e265704d46155ce111ac7c2f6e97f542d534dd8ee04e327ab9d76a449ffc2ac76f3dc619bd4be28784c0bd7eb366634f5b7f592b7482c9125a7e46695f9cc02d95187e9798c225a3e2d16ea088be450cd03ded1edf1b8b6df68573d68256a1e37d12f670ec588b72cf54381275e9e80ca414216c28834ad398d94e3525edaaf2d239f025a41c022be131ede849e15021f841ff5f8a630b83f309276abaaf04919c71a3680f653862ad47cc8c56ee4a57bf363070e4f4416a7c10379b0d9c099c90af255004dedb8bc1c24c6aa7978622a710f7d3b5e71e60700bf0596ce7d01748de1e23a11f14541646200ff3a4878799f44880ad482d88f01e7e550cadb8494b23143303ad79dfba3c75ad20a591af6d4966ad67c944ba8ad5d84d97651ad29dc6ae2ac7021d6864fa33dae476e688eebd5f13404b87d5379a9d560bb02937821e688e8eef54313b15f2b1fbeaf26c5b5fb430eb7a970f29967931d5e581d550e1d8d49cb0abbc061fc8552a39777988f5a9caa2976ee95889d03c58d7611bc61da2cb2d17826342fb23b7f425f1f38339bbd386bccd96a825f012e404d598b9e07fba956e1e79a941a57efaa1cbb8eda5fe570be56b6c7f16154cc39ac71735c4007c4906e93d53f076d2c88c58edc077fe7d1dbb5abefcaca98fb762785ac525887ff0bd982eb025e29232c0cb9dfcdb5c09b32d95f33ff31da3b457de2fd77c8eae6d80eb8775d69f117662f3cd7fdda17fcfa1c34a6029c175754649142926d4d174e10cf9db8b316ba60d0ab9e2baf70a2c4a86a992ee857e66b4add705e87238a94d17a54d2d84be89693cb9022fd17ac1e7a97d2079f392945fd8aeac416e9dc2e5babbae1afae884749258ee8e55bfe60f4cea717645796a45621d478abc9697192f663a93d3adee9500de7bfe68fc6c297b95739353eecb208e65261d2b74393b6e7ac0ec0f90df86813d778496c5f52907d997f4ecc138ec49a50da3ea6ce6984cc5aece98557e8ddc5184cc1542652bc7963d6a994df520952e1cd314ff06027dd026b35fd11a321d384c26d44b009a9aee3806181e9f62de56b1028d21e475e754d829ca3aa398d13b86a6455bdc8780e291d8178b1a7c15bde5a27b6637371beb70c719c5df394c9d2776801cafcd2d12e3588688c608d2485809dd4930f512f8c49ba1f9cd230e448f5619c90ed462b6ea1b280a9a37a81b2b709631a15614a73c1e98f48ece6919940d273b9c022376feedd1f85db8d5ebe593775897cd6b2eb26cbd5000787014190d3e9e1fecd1e23c224c996ab9c9a46fa59571a636ad54f2916fce8a23ebb168bbca66bcf0a7b206ea7ea53ffcae7d4513020ffa1fd336cdc800e2a00ad5e16c213f6a16dd09095ed597124a944cc54ee09eee9e7933b77413f186d6fb63c82d53fa76eb70dd2f907d5186fd343829bb6bb0c7604eb9c7c7516da9d4f963b5e86f19a8302a4beed08a6a2c39997a09265c67162e827081e50924f70922050616cf2503ef27aac197a95e48e116f4531cdfad245dc7fdcbaee39f61edc60b76297bf73e35092da3b90fa12da51d5666619a4c36df8c7c2a725877e7669e1f959973557a1221abf61e412da2039d789931ff29343c9a8bea16d750c2be8c20e1f3bf3076334c30836c0d0f4952036263662eee324f1cb8fbfc7aab40c3e8c69132821434fe4f5ca49d054df7c12fbcad5b5a1f2d0f84d8f330a7e72b59b02d54ed2f6329e37c6dd2a758132efbf92e3ce67f01721ee444d3d97181b693ceef8058ddf766e8d97b2cdbba163a4d554157cf5285dc06ea2a3470e5e674c56143ca365d4c3824baeb741b25b74cb67a806a533b2053aebdf627f56fa6d45e5cdad27e6e204fe217af51e12b8cc1ff51156498728513205a942c217207f2cab5d26304d0c1ec01819148a3fb91793d035e883ca7583cb4d2624d3ddcf52ccd79b7ab16a8da16d83a93bab7fc8d526195963d7510a2ae7dc2d607ccf1e3433e3f2cc7e591ba6a9a5ed0e3cec1eb0bf999413a4d0060b6263d966b6295c861774a72977622a8868c911f37484ed2cb47c4352daeb4903c06399e234a0ce897eda50fb1d9fbdbb244ff88ae27624f757c79c43b99123aa4c916d089ef654e2573592e8f858b6e94f1b3e49bb60736ac19945b0f5a0d13fd8cd77f90cd857b66a023aa9bfdbd12c8a92e2261f8de3920d1ce3613640848ea5ba55687ada56c38b4d22ab4cace035b9a2bc4d8ce8623fa7cedbdd975b67ee86990d524d556855e336843b34b56bc37cec7fc3102b005ab2561f22cd72bdd5bfa4b2ca5e4ca2bbac35fe82361d15ebf580aed9204ddbc911bd9884d870efd46f0ffb8d3e542a25e71fb1621849c79b82c000067cb9189b34f41e5b96461b83a461cf6eabfdeddafde1eb14959b6d49fa3d5cb148a75b3c43974174753e8ce95836b598f5fcd318e4474195e99b4f5eeccb224dad731c09b1118e48575b15cc593ef4aca270cc69200b5f136c86a8da1ecc6b94cc9cc2e8d71bafd64d5043e7602b402e1273325aaa19eb0c85c5c43dd85a8910e95fd7ce012bad4e0fc8af3d4bf652c6795589887d3332229e9fef302018e7897e88f0011e7966c68baff8652992bc426c4a7040f75b9e572f10616639e5e97b68625b11329aeb7575c92648d2c7b3e29400de29265c8b990849ed424601ebb44fce39b25be688e0283350332a858298c7b9fcfc5252c081be9fee3afb172a5f8eb2d21b71beac8105bb31074b8c2c96206852d9ad0ae39186dd1aa359c37fa559caac49f79ff4c3b3fc644cb46793d8c2dd68f928e83afd844f46bd775697df2598929d983b77f4e114522342ed3bc58c2e014c1bf69eda1e5d46c185b6eff0f53ee76847e58e30cc2dc37f98ecc4e3c2889f65e1b7ccd6c43661a47def3ef88941279652bf1b4273f71752c4aeb27b1fe7ef421cbe700a386f2c700cffbb8bad516bd545f235432101dd26785e398afcbcf32955f98d3124610639f0ce527a554d66dd54502637fc0b7e9bb5468c6cdb0041a6c49e2cf039a0ca5760ad7f7416a7a76187ef473538c968a2cf8ab1747f46a59541114275cc7db76aa2bc3f7e9a433a41dedcd9d242f4b1c0e4d6243dc119042b97d80764728853e5de1575a4ec79d9e8bbf75bed24e0e6482ed957a34fa2931729adf46438f164deb8f665b914ebfe075c1da1f66003cb643a4fbde4c9521f92f20ecbd880da7fc80bc8db2b6dea8921bd3524e77c506eb3ef394a9b22e0b1e5f79f90e9a6a0ee9416b96e3d5a28937fe0a343f9153ba1b19414d3996884d107e26a16dfb7e83f1a87cad0b3fb728af735a12189cc44da0d2d746f29aff64898359468aa115d49869f3cf82d868f391576a0dfdfa4a32d8f45b01d90d9a52920ed1058821ee57023d9a5ce793ba4ffffec6286c2d53b201ea87ceb4354a62fd60fbddef9ae4c5df6e0339348dde8927e7e872c48cc0d1cacbbc732f467e423b668b310d4f8520bb9b29466a5d97f3e0b093521a346ca3bd535f65d39c502989ca563b16b15f0822bb50a6f807b80d88baf2fccfd2847e72278ecfc04012cd26d99f08617e919fdef16429658bdd5cd5b6051a442067b99a449f1655a3cc63d9a63d52823e19bbc912c727cdc221b5a39fe606f8f038deca1fc51da1b1b2202a804ffa3f794876829eea9ced372bde27fde63865e74933418fa990cf709b425d25d21e064a9519127155f3562e1d05148c6580eb65a2c9c78cafa13be5aa29f98c44a5cfe1ef1687689a9908f05da1338de1fa61e6ed9dfcf9ae09a86cf0840ba25f6d649f34b2905e1b067331a5effc79e2221c6b26024b11813386c10fab6f5da67a5e31cec2df03a6400127f3bd7130a5afd6b0f54ade0abd5cf5becee8c128f1aaf9bb8749808a74639667eb5ac7f2ab834a4e309e1b21afafe7bc624f41c183a296b850b2e0527f629aa89af4d998833278be180f04cef797dbb683dbd2992dec4ea44293287c5319c127cc8d69b2a89567a13b4f0e672e336c36c1cc00b66659cf2bd729ea6bba63be8942c713e04d8c04788440b256ae76b85e8811e6793ef1b43e99e545b7f9afbdca00315ce46d90a2401cb51ff7c2d0fbb077803c2d563c1722bc091cd607aaca3c551ae80ea5a83255200ca1611c151512c1093c296919a33664f292f2d1edfe484915b3cbbce11b6283c49f39304d5ec31e94fcbcd8a451c557536e2f84ee39b0a220ae577af533cca7e14f78f459ff413924689b262535081e07375a9bcd92e72817137f796418882e302fef99bee73f3deebe360c56cc550fbba70a36e2ee57fd7ac4f8b688da0f4259dfd6d1def6b40d5e230c7caabfd6a62f4da81448d973ccb73610aae69352f3c44158cb0c15af1d265cdd4fd08206ec5b37828438efe0dbe1b2b032a27a3d059cec2f3a4b425a1e206134b4097f937f7e5bbd267f38ef2ba0c2b2ef726deac48cdb6c7a3368d9b539d72876cdb74894f7bb334716872f2d8f6c085773f017b9d58ad68c6929ff002163d1e04349bbf416ed092aeaa3b04fde6d3a653d4a497198da6ab9f403b99a3d179613a29300c944e30dabd93bebf17a232cba689b00c9cd43731af26bb4cabde50c4ebfc87e33ed8096848040a1ae135e35dba727101209387e968e22e367c3fab546c8d1e2f9dc2a7a37f2a5c4adf63db77b6c87bf9cb59fc5e85979cce244fcd97a4422387af0d7102340596ddd9fec0024835e247b8417c12773f46727d31c9b9407b97ae0ec8a025efea86bac615bda23e630869562a43d7986e12de9f2a5cdea892edc902ab7d978189533fafef464114fb5372df07dc0f6d0238c11c45bb73798995a228196626afb854309795ee682e5b0d59ab83bd6204e54ed98eb38f1d7be26ab4bbb2d926466cd060efa3fb8d84adcd7e0125cd020f13867c266e323dda69ee91ea7f3fbc455ba021b7ba16a3c64d614da0aaac6fbe08273834fd05e1aad0593a4d5f7f6a77be12120fd3c1741989390e6b0248f842fb8d41d28885382c67c8fa6487f627fb246c492fe8215ac823db777695f642e7edfff847f550b9838fb9f0de072b5de9cf2bcdfd9ad1ecf330455b53942aafb0fde2a36c0a4733a92386f051c221261692e2750749cead3e63bace01c01b80f7fba3d63f432a6a90f3632ca58fb669ba4f5df50653e0e9e7106a291d578acf3c54f1d60d744b95201ee3a1f68cfda9e38f8d0ec459e0fd22a0adb5bc3bf2d0d589a0fcc219b757d2114e496e09acc80c84d256e1a0631299b697ba5297be95cd8e85875aab8d0a447e0eab43aed5f40d763c1c3668303b8ed1cb3698358451387727baa6b48886041e1ad7addd0225f0770aa51af8011bf338e7a8d1ae7251f71992394d71f10c5b498ee03c5abdd5e91ee460452c15ac1ba080a2e52f4cd21584883e4596668bf9f8951a1c30f5c9e6c38512d8d4f3f5be754893cdcc1d8ad2cceae18ffe95545cf0ba634c2f9ae0f9a3fe0a540a125cc551e8097dbd7457eab790a431ff92742124e4127383fca2e7ee0b7d97b6db99a947a740cd001f25b60a3237345b758ba900f0dba8ae3a88b751e60da08ed3a49cace3ccc8b1e26ecd6ad734eae65b4c5b3772ae0becb94b02d3e731db06870ffc53aa043b87eeed0f3e702982aa5aa5745b01d1cff2851ca24dbd1381953d85693990c46e078cdfad3a5a76d86cc0e72e90e12e207f6b0f0b4339a2697316c5a3cff38fcc5147ca9383e79e26b0b68e772186ae7346390b31798058947723ba02c95a0fc6bcb4d0bb9542d4e48bd56261bac58a61d934800c3b701515ee65cb9c58f2f76250ca1b108add80199ef6e61f5233fec2f993e0d9c0fe35dfc6a8240a6a0e178b38b7aeb051cfe4da6a2f1927a5942d937b1668c8d9cda80dec682e56043a4b79c76d78611407692bed2ce656f4c82da08966bfd1f63c6cc97eac4dc425043ac6dd4d2a0daab9216c9cdf4147686de77d6cb0e1a566a7c8ff2d26211e4784820c9e8a5a949d8d429fd1dbc255402cfa4983589816a32ea7d0df265b42d6e06ab735e8539c98a9939f11c80963779d6254a79ed5f6d2c758f587ffaa992f44d661d6c3ff6d8ea42975fef2d8faee155c891e5607e9c4921fac99b6d7b13c1af69878d0dbad42e5fe708162cf6848267f4c7a6303b5756d0e4e8a411e9974a36985f321730fad12726bcf108eaa9876b13f05a68dfb6ae1d5f735262ebd5687c4d7d692a8b345f1fd40afefe5a5a036748345bbbd614f728b51016caa541b92f951b3bc37a28d193da8f327054b9d2a2cd34488cf5786b363fb78dc2ff6348ef0c41faebdacc7b0a733941abd91c12984e0559ff1b57414f234c621f46bda0da47cc02b0fcc9d40703b4ac4565faabae08d4a05b5a34abffb8aef552c43ce53f7459d60a0d890bfaf93606e8fb81391b5a6bc1c655d048f51802e2b515e4f0f2553d85412e446cf2fa54345a154f57a6484464701fe7c36b8a9fe181b79b403249595f53c6a5329d0508eb913dc7412de2758c490b7b98ae31c88c905863a8d4162a23be93d30cc212d1edcb342fcd39198c29d68e32f30afb18052c3f594e74721cb23fc63f5a9521ced3cf508e1c44d6d2404c9af1d6955371f6faa13587ae34d667aa404c0b0657dde351c3467c7ece74afbb41cbaae0371e935f2e2ed1de5519272f2bb7e28a7e5967a0a8dcd64dfec3e3ef8c1c96bae8fec8941b9b847b0d8aed02488a931bedd0d3f77094ad81bf7a278a3b151b33d368648e0ab513e306bb27ea31257a349aa95381d9d1e3492ecd0d236b1e47f1016b355d60f211c83dc042f3620c56c651aa3d7fc2e249939549bc3f8ea2c219c0fdc69f0f5c5321a65fca2a4082ad0786936106228d112583a7f402201ed3b21e17bc998aef1ce0c152ef65031befff748c81f030a64b449102128a0e60d3d33cf4a6d3e01350a8a127377ffce0304d390f04a0d2e50008622e508e0fe1b9ff3d01cb915eb6d1aaaeeb5e57ae9fbfa3fa834f46a3eaaf9ab5a20b8bcad0db60e0d07e339aa4a2dbc3cc49f899822a629320c117df970f861108c1b1cf9ad0206883607a893d53f9b64d578eb15db45d29ee56a9febdcfd2095dbdbb4a4ae2adf7e25610cf7136c35a0e7f1f0f44727d60475151f223c711b4450f635ea3da4291f325a2031f81dee1d7af776260c794a3d145f6d63f06fcb15d2947614192f2949a595dc066314deaae9ee6deac165de13e5118a16be985f3ae46d06a05b7b6deb2878b14ba9bbef4c253d1159d656d156841ddba902fbcc84a714213485ca435a5c51f1558a0cb5ebcbd8090d73c2d7427e4fef64f867fd6148f9df384c5359949b6a431befbee0f9a38b82def2fceb4bbce40a1b3a7241101c3037e49bf89707f5d4c42f11798d52562163b5285b7a6c0b419945347590fde98f87605a84039a7fc23ed594d15aba44225a33cb7dde2dbca529d1d28f79b529223f7754c97926a2171151535a3f7d64748f47294add7a2b2f84511a5bc0140de731314e8eaa775d08f04309a4646ae3870bdc5778353af009ea03d49090897c9d9a9b79d54ad72bbf36c857431bdf060ad3d3e455b8e7fc8041a81b7828a485f6b714940e8550968d056cc77a25acef28dd52385c4bd5d1849e1ac0af6a815a4768325ac516f5744cbd93d80af39035c92d03f9c31101a5e5ac0f7ef187a4bfff521e45b56d5b1d115d82684c6d614daaee8ea145b6ec97ab1d951d56d012064e912cba975d9c2b3eee4e5e7b40fc3508e850f7720d6c75308c53219b3fcad966a3095361f948e44b195ba1ce21af795bd8f41c28d41b07d4c7318a8d3ba5d96491c707eef50aa5b3c5941f75e5fcb001618b12f17109c57b777e79cd5abf8fc5f31c3b72b1d55717fcaa36aa392df8fec6370166f039e4f08a40cf7d1b730c38f68a82879da0ecb398ee4d94ad5fb9ff355f7678b799a2e7e242a4deae7a4c72349990c7c6a080b850020376210e5747d00f1d97c17e2c1fe8c95e07887a7d53124afeeb7309ef655720a11d64fbfa1e16fadd47ce9f59f81f4670d1ce71f3f8510c5ec8abcf37df1ec264d695b7185dcfe4a27224267f4a8f7d5ff34f6f3110672a5223806072fd7f9fdeb6388e8d5dd6b53f9595bae4e600d1fe39e2e208e2ee4da413fb3d5a3fe45e42f37d8fae1cd09176d3ac6d311df22b8fa90cc7ea2f9cd79923bcee7d89fffbb9a8bd781d83db5197af21857330156ff3ed57b125657aead72dc8efb3cbee8c6bb5e6ecefd098b0efd04b9062cb45868627449f1af95bda74881bed4d3ab2f1b089f06f086242ba1ca6422e9b7277877705ff278137a7609f20fe4c1187375dec13db6792d861a83e7dfe54446baaf595ec73c38b7188ddc9022854b394fc686680b9f278c974899c116fcef8e1a9679634f3c28b933ca4d0917ac03706feaaf5b45be7e6e89afd0f3029d30f2afcdab2ba5340842864c11c397a8d71e804f1723950f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
