<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec142ab8c428a22562c2da193a410bffbd5513b843338d96956f70ecd580d2f14f274c3e75cc521d2365043c967c994432395fb3f1e06558975692914d9d3109360a2703aa67a28a44f5349d3656124de7678a5fd7c94e4f34f23853f6d9b4ba90a85499f08c10025904903b5fecd5fd2306dfdbaef55ca123dbefde570c778a7472a3f23dc9c05ec3bc74e07e6821a3784d93cb29b8bba9077809b826d8efee956b3d3253e71609f3113ffcd4ed99ed8d8fcfbbb89d5d69010be0e391b237624207fcb80f6eef639cb96bcbd59c8666355016c8f841c59540a397fd95dd31e47be4dbcaa65894da9eaea9086a0e09fdc2a27554ba69b09259da0a26f1eaf33edb0967f6d0f1e982097d4c3349e103d1f1bab31b110494086915cf3e0a218809ec7b502dd291a37d753f1d05366427d492e02c4407ef7feeb74c72bf5975af60e2a2ba8d3d005fcd101c5a42825a8f9c8e22764793e390c727035f3854ddabaeee595024a32d62f6996a227daed69d957a85075e868216cefaf140e40b8c8f0f4554aa52968ee2226e5b820dbb54652f434ce64cd4b996638af77981b465968f48300588c8ca0fb28d5b7aa583d0c3a5e791623886ffafb8da1c79635ea813240d5ebd7ab2360a090c1feee545be7afe7aa080a214fc279ba7d5c27796f4e6fed98941ff325c0c78de25e5c21ceea0d3bc1440177a65b4915c65ec5e9f1de3a3163d12814c4d5db02a12c99b01c0e3222c9f0031b6d07d787c3d1e4a5ac100a8d8fac05d5d3e6f5ad06eb142a34bcbcd383ecd68c9fcf5ece43e8e7d1d977297dbbe3c06007e3b9266a6e8980dc5a253752e9ce256babd6202b177ff08aff086462de180bcb8326124d87b20ad069f215594f17328976794ad49dc4d73192822138a7bffdc65cb87f86edf9a3a0aa5b9770e0e81d341cc5d701bed3f4355ed29f04a86b4ac57b5665828bf271bf58205ed3b3108f9f89bb6b3656696697744ea908cb4978a71af6578d5a784313fcdce2d4e5195f441c374e314166faeca9eb6e482fbd094291a5a776e547bb1c2f4cef08f7641b1a04edef6c4d641616f0a3ae791bfd6739094d1706a541e603b70b2d46e06e7dd949f6b3f920350138c3eaf915cb19e06a3866d234fb1e034323495b7895a56341746ca92883e4ad7e7994278e8e276a51802690de6283c2ba5e22efc018f7e597079a2953519fd62441b1411945189e7407b46b89673ae7dd0553e9e15a101862d134a3fde9f1fd3bf075c0d1fac1697981662255e25da462dd9cc251ffe11df1b86d5954b94314dc33de4926464bf4ff2ac98d06993dd5d7c67f86865df029e4c0bd82385711a5fd956c95daf911d556f564a2761d4bf0f89925bd1197ef3e5949dfd7710818534336348eea483ee0a4c3c37cb4199b7e3d306ae1b040e033676ab6808e6a9a5309e92208b436d349390a3cec1150207861986110beb672dbd07b1c039ebf5de2410470443604191d452d9eb272403b375dd6f1c956734325dfc9f2378607a009621598413a2c786c2827cf5a7ed0c4ad5430aa784bed15fc52eba68c7c5f8a3251c260c1d1c90fcb7ea3357592b77c5b67e92c2175078076fdb2ec4e3394c7a81e295ea8f2d9812fe4674d58cf5ac19c7950d7dcc31bc34968c6a3fa9dfa306c30f5e879649ff87a4b1e47e09b09655a8d98c572f30264d5ecddc047fa2b4e5c46672bb8e5eaa0e0f0c8380dcc09fcf24c737bb9aa468b6b7ba6f94706ca7ea17cd630f3ae5566b1107f10088e72fc26cfea75ff84f2505aabddccc5be096764f4ee4bc5946c58e61fa818c1e397c60623f72e934b6016e71e39fa5a6514926d08c0eebcabbc22217cf4cd63f1848304a7d9d197aafd064355b6e96f1a8935fd95d69aa898282a155355ec4062e82af87c16eaccb98cd1811caa0f4ed047a7b2fafa7e3a7c789ca0fec27f7ee1957974a7dfd49aea81b70eca691bd29573726ec7b9ade0c9ea0d807c06c42b65effa90407bf24cbac6d4cc3db5d672ebe0a4819e90f667de3941796729e43eb67ce5adfab654b111dafa5fc96dce902fd463fc174a77bfc2f9a69ecc5c9b79e0cb33d5e055b370b8e1a516eb69a9fe2d7b46f895346fa80b80bd03309c6bf900080775839bc1f1d8d42a93e2d8033d0d9e85052b5bb9e5bdb1f7e8a1a7357d5b7a7202c3d610afe5e6067fbe50ed0e583d28c9046dd24d611a19e2c13fa556f7ae0a377ecaf4c470b0a6c8c9d81ec301273be1ae7db930692a437d2c762b885367b14be9333f0de6cc71c4f27376e2b16e9c00fb2e9486b2d73dda78ad2887b62070e1dcce9539dcb247601361981ef72ed4ed88bcaa5219f20e96b0d7357a39c9bfad484ebc4fae8995524058a125197bf05e5c6c921963344eac3dd68473057302191656c18fdef5274211cd67f4ade1ed0fc4993991982718fc0134c595b8d7a68cfb3950e64a8d8b1dcc936b8876efd8755bd09122b0d6e20fced506f6038b1f774c34cb6ed9390ab9f75d80a1e7eda8d2e3ba7805ed3006b6f2ac46c6cc937bdacb138ea855c808e95c21a23c50b129ef8cbfc745bd2ef44edd32b992e14d5066db17b0ededc127560de50303f56761661b11987e574ecee048bc1455f3b817b450fa1e251eecd2c0a82b7ce53411dbf988ba65bd09725bef1ddd9dcd56cee9c456067c6ce39ea85d2e5b75b207c6b41b68806d7909459f649e3d17fe6f0fc87fedcc5bbf48792c3b5b4fef09ffe43c88ebac37164813b192a4cc949b7c3d2970a374b925b42eb944e89224502580348bc93796563f664e3d9d921a1f7f44111a1acecb3babf548c2d795436b46b9de1b9e39be6386207d93fbd4f11443a1128c77b8d289670997b9f6aedce3bfff7f56905bcf91dec06795ee353186829b6454ee8fa6412eb4b54875df2858ebeea6de45cc54fa7b3e6de61f46daacd81a01aa161ec84e30a8711ef32efbc026523066d819a99cfc673434de8f61b0c6ec0f3a48ad7dcb86934df687d71435b6a3dd33f22cd5c785cb556ea6a9cc79e3063135c3ecc6fbd9bbcf75bb4f140dbc912607f6a042e3cc1f869defdb68104f4164857be7b1bbf5cbdc16c27c0381f51a943c73e1490c675c2eccb02b0b5d004dbfdb07caf1c5afa54f03fb88d7ab5144e4740add73f3cca31d5dfa05b2f323ebf9f2209d63b3a54087c2bd1a00901e1be80e8339078c83cd66b859d6ef5745fa1f01bf1b587bd77c04f3fb708eb31b011b3cccd10d9e92b245bc8ccf4170a77c5c4bbc6397c8169235edbbd1098440149c2addcfef1fa760a7f9fcedf9236452dfb1e7921cb3df49cc0c8f9dca134351a96db8f50f42386f3f4b3e1b9f771d5c86d21353c146a46a6f03f9ff5b9a87b3d8299a93bef52df041771ef8668294755d008aa3dde723f8e3a64a17f3e094154d73f27b3b4584718c8e52afde0c98b49df2ed16f28d3f2b9f673f1c8dc30b8aa8c6f672c7d912df486f14608b445c4d11e0ed2505def811cf2e8fc875d88e04d8e025445521370eafa252a59fd15ff4bdc6b2c8d557c4d9cd167c46faf03c8ee26e9f1087cad6f99c8a7d3c59f829fb95865e94603ff32fe15b35316398367bf6bb11eb3c2f673168038b3d237f2d67f9cc8c6a98ec4571b9dbe324591dd102d6b51ace3546d6a89cec7470518278fd112f995245701f59dd5779053c57dc35e64e16ea3374ea0b480a8d575bcec15da59a6efd6c5433858594983e70aac11cbe568066a374ee8cbb8750b2f72efb224d38c83884fce5c75943799cf10cd19863ffdfb11250ea792f02a9d15a403a8815bc90fc6bae8ed67be7a0260cf238ab00ff78d1fa0f3ca886eef615be8ae6591ff6a8c576363d8432c41c922546275d5a99e8969f2e3087fbcd40654f05f5b42202e5969069603987c201adcfa84a95d655827ab6914bbdd98cb62c8138bcc48545fbfa0dc3da3e98be6210988d1b1dc9478f1eda6c10f8fa2735225f77f16e648aee4f682f4c32fbed50fee943c034a55694ecee5585c1cc47572163eddaf3d82b4f7585e0875b3e6625c72b5fc431a5642f08f8810bf15df44534a9750e94549f82c64745c5e26bfd6a27a91ad8c507f7dbf749e6c3fe967862fd87374ca09f41fb4c86c9de7ec639c96a7c1b15169c05cdf8bd31fbbcdef1a1365c7a0a9ec2b303436fb3c38f82bfc49f83a1c059220096c13dc587a0833fc87f242aaaf0645b121a9bf4ff4e2a8e2fc1d4d724ab8ca717ba617ca2d72a0caadec9a2e84cdaefbe303039b0d5edd7e21d4f9641e31aafd222fc2d92c13bac799ca1be15541361116fed0cbbb6204c49af6a43c8f2ef4ccb72f9347605105e9ca13fd0f52e130082319981ac629cbc937e8bd4f1ef0bcba3c62219085b037f2fd20b3d44ea13a16165ab528276678436902f8cc3a31ca7f8f1745aee078b642fdde1d1cad0bbc65289740f0c728d7eeecf64f73da52175730c8fcd2a5bdbaeb46870ca9eff6d6b1f4b0877b5db103650b1daaad5cff2e82b98aa2025255746510ba155bae73aa5a2e5a46b26dcc6f9ee7193e59edcd7216f7689e7cbee6e9fb0ba7eb494a6b8f9a27c522a4c7c0264308798176ead1e616aeb491a8a82998e574f823f1ac6532ae878c13e74b79943d0058cad88f003ba9201513a849aaf547706dbb50fd87aa33df7666c0989fb4267bb4fe9e15f2a0c271201177735f707fdb00ad821a798629e06197220985bb1d36577945a4ee6f809e5c87e25f0ea3f50d01d31e248f2d5d34b0758c8061743ff86badf097639b66f251a1183a65631e362c33cfff654ee32db8e93d0d4c6a2e5a8ab51d5f4027700747b560f34d1bfaa862d1bafbaa8b039c516cae9dbe5a6e02368b8d0d796262d89219639a7752bd6a968a8e57f7abaa4b117cfcf6761fcf160e68b4bafae99112244ec3efaeaa501723ab11df9616ed15486f3e08696f5d9ed391f14646839c0b3260c4a8809d3b8dcedcc05070c0612341937b396f9584a549892e53a4ab4827a7e85b9b6e1ec6109c285f1174ebb21e8efa72deea9a8bb39dfbd224ed6c694da48732bded95f9a45c35df4f5b0c22c3702849874950f7b9e205d949eae05acd74a39e0a0f4fc33ae3eb1f74da9fa8dc12b0d6536c2e06378784fed87d1cd95df5cfb8f0ee02213af3247695a0f1b9181b598fa1455a16ab0026808212c6f82af047c5108f60de0bf8ab80ec31973eb96e6c57b79a8723f1b3ad1fb2b546cf01828e09b6777a00d22e30c5f45ff576973fc0e4049babaf086d5d3f7bc4cd53b62f6a512bad4ef36363f4837345903c321f3c827636664083aa788178fa740ec77a003c93479c424a5c6b65a1d5be723b116e4c176b0aa37626a19cf1735e935ecdc88fecb63f3f352556f9d50cd4e0a546b869a9dce2cd278d47c6427c41faad5c9db739cdceea2851ad30258b1ca68644a43fd39503a3df738895c0e0dd91a3ece43017779f22b155c2eb48f2602dabf83e40e5b330b54721d307ae04baca492a680165486c33527f6a754255b979c261627d32236d76e49da22fa880f3e3a15cfccba7b3285ad126790d6d6207d1c9f802c2d25a274041972568d2ec6c7d7e5e72901862b38845f9fd0d173cd0370a3cbf818a27d867a67c97a3abd392bcc0fdc1cc49991062e94ccbfb264e705682859d1163cb1275e77f9ae178dc52add816a3069925bed804b1d38d70d910013dfb860e757f4dad3516f18e663e41ea4b83b3baa308f22abe1d2828d932d0465dd0d24ab4652e7e0214adbec75e4f608c8b73a8ea5a311dfea32a08ff9525a60acf5d2047ac45d68d31ef845df5f88ab1052d2a0d1fa1292e70d193d22ed2315663a283aee734f844069af2792f2c7377a6b7c40346af53be9c8671b99c3eef8eb6348737b657b945cbc75425f6cfdd3172c758e76c19e35e70b98e65bc4ae0d2787cfe697d2af81e45c4f7020f5b1fd93539a3485cf1a6a90bb14779443514dbfd00b23dff3be94a56c4b1273a7572b2bc91578443d5fe0255c74236bda31cd6b45aab88e92a24ec73c672a49f15a519015f8edb524ff9da7c39adc13fa9622a543893b89f07f346b236206c479f1dfca4ba2de5a4f8d236edf4ba99b2867113542a0b3c860a7986b76c3468374e29e8f5d8190c75a20a43a93b110fd9f5e09815c66d5c62d76488cef7f97fa771612b2096cc8f9ca1f0bcebff85569d7687336753af8f4bb06efe6d7d407f22ae4f4522aa62f2579f1ccfc0a3810dca74299ec6d24c28b33cadb7dbd14892da209085489a750be026688cce8d8baa1110dbc9fd622ea99958e533a4b3f1f2118c4e90029f7083e3404ac63ce58ff8aa085fc23ab10d1f31437f25318ac2bd97187fe5be49086e530b980d5e7182dc0b54a4e0f2847660f6ba195c121e24f9cbf0e9e062254e1a0a1d876a63540493973d00c53b26b9344bb3f7782cdf2af70f2f7dcf0fb4adda8c98339fcf14320a3115a7b2bab913ca1ec8f2396177b1ab7c992dbc23df9e01e1f0cd99aaca6e9d4572ac66f34ac0be1df2d76ad0bde73c7c9c48495380ddc62e142b3a74803502a705572d112d37187c9529da74686049f6530c1c7e984c72a88f4cd0e1d888fca537edecdc3c59c1ad748c7598bc26a4081389563059164ff22fd434706ddcda38eeb315990153b0cf1eadf63fd4f39774242d805f58801ef4ff294eab8b6a2644644a5a6b944c71c7da3f8ac62bbbe19db801fc4067ed5f64e0afbec34386504e249079e6db4aac7af9d5d3ac83d527ad04f65fe305f3c809ee62c7cfaa3d9275bc189c76826a5b0e533785400242b4eb0de3dc0d967da8afb4054e74818b369a0bd30d010dc11bf57cf5330888f40f7acfad8ad8e7d25d86d842b4ccdd0b789e172fdb8ea7875dd7bf17df6ff4a66e336a8b088e5fcd9f772a4591de2b1a76f6101395651ba1774af720638407e9bae5c0a53ebc9d80fea6208989eb35d046423d5f46515a87ffa223be728e63acf4240623660e3d4465ccf6ad1d01046cf7a541a882c4563cda677dc887413eec573896f11c2d010c967036e3c36a55451addaa1dea4930318818e486038119323a5e22075e4e84413cb100caa76b93a0c94827647c30b7cd7e119fb1feb3db5cdc40eef33fcd3c83c3c509dc620ed2e0895a088ffaeaae03c2dd616880dbc641fb4d205d6293f8af9ec6bed573a5ec6e2b6b5566d1f3ebaffae962623577c4bfd35e5eea0ec6e0fdc0046de6bcdcc2bee2520c55c95a2e26b4a9e945233af5bbf0d77869a2b0ce990aa3afcd707b20765384ca6becca675ed0f55cad97a58d021fb7afbfe31329550733e7773ee936285f421f03894c2d17914dbfc5f5eaa2b3ef597402b62a1c15063b291adf9980d4d66d271cab20997387449e62dee82da951b7c834af5a7d2b4cb35666f269ce58f6abd7e788eced00e7636c8709174e197d12a3d3dcdae5c53883f01974cc64b9bf6a99c3ae806e8da93f48c870bc5406a0b50ea812fd068f09d5a5754143dbb6816fa1fd8201f81ea73e4ca4e707557136f2595ccc7047bae4fcb48df6c2f66785cedf5030e7255203e9f9fa47eac9289f5bddda7957bc0a7fc370686c18d5fa55e3d1f8791507b00a03bcf5f8b12673fb4c21e8099386122eeff45b59fabf64b045aa883c5ec19a4c5f72a129d1ea64aaf3d101d146dc362093eb8fc51d4978a66900c7ef408d58b03a4a7d08f4ba933610d0fc402450f04ea0e6eaf5f2152dfd915772b2ac251dc28865b4488a89b3585f910a5e7ec50fcb564ec3c1795d6ea57f20da939b4ac507ad21c5162700f3ab41bee2a12c83cf6c2837a4dc34d62693ba5715d314960e5af57c8fc143ab00337e1303d1c1915f82d1b57c717969e7db2292ad9d27a892a2b0ac8f9a043c18d44ee377b4e3dbc8edcefec21c6f0c0a84950956243153de981da1d5ca7de9bd709a1e77e8f8df2fca46234c02a0814ca037f57cb4bd00a763a8e6c20439673688b86ee93e3dee1483616674ac16bd8b2c8e6ec7ae4cde5fe0a0b6c6052c9bd59c66f637343630305fdb049475417e8be6788252f0edf8b9edaee8a1fa3d02306d9664971d34da4a82738044ffae796bc61341d6d85b2ab142f192266506f7473eeaca609d22b8fda40f9cf4b8474f9f95c4c0caa0e897847cfe27cc6c5641a1596e5a0bd2e227c53c5d9f14a0d1bec5102dab3117b10be5d904698b8ba058df8bc9b5be66ac787c40ce0e6a31bea388b1f20469cd468c2c3e8702333a0dcc07054f0bc0527294cbf998cd0030e29386ab8ac73dd6d195329c9f27109c46918bbbde761b6d1d04b514cb0812ab6e1d8591aebf430dee54e38d7f1bede203cf048ce2b48badc4c1617800a3dbecac6c9c6fe423c51b1abab9daff55934810395750aa351c4888341408ab4b9cb374fea76d79d613632fffba506ad205a3e8fae6c6f69db6af5267e859239eef941dbbf3ea8fac8fb3a53c03a266797ae79cc8bb5cb1eb9da08c38850bc434338d6683d4f0cd0f3b614a5d9392020c5d8dddfe9770f39706a121dc9cf6f2b9a784bc6b2d9b41baefda76e57f126c8ff97cb7f38ed3755024e6c77b6bbcd061d7369a46edc7d64f2c4a8e18eceaadd9ce76896f6d2ea103ad0f1e871b36d81b309e8d97eaafcf17d40d6a4bb92279ad48a0cae86750b0bedd8607b45bdb517756aad6faa1348bd263164b166f0513ce86077410b7c8e1bcb32a43b877e78584fbca49a015aeae50219328394f5ac4ce639842acf9554c5b43ce049a4582d8805a0dc507cf8db07b79dd6a44a3d094ab3976bab23a893e462364d16bcfe89e058d2140809521a8ca266ae53b000691ecc7102ac638eea7af1dbfda825008ce11c68d28d0ecfc986aa7ff6de9c161466cce708db7e44235d669ca699e1cde3b54f96b5df1a5e24a8f028dd017e15a3538555917a7e1d6045b3f91f93e229e08e5f0411e120a9202b2679798e790084c1563f93ba6d07142f8cd09030651d29d450375bcc02884c1dae76befd5f2376f593f4b1fab240b47b90c354f90ceeb4aa8d039bbbaceac3867f984409777fe861837be35d66f129f6faba70d894b4857c3869c979c0326980e244f1d6c1fc713122c526527c4d9d392b62cfac64d7208f96f25fcc5b9e03dd68037a7ecffc8c719f214a2ede77deee47464626a95f6cdae9cfb7e18ee32f58648738b07d7b9a3cc3b9bd653d7b9d4a79286cb15d0d6e5d02f6a1566057185a8840fc4b7376887321c79bab40df9dbbba94019d98df9fe2ee98aa631d7709a543c9b19bc0b772b894f52b53f2b83e724ba9cba54ed9c88d14f0062f6f1b22e546e2fa07448b55bfc1074ec0bdbce93f8c90cc0ffb54a1aa8c8b5e6ce2dce122c6619296b001cfbf739cb543cf3e392ade9ebb30806658b9051a727f04e3c601af2beb6483fb6fcc9ab4ef34bdd081b75d2c1ac2316af108f8b38270e3ebefcdb5f9b2167aac212098264323f88e656d4b6cd5ed79c9dd91f75ec7fac53602207f2b8a0ada8d029dde0b71c800aff79af6a55444c4d2ccface5319fb57654a85c052f2961f6ff049f3909e520d12f3e372e41fba8ef5c75c1900954228296e5b95394e85dceff24672f7a8b16334d2f46a08125da5f3bfd77ea0f82d80fd4cd807f05206e62902586177b9612a60ca99b025b21d55705f66af635383278481f9e72d12c1f37ed41aaca42767d07018b43a7ad704e20660c8772477cfa4ff3548bbc3bc769387d6111f584cf71e981b54e2998bff0833f3842793051fa7e2467126b687f140f0d821806faf17a362c7394d3f13f452b27e61d71af15ee7dc9a64610168eff501d41cc7353b3fba80fea89ce5d7d56a7bde9b464a46253131841e8f98673b80cfead9962588f05bb57913cc8338267491b0f95f1556eea43c7bd7b3a944e2ec86d8b5d82d5e890cbebe59b9fa5cda7f9efc2cd9ec3472055dc8da3d8961d45859026d46e1ce0c03e98b774d46bf3c85cef1706603e1f5861884e48ac4e6ad6752fcc099e25d2ad137d2674d0d102597d10858e217c6ba680557066b43c24de5fea9fe3bb2dac12907cf2b95a8baca952cb78da513004b904cabbc489190ec199af46b23cba0da5b036067794c7ebd6aa3d2a175663ea8e34792562009e88e156dbc43073f84b920fc7713ff306d89a7b2c7e5d7aef487451fe8020fa8e7aa2399364eff783f7f4d4c35c4804a6e2dc2ac8f5cd91408b54d6f5d110cb0bd2ebaa8ed47364df27b9bced821d3621cf7791a7a37b727eba1846ae69c04a86cec4b52a06829dcb1f77b3b127fd7a35785e85c1cbf78be5ceb1b130fff0abdfe1b31dadaeb1225fca49e32a39224a2c2933ed4882e49ac98f9b5a83a7dcbdf5b84ea7e8611a83cbcd952074d26691473bea85766481960e31548e9af4ac98dc4b908e3fddadad909f210c6d96195e65461b03b88952e8f43ce38025d4fdc8ecd6ceb772a419242db030365cf46a6d0b33f705ca05ba053d77cef1d7cd87773b06a6df2b66584a1ecb82a3737bbca1c604221e4f20226315471233df0ee5f17cc6ffe95dce3a4ffe188c788c1355366e7963a43c1505c56de146801f3c6426f05eee15dad441d4df797581eadaa746111d79be3e8e429ca71b08c76285994f2f3d2bc55390f0f8a232f8099f1e97370fb37cacf650a20815a0d67c53c2b5335a384042f5eec7a5c0243c1a27195967b449d9823194dfeccde600efc05bd884f3bf55b05114beac6c8601c72c3bd13905700a39bb433597747af220edd1bd1e25faa64d9255f5e5effade3b33774f240ad2e5898e5d3bbb8c61fd7ce2fdf49ee5028e7260bde86cf05d443a19b11b3975d860618006dd281553eac7aca8e850310bb31388cee77523155e1861d1c0a9328b13b17997130be0c3f3e9c2c57bf7cc6e500ece0dc1d328b83ae5b8fbcb8d93fe86e9f3fd9f75656bb737fe322323b7bfa7de227f8fbd0d113cc788f7f4215fd8a89298131b6654928ce82e14c75bbc4cf3125bf476e3f1af8ddb98dbdbc1da949745fa58d2bfb250415ebb0f86587f61f74e76052cec0524357fcb353ef5aac05b5a523c8f5ee5925d43b59baae4fd1ef9e01e473b77fffbf83715894317897f9a83207daac64a6caab1c64131ee67ceb497378f8a1588500362116b3fef2fc608c6726a5fb675984e268fe4c5fdbb2244936004a07f0f72d1ac2a03a7a1ed3e81cc415446c0ebb6c8d29d77f0f6891fadbf2ec0475bc1e225c022cd260e0a08c36868a0b9ae8503bc7054c161a8c87c29acd4eb6b0ccd6638170b6bcbda9b79b147e0b4bccf869d2e2684f79315ee9cb06731a588095e15c384e6e56e6386d6be2df9e94a01de50d97122b40a195c7511a35dd9207fa493cfcb5500eb30eca711e025185559bcfa3fa241665657642de8cc4c0b2e065fa5db0bd4bc84a3774d9dac7b5471605afa9253d1289b3bf159a3072c4140e901dd1ea75252e340de449caef7308c04bfb7070de9346d660a4e17e0987540f9441aa8f206fe1cf5d5a8bbe2b15977813e5a39a038f4411879fa97370a95a3d2b1033fb6f0612c92ecbd02f04ce1cc0b3cdbe85996dd396e317633525f93d4f05646bca1a361695e76cf38a3ff7b9b9c136115b8485c790dbea19b4702ec050cb03b58c7ed2df32d0112c41bb7e18a31520cf6c154cb8d7000ea366e89e1c4da79d1c80d4ec28ef12bd625b64299fe7449ff2afdffab7b2913502931573d773e3ad1fee7c468ba2fa3f857cce323d1c614ac21b7384ea3ba97198eb49bde8a27c7e19e94578618b12354d715d953443a9cd81ee4fea52ca93bba6f8910fc5d5f97cdceb07bea9e9ba2e422ef2fbaf86268c5b918946456945008f84f0ddaa871f72caf5eab6da58d25a8027c32f253c8ff702ad0f456337e9a3f115363bb05c9cdb9e00b6fc0c7ee2ab9628c9802171bb28fe94f622b46d2f6ee407312b75fc59b55ac2f0346e81234ea6c211e00c3bc07e259627dc862b3d234cc1b390a794c9c4b5a4eb5203488430ad4c5aef561088deb20387eabfde3086bd08e56430a7eca733208008859c8996d11a37d296b91c30c008bd5cdcfa8f1caf6f8384546f9c85f40684dfd8b444b287f9eae94a11baf92adf0bddefdebfe528ee1d4bc0b8fee607f55fb25f9c95d8fbd64f3c723bf3b1234e58788fe3e82e048014fee265bdf70ceeca2287632d59e4c3c10f8e408222c32d291fbe98cc4de5648bae4d7fb9aa5d1750c758115cf9c4055c1e93e276591a2a1f40fde22641f70474c1caf1fb882daba559588b87bb7eb300ee8177b6b2dc321eac9ce185946611397b9746bbf58aa3be490fd98d8a5d81e5f6c8bf01f3e9d6e0cc8d96f32915c8077d57b7b1a694b947cabd27451230810a83ff1278d9d6fa7ce0a261b60b810f0962dee68237bf8cfb646d4a5d744ae20e741e166caae35387abe652dcde6812e7ef7402b8420c29fcc9e9dab55c4bfe2624ccc11f3dd64f649ef9aed02ee9df9732ed4a3900f8f42dc6af8384c46e4aa1fda77879594b010f64788b122d75de16a3deb1c7cc39b6609973ba4c77e9d9e4035b373a3871e73a9882f1c4c572321b282c779d7c793b919f9f7903b9f9037508c539d45033028a6bbba94eccea47602f3392d5bdf1db77f7b823a4adbf515d84f74350576ca83ae0a547330d525fede19607235f3df96709e2e8d6c9037102a16465b59911ee16ab3e6a1beb547605f852b43594a036600f51dacb18f0b51c7ffacb2fe578a466e4bc02684a760c1a1267f18c43b62f626995dbff9f103d12fe0d4e9dd34bed225786f1e2c07c2227aa4d3f09ba9147da6129a80da9fdfa0bc5c6edb8bf63a035ed805f6f06bdedcac9e0599cbc57165fba280e6c58f4fbb24242d49329aea7056e42317b3def740113d88f12a71d877540b91729f51d1a161e66ae1fca78095b6bf69dcbcdc182c67a1415805da5f4047a73c5bd73a63df444341849caca9bd666c2c7f48906bacf24501507093e439fd245d4847fbbc0d573be157d70a1fcb44107506d12bc249e341a00fa113dde79b4acc071a90fab3e96028af52dcbb8a7b90926f746dba3b5d436159b2c4ebbc7cef1999fee874fbdf0964cb2cbea96bad67042aec881252140d0ded43e0c4ed5a8f1560489dda5dbd5d03bab0fa748dc5a3eca9711c2157bb8f92858b237e7c19047d8909fd966d9f3c3bb64b7352f8001f43b7b67be8b6c66c20fd0e919ae5956775227d834d486a176a3e01351e1af0409239dcada2f00c2a2f4eead4905a41853c0a70012de83de8c4a8ed0fa07765b0d277ffc026a1ecf059655b7e5b219cc06adf0160fdce92d473007f4a3d9df6e162cef5db173bfba1e801ff3629667c237be9b89bb9bb2dafc94d2829e297160a639c0dfd283f12e86227c6a8e4e4c8d7cd904c7abba0576c94245459253196dbe20918153425606c14eb49fb8ab804b212b78f2e6e5a9ee655291000068fd1acda99fd9d269c4f6dec9de4f0b0dc3f360da385f4e8e7ea330d2b9b92ddb6562911d455c687db56c4c07b779c90d8e7b5dd3c5566bcfe86c13fe43effac4ee138bf9fcb3c77ec90879506701e3e1f16ae10c8eaae8002a3352720c8473dcb7a2a20fec7e8348967c1b1f17a7c7ffda84e1fdb5c11d33c28517e83a798c4d89bad9dc99333477f0a0f697eed27005a497f02341c9cdf5cb20290912d6116fded144e4330f88de594aed793149a98071b4fc8dc2315964448039f5f90d0378663e319656f3238aea9b8b1977cef0d19ab1eca96f04c9221b58839727f99ea5dcd82ff037b1b2aa572d06682e76453c18f4413bfb9f974033044ea7447bdf42f06851f8e62c9c2ad2efd94d01a422b835b9ea1769d065b36edac5266e4d0308f46e876d8bbb3c646826a2708ce20081c639e88dcc3c38c4a3379a8ea14ed4e6476133c078ebcfb51ed90cdd1eb9c7b134e394b86411b17f7491542c1436965df78f14e81a6a1a7f60664e7594e8aa801ca5173c45d1567ce6d94664dc9d6429d0e11539a36975ef051315b0a61fc4f3b634ad74ef3b2d31d10b6404a9da0f5ff32107cfcfe92629d7ca2e010502dbac72865c104432ce390819f61a740a73a067b496b94113eccf511333d7376aadfb15ec23e077a5ba186eb8b8322a7c40b4c564cda5090a343bb87552b39fedc826e54f2b30e41e4006d99174a8690a8458681097efd7c249b22230c0a64f0aa16f51c1f4859773717bc6f88752c73cf962d019d7f393fa122da5e7a7cba6c2e33e5e82ccc2cdfc8842ba61892a3b22061a673e1237981a679f3c946c9987c53f8205de0ef997279223023a08eee598a86b43c4eebb3c8f4d97cddd6b4cbecd9aa0bf4a12341c7d1af8483981569f9f0ef9ca0d2c27424ab731bb896865d5a4d703096dcd98d9a2bfdb512ff959c8834e02ae710a5091b4c3e02ca3ff65e4a8803c3cc849ec4d29145f34cada5b571379e2844a3b87989252264092cdda8c05ee8755434038a77c468ae5d21825fc2e4c91ca4bc47db9dd748af8d96842b8a6fcd5fdcd276a49cdc2bb09b86a803a00c9ad2d5f7f4d0e7dcfecbcee4a2d8d687661461a4a51bd1145d840fa0210adeabab9c9f9fcd9749e8292f58656a390af5dc27a1c674618faf06c0eb2e64fd26db005b79f93d6138c98a4ba9f894d8b43271bde3bd04fba6ae89fc0636bd7bdfdd77100d9088e114e73faea94a6984ce5ebcf3a027f6c2fe5184b41d213d385629f5ee8f83934eeeb784c81eebcb9bcb5786b557ae3de6937cb92ca6ab572bc8d4efdce0bcff28f92d1901bd0249ebe813e686742aa5b818babddf1536b44f71531604505eb8d0c7e1df0c7e6da03c7e59668271ce10f56758c25bb587487c85452392715b3cc7573038facf2ebaf517f26b0e0c4fae2ef9c72dad3269361059d52cb3f161180a287378c9462c0a79c8c9e1df912ced91715e0ddb453ff553a06a806612fcf2e4e6e1123a772bda85b3005e848e9cb618061669508eab969c70b8fb4130519592fa689fa11c0684c8bba1ee37c2bf66aca3b15bae10cefdcb6a470b8b1951215e46e97c59505b95fdf55b9958851f91e7602c076ea39f9c669027cff70da6029c2f15f388a1f8e3a807e922c3a05544727e5ff249fbf6ee3e5259b4e5f3d17052984c5dfcfdf16db7891eb4547527e9fbbd1a898a049f84097837669c468a6b3952b00e35d71c2bbe230563673a40ef772e7188538b0e9440b9c2ae3aa702b9d4e73176809c2d86c890cf5de5241f28de462d5f2ef5e8456cfceeb2c8c18835429ed69d1e682606d212fc41763ef58aef42eafa4a5040bd6d7b06780e43ded0efc2ad8433f56cfed4bb8b6b2bdee5dd7c27079f190e4999358623bcc824221591a124929ab8f5cb99351c792f2d0de8ad1ec814d12daf3ecde3965f1c3c6f1bba52ed8651be8aeaf407fa149bc2954baeee115fc4ce17cb8d67b7dc15a7458cf45f45789c96aaadbddd75a9f2dc3f644fea41369ed85b7f59ca0b971690714cd498cfbe174fabc8a4da380fc5fccdeb56a5596c16910d004578c61d82575fc9dbc58f31a6834e906c70d09c2bc47d025b5c7fa4e91399317000bf434897caf7aa50084d24746424461da6a80925f5c2ff5331dcb33bd46c93df5cdc4ec281af1e79f53a5e6e4eb1f42bd334dc8a213ae5fc7e77236f17ccd74d7a06f95a815e4017bda6cd3afa080c3d337730995cbaceb86914a315cc6a4cf4be193473c70fccc6331d43dae434e6c1b57fbcafa70cc7b4e06611cdfdb7ede7202d27480018a98f950445188b9122be1ea5926a50526b5f38d11e50f66f22c9ad6de18d35e9b6fd22c546c9875dbaf72cd697f88f1f701577e6f46be0e473381010d49e39da356fa50e7410c0b1567cb0e887f27b7a7b9bb32b572371e479fd02ea324cc5c267883c3f328a02fa0f62b8d8bd74be6dbb7adce956ea9e613f66f6a1d3f45fcd46b737b980558cb379903cca6d6e85b85310234a7f14f549debfdf3031f3370f984151726837a724eb967dc9f8a05e08aff16f04bc1d86bb42d19079cd5d243164d015bcf30649de63293d2e7352d162ea2d2a12404bd802feb3bab565cc96293bdbed87bba71936ab4daaabf790ea1caa328a2cdd841f35904bba7e4f38193f7dc56424a17ec481b31ad86ba8ed8bbc44b3eb1164fe464433b7efbc9beab4bf4d3736aad2f73424a6764c37c92a888842597dff7542d59517289511b7242e09afd030f5b558247684d5ef6b9c3558306c1dea48a8066287ec39e776e9d80b8af7d8770c0fa3c19cbe60fdcadd932c70936445d2d0d12995291c9b2fa1fe4b9cf59ca392ffcdda734374036e4de0b87521a1f7748b73392e7e8ffccef69db648a8e652e78df5451ab894267ab87c6bffa7b061656b8ddd483f9ac5ec89ffe8144732e0a83f192bedd9cc2fb3c0377426984466f6f75b3463c047a4edff86f36eea9771d79c2cb32afb3375fd6ae715404533876b30fc2d528ceff06679dae1dc390df3be3995252d14e9c0747ce6cda7847bbd2e9a16603aceb724e0ec130143d4c50f6f20ac40538a889da8f3025959d64056f4ccae49f4e82e0cf85f0c9ab7a99578e08a0413ca3ac0e54996c4be86b7e5d0f232dd8e001549e545e1299efa867805e32a8d45bcab7c5bb5f9d971d3f84ffb14e739e6f98510ee1a433f9634fec4dee90e51fce3bbb9e2eae37eeec2d148e72899f68d84cda56ce3f90904b5f84176a70849abf8a330a9e53ce14117bda33668a262e64a3134ceaae76c3eecbd2472ffb51ab6d2b4556171689a1805ab1d3e423bebbd5341aaef20615047bbbebae34d7c62c361c034bc1ef3f09cfd2982b44c177f2adac949aaa1f39af12f33d1a4639cae09286182a71288d89c3e23a068ec8937c4ef79d956d1bd8838bf4a52c850ba79b6fe210b571244935a8d8017587812179120873c9f786fbb386bcf780d10c3c920194251172999ddd6fc978d0e4fb8c4fa81f2384318b7bf0295454d7cd7a293a8a5c7012e74d7ee61987ea9f8981595ec639c4b018e4d591de3f5c7209354b2761c458459cd5f3a5f18a6939a527a98d1988d2230f886decd227b89a5b4648019d15587f7919f77c48b096a77c78402e84b5cb0e99b1396ce08c81d220aab8fa30cbf3e62f3e655a20f638d82cc7a902caeff14eb33691d1e833c99aa3975cce9a8edae9c629dc1d2b8c7bdf2503ce3b03b3b201f03a7fdb5d0f3d93e1456be6fc99629433ed30560322acb6a39406da3b09f1fb43d507275470844f2c6f2e46fd3e81622408212d398188cfc7a6ebe3ea0fb9137a869236f2da1e935e1721045c13fbfbb77a3a84f4a8a429f5a1163106bf702f173b9a00138d3944fa14c1de779512b790b0c150d3726a4c356d90798bc85e65a746c89000d962705a52ef2a5e313a00b3bf5ca7f1557411dc37e10963dc0f57d9d9660aa89b3db16388190b0ccb2a04098c0bdda0af9bf85c586f71778e19babb3f00355b347bb14ec935098b2121dc78b7397ad00dce4d95ed42c07db1c4bf57ba8922159fe935ce816d9fb32b83f3a1d442a7b63050260dec8f0000257e8a54bdccadb40e53b5eff82262d33302b966636542ee0fe63076d4d8fda49333a19d84f5d15a46bee3071cf28eb378b9e8b8cb96658beba00e391d35ec4f7bd44a075a7dd069c045257a829784cc7a2244a031bb710b06e00e735f80608c0510190a41f1dadc768def3a1a2f862f0b5ce0d92bd1fe3edcb8f403cb383b175029120ffca23c5640a2871ce9309704a23528c4f6299b6e58e9f90cf2322851ac84314372c2aca6501a65a25f8ef28c00961e506e0e025144cf1edc462772ce8fe541478e3783bb4f92eef3e46f7d204c6b03beaa587148dffdacaace7d875601b7d155ed969ade3cf2b3beaf34d2726a8b82dde545eaa9288b3ba4f101fdd98455fa339d7882062f9193e7d9adb03af019e671278453fa6b290b007","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
