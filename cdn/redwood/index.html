<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2a6e6192b5e5b0b274ee8274537ee61afe8775ff87a873c2d5cf9b458e085748d58b5a598bb3f417fa49ddb8901fd865a3ec15ba38be0d95097f8aea9d1d1223aa96614c12002492d961048c194a265eeac76df5f2c585b689dcde6ac138670641024708d7d768964b47340d635678eb9459cc1a6b63efbea3e95ddabcdff4cd0ac6bfa46176c160dcc77b8fbbe573292686ffdf7357dd268a64e021d6d787172f7564eccabf4caf494dfa3239e77cc159e53ce918e83b517746ec38fb1cf2dbe3888276006cb7f687ab949ff16152a70b3f41a20cde9c663f8de01ac05b88a40ab159d6fd66c540932394f85e3a93bad8ac30a58d640a0638f86b77bcf4c483a3df73be58e9e16f6bdfe14ee3987273ab998c75bf70dffc094cf259d72beab078df7598ac7122d82f5a647ae907dd30b6910eb148cd8b8dca3c28ada47a4ceb68c579a8b3bf8caf9c84bbdb6e25a2f817316cd9324ee45d3fe8597922239f891ef1b35aa11e18f3e7faef1a91386b2f808a321f143f9a337de6d75f9ac47986a027d77f72ca20b05d6e0c172e3f4d8614c0923739d8f3370a87556552f30e372dd8e36d803a78fba12adff321dd4e3524062ba1912bb13f120e71869a16bb9062c3ef24291907fb51725ae43a6a9c7837c4d6e19e1975f3245c2e05d8ecd8e8af4bdfe0d5e841db0fcc08badb9a54461937195ca70b37bc6ae9826957217382c9db13ea779b8b541d01fb6ea70fdc3763eb1d621676592e7a8a7ffaefd4ea669f2a6b4804d8f806f1f1a7caaf177a9b1db0e3f506525a7f94934264b64b8768170be4943ba6b36cf42294c5ca6d52aa9adaa6a0b8ba72867d998dd15819bf913adc0043471fafa16e7281c40dd8193f9e6f092032d8433441386bd10ab4687103f989b1c72fd8563fbcc41f168e4fb15ea2074ade73ba602f5ec01a7d32e21e1acd1d257f5d4daf4cef344c75e08ba13850d87bcd7ef9ab8824232f826181a75d3d6b821a6358df9a0d2ae856ef329716740e7a377e58bd66bdc59a69518dcfab619ab59017c5b3ec9d425ecc5e10b92f93b38a4253c783e6328a198395d0c2dd1137dfa4722256dce56b8984a6eeab648b546e9330602e4dbd79b26c3fdc6a343df3f967e5df04fc90a745daa4df3161609522012a0297c9866400b2b28cf20eb14147302d078abcb21ff6f172678f95b932bfa5e43c630c3ac763a78b15e471825c98e8641c021cedffbab7fff5400cb74b2bb150f5f856b455f80d3eb0ff5fa3baf1a2e2e865caf72ef192db2662f07a46a7509c72656051c72dd33b70dcdb3695890105084e1c2efcbfe28b560d7845eabeb5c79a23aae7c1726d9124fe7fa07f317697b6f711e74a6f286cddcf27544b6cad87f6dee3fe31762425a7fe3cf92ea1371c6c27fa7300662e4dc6bb7f1969895d71bce6d07b4e714f348ba7bb1262c00fbed3a14ca2da25ae96abdbdecb63e84d578be1da25a7f4f0acd91ffeaa8abcfa34de7e88b764379957407bbbeb098f372bc083327932faf62f7764a12c0e1954aec77324f54f5e590d92dc11a6d87cade0d1d6a5f656e7052f4e3ff4055d11f192ac3b86031d9752f1aa357ba7f257457bf9a967d029cb5e41b6957a9fabab3ecfd9c25879a264e70affb9d4cff8e328eb93be67d8127c32b87ef18a6a7b3a9b8139235d0193dbcb86387fa137d85d4ad4780185c6fee7f8c87534fd100f8b1865bfc76391af18e11afb616c56fb06fa6d589f82e2d4348abc55b7eaca212d0881276f1a643bc4907ca06171dc524d4d22f0d170d64c9e3b464187a72d04c967e2aa85b676414b93c451108a3c51f62a4aa54ab54200b37eac3f69aedaa66310abfab48074d4607129058663b327f39eb2699b08adff0c3543265823fec6dc66ed737e1db41bf909c3525d47f5010996f2e7cd8acca90cc0ba9b0b42d47e54ec238136f867659c09ead93f4af81fa0e8f13beb7b1e28cf94a1ed69cb2d475b54d91c4ac074250ff58e91eb7b6bac0b20c102eb3753e847f1494481ab2df3ab7008426ab5d4f20b779b9b178c99f25d94390836107f8ba5b1698dba8551c72af457b47fba8d1fe28b5a61355e72b112d62925819a45e5330790b86c630f9b2047f643a18d4c5c315e8a89a4ae00322eb7ca32ec438785a8b1b607a5470499638c9ae8e81cf7b441d5bdd3c21e8e8b1ddd8c9b3600c7ce28a7a82aa9c01c942145e095cf81d54da89d61af2fcb315c1b6b7eac03978b2a447546c07c51e841a6ad256b8ce442bb1b2c3c3dcf10f28dedd953e4ef2d0ae531e02e7c9c9114452cacc5ba623d4ccc7c82fb69ac5be439e4d58eae9d8aa98baf6881a0ce23d9210f495aa5a7ede0120815656034100ac00327e7c373eaa57b1a87c6023646c84141f51981df2d899b4ceebe50c1b7d6287211445d1af9e84f24333b6335976349795fd8361aed129a6fc3a45b42affb398b9e153fc15e7d696912951e68c96c54b5d0bd4f0780010aa84bf9ee511f1d71115834f14a58917c7b552a74f4af3d25f1b510b72c779eed116ad41d001db7d4c798d703840dc96ae070ab9f57cb61be9278b4c8ae1be7730852390fabd1d41828fabb0a178a1fc6605658c141081f3c72b4385e24f4d2d7b46562e3ddd92a2e3a2288d9837803ab161882a2c866b9a246e500e8d339adb6bf4901b5e1153be9764934bb0177c926f4e61ca35a634d16c033d7c4bfb9ea86b226e7b505195931c01a6c02b314c8f41eebec7c73ece7a0bbd68db9be3f2e52741933bc7d47f24c3a6263127dbcd33d58a17ae456cfaa25cb61246bce847f537a997e99e848783d89826110cab732fe3d1555771c616c9cb65884855ddca98fcc2a5bf8431f6961215c3b9e857f99d00518fa42feb7f1ece661cb42bf0ef3ec73c0771c3ec8b44c6981485293b372ef2e5ef9cfe18c7baf22e3e0123e2ec006a2537f8f62f4c10b034748f3a431643e4b2963d296b8ca88531b87610515d6455951df62047b7b2b044a6cd67c1e14e28278b8e53d0f4a1ac4b630d250f5483700cb196efd3c738fc32f39996467a46d53ac748b82a8854d22d1d311ad774b2d465bc7be7be40c6864e12843b436ddf94751cd49422bb1ec0af3ebc37c5aa125fb9069e733b29e0eb79a0108580121f0e64fa970c8e858255aa3821f8c840afd5af5e0f18c6a47873975447da71eeb624e9c78df226bbc3175e19f69793425d472c70df60689560ee0783b6a3c3c3c844d865b26ea948867afecc412d7b0a24cc0925d23ecde26141efc031c894c07f86684b05b253d3b288812af9900763ac156c5bb65b3e8e6770645fa1dd3ec480082c3a6fad7ec17bc26f99ee4fc38b491b3e74e55f949bc0d9ba2f75c4caea650bd54da0779198cb700ebae84f9214168817769ff1219a3604bcaf37937316c8cb146f9f50683d60d385296061700f0c31775b40beb5bc7c7197f89c56271393754b0cb3142ac30944a7ca075d210d0b8dd92e8017c390c8884bff509b89f06f70bd7ce40526e094c92ed58d1a62d7dae2e2153772ab1137b05a3af74329ef3f3db530cdf4d2b33cbc20a2a2d06d30fdaf6e667de891b8491d25e90c83b1f57ce88758518dd7a0bb119336ee482003d2f612011f28e1ca530e3b9d0ab878215eb91650a44f69492d9af1bbef2b569232623026b9eddae799ee6c8a02c5177ccdc672fb89991f211c65fcbbb19e493acefb7fab663b1de3ea1326c7413a7914f853969cfff00a3c84aa42315a8642355bcd65975329d9838df42f41093eca1a26d9500867858c033ff0bf289171a8b529d591451e32d111790192c3d7a48a82376439b33c4893423ef323ed25f71ce10e7e6ac0331052b0d627198aaec0d1b53720decf217d3b041e7847be5ae52ff3f211257e51ce119ebca219fc0b17e943d590c3f35d49c0cf8f59384382248317cc30b6edafa038e7e484344ce33ebb5a44284173f40e52380351a721a346e97e758483572a54f799184f8ba533bb7e239e5a7467ec567ca83c37ee24a17c69b860d4e9d2fb6115ac274a188c258ea4d7410980c198accc4b7de602a6a1519045c54818d6079b2e369a73e6ce83be585399f34fd44b75e126d0ff71e1f6d8f94c385ea33de6d0649a27bfdccf3771e5a50b88e8f0c45a0378664ee4c0f5f013b708e826514973e42f292e12d744cf228ae1da67bb60aa7d6ace45ee644f151d3e2e36de56b7ed64088f5b69a86e9a42109e62cddc52c177e61dd885104f4c0e06b0d3650d51f378512c6e93e6bbe8c07082429c86e4afc9b5c1f30e9257b1ffddcfb16231107ff1770d5fecc0cbf3d1316b53394766a76311db0e7ab29698318f9c07b107fde605e29aabe895958c65b0c0377ec5641ccd07e6cb07933c50c0d568f7f3b9dd09c5db116b8ae677a8cd333ad43d7617dbd86861484d6921f948e3a75fd82bf18f59cf0c9233ac365cdf2513929156bca778c9ab77a2bd514285999b86e0ebb59de7453a1792497a1bb403ae4b508f19792081c0deccd3a649cdc6bdfc39c9004362e69d58b551d18284ef67c5dc729a2c0c897da3bcfe47af3fd037b37c7d39578de6cdf8a56e28166df286c9aae38182d84f6b1826df1abdedcfa53145d3777438c8a3af2cea3516c4e9dabc92b77ea078143291c815e14a6750d246ae767bf0a77b10292728abef6d6348bd6a3b13b68dae4d25559befd8487f51862c3add4b25676918f4fdccf928c46885f964b6e12365c4a0ee3eb54ec275460ba3d43f417196cb9d0af3b6b3611cd33909f37861c3be7532f9b4479ff7c17ca64b61f566b27e26405eb20a2d12bd9a9637350967b4d0327cf75713743131f5a2bb36e00efcf714d6031c5e6829660970e726fdeca7b80bd6826b36e09ea5c3b84ae5b2ed520771384cdd0589af362e8260987096eb93bf2fe5e382fb26b08ec8284460f68f3c776f9fba8a693cfc435ed887d99d5eb0685751f411e4ccbfe18d2f6c5a8a4196d69b24a4e192591bf14fd1b197b55cdfb4240e69a1a8c1ff830d0a3fca28e9e25955a7f4e3f1df0779d1971ce263d2d89b383656cea8821177b01728d48b2491a58bdc8d7b5c685da88769d3394894b457e652f7cfd42d086d110b905c2fdd653086249df986770f1517f26ac11bc154a11473ed95cc314a066f94d65e66983d7a95207aac2700d25f63fe3bc80bc94a9329cf5e8234a6416e1a5d573088aba014eeb51fbf4cbe1d8daf5b6b715a37ae736db437caa81c1206a823e029117f9ae595b750a8a8bc56ab6fa2fa71fdfe0ced30c026512f955fe4b57b413bf8ed4035891ff6ba96e68b0e2455f32c0ce0eefa95c9c91d4150fb9cca56e408e65845696877e5a4b1eea4e7314f80bedcd506177a5f3bf414170cd1790a103d3e4b5cef94688303aa7ca4fbb71c0f8e2a094d9220e354f3b6c04bb540910e896b6a19f4a17853ef1d73e5cd1763330cce9b163881fe26228c3bcd2d743cf2c2c2106bd5ddbbf7e317d8e6eff00f61d8544a2f6a589ea4b3f77a9d4c2d1908cc16e29e9c074bf69afd9a6f3598739da371f04af2d0efd4f3b3f70b038f11159533d5e4875944ca628a38df1ba0404a9ef88555681aeddcfbfaad8959be94b3f1cc8ba00c66142422ef2880a2bdfa79bbae03401517240332acd4acca8a3e4467a7e8e053e43b448e74322743ab1f8b569d313d13c27d8444d9045390d11f2e79b2ab5fc4666cd76e9288c2d50e0d8cb1f2fde7a5c887c0b5045b1ce7b1ae92574c485617529e554788cc2bf8d5c251951aabbd4d201be25fdf34a0259057d512f0ba02c26280044d390dada522cba4e91762daa8b5d39cc205a8ea147279ee3c8b19a8f73386d49d19a0db0f52c27b2d1a7aee68dac9ae1d9c25f36d9587d2de81eed88819fc2a03ecc5e2d95e55b1a8b53413329bffba5235efcadca6408bec024f63a3074dd0070982b17219542a18a08673f5411c9acc686cbd5a211d903837f726d202c2aa61b4c5b6ee05fe774dca586cfb0ec0320ee5401bc09b0e772470162674318c12d43c51973000b6f9e0d9a9b264de99b0f2dbb4fadb5fb65c9e0b59443fa7097cd23888d7b5ebaa56d35db97928acec2a4071e46ff0dec5584d9484b8c38811e08c382310693c24525b1f22491d03de757eb4d8eab825a7f826eb2dc963570597bcccf1877a0e627dea295b2d9f337b2c01c225b714cb7270ee5231c477266825505dba00e5662d72302922a11f30dba193bc1a598acae0d88c1e418140f04adc770cafbd36fe0372fa02b00b712ba8a7b550e7d3af2ce897d28913fa4e39cfa652836176d6b98d01858c5919abc39264b82d65989fed5473b49c1a2f43480a5af2ee6903ca131ff8843708611d77ba77eb3c2fba9964925148c0ede3c6a285b933ce563498354ac224ac242214fe29bda3195a9aea85b3a0a54d83467e562e0de0103cd2c474595fdf42bdf72e32c52418d278547510bb08ca7dc6ac78ef9d5da058db8d55b67c145687221cce22cddec688fdb313ac7a72f44a0ce0ab2819af9e1f05edf83ad23b6a755f1bb3a8644349312b7f94292d23181ae95c275b1cf1db15da04768e3d93a0b6607aea24cdf3c41146e64c9ca1d220bab85fded2c082e8c1e051410f9ca2e910197fa43f3b01ffc8e5fdd86ee94b259e466fc81093338a719bf47367a83bdf226783313f1cf045cc4293b540a9027dce5402f3925894f8b232941bb8582a42b36b1be3d04631975e7c5bb60c67b6e1edba1909454bba7d2044747d49d8ed776e1bde9c3bbfff05d7005f470a9a2fc89f1f9d32fb3b4182f3f7db6dc81ba6e3187674316e4dc642e36447cfa8f3ebd03355a794c84522a78f478851248206fbce47afc318818a1fab915354b6e046eb43e920aba267d863ea7da00fbd43e1c837e32b833ed43e03d328aea149a19a55b61198da08819d7d561d88df11ca34d8eb645d1b8f08d875b4e22be9920bb711b24a0ce1c7ab96bd9a712acf9439af4e0ce9f7908f992efa9310b691e79ebdc89023729d79a0241f2badadb3b1716966e26832c3d0330f1e471cf1719f0d061bddac0835f0e0353c8afd66bc4113037998ca57f2d4a630694a22eafec37b1c5291c71d9174e375995b13d8f6bb2dab02ffc162571625c8f805f4bd823c62b60d7179445fa22580daab5839ccc2ab07a14eb3a57c3ae0d0d1c34a5f6e2de9c6bce05e9bfe32988d0ba9b11d5a233eaa9c3bd7bb614735cc95c7e0155fcba3a67d46e42bb0b96f85f2c33223fef04ae2dd3416417d827870f0997da576d3c0bd4e4b6c0a14e866261432336c5ccd8c33dd90344d28b461de0d28bd781b05dac97bb643e801a4fb9a6b1e55a5432dc87535fe208bef8710d428017191c277144ee8d16ee3126f629eb2c67d3118cdabccadf12ac5ec55db32ffa0ce8e1bf638ef6eb628e50227647c058702a7660ca2aaf9d0575720f93002f17f81df29d084b31482d19bb02c44c213682a260e3a6889ad4c245db89cb8255f3f3be422870396f7b14a1cf372c2bd362d331e2dac733b02e02ad514e21ba1dae6077666f8ba1d163bbf35fa572e45831b8022c812a824afbbbcd4ba25806d2aa9d1037744e4d7b26adea7bc0c590c53f6a083d244bc5ec1819d554fe57b8bea6726ad1f9d910aace53400e84f9c0aee6b612b6a0892ae61f0af5456602bad328957cdd8332c36f969f3120243fcba6dc119c534ad05cda99064a3ed4fc7808a80d9d335c782fb7af13611d21696a5064ecd405ea20956c9ebb0229217ff426c0ba4b22a89977f5cb471e71dbe49ef9b3f4106fd7c7b6e80498bd0b2b947ad4dd486e3ac0e4b4c75bab254d0996ed7d33b44f6f2518c2da5232b4efeac2b38b7028ddf823ca40f74af5e8964e698d9ac483fb0262a4dd1cb492650e818a3632b7065e7086fae32e06df3556930ae5c74b1d432bc721a8c399a86f79ab200c465bd12a713c9ceed6081b8f61ec24d0d9233ddab01bf0bb3f3956f5cc3e17066eff72fba2a1d0ec9fae503e61730c3df0240dd67b65db78bc893b17d50667eb6c4e5dd686b6e214c65845d0e64fc75e26ffe94de75bc4ffb0292a9eec8093c1eaf8354bea7efdd0d43515dbbb6630912d8d840e9389db5eae4f6ee2306234acc2cc993d618297a7b95cb1c602423e19624e9e110315f8f206b8210bc72fa37b398d082a557d0e7e6a91e654fad5347910606d4a1f59c08f61ed5a0f34e4e0f8f063cde9d9d81bbcac775d0ba050ce379f22e315faf928d78b795fc182f0b7fe9cd54fc666fd9b1d5896f7497227e634dab54f15e1f7a717b41509d6c77e7a52a3a27e6b93dac5854265ed13327687c3a93cedb5adec38697b73394cd8bf32353800193cc02d0e34e414472df0fb3c037d41e06cb82d2a0b748b30e4dec484e236e2fb46c4151f5103e87551dda63c8925160c84c6f3ffd6d7fda343c8e5564f45e5178e5c2aca3104902a996e84c62c55b0283dbd441b83e4fcdac085c9835bd003b9348898d1b81e167e1377f25f0a9ae0350e1e5c93439a18a261d61a249bd2af6f50b4c2ffac664af0cb34424130385eddf07ddbaefd681aad0e7ab75978b3cb36ea082c0840c272e64c8acd9aced1c403883643bd8ea54a9b3a4cb2a87f78e30627843354d1dcde96d0cc42ced76acf8f27277d1369c521a9bc56f77d25419600204d5a0f0d2a3506d1cbc44d86c963ddf9b1eb2efc9fc8c38920d708ce1abaf382dd492f1f45e493cb0c516f30046dd456556dcd4f7a8639d117c6be81980a3125fd406bf45e1b6f5a355013ed4c8f3d94ab3154acbc6966fe01288e0737d8f814957dd96b568a17ff13dacb6cdae6202b56d79a40a9e2e569fdba15b83ea600ed416dbf88f063c80106fe42d7b8e573163523adbca5d274183fd5ee2aa35bf09c1f6b937eafa46bdc7850e5c2ffb9b46a450ef1ce0020aa3ef03ecb562d25e021cd96a3742c7f6d9173500447e50f50bd94ae1fa543a10a607e51dee1b5e892646d9806dff4332044929d2c4645f1b118d042d0d8ca0476c699bfbad1eb97c76ad204b73dcc0ec7fffa1eae3e03e266f34922e435f3abb9e79e99d0033c37c19eb1bae3b573e54205c234b4113d8823c749f5e3e93fe9187cde1cf9ab8155f33c98111606828d63e18679990740bac3dc305c3e6e436b2907bb8d92d17978e0d46d765bb025f4c05e0048c7f1d5d13a3f410188df804aa1c7901cfa5c6d8b5fa9162a4b881418e4fe34f57dc88fa688614f663b228dd3f63cfcfb3cbd321c3a14802ee33dde5edb93eb6b3147feff19c2e657d63c10ff8902c953e82b11004ed4bddda3bf2f391a6c0dbadec83542d8cc4f9c7a2bbf5fceeffe69cd91e75e8f66ab40832c04fcfb1878c9d05d11e365072e25847818bb84f50c2f9b4c31a6be14b83e9695e7190f6b5ef2c2cb8bc0e17581d196e4d7d63921eb839646aad0f5b24768d8f3310fc549279c7eefb6239bf959dea66540cdc6f020b1c9bf6a2160d25907db50787f52b97b4f1baafc9e3b2811e791ae66e20c3871b19449ad718e32ffce069ec275b969e72e5144915688ebd2ee846fa066b831a456d86d6180b6f9e979236033db14ebb0891196dd21cd28ae8d614df781bb6881b30ff851e3806aaeaf0a6e397274b7bd8a69c1d264420ceb7d729b3db04aeb8a2a8fe2f92bd9a1010c386d9f40959345bfeced1855ba6bec1dc77acec76baffc2c97c20ed3cc308850a91d3eb3d2a114eaa32a26afeaac9879fa59328797346d2601c0ec33bd3d14a521c01351fefcca5a305d06bbaf1c54e83b2e77debcd08fad2c59d20411eed221a8e53d7fadde48293f5e524e1a6d8e2ff1f07855c1bbaae4e98984b745b89c26602c8c762a3123008c9c85cb0c7cf4907866a26ab9635399df7fc55a5482e331352446dc266df16de54d8d962d2dc0a8f0c01fa1000edd3985644bf5a9310584d04d5d1b200fcd486a637cdea4a21487170e48023b1fa6ead3a469415e837b7dfc07caf4bb5f3df862cddc22ed5cddb3454bd980562389a85d76cb55d4c5245050efa246d7f6d48c5b6d30e2c6bf34b741e0e0471c27da9026b73f21edb9c226165d56854dbd07feb63aa4b97860f8ba4f3537e2ca4dc2e180ecfaaf887244906331c638621c950ecdc652fbdfeaf68443e99d62af840d5abb891f85a4c6fdbdc2b5376e05558ea2392349d5d266b259dbfaf6ad7fdc2a6c34fe2b9736af92f01dfa8d9e3026828047e9cea6ab182e688373216865ce427b814c44b7158ba4d8c2fba12e2c36be3d5f6e81b99d2fafc2bd19f5a9775af853a557658d56fce2675072d78cc241a4c61487843be6ead4f114d3ac580f3bb14bef20ba87f62824a592b45aeb6207bdbabfa2401af6e3aad73d659e33202e2649af0ff59955f22b40781dc67f3b50917aa282daa65e74382d5e24b59ca01f3d7403fe27a7f7f6692fd081b9cefcf2a58956584b639c7d2088bcfe737bb22bd03654022d8839cab486bc2112782cf6037991e5399532f6d85db27ac56ca626b49e62cb3616e34cbc262038b3da974e50c23584c05f30047b407804f28054b3907b461aae214412d9430fd29dc4400182dff3c586554845e7dca2248e626056d7b1632d47d1e5eab7be80f6da7947d89fec3e54b4dee28ef3efcb46d09f8ad5efe866284a4c6d7e06b5d34b4131c14f225baf8430c45bb86bcf4002b0579e484f5816a0ae804d1bb985115a282920606a551b43d84faa04cd19977fb58e6927df8fd5921379118effe976a1073e645f47fbc2b66cda18f3430341973bc256bdb3232e59c6a18b63df7b25d7a94afa868cb82c533c08f3eb06c5f18794a1e9fcde5f6d5556809c7fd8f9ae68d3a097b3975b0349f3cdeb0ef7540f57e567d6a1296988fd54993c6f6407185a9283485eda3b21d2fd2141ac7c1d124498ba4b01d3d7f9b400c75218da0b64e4cac7256b52098f6f4115a4b67ada48a6e2fd7a730f320b885692c0bb10f40599c3851efbf524d95938b502dd052d91c216bf056813442a696dcfd9d188b11bef8c378eeaa46dbf4a4904cc20b80eecf85c95bacc827ee5b4d4cca8a10892ff1af8e98bcb974850824299a0c8346ae937a0b92f58a7b88a148bec5eaec089e34b991b3aa872f5f285fa0add85d5aebcb2ac5e46ff41a34d543ee92e1b9e9e75e7ec901569f62caaafda5b327fbcecdaf71b57d2b419aa7e462437ff3421bd34bc0f7d3eb4bd65c375d71a94e43810c25cdafdd81527d9c0ac0741525ad5de70777c5f0c0fbc17bd1f46ade5a2e384b8380212a82040ea0fb9a724c92e826049c600f4bc40a547aecf6ae40935304d57a12a64c0844380936d3a9f497e85141f62aea116ea66e3413d5461b0dd98ecc29db7be9b9a4e36cfaabaafef6749e216f93b42eee4d1fbe7f1a7e2e9911e1942bde3c0383d2546a44e8932c0ad5c84feb1bff80c47b99774c2c11f33497f663bb398d869e6dfcf761cfdfdbb050375cc6e81cad7bbbb1cee6d50ca5883560cd36baa04a5c69a7593de9682b96ba97db833270eeaf1a2ec8281ec1b838d73748f7f46ecc2b56618155c376a65bc578f90b095057c2b10709c0bc74d0a9789a6ee7c8ec7c6a4d29fc38d1bb38b5aa864e6f7d9d31fa27dd78feb6621bb7397613938025f12a3d5fb3e32231177bbb74836ae145418fd4066e962bb142373e26bc81d37192adaaa1329b24e8fae0e13e5e8e8741e849c34f6853812ba38dd9c5671ee8eeec2efd397ac22a698b0cfa0f0e921a6755f6cd7802de9e98a5eaa74730d353a9fe908c721647893b0a34af27d90c37a4f15fa7e4bd826bb6043b23170f6746218002237ea79f194d0740bef800abe66252ad4543d42031b5a71ddce91c5fe8bab1c3922fbc236ffc5c7dfb7eb561af5f865b8d1a9f03cd1fcbd9d27465afa469a51304f3c3652be057a2c3cc92198f0dd91c19529ac82fa495d7dec4ae7113cf1148dae99f9b710b37fbdf60dc132054587c8e64790665c7bfedb78a4d4405620602faa5947eb44f6c0554f0aa641cc5519e19797fc155fbeb50a7fdb7ebdf9e8402092b53d9652a6a0cfab3775d9b780b08aa209ef1374914590ecf0e833ce38f00c7c4055631cbd7015c33d013c08e559a71d65d8c2dc1a87270883eb77594c2ed804823dea1136aea7bfa43b3aa68805eed1437d62e9cb5a4a582d5380c104e614094d68a27fc427013aefeaf10074725671edb994577ee89165d0655d6f62df4d623c87325d7dce94965abf27d395e88895cbe085c3adf7c58074154d5534835be840476cd5e78735f195000617624318fd7dca320610d633f19bc8ef55b64cb1eb5d768b32f57f637df293756bdd51b7a83cdac1cb4ff675566d2791f51ccfc3a16a6ee0829277a3dea0a468bfe24f6f40c9a7f4d03aa21286cb3eb09557975d0844b41899721a4a068357704de313fb6985bbc3f8cc5e43f6e33ef771ea1ef3742017a8d70914e8097267543d80099b55efb47f680eebb8b47194cc8fb2ee965949c0b675c4830d023ce28100e78c525f72c3a55482ea6a90bf7dc74b94026c5d96b6f2187aafe6efc9c9fe5f392e9764b578a08f94c7314e7661f569b1aa8f9c7c4544a34550eabae4377b66c2f574474db3f6b27c80dc64b109cde17de76ad175fcec95df39daae5c90fbe6686be16ac7b649411b5d5133698f7c017aa1e96294836d2e9872e4a0fd5b0396583f2f941831a2882ef024866a1d7c7a6c82a282c6981243efdb8b941c74391fe0ff07e53275716ffac9097f34e5aed25fc951639f3533288c8901fda2bf71afae44ad806fd8cd4376c3dbe0efec8134d5a58294cc5c43e1ea8c502ed3edcc932eb1a08ec5a5b7e296ff7a150b821e4dae27f1479ef5c27a17a9eb14b988def88dc3e1c7f789452bc216e7122c01328c4ad7a823aef9394a5f4bb5d9f6ae28c3de02a02241247f727eb92cc1d8a1728d63279c480f7f5f629d980f2ad9d68ee10b32db0d3292e70c00732accb7cfad7d0a65f48a7b79f74772b4e0f639d9062b6244551971c0dfa4781fdfd52606e56126b4f6240f8725b41cc01b211e6f7e3a79d3e02a145e87f8b7c02ff3bea9cf1599fe93b3cf6e3f494e9b58da8096f89ea157e6b92d40bc45482559e1d1850be84386afdea35a50f44cad224a6cb129540c747875757ba0fe553e09be8b0ca82369ca00a1fadb41fd5bc0fab99e1b2e4b1cc0aeb8a0bc6e409dc5caf353fd80e4a3c5f8f422220c16246efbcedc4660bbe85241eb89befbb029521101204778441869f391978077082be5d85620f7fe38b8d5fe45fee171958442dcf075ee575ccd77a06d63e5c3f206636a9d843aa37bee088197dc0077175424562d3fc7e9cf3b0393cf8ca82326e0e87096e827eb4a726aae11167017f20a1def4a35f3b484ecfc59b3a6ef50509212047add4ea4c06a69ecff8ba6a7092bcc80fa019a289e864d3a677a8bca0eb98aaaf40d2709d69286460130711a3cc7b4eb1f89727504c7c81bbfd23ff11ee8f4f2d724e46e1cec3fc45f1b169757781dcf069c86971ffb696d9734de80e830ea7d9c4e86dc45cb9d4b7632309610c44c36081282f5adafcf9653d7eb696c8430f78e0599103c0d094db6f5bc729d3010a15621b7092bb4dd6a339fa81a2ce3fe33f2a7b039f799dea5603f07f9607efcb636257a79549c5eff3d08cf99083dabbbe7ad59ddd3b1190876134ec552d40f5017df6837da6c12ee2a4ff5675d12ad547575994b11711f9bb7b0f9caeb2a565623d9b3eb3f70b8a8bb1196021d1d582f6d038e48d07f597001c6b10c75f259a56b0d6816753750ab669535e09cf81af7f214386e8f3b4e92d67ae4d8d99d21947ea9d963b51976c3a11093e5dfc5a220da538f6b13f4fe376ff93d82090e32ecd76c9ca87f7aaedd80685889ff8747a02976715cca18dab3429e8ba0afb2320f8497fce5bc491e673c0e98633884c9d8af6b01ca09c117654135ab94363c83349092b0151a446273dc63f8a551902a23d4e661db7685225e842a1e973c4d5847788291fa561e45e754d10740e2fe61a609f41904e388466f49e2dfe117a06076688a14a50c163f5a5106f2f427e09ca90bf904980baf8a086adc7a5f43c8dcfdb508b555552ce32bff15fad7ea3fdf3fd2e397c93f7415553cea2269235bb427dfb452172be07d8a72d3ca6eeeb2e8a5f0c041bf3040f46c4b029f4ef45cd7d145875b10ea73fe5ae71dc9229fedb3f8097b0894be6e0d39066facaad71315cc64dd3f5a835c57e1297db13bb992aeb486f8c3254086c7ff9e39746cf1ff5c823a17784f6a075b47aeaa639066fc1cc9da383e233b306cb75cc5cfd8f125b91a23178c7cd04f06120deeed3004d703579447f93d63c7accd62d39483f9181ccc5c6a6e11b54f9c94e35b2c3a2e831372211b155853af50bca75e38b265c7e2890b267a651799e5a922f1cd06a857d0477eacf497622fd2b07318d337e8b23550c93300e452dc245ba37787503f1e94b4558a118a38cc58339edbcc55029e698a943d1730869ba8df541f5d40a0d419f5c2814baa955fba5820642a559d9f4bcb66c7b61905b4b2f38544c3367d0a081e462c08de10cfb4d3fdefece4ce968dcdb527c4955be17c6b9041b86c9ac1e3095c5341b4b208a8b18304e318c7f5c5878d1b07e816eaa13000b7a516a1a7fd6825711af88d9b170e0aa77cd75878fcc9e13f3c030c5a7780387a6e2378b3dc952b34389ec9517dcbd54c761fd882abe1ba6e530cbb5d206499cdac22c8d9f066bacf377650396dc23ce58fb50e25193a90b6eead8ddbc23680dad9d4b4d46996810d0a45ba18cf065dbabec2dd40ec0c0200fbe90c64590fc28b01bd3a02a034a41d19a610cda70e5eb4810f7175334cacffb860b1b4dbe23e3d8b41faf4ef0cc89f0173fae94200a3861e01214e13ebc8012748be56a7ef8d0bb1867cd175ffbeb9a6a82884ae84b87cde5cd28037d5cc7df78a732a9f64d838b257cbfdb6448fff5c8fb3b1730a4544324a3c64826d0b72fa4a7d39117b2566fe696ea86465016b4b1429c5744d7162795080f3ad43439b3cd3306863226c839038c1e8783d2be4424a5fdba5f15bae28ba9b85d8a58f069b0cfa3da99c5aec587566f9e18a1f4f45e0b0eb9e0f25503fabef43b48919f2b42be048f9404d2b9d1cce2bf4667ff63a122ceac323d2556dfbf88cebf87374a7cb489121e27cbbf0b18db33dff5f67efe0e67caf812bcc315c685d7aa2f81cd00e0f23135034d24db95fd22db9e121bccf0e6ac873518c61c3e176dcc1a115e6901b34b7042870f7141f700ac276dc188298feaa93ad5682d1e9eb906d40eb93a5e70abaa1244cb2a79d25a630f14097ae54e8b9feec13976662f7958a2613a166f48b9d818c2e8bfebd4c8658dff1211dbaf281f760f66df6a7ca3396a8ea3c4a49510dab56a35c45415f909029fc808fb5a7b00139ef47afdf6abb7dc5e8a1c5f5d3397f7e9ec604e0396fa39a7830030ace83952febacc94d7fcb997b5c2555da9bcf46d0b32e6cd12a769033fec428e2541c4788402f962b1ca734ae3dd7213b3b5f5acdff6dffad36cf75c16c42f1e3f56313b2e1c9957bea14c2c703d298951684505660ac14c76893d11123cd026b8a939e7e0fc9d2560a2e213b12ee973b60125323d269d6015856192f8225079c2203fab9fd3bc09c3834010d74e8271558edc0bccf6e4d7b243658e418b4d8537f17c2e0642465366f665f9efd1f0ae412234b5ca7e99482803ae086379e2e2462b1992f9fff4cb80cdd1a2302e7efadb88462598208b1cd2178e5f0293a52596ac00b797c1e1e8ce7ae55a9332e78f58313d1664b3ae70c64fd72a26af5f4e937488fd8620d2a2027934a894e90ae41905cb529db1c5adb6cff591304f8ca4706cb757417da0f42ca0e96deeba28c7e8a1cb2dd12001b7b239eaeb876b14ee95e5a4f92ab61cfbf188c613edaa9c01513eea31ef1471dcbd312e2df392a3b79df6f73544257ebf0b4170ad747b03499b586b83c05bbacd1b5cce4bca9cdadb544e3a5a1dbd571adb293edc7494e540dd14ff3e2e865012e5368467589d9a415973470e7d0ca889cdce906f80be4ba5a0f23424d4741acb5ed79139eca955b618ebeaf23c54dde37d0402521afb459e0f9a86dbdbafb89242d8cdb3ae88a8190459282f04f07821649f9a896857c6d631383ae904135c4712e4424cf43ef032b7ca26a458ae20d94252f76ba89d277b9da354f85f364d4fc0f017c4f7f039a4a25756293a93e1f8548bf9bcaf0cc84446b1767ded5e5e0df0ddb2fa5cbf70c4bc912bec0252938669b5ea8649088995ff37777cf5391b97d4e8860ff29eafc18a6d00561c54aac0055edbda676255806dd7f6da3740e279c1bfc2ec749bdbefadff9c5de15f3e73c62e183e6666ca0f10b8d9e63da584b124b891c619a28b6754fdb6677743e1dde898b7aa40780e94414d84b5bd64ef193618d9729e3c82e920aa265e21624d25eb289f48bc1e263da5e33e1d4de8b0d2392cc51ca283f7e6d79bb5b2fe8567971425ab6d158616d641f51ba65039af9c1a528a03bce78ff339cf10741137287794dbe8c952e036aebe6800e695d25b81e9f09c34ad8aebd80a8d8284a03f60c4abd5d8cd9284206f2003cdf61c885315b760b11b67c17146cece02366ec57e9d2968849da1ff417bcc7e22ed6aaaf2e0f12b03e78a4a9864754661a84977cbd6411851f0368741274a0513e0e32ba253266c6f5747228244e304613291c0686c5ec1e2540f4f78b657b09de947964d6c98db268e1bf5e9a854984deaa630970af9d197e9960bd6921c400d75a18ff1a17fbb375230a9844ab093764eebfff74f31ef385d6c6b04a38914ac349d18a52665a8287b6bd5975b0406922c099b0eac5ccd74bb06d67581b74581a734e7fb9609466dc4ac1c10585d2e38ec2a60f8d153273cb2b8cadf809754997390bd431048f16e76824cd3fe0fed1ef80fbd3c3aeaf18dfc0c7529c1bc5e836d6581e177f76eb52b7d74ed6aed5f34d20b258fef39a1d5d6970a55f9b8dbd8e6daac1e1c39919d5dbdf3b8fb3846917c8fd9506fdcdcf21a016a256264ee80bc53660c18b26a85817a8e1d8c37185cfca52998ee83465e7db27cf7134bc27b330a00220dbebf0a10985a5b473d7d2d97aeb93074091d31c02f563d53f5259627fecd5b2b4b0b528f2b568f4dc5309cf01fdf865a1b281ee6828b2366e685b33b07001fe48067a6e701fcbf096700a73997e59248e695f4f9051bd7e76671a7e2b198bbd7bf3753a71c3b7aca19786701b7235a32d53daf4bbc24c348be464e8090a204c436cac03080414051240badf3790a3d3f8ea52cdeb5887c62602e46b980be06827709fba4b1de566e3a20ae635f53b9f0856e6593768ca9dec2df68a1f60a2b84e7714ba0a2b2c3dfb9c681faf584dbd80adb34d51827ff42eba3e772562cd37521c2b5835e1b7bb427eff6ed97b3de39f06d4f60f9a61693cbce49354cb5ec96d5a0ed86e09e2574976dbe3c876f729fd6e42e25b13facdbe84d1da4ab810ca9393d25d41af177c5527d5c6ade49e197378f5df9f82c773df4e93022a893d42c789279ea0dea0d45fe318bc63f54bac0a80843a2f37361d80c7b38e5ca0f97120022d7cc0a974565694fcb0a1f72d471c6ed07d7d37191fe002b7b3906a7494d49e1099ad5624543c255fb27c3dd15f9d0f9c749fb57748eae016eca8d146ba87f52b13a394bcf5c5bd21548c257bbdad1b08e1b458d6be2808a0d362b68655b0c438f4b6664a7a12ac3c583b8bce4f2eb894938b0533bcd039b163741c68b59a4134bb3f0ec3564738fd12fdb0c80d4d8cc2066811b87da7f840ebff19169015c0519efe6fb29acf94a0b07c3399c74b1294890f14736369fc7405d82a14cccf38f26df2ac61dcd6428a8812458e075acf8ea9f75586940230e4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
