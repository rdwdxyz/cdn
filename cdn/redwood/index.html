<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22f7ce9538719dffc40d3f0c9672b60de7c8c4c47eb9f4fa1115b84f99952659446d82dae4929809d063a142387b5f073ee69d576eac40067b453380d862b60ecf4c5e9c4f351bb591c4a67b3698b64f888adada6d51e52d783b8796706e07463daa120180c261b636a386c0601e035d96bc2f14ff4ab9e2f88ccc101bb5cd8dd222e3f9eab3f72c6bc1e37862d5355ef4c3df9135926f8155ecd876330ae559ac208328e7df4a5a02f436ecbf8d9845625d4b404743fb335c80816d7a87bf7c129dc05bffeaac9325871edfa1b83e8fd729185ecd0557c37afb290fdf0eaa2fd7552181d009669f43a5093ec7b64efda296e40a922da2cd37a10aaafbe651f83dbf5f6c48c36ea1501fffcc94e090e6144837b90497596ea49906c01208c6cd5b41b6dc3b1b84273ab8eda51cf4214a41c91838b6e003d08e6ab42166ade56b7b0dacd6f0906e90f85e0652474f452885926b6a1030153bf6cd6e0e1705b530a7ea4ff226e270dbe7a25da55d5ff0db473c1bf5ac3982d8bd15082c32d6efcef9ac307e6f4b6fba3569f5089d774bd6b17d2f78e703137bcd8411a19be86192c65f374491c18c768597a6baab96b5912360172ae183ec049a64f323193bb2a0e9a4666ba6873190cd978fea567497b8933e3f4dc6ff5ba605be1031d7e17d56776b5cd049c51b9b4c6a4bb4ed81ffad2fc32ba524035be3462c1f7225f29e21bddf9b232fcb32dbcb375fa4bbc03f7d8023eb30d757a7cb01991c2b60f66e58833e6d5acf64dc30a134e3129456bb3dd2c3a8d63d4fa3ee48319b6bb81234c6a3dbd4b568a68e141979ada6dc2a04183bacd89abd294f5b13f638a9fef2ce6845031089a12d488e2a48617941055a7b41954486dfb21a02b39de5304c8367ef0b9c551bdf775a4d6b89d09f7714142d2d90c100b85cb3f1e21281d796eb92b42b8561ad3c7c4892ef4b28b8530bcb5c8cd0c3561aed1da6aaf0ad4df987101a751d3f0fdfec9a7da285a11699f6d2f233f9279aa6d8c951b0910c146e40876f33e4bdf00eca61ae7527e108aca9abf5e741fa27c82f3cef9807e849dc15bcbc77a9329f40cda410f6df623e916b612f0fd3d3ccb92e1b514c397f0d4e718ee97a2269db6b1d09a74d66329280ebd038f568c4f5425918dd6464dde84583dda6de97e7fd0902ddf85bb6ff5a84d544cb063a4bb073d6a41c5a3786610ed9cd779ddfe16d4e758b6d6b538d4be415055e76e33b1121f9f6594ad8ded86bf62c65069340019eea8e974711c45fefdde13ec676ab8d7756901ab6b2d0ac848367bc016ee994875db52fa1eef1ccde6ed174ac6cfa2d8bdb2ed8ed3ba235f8379cccf42d81c3a81c7613f1c4ad4046e7b79bc1d77cc40b21a438bca7a7bcf2cc3bfecb2242c4ac017c2eb743d522943045c98692a82713e2107e82a6af6a3340933b139abe7f49dabdc4993c25756bbbcd46d12d0ea09bb70ee11f76ba8c5b8df1190e3780315f3d303fb8cbc6d936ced18f5ae493b593709fd763ffce06f6fc120fbcbd3d75ed46ec97836f32d1176beeecf5a012dfb2399b49a5a1b00d9cecff646ab8871b5201e145e68db096d21ef984ac2206db23aeb1fd33b6b44f12c5fac4eba408ffe42c23138c67cc1a415e19284de674ff06d8b1bf45725292fc054d82a7008d195e106313e10d34d08f5237b4956f6086a9d5310a1226fa6243f48ca147be636a3c0c7a1667d9ca7134ce29e2722080fc4d9c165e95347aaa98cfb6776b0dbbf1c35dea91df9eac87864a114de006197aacc1b9c161041927d20ba1bb0fef573859bb44f2e77933639137072cb0e2cb09af12ea17f449f1b1ac06f677c669c5e484581206c68573cc1b245fd6508a6d9806630ab306bab55dc359bb19bd5a4d4349d864a6b6c33f57c9fe60b9df308835de2b72d98744a5af6f045d68a3232631cd4b1f03590b9ec72e13869c9e37783f238c7d942d3f55aa25c65ada6d9250c8e3898ba2a20baaacff0f8fb208b1859c62cd2112001c592cf607164e7e4303a6a15bc11c1133b3424287ff8c478837ab2fbccb75e4305f56bd82e6739515ead6310c513330d9d6af0854375e7ac22ee7083dde4277e4955486a6b021f7bdef1170894fafc8877490f614587fe3d2813c4e3afc0f594060bbbc32e68a7cfeafcae54796f72e018f3ec426d2635b5cfa6b60c04753692f2030decc6d8136570e8cc6158bfab69ec05eb47640ee2a10463e0154129821cc7fb1412ef68ef04a86170207f36352155dd25a34db49d4099f3ba44dbe29d98481b62e5abeb60c02c85a84e37f891d5bbc10c0cfffdc762d3166ac08a5398e012b15aef59f15287a9cda51dac997c0885e6eec969652213eae8e30d6548ad55681df924bcf97b0084ca6dfecbe8abd448f6f1ea51a51094cc2b322f56b5ad9eb50d28837e042426c2613bbd3ca37fd4672ae36bfcb003f67f7ba40c8baf2d40d9ad0390c332fecb6685da297d1d17b852407f3685d0ad860a9bc46d765316cb51b8068a46d28bd367e2f1cb9dde64750ce80474e3d8d67c6ef123c50ecc1717a62082b373dda9a06851e5857ea46fef1ff7d470d726cd6515486d46e2a642c6c798b157eedee33d6a645a294213f203e679b60b8edb326d53561be7d9d71866c360371047dbdd803b3abb4dd2608af91599b48ec62ab347764b87bc3ab4acc779fed7123bfc628c26567b7b0bbbb966164604e655cd36ac0b8ca49b4b28a66625f85a3a48875bfd3927a244f6022b76115d37a42cc913d983ac7913c2d1f1e3aee8ecd934d15888224654bb967d0dfcbe04e559a39de6378e943f84f2893ee2abba8321e3cfc8aa42a7eb52f85c1f7291105470c5c0a4534a0b75be0e5a49b6c85ad80a1c0291b18340527934afbec7dcf54d921fcf28749f8d76c196eaa17292348cee320fee31adb4b1c47b7799f64c2af9555daea202c7af183caf0a76f65192941f5a5aed13b05d4c28a26b2fb8c25ec810bebef7dc350cc7e8d9b7a6fef79ffb6ed45435cac3074f6790bfe0de2b49ebb4ed21d3ab9b34d9f5bddc2acead44fe9b2bc3a3ad5553743c00c2ba429f0a7091b535f035b6e8293a2e676090b213b2dbb1a224a8381964aa49c78b4c2698e653643c3526b4a40604a8560864d26bd5c92f44ecffcae2dc512bf1874e95bf58051b8ca037fcd7e03b85ef0aba8ff1eab98b4f2784d5af3cc761a2897da83354af8e730d06e30e4e03ac95ddd2639f3fda86025af1f62c1c4e47b4a68b80867e8dcab99e5a3d727a1fb644326f078fcbc2de434a7ad90d406113d5b307fd920e28feca4f96148ebf999ac84c0b6f2802b36aaeff3f7a21a96fe9406881e6ffa94166bb7a1dc68f227efeebb5a94eda9f4642849d75f1aeab4507d4b53bf4360f87d16235abf31340c1de98826e86ed9d893bb94af199d021744e653850b5ad8957a8e08183f21dd291126c76390536f701aeaaa184b8e429da67ebb2c52160dab04d225a6f5efd01c2570b212d632355f998456117f4a02423a8156c10f72c0de9182bfcb708612993ad087b1ad0d5400010caa1aad7ad57b7c2b7ee28995047ab4d78cef264cb745fbd1cecf3eb88837f877db767da63b10f6e2921439093d2ac556261323f3aeef997eb926a3461c36f91b3fb90276e6b83a49233fe077ffbc5c431126f84d5cd121d90a583a72b6259c50de0e2bb37b8b8108a0314889620c1e443cd6a24c69c414d04979cf3d04ce77fb0f151b5b85ea1f55823187a4240c6020d20964e934cef4423cd7b78990c8793f73d0d9232ee0cc831b7ba8c4403bcbb1d110f5be7b661ff310d4fb205162d16554b1d3eac9dc08ecdc5911c4b299ae5f688d481bda7de4906213136baf94560da784c76ee0fada685279ce6285b6b2caf2f249fe48d156a7938f3984317d88082fe27eee7ddc3a4afe7965a24d52230dd28ef92713979c1331b0e119e08d1805b3f7b6c0eeedbfbff203450eedb7b6a77b070b6122c7b0687862621429b9c86e7631be368655e236e6f788e0d450dea1f063ea1d67127b5d89795d9e3fecf144d97d11f1b54c26b879d65ef7d4bf6381709afc8d743250584c66c6fef22781b5d34c4399eea1420da13c55c21c1141544d670f9858f792de041c68c736929dcf167688c3c9cf21d2bf589f98a029788a1975e60bb56caceb2a4c2b2cd503d447debf01002107dd00d54810ddbad13412d4f0f4debfc4166e3d349d2496e77c0539912057006322bb1b52d01604152dd9936f35bf8a699bb1e7d062d50f3119f24f40c649c7853c78c5429f9f96c48c897d80f576e29bdd455ad9b1b4f154b3a5f6f858afe936227172375ba2597e032eea6172dd65bdac3e30ec77b03c572531b8eb3c86522700939db43cd16a01ee6ccd590206e7de3b46c03ce00c57e8a54e09abbde3b0e5a3198dda6c43b87db821ad70dd5c47cb3e2dee0de13d42e7060da499b4ff6b594fd10584ccf687877ad2553d2afeaf0f57d72cc40f1da28d6d7226a93f784833ba12c2d6ad264c4936cc96757f1318ac5f5a4ee17f477543716609a27d42c74af352abb9231795a4d652709deac0040bf17e60c088419376341b192c30cb12a2c9b7e01c5439de31fff5484266f8cdf1a812d09646e3861018a0db04c0da88ce0249db91fcf5b85b45760537292b22fa0eded099e8f3cb2ac339d8a7c1e292e1b1069da9ef39846ec5ae3f9f533f4687314737921682a11b809aee48b2e80317e2ad65c9e1b19eaff8b3720fa56271a96ab00dbb12404f2ccf5dabe9fb3784957b0891b6ec660adb1b60ed35cbd2992bff6cead5137bc3190ac222825493397d88ad411ed133f8a305a9bfb3416ceaa32472ed8b9ac71158e00428fcf9249d9c37ace17be29b765df171e96a2983021878826f98120658eb2257aa336ad641979aff4348774a39d57a3206d58122f31fb5f58be75626caf44862a6f4c6da8de8e13ef0abb8443065dda686c9d9e006eb9d555eb202833a54e0a4f61b412b8b1a6eed6d1811de2f41c502708f022a5922279c2945d77234a813127a821f7126fe6442f95491f725401a241cd5783bf6c9caf3a905b70c70f8db7d1ffb1e5d06f511c3276cdb99f02c787730d78fa935efdc2b89cc57226bcaca2b28eb4330ba749d80d8d97c6c73466c12f13f81020f17a7edbd201109e6f71001384db17ea2fd9e5bc74e701916f3d8914541b931c33c20f4677c64a5f065e60dccb593faefd07a6548f985b80a69a9fe2c7aeb2de308abf083a0d9ea807417c325b88d01b9cac9cea2702d4c5596421b8c5a5b999e1e2bc44e93180b703bb2873abfcf4aa5e49f995f355a2825a415778d8d72f6927b02bbc53030af12e9346c0133c73913785545b0d4a15d934ef9bd5fb6507371445cc2ace2387651dc80fd3fae312d6e60c0212575be71cd1972e601773deff2b9aa1ec4ba5cb229e7204838ad7f3adedd8394d4fa5d90ff34fa7c17e60897426c59ab9e523a0c257aabbb658a13e3322de69f9e7bbf3e855e3919557d7ecaa2de903d918007126e1a962555b0f3aa847b6cb0163287117e50b281779e1f70bc6d4e192e78af9c5f54bfa73d760e16560d2fef011f5c6ee98f6ef3c656c0e2106dae2b55fd832f3964af448317d8f7081eb6c2163823b8068d1bdaafd64f0ef4b1b1cbd855fa9e306847106ef2f9aaca706f2c7dae06bf25b9af191ac18b69dc29ff2b0455931ebcc77c2af773306664a09294b4338ffa7a911951595bce7cb2c6bbe18ffd4b5ce6eccbc2200560672971226c16bda58df7d995871cb0edf428110756f62eb0281610b7098c0f6eb5ac5aea89929027fa7162820eb532ca483c86a4b4d647675e7f048e907af20fd7b3c62c91187af0936eaa6ebfa6891769f7b3c737177e052dd8230300dd132992442de35990b7b0b8bf830f6a0a6636cb0bc0ff6a2a5315b78b69268704084b893f2ab7bfeb0fd50453ed71aacf984526db92d4d86ceed44ef7365e539a7bcdb9f9a3d109954f2fa27d42643463f8a15749a357e8122e57d6eb6bd7938cdbf16105ec0e8e933151732a9fd511af47eddad1d2a562b1df69c29e93b9b683c15a37ebebd5c8783c5fa6da9d1070c0d3f7985b220ed7afbb3aa5adc65fa609db5e56484b694856b6563cadf0f61f5eb2a604f1e7c7ae518a069f8adf790821d6365899cd21cfdf09a343f5147c1990af60b2bbda5b8436845e1eaa7c410d0642cd8336c02934d372b2af44e3caf3ec58ab187f35b78004eb50fbbf28c10ef3c31659f77eadc76d4d351b14a3ac384debd2c670a1c7ab96d7c02e524aa973137f8418afa5fd50aa1380e6a933d7dde3436e30573d1e2484ffc312ea84948bdde775ae628faab454577868d5311781baaf4821b4805d93285b4fa579dc2f78375168ab9fcc8f31d6020723c343e03aa7fc73b694483222b57a259c43f7399bf77674981f0515819e7db0a99be807b0bcf114c7f56cd2af5545d547a60efb4d659c5bb47599837f8f6b0015f0d3ce732a22c2e0d74576f3f35380d67a4dcd1176f4f47cb7275c1d80a8c2addb0eeb3b970d5e5fafaaabaff380286cb45752b9f873051d7ceb9569f5d613317326524bbb689a6d4dd2e6b940bd8f063cb3d11f41b4f074db536bb37ab79623cbfce44261bd75a2a71bf88ba2efda910ab969b49f3f504a9c8bf7990522f382a593ada21a092d94b792a8057f3224f17f556beb8b5657d554a696bc5816012619370d73950aa97da261a1d69cc1bc39a70c4d9964a1e81856bcd1967123a03a9e50193e4ea53058b848b5b7d489159c1b821079410d0fc382d265805eafa3d049c63f38377961679580f4d93f9285065a52bc6c03633b73ec7a1a1bd7a12ab6eab5880b01110c66085f19553c38b8966d7b46f83b171d30fadb942af2be033bd5a509b50d25769b2554569365e853c6d65ba983a6ab50496d513f9bf266c79a956eda930aafedf2f4559dfbc29e4e3eef89e0476d7bc44209bab2434148a2ab78fd897a84fcbcbc67d7045caea969cbb9bdffdcd94bde5e47af7dd51c394cd36dec95117490144fc191269299787b70ecb58c66bd1e8cdc44da8ab369de02524d4ae4885b4f58d87ca4fe2715c863426b48ff90be61f2972952654ffc5d81643c914aa8d0385240810a895334d7523bdd7a45b3d26a8d8dc22a018b97ad3672a5822c3b65175f22d9ab11a05fe4a25425eb27dceafe623b34992c6febd94f52d00bde0fb833d33350d69af04c4552feb78414d195c3537ee732ebd70b5e6e676381dda71eee4041558f214a10fb3d1ebc66b87d3667a79446d7b4cb19895430bb46fd406c13bfbc44d23b9a01e957ee71bee9ea00fdded008f7838c2fdc9db5a459c4cb508c0ff9a6ddcd318e7b19796ffc22cbe63a0fa8d099d65676e86462890370bf9ba8b244b30f7525472339f03b6ee432732bf51fe3832d8391c5ce82f8e16c8fdc7e0bb765d13f089783c3be3bca0dbd82e9ee84c5492c064eeafd502259c455ce46193193662564041a73712c7ca18de23dfae6a2717eefdecddc7c69cf1a98b5168f0526ad1b53c3a9735acb3b2509d84aaf46bf2e8a51288a0d783489a93accba2e7261988c68073dc931b0b47e1a6b3788d23c9bf0d2002b72b253418295b8ce22a3b5f5448a6b47109d16cf130eb5f372e8f056ab99bb7219249951f9b549b393f33a2dd239957a01615fa3d68bb39ce39e3730101be6e0cb220d3877bd53283b2359b5f105f86f8c3938fe7693cf7fbc0623e0d6dcdbdc29366ec5c8311884ec88026569bcf046e1bbe898406c1db3ffd6961e1a7e0fd83bef00badf99af0b0538383e740e9c4159a8afef56cd059aa5c982dda4e4ed8c9e97cef678494006aa5e99ea665f9093d04bee1ba9cc968f1da037e2a6780b8b7a7cbb1e209d0b4962566647f2befd1c1816ee5a0c8baaf3a7883417a52c24c000e24922c66ecef5ec53e730e960ab8f107b55fb88cc32203b746b08cd6533247a1f99e3a032a55a24dbd2fe9aa958e32c974a3da274b31b897c55b7103918548c8b59266dc1abd5ab00e8acdfdd7a4ba15bb9afead4509e08cca272d91fe8aad1b78b8ca9994fdef75b4e793c4113826e4b088e92779b9bbb0b4b8fcf2874da41d9cbde8385c36e07d66957b61d3f2f86388d1583705b9da29bd2f209f05697761fe607ceebba96a492cde74da7276841fe184b3287ad5c086d19a0333473ffae6cb9fc45bbf78763bd5ca67e92842f84748862b31af1dfcae1292bdbeceeb36cb3dbc7b9bcf736c328094c589b49dd3f0552858fa83b6712b8adcf20f3d78876b654c61377b0efa60ffff2b00a6f83cbeef25c15678d6a2b82fcb53fb53e3edae372866581b1163e6c7a9b83e61508e28b546eae3b3c535eb7d6f623fa531fd6385d4ddc56dd2d934f6fd83487a3ea3427441c8433cdadf9d234359522caee6b71104b663e3f1603948a83319e26380615dcab2ca6e026eb805724c04eece38e537f8304ee5b1d78a048517aa962f49eaddc8bf9682ab7c8de5bb0a2c6cb0d19d751c7b79febbfb6f7ba38f90d240a38e04d5f92baf847ac25bccb46afbf8cdc8d37c1143a1681c89dc048b2ca6fb53cc7610c04fe24beeb4ae73e494d7b01371e99399e982bf8625e26d9aacba736cd454f0548a2b42d725fa4e8470ab5c922fd64d575cad42315fc23a472f1c37ebe736a6eef1b4491427d3aef5dbd78c0cecf46cfec2713bf68da56dd98e9aef762896c91cbc85ee42e045bf3dc964f7ca180fc32f831243a20c63b8a7331fde30f6530fe5d71c71e9abc47edd52f0c785b9909ecb730cd3c16f16d8f10fb203fd8429cf9085ef1d1bfdb15d3c50d95c294a5c0f92fa87c7e40d46350fe6e4046ae03f7de54b20fbb570881846978a5a17f67727c3ec771d8ba70c784205a1228d10ec0aa7375be112c6f5f00ca03268cf9f401684e7d7ddfead61efa53c3db5ef10747385624245a36a27e28b29729dbf243ea8db7f06d38358ba6ec94718f68c224f86ca5730404016b388c93b062ac79f9c1a58b7996afeb98eb805d6529552fd8fe84f97e083f7b439640f19d43b60dc81a73a1aaf29bb8585565693128a778d5b5e1bad3bae71888417ed26401fc9f05a6975a879928caadf50a49a7c5bbd39388151ed40ff396ec40d5ddfbcdc0334d23f4f18407b113fea4ca0e294df7fcf1036e44b65cde42ddd4489d50d5f2fb57c6dd2267fc5e71f8eb8a2d0edece969a1e3a5e2c12abdb89e24869c4c9b577b98120e45b8015e72d92e4a18bc8f06ac8ff33d9c5d4fb42818fd4ac9341e904675c0800504a0528b62b12b9e46aa3ca5464ceccee252a3c12fe11332e68717fc9fc4a90abb17335485a72ac0cc37b4d01564ad61c33e831a6ce1030c1ff7ed04a999d3592617b07b5fad568677f63e14312c57dd291b16a402dfdc581c5448355f0083e8d6b7dbbdc3b0b74e7c95852427e78db0e44f829187afdfe11d9d563c54e84cbaaa723986787e8d2c71a7c059de9e42212e8499dc49dbefbf02873609b9b2bc0351baac3284617ca8cc82eb6bb5b77346f93b36b37ade6779ff7ea318855e0a1cf7c9a7f1496144c22394acb70cc0b1a313c0c0141ce3680123e7819fc57d2c2dc749a2b7fa583ed822939a16db0709ec29af68ebee3008fd43abf0d4e87bb96fa65ff6f1ffc86610f22d014d4c0e9b0ec7bf30d940cb03495ced0b7dfa4d204aa17b148aaeb0cb29c22eed583fd672e67c0a091fa93609b362d8c6b93df3524d082e6963dc9f9a5e3e81c32023b0b8cab16b02b16cdf24c553c1d34ef37d1fb3e997d0c38d13bae63d10cb5144ca8ac30d77d5040772e7af11ab0944fc2241f8b76181c8414957bd35b0b347abfda4fa0f86dd86c1f511c642ca244bcc2d4ed3f4b0d298eab23b86abf728c1661033def7ec2299af2cf7fa79723fe611276ce89235639285b975b0c5b9dc957b8076f3f346040ad6b5d4ade625334556e4c97825b4a69a5a515ae1ce53c13cea84ebdea142980a5ac207b9d96825cb7a93ce0acb07fd97ff29c5e0f242d6fd0a2e99706933d27601004e76e4e7f611e66fae276c8a07bde3214c743a1abc0689fd2218603b21cd26ec9ebf6a82aed6c8f476268950d245b4c41025d2696f6188429a1968e33072aa1ba706a7e96f07cf65e916ebb39313804aa285bd7d3113ca5038c6573a55e201d1c12d3e4cd197393d1268c8c959803a7c26d436b53b7b103e8ca64b904cff59873dd6a691c16b136bd3a012baa5a639f818262000659b85f8186844453c35c0b481c431389b8278032a65d24c0f019e5198c136ad20c3c28c29ca38d0712244ccc706178ff8fca1dd49271275ab3ef5fbe27b9fb5d561c6ff8020c449bf967460a331e974fe1ab8280b9b9b98d4310aef90f17b92c3de27305cd9d038cdd051e01b1b5044844eb0b792d497ba760efb8a4c7f977197295d25b66d679e4aef0a19b8d257bfb0bece76c9df3fb5339fb96972c92ac54f080f2c308ae8e81f5ad350cf29f1eaa14f82bed4595366151082b0cdf0c788fc6755d50ef8766d742d86aad7f850eab790d778f2753cb7cfa31feec9a1dade8726d65e4fd0298f9967bd7e6c1fe238ac733dbf4abcaecb7ab3ea063a60e381be2c448ad76ffb90f6ba0bd5559bfeeff50bbd27119c4b8f961af535f2f2ce0f2133742f49956b7cf3e539a15d869b419b949ee36dd96ed8409395a885f383bd381d83379bf987e0cd39ae25cf1a93726c65002e87d5930b699c5ab2f3c7be81c57807b8a296e2335a8c0b0e2f2997a66d77717521331861fe89e98fc3679dd32277f65c06d3b963f4b39c63b3786fa01693560090997a8ebc8d1264585a8086ad61f47152216f733dc2d7ba90797234bfe37463994fc2ed965a08e616c0c826b3cd6aea0a93e12bccb0349b434954ae300029d231a326b81f82834beaf3ef9633945dcbc1ea761937cc19ae350eaa1b779a213d7b145fabebd152e96d6de2b2bdefef0cb79394eaafe54870e2f9464c36e10e0f7a8ef0f9463c7d97a8ec348df5ba4c773306de73df1d67f2b337f6051b11dc37240a2a7ea012c408a5910895a1d5d68277b994f1a82ab905f1256bda26dd8b0990a0a38fe199860ba15c3700e83f743688b1affade33c2b1fb394df63cec2f42f1c6de04cc707bd52d74609c7fef652558c72c2aebd059d0eb35efde5ba770bce3a52e54f45476a5cb97d93d7d0cb486d0ec194d8bca70b3c0e760112dc3e125dc09ad7fd36aad3702b1a38d17f7c8a9113ca66e03be1fd1c573744d863a1d240a49cecc76de2755ec76ff0ad1283df9dfa4151cd0421c6a412d34d1955dccbe7a05ce4473c65e1dcb60e902973d6a358f199afd043501ae8a63ba8433fc515deb8323b5c2aa04a7fa4bf2b79131f540b27d594abdc7bcb882d068d61c26eb8fe9b52fb5d2de463b9aed39a451057bbccad659c1709fb604d1e77aa30a8ef77586a4834777d5255c218d9c176a9fe26c90bc0594004dc71af15d53fd90dc39064b0efaf54c715a91fd7e4d375ebb8099cf7e0411764497c3d978b49cf8aa9cf7edd3aa4a3759090caaa499fa5de547f849f5c238ba9c03459bb8633c9841f72216a8b642f47a998746b8142c0a8a0abeff56bd773b15aebad6bab79dea49e65d525794ae69457d30e49b5ae3c54ec63fd580ddac2470ffac58520e002f00defa5eab81ff8a301a7b6a0d647ee4341e8d8ab44c2492ca3a812267ae4e16e5aeaef117d4c4ecdd2d3038eed1d3451ab5396b0ef4a92e74e8cec6d962b342d5bf158f8948e9bbaec655f24cb49109dd0d34a66d039acafdf9ff88939e8e59d3dbe75f93f3aeaf7f895190deae3f9208b19d884dcc2db3910c246217de96c7208464778fec079be2d2b97bcf52c74336feb6707f0766726210f3351333f21eb43f3247936c3d9f769ac6d4ce9e3cd80a4f7aaf527b0b7f371640b3dbbf6d9698fd6206a8fea82f9133a764937aca082fab34145b94d69fbd39dfa49e76ab71481c4d6ada07354e0156d405a442e4ab228351b5f1c89c91ee73a0ffd07fe632f913aad7d5a33ac622b2e38d5b86442515013057f1dbce499117f2b203ab0bb4def9ec3ccda06ba00cba2a0977bc27eb4c8f7dabf59a7e891b8fe57d18f210c37670dd1791a104f06999cc70c44c14157d3feaa655b30c51d17843a11d7f0961af675b8948af10a03b5b436b38149194a379c4131f918f04ce67db6a8e667ec8facfd20f0a212473a85176d14bf12925f3761e86643c324bbc72879cb0f65ed786cd316b7b3e2c6c236726fea6d204427f7a7c5788ca80d4c977f3e43d85f902820385368fb7a2d36321c7b46affe9d280f096ffb02744a33598c796a5a25e3345013b015f0eff87f62013e3cf9d0e7facfa7bf11a7cfd9b144ed103e18aea20d1b16cee6b7b78a6a254f644a7ff7a9db9d15ee2cad022e0f049c7a0d5b627ac95b0f9bbe04648678450e445c76400fc18481b6ef4917e0fbe65133bee2fe086b97dd2eb3b438b1f55728b4340c86bed69088c0fe4c5f017780ddb5cdd12ec3255e246893665b7baacd261683b8e67104731f6a327a09d500c2099de8d94537d949a0e2bc5fa88faa4327bf7393881648558091142021c16d215b8115fa724fda80078635b0161d6fd0cf6417cad7eea2e37f9374776a8334cef597d4319402f1c869570f93b6d17a95c0c4be303faa2108e128a1084001f0c477ce92d0cfe698de27148db103f613d171c9a17b1bbc1c8e8b2c7bc14ea279e3fc6c36c111b9a134f0fb51d53535808937fa0434fea007fdd3d3bd9b934e304c1b86aaa2f5ef2f9b43b357f0005e4535f391adbd3bc3a78b1684b9e90c6238f37f6a532c4e0b2bfbbfcc12cb80ea32bc5ac18af7518fcc1b03912a6a197ce03e95e4ae5b5d7bf23cb19b612ae6127ad3b4bc7cf26adca9f47d679c5e1f10e1527af161088cd77356dd9f247d8647e2fe43f97c3cf02d74119c7af87ba63b9a296ae47d03b43b1ba4afe294add62fc40b5382d53c406c08e5c1f07bf3c7e726a5ab43580d7d1e5965910411b0b55cbb311dbf0afc7c3c9a1222831beda3ec697cc11c31c2de5ee98dad5aedb7ce78ef2357c5a1bd10d4333d4ccf721fe98fb08e8bcd631fc8011923aaeac3d97513b22dcb0d608d5bb013e02fd2ae8e3460c8823cf1cb4e8371a92ce357c80e4f0a343885d1865cdfb4d17e9e0c7a70c40641254cb5b17afa6075f51840cb927ddcb6e1b58aeedf467480f590df523785f78669d6f1952fbfab0f75aee72d9101f51c596cea216515740ffa4467aede6407bcf76a5046366b0d1dd710e557c3a6e8af166da8b05079644701331bfc22aa7cb0754a818c2279f24b48ca24599d18f19eb87ad60618644ffe5c44d9f02dfefd490596232a9b58460a8bdedcde113dfa89bd0ff61de96eda84ea0967f98ffce8d97d40ae37a4faee5653892a2f25af7933cd592cd5955406e6c1dd4524935fe755f88044ff12df97c76c3a766387f908d1b8a64ae455f6d3b09efa12f206bb5ffd69aa3a9e42812e9fac7e4d10bcafe6225a5a2f6f16731b76ee5c8c2c5fd4a01ae81d907d4dd2321c1788e5dc070a7d8d9f06482d2a5f970e89b1c4d93f016aa2294579f6da641e7b35bc14ccd2da8d6dcfde2a7e65d2d3c670e5099ec1f92b56f9e3e0af2ee8ba317d411085e08fccf58ef4dea7163aa404fe7f7fa6e1fbe19444ce1eeff3d95c3e47f59b2b5ad6e63d589e3ff2d354b892bececac7559d8524fe99700ee27caf57302c586aa6385420fff80c411dad7365e17d76c3faec8d04cede20e378bc913489eb4669e7c369bb5e4f0ac3e9555e0d2f9e187cde21ae0d28bde13bb985136622fdd8e15685221fc809e7318f8507a3bf13a8ae129a4d4d3c2545e8e590ec4a72b5ecfbfe6c2ea55ee99eaf0c79adc412c64d51def3a7abd528ab9a14dff9f3b8e6f2311ba772ec1014884b2fe05bec199587addbe66b2e13fafef66eb5636b13659d9c043984958f5d78a30da9fbe7ceed70b256f67aff059b5ca60ede4f61f53ca99f2154a8adadc49d0fdb71d5f6548d1bdd1cef7a0eda0c7e65b465e3f02986969ccc6edf2bcc58821b2963480602b9317aa189f17af62078dda8b440346a5b09ad0b260f1d9f5a955e8c7ef2b8e0fb786897ae44f838b8c627507af4b2e71874b8a6c30abf9a43ffe200606ecfbcf7f9be38a318bf228d052d4575b5491ef71268e5b4068cda935e0a715558c9c31c31d7d1341bcb1160f9925f5aaeffa0b43a079ace6e8ce53ce7c2559d6fdb4e79bd060d2793fd3f44e30a2894e7bcc337aade93420d425463351b6cc68ed0d832a4b2cc0073127da673c82c292c20120c628bb8c244dda2ffbd1337aa7dcb1d59dbecb2923617bd78d018070884f687fed0d26983ddebcb07d65381f5e84bc9fd3ade19cf32bfa3fe1db6d66189de5e630c56aa0d0431d476a2345411b3b7d1c5890d323a6e8becf9496253a3feb7e6c8821cee651f45815452daf5129a05884394899e0d66d50e2171af2cfe7b40e5b8c3dd51f00efee56fd1a032076a21c1d395449c2753bd09024b44cd8dd35f08ddc011327fc135584a6b05b65aa61c03b0397780d0b4e7ba832e0153257a393749d02f42da7f2759f3488c619ddd1c47fe9d82cd4dc177d6c8e839f3aec1339b9e1242651cc5edc608d303e6c3a06be710fa3c7a1a231e1f6868f28797492bac2b08b43c98335c7efccacafcd990da7a0a29ffef0218021213fcf493ff04f19f5a9641c5ccaa316eff74439fce49ff01a0e00de6f0a99229e813e902b643f29caae6e897fc088a8463c1d6d2d0ba81c1051c6d547b21d793d8904b814d44fbace6c6066be14b17a99cb6f787a5a67dd3a271d48cf6f904f5464e723cff5ba0f8d631c0e1c23e50e90e0ee067ca4cecf8e7107fc215279127630d5e7ccd409370de4ba0ff2ebf107d68f3a81bd292233ce35495b6fbaa49ad4bfae08c8007dd630dd6c6d3df1891153356edc38c5c13a6070cc764b1689dd632fe7273dd2c8ab52ed4837bd8395192fb42c11e48fdebc4e113fd96a57a13d8f92550f672dfca643a29c8b5238d8d85628f5858a310dbf9b4c4562ce293cb0711c86e76b89a208a51eda4b5b0d2e2c8a1bf17ab5ff4a4b7c14ca74302f897560441abc945780f36ee968720370cd17f7ec10a7262a64ac2db8cd75154fded47bf301786e07d748370fad0ff5d14cce2fe8435ea3dca19d47e995ae3ef5e2daca7d92e40e8e280bbcad777150c961075772bf0d430f6f706db198d233b7478c0e41e00f226083bc1cbe181ad5da5ec4864ec996f2fb0ae17fe40a8c95f6d25c5b95e541afac609993f3045c9231d8fdc8923d85a7b80c9439ec823a70276629e97862aab5c8bf62e612b2f456838c9b5cae1c77f0db16024226984430f236a5ad03def1339b79ea8917bc46e439d36b97db5f73596795675d2b45d3bcfb38c8140a333aa7f8c2da67d30b8e62ad223ba26129327f5a1463f45a8703187ac6503ffca031b89e5770ff2c5067871597be32be30cb35a0279451af8d7320a211133fde3455698f1c7f0704b51996d192b25266dce3dbbb24a3c2a776a8649b60194dd8ee55b7abfd8641230705a286997571613a1f847e13e1dc8a5ac50fb906e42c44ae9384197c735680ef07cde2e90c80f277d85aa73ba72c60db67f1fedce3a55921a6adc6df614697bc6edf91cd9246b4981ff356a67986e40c562874f4fc9c56396c3b1cd4fc9ef47cdff3958c0c7b5f8568a336fb7a45dcc2770c3af0d805cef81c34c8f252b109eda99c61307352e7b5f5651f3eb761615e2464c7959723d85bf8c16f4108b4f976550cc115cc5cde026bbd825aed34f2b7b35a3ccc1b525392e16d6b5ff9e4c074cce6e56c508d34453f0daa1a38689b23cf2d49dfb8987661bcad4357fa2dfe53c4a3c5ea69ef989562594d52fcbec4b021fe79664e617b3bebc5f018f0dff9a75ab896be9f17d3df0ea37a8e7d3617edf479fee7e8e98ef713b15e7e8cd5ded3b720dacfa8a9c5106988e362b59cd8ee04de8666ab08ae6614b9eaded791c6de3d9a274110918ae853b4ff2d3eeacb8eded04c021d8624bee93d10d087821d281eeb224902d3cf55c9b6e3e9e72d82c984e5fcf60d95cc4e96ecc7db023b61db5f475e5f76acf57a62b408c9b9d97ad03062d74b6acc45c1bb19677a4b685f540f079b91cae4baea37c5251efd61eeaa5a4f9c0484f59ae906a956b0e4eb26016c3b4606beb1bdd88a6d512247c07b3d0551c5aa53e45be0a603a669b6d7bfe2664d70053aa4f0acc7ce4b877b10f1fb245d4e7c337787b63c56be1b5820a0506ab0d88b2b6d359cda67432dde0491f1eab60ac70b920f4fa1e833e207c004306568ca77a0da87c54c6e5a708029f5f13b8f8687548dabb1605201958c1576d6e1b2b492e6a549d61fd5ce25f6e12866c945c62a8f8e3c84d71352a57fe6a2382fe068f6752b398927a3e9cc3a7bb2adaaff46a3c54bd6c73031fa2e8f53334f786e797526da35d67ed77eb8e41fa3835cab0ac4cce23c7194994c5e918c2d40ab7e3de6ced4a733e798936602df6813ea0ed7dfa2567a5541fd0c872a221e0c9c818ea03e9faa65ed43b814fd435fbf45ccea043e54121067c50880555bf8d04e14d1a524a524fcd1a9530c8e0dbba22290ee373e7335f8cbcc5417db99497ecb2c1b5a5a6d2e385eb332ea01383d67059b52fd5a0c209b62fc8eeb93d563e0e09c68ac3b8aa89f9d4e4e8459b5069a64ab520cf986a14f3979cb9e5d2116dbc82a069f33f33f986654b55e211a0b1dc86468f5dc2cebe7ba73c51e541eba8185ed48ff21bb201108ffbbbb2534de8169d8ecc1962cdccb579569885afe47d2a87231d06b4c2603424aeeee73c64c04ae6de08148f7d6c844afb2f3df5b8da9b0f65340815c83fae12353540d1472a5f35e1364289958bf8355faa6f1013e62a8bf0ac50d7b298e0465573d0228ef1e90a6f537459750a84d989ac0f2c1d01a04a25f1910f0ba4857bbbfcf7fb24eee68951bba738e96003a0a5bc543f2b32d2956fd88c798c4471139a0f2ad77bc341b1cffc4cf53d9aa5c46b9feba8c3aac27205e04a1879967aeba185bd2d0a17e33c507fc61bded46c6516c1096529fc06ed711d36f2075a5d27381560ca00ca765619a8029ac81f9b79ae82e4bb4f3f3b4611f0dae71cd7618a33825c8199e3426b42b29bcdc5d9f43ed605e1e515e5381d7589915eb760d0b231ce8d988c46ab6835a000ac68692c616eb362d5a75b5a8cd2146a232042fe1d4ce292bc8f1fcfa6a4de1c916683300baa9fe2a9496b1dca546b4712284975f465236de4fcc6baa7286df18645b99aa5b38f91b6a307cb35a2849795479ef6c1c21d82bfd634d781dfde46f7485853b6f68702979850643d4afa5e4e2ca64c8fa6a16d4c1a48aa7946e6f4d43d2b6b6e00118ea88c7b3f29eec9d6652ed1ad118097e3d8d0678c38f5a54bed86c66d82dbdc7da000c6a10cfd086143ba88c7a54f9df8a9b091f4c2ed118a7c34615b30d6daa1fdf33b96b1768a0039146dbb1fca364faf6768ed545657c05562cbd15627e7b1b069b20d8a4628489f5e19724b08368456bd03c79048e824d6fcb3a564919ad1c81f38d2896dc108513d7191873549291fd20cc817334e8f211e5475fff447042c92c3bf8c33fca439c20bbcf420d43ab4759071f9cb1ffb882793f9f05a3c104818aaf1debc68316c51f75575f41374420e2f9984aca4d158d89f4016a1d9f3ae76ef48d9fb1c6ce63d2bceb99b5dc11cc2096576a47f27027888643c519bbcfe23d3515f7ed7568cf6f6d1241a98f4d7c23c078dc74022be18cb32286ad1dbaa0e2f2737497f946d336418d2582a569f004478cea1bee8297cd340bd7572e4bcd1906cf8d9c55facb2b8ae3e0afaa7c6e9723a42bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
