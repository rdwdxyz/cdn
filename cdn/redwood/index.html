<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d3fa543be7002c4ec17e260cd4b156daea070de3c10fa9af194d40c127a3ba5901c537a1331a4fb2ac02a9cd4d407ac9910b0031311cf3e895168da6d836f2d807ae54f16144cee9d0266c150a6c1501ef85f4cb046334bdb9cfcef569bcba8f10a723228413971a9cf1f8d7f3ca80bce70ec595821ea464e9c2f1b878172d75e3adaabfd70dde989ea03dba2a85f5dd406c7fa54e4fb08a24d7bb674dce3f6b8c29983e3244a4cf911fa443b0e9a587233af518ece9c618c5ca2c2fccfe690a1634de106d86477b69044d0e4c03306b261e01dced0e2c06acf6f396bd48fa4580794d0e5f5e8b2e6858c53abc653daf3bd965daccacb247d04430647ac4d3524a4a2cfd3f73dced990987ca9020394f71d660aded938caa63a804ec9e2f8127a80314c22027bd883f6d76671956097b728bc9cce72f5ef10f55124f41132b26cb3e190853435569168d28d415c33acc1c51466fa71cb79a75cf18b086a317407c4edf60ac432fce20ad0960e479ed688d7670a5431343cc9b534ecf96434da082a97ae195d884a3c50ca44c6d38a836959bc6111e60934d28d256085522b6a08cb0f371ce6cccc4953ac7b2cc40ab0cb241d2fe92a9d16bdf92de9fb19eccc0d24d30feca8ddc5c7cfab0f70b8025467e20e70f7611c4d2f1cf69a37bc052e14167fdb1f519577013198802af0c195764a68ff33adfebf3ed058d52a80917765804fa767e81a0f53a802f47cacacab5c71b48ecfd9c07c2a81eb3bb94ea9c8ecef39ed7ec3652f84eb169e78620715b3069828586fd8dd97b35a45f403f92d1e0a046490ca31c142c93c4187ccbe8f7577ad101020b64245bc159b595c5cbf848b0d4081eacd93759bd06cb9d8917e363f7f21e87cfe3aed24a0e01f4595374937b0bb37681b8b4ba858cfe8794d9845eda7271381dc7e519290bee14be138e7a1dee7b9b76c2be3e0040bda6dc7675f4a02633a96fbafceafe93a23ee5cfca269d6fbfeb24ae175330b050cf1a9591852ed6c5ce58bce56c06a22c4b4543456d9136d590a48d282505d1f8d777aab5f10df7c209ceefa20ae0ec4c8caec9fd3d5beacc07508c2386cb72a153c9eb167f2159ce295cb9022c01e9d1076ed9aa0de1ad14adbc0dac142e1161fd9c5675563a207928fe3291be31de2e4b1bd50b8d09ea2ad4dc8baba57fa956a9c0808627e155d860b998c62ae967742c1fea8cc3167352548b3b472654a1711fbc207de1d4c8715fe3ce92d44235ad19463eb89762bd5fd28a84d97a623839cd62e1f0a03b7d465abf9d7bc4e811886f49e3fcb7795f7ff673747dd8e44d23526a37b72ccb0ad8ca4c33cb34069cbc3c30ae643659e738b6eadf5a39dd0c487096c27269947a65d316ddb1f595891c251b31a75d35f223d5cf2e64bcd75a6a5dcd9564b6966e47ffabcc31e8a9738ddbefc557b7a620c27f31dedbda984166f5da02bdd8ec959d9810262d1c21dd78eea60e07cc704e1a0c4c16204d2e2c8600eb9a969cf9bd3ff4144fb5e6de09fb86b4027fcefcb8fa702dc8536a0d7ebe22b756ac5193b6fb47e664e47c4b3501fcc3903d32d5b02a6ed571f268ad2969d675ef864f7ea29017f5c11067974f7c447517b86f8ea5f548b3f4442b16474b24b5aad4509914d15e4b8668eb5a69b53fc67e7abe50f6eebf3e6ed586b8d990ec3dcea70817b078fc9d66272629a018b06db49e4e5226c5680f4aa6efef47d85a000fec623fecb069c579a347c68b5b03eac59dbb982fffc2ed8c690323ee640ce5467d012fccc211a81958f999ec26e069649bcdd3bff718c9d228c75c854101d1b4d090492c16312109bb1cbbf552a07e9bc3cf3a3ec47c2f5595823166c2e6276ab480f78e92097c0f7524d951935ffb4b2f865dac7589136158115a66c0c09af00dae47b0ce2807973367d0135485c709186613c9d9ba4d9714a917c7263a8f09c0e9efe042b3714ceb0be1f26c00a0c94b6dd4136c7f10264b22bfef644498ee9e352025409d4949cac4860934ba949f2ce4fcf36e2a54132bd75485627dbdc41e5e3419c6c14e1e405331dfeee1eb57b6eaf0ea8f3ab11c7a05b6dfde69b0ad4fec748bf97f068541092dbfbf349147766d6c8afa631b8114f4851e03e90bb8df01a88a3613ded2fa02ce3dce89e2a11963f3f6858923f25227f69e854eb4ea7149617d4539f15bebd51da8c4987c84fb0d762bcda6247aa906148dd6c2a780c5cc1d2b0d63aa539b2c9f35c41e98c857df4fbbdb8a78cd8e9a64131b740e30a6dbbdfc56cb67c262646b0f8d1c4064e816adc0539d635efd58427c6a0d518f9f623032d1b30b5d69f9968de45dbda808c62cf5c98424386ef1e48e190eff653e347753d6288bb4a7583e250b08661f036fceb53c7b969e5da95b404d44956f1fde98baf19de0fe62de6a5bf13679d2e5fe21bb716dc8f2758b0b843174a54c4cbf4674336c812c7629bb701fb76a6fd8a830881b42696d4d40815b5c3b9725fa12797338d2cb8d52ede357463a732bfbfa09aa989efaa7b07a9b7d89e9d5d05137d437e3f25c83b2fd855e1ef80341e3c9fc3fdcb54e3651cf825a87ea5db66844d23e12fe73edadbb16677c0952af2ea7ae8b8b1083b73689f030452ddb96f0a838848feb621b1c5333aec3934bf9d33f5245733c6520fab68fbc22ff248cb91d1dc276e7825938a83f48fcaa8c967fa82881a27f8f692ec9870d356808aa3444f8d0a8ed5f5129bf726b899e9bbd155be599c821cad4e13640e6a8cb2d3886f8999a0eb6bd8ad8bdbab531fd12210b695223b66566cf2e15d3888e68321ac4c7e2cfe11741561c18a3887c03c4720257f810420b276825d9dae532e1604dbbb9cafebf6285f34cfd0ddc8577c875efa81e6e7e11774c75d230986568f2a0cf168cc18380ab0eb8966446826cbc65b1a7429c986ed89024e348dc9d234731a7be7d0cf0ca493c9efbc99fdfec12c0b8ae29488663286eb6f4e554038801de364316d9f44a729561606c72df66d4549f75e3da1b524bcb1577565a3f0bb99aec31609d64dae545829a57f5d8ffea0389f77c456e46adb59f5157614b15d4d2d375fb173718b35c6e3407406a8cc3ea215c1515c80912d7560f81d22408d457d6bdcb9d8f65bddab6ef0b79e2045c29ebc6f071314f671e905b7b48cefea8a9fb1a542a3f799530c7e74008ee642ac9e555cc11cbffd251fa8ed3797da090f5c9474189d5a804ded6350790bfcc22d856a66cd3e279347eac4fb6c94719c9066311b01e2fbf80950e2a51b362a3de594a1faf437e25f77d922f483f1d32ef4f3c6653fb3a37329b25013d15aee3409e5b25dc2c004a95d64d7ac18fcaee94a07c2b7f435ff999867b8e6c536e5e0b1877687bf5fde03a390ec193091df6e19716afa0611a45fb71cc42a7b6fccea6aaceb896f813041e4fea29d2198280e22c62944737447aaca72fa0efcae78661fdce7670255a3ba4a10d4169baf329301ccf85780ce30aef04427c337a8673415886794c5a6795b24ddbbe046447eab5444afe9965f40d664ce6ce5d731ad76c74a4823f6ac4ff0543cb4ce525ae220a0aa81f9820a0644330e39fd9fca91055f5248c2eb67cb1b3f9a4ebee1bb033ecbe216626559a16e2cb922377eb50102ba89577a6e1cac4c2062c9402a032be4adcec980917b13a0de2a8771bdd677eb6fbb03e61e9f6405ac850c4fcf4791e1a62d4b751dc21745efe848947f35d941344112062f7ee5ff28eab85a536f099b7cd0ceaa6d5cf1a2623e8534fa4430fa9c9a2afa387b68087d6b33029e5b8b648fd663627da63dcda97871effea02078ddc1e392a0e1967dae422cf4e2946b1058cd3cd0d8540470f718326b9eb43681f080ec492cce4c7c301812d6143b6bdfbb4e4603ec9f55d84b8b124b5a4dca8e2b9e86d66a67b95e2cdeab0a35d88d3c043f665231b270029b5c22cf171e56577c20c7670c1e484c924849fe6c456eaf3e81743e6711483d7a452946716abf4f8961ad26854fe0c5bb3d75d3daae1d5f43df4e00b7d0d3137a97e5c8ae5f537f47328636b96be4db09dcbabb1b836aa1f085aaa9000d4a20b443ff17e8f02a324e81c62129060af833089fed7bfb9069f129f625f59a3d112f1ef8b12bbc496209d1f92c4a22ba473f4b745472fb684905c14fc40c30b026c19d105ed2e6ba321f97e6aa1f3aec28104c7209ec9bd411d1287c83f35166c870e236ccd66e5734568d132ff50ede774cbe5d2166849037b7b7b5a358ed069b90e3dde73f6eeb1d89dfd07febbe3739e9e6a5cd7824478b350b856a14ec97d1e2eaefe114b1b88eb2972b15500a7c219c1db3b6c5392b0099b9b38a133f7294900f9d7db4343227107da6253c562f6ad73349607becc5062f67d38ae7a802b792a20b1b95ad2eb15e8226c24f0e828903b51015077c1783b1f2a50d34816751f4428de280b41bef3ca61e73d2fcdf8e8b3a1f56a8b4d280883ac2bbf52511999b9c44fcfd9cb7360beec5895be697dfc7246d72b8c7534be9e51a1055ae3b2ca1d4dacc89099caec5b9947224cdc1e58004e2541ac74086424eec1b2f87ec0aa67749da6602a5b33b17b4b1064c577476143eb202c590910a7c74303023527e3bba72e76b5a189a060595a7bbc46e53b4cd9e27bc9f17d61d755b4a4ca564a2aa01ebec1eb0336ff5bf42a9d96f8d2cd0891cfa92974f9aeb5c416537ed53ea483f3051f78cbb90118e6cb02f87bd7a1c2b5aebffbb6f9beb3c85bc859ead17d20863c26d408cc2252fb4cc4a14d54b461810936ae501b5bae7588fb4fdd1cf249393ed052b2f78aeabcd81eab7c2e3a65c953d90ef2847458d633d1f7aeb8888d85529fe16dcfca82dc76fb1c7c24fb5338e7d360f4e0dcd0b36012b8daf08203500f29f50f539d2858a04dee5a8be1d8d9ab579e4ce9540d2b33bdd20392afea2c1c457d33f0150d6c45ee2f3b0dfdfe98a80eba550ec9b8aca8963f52ef7995a46cfdd2c9c71559affb09abcc41048083dcb341e4505a743144b459cd03fd81a615987e61bd88dcda20567bbf0ec42c230e3c073a88cc27ee9f4983a6d2330155f8fd9cfab68dd332d758a2c1df4c624fddc83f4bf5b736cf684e57a5ebd9254a156641c1d005bc297df013ea63255c540f4cffe305af0357c805669cb13b42b53790035fa0a4457914a476eb36f23fbf08424e367cda9526c218d303d12682c499d3759064b99c745eae6cdc2f0a4de60377844f802b1c8ab3ffd1780a962523cdf21c463176980a5bc01d6a82a4676b636b7f72356699eecb60f579413bc4abc02553ab7d52db04a2ebb6ce08ee1b645c28827af5059c02cb5aa72c879084f17619840cd992548ee623369aad997fd4e062ffbae1eeb06aea0efd56e0d4a333798e9a447aa06d7b10512a6ff84de040fb494f1d18f456b4fec88ef57118bf1d9774140c93171880ff14d8d7574a685723414c845353532bcf52447053d226efe0c74c2c8d76438dd17198a633d8e457fb29139983c0667ec2e1429da5e8fd090c53828997e8620551dd90a1e5d1d59fc814a241e1f5bf8b79065e63a801e37231b5ce07bab17017d135b86e8fab4e59244ae24345d0ed6a2a59c91587db3c917b27750b34af6abcabb521a62e5ca42d062c68458b92dbb681a62b3d28c9e455f47bde9419eca801e525123b7d5439b446f4f6d81f2c35f73f2b6e84f1b00ca20eadb518bb2096bd247160f08b3d813e5f6a4a49fa42c597cfcd3f681740a475a5ba07f09bb0f9222b1c7e4b62b374649718fa7dac1bfb10557ad2e9264aaf8e0464dd78f3e5dd40e24603450ff2ca38c199256fbce765022dbc7dcb545200f2677d3f8570861a840001a45fa073bb249a944135e6ea9f9993b0457a2b3b873102de5782941bf50a4d90401522a719c970d44086feabf73bc5e27d906b5a1aa1ca6bd5bc7455604c76f6ad91ed89b1df0631f69691b6265df99a09f2b90da4395d777c416adec77393640864fa760dc3d02b786ad64ecb6bc0f9085c73d110c6c50b509a2304bb6edd6ae953d6003056acfae5a6fd8a3f4fdd51af6d2c3ab57130d40d81ce830838f89832e0537cc45f0d8b5da324799189b5f63eb3a322a8a87bc96b9bcb7055d0ba5ccfd19dcfe896802b039c341422a37d9dce061fd919533084510fed42a323307c9003c5ccaba1629298f440718fb14e2bd24c06e3deae5ab843200ae2a4a420412ab1d5d69eb50465fb77db5d7ae4fbe3254cf9160acdda20f22784133a13f62c002385d52ebedf1b0262f981e7a97daa44ca1076e6377978b21684bbf10cd4606422a03e3e29ada65a6a62912d8147bc48ad073910c436e034b965d2768180edb2fe00baf5358dd62cac357747583858aa6620aeb3c7af70890481173cd7409ead208ebb6a3e0b3de5f79cf1907581399ceb1dfec6762e00031854231d0f4452f86cd0dfcc352716dc4e86ea21b7416029ec99ba3fb0f2d860cdbc45a081491810b9b86d28a151aeb149bd32605d041eb9e3a8e89973e554c5bf98229d094347557d16cefaef5e0f21cd798bb3cf24c0ce1a19a048947c71098e652cd58a596c681d46f73a60c24871867f97325646e40d691bfb1cf0e0426663e034fa70fca1c7cc95110d84c36eeca896fa88200760d17019c6bb72d062222c144a2425e8f58b7c7b208841abbd82746aa5a49cf3cadbfb465e394f4826b8451170da67732ad7bb74c535bfb319f0705e5845169d08f26746d7a177c43f203dc97feb36e30502f074c49bc3226d3d2232bacfd070cab20302b29d0289098f1dd70d440ebaeb130ca2e09235917933e5e1b0f7ab9da931df8b6e884f1871ba4aed1e69f84ae9a03e1f4eb1505f4eedf2b832f17ab2eca3781dcb19a00f7181c76ef15e9098edf001d6b96c16e00778057d65ec067859ec46f1315bf2f396d3293601c7ea8e484f82fa4cec90f51ec14c5a863da7773d580a5d595ebd66ad0365fffdbab2169b0caf0640003d6a308394c3a4675b642c531dd05b6cd18f49780d71bc97143c75789893a328c15b3b557115bbf71261311c73b512a09be93463eb843b44a11d14499f2d9c69e1871d6f16a118533c71f21ba4c6d51cf0eaf406c53dae5c4748fa0290d560891278c6b519b5b07c648e94fe6813524cea8e3ee3215e76e2029ba21a3bac67f39b1286f8ed157cea90ec66887a2fe2a70734923f471adea0e7ad4f4703421dba25adcae7ea2a8234cb0fe424731c3a4b4a8c50d7ca848e761fa2097c9f6d3900b04e41e010eaec6fd731385015acb17b31955fbedd47eb4b098dbb6a26181dcea24fda7b0aba5689b704952f6f0701ec9f1d2740b93a5fcbf9ba849be1b091e2df98f93b3d8879c8d0d1177be82940f470acef010b7288a540ffb3a4f93fb4468738e8d74268eeb41ab79f471868f2247c1dbe275130dd455e44238f16896cc82b98a7e73f8764f2d7f3a000360d7a9e60c9677f38eb891cc1c4a1e4ac77e8c4fe5cda5721720a00230520cfee572e346007fcf784b5ec73fb23114b343207a4e6747c91337f40a2a3b3b63ecf787958e4d06ca89ad7f0cdb9d1136cf3fecd5c66990982148f4d92e3a3642c6ea5d553223bf097a218ef9145468b8c3a2026e38154e5aefa50685f1951a411a535d510ea71066d7d664983a9aa791b12afeb41d5f91ca1ce074dcfadb90e105e64b64a7b2fd715469ddb71eeb36fd3f412f943275cab32095f1d4d5100a961348bfdba7ae57ccb3ff475eed961bd268971f774b35a29a4edae02747cdc94698e575e1d2189493f3357d55a8d499f108becf5992a78bb25ec1ebb53e2444d81dd66a7d93c99ea8f44f2159b407f51db77a92ab47d3bb30728d59c9f29c22d6f6f0e4f8b106e9b14e5f6a5ebaf870cc547dac8353ba0367a4347e2d02921b0077c15dca5d90cf037ea76c25c611378f59991518fc69585e4293bea9f3f97fcdc04e756e93a68d7cb88a9c888c22939f1e91689fd53067b2f5eb86e929dae76883c9dc5311505873fb70e6446744b25d30181b2f6fc729304bf9c8ded2494ad7f7f8d52900f073b3a0860f2a6b7895dde895c41f0195dea1228638970419daf1da56a694ef7603fa71e29878d4c9ca41e1065830a1cb7737bc8855511a57661d0fa87b98d26bd38e5eac1813386790b8f4187de7bb668cf99a84e00940c3a4d630baf39c6fba006f769e70da295d43c2180c9ead02d359ee010345fd4ec8e8cc4c032ebb511b6a34a3718833d4a1fe944c795d120530be654a6e0a84de279aee73c69a5f3acc7d8ca9cabb38323e201198df4b7172987d1ae5574c4fd52aa74e54bbd5dedc530a4c67e03b6265420f064ef684362756203ad07ca06fa76c14a0a042d4522744f082a574eca8a177f08ba84229471395357e60b622ec9da8d486f7389c640fab59bb520e26d2aa6f6d76d9a33c931b923ce84f590682a25d8160bd9d8013599609d5087a0bfa1fa42cb3e11d8a157fac52f8239f9fbd35f816c2ff0d61427c9b7762f62ea34ed4417a63408637388f8dc5bb3fcf425c0c48c06bfea1a3371b589f5acca34f4d44ec249261366dc07072bab79da15e6b9393a9fc1db26797893772d0d4aca1ae0e2ad6c83fc184d98e2273492ae6439f3c019b78edfc5898482fcaf25f0748e48179efe5c94e629a19a3de4028d02af20425b89d8a398e1245a864affcde4c6eed9150b8e2780afad117e225037ee9ba4fbe837542a153650e4533f9a8eee0891a77370b05712939203f2a9980b2fca0fdc3b02f2d002b4af054e90a4315dfe3ebcce265b9a4f19cf8927a4326ed146c9ed3889714b56f134dffdcd1f6c9f899e366f64a25554d5981ac6f64d7411cd33b4420536d67c49abfc6ccd811384e93f8023301886a91d97e634c0d1e20975391564f42e6a29a19674aa7a22480c3e999c6148836bd0599a37496c28a17c02078c5ecd57bc74f454bdee2f8e0fd321885a69c6286b3a844aac4dd78597238f114f276cd8c223f3e4ee8f81feb35a54d88bd4f0e0d9b93ce9ad806faf60a70b0e7134f0a37dc46bb14a425614ee6578cdc5658d5dab223085de0376d5040fc66ba5968524379f3e890e2ef5f4b290898525408eb409986c79ef04e75e066a627c7f2fe5ed59862bf1e7503d0cbe6f1f91ac0f251478e734eb7fdb9ffe2ebaa67b85f1bf9b6aed8fe056e61121ddf80505aaa60defdd9946521f4dec1cc240e12d8a3a7321eda4741dd02db4775ed16728f6a14d6c4c77350af57ac774dc72c33cd4800f947d80c79de9510e31e37cd39ff8d4749fe1af12fd1ba3634aa0365f8ab95bc15a75aa8394f5f4dbc011bdacfb7ff78123cf4d81d3e9e5ea0f21f6eb1f27b70e320a1e929fdb1244862e309f2ed5b3155794dd7806319aa9dca54a65bb0f2ea16541686c64e0c65ab577cead33b695feedb59e276445c68285f29afa09f940fc72db13066042ddaf0fc3ea31136e7ff96bf418020015173877fc6aa280320b159b6c3b963a7db5c15557d8ebdd352fbcbaa9dfc97f379083f36c2bca59060abeebe95793dc483be7bf42455f62c513a81a9458989be5589eb423924dfab8e78348d94c805529e8bfddb3cafd684c1571a6bf2dad10d1a963f50a99aaa26580c15fa95d0a6cedb929b7653320b20551796ae60d3974ba0f0cda3f3b09ed12bb2625d1329a0665ebbf06fbc7f7bc077d9f3117c528d16c45a78bb345982fae16e683564d7aae48acb4697a6fc3cf3b510ebd1e6eaae49218325db476f17fb093b6c017e915530ab4ca4ff5981ab4eab4ef47037da2126776e5039e0a96fe35d41a38052f3ac54ebfbaf1e5c430341a468ebb937097f7d1f3571bfa4e314cf01c1d1277dbd8123aa878c8897501cd79e85be2e1318d6da2fc65ed1a29778d887bce5cb18665a2a6aef09e89fc90003d3b3172b15fd12a16ae3df12bdaca8d038151734402c6c0ec200937e879e122b5699db40b577b20af01ad8c35af29885729b0037ed3954dbf5cb8324f954ab37047d4d368b74764778cdd1969fa6b19572bc9108c0f098db85ff197fe6758d39c4ffddc61cd9a4e7cf2551ddd36588b7f5511120df99654f2f81b5d9875507ba81d09de9f566d93bdeb11482023b60491cb2ad15b65dc57ccef471325a071ce30e77b1ad50804f7f04ce7430a27377394adf637225d1b06150f561ed1d620cc5fd2d2e278bfd799c766a4c99ba3f07e98ceec76e2900fdf80b16680d7e498a0bb67a43358e17958e4876a0918a20db1fd391452f56be13a36ef2ddf4af7c60de5a48f5e429b5069b0c0e517aa2e3ee81a1bf02447b1f8fadb84a9382c04e475e5a9dbf392f9d6f3e6a9f6b7ac42aead108d323c45781f65dfaf3878bdf3a505adc1838931fd9748e0be17fac744fafdcc9fb296a7644ce85af922a0b3a13059ac305c672465658722257f86d29477df505c078d42562dde2bee2cb55caa06321f54b973d89e925c12e0d8a36f494e703d0ab3a594c6ae11d94b1e51aef154b63d3e1de35747cc35e0106e3fa54da7d6fd0f2cd06a2ce96a18c443857fc92d1f4331392d52a16d02dcbcc4a7debdf2400550eb61fc4fcc0e130cc6b226ed674ec778c3087a447d424da5a0ed6a10a4bab469e6a4980ac197b92acec129e9a01af3a215725bf8d187e95118853646ac41834bd2c5ba7d90aea55d6217f5a605a581761d3ae50fc7df11db86f67255d9416b2f654453dc24d7bcbc1407a29cbf46c1438303afe0f33c57608554bde03563c5e271a2c9823c77ae71993c2db5ebfb0e0114fcca72c230344f5c978d233b4e1fe3eaefddb965e45a150c942966899f3ff2970742f18d4fcd0bb794657f2fb0694c9ef1f5a52e963996d9fe0aac88de2b3751a63878c921cc45afdaef15672283ee4704b430d8cce620a4e791af64a37c96b1e85bb87a844bc623a7393eac34b3de17697a31e4c60e8dcc18d8bba3b1f4490a3c78a9aa72a306d8e0a20b313e60cdf77d3d6addbb0472efe58a02befffd42544a800bf7dbe1b7248474095f40172f6f15ad69d936556ef1ca9cbf8dd8dbb98b8e440d9dd21589e20595a640588848a841a593a60d25cda6f29d17d10e006d6abc12ceb49d1e7f33aeb82d44b4cb459bf71957549d9ec0f4d52000475e9e968546ac79274bf40967b7da579a146068b765efb19d81909f4512ff725ae4875189de8a0ba862d989e0d6ad897df335f5bc03bcf40a8204e465ceee067b08043468f9239dad765e455003c06ccdf05e9c8b22502624773133c51f3561af361c02e1d9cb997b626daba5261cfc2b0eff23d8ac10ae326a248597e963b26930e0f2b02f24bcc907ef11bca0f504dec35c50b970d3929da07cb5406a1700309492a50b03df93017020e16319a9b21d7b4ea335995762de52a155478d6753cb31fff882e939e5b6d02f0e48d3521cc757c73770da8e6ebd3696fadd9e71883cdfc1aac1ed5c63a6587e0a116fecdd616e74f05487e14f1d2ffaf47f4e8d658a3e7eaeef0000de5424e0df8f91cea61c4a54356576ba966adc7869e4a1892220093d26c83c8aa0f6497bc854306067fd08afd7781a3de52af76e775fdbaead301b4822949a6da1f1d5ad0f3501bf46a06b980be768ac3dea048e6e07127bba5f3f434695ece789a2b89bd349cc238731612b005fda3aaaf01197a3380b2e10aac110ea58c360d6cbf93372cec0b28dd7a03087cb1e03c4629f71f3072b51ef4d8f47a500335a2aa9d5d7369631669b23834edba9d28d0fb339619c06a1953e5468bb50809fc790726a22c2ab6e1a06f9ee40aa0a99eb392b6fbd47d8a4b4f03e2f8525ab18882f8fe801a2c54784b930b995d58db49666f68cf9bf65acc24d543f05c8b83e8a3db63126d8e78310f99750a01c05848f8eca45fe865e10eb8d48b56452383fd9b3503c5555819948d6588d9eaec48ff4e841b2d2353e7a8fbc3f55ba06052c2834c880c8b443d485430d0908d2450ffa35c5efa9f0e8c6190f99be3370abda72ce9819b59dba86ce6500767932d1e659b3d0a68c54f603ab629b760103698c815d922811adc965d9678145dc383145d7557d339a1bcebc6531a8cbde7cd2bd03b5f4752f300b1568b79659c3e8a4574663e27aa8df64046abdd994bffa1eb8af429b7b23ee3c1bd05a22bf950c620c31940503991d2aedd4ffec6dc64b253537f888236ea760bb8c535ed69a164fd35585207f0e530be4bdf5b7c78f0f7eea381a3260d596f7872321c4be113d935e3bb365588ee4adfafe5df592506897bee2e4c55a9d5f2cbb4be8a4e778ee80f44bc3bc14fce09cb508c09ac7501c26ab8a678a94398a2162ae569f19ba8595a1b0a3057e6a5435c494bc4fe6e79882a11fca263c27680d1cc09b03c3a049b104f597ac168e2488c5617d2448aa4f293c21f7b3ab3b68fb9cff46aa36427cdf91366802a2c429289fe8b1e1d2ed946f015d39bc3a8ee0e1e7bab944081e5042f984206f7cb818d76c9c7fc2dfb201a06057ed1067077b8da9a6d8b30387c2e1f21b8043028e20bdad6c2dc45ec7cdae6333f573b92c571c8aa155241f4f2e97677e6d205398bff3fca2b403417870f157c0e1a604831563cf5a8ed83da5625df78ea90f72cd01cc05137ac215e4168a5c49012aad0880db899a734966e4ad7e88fb1b586231dfd8b8fa71b8d32c28a63a8cfdaf1f9e0a35583b113e23d62476f26fccedc0cb94a282229576ced4388fe9f1ddff4531662c51f63477ac27ddc039b75ac2f23f477140524d5c12475e33c909c4fb0d064dca1079839c78209e77dc285a92cf2481012a2036cd051276a885517c5c7c6a17a4dbb2620237fdb9ed002f3f0021c221cdcd0ab70e21153799e25375b68d835743dbaca6d45fd3591fa3a9131b3f343c23a01e43c237b5a9dcc06bc2659c1467dbfa795fbd84996e9313d81045980296e6e5c1b55ee99aa38c545b5dca937f74b2776c50c4c79723c126e80da49349e2af20a197b34be6fc87c4356ce2ac0bbace08ba6251dc1229dd45f6108d8f4a4d23b1541e3b0d58f7bcdb338a895400966d20b808bcedbecbc48e5432f0e11b206a09c267175e820899c86ff2e3aafa942c25e21bd3af02ded93c843187c51de7b4891d5b595049456e5d432c67761dbf8b5ec5e02e3623f579bffb5c0956766a482e2020f1d327a5bbc8fc90d300f2ead522b9852dd59cb653907df39547011ed789153a6e3fb6d1c1fb1dbdb20924f7c0a5f4e4ed826fa46359b5a14467e04a823c0cdd93833343d08cf9475438f6fe4b884fcc3001c236675af21745f5e85f09a6234fdef0abf5b4ef6358228e35b753ca721aba25b13945278ae1296e8bb5368e2f895de799d12f085a9f90451e45d2ddf45735a75e3406ad5ac55a669987f6123454b5d2c52684ce7b66f7b22b0314ac7490b42e9dc29efc23477a62b68f4465899e122580784643cba4f36413cdf4ff2e984c4299a4a2de608d3c89fdb0579be3d7a9c2fca3766a66f6748014ffb3f78cd935f485411c48b1c7f49983c09f74d24e86845695a4b53d95e9517286c8d9357f755fc9222e52dfdd29a8d37b847880c885e5a602fbb1a625695a134e4430d6c4194a7170589faee1659c5bbe5bb54deb116ec357131c3a2843b6305cb8caa180c12dcfc8f0505b38d70f0822bef6753913ec8d804c893b2ea9e465d8d540f3102261f6ceca226ba477e7a3cd73e05d701957266c1e54ad95980a7cd564744ba0416df0c9252288f5750a9a3086ed78d97b3fa164069c3f3d40a4f4c684c4a24c933dca06a908400e57651fb2d683a0e04340d4dbc63c6ad79703526c90dd70c25a7cb6381fc66de1c7efa362bd4037815e3e36095d75f0feb6d29f1a5dcc8226da5f166ed241cde86d373f5a6274d99c85fa5e428ccd3ac99389ac2d850ac0bc2539c624a84114d5a21f1a57f7c05ba8a3229628d3b1d100524cdd7fd9611643cc9ac057014247738942a3f838f4b1d40d218b19e724ccfe61cc29dc3e370e817faa095b4a0205cdb343ba2730d39f8c944a2126fca020d4c3423715906d409d28ca3d1f6f230b2600fe28947ec64f9e9a37b1fe7bfa7eee8211c830128c8953c3cdc4aa43386f099da1ee22d213f2f7cf390540ac553f3096a8a284f7d00314da38278b451a201fa530327cb9a6a05afb0785d7fa7c4e39eaf6db6d8497589131c1b69fa2437e425cb60b7b8678bd31a42279b715f7ede86a9ab29d123afcb6ec4a5130b642576096ca321cd5d25e175733129e28b230a8608cc5c42571676bb5a8ba9c1f417703a1772a326243e656664301dfca4fba3acc243880de942bea353df67b9074efae12a919a0852963a0c75fa483ef6c8f29acb741505873265469eb00996d72ca2e1e5d5b5f7506d509a8d9c47bdcdbac48edc296661b26b48c525633176616fe9981e43ebcdc062664a9bea8cfc9389029dc475fecbb363db2a827d6d6fd1a6a903206a294c2e1015f5cb5739049ca8c415027ef20265596ace1335c2bb7d309cbb9e8e14806ecb680bad6a50642ed7c377e76b04aeda1addded8c5d55eae0364c1c2ab9ee7a1ba3caaf9aa278c77670378115d517ab1a6f62f515f22965dfea7ed6f284b1b7961db8b897386aff56d3c97d04ea894485803b4f86f44dc1299a324701b2f1059415f11515b3adaa82a452e91e94f9062724ee8417979455aaa979843fc45c5733ec4f893b3b7f86180e34600132dbe834f7a0503c0c55f37bcc2478f9174241cc55f3647c2c4ef6d8c0c88d3f0e0a660e51ccf704274f734be443a60440055913e69b094eafdb05e82e0f119b8349d7a26272c06e22dfe090c2e646e32046ff2fc23fbf8aaeefb8b116c5c3f0a4e2f3d60ca8eaa95c12d3ff0f66aefdee0e3bf24bf31eaf64c2748952006dc0e9a459d4b9a02e64463f2639c61950421b34c15390d1731098122b584270339f087257e25ed9b25984e4169b6e51abe6ec38a1bbc886c85ffbe1c25582d034f6667f3f5d52cb988eeebddc2dcfe7133ad68246765e23f474a4f450df7ba64e72b8813badbd49cfce209e9469e14004eeff1b6d2de96c9d3350e8be97bbdca5dc82ffe1d48e0e8d43828cd7d5567015c2baec2aed5c1ace5518dbb5c212ad2679da77175376a2ada8c83e576093687ea8383c819981a6601b2c9692811111cfd4c8ce0866488cdda2441ce12ac68a34339bdd15ebafe13dd9fedd6b37f6b43f5758b52648eda62b9dcf0b16eda3afeddecd56e81b50723f6c10d255442da7220c45368ed331e881514883142e880a4d479a4d437227eda1d33833061b86b07f33bc162d78e26820be3d3b16a4d9cb1b5dd798ae838024a3d7616c9493b8c9522e11d58bfa0fc2eeec4b44d3d58bd65928f9f35b4597752f0570f6a4cc3631107fbd3d2675c7bd003c979bd68448805838fbd517f781a5d8c9d76c03ba1838c7663f0c63d3359506dbb7156e6f8f9e2893c19f014966ac68b34a3c2c6693e78d477f9660b3abf5d5cd717a71f826862cb00cab5f895be6969b01a81edeb7ff4ced3707d9cff3bfc30adf1bf1cbc3ae1be2e08efbe2c00b2ed007e263eceb7d89067eec648ee9f9bfc5ba1353e6c6dd2f756d80c89958beb37078c57055c21efd080b05e121e1ac79fdd2f4b50456e4d159befa531c68075caafdf056b5ef15961c5756cef5c3f1fca92f8871aa85f93cd8f738c975ee9e6ef9ba6a78bf7c3155fd7dbf0d16cf393a43e0db780083f0c3cd83fc6837c1a3b6453053cb17de89a53b8d25ece2d16a477a04b3c13516c1d840503941ca82a48b55283cbf345cdd159fc447458da892683f2ddce96f820ba5f6dcc91697795108ebf343c71161abd4335229313376cec789080bdcd01e99fe41b3f65bcec6af7362385f55071cfba0ac52c6db76c6c50212a6ebe5b56496925434c590178d0a05403fb41e1e5be5b941848eb2524e4f2fe1414557922fc25cf6ab4a0b502242fac1108a1b9f78e45ba3a9c848c346c1749f5a77461c947443bc8f0ddda0237609d08275302f8ede25e23d2021e619b763e7baee66969dc167085fd461f1c39a731f25389e33bb34076a14c5194fd049f0d4e5c05f3804bb8470d3c02e0f2b104321353d0bac55337c069fa72c33022c1acedeb94afaedc67dbd4311d27cb7f6cfcb89da7f7e81c337c49c1d04de0ec5a40ce3c71adac3548b09de9cc31e503af6a1c03641b378430d451a1cb7c135bd693133cdc75302424685d731a4221158cc0d0bffe4d1e386f5a7781f261723af4a28f505a40ba07e9228befad4847e29dc1aea5e66c7954c0048c3fdb1fb886c73c37d364b6375bb251dfa0fffea663d899c6585f8f505a51a035f593511c9ed5d24f8c11ac3de598ebb1b89a300c08ca8cc179c12a4d4724a02d8f27f70d430c26c988b96cd7d890e8718a86b3d3e4c7e0ef8ab132259a02bfb4da4f4c81027e9ba0d580f346f1f1a1564d9678aed0b0540f7a4bc635f49fae0beceb57edc32270c566c0bca7264cb264997e73fae175cd0694ee4310137e27ffea2973e8ade9921f07ebd1cf231b0db4d5b976427a7f632b8bd857eef933a933d4da340650d4623bbccd45fe65de28c747184848eb16eda50db68b5585ab6306a8dcaa1f046db00b1d56cd8ba7f6b00ed14c454520ce3139217f32c92dee3c37fd1ba8c41f8ff3220214826d1dad1b4ac1cf9daa6d68c506afbd1cab81d705a043b9a32923b84afc8f49baf56ca950c0ac9009fa50d7d0ea0595a99d24a681a4137ea9fed527ee38bcb992bd448ce98e84ebd88d63ef65f4ac56027da5a554a97956e9146bfa63959865bc760afbbdb9f54136a8288c591441570c7a1f2e0dd2ce0f818a8f6eece3e01d86ac794adfaed12fc15384cd1c6b488e28d981fc477cb2f3e2700cd59bd8ba7add26518a132cdfd64dd3308f1ef4c6c8ae9b6a722bc49df3175cecc49be9daabf2f4f0d2aa3d2b89fbc01f2b0e205ff514cb827c7e8d0af320bdd544109fa3291311ae2929b47624933198874e5999404fc2132f5ffb553dcffc9c324a7ac5d2ec8a8585d9b831b2c1afe6d726dd08b6cde187a407b06cf67e3b884730d9ea2c06431cd338f04c76a2b225916eb1e5ac7ba727abfdf4a72385f189d8e6bcf403c26bda06071bc2e97eb9343e92449f79c1d01d41264db933f0505fcb4e639cc5d0d6894c252fcbebd5311b7b1aa5392eb47e8e2f45f35fc83cc249b59d052f7b455761b94e65b3b6ebf812d45f94e2dcef26a537c14a18d3c6e65883fa495112e4c7460487ac3a010c8c916c100582fd66398b30d8a85285d7517751c21a9b2ca33b37f9dae545767a05d00bedbbf5f9a5d356e0ef54fba24e17df55b3bde4461158a8b68038a9d16a923be5474ba00d568686df624486f7cdbf3798309550ecb3bda928e58cf8e64c2161939a4e4a9379a15519e0397828e3627d7ef44f263e47156c3290db4353cab1ad995ba58f2a97a8b7c18e98942fdf4e8e10fbc1ddb0d6bbdbda4c9b4d916d9dedfab44b54511a07b872cb28f3f031b40e763837b56661400e8e2c2615762f6a94f79b767baa72e9e5ddefcb834c5351963315f9527f837b68e5d4d7cbe44a1e6e5ab0926ec71840fe1b7beb7643af376577c286ec7bfdbec11f1c99306da9c0a00cfda78b3aae782d99e7adbff3b5cfb3e7cfe0392a3b2f293a5e22a0811d2964c6e8eaf9c2f4d92fed6aa6d814e3c00055c847036314a3b6b07e4809a0f516777703c5061b1b037fbd7abbd9d1ee10411a078bc94eb05d5a40f824b807fef13d4a9c78c918ebb2ceb4ef669c94d0d142e0555a647912eabf4754ab8f42277e68e3a89c8e43f9695df807ad19a39a953793fdab96dddcf7ce3b85989259e8e67837077781bafa9912d7ca18c1506d560dc1b4f2205fa6c3cb1bc8765db0e21de2ad44b5da68c00d605d3bf5f3036649d6b1abb9595c6b813f34088432c3c098167e4803","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
