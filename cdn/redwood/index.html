<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33e79e98d10ad9ea9b55843f5ce26390993c77f92d59c8ea8dde76efa9cff0d94be64879bd25fc440f6881d68f1ddc2170cb12365e437280e274a809aad5fcc63177d51b3ad1c8a0faf29e4ba3e1bb1c570834cee7b747cdf924b0830c2e3df2f73660f911fb52157df534dfa986cd6b35da2421e35ab638bb3579708ecc53fdba301f599ffc69c3cc8258f74215c6132a58a21b51d98d25e5a332c1fc4c52dde49e65ad02c5a0fb6dc1004e3ae67bdfc087bf8eb93fdb6cd5cd7d84abb8c37b77305d1f94c86fd6903c5cee3d6ad9b07981a98b34694a63869faac619db7164a73eb6c9725f8a91d4b50f5b32030a66e4144ce5994b20f8dbfd13f9e84f97f580a3df97abd0ba7694cdabe3010507907eb1914be6fdba70cdddf99d6e4cc2701993774849af9d3bce4addffab912ca7c48722c4a3662c13b03ae497ae871532ae14288f06b4af93ec2e0cb93af68ae74d66683603b364bf7ad337f96fea4ea923a5ec388b81fe34c8e390b6b31a09922539da704c63a8ec5d23063bb3d29baf99d255a176382fd3c2d8ec4553a5080d6b69df85ab28dbfd2de4ae81b0b996faa6eea15fc37c07ae344646b045283f3a91f31693bd26bbd7c0ed25c7cb6e8c21be5b1d36d569545ddb6c1cb7548ad5cd07eac59a0de3993d0d8b050e579be21433c6c956a4e6f24d2fe15e18d2848bc1bba2bd84c4e9dc0addf6af189cef1c5eecd3343c9b5a7d2593e1e3b65431babfd16b01bc264917c4fdc774c458a421830ab8c29e78473e4033e96dd6bbefc4890c2529747b8cd1515c4dc65ecce3ae0a24eb1a19875c57106685810d9b32e99da3c3aab055b90210aadd7b58838ade37188efcb0a926dd9aab712cc934c3d13db65b9a5ba5b94d0bddc7a0bb3e9fc3fb4470cc411785e633cda1f287061d622a41aede42ebd03638d5aef19cffbcaab62409114ddce14b889156a107ff29d212b2ee3b90adbbaeef9ca1d36d1eecb791f8a5f79fd5b138bedf7cc0c44364983870c47995ba14e99dd111cd1f3220054dce0a5d74f6cdcd9ccb0af6ca5e25cbaccd216d477dc1accbab2025555aa9f931ea2873025d8d9c95126f1d8335ec6e437f22869c84bef3f3c942ae37dce870e3c44b1bcf7af20784fd616da7676718e592c91cf212104fabdcd106baf7d6a091932dd56deb88b49758ebcb406317973f7faff96fb8533fc27a171523ef560d0175a868debd608f4569309f59653dfa045b156a932c87ee01c3d155206b428e2b03603a64c3b5b0c0dc91b6b2a33d5780a1a59c535a5428d73eb6747732995be08b5b28cd6ad270b68b278539405ff49394f657860fc44685f1cdf17448247d27d7ec67fe159eb8e68312f61ae9ebd8ad0ab0b2d5eba0e8a08434acdb0f126302c4c16f45d2c71f7e49df994bc31ad7e30cbe24431251943a52419ebbeab90c50264919dca97ef6acba3b2f4ecb0dacead2450f530dca61b6a81825ac0077da50d9d21231dfc9d3a1bec35a7a59b5d203c41cee293020794cf37103a58dd3d130a8f84588867c001312ebe1ef248b161373e6ec31c633cec56e704bccd2e868b051e1fc37e059366d2991e1079c9a982b1fddb748ad6bcf892f6f470bd2aff14ad1d82e986c2170a2cd54d97ee3467cb0ea81406bf00c490c1b09a2ff9a503e0fe1e8eb64bc502efe751d438b0139a2c009745b8751ccf07803b8ac62faf5c401ab425a743920413454eb2f1f2e7cf2921f54daba1f3c0aa7ea753f84042b47d1c5ff7129a67b6c6622a6eb41214a65dc71fc1ec5b3a54f945bc4cf3c2b1ae779b5b73f272761744066f7b84116b810e3c366105821a1af1f5d8d52ee646f0ae6a0cee2d30f43f6e665f80826138751ab245c72808c9130947395724febecdfdc513fca869e46b065a6f9bb4621eec8e40718ba4ff5e64559c8889dc811acb5580d93e5808bf1b20a9d8c060093070e5dfdd05296402def9f69a392faffafe7f6812f60c694e31ccb6fb0830ed8e754cd46abf1f37ff725f322fc45be3aa7eb28dce28f268305d73f576c6528ca22abdffeede7c76ef998bf0c60d7ff85af6c0908cd705e62db5645913395eb1125c6420b6ce8ffa3b647067666cae5dbd278bb496f7973bb581a17f93cd91061e3df2ff0eed7d9eeca83eb3024f04bfbcc97b4a8770b38890ea962f3d59a683b3fef9a575d0b92a8b2c4fc5830e0eb15c18286359a9a4792f11c6f152f404b7663f38d21cb661005f0bc188f40be71045d95f0d04144d31bb2bee29c9fe7be3443bf0ca66e1fe10d570741a613414991e88c512107b431ba28bd34255a9a3b459f5b1e2b631ef6d83c59cca9bc1e63154e17b6c69946b5f1252a4650533c47fbc56dee3072fcbb280b923a48770c477c243e3eb08fc61baced1cadd42b6ce454dee8290e58459e244f886d10e01b71b20806cd966d3a26608dd953089ab0ab145edafdc3e33d3a1444a3e95c5978b449ca6f9eac60feb208f15a397670c870cd28a02d08b1fa319cdb18cc8c4108314101813959de5ff51df075d5d6e996c19a2dd92c58fbd795f71597d93cf26670a1bfd3210a9647b442dbd4736533558133692421c7e4ac7857e78fafcd7a582be6a4b48aeb7295b7da51428a119bf455307d0eac534be6de36da57f1c36a09601d3005feec5b9689d30876e1563a25c85c8d15ef425f7aa18a8f2f7e29b4354ad5a5735894e38011f25513c2d819be50d845fa6af4556f3563326adf42b04bf8c20581b38a21234650d47477a896b03b39556cb05ef2600bc18a003cf2affa1e84f2cee1223384597c9de3d05241608e55badeeeaba1c1292305705c89766ba2658252de89d75c71547bfb8073e1de50c525eca2c77a85b09faf72839035f6fea2c32b409bb8f6e57164132196e0dbcd4149be58c8e49fbacdfd04bd2fc38e75e9a68afdb1cf9f30366fdf05c62bbd9196e308e3747e3be482118033eb5d6360eb7aa2662ee6e946c579ef4a51e4d49ad2c6aa56f397e5945edfd5511a7b2284b8dbd5ae06523ea0575805ccf9bc7255307d56befec557a2a15eb73f2aa03596aa1e8f870d31f8ca738bd231f1046fe4b2b8aaf180fc9a8de698486202a6995405a4b5436ac32afdb301ced0560ee6d62ee9202fbf7f59bbad65cb1bc5103c086b125ac5957cfa70f90005d032f0f0a0628d5b75cbbf13d16efc62f5776723214838ae329ebddd1e68437bbcdeddf235b7238bf0a70f934524bf910290038b3e6f959c0884c876efb1f0d60fcbad57d90cc25b848095e2b33989713fd169b11b01e70f2c86653281840d9c9edf58e1efc1390a504ceedccca4eb032aa9fb14887b6fdb458aea9a76a255e563c4b8e3cdfd1234f2edddd49aa47cb4aef252e68ff651e62ee38d378eb0176341c4c7a006e0e92a8bae90b9acf8c5409cb07b9d0881e6c4a89f563a6d27bb17f127b4dd84524213f23297b786ef461caca7c2b5df3294dfa87d789821a2ec3c1b962159334fc467b8972ba3d68d1f2610a6168e1a75544a5b507d8250de78b043279365097ad5f7bfbf15618e46c6110ab53326e0b87db141f9ed5f36b1ef7cef3ef1163703983ea9270c424b2eb75609b91672870ddf4dd44616d95b76df503fc47dc328cacf719097e0e56a06f7be6ac1a239bb145fcd601fb6617c8e7691021beeb0720b31cc3343a83f9efa09e2cdcff01d41a4d4363eab52c16c38c36d09f7fe26064d550f3b0db682083c4827701b8c5f5c5d08bd415976fd01909d0e97c8e958a2fae42a1bdb18052399c33b741d762a82e6f89962527a23de0a76420829a7715c5d7adf77d4cd2651680fe35c170d3e21673358f119f163ea7f2c9fdb52030d43d319a51b07c2b90bf896b2042a6bec1d4dd3bf2def4f21f519028bbe658a09c4dad66493743535ca2f21f7b95048eb7c2c254c730798d4f8a1efb2ff6e3964cd5bba8433748a8a1ba5127e43885649d489d94a586dfa873f3cdf56320cd5e3770062b62e8b29256a89c6aea9317b6d7ea650e33b70488a8f63db7ff3c1c3c06e7bf901d44b12102a4da1070b690bc46539230f8edf03e96a65574cb5642dbd249aff71d3e945c7fa0da858ebe18bab07713d4de4ab80b314fc7c1caad479e145b5e38dcc10cc32f5e69a70d34d885f2bc3e91c93c36d152e4ce0c343f32b32a588cbc51eb7d8210cfe3700ca4db1848565e2b6201d2cc6194433ca0faa3317c744e1ffd9eeb772befd21bc9bfd661a4b16e5118caf619d32da1d18ace1ee37df0e91f95823a9452740c56bd3ec94234633a529605700a54b70a1b4a64a8c3095e69dac8e68c71bfc61dff3ab9fc6198afae08b7982d879f5e3efde3bce7625d33791cd75870c678492cb9367e07517a9c716decfa15c507824ec6e9f2da1828bc2e93049f5bc89a8dfd712fd909687262f4b87e79ff397405e402f5f74bcb361fd9dc20e194a93b904da6087712b58905f187afcfbfe023357567ab5485e3a44b3bd6f3a5737897b22bd8918d8261056b3af28c44e57e434bd5e58c8189c9b08cc44016cd03d3fb5fe094db96d1028f2c2ba7d8a7c301f8b66257ad0aabd94f6e6a46879954af264b95908d38e0d969d32a6896a9bb0c721037111e5691194788d7166d6ab3bcd1438af280cc0e64781b723a8831dadbac7dbfc8b30a9f6f75aa0ed7eaf9f74c5359ba2b5447b55d2ccd7ef80ad80ad29908b3c270c9ff5204cb4aa71e55b0d033bac1ed97aae1918c0ffa2e386eab614c091e2934a0b8ba98ed3f3f4c93d9e26a7fb1199b5164fa049423ea55f17dd09d83ab354eb1e84d140455e4795e66576fce570cedcfe407c9f2f5b1c812baedbeaccc295e888ba5c1682c859ddbff696c01b43540c05bfd91936b8a7410c11c50c4a5e291bd2ea1338f3f79cd968e5ac6e5fea98557e40c1b45dc56fbaa4bca1871b050f43e4fad7cad85c64652ed21e52f1c397fddcd8cb2a0d7d42d4774cc90d77dbac188ae8fd96e65dce598e97d311b7c6e2472767e12ee32fbb05008d7bbfe11eee75c2b8a5e66545c99fc786d11e3c6a58cc4774be3007f0ff432b6df26e1f5f0f438ee90937f3bd38c4bd154dd4be2df1340862a2429d50d21b820b732eb939643594ed8462d9e7bf2f2ac033dd43cba6377bb2721c21d4a255a1ce6530fc4fd17b4a5fdbc9f2b957567f90573777888e7ec5cb8234cc59bb35565af8deb1d7780153059d67dfd9eddae29454ec66f13b76aee702bfe441f00cd398c52a44dad648ca3df796a3208395fbb6c2bee35a1a8a2915854648077bf89a896b32bf552001f82c7e7976911a11f728a399a29f13bf58a5052e2a099ce29c956b2c6d3ed6d45b41d65945e9805a8680c8f4301a58604a583a24822ba3c470e52b2ecb366126180fafaec7f9d8ad201f8f743718bea193d10b7db152c80cbfd42f301ffe5244bae9f28c9b3b6dcfd13e53287912a6f9a08f0e295f3ec053e31854d0ef0393083a065131c617be14e6bcbf040e1ed10174bb6a11cb8fbaac08d65b95ececb786b88e31725137f701366acb3776a025840a01a069c663ece11e22d3f47a983433fa4fdabb138b4c33bea6525db17381078665d093e8a607fd35e01e8fd3ad033a13af58673535ae1d0deee1e2786cdca8c231df9bdab96bd8dd4186a697117851e43efb164f99e827f795800e59b3e7facb2156576ab80f7404b73a249895428950129c0f1e32598206767e45aff54812a062c93a23754f24a6f69e53b660db6a263bf41c5304f08259bf8335cf96581b3fc050bf9377172c5f14fd8d7d5784b2a8a66e41530c6910e75bae0c8bbf7837921cc3a1cb52e877ff5349dd6e986316c35163fc2c61c5ad223b44a70ab8bb6731b89947059da0c4576c2eacddb51ce95d6f29e850745f2c2e42e6ee075a569fbd8eadb03fedc0ccac894ebbe02e7b7d3bc1a46c31d5f2f4fb9592f30304bb573a8fbfe75d3c2165c7013cf74b8c6380207dd11d642d0dd968dd91106cc0d11ad4cc66ffcd9443cb2ad46dc92c98e3fe7ed74bf3220b1542e10138d5897d9debe06bc8811635bcbd78017cf8eed16119a87e539036227dd782b5ebe0ac819085526966a5475035942518f5e63080c8b555f615453025dbfd9dc1e9b08c2c82a2dfd8a9e0decd79ff8ba3e6dd2e511db9504cb9530698ea4709c3aa848344cef1fda4b176ffd3c425175c5c2899ab627383ebc90d7272030e5bebf76ad8e691395f59e5c23c7554c3a9a72e9523d2e8a09ce22afc7014514273dc723fda53a4eefb6b738b353425450a9c89dba159835c966a7f174261e9c66e244a690a24748cc31364cc48e643bba974b5a8ed641f86fd830554fb6c201cba3ef49129728cd08baa6fd914f3bc39e2f451ff184dd7da4ee32c99fbad1cc198b1efb20e87a43a33d5107c6bf4562da23451fdf06c73c373cfd8cfbb2471df990acc932f8d71697f7a900678310c66cd801d66191c40c077c33595f41d76c8205cdf1d0212334cd747c1326ddab26d8bd048378ba6de134f9e31df8cbe96fd50122aeb5ca6da6d629025bd8499cb84d94c45ec3409b31614e3397496a6c4238c77544089414b91ab1b7e047ec5dcbc5236d6e2c5dbacd7d89fde472695c377ceff7eb9051420e708b8a31c944e140b17263f6edb567f96b0d3d35d994e10cb5c09c1b110e3b4c18ce69a4f0a62e6a4a359a5f5f377aa4ab01259a6b365d242978e8c244d812a0973b30ec67fcd4d1de470985432c33abe92ec03b9c29b8fcec6d8eb8213f0537c3caa7902e73beffcce28f3947adb3928111f3c9442be4cd1c8f855712950f577e31a0f3b551f3a3cb314df3a2886378360ac7338913e15c7e2986ecd04876c55e4af568b8e4f3ecd651933b70333366874c5888d6deefc5e1935f0505568c4ab3cc101b1fcc3745fc1c726719fddc548623311eca25212096d40b2e2d3b3a653b712bd03c52ab6f303101fb99808c4af5e69e858b6ccdaf88fc68545191f12b5997a363b3d3d9ea7b865986b30e5e7254be0fbee4a7864923673ad4d42c3b6da0045ebbce5c2fe7e08699cf5348fbb32053fb2f53f10d317531b8be5b7eb65483ca775bf7528b9cfd14c1cc3d9a1313c5c21e6fe95b412c29854c89fcf62cc72bc8cf1d33d4a5f4679ec581b9b26362d7c3f7422d3108fb0742c6e05be1c994fea6c34bae55b207353aa0bc79572adbc280032665324a661776ba8f253b2a4b3e989c8fa5c05f2d58913e0f56872f59fd0a74400475f30fda0f03e481e52947e61e53425cc5dd2134ca225a25f1f88b5cfd8308451156c76c7a005d76df1b42d15cc86dc6067149bf840a7007ea36d94a4ef7997e1dcf00ba131f027011630184e82dffa9f2b2761552bdb09655a662130afbc4b54ca07e94ac4c9d687f9ab9eb0deee578b693047f583a63a9af2abf011b911c3a2c42b0c9ff1ccae9330b26a25e2dc9417c4f6671c532871e95bb7c407f883d621beaef84e23f6b48206fab1e9439366b0a53b22654bf8fcd3451aff0f0f8f41d40f532e72366be247100ca11f431567a198ce518e364e4675c6236504c2ba335c6460206018f1c343eccb19427b053778615b26cb3cfe7fac578ca592763d48a33b5c7f4377127f40b5c73d5c92c43683fdbee9d493e0dbe96f8ce93b9b2be5cbc1a876b3916308447b4b2665a642d2d38866a8427d85676e5aa98735955afbaa7633dc0700ab516ddf55669822c5ac137cfed655ad8a1b629cb5eafdfee213da047c215a23e904860c5f0c3ccd81ea399b34e93f23996feeedd8f34e8b06cfbad11affa02789ef0af0f1e68b93627efbb744362d81ca1306ab2e8494708762189b0999f11c1dc2d7cd6cc1b2fac18b646a6b273f54d6648d955d9e368dc26af12f15642971ca725b779ac05dbd40e21297976df7b430aac1e1ebf451b9e03bc96bd19a4a5c90d5d63bff2391990f64d34cf3c36a4a987ec9236dc3c563fcdd3bc534bf50d38573f750332ddb26f686ea10a2251776449184c5d55a174d6e7cf53029280333b9d46be8333a9a04a2f88cb1f783592a7b38ee78082fe9a3f443d353f281517446c5cdcdb255f19d49ee036c906f14848d5e68ad150a045b74c17a8c6eec89b48c556cbb1f95802168ea9559b26d7d1db978912bf65b2808d53214d9cd351f62deb8f9d401c8019a887dd4f3394ce0b1e8dd254443f78f1a722a5c473150fbb101e8bef28b3b0559b59c12c55e1eb78cfcfaf7d58d053eefce6dd8e0c57eb802f4c66faa6a6bc359f439417c6e71a523ec605cef5f6f186ef0eb56bd393e82796531e435790203b0b937bbccc1d7f5bb379beaf95ab6457655c5e248c4d43688b6096f8eb948d376c5b9e83a95b3309eebce07a9bac964f16cffa21a03859e925550a8290788ef5cdfb688ed32be3dc2a96704c9cc18a7ec920b94659ab1b49a75b9c38b43eade70bc4c912900607de76f9cfef7334633a3a4ea0093c48b2f0f60a100806dd35d82ca24551064cd07d0d72ab31f09a63d0b68205c6c17ad538f67002c59a1e2c5f03bd5e731260d5f0c8e5a6677763757295a2592be401b2de18ad73f188bd2ed5e15e604b853944f53379c074d1fadb5ad22cc3b9a0adece5ba83d0af286687a56f3666317a54b8e6c7657eea2ab55acc75af81148dc0d3ff6c983ba2b9bae252424fcd6f966eaee4e4bcb1194cce747023c1862d04024f1f7f9f7fc55a5e967bca074e054f1874ff96341867629f94090d50f5aef33215c114299c8ddd12bd70d2c7973ec3c6a20f5d74686a979be454e9426c7058ae44cc7c9ae8605dcf633e052acc6ecab14351586253abd3e1b7d05b743c53b91ca48b0f956f3b822029b8be55216cf182b1d628074892328f65646d75f97097a169ad67f4f68b65d10039eb9df0381ee2e2eeab1116623561257fe70d22d2fbdff334ba5109b96862c392bf1588e0377b66540ebf6a246a484619963dab5b158608575b1ca1b90cdac715a3cbd83f31176cf88adcbb6123c92fa3b597b801288f7bded30a4a447747787fe40f49c3c404a56debe5a33300dca689eb553847b30743d9be046748899810f7c6745761bdda948039aaa1cda9a04109d9a029c0864a281bcd2a1a8034e2c5bb3ad97d3ae07e27cb96a4c78c8448dfa4064e0679f2f1476a9101c2e3b4529fa36c6b4c775d86e91cc3457ff586fe2d2538e430f0bd31d7d08b3a41cc8d55f24f1c5d1ab17331897a6d2245ad3b3cc46f348ffd028b1eb00122295e44462158444fcf5219413909d94287551054fece73ab536bfe3e42a9c670f180a0455668515e6adbec94a2d80086f965bc16c17b33d50fb5aa77174779c5dd66c6e154988715cb4f4a9fa19213a895dc2ed64513b750239e1f45d2b334e330d79a4bb590956217ffcbac31d019f14b138c7d26e579337c0241d6f9e0519b38f3cec17dafe4efc80ef64d86701757b1652c5ebc7965c7c91ca93607718a7372ebf8be79c965bf2db1cffbb991309baf4138fe1a820b5d846dedc7ba070ae0de3ffd7be02a400fe181512cf3435b7b698823fad691b66d777f4d797718bde66e6e87afe5ddfb2ae96d53f06e856236e26c985381124aa7dd4b097d807ef8bd062bb81657107974fafda2981b0ca55f871583884897cf51c9bc87eaece74e54b05f7f3c40fb0c3c281bd4736e502db39aae1e9b21264c307bf4356548e9715f584a960b1d6f706db192eca6a7adcc4a085f8e872034f717f645c70546b88b22d01209932bc3a68f1b7d0349c92b9fda2e46559bbcf8e88464decb73fd0fa5050b26a525962a9adbb846227fda35de4c461f74a015b4ee58caeb3dafb8ab5190d2ac0761b6b9942fdb4abcfe30912600140e9d26dbf6b2efe160854432d01e008f2096270d6fd84f75d2df6ed6681acad0e4ad69e52726447f52cbabd1a5f363d2aa3561f054917c06edce4903d2dffa1aa1a3af3f056684802b49dc6b7d398e91b04a38b038f93cb35d27a032de5215c21168116ef47ecab6a3a286fb49e3259fc9a02f5b853d0fcdf79fb11fefd1b24b224779159924c28fc3a37f7da03200bc1d6b13f6318deeb3ed473444908c9618bb71cbc9e7f9175f623f1c618d12d7e3a3fd5f4a41c6945887683871ac45a8a5a96e44718f695b8e663f5a01f94c454e4f8255ee5c45ba2617ec9c42e2e1e2c60600eb348b3666de3a53813f3c4cff822b2c287e10f228165ed1a2665c1ab5e72be0b3170d7c7cb920269001fa323346122f054cae162de77c4156f3c45efcb6311de81092b54b761297ecea1469249e73aa874d6f83bdcd7d33c7ef1ae15b455fde33152f3f7c26a2a4bcbc8c68399a1975f1eeffc29113d32b22fa71a4f2f1bcaebd3e2f392a95b7250c208ec174bb70694e9c664c9084439e0be4818b267c44c252c6ebcc575796688caddae9386f32d9736ac65e95b2df8dc779b3510e7227a73fad946bc1006f108e308ea1df898c492e9accf6f5ab934686b88e63721abd66f8e8a37820e40c8881c1aebc04b7552611d703d80e0a04de3ea81edbfef2f69a015f962f1f5917f2c24bbbba81645f75b9feb5d036543868f76a33e4273472f70296e855460170f5bd08c1b453b09d180906704eb205363d130e2cc6190b0fab5ebd94c09a766b8738917efc5a8fbce61654abbdd29f918126b52bef63d464cef1ff7f5b83e0fc10f910a7174c70221f455f50df5a167573ecc79b8d8616ea9006d896c6b95ded3d6e0862c0a100c6eaca076045cb64694c7f0775ac0723f4291a640c1a4dc5d5b1dd2b8193e03a63e959a30a79237a9e50422944134bf4cfe1d8eeb4f2462b53fde728b81c47e066aaac56759b76155501f847898134b1191cc212512014a89b36b5fcffcd61f44c8e8cd3bee0db11355e3e6a4b04e2340e215635b775657807fca460baf93452b24808713acda651e4fa3e09be0c2ea3121c3c191e4e7b70f523ae1932339034b07c06033b163cf48493078a6a96fcb38a38b49d8da2ccdec0fd85062c505aec2b9dfa5ab2968c4cd2fe27b06418715b76ff6ed3fe4d5560beb1571cb8c9d12a6eaa19862bae735658a5676ae14633985e989ec0d0c694777bfc8c319ef2c9990a719f10567957f7c8dff01b510038db9716c92ed71adf204ea75161012646c78f3345e39016123ba4208e6a65c07c82b0c5a86338f1d73f5c88603e92fa0fc87635cf83a79b03894ba278150ff8e87bf2419e898eb96159519483d4b156c1c9f667bb1835cc21cf5ae1e41f7467fd86cb7cf6d7231005000278483fd972615e5d171c588f7ea8cf4a60d8278ce17ec07096b15b4a010f5c85de0eadd511df87b083df6370263b491b0d227732a10aeddbf843e7d93ffa4ade1a9da6150bcdbb612b48cc9741b8cb99004ee228261a79a9c683011360f93ac3b774d5d5348c2e02ef7f099c8cce4c5481c1aba4d6d01534765d25f1238b554c88131e30fc23e35a5f3dc73d77b1cd0deb974744fae6fa3a7ef92bfa4b461f8a614f79034571c545efff1714135d447ef34650dbb1baa8260e75c032ee57ae164065d41870efb229b8a76770d574d656e8d1709f843d9550f062b80fd0988defd50b43a1ae942740105436c7528bd36776b4549fce035463782d40be6cf45000155141df9ce2db677dcaab86ea36a9ed85c8faa4d8da4f225071929856675d32adc4195947795af0bc5f15642ea4836382bafbe24f6c1fe60e960fa3adeb59c7ed42300c250b53529e294c8447bff09167476f6afc4352e2bbcee057a7dac050e0f96bc037a9f71ed76320ed83491a136e270c9646592479e568886d14316b31aa0c75120a93baee6532d2866a51392c9c468a5d60b128b798829ecd93dea28b27dffd09d1414bdca282b9e0110eecb8fd3a34339f192f2d3e3a37c1c9f848c81c49dac23dd1ff6cdb481be46dc898043f7a85003b12edf15cc5608061681a11e1ec418ac7fb877b187098c2329c55a008ee15872d7d1cb85e8c3614e595b22c858e8936b7c5c71e61b7aef0639bfe94cd4c7dcb6869708da7e0b780a02053a299ef3e4106be99a878e19a9049b4358957f06e384272cec43b3525086dfbada4c12d7eca2c64b32fa410f8bcffccba4a7c9e790b1a46e5f6fbe42a428be1c606ca1c1863c1079a630324986ceaac57b3bd78218ac60aa5d1cb5f61c5fde05ca661a634b46621ac265beb515cd288a2744f7fd2a474daa9f239f6fbfd658ff85194d54533706dc0cb13036c4ec2bf2ceff9568726122f66aa8d096bd09c185909a8b4a693b2517971fa003aa15daf045e56c7d9b4cbdaf424afc20fcfc0e186983a31b9a62743e13420c724259d713b4c39ec777ec04f800fe293be7083bbbe138793d28d1bf4cf58626bdfe97bba475c60d60f08e60af10ae8b271237436dfa2521780576c841af32f068ef2de3f531dcecfacc9b29692c2ee4282f9982e46c7c08873ee67f0f4cbb2b735f6348e6b5731ec435a9cbfc9e857ac55caa932be4c47342c7c6c29deec909b7f152cd92bf43b172e43db8372b395d84e7cf95dd34772e5429b81aa005d2ee1cd35bb89ed606bfedbaea1ec9609fbcc9c47aa59012332a344fde56d79457f599b1ca2a2a3a996b46e669b4e0e43f4cbcdcccccc937e9bf31166084ce53cc8b1613574eb78b413546d1d4d0a1f657af980f1bd4b7c8bd29deb10cfeaf47404a4ae8fec2320b79ae534f3bdecade91292848d51507cfaaaac242463c541787d94a418111265d54746d50532813c70b1a4c40bd1eeae4cd99b9216b0645068906a9316e86af32ae8fed18733021a4f9aacd74f7ac421eb3c414137dca6615119ef27de4b7bc8689f20ed47509ab427848376ce5cc7ab466f6268e450b482f0b209fddc63d10d90d9d668c402a3fe9a4618c7ca6ee69767c888837707c99ca2480483a8b4012744a726e1546325696d3bf80498c14565f2f9fd4ab32715af12336e51ce5cbf06107e0753f6ead869a1adac103ceec927ef1f62153f75bbda9a2152093524349263f532b60b6e0e53deb14cc03bbd3b44e8c1fa770d86e52031ed7b76860a14f2b42110a7c2e8629d39c73e82cce280cab0d3ed8cba24eb40af04b6ebd51c46d0be5d905c987b07a5c186fd9e47a57e999ffd42b7094a3377725aefb56dfc10147bcde1bee1f6aadb0aae85e31dd773039ae6cd856f9bba28217414773ac35c3a4e761845aebdd5f80dda709032ec8ca62b82bef7fea721a6512ece6c165cc0d24c215a9818f6db42354f8c5862264c63c2c7af690045f13be8b14698045e53fed50a9f843b3ace15329396548bb0abb354224c098f579bacb3aa3ed4afe6b943b06aa0f4c2891b7d945cd974ed4aa967cc2bbd77908e3445388d67e947b94c83815ec899b0a3a7870811eaf02737e89b8c72007e63e63c5157cb5b0ab5a4b64cb3b23191a75ca25bba2f9de364ad3d82e6aace2e71d7f7d2cc751b6aadde59f5a60fd0f96c7c83f9bd65ded9e7e273e536c5b53c4a505829534bd165aeb9f8a8abac02358bea78ddab600c447d56f56a510a4cf3b9b4f2767a5fcfcecd606800ef42fe5179bb7649849c5341edf6baceb69ac51589717573976f5940c4b585f0f419f7e503812a6b73a24deb74315497da8970323fae1089f4d908f478b74cb318601e20e1fcb830e92a41ee2eb70746a8f16cc5cda75d5039018406f1ea10f884e1cc5b9d9165caab6f99bc0431fe75f958d0e978a37565747ae669994d426f3cece835c76290614617589e82798c6e5db26d50a13d0b1f2328024a309297555da17d6402ce1e432a026adfbbba48ace8f2a7d919fcf25c39e8c49b8a274f8a2849f4a53e1f63595b7d3c4cf3c3f78a092b5d8d892111c5a6edfadb8f610d7a56978f5c50cc2e7039fa9c3a26087feaeccecd64406bfa6579697e8d647b4ac8273c9f77fba738314067ac2e22577815b4ec1b965485987a7d6a25c5e6594add033393976c402f4bcce5636d84f578e2da041bd78b9126fc1df2211da6e23b1966c79213db9b0c9b4c01d234cd0ca525cdabf7b157fb76d7018099f78da86738a217feadb9cb671d9aff250dcafd92823e2cb2240fc5d0dff006336ba3dc4131df5514d7ad20b5b2b325c8c9c54a76b2b0f11829ea064b7b7efe75ae1c8fec474bf82d32a12bcb4ef9da8775396ca0c4221b509d45dbde2211cebc28e2a1cad30b156c82882a970114dc582020d000666e67259ad4afdefdcc4582adecdbb0fe52e5d30caddb66c5d08e5513ef80f846a4a76df481be7699967800acfcae7e0518ad162898c3d57cb88210dc4ac95e17f8185fdc80e2b2590a9306bc4660e95881a87436b76ad20a46b126f59dec6b1948aa80be201d8632436cdcc2f28ea478dd8698350bcffd265de61a36b56ff5e3851b02b2dce45366dd4128cc28f8b0bdaf19b5d9444b734f3466a18f056b45f7f1a05a10a1356d462bca06036f849ebda2e3f1bf43f6336f0c72168eebbf410a28f3dd4ecc1acf0f250b49dc78381e8d4d46d298eea505c9d2ec6d090ad0fb9953e29ef001c72574a19c628bc1b9bdbe869a791aafbdd349214b2252b567bbd7d212b5b939e0ecd886422e1cb289125ca8ff5bbf79f865b6dc99de9a7f38dcba70cbb0ea3aa6ed7965ff97f5caf4c9452e22fb0d9b04fcf6234e07b25cf1d8c25758d354620b6d50aaf8690fd3c5ce704b21d3dd65b6138f6eab0874cabe71b9c9ca2b680ffcd4fa649f4130487b79e88edff141070ede37d4f3ecdf01dfeb58c41bfb304bd4d453748f1dc355308700e6531f85b95f0ed96ee88da02136945007b4d3361313f31ad818ef4ad35a9bd674534ef177b78f7e821efaf306235c6400de64b8bda85bffb74fcff61aeda8be685c1414e10bdfa6c3fc4ff1babc7f646859260b5cc1578668259cd4634639aaf7d0c7d5eb943cbd8e9cdfbea20b732a21eeab817ea3fd402ff2ec1a1ddcac50a676b7ca5ee429fd6f22e068072a8b7b2a1c96b7be9d566f873ff39817f5804b01b6fe1427abfa218f6b9000a78d80145b4a022828d20e1f325dee3fd86dc93b6827dd2b51c1e2c303b616aeb7cefacb40fedc1ff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
