<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eed2a7a5c0685f0186ef6b41b77d9a81d6d323a8327282a4656163bebe9cb9c4ff3ca7ada3337e696a3da93163e881d254d750a0b1c9d7f2cecf49f73c63550bb8bbf69ae8325db3bdd8c754c95e9eddb2068311c92aef4a63b73bb9a3cf93c9187aefa6b88d84eaca1854d8b61ea57eeb76b048bcdb9f7d812d4f27c3d51357e3da674c89db2f0d4711a078f0aefddbc772a1fd8cb1de5728a192f48550cc0b4bb37f031474c4bb39d6b695a162528c5f2cc466a43e878b48ce871ad75eb826e3d65b35ca9fe1f4bb68355c6a40221b54c9aa411e928229dbc5c2ae10c0f37aeb9f0df526b225909e46f6e96b973b3da04d380d2cafffff35deba5143a42685348379c8637382d1dd215ef6b1e5204575580dccc9703708cdf254d5a4e491e1c56f9e57034956d76b2e19c11253fd5cff6458a88cc6d790e876c2fee31a7dd79ede090e50079e28f5749468ab2251daa53c2ea1f2f476690ec6cec627dfff85a4dd2ce7eaf0c90047ef5832a85d58cf80bd1b1021763e5d8f32d311c387b28b23276677c76a76a2548caaae7b7619df4d6a91032362aa7a1973da583d916d3618140e739b0803b9bc37aa825b35c319ea83e22d7d66693661358a1ca67e3a7d103a670439cca02cf93ceb8ed62f9ccef76b214d38efba61ac7fa66494e26830fb63bd25dbf5c7a125ee6be0385a08c30b4d7514eaf49a7af74a38f69a494a2b07cd1e74b9ec89dcec006c361ef1981eb4a0044b29dfb777ea704e5f48fc6f0456791839e7623b59042ddb65405688fb36b58afa500053fd8d1d12d10e4679fb249107988a9b9f53476d9da959164cb652859422ac9e5cb7d4b9e307d903e8a27e02f8aba71b404bd5cb0ef0e3d584af5291cee444f2c71136442ab11bd778f3c015e433e9cf340c5de282b4a31acfdcdcafc11889f66dc9e812477a2b8e8bf837183ea16e124185ef216604895bbd6395e3f2f91fe1c670bc63a61feac5f62b52b3d5a86c5d8733937370b6d90b7320401e3800942912af0b15da5912224d9c04bae4b51fe2b325a12fffeffe63d26acde0d1f1048fcae7c9716598fdf4bb104ef3c470bcf859dfe1549d0aca4507c9898c10f2ff07de53e9d42da53ecbef8435ab66f075174fde4d90fa8e69e6e670d29208c06c1384211cb895e822902423473431ab8e0d24c76aa1b1d66230f4911c2be03801379e45f0a1e0d5cc4bdff2994eb86b7bbc9250e6aadb4409576865aaa555b2b1fe86907c8a27025fbf8af23f6951178b21d53d7cbaf46d093ad6a1dfdb0e3ffe2e238547c2c254d1de4dcd6c8fd0dcc38c083deea28ad944b6b058798cc854ebf8f1935be6f4c0504557484680294518e027a2886588e50d966307f6b778f35afe4c8f8a40b3f7cf1b6d92c52c62a479f2fc615f4b9b689bd9567ec1c77a08a5957db6b4bf9f7f31d217eb71a371503a6f8cecf1e4ac8a3a2c646d2c59c06bd9b37667bbcf62eacc4d5b87664e3372ac02ff5e5bb32c4c3a357fd8e4b5b835be0b83a2bc939f698bc8d5588e12f72584e925f4289767195f05dcd45b70cd3df895ce46f6c3afe5ed68b0a8a085865b945943b231a737a8b41e6408a24381d1134dd802b403fb5717f438126cf40855f0f83a096fe8e986965bfd9631b279f79bb069e1822bd2c310d2625f1d02566e71e96118f3d4f513b9d7aa14f451844d9ab5acef72e8111c187f461eadc6fc597b1287fabec9ef89c7494cb1561809372b912560c2c80035f657b8c8f6c5363166edb5ab183e2dd2d0b31f8ad92722e0d33eb1731b74cf034fe85bce9f185762a90e1b9cf8d268f8527a432a73c8dc8f1c987b763514217925e92d4e9a60b7b708b2893e461a3520ef4603fceacaec8bc8555ccfe67135b0c4c57c298d3c3e2d441686c0077e4efa675f92033049e00ed88322e1d94d497a70989ec5c6ee50805a0acbe5acfd28cca5ddbc23e298bced77204c6f36066a0ed9bb90d0d5a609b6ae9ab46e688543805f747375c5025f625bb6318082067521ed6d69b35d74b5b065a2828753c13b7f75f7191bb81bb7371d941204022adff15218f2f6a2002a3985d848a709e42198edc92a18412b239b609e0683a30f7a5bd638108069cfa74dd8e5839cdcfb04c91019c4d14b480fd8e3dd591672edc37824d094bd9b7f7d82a92310321c99a375d5277066caa5d6fe9e79b7b0c74bcfb55209ca1f54b944fab38a6c5b77aa448cb1538614016d5938fec5fa2469f4a3e8b0cedf7515df689b078aaf1ec1652a68844738a6acda50f4c57a47c1da2f82437be0987d2aedd577c75425bfaf0ede12529c9ecffeffa76df28c41609271e2711803d0617be435716f3d2dddce03be574f16b3a3c642070ef7f2a9e13ef7e768ef5e331a5252b1e53742a163182436813aeb2c351e6c48e03815dd977f4067005bcf81f45d24c2ab31bcb92ee57471872df63c27418c916ef21647aba633bf9b367ba098d152bec0d9019e7904e54b7fc4bc27ec0b8efa3ab5092ae4ae8923b6e0c0af6efe62d08e81817c1fa58c58baaf2b6885be3a3c60e6d5ee88c72aac417835744b9b4501c887922e71b5147958d1da3c2146dbb8fb12dcc3fd43cbcb8b2f997f74c976ccf5107d984d1dd69dd8e1611df6cc4a6e428d578cfbb35bec5de3fa9900edb4f7d6017b5fa571a335da0fd31ebf5c082a64c91e65cd023e2829f639a1926c67f15f290bcb80f3c8f98e20a7ea14e80e2147624d27041083c193fae5982a483b2c04d5e99792219b774f9d7097400e4121c8edddb93bfb70553b0fe093ead5caf7864f0d1ddb538fe47134973203f6bb3cb523cd1602045a13d423915da188650bab0d87c9ec3eee498bdc9761257d0b7ee7be52f21835aeb391238a75087af45177edd9239f2f03cff987bb64d1f02a721b7ffaf94bcbb786383e187b629cfcf91ea1ecaba1329899b70cb213d0db6ea0c165d2dd80bb6ab4edfbcb35b7a977e2ac125e5bd3306b34e1244b3087bacb5a4e8933ec95cf8b92b12575f0bc5ae7e875bca394191748b8de4af46a22105af9b7f08af705da253162463aa61ec72da74dc3ec815d00913fd7158f1d820d071edc950b3c27d346d21337aa94aceb383f4ff8d06bbb79f642c00d99203380185d8c4c10ab1bfe46e7fda3985da209b78e9a548b84a5f57052191ba0f557a628636105ce729f7dcadf697e4b1f50d214c87a725f78c813fd10cc51ee1631c483fd7317d7c1d00a919bafc95cb4b1c1b4b4225eb5e47b80981c2b001621289455ca062bca794718114ba1c110a2fd8b05135a9546cebd6da22c29f4f04c29f6d5c7377dadff5c6e8b2a924136b2f9ee97b42b8c28bd3f31be01e8b0e2d13787635c462b1eb23e4de799888d028b322da7f3fa214c6706226ba6a9af00c57c4d777df97a1d8a9287d56cb9c8de76315fb33561a940c0baa8dd10aa7658381c6c4562e4b7180999b151bb643968918d61c112c2b034671f5b02badda3ea6ef1bfd86c9016e790017607ef20a0d06eec811f3420acd9f7b61bb100202886ef041b29332ddd68920bd3c991962ca406434807fb3dcd016b36d5b1b649538b3327c4f7e67c1171897715775d921db3b9cc3fc2fd58aa0bea838236d32cfe55ac9c6c8242fe189585fa74b634f4a8af1edf73bbfec92a329207140f9524f9db2e87182958ccbb474df6ca133307effdfe62a013e1987cdc10d4dbe40801b9154d05c146c6a668f8ac871e829a826e2a6568fe747c2e06c900089df85e8e17619fdaedcfda8a56111751bf994c36483a9a98cbfd924a41ab16f1a29f84f7ae9f7bd2096f55451f293a3e26bafa454fe04bf3d1992d8e3ce5b486cbb89bd4ec6084fc8dc3431da43cb5c6e3682feaaf37af383378bb6e734e237af18d8d2c7f4b06ee84fab1e5604159c8219e03a39ac6619f2acc156e3c216f9a2d2a9a4c1eeb9a5a8dacff64e68998cfbfdd04c3fcbfa27b3afe9f47ec0e55a1b4b53c9d5e722a10e89405057e043f2ae16129191a9665c7961f6f081550323838861cb8c6880496081e9472da5fa703408412e749d8dc6cb7058de9dbf7d6a631ed0828e56ec4d8fbcffef5a1e2b24f66a40d91b4c4cfeab94df9172e69a5af11e070016023087cc5c6b0e8a04b9dac652aeea5d79e58db5ecb4b9ee14b2b992b7a75197dbbea97fd02d611e66e438ed8b7bff0374e67ef80fff1a20aed27b128e8d4b7556d931e96566c18457904a7d2021a456e64ebafa83692ccbae00af4976de73d4981dd879a5b84705d8978b8e3cb1dd716903ea19746fd66d67ffa92ba5988e2a1c84ab9043f8e67f68d51387d77ad00fe9ec62526c799d314cc4a6d5b1fd784c93054bd04279b2b378279a866fbb6af2b50a8bd3e9fadf23124dacb4679f2b34f498e633fd50a18388f568336e34da7a467932327101671ff371ef284508cb164332cb7d71fb5e04903b7fa37f896cd2cd2da875c841971374023d92469b60890be72d8ada592aa08cd663baa86773d26d747c13defc0e1d74251402ee167b4ffe4a3ae9d7b516c16abe3d7b04a6508045fadca7bdf365d2d6db5c6f18c91e63f83fee7ca0b9c1a892065a3a41caf0f46bceadee4f9d0b0cedb07ec032c2a1545b750dcee0f30993f8cb5ef54b6ff43d75007514615f1cec50a8964447d3ae36d4d6da6abf4d71f82f781f28f8ec9c7cbfe7393cd1bcddca364632bb5d2a02175dbd770cc525f30670f34b2efb05a7423ae479c6a13f4db1cef879b448d192a07a0f09af877abe9c12c817b80fd75c669f186701568eb5c23cbf9b4d0e6ce3324421266cc656fadcd19caf3535df7735e8a5eefdf04dca68c55cf6d6dbcb508c467e01309d439894e848c9dc59054135cccfa69844957e21c599440fd15727fa73ce5c458e505b16cf0e82de47ce8b2c33ceee71f0046f76df4b1c470b29e8d60af80dee9811543f2573e529c698f1b7d02304bd9f636e5746a2aa8c8fe0ec62d9724a4ac09dc21ddb2def044b78c37abcfc15e3677a3f1c4702d4208ce09679cd11b5c7cdc2a0b6a4c4ab387630dac2cc14deefaec1a0d12e5f3b47b9fc597befa7efb183392833b397b1b06a9c25a47e361dade5c9b5d7fa7928c578a1f5e035b5af440ebdb7ca13161d0ddfd7648f6c7124070a5290614329d55a261a1e5abc52ce57cd746e655662647395ba938e0bd550709edb015589202d7c80325bbd673ff87b2cb4e5d896f94feede2ce4e76949e9ab6dd9bd2af7bea7fc240a520c3f483ab21425f1755d6c167c6eb760051a786765dccf3009af47a7c3fc7a99dc630c45f234646bb95169deb25ceaa7c9841fb0c2abeff8340b10fbe7b61f03ef84a51a69edefe222662e95fa2c8027d888596d3fd289baf633a4ede0797e75100e5b23f900a6a748bf9d2618a575e2d9ad058727db58faaa670348ef320f1642d5120e4b803c53dec149c72a89f7c2833f4b9039c94c4423fb16e20385850e1ce0fdacddcd5ee62352f996482b0e634b7661cb7d1d939e4c2e3ed64fe3747e5a2c41847fdf550326b61f964c32bebe59b6f8bb360281a1baea024fcfe5932981c63116413c08e1ea4de4f82467558374b57d0730a6c3ee9c50cd505e2895d8dfa5419f003d62c1135d15048016fb801d5b0975a22fb9ae6291292a8421b3ff95328b9e9878c61196a2619380539b50a2fa9e7bbc74de257c534e41a10329f1353913e7e4a156812ed360ee018554be45c62fabebc0b32b51c6851f4e107b941ae3ea57face012308d6145f95f1809f741faf9be518dfe5733805293a341ff46b9fa3ee08be5f71edbcf2e6b0a43a9afd697ae8c074371a3833b5b56ce62c2c07745ba483d2d8ea76dd96e6114d9e80bb3b361cf959882f6d4b4c81a9bf30f484cbe23cc7271b638ab166e79ec0f102c3f0d63cc2c8aa46840db58d31fa85b2e9271a0bb276db68f8882e649d0b38c9e3ef4578cf026a92e4a25da425d693a49dc4ce045a26136fe558e1678c18afae4591eca56ac4de17f2b6c52c02a93e37fd227de78cc537af5cb5aa9dfd7ef2d55c06bcd7cab4bf222475b76812356c884bed7d7b12ba1b7d2b5089c33ebfa1c2c65e2777fecd3566a47433b276ce2a7d1ed68203d938adabbdd12c239d381f8c472a5ecf0c039dcd165ce41958d546419fc9eb8c376404a0f66629c1d1aac3b28754d52544baba1e1721ff136378cd594eae835853ca0a90370e560c8b93f3b40814bc44fe03490afe0ac7d369e4cfee227f56f3271b953c2230b8c8864cd37f6162ae3f7333be853f1b5930c9ba1055db5d84ef13c733541fab931bf2a6c0bc79f4477314ec954f97373f0c7ebfedfc9cd385d4eec26155721ea504e57085ce971144055e568a5348c73a171cd839dd411fd97c743e9003a7614ce37a09f158d48b85256e2630665b1175588cd2df2e30b63f84785ca2ac4f92a362e59ca93d13af16eda60a14f90eeca9671e49d08c939cb017897243e016fbf95e671fc02ed99e8cbe6afb25ec96560915957db22262628842f8f01e4910cd0ef82540f9596788dab6f2d85b18c838d429cfd46a2bdaad3e28c081a7197b671e302e7ae9b67ea0169bc61649bf458809ef49694798c8ef43654bb595ea9120a9cecc852c129b9c2ca03656d80aedca71de33a5284288f567665d76adf2b01d5edfd9a7628ecdda7681f3b8d39207cab1596421a8a4403a3bef5714c275072cbe15876f6f33c04d9302820af75fd2d8cfe94eafcf30d00bd84ca7116702efcb716bbdd7ebb3eb539f654748a1696ede466428df7fbccf0f8205aedb2bfe76347a6e896530a5716f40f112dae46348f32da396e8f84c621bd239464c4c575be6fe7ba909c7b3c703cffcf0e7d97a8560e4507bc68a812bbeeb199c727fd9c8ebe32f0d2e3cb03ed9f7467bdb34a108692ff724bae66c1886883d0b691efc0850f7d88ac1e2354b92d87eab710897ad8fb9eece240d6f7739ec4ea538a9d2e365d4e5e0b3ad4f2a675da9df189d6eb22b07f6c36d3561f4fe063e76e16b5e9dc22fdf72777a267e0d9b586f7965430f7eaf381c35c387a70a070d7305ae5a8149c70f59b83e3ea9ff7e2d442d53ca3f2b28fab4b19bcd80a6177235af4737af3c15c94e9c87504ed9a0a76c154b8aa18de8b63fcde579419379a0d009ba91205b4dd5c2869fd95d606b8d3f2cf480bd8da967e2269319c3ca25c4643409c46f619cfb8f51415af2dd455b1d74645c312b87ebb80c96ba479eaeebd00116ff42104ef025ae2d86dcfbed71754c7b5aa6a08ef47cebf6297e83c2ee7e55faea704a4986f7b0bbf0be465c09977d8c03fb5a3b9caa2ab887ab69246c70d021d5e242530b7f57c9a37a26601fdd5306c77a8a49e09672fd71e96b1aed8f5e799de6c445657623636a2e46b615ef29cd466a8109e1194cbbeb23f29c19159fc3262fbce281fafe70a320c8e65d185e9444d3112a2b190c6f61219b0dcd58ef5c9286ddff47326c4ac85fec4900de166b5e3f28c1f14e3b37ee4ab452ccff360dc874209a5afe1455d01d13c5e437b479576fed286000ee21674267cd2e08413c2d5c2c6ff730f30fc394e1ddf6ae2f186693da3558b573016ca0933fc9e07eebd24395b70e483b4c9f75733ece59213ef3e0158b9dba99bf34ddf5f714d58c7cf75326fe15df7ae8b31ac3bff86c6975a9f868601d99e554b390d93e8a85824993a8b6574c1fad6642eb3c0141a55461fed576886dca60191729c45095c790ddf372950dda67890000476c73b2d9e0dfa3b9729cae4dd88de85af38fe9d5ecf93305eae34c717ecfcd26ea1a7103426ec82941bcd1416f3f4075c234411aff7ba90c6d74d4ff95700489c0b44ae5f1aaecc826f12de950e3e85d7c01f2c6b4d090d3d217740aede21e7945ac0121a4d16b97e217e5d60d35fe0461db24166ebfe7c5c1457d74436622805f196a7000b59ec8cfc52075af3984c48c8cdfd48c903ab230b1890f1dec84f328b1f73926b105cc54f3f7e5b1bbb8c6b082cdcf27c32a6809a67a1f0e0f307a67a5c296a954ae3679171fe240a5546c096ff8cbba2c002e5bda75d8d7d020890a8b1afb862a610db6e87ac9be6c45838c9c6557e3f4ed2151af681e42e416bd553ff517ce60c8249a7711654cef2a8fc8e0873ff280bbf1b8e7449c8d8f2e9d626c438c0f85105adf6b81bd89ff12d1f75ec3889fe918eae17b12aef098d28f850327a3c570a5fa693d3ed88b8216eb6a3103b90e6257eb48ce33e44861f609fb8e0ba5179fad7535ef56e0caa46730110eefb2ed3e6c8f73481486b4e6e24975d65dcb143003b7078ebae1cdad49da62855d905c232f190d7e5ef9c48bb1dd8f20051c49dcfd254661a2dec9cf522f688db7173de5afe7062bcb0568070dc6e301a2478de82746118b2f82202438bfc920fdd2fdc5f42fa49c008d95bc7bac7a383607b48c4f8fc4ac65b4b404602cf476605c73ca7a8de5ff4e5dc4f85c922f4340976c9d0629016b10b4ddff62e1d72921359b320ceddaa4a94d58d074ca7831032e61f1af3f09c4a4e7a7e3aab27282030a27f3ac66a6dea97abe83b0fc9983bea58875037e9b3996aadad2a2e673030857fd0cfa14fe08b1c0feeb3572b6ad5f3c4b055deaa6f6ea4840f9d47207f4385f224448ebcfd7017758f5d0986e0a090426bb7223a0939cc5410a11a60ec6a1e44079ff578bc965509374ad86c98408114ef412c9e1034772d5b262cf467721a7d87e16e38ebdf573e56246c5d7667afc4e5679e86b2e0b86e449bbc91889e679a82eebaff1208d18b241648f36fc8e491d30cbbd6b5cd79edd19674f81c4e576bdbde654f3eb1d16e0722c04efdc6446ec279d41cd1fbd4a53022d8f01e467740f7d825dd62ec4271a234003d00b9a50a4330ff909f2d16bc0ad91499b909c0beb57e27cc8342025204824b947ea8b1fd040912ea4084e63dc249b74ed33da73c4e2e9a032dbf44cd2caf398db869c68a16999e9726f78d8274a5a31b5e325ecc1fa0d861b6d5558fe5f73f6aa19e0ec6f7799a7a55a29c91e4444d5d979b79b00061fe0563d39708b4a0de8fbf2e709579c3111f925422bcd0a25d23cb085f8885c5350a26cad1f6dd3414934a5d7a937b443ca50826fb6e9649a83a1ab3e8aac5f2750e2ed3b7f7911381a1c07c8c72daedef6199070ad9d0a71bfeed248d240704d6765c97c2d39fb4820cd90b6ff7ac2c50ada1e0e1b6571c44c5bdfa2977066dd399d9568ac2144485daebbfdd7de6fe61f0653ef99aa850d60e25380ffe37057d265509b9fca03057f3fd20fdd7ed4b549f9dee0ca9704f93cf5aef71fcadb7aed9af311799fe2c567c5acd3f055ad8a4e7f60696d856bae56b92bc96c409c6f549757abd06c1d285390544a12b044f2005321fd0e7c0ad8c3b2c05d70456712856a49210e598a65585c32b5c86c163e22c1a8fec1dbca0153b722b16f4cf73100764608175d978d2cdb0464ba8186fa66dfd36745a6b1aa9fcb4b8072da803f9092348f7cd741bd59148dbeffa50c237642906934487663bf4c86e2f00d79a35234e0cf5de754ecd9699595150b295530d4a129814e583af06fc0fe68384fb37097b09ea4950defa8294c02ad3abb8bd10e36ba17556b7cac7d4a925fc72142509b6f1f8f98fb169c2f7bf12550aeebca75eca935932418eaf19ba536fab0a2e9b75caf8fe09383f3f95d1601c7f3435935294c028301a5bed9f4f6b8a120fc2c17e652135437d85b1f5855df8ad1a035b7b8fa812c4f4d7f7f428d1fe1665385cde5df2b1ffb6cf66b449c7e87e6fda52551f82461e712eb5932c87803ad77138710ccfc5a346e3e2e5a4e07a1b61194d33eeff3494c06050161372eb71166a87b6ad9cf2aa724a732e68441e31b44296f79cfd4b1cec85d4f83973d35c188df23a8eda90c6ca9a001620306814abc76d33f01244e0db2651b297433ff6d9c837affacc66d40b130421af6c280e87e098863b2b8d0910cba63fa9d4ec01f1814db6fdc9748d9ad1a53b9a3aca52a3114302ae405945bf8ac5cbda35dc98f405c4b840cb80225145f070c78aecd180cf2245e156ce616f15833378c9f28933d329a15331d0a236e5e5e23f54c3c574d38e7f5f0852eb50a6546459ba55d5ac7bc18a9cbaed6acdf71fa73d3dd80e20c5647158065b19c2548c884567b61f409ca5f4b99199b8457dd4d3b3867eba6ae3bebe55748f211452166831066153e60aad65f23f7d610931d6780714ca2e950a78ed5513d490fef171ef93c763cef6b570ffaa1a099b88db4b0cc1926805c7ccfc42f4696823df852fde4e087b5b5e8db78d26169fe0d16bedd477f493405592d500f95a83736db2852c4a5e2a715ebf099edd8d4796632d27c37b6737b1423da748e0e201c40bbe5f55a228007fdfbfd4f05d9a92d990d8299d2e114dd45413e9977a90d67849b8d7b5ed8922b3a88337659324296236e2c814bb091586e7c61190b58fea21de37b94feec5fd80b7084cef66762e598067b7338d6363fcb88d3b71f6dc29dbdffb323090600dea9a811e75260ef6b4f2dd86adfdd232e3c372990c390b00edbd125f43d77fdb8a2a7cc30d9f0413ad4460ae95f1bad01d318af9a0842ed6e33535ba37c494b8759b462b95880b602c605d38a3cc990d30861462e55dde43a1da8db03c69bc2d617058055fb17dd328fd2bb13dd8ac4ba8d95ca816f6ee1c34dafc5cace3bbdeea1adfcb95d208430721784c918e4a182a60c1762c8d6db279a69392fcabc735c4c46a57cdcd49d17491a65cbf67886bbbcae9cf599adc241e4769180b5c3dfc171218da0ba08b92da10b14491fe1a92f5d7e69f09108704e0dfafd83f42e74b918a96ac6117f741ed5eb934bfe75331df6b9829e8bd4b8e1f25d5b2c90db030c1899670e938f7faa6374d84c4257a238195f7c04356771990265ed563ca1f5fc8b3acf6aed80ef80968126b56160fd7f51df0832ad2b21ceb35bca5f02f042e0b43295e769da4dd51812a5daa143581be398deafd68937f241258a0e3a46216561bc06d94b93f633d6c46e264401d009e7d4e42d7bfbdde7d329f6828063fedd2f7280b0f79e06f1a94c4bb5112632092b30bc7b75b93ebaf34e76949399510c395bb6e385e35ea20154491f2d5559a62ecf5b0391aef6b3e06958e8092a13765453a19ac89af13e06eb1a506baf8cf8b22abff399df6228b1b9bda7060fd84eebcf0051cad681ee1b5dc770996bdd040901554e33659d3dcf621238b4fb43556ae012de065b8ad1897bf233f8566042ec17c36dd6ab12edd7feda8aded8efb5771322e2ba6d12ab5cdafa768bdc13672756ac00114a5475af71489be4499c5901da4f0c52006f56b5f62da6080c315894a15f592f3c5b1923001b809b1ef4a16aa084c5d61f98f84f1b09ef561a9430769caf06997ee13838224f024b24bcc4385bf2029b7d2133594ae0492e26fe5011cd96c5cd9512a3efbf7ee6b6a4225a126e5bb937150ef37c691eaff1b4994153b8de2e26023976099675fadc43dcb471bf3543dd89a44c1905c16b70c395007822f25fd90ec15977147e9488e47e6669a34e985e4241761680759115ebf253075e9565083c3e24568c4eb71c3ad32ba18d2e638f471459bf965df8bf7703b929dbd5a989652e2a99c6e8f158d30ffdc4a9d7b6ef2c3670034e9212c68a0c965e94d5cb0dba993a0d65185b6ff04885d63a9a771fb9a700134d46a5b78c87e118a00d7939a8c706c039895c0a8b91057c8b543deda902b8067c3fb4edade72032624fb7e009bb6c6a8e3cb6ec1aee495bf30708db9f259f52998a5fa668174d12c2a8b695b0bdbf4dcaada8e73965bbcc1fe7b9b240ce6003c9d402bb3f14ced523967e9162c320577b904a6285ff3cf2b19aa7f5f8c89f7d74728515459b560e31512b917f8ec744a1368740fdd0779e75d6f67c60ee0ba8eb25eee8183d0a954d7076aa4ae41a6d045c09306e8b8b3800becb766a9e2802cd3e75172837f9cae8accaf9a83ae2303b7c696155f2bf4530b7c79c990954aecd7b71d7b8f30c01e8951e4146c7fe3975d86fbe7e03daffa1aac1056ad839f5a5500af54291cbee2d2476f4bdc26cc5b748b9ea249f5cbf05b4f5161a571354ff0a684b76219783d989dff2a4b88d7c505d03502a94e8bcededaea3a1fc52cfc49cad2d5ef363dd028af5e6f86f163b4dc3be9b7598b6410bdef4fd057def36b5f78d3aa35e591ba91a382dbf081e7b00b3633ecf632cad8cee55aa308ce3b2a1ae0cf4e1a47404597e9ccda244cb43a76e5b335fee236c030555c40206138319408ae340bbf40a3d3a934bfda65c7c8d719f93b9058f20e4b3c384c70fc641c18ab3fca352fa154a030d0d4ee02a346decbb2b7e24f47afc435beef792cc7f5a24490a17544803024b3cc17e4e08872fb5896959345e9e38c545118208be7f9a7f845736d5e0d4b23f59ab61265390104ef1d93fdb35b1b4a77a00eeab445e6078c8e030c2fe751fb6c5b0e9f15d877516114658e4476b970038c084c4e0c0545c063e37874af3f30649a134000a8512348cbcebec446f693e27c02b1df3ae5b1972a1088fa66f12952d6f5ba9ddcc90e54d0099125c9e7d10c27fb31eaeac8aba2d642d6087768993427ad45f96e90bc8bcbc4be8ed235a593e61979ffa79cdf9de169b4c97613f93bd467fc08a95b4b1a02342c5f5605f63e9ece2d334cb070ea554ed8ec62c2107f4570cae7f78d49a6cd511d2c42d24f9fe56a5eb0531eeff9a6a2f1ad2c1584ba46d1e0678303aa289ec07ea4d1c3d4ea84e69c94d542fb9edfb8c82bf78b70de7760abf11cffb1ad50f9331453bcde4c3d34a02c3b7baf24e37a67ae0b2ed704b298193af12fa9299f83561552be231b76a2002246776039a34c01cc0f9a957d6e07b39d5aac341ca207720df0396097f400946a34f60bbe221580f4c5fe46b21ab42dc674859594c0c59b34798ead7bf2d71121cdb70709b2b903ae40056600eeb80e1bd0d1c7fcd6f1ea28cb340e20c7b836b80ff09e960d9a5f025af1b8ac30092a18c7aa5f6e9b4747e6b745ac0ad8235314df7de4198232f29e2c3d063d02b9acba3737a293e93dcd7b332b5e60b89d2a0f37b94dff855d1a26e98b54dd8df8e3af2729945b846622ecc4f22f2df36e0b59f1f29809d36b7956dc203dccb11669f57c58759a94756970627ca5dc01f4c6b00bb5539f41d227ccf4b06b350df6f367dd4703ca0f457929b0e9fe14e560acda567e1c83de56c623939a33f488be75265c44adb32e9e12653aabce10e4cb9aa9eeb2c002cc7a4eca010aab4723eaf90bb849b9ce1b9a9eb3af7c3f21c807cd812be9b49c4e185c07fadfd5eebfcc744ec88d93ee8cee96cd4a9aa4c6dadf20cfff7a8885f5a231ed434259a492d31eb713a04e7312dfe11ce8f7a3a3a5a478cb68f1cce583bbcb4aa3f1cc87a9c3ec61d102f05640431579eca2f3b6458df8f1ac590cbc0a53a9e75c86805eb505456d55de5097833f6768f9b2e0060af8bea33d72ba907be4eced0f43b483d25a10825516b5635373c4615dc48c287b96f2be7a3a2048ba07641664edb8c2cab6df139c5a2722f6dfa8bae81dd84010e1b43cc95cead4f0d1c6b3c5ed325a383b840b251f650c5ddb8605c8f6441e16db0fa85aa3398dda148940d8d31beeba31c87461c0d52faa80ed6248e29734ede06320b7d8b67a7cde4a75e19a9b0269ba4ffa3bc4d4b8298832c4441026371b1a6d217b17acf77a5fa7c8347b8f3175876c68966782984d57c93b66c1766f7913e6556333ead448ef754344272a6f50938cf78251cc65805b5aa9480d70437266709207af9d73ff4d07004ba7e303b434a96dad53322c1ca0a9bb657015d14cb06aafa7072b82e77a6715715c65d727b7584ec36f24edafb2072e3cebd33c4950f25d9a599b53ac2b3957ff2312431c1e87c5227ca9f8f23dc5c30849b02d4164fa6c0bf99960b986426108a8137db834fb8ba05b070dcea9761920aa98a4422ca9508f86ff76f58cd11137471a461082bcaf21d87f13d471b1a7e2f4f80cca65b1eb0e319a9b33fd84a761d871ccedbd373ab264bebb061f4a9ab1baa177515c4c9c8e986da3ecfdafc33917c184e51bb644afa0402bffa9655929ca0b9b9640725df0d071b92459027d4a2f8e95a6c0185db934d72393b4d5ee4b20f70407f549fef9b5e3927ab63663b08e55569d79ac5c8790357c2870610e66be961919363f62c42679a012815ec96f59497e53477527050f5497159909320ef00334ded52a6b6a870ae21de1ee8142d1f87b8f7b0843fbc92cfb95d79e35c2dec5c147a5fe922a35a81afd16af4ad8ffca8869d7e24721680d1d1eab0ecc0b85db1ee9dae30e36ddf6335d1a73728dff25ea38df2dce7d3edaac99116e9152696d7c8213f88548018ce689acb15184f3af06a05215de105e155910acfb4ec9143d71d2e2fc107a99f1e7315f44184398197ed4b8586f75b5c2b4c39bc0991ba6f957656b1a61b4b24a1a46ebbbdd396241b489f3573527f2af26c28ae25a8767bf088096a1636167102bfb0275d7cdf23dd0950af74048452f3d9e627261ca4d934741949e0143acb2a2111e5b13d5cf9b3259670ca16d33f979b0f575772e7fc7a8636bec837f229ba5ee7df37ee4874cd3bda6d2e9885e6f3e2d4fcf7d242067012ce12bd613d1aae4b291865ce9befee8d997d8ec51f1fea517f2a245f285bf76308caa5d5976433e40b76b7d7fec2b283e83bd20a5295e8d65dd9412af79c6d5aa4c10e2e1dc626db2043419cab901a2f1e6909c4de0fed6804a061e46946cfb398dda3d9b9072d23821543c4f4a9ec3d297f6acf25c876fe0604dd5373633c36c3ba928635c1b43e93d99579e0704773f9ea2df1d04ac23664f965020167b1edba1b2c5a6d4c40fa640be5145fec84fc8b3128e3e72ddbd9397036802e6fa7115f9a50a143396ec27b838fdb1bc95138d51f820bf1492f8788b5517c51edc15153f93358276856998dd027b64c1cdf9daec1fd5ba5a1d0a5e9de0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
