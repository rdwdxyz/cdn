<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c51392df267bc705f3534157ac37cb970a5a01782c892ddceae3e31c84752ff5ccdff781178d58eac33a468d76c1a8bb0c148a037ad9ec383b07bf56ff28aa9539f3a295db094f4c2a781a33144927a8ebbfa999d7eea31ed21b6825aa96083f5b6972de8351801e371445fd0eb883e77e8015ff1372057fae570636a2f6dffe7db50b5452367799517205fb3ea8962d20e2c3a27b08bb08fff44c965b3fb48dbeae03d730c45b5f29840955ae86719b2bd22154933dabff1e684f5eb6955a14cdd8ea26ee83384673c44502dbae1ff82d29e26f39cb8b58fde577a5c6df7ad5e9a48d4f2942f82a0e2eb1142ef50e5785fc817b2e27522c85d2bfbd86f58752afbb3ca57e90eaef2a20c8455e8c47c555703f1ecdd9cd4da92aae2e497d1fac631280519bbe6cf6725a2426f235212b7470699479444f1c9b17b3c9c6a4584599b37c64b90dc8684cf211629f1a890d7cfd932ab8f7e618f62b25247b5f706a0c2380c9779cecd01812ff7389d4e6888187173dedbb2f767eca4813c81a9bb05a4fa37fb1ff352a3e30777e5459007a463eca20d3d9d7c169e06ed2f0ff1362a476d436b94afbbe59e2358f70cbd46dc79923d0dfe509cdd1d18d46495bb74998147fde2d2c6fc0971602f6810fb7937e6cc08993a68650aac76a980036364bbd7168baac9cc20bb7173d17d32925e48cf721522512bee10b3fc762b595400afe89fc83fd28b2e0c25749e098c0247f7146d010963cdac330c827051310a9089ba3ba958d2b1cb42c645db6838da151f57cdb37f31660fd4ff8e275181e4e9f4a0ef171a8796690eb2c66730d480216e6b03aa5667bd4e338c693eade69681487941eeb8d9e6f42b0c12ed4c3fc84881d464712efd8869e4cc37f7372d5be5909494140863ae4b293e0017ca9338e1d065140e2f0606b4233320d4e96fe6cf5393234267cc65845200474f3e1ea3c4e13a23b6d5066b59c78560f9f31bb7e14dd2431259088599596e136bd983f2cd40035c546b620f2452b0200c8cf6034d11aa03af4e896140fc17a4c6e8285f9e3d377a07cab5a6b66d4ffcac5d374f99b4b704853c0093ee00503b16f1b42caa11b3ce84f8581fdb9ac26bb0788a0ae631a3e09b6babc93eed1e3cfbc41d42d9692629c0a4bc0f4b00ddb108bccf3edb6ce8413960cc4e7deccdd9af1019df4ac0c609033bdb6e1a5e8d06b03b232d294c0f83acd201cecc0238f58580e1015b6653b9682d0a6da19d41a55399969875c4198384c6d11e8d5367fa9dc8f3819068ea848eddc60242cc05f0f5340593842c40ed4b3aad2320a9092934e5d3f51be76a8e267b752a0766be0c5f4c8a4ab7f6b7ea4d9f5a61f64035a89670c1543a65a36ad4fcb50d546b32e853c799a01ebfe2db755e3cd81a66f71193da780b9d1b065a27cc598c4543cb75f1539992033c89a6b990dfd58a0da38e0407681fa664a3c2588fd3ad0e62101d05188a7963a20c4a55c59b697aff3137b4067390c17b51157ce469d5e8288a167e450dfd4ae7c834f89a1ce12acf0f5ca63aa57940e2e0336394ccff30da68f8759ed9626a4f0c38c634ce649d49a23a0222d5727f39ec2159738b401d8882dd2201e04cbef25935222c4db141aeb0bde8a22c2c8b363c29510fd9dd9ecca65dd224afe6077a671e336e98f07dee7f2129d08fbacd65e69ecc257b243974242ecf2d920fb8fe9a80809343cd6d60d931ef9c5d3a2884e387878d078ab919178d51131e6d6844435c7fe3c0dc857ec58c60c12b1ae9efc3ac6e9ef57124d80d95008883c510c8f810aae78448f867ba98a1d83702acc881d6f689b9d437cc3d440b9949594989451da300a723a2603b935bf220bef78608e9f3412665e1410880711a9c16154a88fd600bab0743be0803e788cc61358d46d5811addb3d24d22c9dec972595a77a9719f053c3dc3a2e7932c054bc20e7578c3fde11e674b1340d8374a9260f0028d8b0a00c55c25a1bdaf60bf9b450a28e88cb25528b3816ee9f3310a2b08c9043b8f3b575854dcb85045bce11ccd1eeb6cd5982b438994ca2603611ef4e80fa6ee781fce1d10d87782d36e0e66c56f9ae9af2ab114efa280be27d15e7ebfbef1e217df955cb2f4aa8d008f187f193afc759b9c560c9b62af87138ee3d4fb2e64f2229b48972d5de4d24caf84178273cdf344531c6edea5c839237d2ddee61a9692af2d98e2a4cf2c350d6b0335d36c56741a759d7f6c4f685b114f85e659f7e3d042ce6da442c1ebea218d10f94aeaaf86923dfbe319a579276de59ac839f93b176ab78ea4b039a997459d1ba65b0cc7803e462ed255dd15b580a98609de756ca2580b477fc616f49b0773a156419639ade6b0d9dff28058971557e5113e04ff5060eaf3ea35d67d1894c228d8cec9b2b6a0f7020eb60941499327d10267bfd2eef0283e6f753b23fb6e612b3184413842f9da37ec3ffb32ca16e260421f5a1fe19242d7e2574c98147e46c8fd1fa08f3c8a712ac5c0d13e88bc7fa78719b7b37e3449bd0fec8b5070583a029175fcaeb38df4a79aa6468a560d6c8da7583f34d2f9280039ff6936ba104dd446167b19aba09b458859f3a866ed741157bb82662d30436de59b0892c736deb46d725559c5ce6d1c55835e1e3101a9d094c57da3a1296172bbf3b429b874771183c1169e591cf6740fcd92605778330e338c21a9e64cd3f4be8c6727e63cad292711743c5390a8cae538112396fd6da950e300b0135db6d655717e8c79771120f5053953eafda0539eea7f0f6590d7f2521d20d63f7e1632f31c4809502de20fceda0939bfb00f5ee14e46e23caf65bfd480ab9995aedd7294d8179d089e7dd082b03ed55a4468c39e3c92ee31175fe238a52d48ddbafae9bbc1af129748066177b2c1048b70b7ffd108955721d4a00e0c2ccf28e7e614e5c1b8f0ab9ddec5dbd3f7588d69aaea9e0dd3561ba646aa782f73e665500d24ea236fd58a5400a8a31fccc3eded5314be36316ba4455d96d7c59e2fc822d89a450f1eea48ed19bb913f95185f2e099405de360129c61ba7fcc7306c18c8df6d452934b6b390de46e1c5bc5006109f70ba9f0d5c49235df45ecbeb132e8cfb71fb5937081e91eb662b68d317d754d14a30691998e4afcbbfb556ba746c60ab3925fd676f9e0e0184c32bc1946becab175f63ecec053bb105c5e1ea41bf1e6baa3bdaaba2e8b5c67b4b801c2b5ac5f75a019214e19a1900276e75929c69ffcf1bf26552ee6b73e983d1517409c6eef2ecf4246fd07918a288c5eab1bd684cd20671fe6d0c0ca1b2073add20d819c0a8cb14ebfede5015f75369ba78759716f120b0d0386c9c775144dcb2d3943c6462aa52c7e671fc022b7b4ffe8a421ed73cb1e5aa8eb85605ad46d035978b0890761318db462bb0b5d054819ffa728406fa6acf128466e9dbaf12423ce67a4c0d4ba092299eab1482c1d7883b66ab1c7518fa39756f5fa47c570c6d8d589932edc174a83867c232c42d7998c46ee0444eec7f1ae589bfc559aa997967504c34f2d6c49d4251ed3bbe71b17c0bfc86e86c41af43728fb6c4c6fd5f876a4a25348010d25b0a52f5394b5af133131b9824081072dd00a373e74d6c33fb0af20cc810fad163f55637da49e0bbc1d21a5681641205a44971ae3a792faeb75226de0b5136a8710815d3b99e860935af65c64329a66d7835343170397489c7f34c0251d54b948401e6a8fc2853428379d9a88ae9275d255cbe3d2612ba0f50207f5831dff2a66bd108b75e1f03b4645626d82b2b588653060476b3cb1db336f49027bb08d02a9bde7cea17495d4a32c34d7286ec6f248a7a515a8bd49814affadec423302ff16e1a144a5a23d0f23afcbe5802e55f6a5895e0ddbe7a5d7303d981f08e489761ab8a9c86ea684143b44a344bf358d7b0eedf69fe1f15e404bf151062e98af6746d9ce9f53ae30bf378c8e2b4a0a0e3c18bd1b396e28d4ca1dbf25946703f52a1e1266d396c61691562a1f223441df111893bd2254dad3f351a23a1593b1bcc0ec635af7a8915f13d825b76fe943b7d0c065ca7a6c6978706dbc002e2b043980907aff6829c51327274aa32eb68e874b622f01d2cbbc2b2488fb5d746bab6b7fc7707cefad6cfee4ea112862cf5c51ba8290b0248427db8dcfbf96e828115711799d9ffa888f8aa23860674d9bb47333ec1736d3603ffc908e8d114e54f1afc5a2f4e8bda15b9100d108abcdfa936fe80f6cd72d3d7bf690c2e96b7e9569cde41de7fcf6d92ed9dc90af6533f8e76627937cc7d87369add687fcfe087dfe6985d76ac4aa38cc4f5bbdeb06e2022be7fc749bf38aec3d78aeade1be290c67d12e89ac69930779df17dccd0d8862c276bb7c7ad8d09d93bd4b1c967f5eeef0c278e885c0c6c21dca5e8847225500aa3a6f17e3558b5f271ead648b25830eeb7d17bcf76802fcdf94715642180f35b6e6b6ec1044c9c4ce156ffd609e983b62637a00a1278bb0f68e9dffe95de8d54577f00c8a844078075ed95a8a478efc078c67b5239a7e900c6f2eb03b4e88a97674abb87a2d2c510c9d4178edb59906c26fb85dcf318d6e3c5b7cf035051d76e14c40b6a96c55e1f1b39d8f74fce8327222a7fdb0c6f656da55b23d2abeae43a911efd282782f26c704aae842efbc44395b19d654a6c481689baad6c160ed44af02e23a6f8c219ad91597190a03ff3ff7e83d6efb6736007f272d69c01db2a8a62d02ffa56ccdc0e1495ae923ba5d0accb7a16d99a591501ccf3909b3542fc0a366dcb1588a826156601a8ec3472a5a625e43429c6abc01790d879a0349c8df92489f245feade597f64e547ae72ba6a8fce8b482f975091ce22f788e30482a734d66ced887d007b891107c30f93b740580271c67586cbad54c19c625642ad64a26c13b90b85211d0cb8f5ba49a54610f6b2e679a333cfd27e9f7bf5bcc5ab8a333d266eda183919291077e70b668fa313eae6d8e69e960ac1f5612844437a7878419eae9744b74876749400f7c42a3477cc6cd8178c59f2fa0ff94b804c7a0d1095bc830f0e2a46e9391c9ac6804fae18ce182b580695b800f4d8ab6b215e2fff37513f311327ed64adb4e40c3f42c919ea7942be8e62a5d5ce9f596ccb1e25ecc6fa1e29e26e3f33d6a9706bd71759d6a61ab8533c5101dd6a24692a04a4a48d1053e5c7650fdb1e6fff88c7133d6d6fb08a27648d07bc33a07cccf86b54d42cf1dabbccfcd0a9901a256e19e4004ea863b37321c953a639b3c71d1086f7706eaabe2603fa60a4d5a4c84bcc42b2178643339fb85a05e5bafcfee85f901156f60ca470ac1ee0844e2c8b89c2dd89a2cdd40d7229583ad2a4a9026a6dc5f76567bd0a4ad6feb3044735094fd2a21cacd33a13d3d1c073365b6188d72c0bd24762951483453be47eb13c8754a9729a8d938b02ab4df339081d126f459322e639a5e1b571e1983ae07a9f6a5875d10eacf08f6b9677db59d1186cf0b7a09a96076f0c2596bfd903d910bae7ad4e486106fdd02d0ac5d906125b564865db8e569e7d811f4dd3f60c9060cfb5e82d1357f7e7b46d53333ad818f46d2a49ee938d8da1a71850a6a69af957abad4a2249a3786bb30937acd203353c25bfe559f4aa9bf4e606e8ddf0eefddb4a93c4f58c8dfbc189a29351e81a438e421f9d546a5e1f19c13c047f86a1e4f89d3b0cce52e39f26d031f8f1ce9eb3e79e6d299f6b913e3c7ca528bb50b7637c5e55b92a5f93e0942bf2ab21bfd1d4e3f3a7a70b6733511a755c5420ef363b6e6c204ec5f8df07b6a25fc0177b1fcae0294f3e7b177497deed16a47a4e4e8d35e81f49c1b3dcbc96fb9343773cfa55c4ce36a1cdc1932d963f9315cc8f1fdeb6dc33cec6b7f2033bc8a7e986976c5deaa74bd67fc4a94fc3dc3e5d407004af251c4edda721009cd3dd4ec45874619aed97fe368e8186891d9c4d0243dcf22ab5aed38caf95f8d4473dfb1339744874bded63f18bb150c8ea41ec72dfdbeffd8c92bb0b209306ecd75c485b027c204e5cea79c73d0a3ce34b32b52fbce81772758f4389bfcd2c02b2f4c190bdc85fb0157646e164dfd809d7362e9db636b4e161dda115e181bfe9651db5d0137cba189caeb94daafceb78184b0dde4b639d4e88765a7c97b2e115f4f13838c02f40a9a63c906c42acf26a028fc72afb1803894ba0131f2ea6ee9b57979aaea5a0c899cc50e958ac60131b615716df3d82b12012137d8b8953d92a8a15d11335294e8ed5784daae53684c821d547e10422a63bd3d93fcdccb285f8ef70521a7e3a3ef732236e0cdbb5f5413aebf289c804c389392d565fd084b11eec65cdc3f3b816c81a99dae16e66c0fa16c984f13ef4ba93e1515a7570f110e2e73fe234f7894fb401750227dac8dc84e8f7d66a8d2d0ca64242dc2717c5bf57c9ef27bb2623b6212212ff6a3b531a14136a07dc9b5d80286d0f7d7fe1873a7052e3b9cfa66e7ce1cade84ba82875088ea6bb0d7e4f8b7a85cc0c7100a308d878b66b614e0cb15d4b9d83e8c81ce76c7ce46c639e863b1a97fdbc3e0205a5b840281d9ef02c39b934801cad1e5ead4abc8cbeb745b8e1b55a34e0e19a6fc4d951f28d89737c41ede58ff5ad923df7ed1a7cc8273b7a1ea57594a57d5f5e7170438431be4f24a16b0e0230dc3e26e106d6e803585cfa71e8825e318dfc7f0006bc2d905170052dfb1a272ff2e9d07735f13ea6f5ca8aa28dca210a951ebdccd151a2e2d5839291d7f81ab0d8d9b236acee95493993c9246d569734201a01c150107be23b673a4a4abbccf7d91a47416a22f940f7f8bef977343781bf70b3bbb6b0aa40a4945fbb03f75ca2e687c01633c9bf3c198f801174bac6a57cc6d3aa72328a560dd19ff2fa5c5c72b95e6886618edf0433bd14db6fb7e286d83bfb5991be14679f491976b603530301df4e874cf9d51bad28c29d6d14b4d22421ef02a533780d5a06dab4560741a54d6b6e7fa92713a50c4d8ba4c1796484286a6875da616b737415b62acbc7f0d01fe13affdc01b6e014da441caedbfd46e95a808025b2c9f0fc4773ef96c13e49331c327092d64765910824d512ff32b8945d502067b77b3a89ae11f0683c113bae4ac1afabf451593e01e740a8ece670796ecc8a7bbbfa818d3ed6a6202196343dcf578e5ace584383534649b6e33bf5c9ec4280e203afa03ba1817186b1463e2ac46cad8fe4631db7a125419a1d22faddc8c996c3f3decaff493e8bd848dae3d5983e0e135c4c90c889e2bbb36acf4caceff3b780948e9e9701dcca7e0c60b00be2a0cb070906d800a52bc723326797a11975040541d1b07b8c0c9b4789b4e909d104c1bdbdf13554d9e0f3f379cc30b8c276d21d82a5da3aeefb67dbe82a5db8763b1ec7e8a8b1596c79c5ac13af6b4d6811f86153e570875d459e6a65fde3e874a4aabba8b0bb416de3bd3d47288a41ecc641527c215e7776fcbc5606d68cd21b20a2cf097e377f74e6b1611a79310f39ccb24fa7b9c7ed2ccda2bc34128499c320b5abfa337bd054d1d06daa9945dbbe7ff25b5e66848b5c7cd22c2e62b96b1a7207dda2956aab61f9f17608db0a67ad4a2e98f80e833effc0cf3696ea1455d84d6c899a59a4a07828b574d827e9fa05116c9ccc245d46200b9844bbd48652ace470c4e3b55b047ffe3d8cbe5d3f1dfc9c6705421f17b20fbf6cd21dbe00dc2a8e5f6c243e22ebbb4f1635a7155986d8de6edf95dc93a9cca0c02fa36f6d2bc23fe16256a7ec589e09e7a1bee580f11ebfc52d84bc6b674feacb5b5434448f6c6c0b561f06843e0e92bd0f6bfa2aba152c63db7e8178a6c194c99e442e41288f413c5f07dbfe1e20e9f0a0a194e24361b0d329df197703663eabc1ba78d6797e35d9d8576dbde6c530aa52c164df3615a54f933bb67c99b81cd46a1d70273fac1a4e175d64ee31889564d61ab78a42896f074eba265a20bd5c37cf1ffcdccdb4d5a295b4581e4fe7e2e4915a3a1ed27cb1dec58d7de2c1fc4d3166634920b7696580375bd60ecfbcd1a30cc4341d280db473ad43363cb0286881baa74c220805fafcfaaaebec19d4a107eef7b30ef3c668ae3890886d2cfb2894bf6977cc16357ac7e505350b224d812ae61019cb2daad03909c908e2195d7f4b5931a820d203737fb4641913c56a2ee8995b3b458f24c4c912d2ee2eddbf5fdc407444d94e7a521e600b51c27ddbdc3e8882a00f6bd9ff7227971baa3b97cf314ea8e8a897336ca41d0209a3e8fd1ab4cea2036a1305433d145b24dc313703ba304132e9a943b43fd115917e6ed4c4720f1328169596aa2b8f082cc9533171556aa77bd41078fc33914f06c4a07b0a8c6cb126990275c14f7959122bea345e2214cc1c5e4c8068080408a3f21cd04b82bae1d3a579eb815c0615057fad550f8c53c0077287669ec8c452ace6b571b797c6df602344f63d74f9f1c788808a800ed154c8cf5b0d205137b8226604958ac750f6691bd3cc67b59574cc402a5bfbdf47e70d0be8611bea1e1bdb42d082085565eb179911c014425812720fed8be78db602e768d69fd45110c96d153c1ffa9309847b531287b006e4caf057db74e82d8499577d5c68264d31fecb08adc5e638e47e3e43a22fb66f81292df30bd0fecd87fb6bf5000f1ab86c5e7fbe5763697d7fd4868d8dd16fff2c52fc434b71ec46e14c9720e1d5654840badd748394a78fa88d0f188647d906e327d742de6b05bf2a21cd4ec5a9841391b53c6669b8c7316649fdb2fc67c655a4345b846c6aee6f4df25ecc7ed8937f32b116c9e0ad5edd9da8f4e0fe5442080317d0013170a63860e96cf550a51d1c28e86a7dbe3f3b1e3fc4cdcd6336bada9168777f11e0dc12a8c487c1f627f92dfde290495e3961b0f6f9c9159149b921d505992fdfd7e69df2956e692e2db8e7d8d48df91199a9cce012922fca9cf7c9ef42bdb13a533f3052ef333a21ad4bfc74535e2898d319378647ea8783d46a3a18c3c8b618cd49ba826b8a4bf3e1e0344b9633fdb5d7d3901ce1c145b157e3a0081a83ef198d327cd782aacb4b76bf17f28eeb3368994de4bb8ef3f22b03806e7c0ec49167a3404d19c71cb7370b9dc7663f5f5a35927dd73ef059c07d5b0e668a66dd34134a2350f0ea35c9a6d1233d32534667021a52c6458df58fd1efe91d8ab9e65b1852563b5473a004c9559105c8c24a70b97da2d2599ffcec76a2e24f0b883d1553c7ca5101f51c55daa5a9d82c3efa29918ebbc7d3c8a0de6297bf2a1199824fcfb6bc129ca0838aac0d2f0c38c4cff886c5e29a97f99910d83b3c282412117840216bed7a16c341cd4e41f0f9ed61e5fc82864db0632144515519e5a636eebd61c17b607fb35f25391804aa0cb03fac81383eb106bc97700a5c5a6eb3244575be23e1cf5631b5a00c16dfcfbc075064dab612b4ebc3179e14cefb8ef0704189952439d4471fd076504a494afdbfb3659704f06e68606c6eac2aaacd74ff1da448ebea087c463e96c9a206922822f73a289a459ff8e1f4a0cc43967d385b6f89ca709d6e34949eaf31632ba5b13571586815fc0feaf184cb298f5cd5cfdd6a6d9575d8eb0c4192a2494de51efe759fef1afd220098555f5d4137bb33b575ac014f163bc983c3582716c86fbb3a81dcf2c65b468534b6f4fefcd279cb5a6fa550dc33aef0ad83484c6473d2e15cb07fa19ba2a849496e1cbab6995088c93da646852d838de24b92748f60f5c483426b15f6a3a384fc448f28f9cf0cb6fc6d08d9fc2f4b31ca350c74bdd4d6b7fcd8abcaabc92071239a626980968f258711c0af59582a62539ec58af230f53a397b7b66e2b8b09f46e23dff12831c3b60b449eb537fef47b43576ca227c5d711de65a70be389a0e80395d6ad0f2ebb124e60dfac873888329a52fecd1bebd9727e5cdf3b91292daadf625a1f34af7977926b2649e8ab999fa9ec31157bab4201c2035a7be1e0bbbbbc54d96d2fe70ed88c6d4d056c3c24cffa8773f1b4e2be8ccda557c620c7041758776e1ec76b46d618bf7de5b7b205d0e7d8870703b406f0bdeb18421814b336215dbbaeb6307ee15230651cca71620ef8c00681f277ddf5ba1771e35c12721139f8566c012a3338c609c580cdad27b12f8073fc164e67e0edf835e5fa02c23a79052af06debc2ea9826497f3aaa0edc4f822b476a5c8ccdbf84aa4b127421e03a28e87e44262f4b43e86ad9794d79fae95ed934edb8a0bc68f4e629c0333758b4e59dcdc7255e899c637cbf7f2cb258769f1a02201f25b210b860ffaedeabaf18a6cb800efab2192961cce5ab7127d91152b2d716e6fb397464f83e4c0cb5ac4f2329fb0c0f9d089f365408943ef5bae868c9088a7e6f63332e68766cf8b22015cbf0150eb2f7a5d89bd7fe5159f7389a52e761fd2fa20365bac00986b9ef8c8b0c956a696cf8049826e784cb50b2c6d88af599f2847be96da75fee496ca9811366e5c7725621acbb47dd67c4edad8cb438a22e7fa74db5a7f6a097caa8bb2c2022dd0c679fc3df0e065a667a062a5a435073aac904f373b4da5d47471569c94d9f49a1799db7a8d8b3588bd01dbadc8793926ed2553df045883a9aac0361732eb3dfb7c927dc5a0b57b04c3ed728e0799f0dffcddc586016ea126f109ac70d116e97fa83b216e697fba53a0f5846f94d58698492573f5a04a3298ae7f53e89fbfdd23614fa21ab1411911baecdd67246cfbbed58b4ace4a1f6261a96082fc518806e4d6c4bfef91db4cee2d7b64b5f2d9c85869d6084bce5f1067ac8de22b8f004c34ae56d1867fbd62c2e5ab1725c7363a637be854bc8457049463cd51cf40aaf83b2ad089db0cd6f736de9ab4ad2f3f16af5b4b599f26d03c481c23ab537715fd38ef1f9ba907529416da6d003c992cc4a41862966d0c76a27f3b44f5090b009cb826a9dfe904f2c88cf0a851f4804ebb42059e5b13d08e7f4e7b74c4487d7e21aa95b00d3d368b81d6699215b687c52f8bf7e809abbbad1c68e235bbb6806e4dbec1012a5fe090fa4cf1279e65f9e91c215d32c7baaaeb9627ea9eceb65d932585b1676578ef602489ff8e0c4ddfc5dfb75d6b0399ba57ed9830790b15e0ff999b256e9120b0e8efdc9add1401347eab2b2be0b895e63ab7717fee81dfaa80b3d72c8adb737e35940b71fe2fe9a4ebba0a9beed6b20e20ef6c4dd973d8aedfa00767dd52e0dd20c2b2142d80cbeeb1e1ba5092a90f5ef432fbf51625b87709f1c9d0c334dd4473865a4ec9707ce0898074b386218a5fe9730152e92a9414acee86c329004d935ba8d6fcd3bca23c40c1a3eaba31e2fb16fbfbdaddf53dcebea82c386d93873fb1abc6ee5afbed86a947ad822335f7f5398ac60269eb966be6b8cc51804df4888df6c564a04ebd2b6d082c2cb00a3bdc245f694f90e9286baf291642841dd99b00500ba5dd59262cfb9b2a8a26a6476b1190d495f005b6137fff611f2696472e0d4f4c15076b0a33888230618a10467713830aafef23c0f1cdbce8762ede600ac89aeb1b2f1cd517fb4dba185933d44bd7588ec13aba700a72bdfe77564485f26ca671c3adfdd657052c4b077598dbb8666a8230e54f78d6bb02505058b2e860b576039f7ca39cfa9e8a1bac6fc4976b549891919f79e13276206eb48f843d3ec6419931a5a695164f9836ed94b0909daf99af9b85f0bc5ef0c43c5bba71850116c4f9cb7e91904b0888859206be0aae1ed2b40d6f97a0586ac7ba73a91ad959168e25acf7569a72c0a2baafd7c3a0a8596955a5dc2b38b0f2223111e41b3e481e3595323d7bdf1e2c683d469977ad7acd11323c687a678f1ae7bf634ab40ea5af25ea7c0d2c420382f61ba6651b901557a2c48b345cbe04525c509cdbe1275ac3dfe0fa4db43b352c651df511e992482ab4d2e395b5606b795e5126e22763e9199b82cf9943018bd766d80e41977e1c297cddbf5255bec7ab9086ec6234d40a8b1eaf313ae1b789e189db5638e9b46cb640a19e2c70649bd97c20b7e634c92bcac2fd9899c14bd0b4cf94deadba6cf3a08a00f0be7dbdccf4226f8e858677a056a39ca94f99eaf0162e7d5bb8638afaf15aaa7a4652603446be8f5c825843c98d9fa6ce34aa87dc99c2726f15517a6665abbc8dfe62cee69e5c04596d25a8495ca45c07a5dd9d01490fc6dd1736e98046ec4ebc8119c00c4ec3675d42baa964133fb9d6a31eb65fae2fe9a877c742508b4b3b1fe2a0a6c78cef398de62a358e7c1d1f03c036e20dd013fc76dae1942277f4da64adc2bef7985233e62512d17f4e12115c442dd8cf1d031ec5d02a30a8824047ebc0444c85f82c8fe21f95a24079447a90175a546e2608f8a71aec4345cb104e87ec9a3fe9c05dbe8abeccc16555ac315d402513a955e424f4fc70bf5e9a61e21ef31ec36c7597e25ac86e7878c540b451b2ea007b4c85d7d8c6f0cb6cfc1912ac4e0fa6428f9916dc49e478852b9b091df6f30fa51cee91ad8a55e2d8e6e2a7ead4d39b4ccbe2b766bc17edee0db0b031fc7e0c840f7b7dcb12d495c92e04b70c01e11864c3ea17724d4e3c788f6d2648345e7762836b9008fa11cc677ffffb68229c897feb5d9b70ba98b87fd3d3f831b20b04e21bc96199bde3592eed5b1940eb084df875cb832828784e26774f490a60f6bc2f46fa0efcd0bca7520edbb0619cff11c96b2bfcf399eb0b683a80de1ecbc5c7e4d20cfebe816c7558619b077d6aabeb140deb86cfff5430e50be04b239ae6111a07f1c412b2bd479ffceac581c04f70fed843dd1b8ebc9ced4b58ac9e0783156fe9f5d28cb4346669fc9c5a48281c8993399d6acb7c9a2cb3e0c2a3a1eedd402639f19cd7613f5fdb2059d8c1f624bf73e6423fe29bff92d76c8a6050e140f265c08ad062fd49205181c82e75d42b2c4ac87579700dcde0e409b4752db674908adee3bf06bcc701dc381dfce6e06b4f2b3924e6bcc21fd978fc2f62294ea35d6227f24e56bdc8cda33e9e55be19e77d1d9a1628ca0dbbadde42d1a594d1b6047e83b05b2c2c9a4868ff3049317c60342fcae51014e346604336cd7b74c0f01769791b9f635dc709655637ab40aa4b0bb6b1b951cc31d762c7279f89a41d6d46c00d274145f9a16541c6dbd751ac32e189bb6b9609c40bf2031c78d20ac8e2f07ad8319e75f43d94ddc41b3b4a6ac7895f0318f824441c826edd383cb0a325bb552563326ff07f7bfc47fe3144b3185aaffc077471a42dd71eac83f2adbcb4df423083c9096530ccd8cd14b381496795a6bfe6a572efff8d0784a48d9487a348bf99833bc141605e4d5efbd216d20214796eb4f24108fd69c7efeeecedc38894af1d944e90661bdc9cff6b60ed5c6ea7d546616919522ec33454ea5f58dcb85fe65ab99ac48090deac636c732777e5f0491ab4f0f6ae32a148f20e63ef6c74131d992e0893e37ef1cadfd24a3a46701983437db63d70af361cba4b065a8a36bed4836fc4437d433916153e23d308c716ff7e454108b86deb52c7599df52c7663200f28b9be1352b8c40481f5ad3eecadfa37ec98cc33d7ddcfaa8bedc115837da88ebf9cd46e4cff4d84af3862881a4dc217d8e094c9abd84de9e315cbd74a853193a059ecfb9f072030d11ab8b65fad6a36b2f64551a85908320308ab900b70fc244b2d1c368689310ef720aa6b6bfcf9a8b7cd1988ad9992db8ad04f6c952b8d920ec2f9f4e8a0c795ac944aade932df4a980afd16583651eda39a8c2920980fda7a156dd524a5cb0d92f6f9d7c8015c6e659ea6562d538ef77f9ea317b9852a43934145d8e9a54dba4852d937961a72b9794e415c84481dba31caecd67ce0edf85614e1fe1f161a70617868bb6622bb58268c7b09759c5b756a32b8f907e02cc6a601fc2bf7bf250a704dfe89653e79021ce42190811a358312eb972bf9db38d6d951690bda5200ffdc3afeab6b8909a611d87691cdcb4fb2368b05f3357329df3a9e277908e3c1829f2b7557c80b35f7e5936f451865e73e5af554a82bef2ebb9128a52b48a1158ae334bc8d81ff592a2cbf3f51cb45ab886bc6af5caa28f54358c721b77f3c6963707e3aebb6f278f63e2bcba8434203bf1bafa0a529c7c26a8b167853f3453057229683f63f0e1a372987e6793916a27c1d2d333af2c99d563331769e7a8fe0ebee3a9fd2069589b411cf84f810ae7ae26811c8a5304d06bf64ebb78b29d5024f3604a935093143601bd8106e8e0d88c4b9f378e85f86ca5861d5800eb9070674488c114ae3aaab13eb1609f065eae6dbbc2a42f89d150403adf1700c215c6306b46fe7494fe71e6505f6d67d8487672f37157af50d8780dfec011e1c06c440b2314a4eb13932221b9ff1be94076e9d0ccdd46497ab343055531d3595c2d099347e7945019565d88bf8d05455641610043868e14e117cfbd6e87dd2523f3c235c115716df86fbb0caa07b182db9cf90631d249b04d965108fbb796ca75a95b2d8f823a3872e91512ab8f16b0dbba652f3e334788cba53556c4cb3a3beb4a9729caa78dd32203b16dc46a099e346eccd6622e5fbf039eb3cf8c9eae7d10b8017f0351f9cdd556edddc260ea20203e94a75aed6919f8fcb2a07fc1f5af57e638b56ba78001dc07179a880fadb2750ed4fee4c4e8676874f014c7c0d39359349b26546a0774d0e4fab094932b289bc674e02883115a924a4904ba0e75dbfa94ac8e8892f8a71b43709b1ab72bf701aeacfc60e47a3f9c94eb920a093aa9459709be8655b9f81ced3497236c716a80c5e55a40aa822680c9cae3274739e35bf41b0e6e396b427c79fc16d175568870f89e877551f0bc6e3ff53ae4379a1cb28fa4cbc42a1f85e575e47aa2e6faa62c27e6c3b743d2507c8183881d616636903b9de36f42edec90433400ab6db9d7b133c578932ffa1d29e38f81050d38e95e9678e5e71beef5e2b3384e5f7abc94faf80a183a9413a9aae514adc622492985b6d8586caed9acee820f367704613fa501c6b2029080f143d88de9d6f44084d10657bb71b3565d0d55e8a5ee3bc68cf86cadc38e6af914f3e9d6e60dd68850bc3170d4bc2daf71be01a81ab9da51bdfaf632c296044c317507f12e9741fa175ef377383ac57bb1218df54aa7a3bd117aae83f11e8c82faf6f2879496361a8a803bb74e10b968000dbc064175142a2f8caa2f9cc2b6e58834566379734b1d6dd6e85769b27da0fb890296d30a67a56ebe8ad353e679e299040433a789046253c08f3830168270ce58d0900b1c25b6d1fa71837baf4375416678729b4892fc600ff9c60146e8f82edd9dfd9c7fb3859bb69e735c5dce07e6566afc52da3f6002ac0700364aff3b2e6f2de9dc734c8ebe88067d24d683c6ebc1178308b15a94a9686f151656991b7fa997125d72f2e6023c14a9c270ecd426b6c0bfa31b7a24d0b2c10959298991ff5e18d252e7114c12d2d4ae26b9d05d99aec48cb1d2d64457142948cf629662118d46a8ac420d8cf57c61ec348f23c448b51880c551978db8d1e07d22b030325ea6de63af0d3a04031b25ff54174ecd3dc6bebc2a9fd4c0d5c4bbcf4143006838ebd3dbc507ea4c578686402b4ffc147c67d9b2eeb498b92247360be03aa5261eaeb2aef7e926c33e3173637e5a6c4a1c4d5fe979fb989bb289b09837a75f7466a5fc0c4e68bf9278ce3dcbf7a14b954202313deb66c635da691f9396f1f9b940c569bc43478d4f94f2110c39b7f50e58b8812214e83cb15f8580b4d669d5dbc6aaefeea6f661446de2348a67b0a915caa7a12ed5c52e52c98f5dfe751d5116c0b0cff64a79a8621343e69de7d6c37e1d1afdb082cac3fe6f1b99fe351003959922bb76825a5bb5b0731d60b6a34ed2417607fbbd0566594adeb009a16a21b70b430af6adb8c25886de478aadb6e81d336612cab9da9020fcd6385202413023fcd10055ee0d9c96d8804e5629c54aa3c5f09d7839d6d8b76af83e9af8480d9644176b87d139f58667d55bc1d8ca583eeb41d96208047f3c39ab92a302141c23e715756dcc1aca1d297da58d4d1b307accacd8f62b281e9056a247e5f5bd8a1ca8a691e3ab6b5761a5f8721e2f77aa7c7be4e8c6edbab32cee3db8d9f95f13c4d447eb8c755ff9bcf19d06245f28a2ca88f66d8c0fe43315225c13b9bc2c9f48c35fcda21093470a332391ffae670ed77d5f073e5ee925c4e1ce5c1330146b4de17dba3fc018d00927ec4cd4375abdfbcd70e48feb0ad9739d927bba2fee89e184c42e398d74151328d0bc0c9f7a56bcef6a581d4b1d351ec734e7eb0cfc041c9eaa9525286b179e9e7eb17906eb7945c4f723811561fe901a673a3390f44b6336c4c304712000fbe02bbeffae2694875f5f4e4bd8bcc4aded7fb86b32ccd979fd69b3430c3015dcda89dc8ceabed4e422327f5bc4881003524bc88471ab969bceff326bac9659330f89e178b166b2c213d8189e47c6642f121a4b6db6b272d48597fedc6c69c7b7c3d1fb848eead96a5f49bbec4f53773e0cdee671b6c1bccbf811d0a681213f4cb86b895d243b6cec31d31e0f24e460a4eb301ff4c7c8fbb7c271dee06c027157844c161342982df443bdca580a141f59093aba8e4f2095924d95487e5381fe4b708ba21e108dffafd5052ef2fe9e30f168c2487bbca70b5f5d50a587d6d176550580a895904e2683fc79ef5c3fa90bfb9f739172b4915d8111de10143dc36971475c98bc2d3867b3f2fbf5ef3a8828be99db8e72ab3bb13f0a8c280049ed2ed507fd91569c9ead2bd2805a204dc2db82b9c354a5d81d8ba30e778614c942b3d77d80ae291160c5f727666c6f382d56d30f7588598e92225bb7f9fe31ccfdcc021815282f01589c026af629921e5ad8a90e73eb036bae6d94cac7abe377c7e12c10d215eeb0897db836c7faa81b9dda48963ae62bc9204d9783695d242ea0242a75a1304db478d18c108efbeaf661f9778d74839d47f033c8658710439dbe491d336c6aae7c6edd6718db69a715f5d0088c8330a226b578600c9db42f8150f1a05873d77e9f51fa42f45b157071e1e03fd1f6e7301d0e49cd8680c33c349cd3d4dc18328f701dcfc9ceb75f83327f3b6642d2d5fcf69eb91e0345621ea108c58e122638a3beb823782c39f8c143b7cf240382f3d898663a8de8046a9cbcd218698b9dc4e79460aa45781b43d73750b7aa241022dfb25a38d58015a3bae997a0556bf952a1803db1befda3bb28b5b6fb1f04dfcd5a3df774b77e6185cfed6b2cbfe3cfe340df208f229b392ad41e7cc80d4787fdeefe222952d28e87aba7b93155d78882e6a2363b671f269aea81d6c740d80b75eb91eb23e78d4608664f78694cfaa05eca7fc2a1fa41d189842171e1c3435b83642781d568317168a26cf77968269e4230b9d1831012bb243f1e1104161838a25bce7413803b6eacce86a319545f8065a55c595fa1f2373897ad61dabe98f2f659b5b25733b25be5d989de194e2040351daf7aa460b57f47fa6128c3a1eceb5b81d7ce578d4a84cc7e94b882ce1633d5ff975d8f33116a9dcbd430bfda30688893f7394eeb848ef7f47b9a534e536884e5337e5c2e93eac345164ff0123dc0869545abc5071f38eccc3251afec36ea83b6b024281ee727e94811fcd3de94a8022051df2e127ea00f6c27b27092347447dc1df0d7d2155193dc99a1d7f42f70e0f4ccd2e208253dc9c6e6e85787dc089c5c5077d91d09d5400199ecacece772340c8e1fef18177804d6f67afc68bea21f9eeb9726ecb0e4cc9ec890f9d3b1ec0c163f1f55edd253fa0dcdb583041bce567e65307739882f1ea566913c3fe9ca3404c778af302c95dd2d24651b4ae0887c3e249154b71b08cdd53d6f9e60aa039f8b0f71c6fde5320f2a188f2524e736e0f4c06971c70655e33c5f1eae808b723a5dd5326b978239c044338f71834c6a12aa05de9e6050c2717d50c0b8b49a12f83cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
