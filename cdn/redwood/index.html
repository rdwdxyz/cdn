<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89cb41bb601cbd637fe803e7acf5abf6bc6771415599b4ba864c27ad5db67a96dbe5fd53766e2a1ce3767b2834efb98d73c6d14d8c48f02757bf87ccea2edd3882e21cc8105c55240791aca8df859485808275b582baabea24c396b863ff7e046074cda447fdb2c80b24ad1fd0d07097f266333862211050462ed06c85f0e8c3c378dfa3ac686ea44a430e71fb384d3d9a327cb79afc5d17750687e32d80e9787eff93d6fa860037c22f0ab65b3ca3e8623991deebb5bf4f6825bab967a624edd1431a49a6caaada36e8f6c4c59ac266da3851349272a6ea3d6b22ac103143fc98f0308fdfb762c620f7442c9a894109a957e840f78dda9a19c79b1aec21f16383528c29698cb2a6282d1dea339567aea12995a1dd99a7943d26fe677761ba585c10a36bdc33fea9af9f364eee78323782f391a1fcf7973f892fd78694582077c70a395bcbdcec9711d53774841d3bd72be6063379e0862cf72be51f118dcae9e364e87208cc296910e97c0a280116930ce2e897901227e4916c0af6ec9d95a992b01b188c1ae272d4b63c5b3acd3a724601839395db0e964929b481f3294b38002b16bbe72966d38aa23ad8f329fec47a90f4c1095eaec31161a372adc2ebe764f58403bdd2dda3161ac68cdb5850d5fe0fba9c4b3499be2cbf8ec1678456186d0347eaa849296c83a04dedc86e3cd6f2b45c202d3ad02f37e60324d1678fbf89b916ce539bb5b5fa6ed4fc1cdc1e09e3583c728b12553a5fa9ced7a0fd69f2618c1015fa6b0033332cfa408b1697f3d35521a86d8432f30190563f719e6ab6c4156c9f87d0d0a2887fd6eeb40e0dd427e9143c982b5ac068a64736bb206ef21a5fc7fa4cc32a6a35d591c5f57744c0c6e713e49eeb790a3b98c4fe55f32887f85e5181ea8581bd264a2259b043d3687ab0fe49d2a4be7bc13dabbd4fffcfdecbfd34d05bcd4ffff0010ea6f02205b67ae3156c09295dbaeb3485a2ce150044f81126c1e253586a9363584caefeb044aa887f026d0f25deb5cf474897986d0ff5128b3c58575645dea75d6ace5679863fca8161afe49a90f96f6ff3d37375b948f4ee596ca1dbe595a7383ebeb6e45efe1c600c31088600b5638ff36783ffdeb28e0e122933705d0e1d54e6a9d7a336438fccec481129c609060d0ff90c812a220630dfac3974041d365bea3beef5cee525ad4ef41b52fb32025b4c12efcac8edefa1ba6cbc96d09d6bfa65524845f4faa515f15b0e8017eb2a1665511d88896e34add1dc46b8f174f019dc25fac3f044dfe7118014def2a20db9a387d0c15c176ca1816ab73db35ad9363b274d110e01d472b6f7f7d30af47d22ea4f9a4f8824434f68267d151c3618ca56203fae02c21e0ef7062e1d31e2b428eafbc37e373e3b40ec7b3931e127ec0b13414925f5fd9155fb965397930f2006141f55b185a821c02901c11e0fd5de0ed35ebce2880df51bf217e86f4b9d7c46d2d70401fbc9307cec927f624425af4579e77fe3949b16b544ca1f7a38b6c61cfe47d9f55e2f9c9ad4a50465a79b5747f9e715f0b2ab6976b88ab2d8b440ef08b8f58cf192e42fea7370599526f287cf99c820747c131eae34ddfeefe3ce56baa43e7062178ab7539d0c83ded69d22425b71d9490176026ee3e19c6c72199d1640c62d8c6c2146255bba34601c405ef63f20b243f9690e0b2d4d5538850115046993297588d2a87345d95a2d0e5d4a6cd465136b65f77afe83e61092b392c319c22a60b4764e304a3f9278dcacbc34ae1e83dd76e12945888ad82f579103a13f5e44cd4bbabc219ad5558d8de4f26a69f34c1560d483c7dc37d5068d30ed80513880ef0d0db81ee4f04cc7af15936dccf29225cfe1b1e8d21775756fd60eefa126c00f54ee6968690b9f9a3ad5e1316cc58504f815a42f266a18192fec450a1bb2fc3270811e96236149c7c8412bfd3bca3966e4585560c15cc9f4a0657a9a17fcc0f484c93749860fd6384e7d949d76cb5c5fd33ca163e0da8f64ea14cbbcb879f5d5446ece88c589aeac1fb1203d5949a4450d2b7f43ac73131c7035e42efe9716a54835a5ac63917980ca8ca9c1c7b5678fdfa551263ed105393f0417685468d2f9348f5ac58cd6d83c48eb23855e339f29ca15f4f14a988a7bb2269f5c9d0827962d96a86aa0ead382cd975b164bf9118422d8725c66abfd57191fbb1574b2f1ba69fede89166df6b0a99b85722e3da1d726d730d4e2779d285db420feb7cd540d55ea3c51dc0a6883acb0b3dd4bf35ca6e882113b7b635fb03568e45138d22c01836d386c3ee52a4fd7181be0437018803dab1bb2b4a1f147d3e7fc3fad8f66aabefb2e725ae537dd4d654e857fda79032daa4238fb486be3d7bc62a528e5bfcc40bd087b7934bed5849bb91c1fc29d563f17493dcd953553d94e134a309abd010dddc497d179f457d572153623b6175af1b6210b69b3b6ee89ffda518d45fb7ee5586d2d61947a3a746e80bc2b6fb2069657915e28b0f5d6e5b1a003d8c46426646e05021e06df7fb52e55ad47a1d621fae8ca41db814422821b7305680735633770c272d99c7cadced1fe61b8c6a641154173b07463d9298c21f1ea54476f3cdd103dae9900806b1d83c1f6c918ab717e61ee46476a06f7ce0e455cd58b6a528ae0f672848cf9fb824239da0a87dd6852487b0bc6cf98fbd20797a835791bc2e2435beff45ed1af645e19fb54091dc805a4a2c8561ae523be66e6e909a3b633974bbfe80b554cf85d07c3ca25c8dc906191deb153ca48fea2969e8c18c8ed91997c6126d1413c82254c3b23248569872279a9a942033578b040ec96b92e1975a85a69d929bfb74e575000b062f18163f0a76d8a2b6473cb6628227c4eedb8a3722d527fdb611937802d92f901c964c2f34bd626710f269efccdca16654661a05409dc950f01d95367da75361f561201ede52ff1437f36a9e7edab26f9bd135c8a61bdc09a61cbff7eeb28e34fa11735583557e0e11bbd30c84bc82861bb683c31d270502e2ccb6a1d08cab9905b6fe2fbdcd8aa4f092a6a155c0d2d9845631658e77f84d7c5780159f0e11280043391ac82321c39919a6a0261e2b8240e38ff0598ca3f298e9200768336a79ffefe4bd3e820e126a853ee65d94e97b663e860ea8ee70bdada05927ecbb755b247eb2ca3a86c0ce261be49d7de08ecd0fc7b94fba08c5657a78d7d1b9e99c7bdc2dcf5b056a5d84fa7502f0a5bde70d0656536ab3a2efea387c51b20f44167fb8173de9e90c994daa2bd73cc06885673e6f31bd96f689e08813bebcd438edeb1489718648ba62387429488c07581da916e1ee1d3a00e0549217ffbc2328dbd646ecff20263abcdaa64217889cf77bcf806be683fbba1d99bcd7925a4476b45fefd6d825431e6af5428ea17093bfcddbfe9e73074ca92d5c9540afedc1c423489b69fc86c82dc388edc98e375b395d14b92cc470bae042b4fa4e13923efa969a99d54e616a6f1699cddd58194b166e4b9582597620ac8cb6404d87fde7d48cd3fcebd4338d9e8c8a6d1b4054a8dd91b84ecddafdfab3c48bf3fd7119da9363ec65105c9bc6b6c7f67d2c832b52a5cd7f6dedff3dd776e4702fd4992b6b7dbd42f5f5e84f689ffa6d08f5fa3191cedcbd062d956074e53b3da4cde957f43a74a8761a71d3a456054528dc28d08f36ca801b934227c3a22c40eee66c894564babd0383475c1afe58a36cb2e87416b5bcc52d875c0bd8e9fa84e63f1935f63c9d7a0d31b4f524f50bcd9c9d581d3f177374c573f9c463048aadd44f4b65bfb67fc84faad9a01566f94e2a43d8adf5357d38d458f19a33087a46c159943d92d4d8b93a16e29e57dcfa0e4289c9424b337bd8aff9d5590a36b82202ab3d7b3d2e5801fe5288cba3ae19cf73694b07c5a24d8e3f6204f558033aed9932a00981a8a13bc573466d84f39842d64eb9a7e5237356a02158578668f23e0b79c622c5bd73d0c8497261495418c0ae4f6520e603d37bcf508d3f40b7565dd7061779d46599ca7de9cb81c46726e50c417850298d3778d248c4e2c32d98e953af9d78b42d4815bbc834fcfafa9f0b8c196dcb73e091dc8819b1638d73ad9292d4598bb1b8c64c1583d76cb1798dd20ae30b3e7bea30af46b3155f8847b59dc41ab7847ff8d2098e6256e653dec0f867395107481b05495ac8c46f9897506f37c0979a60bda32d46b9e6ac670215c15ab8ea686831bfa0e6a296d94e369112dcfbb649978f59ab27f15c9bad63affabe90b5fefea86b3a2b5af9456c2dde7eff782f97ed6470e6b332cff9140dff910d3fec233ccbe9fa43432fb2efb8157b171294c0abaaab965d57c1323bbf58d60f1a1e3820dba6cd248f386ca84164f6811dabefb96d1c727fe912203763e439afe2a402cc051b328781db1ff8fadae6856a001d0f1d16e545bef85808c8f4a31b6bf02ca3a6e5b5c32aa35bd77827c6ab5135c2cc81f5b5e408ffee7a10f244f6b420893b876ac44e53d462abcf8134227054430290ecf18fcb37730bb022de011f257854a757b29bcaea221dc32856f7974ecf9fa00830026d57658d4e9d0e14d8cf09187ce29469293ebe69062156f3a9f0c9e5610674a686239becbe34b9cded79f68a387822930e221a2cd0257a69e37db00fc513b9ce61224d3f63bf13255e34d154dd384eed1736154601009242b738ba5025e1de84bf225a7b0614f23af26876c54388eb7269bd239415ab24829e73182ba4d51f3e028dc296c1457b8a1262d3c66fb2f3b419c2457345ca02be7dc68278285e6de2fc6da027751d079c99ca74b8ecbb19838cd68233fc64e5db2ae6a992663604cf379d782397dd7ed474ca71a1c93524c9b31e3e4be6fc0c2696c368087c6be19765ba0d71e00318f21bda84ee96587c1eb810adc65703b4471074a1eb8c1b5af38995152ebf012e7b22a451051727fbc1f2660fcdbf6302a589dcd30e1f974425e41234b5c7b76d48f64e72f5668d566bee7511aafd5e071a4bdfa04b589ae93113b1d2d77749e12b2911b2a391d5a149115b04a71148cbb2becba3aafe11403603e51a988b5c1fb0fa2899101ed51392263cc08281bb63bb0be21dbea39f22a22a2a1d76a5797dd3b9d92b36f52f7c75ee3e5ce828d83909be4e926d4f6ad56ae1cfdee4f9204552af79bd5d1f7d64ad3ed84221b12ee24bd427d1c94dad339db6b111f4301b3f3d8006ad6654cba60c7fb2189562c14e4511c48d0c351903cf07708fd1167f2260071cff9505ab5a7efb8e188e5ae9d208160b50d1e02f1ed4b489038a04c92998000b56ba8afdb408efb8d786514cabd9d94f40cb960c31ce61b124a6f2e051e9c71417805881617830540476839cb405b98d48d6babcf99dca79cfa0455d82afd2dcf85e06f5065ff1aae9b52a6fd0d21b5addcdcfd08762c5998811e9fadcdde0c119e718a06d7c128b65efde04579230d2980da0f4e00d4251672ef1301f0927260f573c2b1fce4c7ccfb05b67062028d622f8c910cbcf0ca41aa714fc1b62b43bcf4e48931f3c97473a323a9eb6e2f892b22f10e9f5559eda0d1e578913720ef7233f4f2501b441a2d6acc75969c9b80ae93d378cc1379f10c3d4eed8c93fefee188b96aa4bf6e4347810f7c18f98b4f89d799bf4c6b5f1ad41dbe2bd0fbd0604740a26560098aa0a1aca248d0de9a50972f5c82d9aa1aedc10ffa877b76b4ab6c273f50792d21d946b1e3f37c97d8815eec71b5b942bb4da4164cf86805f30e06ca0ee50f04881c928e3a7045ccfbeee7a936068720cfc580a59c9efcd7b7f688967b392a4ef8fdd833cde320a0074d51570f438316f92fc0ca2824f7b679b51605d1595b6f73629eb1a7ef80592b7b33bcd3b63aa27cd9b58949f89949ef698e4960bf9b0fd5c7257e12def88f6a277796c55eb72abae8dd5489670d548d8ad7f587ad6cd912229ee5aa4c0fa262b09a23c7bc2bc65eb2330526c1288675d126cb4a690615b632bfe42f5f046d01019e78a8f11fd53aedb5d834a8505900067b7e15b16686d14bf3ebb87ab49e2b19a4c54e1316fb8e6065d25b23bdc2bcd244db6cfe00304ee09bf97179851b30b7bd3501df3bccaf1092e1cf7beb7b7867dfe6934b7b6ecbfe7ba0a59ff6fa8f6a78b4a1f3f601ccd937bbdea7f62267bac13839074bfd083c3c61ceae21bc79d69a430727f6fd1826f3e50201bac1acf932f8fa3064fa51069eb17330a3ee503d1461eb56ebc6839c803f448a168d4817a55f41b37e545240c28381c9086577e98c8aaa81d2093007877d180b7b5e78cb093c4f4c5e4bed6ee382c222266c8de066b129af443923708ec630f60d282e496424076e8eb5a56eff6052fc327022a0bf8e36819cbcd0d249163f18910f8940278feab2d8ab0b6046ed905d16c154f9711347d2873a42fe4badfe77ec454c83843ea5d01ec8d02a9a92fe7ac2615086a2129bacc23bd98942afb020a37b6f43c8f87f0aecf49a38669412e48db660191825d5d7dbdca72217d8392b2685a6763afa02b8d7b2aa98b50841752f13db4af4959bfe5c5261b595568d887509443afcfec51d5215469e72a4c363227fc2d1fe08bcaa2806a67d4fb1dc9a66fb1e9662cd29e025d6d3e94cf3c88ec3ee88538dc51dcdd4c27b3b49bd840551af27d9d594fe66902dedd5eb5e29766a7f2f23581bd04559cf57af67346678b2b9d4f00e4bbb9b7c858492da10a39259e8a0fbcc626b752f219218130db633b0d7e11c290bae7780e180aa0cbab458d93b974b704b212b1a649b4297b5399b1450882c0267d8e7d0b086bc0bceae00dcfb9e1811fa445106fa92a8bd7135bf6ad3b43f59e65950bffa1c023fe68427ab9c063d6ec15a174bd277f5e56a9cbf314b9dd2ab74a1d1d10e25966121943b791829764063d3b678912870f0185464fe5c4c284705f06075ad8819e1b4c8992cc09e5a9486cdbb3f1753d0ec8d754b440aea1d64fc769bc3d7e6453f66f251d02d68ad46730dce52f473a6217fbce4980183681cd31bad9dfd661ded388641e1360424dbaf19f2ccc36f02fc336c65d9865b6aa694e8970566a6fa6d83fa30d6e3d0e48aed0b7e4e30de6a48bf8ce95020d7ebab25b088b41e9b95e5d5c50c5faa34db002e83e242c26a2eb12e1ae1905ef824a658186c39693fecf1427d1e5006f1bb3f1fbbc6e5a40e7c9b55de4eeca1168303d69f561af0ad0cd2dc2b00efe315e16793eb348f44c5db0fbe1adda8e8d31716644e97fd945404aa798625f6cd0938c4a8dd9213ff1fdbfe62e041b3d2aa9131ac67c9e1dcdf7cf9dab8883db6aca33b2905a8db530df784480f8ccd8fc3230af2ff7747dc6bacc45fb932f4386beeb5d547b688e65736d8057e531a02c93d6cfbbfea998eabb66d4ee8ef581dae648ff5fe95aa8d5748dd9875d7759d8efe66c3f8b945d697151daa858d8648af01ac92daa9ee6d1a32d58a233198d9c2533b3315272781fa14bfc26ff75d6dc231d539062397e2cbaf836ae29b3fa64f898269723c293a88a153c4aaccb6607967a7a85d7e51ba75fc3e1cae2ccb63275b1d029ec6600e5222c587077d444452c7c7554fe1a70c72fb80b7510eaeca055553b4c7c545293f6ce3d8d598f84a5d773099ffc25ad82880e164c59aefade31c279cb1fe47ddffba5890f2ba156e15d678d4f4c3b82aa6a1e7bff145684e6df718a818a23a1600d6ebf5a019c85597b4e0b5012e51883c9d45119d9d1c77423c97bae3c57f767b903949ecdbc9e2255f5a7ab4039788c7f3eeb16560cbbbe58d6bbcf72bb7f335c16738878be08032b5cd2e8d9285dcc71c0b4888fe909aceb14600cb63d63a7344ad4da1038d43f74acb2a1d9189cf69e44b3c091817bac6c03c818ce4c4d961f3154e70550783c7a53e491e27f73114ccbcbf0b626ccb2f99071b2765507dbe7d186d72135e290fcf59b0a74d71488f24880876f6aa007969b315b0d6ccafd5a5f8a4d98f9f70da1ca5d2ec1ac22a92f30d9ad7b63f8af6d805407d9580844bf4f2937cd85c5e1f6f4bed1155cd45af58bf1891ff5dbacf6e6fc4e780a550a99b10d5e03d5d838417d3a02d7b8e1f6ffba56dd5388c9a0dbc3b40fae565bbe1316f0eff2a6fe0ce3df704feebbaa656897a93471ca2f84555bbadacbdd37e6be55f42682842e07a41bf3d7a0d84f7a083a00a6512bf10149be197dbfe4932f35c8c9973cb238785c3dced69eaa433ea6c17b6e40560fd66d4b8db7e2558393d71a2fc771658a01ee61aaf297bc4c43a792182276d4983c92afddb72ccd62f31f5815a29e654b6dd4729667dbed12c0b3192fb046c8a6514988169d085ee8cf15c3e232689fd205118b4e534a4ef12bf6b971a23c6ff6e4bc6c2204cbf7cbcd437435cb0fa0f6aaed1310c1bc1605a6ac99a83ae5d83877914c6acb987ebd9d896ee87e9b3381ad27e7eb943d1aff376784deb783adea0506c41dfcfdaa039c1271811d453e7be9123902afb27694218b2138ffa52f0fcb907a4a9c49da19ce59815223148d3c087c624996de2cd51d758a38120a04e37fb199dfc7e4e7dda2ce2e67fb68091b60eaf67d31afb51a665eb992bd7c860071bae177f183626644aff72c98afb5e37680378454c36d7e6030c4d5fd19b4f7f026fe97f557d1790548e7d618c40d41298b052c3b16bd3dc51b558b2ec02c3d75c476f66129b9b2e1a39bf2c8e6e138b47ab0b5d5cce21353225a8a1b1532e944b056b2c7339367ecd915d9a2c6e6e52f099b2c1129d2cf8a520dba4a00427d974414ad5e93a58c425805ba91811f2103964bb79495f7e95464af9a17f1fa4658cc29cf13b8d164948cc6030f374bcd0a78067045a760ac35658071877591f86d2bd88006e88dbe648502a156dc2f3855df8d57ffd11af65e77f14b179295fa453d4b113eac38262a63a46e4c1688cdb18a52b6b780d8096e5b71d1c84f0b9716a4b306df6b828207341dae68a88f6821806e3882bdb336dc01028b0b6e854034e1132fb1e8e786302100eb382c8927924b9ba93c157c098c4f3c296fb117a19d8f738788db0880262a87f9ac5fa41b667431046e55e2283df76b22c88644f3a361569bc96274e6a9e06f08f82168071a92232ca86966a8699ef40dd06ba658efca00da30252798bb1976f68c5a94e56027a21d124563a368c27ef4659a611a916f168bfc5759d0af3884546c435c23e0e6cbcf11a35047eea9a2546992503b327863ec8b6449939cb774631dadd0e626fefb54382c6aae7ef5e46122c970f7c51043264db15dee7fb2899d04759f26d74b22c076de122f277ba157d52ee8231e00a505d95b88128e4973cec37acddc928b3ff794b7296d50a2d0c7f96144df4fa178d6e2bd889841992e831b5ea67b7a2ff431fb302d247267d0b9dd65ba0f9e2a660ffcf7d4412ef827b75c90c5275baff48dca402deb86db0b043c5ace96aba99e7c834470bd24e6adb789cab353d52b5ddc0d877ca81cdadfd8f81ae50004ab143e1383d04765074ab4dca9732bdb31b888dd1d3eb977cfbc026267a89b9e8d21c63832a6d92f03a65e8adca263301595ebb190f90dffca3466161a2318a0301df1aa7578ddc387dde78b3f9249cb3a075796f92caf84ecfbd347fa39b40224b7f342665dd70a4e53ac153059ac3c1f19304b374c5d23f34ed3c58fcb28d9a56980edf58e5ad84e8ecab32f11d652d9eb8f382b76906362172a14b37ec534f038bd4ed5de13812e44dee5957478ecff5ea7a33b3c6ca235e0785791d73cceb6a3b5d395438542abc2405e6bd99ce541153b3bceb41b23f081c48808319d75eb0df604c82471a818889d18b713d2433855a4ce1670cfcfe6bef68d82c6b498f8944accc73c1c354eea99b4a0078956c574883162016ceb3a6a60279be4e383387aed3fa3ccabd13a4f85efa7463586b6985173b30c443040f0ccae94cc1a61fa19ea9284c38c7ceee30dc77c6263511430d38c876d3a62065fd4651bf495929dfb6d9ad4af6b09c042e944d01161c3b866157bd352eeb376c60437c60c7ad7e722f10f3ea1ba52c466f98bb819b4fc581fb900424208adbb858b5c5e7522173a6f3159ca91fea0b0ff25c06f2fd4d9deba2c331649085abeb32b6ef56f33dc860b28d608aba80eadc6b5651891c4217721e563fade8ececbeee96ab8c3b65bf99bc317b47d73bb880d0f454e4cc588e1b4a4ce47ff9b0645dd4ef0537d05e8dd41a2048c578070515069247516e08e10337865398e4d34f6b5c5e2265b5e9074fab6999b54fbe7972845fa569eded94da31cd9f795f5912a0cfbc05ca442dd10b9da4dff438de2b4808adb2bccd346adcaa966d330517c116991e08013a9cdcb3850eb9039e367f14fdb203beb9143ed12f0641a4ed5467162bc9bedf806e47e0c88586a295a9418fb9a56efd6a43f0747237c7de46646ae0373fada3c317f6c30d995163fa2126e7cddbdd27ae11b749d36a26286f01a3ba640c097f79c2cdaf16cbe09e8947762d0c11952807b5eaa30099a23f57649ffebe71388c1f299b75f284e59b3ca4eb418760329432c3744aced3f76cf2ee461d2604a7a26981a4511a6b8f08582f7c0ce4593f214fbd2861b496062eb262f385671199529cc4dab2a52154acd268c3e79893e37e1dcf1764ccbe4d1f9be953428e4c656e330fe2a6badc0e17dba51b2adb27f96175c66617b8c89678bd9d2aafb3781e6031ced663c528b97dbd531125c24913e1986a4e6d420b23a1b2170d9b789abacde114e0268020df91fc918936936bba294ceed1c1d2e4928cc47ba19ded870e7c392c11fc570f0db74394723e5089bd0bec71671611db5c7c27817283737edb71324f62ac4b768f687b58622032cda38cfd581fcc9bd396658ebfb00e127ddb2530b6bcb99f181d43e0fab2508b954b24bd24bad19b279708c82d4cf2c45b6f4bd8c3815cebb5c098778e9a7ca4e254796383484577b875a475701bc519b829e76a47072935f40d236166663ad9d58917e095c8136365f1840d85f359acb6c40459e0e4395ff053e0af634eee54bad76f238b05eeefc541371d3e67c8f5323dafac8cf8e5f898a7114e0ff81499e28ccd1d292179a51b8a17ca90a17f4d343fbbbfc7b180ba27b24813a473a346966282a0c78ae6a0dd372cfebcfc74318813543907c9a347ced0ed38ae6c653d2e69d8429d37292a4513d3a342c5b48e42e60c65b245756d7af9e3059463ea061d14078060a1d2c976db017715cf35702dbbfdc05606b347d25709e5779c732fa64ee34253c1f53fceba851d994cd8ea88cf2a81b3c4b6b1688e7b568601a4c63eb597e5a589362990007e0b8a05eb8f92dcb32d0ba89f3e8811c8181ec7138e55f126c1744b75e497039cc9523a9bc52a2270dc4e6ba5d4a28608f192ce3cb044c583588e208ab7830f07b601d7ac741c07d289d531ef773ce659731c08ee904039300fc5217a444e62c8d6fd2d06de73b97240694a3b3ac8a09450d698e9bec003d8e6bfb602303f989454e14207911eeb24deb38a7fc726310c7e81a897c4d1937160b14cb3bb8dc8eff4466cdee6c0d4e8a654c3e68c36a3460a88586cf51381b2cfcd4dc9ac82357958636926859ea98a631973903452844073b23e5c8a757ac15f343703bc50c9926edd8a7f710774564f393f53570ca5c88d7b216e2d95926f664f216aa6a5922fb1e9350ba31ad243dfb4952d3980f72d1b2765cc8d50bacd53f1247b6f782276b456843d4908c53d502183816d706ed24debb93be7db005ec869d4c420c7267575bbc5ea62939c67b44e9b98ee0dc96b6747a41970b2b14835966184f7ec02f6cd62b5dd21d7e17dae43bb86d7f0b47fc09be7222e9be8e1abdbd4d6b02cd12bea79dd12d117c3de171593d7828c692ecbd9f27a50352bb1393ead718470d257e91b481a34f053b73a9dd02beb9e9d95ddaa3403ca4a862760718f33895d4a9d3137251324c88cfb94b291a1812ece1e44d752d36dfab6098bdedf2b41103833b14924fc7f561499b8ef57ca0f1ea07bc779f0b94a88712b02b03fee9628ad661e9ee8c8b3245aeafa2564567baf2f75da8c4926cc4766a81dd8fa6c73e3ffd32ca928ec5b8df69dc6592b5a5ab786cf91ef406ea65e782ddab7e488eb7fe8e91b7da71b7d6ea510284ae1ca16660098500f8a85104b3ea3fe96baf0e7d66fc24635b71119494f04cf98a481a1c96c4db836532429f491b8d90acf9e441770e7771718a3f3024729b42a38233b869c6f3d0effa81aa50aa49d323d5ea4c1557f97b73aab0d6565537a5ad2ccaa3cfb806b33592dfd7ac60e59b885088411941a138eb15fea829d824d8285a17f86acf512902f3d813b1be9a593c317e7fb491c41b243042de834476b3cb0ec78193c724ebbff53227313d61b48b28201a9b578610a0c90c581282b5465848671cff49fa848defc71535332d89e9575070e62bdb5c7aad32056756460e67390b29229e864849bd8edd64dc4738488c15eda114e11fd2dcd1e3762ec1c29d983595813f5ebbf538780e763e8f60c506dbf9190e9d19e8202ed7101d947eb03384fe322e7f3e9698f45cdea7a51da257071009e88d4d8cdee72051a3210c043175f04a4d561d912acda2d92dc5e2184738c1c942e1a8a4b7ceaa86c293f54b77232dea513782cd41fb60ff073f2c00681bcfd24823b942deb40d3576accdf9792f81e3129d74dcf7f1d778aff997570f920bdaa007fffc65f26f05551c0be7f63d5d33cf2bad1ed279ac4b6e1e4fc7f1eda3063dee8569b0606acd3b2f455a86265a65b0c5ea7f1f19e12baae0dc46dc68dcfc966b7e25f1a3da0eb36e885bd752e357ac9a454d535cf72566526e91b788f5a9a928414e8a5ba7ed1bee85de774955b4dbfeeb9f7a4f627a85784db86f2850189db6b0ab4e0d57adfaa879560cbb6ced7a98a82df5f326ce4fcc852d34ade74609d6d8909fc1a83a9fe04feae9b3e3b3754ca72df351ee6b5911bed09b5208f3ade974e29a592eda8298297d7a3cb3d72b267dfa1186da1169a3e1f26d61fd998c7a842ef093bb3e68819afd060ff371a194f39475ecf104d8e63d3e15b373b962dc4c9a181c5ada2cdd80fea53244fb992bef01a194a9f34fdbebb214d20ed0019a3174d7e38534d14dfe110491a5da8b06d817288024aa1e3d986d6ecb8f07cffb5ab436136d6930aceee20cc18b1ed7b741fe180f028323959a6981355f0e1ca41a16b929dee57863829bc433dac984603db28373d4fbbe6cd06ebaba37a08b4a72523e495c2da2415a0379413773414c9fa3bb4f47d5615ee9de525be907f54cb870902bd2f7ca102a5babf2eb5d1d5f96393db023f0daea1fc9814398d2f43c2798764c213be5fa83b74dbb0f603efb1670d94b47d1eef4b930bd294c3641ec61ceefadd07444e67aa8ad0b37225b8df7b276ef171cb132ff2966911964c45636f61fd635388458f8e56818f8921fd52e789fcc333163f64cffba8de3c394a5b6705fbe504e539c08fa8c0d870c43e9d0288159231ee835461732b11ba6d6248951993af3a172dd99f72b12194bf651f76c5e0a0da0b6322bb9cc69c566d12700afa60261a960e9ee0a444ef2fde714acf06ed473808a61424036c831d6848f6e7c9765d838f5e60565be98c2911b7e9604cd63152945a6d2702336936ca0b51635b98cb52bfbbfde4b2384b77760e0d6e84b89ad9483a41828c2ba3e89bbfed27af02f48ee6c314da7e3386e77f6c8f25adc2a3244ea9b799403dfdc8d493daa083d93162421cace1417feb24c2fd6022e8954c0583920a622a2694093aa494324fdc84ee025535b015840bb3329555388bdb8d148e6da1035c6d273bcca6f4ead690cd9da497699478f6cb1b1cc2e8ae1ec401157626321d63a92f5917406bb8a8627a2dc5f4d8bd545d09580ccdbebb55c3e61fe4d8d5ba44aaaa01768855c90f32058ec37bec9e73d2c1f47ffe79f8d7506a52f497235da18112e5a93b9d817222160fa0cbfb0f2f59aa229a3ff43fbb5c1022808283cf2ace5d97f7831ba250a348b20ce264d4d61da5e3f39a3c745fbf896dca1c24a3e1521d8b06782e6b6d9759ceb90d7a05772db9b700ed79bf6f4dcbd0f313ca48d1d7a2e035a208f350db0788f15181aade509e412b02fde6fbf83753e7a9b4be471881adc813abe44318264d4a26c6ff8b0fa84199135bbec87017a83167469d1415aa0fd304b50cee3d9b563f8a5b9221f4e7c16b827a5ff44a747569fd0fce0c2e281499d0830608be3e669060f379ccf11d751bfd326b05f1668e21d5d00bf0e19e52c000f2d7376c1bc711c09b480cddd9d10ff4d508ec193982a6d3b30ad252f3ac1cf1900f660ccb240b5afe8f7cae30f7e37fe31f5123d9ef35f15bf1e6fd62e47803cbc66b77632d8e60a2ad780c868696a6035a960f8c1bd6df24febd20abdd0927458b669159e63f8c59427309b11b48c1521fc86976df63dc215a4ee524ab58fb3b5496ca4577b637ad07a541770a692a8a5e7982ae4041ee6a9319e776f3f65a76c8d21da61f43ce7773081f86f87cf68141ab75a966de836a074628caf0b7b75bf0546c7a671f2a2bec220eaf4e21db7a3a301337041ccfdc69cbed669fa5b3ea67ecfc64a007aaa1c2127bf5eaefd76f82435e166779d0c5e4b491cc1e6f97cab2cd66bf6dabb0a2539d290001315b8cfcd3002cead2e2837960698966fdd91880bad4cb5c1ed515dae4c0f92c9936bf738311dd708e2b19b650462a2fc56e9a334a69ca86d9fe2b7db62004e007aec3b21239d9ca9e4d03791cf3d92b68c139273422aef81cbb84f4d6a1760cb55d00b86848d142a06004617df4f2e1e4ea136134b396d89afe53c96e3a469b4ecd261ce4d84a8afbedfefa118228ec7e27f7ce5f5734a741dbf86c2e5871b020d9199734ea4a5595b8820df1558eb4403d5ed03405091f947dfc195c3599eb59c12d921b9e01826a351efdaa124b68729676ed89f83164f1a81285bb46fe5fc0c9ac41b0b587af20a5e12efda71fdc006674ae4437bd72eef4d4db28795f7c4088579f64aaac065ff4cc4f24dc80b3be744c6c2cf0dd70d91eefbb6b59e365e5cbc2b5cbc4b6e75730bec1bbe67c0da677b750d8f417c4b4b5c3e341d4ab3f5891ca007fa516aa3a8a448437d6d7180fde92cb503460a9b05c0c03b67747acd15068669a9aecbdd16b60abe3571915d281363a9bd4407483b9ec1b87cc0c6ee8d2c51834db31ff46874d6d848f1a7d825471080e9697f222ca67718d56ccb6a4a1ed6de0dae9625f7a1b8dd2cd28df08b3df8ea382aa46d47c1247dedc283083e900e78a1168110511af3f0f19a4124f2dc3f26fe6fd7ba8e4c91c57dbc4a57e739d363b146e8c16a4e755e8f8f657971b5c0f8fa83a584e868c6a2fdf334cb327217d70f02aa80e02401c88d62d0f39faa9e023b78d01e4ce9739671b75a89f59eaa6b3f24872904cbf19656b4a52966bc7c470b360300a5251321a9a2f7dd47f4a047024c95dcfe0e6304f8f92c4af1582e054139644e51e1a701ddc4e15887eed38ad505624a8311ebc763df8329ee96c7287c1ee536ca5bfe4da934e449265885514358c5f44ad40f40bcd3272c715ed33b6a8ecd0aefd166a9e0380e4c60d70fbf4c0bdf1db919bd016aecb748005620dfb709ad60d563b00de37ee4307698eb87deab9f4c960d290c857cd6c5cb360ca1d6489a7039d353f3f72adb90b0a4849146dbffe6cb8564e4544c62944abcbf00e94a1c35000ffad92b4d5b120fa347d83f7f94f42282543aaa2063f3ad529f47e205bbfab89b10f2a4638029b00f9200eea3be612a2a134c472f7599e9203f18cced13a7b79e08c3c66b682086849efc9140aadd31d22638ad3d168368ebb362272988a1a4be54279985b3716b5e638c368702bec21a47d7d6cd6586a611777e2480a485c6aa9f97ddf96fd0090685f3f0230bc2084ea8f2c6cde1935e2ebb5697bb6570699684a58c43daaf0bbed3aaa2c8f3801ce110d5653906011dd23b30c7f5466284eac1486170e476a3ac85b05beef894dc8c5636004e74066ea042dd742fdd8ca8def154b9072194e268c76a06c72025e0a86f719f2e13ccc0cac745d03d7195fca699936b63980ea2ded68f7c154b622033b7fd8179ee90abfd7c74b6007b84f2b0b4567c468f842214a70b534b660fa148a92a3b9c1ebec45d6efd7ed542e51714de3a31e5684edbec6a3376b666cde6bc649e053b9f343bc6f4379093e5e6ecc9fcd4aa8029179aedfe1f5567b99fb3b65238236b830d3f4118c73e15520d29fe683d59655a1edc7d36cc331e9b36bb2a79551278a468a2e8dfdd159d0a5f1452edba246a361490eef6ee4f82b6716e614cc7b994d739d8a220f7b26e2db7fd2dba88325ba60e7d168e065cbef21ce77bd41220f80d15e327a46ba20802b760bb9738b794ef34d0661fb4072ea6dd6fd6fe0eecf2d50d1eb80e686a3675edf0702e5f47f8e0bdb11c4decb0903e9ac4369671c26b96cc3141d7c2587a02c821daf46b8546bebf96a7404c1604b13dc5291d079c57735c681bfa262449f9a170cc75cc81aae27e938fde4f51b47c2f24aae25c427cb71ef764bb9c1332aa0024835f0c4f98fbad69dbe7f48d6a5b366ed6fd093e959be544492332e4a0dfadf7c2d2221a1b3df811a09f4b370fe9b739b8f94c3a25001c30f480d1930c8a23236f2c6ac1c4bcd93d1465ef143d4b02e955aaefba01f91179520984acbaf3add4278d1f7e693d59dadc83172a27ffc646903d73c1a70b53d88f9bb93def6ee3b0086d9d38de469080654992c705339023e1b1095d81304003af8afe1fa0db4893fde6567cfd917281f901db8f8809681cdf69d2e391caa6aaf0abfff16ef4ddbdc12fbf687f19cbbb83d71ca2053cddaa4c0fe11441b2f3268513e899c613e6819537185d74ca85b221702b18ff4b801b86802dc5d6ef374826798416e3b68c7b4c43128d55ba389fde579e0c288ea043dd91662210a7852fecc7f1719f72b7249277e8cb34a2933d1906d30de10f4a3f73656d00cf0afe4f16e96ff8cebb4c3681a6ff096616b3885b40ec01460904f8eb7a975182873a804d1b87ab1f31a46188d2ed602a86955e5a2cca79a89414527e743b408c3848b87e7d86ef79bb569c2911ce75032b195731e353fc2877396a649145d9c2e966cafbf7c960ccaed216c5c34e93c704f465ee729d37cc4db48f5332a0d522f5956bcb7395dfda3cdd24fea0693bbba14bffb0efcc55f807130a52b5f34bccadad3d6430f4f078fa8a6a88ae75ed2c1b986e0cc94f6e711eeb2decd29380df0497ce2991522e68463b6261ad9baf2523ca774b93f266b32765902fe5a6cfd9e11db890210fbe5e17ff443e676869f115c296a8386d6a3b10c5e725cc6a4597d54896d84e928fc64cbd687e13f405225b070ca9c2dec2341ab190aae25093f1b539af26573624ee7b88383e1813305773c2bbaa8a4273cc5cff793a811472e282b7c08f5d853b400b0b7461ef65e5a24e31608430162dba82216addc702ab4c9c0cf1f5aff14b2d2d9de532effd6e6d751ae461a1399e0335bee6327cb3614344b561a3690bc75df01d9a2b64f6fbb19bde7c49e5d0dbea8af8a334da44d3e83de7a555ec5a89213b868f9965437b8c4083263fb438f82a9514d1aed9755a1a2cb797de78f745e3701e9351f19164834210b7f76bc41b05291b830ae478e111666a558383c9eb6bb2345a1e546a20630057600a0e079996fe77665dbabbf850cd89e1473591cc1716e4db5f4499852f7d5ff71d7be9c7774a1dfb424dfd5929adab1100d4d4bc688174e164f61de84a703b906ae933f7e2a8f37f01a300a0ae82c992f18fd63b380b0007d02daa73884d56ef9221ab5167dda45a5b42b520c8c3450bbcdf03ba5be90171389c78a77fee46e67147b15fc083ab2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
