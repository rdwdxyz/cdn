<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef11a0d5587dd3a49f4e80e5a25e062688b79d1b24b3e14bce2560e9b03f130e4c1e333385add78ea972357c948d726fcf9e42b13538368144aaca80c9c41eaa072bde4fb0bbf1f087efc02ddbab18930cae299746ad9102c05f1d6105a9bb28eb3e281c1e90818253d8e0a384e413911cada2e562fabd9f799d431b5a4be3d58b8d54a45d5b5fb566029e9717b7d56247818cf5cabe2bfbc8bbc691a0a0927382a3b353993ca9f4f7b8398525d91dec7325ee7226644e2f43e05d3103af3959b08d66c18f763aab74aebd24b81a1cef33dcfc5b1bdf4715ce0489ef98094f2291a85c6ebc11cdc28a74d07743534c402e036d9fa45c6c7e19c5adf06d577a08788a43be9948887e1ffa9c8b5289ee48b88cc8d33aeaeaab383bb2814a77a640f735b383ba4107839bab4ff96192283b0866f2235f96c34401382e270b22ab2cacbf70acd4e66ff46261370ca5357e82e9b8e603002aa4958cbeb53c1a1868798f4474ecd805ed9bd531f869237df9dcfe49127d9c55674178c75e23fcb66017d58b3159e9e55b44208665b8c9f492f1ba2387d9e1e4a5b144a7e5ba7ddb9c54cc1ab12b9313193eecb3a081c58e9c14547472e627a8077cdf5f56641c1e423c5f19db29b54efd5374045b031273b34557096237025ccb9b9eb21aa56233e97ecbc99855ee222398c1d1db6b32cd5d1123afc479743b0b769758c05b8e0078930b8cfcdc63433fe127a35fe9722ddf27d934d9d51ca2315c1ef7f08838985109f239744e5d16ae6eafdae0f6d74e2eb396c8ea047251e5c8a0cd2bc70e47830dee0d58365f31af0f1d9f4ce50fd7ceb9746a730b955ebfe0895e25832940fca362da9c880a5d45dab430085381d3081fabb8ec7eee12cc69f1191ab2d64a333dd78d82ed8459206301c8084a8a3318226eef711cc8ccad66376014fe0e3eab6d12f312943973f48a5fe8be6f3479f42d635dc525c38646a96629ca50a79d531dac567b81d9338dace38dda3ea6159b6f29afafefff4182c145186a9716017583be13821f4c3549e82876a5829495c956a473b5266ab8dd6dc500c6ebe09425dd819b39af0102622267d4ea65620df8fc905a0a5717437ca74538b5bc6d87ab28390b673fb0177f4cbd54fdc468f1c33f92a87e7341bf9476c17ba44bb81d9115d57deec237668af5f93cfce37ae63639e0a148c280358cc724a32c8a91a926e36579c328b2a3696c86a4588a5f71ca47a027840613e9208c21f2e84e3c2797981b55f3451164bcab043258a8bc243813c82fa82b87b7385da6b837442d38d3e355e4f95e1c82332f6508d2357c943859a7a775f20d28c1c20e81cd7ad712c18aab1383be4807c3035315560ec4e8a2d8bdf932d44e9be24126c2e2492e59a47c676f9a25d92c37986a1844f0e3a0bf8056d91e459187d16695809925b65f91f0daa65be25d1153f1ca655f2526cf4c6b69221949c877f42d4e45a8fab8f5a0da4ac7c12d5bd942f60d7b2f5eb8da04cef49eb3dbe5a1cf601f5ec91809f5bd928c9859eea5a260148d7dd64b7d3d6a62cc7eedaf758f2f3fa662a5d086d0ec08db99f01674f49dd78bdf03ef10548081e5be5038243618398cc01cb47407b8b5b0cd6b9ef2eef269c1dc6b04cf9729ae0d24ec2bac360546b47482266c23c1791e6e16302678d02bde7ba620a258de54ddb9bc1a51390eefd36c03edcb0665acbdd514382ec5226cb4361814dce08c629e2069e6d025a8ad96863a1477a553d3de3af10ae49fea5ad3b1d540aab6b0d0665e4fc34af5717725d58ba91d213e2759b761b67ded2f69d9dc4c38e5dee20c98e054cc34a210fae787faa6c6e6b16cf63840c65a2eb4e28d4fd59a744dfa5884bf90fab29c944dc4d746b0aceadc67418be26c2c1fa5d4ef3831f9bb4821ef8193e93716d276c8118de48e58e3cc81dba3d2818a6d5978013a119ffa2656765828150f4ab56847a0fcb5449e40f2ee48fe01f95e74ef71578f9003f6d233ec8e2f5447e4eae5a6e999a9eb93d1637817e42e82d72898eb1b71f94e44714e2acd827a9d361c0c00a852cef8ae018d6121e2562047ed0a38ff3a08443bce61d9ee57602150ca3a675d3dafaf89f59190c94f2c28cd7d73fa7d9d1fdf486428ade5002bcee54c58046ef7083405b253bce8df957cf3fcc31f3e829ec6732d945a514b4fad9d1d3f4cf1eb207053d73c2958bc577193f576be09f1caa96ac7233d0f17ac59dbc2a825ca3a87c0a672ed7022cae4e920b45005798d5b3c4c79aa4d16af36a9e08a0de8902516172b05f2c834b3841f784087fd90540c40153833b93b3f93b5b7c291b1a10b4b9a363bc71bb1ef20e5bf6b94d18061c126d7dd9e6b00e83061dcf22bf475d06e06f03a8034856167bfcd3a2844c6930c1850bc7f5ec08ac92a2ec7c6b77f0461ab4b2b978ab147cc22f0ecac092a5c557356a1369f867c3cdc2b7853febd4f2ae74fd9a1058b58f9540c330fe48fdfc292b63ee2e787511a7ccf7562d0e38c7323a46b5be782b23d7f1b33147960042288143d3f772cfbb4b25d27cadf8d7a874af4770320390747f7cc9a2d4e8ccddff6cef408ce085f611fc0bbea9bce1035ef52b46577670c637d2f79b8b25881caa209704b352cb7f2f9a958897318986012e9b411c41cdef4708c2be4e005297374cf070cf9627db2ac9cc3e69d276a61b5a323ee2f2b053de0d187f1b6e24b6b22f0eeadbd748fbc63a611c98860b69f5dce4d6668119d9c503116ef67e6b7f8b7d4822e4d0e1b0666e9012aae547bf01612990d04241fd123f7289fabd9eb9f5716def378243a28550b2192ed3511803e06a187567af05fb1be31f3711979d090cd48e2ee5ae1683fc6517fac61f62ad1af86dc2105f39abb4a1126871f36fcc19d6fe1722ccaaaf83b767a418b07acd886c8f849640482be32cbe935da9058367388c1f9b4de4c8c19970248c8eba14267881431d9efb49340d8a7400d7faaa18e731ef5a6480ef6b34bb6d56a4cfe4fe2bfa96332c11525d4d40b779db1ed0c630c70390d45737bc21dd8d7d69359493261c2d6659e416e99b2a45b06c1fb4dfa4c8ee2ef3451f673138f5b32389cf0fc5a0f0256ff96f23aa7c7f6cea6f20ca2bb60e454f9c408987bd294287613259ddae5603a9bbad712f45dc13430526b84e230769128d4aaceb9b24d630fcca2fe4b3e76b537678e4bf903d184142b98f1c259a63da30c6c594903962a33d338b436061b699bdffd5295c9308ebedfb6c053c4dfb0b593570020b1157f19cd498bbe4e0ff026889721c2bd4056d785363ed7cc2bd0e70c01177d99f58c17a4ca0a355611ae4294696842b646ddad42972b99c6e94e68547a22ae2488bd28f9c6853873c13a8b07c7500132920bbc7bcd929297ded301bbe11d77b866ac4e6c36dcd97995124d6e7cf5bb049d6bde8a809e82c3fd1cca64be8431937d9bb225f715ad9ea8cdf1642a837556cbd624295174381e0f23cfcb74947a3b6f9c0abc1637a24b3294ad24ee359bac4fe6a739649dfb9c3d083d28bc6a11a83087b917ad94d0edf95352264d9a6365216ecf00ab11342d3ed99808487cfc67da4f5921023694313be30ed5cbba870541cdf61b4da1f79cbf9a57295282f74b4ac14842cd2bbe53985d5dea88edff8aea0cba4a9bb6f85199152c46ce1123bf1c7f1bcdd638fb00fab5a95406ebee6a87955b92096163339b4dbe520e4e7c371cbf104b81cbdecb477ca0f9535078c6dca659d67317832ccaffdf889bac2aba0c5b58a2df22a4df59aacf981ecb8becafab7491666528b1a87cacd8b53f631eb35ac29b2ed630e62c010dc199c81f6934bd6eaf80b0a4449da41b8eb0767f1898870e745e651f0cdfef9256da3768f3a5624f0ad14ba54149c499acad5c414a45c5877929d28bb87a0664528b17597e3b4fe414b8b8399e7c31240a0204028666dc3ea26c07b64843eb06a56155d43c14f999fcca650d0188e65d271c1bf489498f34610af60961748d2dba3ebeb39d03c0747829e1081bbeb8521cc040f4927f955ae78dfbada75cb44787af66037b923f214cb9455572b30ea684ffa9fde02a808f9206939c9fa3e9702734c4a717a374e99458176635b815aab1977e7333b196bde22a7bf0250473291534327cb61e007605df9b38e27652ddf9dc543d945196ac0b59714cead78c79ac21524b49e01d4dd6cb051a1f970b01f5613a9b878e2f8d54e417a0935b56391b7f5512057a7282c0106a09bb0f5e72d28df720d8c279672d8d4e4ed8649c2e9c98299d802fec60c0755492580226e82cef4d092de5de7d069548856d9349d292f3dc4b2b61dcad79f1ef11821c2a719d8e2bddcb5a22ada0a1890d5b0d51b8281c8793c0c2a26b400a3e34307ce504af4ebc6c66f95c4637cdf60dd72d2bbe1d13968b1be74d090b852b952d57769579dbbd50845865b8540d3e7e27bbebddcfebba20898859b8ee0641189c2232188bda5d4ba36ffbbcee279c8d25b50cdbabff8c1b28bb42f74c414e978e5ce34c3eade113c0e81d718522c424309b2060a2b5bf67bd465da74ddbee3050aae61380d3711273c6acf97ecdb7f90b368e1c920b0e1f9a0fcf724913eeebaf75f1c495774663d2378549c4b9dd3efb44ba374320b8a52e8c0b2146149a86600d89562d4265dab32e7621ec528faf5b59bafc2d458ff130d7cdb2b450cb2856ba6b3d7a25b5ef643dd66c7ad61df60c0478d95a5e9ebebff50c1c379954a9d83b3b817a093701a7d76820555db39bda450a81c47d73a5a647c50c84ea1b3c161ff7ac1cc811f5ae03947ff1202ae0ed7bc5ff8b855890e5b210bcf9806c60709239c6d4270e49eb786ef97abb4f4d87973a82ec41e57efbd008bf07aac75f2246d53612e01c786f7ffb576952ad3409559a74758424700820fa5d4278da9c6263e5607f87f553c3f16b06bbbab7bee475677d867056b35b5855a2fd1df1bd1bdeea40fb2f93db722200bddba94d5da728f9ae375a90e26bfbc4eff09acf0d21b212aa129f2e2d230eff78d93c9cf3c7f6a88b87b71f977c1403c0dc1a788874f30c3407fee33fb3a31a7fa84f56aa36a9440cef68f952d35a7b09d70e3c9405987c6ace3b9236d8c45455ef9b7a2a5248d002bf03f68e6d30c86ec6285b267fb82551de79dd978f9668253dec47904c661766a0036ba7136fbe9a1b90a84181915e866cd3370de1634305f8f4bdd8310ad9d7638d71c3c609001b841358bdf8f3f6dcd492b57936d366ec2c0c5b8577c7f49cf2df2236bf27212aabfdfdecbb35809a5ffc540882785ea56013d8e18c756e23b85a6df5f5f3333cc03ae0d0a5daa7bdfaa161de7fa100e421166bd5acdc5d667e63c3d940a851e8aaf1a297dff42ad140ecd1409edce8d6ce3e6c3e347f48e56224d820b2d9be037d4da06cdfcb6ec2ccdd9ca8d4f492b253ed288865cfab390818ddacda80758c1093a34f136ec46c2c239cff5d0846062d6b37a904b0487e58fed1f70bbf1d1c2980c95d9596d4eebd9428c37cf5c25b3a5ce92095d439d766aeb5fc28961d802ac3ce883c153058593c4bc97eef0796756871e91e9400575c1db84eea1dcf3ef5a277f071a312f653ee7e5b76a4830f14542a707b9e871417c9a49ee26411f9b0e30558fdc6ee9d2f0e3f9fbce31d650f8797c5f2f312265117029de697eaedabd8c9fd8a8ebe84118e4cacb0d81cf9839fa1765bfdaa383576a494790b8577f9064560cef5fe52121da563a9a398fe0a78e3cffed42cac93599cc30c15bd418a2c8c910e05d3f29e3c3721f6410f5e9c300d24e8256132aee6984807e24518709925ad2f5c804e6e03b6b6db3b31391783482c00085bac50c526b1c7eaffab45de19976b7bcf901d6f8a5968740fb50a726aeda36b586b8742cbdf3f75b5e29cfd0787c00695b0225444207b7d0a08dc559f93c854abc1779f1f0992608cb1e26ec2380509148eaf98a7b01e8535390d8157644bda50a3fac8dc848538c89ac6cd52465b864972e7b1abf4e3bc3324268ea16e41b685afa018bd045903e7554f72f0781a60e409c67c0a3ee3c422487cb1cbffb7ad5d5f8fd2624a666b3d58f06d159deb1974861de77ef3143f44e0e237d416dc478fde64e6dae6ec015352f4b5f4200c67b5bd5c04f63eef2c527bdad30db61e7a19572ce4bc1ab15ca1a279eacf4ae4e02ac8537e6a56ef0489f59068f46305161d4f5928847f70a6b4f98212c69e24f5bcf43953296ce1a48bd8b87de466282defcd7070415232d10fda3725150247dc369cbf110955820df9bd3e9fd85a94c3aa1f74f4fe7ad9e28d283839fb4485df01611ccb9725af661ba32799d62a1f32c99245e20920a7d8af7979a1e05570e2460bfb898ae104cd68ca24176392e0c4e488964e7219a3553eb1c6d34c1bd472da6b5a1528fea112b6f38d273eebf751f20ca8c688c114ed59eaac7edf8cedc0117aed9c26f9a48c966040c91779cc4fe478a43b43642315ce7300fcced481580a157e8d8664a885fbeabc5075da26a74f629ece85c581405d1a379cc610f3cc60575cdfc0bcdf6ea3fe97569f8244f737915c51448b72942935d201f0a720327ba5eff67402ef416ab073bdd7e7afeee2105753588cc3fb5672c1b1d733be982343ce9080207d7b27cfd8ab965fcc1fd90599536e5313bb69fb07740cd5816a03105ba889f6055801f24b69ada9482d43086baccd913417a9341c507b472ead737e5801616af61704f5c41f490e8a884ce9130827725227171a77a61176c217e064fcee6b5a9967f79c0490fb34d76441adfbd46b06bd11b4b707f9c611acde44ed3f52ca504b5aceca6d8a2ca1d04fbe9b7c1fb1e3223e691cddd39e35beebfb1363c7da28cca5f8b9083ac140f8a4651a16e60528db9ca56d53781e3211eb66f6f14a1f31ba2ef3a5bfd5608620954fe49a41f4e06b3d532624eba723c86469cc24abac6053aeeec469db221bdf5b96a61082f664b1fc02b185f838c742aa9d07d91cc03cff44f5a36ab62d22173ee1459c222c54ea156cdadb60d147c1f3dd779b3a5cfe234446b931549cb1650204aa8cdd98bb5bc649525f3209cbb0b67a80f49c26b83aed5edc26e6f5d81adccfb794f839245d4135545c2155e6cd3da813a4a62b58d897d5bfa29b3b6bcb8109a19cc684723548528789299b0667a8518bebd75e87bddb26f044e5932a6327429d8c66237e428fc5d74e9ecbb43f0d2196776094cd4051a8f42ca8df43eed61aa20c6ac8ed5132624f02d0251a9c45a284a8f25b5cbbbfa7cf13ad5490ab988f640c0a9bf55e0e3dacc028c91dbcfa4f7b319fc72424a7e4242d0e2a8006851e9d165deba1b7e9875bfb6f8373da1b2eb477bb7c1da67cc40d203ce6c2fbe4178ea8e5bcb94e38e6e6bb5d6cbcaa7c029aa74e05fdda458cfaa9e8225b1e0aad756b428139a23ef25b84f09f578d0c471865fbd983ffb8bffb3d0672f234f79f9e6eaea7d492d5516a0a7b30b0dd4706f4790e62d328a95d008b0cebbbe8fff8fbf34255e100d5d611823d0da232b4e44e3877542e0cbec0be0be5ae31a83065547c7eadf9259d63eb059c9bf99d1df3f67df9b6bf94aa375a7572f7d6c84cde7515125b43a6c1f0db3bb768b75de245141ce4aef253ca4cd3d72b1000fb80a3959b2fa906d52247a83acfcbdf8f0418fe258fcbde98e16f1ccd6abcab959cfc41bb6c3d74d3d52f610ef8b95ab4d4433300f13fc9add4eff787955e361dc141f2d83f8b9c4eda556fcd876159b1d60f4fbb99d8726557bd0f1bd971ba840114bc13a11f41ff1fd4f9427e26402e5d8202001d54cfbf297051ee60ce9679ab834d5e4fe59d5d9764b3069775ab58c265547869135949ab8ad534a5c3ff277eaef70b24fca47639b0e6f4d13d08de9ef3f5f8c28800f93b84af1f9c339e8bb490989914e8278e6794a6b15c76e3793cef1ca17e2508e2eaca0593b0d18788e9c98bda7e08b5f591234c28e8a8ae2684d1055daf487ba6df328303e1ee6b9b07bff5a677b00c7bb0ac70d9d13846512afe2d5b2401cecdada99b839db3705b231c14180317f1f89721d2bde4c2553b7a688efd750110d99e12a8667604a3fc796720789f2a97426706f0d4ce99ff84c21f6c779c4cbf952bc3a0f022869b2cf78c3903234ff8edf0b663e281f2fb47f2fdde5de78acbd3ecbcd09e304dcb55aacb923f58a90a508be69ea45e5f1cc085de4cf4819f4d2c46d7afe108569bec3c60e48e269fffb00e95e7941bfd5dd82085c888acbf7d99f0c6664ab4e491ec924a239cd8ff72e569372275b6c5aa07cfecc42e4e3a737e61009a5693fd2783a012e594d4521940e7468f068298b9752b092d7b96e606bee4ca3b6c4fe81e7fd116b1cc610ece2b99b34c44d53aa9202d2b0d750d912b06e8efa2ab4d11e0e8216406ac8154fbfea2c46d4aa69a3f9f538cbdd6432b7c16f7d9f69feae4afea877d5bea83bf15462db5bac25c99aaaa6a99cf7c8d5df8207b2ff394b09c9847763cc627b12990cf1eda64af6a6558d423a229ebbce0dae46ee29c030d0990d4c5b98913a09eef7cc3bf89172eb6139bd955142b628c861f1a140229c4f32e8e23264258c0c8c112e82a09e5d61fbf8a2b035c3607b1143076bb7da14ecd6cf039fead5b531ca696de5b923b24a6a35b8d616f2b28683a86683a73ecd8eb9f16309c582115d9ccec65cf06455e1588f11b988ae619ebaa5e0e143406349ceace0ee0f610b0afec927887c904c19118af8211f89ba79beb7ff3086f1848cc51645e376e8c49624f552cd60bc8be38260f6d2fb861c8c82bd370c51ecc956c422325eeafa48efbb96b52549f6b10dd44d8465386acfcc0eddbf257e39b221bb8b771827ac3b47d110e11d4d3f3bb0106652cdde44d6232d7ba75f332363ccce3f9d5703bae5140ba619433cf3be9a9c3430c9b0bb04d15cede5a15d2c2c0a653771e9daa8c33f2609be00dca009dc8f8ebf7bf67f8491d4831531ecb8c321f5a9f5b4ee191e9abe82e23d4deda338a2baff809a79ebd69a400a6b5819dcbc029dc0bdd624ccd1ec62a081958e0e8c7664a912bc7cd3ca182d03d7d1f8970383c368ea14395dbb75f9fed4daad8d4ea8ec0a39a2eab33335724384f7f402e8f1be48aad5f76131007ab497b6fa2a9401677d1129e1289704a48600fccfb993facea97dabb743b241034eb66ef8a8968f0fec2c3e47164a3fdcb3106be17a816cf77089638d98c884522767a4f7a2ebe0c7de51931310ac924d0f4372382f4d2cdd81af275b95843566f3ecebffe1bda3abb79ec395d07f2f92633af8f3e99ea239c89b08eedaaa17f22952f97b17df964a8c1bcb0bd09444535b744c15e90ba1ece496134d201bfaa2b3250e377f0ee2bb029499de4a2366956e2659972e1db3d572b1d83207aa9a0e7bb8aca9fd040595023f2a46fb1d8b5c164fb40da2d53dcd62320e6988ffda1f5fbf4ac64a1ce046246662b6c90d96edea4f55b9938a46fbf0070966ea97a15f8b80370eb4dd228aaec9936434e317cf24fe2e8944cfba80fb07971f6540c40353416eb6a2c0be6e77c4ff055062c9bd35fd0e4e5c2c99146701c3259ef19d140eecd17fc48236db2e07ae27ec26ae2606b931a3803293b244d51f89380f398feeb467f81dd26f25b2da11f62b9ad1595ee431ecd8d70518862ee227c364feab0ad3a6c355b1c061e172672dcc4a7801b70ffd9695c77293c93d0d63fd193714c171e1eae0661700b98e0b4da89552aa2e5fbc88d4757391198a679556af1d98e9d0402e8c81ecbc099202dbae0e6eeff259e9ddaa55e264d194ce387b76aff9eb02c0dbfdca0058cb84c566d2b11ad06782367c229811bd0350c420d77fe8e1fc3dd094a094e82390721733dc39d8d5b2625a6ab06773c160ef8d2ed006d4d521e36ba50d6ad8a486a5abeff667d1623ad51fc68a326f5cebbec074a28fcb79ab02a3577498e3f4640babbfc19d72f22e45f8d9a3f8966736b641365d822461dd7fa969be8d4c4b8b41797cf4fd2c4f10f0838d3fea31fdcb33718f44a25b5453487c03ee6fe37424eaeeda4b9c31575d3d0aa0efb3848024ea95569d55b7bbcaac8b1ce4e0c6d67a4299eb192a006452b8a6d28afd854a7d2f27c910c5e4330b6f6e0abfc3177c20873b9cf093b59c73f9755eeb8b78838a0faa380befda1bd14f87a6ff49b62a80b3b30288687851c80e13019a47f776330f3fa21ec260e551c731622b515f78143eeef7d3c6fe0fbd3bdac437b7190ca2aa190ded146cbdb7691cb90ec8dbda551a76b562865df68778e073a0e67ae8710e3f4c6b7260f2ecb46a3ebd116694f7245cb04784b6cc0afa9f7c80e78fd238c7b6ac750dc495f42cca4c954b5903558933cf72d189dc3c587befcad62cb4f16a11afaaaa4d11e7d1cfd8ac7bbedaac83e457103dcdc5c4f34e84739ef9d506975ebae47b12cb589e2489f79c41dbcc2bc479fa48e34a82a69595272d3f8268ce5269a5baf9e8f5b9c08fcde4c87d2f88746d4cf4559051f51322fe1b7b7e24ede5d8fc3f80c48624f4550091320b06fc67589e79be806fa0e99253629d9c252e8cb568250da25e56e16454f42781780ef41f504f9e18f05b17a8200f78836aae7937afb613bd382846fc16973fe281004087c8a936bcf47270fa016518952d6b54a5e5d5232d1a858ef4d29f2079226d1f5b3d4f739bd95f5873ae05bd6ee9f93d594c141232181152b96238a0f5ba53be463b04f419f58149426718cec172d93b47d34767102c2d590afbd6d44f91590e181c1e186d1facf76480a232214b14f58b6cf21892d634c97209c6adddd87ab654a340925661724e90ca2ca07d0e84d2b51cc4d2204484378d8349478d33bbdb9cf8d40f336442f879248ce7b90c0830faa2df9bd05697d0b5ad2866afed4f541cc4aa9102c11e4234f67b7241f7bc1c5d984282bd5c4342eb4af04d572083b10b7c5e22be8dd2425747f59ecbd0c126f866ef22513f27962caff2b142009156ea959395567d2df93e14e31cb7cab583ffc229a986e02880169a9f3c9aa6babe9b64d1004f1efc1fa3cf273fe3ab6f202b79b95bbd9050e80208d43d1366a0a0a965f4e13d39f131b53e92a30511cd6c242024244db4aa05d1d06f0a4ece8963ea198aabfe132420e1a8259f1b750d0ab83cd63e60311b329dbc742e399ec82c06ad9468070026e311ae3e6a4c4aec74874b295ccbc5233b8504e6d76ae6e2d68c3c67d13cf8b819ebbd2866319aac698933652b9b960ab946f03c2bd12f23402c5f199c1bcbc8126aea4192ca7d34f4e2833ca3e1cd74c324d0dc1813b9d2646874c691a835ee5ee1570711d2da491454d9af19ac6e06cfac37363329375ba734e42578382b328e702abce67e5b40ca3f92a7c86e8ff3414bdbb080a1d4aac2c65171e65cf5f408615285cb5de64d1f4426847b4b28e05f21e95c4b294e9058cec78e27731874d062f2a3458600d90f1e932552ef98c488af372b3702c03d4281b85143ce55087e188286d41fce235d5a0b22b11e6475bdee1d1697221507270bd0852add7c26667a2da04ede281db1833fdedd34114d32c6755580368d63621dca13cea87bb83642a2f174279cfd95f3e2140789a3969415d8d6f2a80953802e79e5c47c7b656208370044532f55d5334870dda53a3157439813910507d34542747a59649764f71e68a071de38f1f3672e4fed1159c40226acab5544d541967ef9e14e6ed1a26929db83d1cc434c4cf13fb4d3cac0006dd8a2467de40fd998b03c383ab51fed5652a417fb60e92e09ed4a383e3c69ab21261a04315491c368f0dcbc716a1769d309f103eca05f75898266a386255d0961160120fd27976c5d6dd5b0381a827f1ea863d17214f272ad095e902804ec128380c4f7e98920cc650b7c6c831b0879715ef00430dad4c07bd63a070832e6cbf28e8ffe1eba15f83aa82b41bee879c4e4d2337a7027c01d0873be25839822b467487fd5a75f1670b6c4e1ff76ffcd7337c51836ac333bb083e145c862f52b2caa9dc5d56003efd6572526be748c33a67ea64fc5307bbb1f3c148a01b23f5e01fd2f8da0c38303f76ab0d32b74bdc19102d1f283a28c3ec6e877954d2c80f475334a7208cc7577e5908ab1fe17fa4407bc5354c24bf842a777e896c74e69b774efddd8a60d2d91abe1893a8009ce0c6a802af2c2758d28b21a9cad2418cf6ad27b759a2678fb6a9897c8538aee7b1504550f95510b5238e750987b194de9d89bfe711f06e7f25df34c295ff8728748d5445e647b35c1e451abbf64108b8d0ae5382e46e73a5be7eab41815a7ccdaaf3fa60cb20e1f94c21c1c95cb1db7b2f506d2f6bb536d6f21e72c07e94b57a1ef93e2df8d02824caac2ef9d6f8ad84a6347130ca3d3faaff9c99dbb7c58feff2d7c86a3751d50dfbb70d55d21e471d5774daac29740cadbf0f84b840c1dc5d59ad6618316736a92d06a4cbf8154b05177c7862ff07e8476064f0f093fee1919e8d722cdb6f9ad014622a8afe53f15a9825253ef1d469162c8fbc230f4641749d8f97526284e87da67aeb064c19ad65343582a194af3bdea87c06a04c9533b9d5103382693ad0f9f3343630e63ff8fe6db8488e2389dae635a0cecd631e547ac0ecbe653d703db632b1f67a474a4654565f6aa3449bf22aeb330872cee18fd9fdaede4568f1f5bf3dd646838c30247979f87f984a0f62cce851271b012799e834cb714ef48dfc8db9d7c3aff68eb5b4aef371a13ceb70aeb8321c7c9a5dec964905b1887cd687ef8be23ca6f7408cccb0b78ae314664dcf03af13f7aa07031c98a971b1d0aab4d4643bfb235c1079af7c935c35dd0e1b57ad15c493c145ddfb67c56ff66bf593129519b93cb6beabdacb9bb2c1685fc919a131194c114b18dcf8ee92bec858cf5db78e5465c5324c9d2c5818d7aa2313878c260d433e79e226d40d79aa0bb149390e111c322f9426f8a94190044726054c23699957ac2a507b09fa567c233b2e3f35d27f6ff985f6ad7c9076374c8c3794299d551421105c935da4e1683c1acd4f4bc41485653070e53f5839d330db4b76b89622919434967a88a4a79fc71e6edad521ceb7e22ee520a4a4a3cb4c0f8ab77b1dcbe6bca349eecbfc33285e3da51a69f2389f8c90d804793613ca6981f6b58794d08a508283b00c3ddad43f3a78720290a784957817b15744927194603ffaedd4684c210a13fd054d08ef3f0857b9c67fcdc5ffe8b9184da333b227c2594ff452ade65613316d1c270dc7433ea082750254af56ec0d6d9a5b47b9b22efd7a739a0fe0380095b49dbd64f926d057441d038710af88cd66863dd1315c4558853f942c8745a4918c9b4a335dd2e262eb0576ccbc89eb16cac3142735aa9662af0ddaceb3f8fc27c9c23b5a16da0af666c840269149f9204ab2a02b4f0d256f032829784045e8175d6d9170f34dfd672aedcab474cfd8230adebee42c12ca2cfe2e725d27d1451f99f602e80b697cfcc70270924a60d9a5369113d90380a162b76193b791455d87de3b5a1aae6d737035e6b7d3e1922c9dff2735cc60b6894ba06cc0b42a5556138d6266c4aea3b4e3a07dc2b109ce13fe20805d10bc3b6c9d428223058dc5183183601479a14c50ff51b32c414f45c37d763a101663c1fac4c9a5382ed1a9d6579b4ca764d5116c072da56f22be114db52559fa8ea375459909f9f9558d60b48b66f25577a414d5e970d6c7a2589acaa188847cbd53344c524ac19bed419ed050483b9b82f5703d79380492f09b4049dd5d3afcacd1ce089de4ce084eb0c8e92280daf08671222f260b304c14e11e9374a17eb4a2c455a93a53c76ae672683b0be034ca4d04e02433d9e16fa018f7f1fcdc8e904efc582fb8d20c79235f0c4b37e632673631033dcae4ea1d74195dd4b19f391c91f67b777c910bec3bd0e91f6dbbadac5c39baf495371025be261ad34ebcc59f352f5018fbcda4c7772d1cf4dfe46765294d0a50e761f003cae0f3ff88337d95210d3dc93e5c1528ad466b10d4167be0d86d3bf3a08e2b401b26cdb0e43a53f28843e9bcd27e99f51fb6d546b892aa1fb3c737f636f1f0d6eddcfe1b9e6edbca30bd15e54482a117d73a730f6739084f8e6b34e31a441b2435313cb91a4aff2fed62592e622ac0264736a6e8dd1c59baf772fe0fdf472fab008af16df5aff49f9b6f75aef4a21b80620841f81ba362293c21708a83c1c8bdd010608b3b38e73982452c833470bc1fc1e67957dd9195e73d4c0a8f1da942b2e2a51ca7488c18affa4ac8a29aac7980f2b913b7530dd03fa4a971285c5118689dd493dfd91950f13e96579c2d8389bdedeca15a527fcfeeaad0ab3f3a3ceceb5202b04706fc9e2399ca0da0cfb4a7b44563b9d430039beae367648d99cb1af42004587e21381a94cc355b2253b22ff1381fb3c6b944ef90fe9d3ab931dc34de8983c5f4c30aeb72a17f11a8248c7779437614f73e40465b78e8cbbeb76b9b64a598a6b7078ba973ddfec7b80b12f56d8f17d1fe457346179e3e7256cc2b4cfa42c3eadd2450fa7731298b8ee0f5a3d431c4072dec4b6f5b602a094efd395987f18a6cb79c534ac8a845d87bd6a4ff21a5ea127ea27f5d1b69ec99eedcc54b78e9f8fe70ae1e710881b4cb5ac04b19165b58162cb1ab555f0d345040cb651de049d3106fd4cd7ad126878e1a7e0ff107b3712e20b5e9eacf323522ac3ed86fc279a5a70d55b5a625fbd02fbfff3c55d1647396fbfdd9c0da483157ba992a4024118591326a095333a10262e675f831757a044c52194f97fb8b6fdebf8d4119c5e79052750e2b1c4ae2f0a25f7a378b9ff63a3befdab24cbae35a856ebc7c9b99602e1ef426dd99d050c4f2e128fd743efc92f3ba62bce5ecde70d9016eeeb02ff6d3c5135b96e164509d866d3bf5e5a989dc7102e83d69f6c2ca2221ede803b982b49b34cfa380e86680b1a251fef550acee8f6f76160b83d579b81c2a680e0a5738dad9d99a7057faffa21ec1b311fe5c8f2b9476b1e6a387cdf218d44518c1b56b8739b1f5a23d0d677653c1674c1557ce0ee0e85e89d14d2f4dff448a21cc8dc7808f0c49b549dcf8ddac0a3a49155a80f5fc7611eb9e5b0ff10a956dccb1e541dab0e6f43e13540b98404ec7ca2f9673d2e4f1358d8b3639554fcc1fc3bc5f0a918005502b05b460eadb4a5bcaeccf6eb4ab61f755a3484275b45e572de69bb51272edf5831cb0b15b3b79d43ea4b7962ba5d38b1d31232a61a1b3d82237157abb9a6855347b7775255fac3dde13ac0abc159780c6d19ed9ef017bed65463d8dd97011bc9096b33d6c7fad979d2c4c2f43dbffca0967d5e2e428212558694588db84611cf595a16f942ceee793aa952e7b571ae8bfca5be1e8ebd0d3d0e8ec846a2de52a1a3b9dfb1a21263ba78f1e313a1a9bfa9a70c117003717289d743960827fba7ad25d168c906abae7b0fbea972f2e80208eab8f495a46526d3fcaa4ac90d0b3eac97697f78791a4d223fc4b726206f80ec8143849eb316ac1776aed0b60380379308ddd50054b4eff7413f615babc199f22605b0dd97ed6b9349994fedf953146059abd5a8a73889f8db739f914e5e02dc3ad0f8eab7aee9b1a3f33dbfcbffc1deb09216a338fb13513aa802b67a5042cd89bbfffa98b25f2aaad09e95603c41f5c6a9a8edc6ddd16a2c18cb4d0667731db409fd047a506566db60a77c6c82f22b71f9a12b9b40eb81224e45ae5c7722cc1c356b0bb3d3da691fbcd88b45c11663db1bf083cae42d8591b66d52c36eff926dfa28a01803bd1179b3a9ea6d47e30a2032b47726f04f53c15d85bbdb5d0781ea7fde569cd6a2483b8e9d84fa3907d0af5cd5cb1449de99bf8bbf17ef71dd5f68ec9653e74f5d4551d441089f68270722145d3d37eb977307bbfbf87aa0fd60aa3dd33d6e520a6b668dd46c48c1014dec45ee84ecd385d50661d88a64605c7a7e3257bcb96c4d24184436844306f572f44d4839c0f144a56e540884652eb0dfb97abdcd11b9e6f7a4b2a367e921915b02323c0cbc35ab2049e50dbd0909430e2e39876cee4d8c5990c397e6ace80fc4f535fbcf247768aa91e6726f79388f166161be46acc37acffc9c4a67708fc0b2e56ca63f3b086741df636178c983907048e9d92bd3280ef0be073bebfce1084b8e5d2428687bafdf54df77550b064e4eb35341c1858688a331a4737e06f154dcb8b3ae963f18aa3efc2945a1310505dcb6851483a4698370a125956953da9e0608976eb0cd626fcd22e871d77042aaf4d800255b4945679cd50635e35b99c6bab04dfbe43ab21f424cdbe4209f0767651ae9b6b12514cb86316a26a7108e62ad29d43f5e9be40d5d28f5fb462ae1e9981e84f441a70e3f0ed038ddae40b6a5d1b6f1a9c5aaf1d9c3fb9ef36d96d71b7f4e456acbd107efc37d0faad041e35afaf9988f7e011fa365775d83e7b480e4bf22627349ce56fe243555345bf360691052365c670eeaa8dbdfbbf2b69af53cf4c0d128b26b919f5fe22d577ea92334a1ed69e1af1ff9759150c46a86a824f3fc847671e24888ca805b53fea007bf2820f4309c7802ad5ea9d44064b37e0e323b80dc7af90f28b9ab1e70ccd6608da01873c99d7cf7c14c70fcdf36a905a609913d9151f360a84bcc804256c831a04cc10656827b0a46bf194c63f06fb105843b696c120ebb1a1eda91a85c4d681f07a4f9cccf45f47f944f4952e99372bfda15f53faedad50c0afabc135b8a266a6f368d082aa27cb1a44a593d9c980de02b8d983f14aefbb86486bafa04cc0491f58eebda90554a575e278096611f0f75ccc2f297cc2e8b26f8470547d696d84762e3b5a602b55c39aab895eae86cea1242b97818f298f54e1b3d2ec0546185e01acd40cf0ea90c59bff6c90c6011e28fb1363c3271f5719c4acfae3ad5de63893b1fd6ae72db3798033032e0404810aecd8e41b467411c9c41a42df4993a0bfae08b1c90c256f917c76cef8734537cc9425d9de9bdc3c77471c7291be14543fdca9390f64091b40bfadb72bb858e4f283cf3976aff9c60a3aa863195751d589cabfe80ff5e5dc6c8abdcb00a3e6ebcfcc1ef02818e9838dfdcdd915617cf113f050c247888275db9547aed90702808117e3124450226f76f7f898173c0235fc7c40ec2046f0b2151fdd7d03c69891f5b91104d249e7180b38a99a6a68f97d89cf0c052f2b509e2f2d281a4cea20351501a7c6780176a0b9a721058ec9d6b2bf1cb7f94c6b4ea5e9cd6bdfaca105da85577723d69bbfcb6f97f7faa4a637f6488b6996c7bfcae920b32e601259fb796c9791ba51bddec1d93bf15098522aecc56fc6f533c69c9d84d199a5a09451269426d8ca8cf9e8c985a4a76ed2d89a2d16e6e7c7a0a4e789b7576bcfa806e46bd94464ed65f733b136c98becd24eab7254e6b7f5136f7fdb70a68a209dc9dd503b5fa76e4276509c11534254303fcb87bf597723b342bb017585dcd137910ce3cb5fabada732df766fa33ff6ab056573e35eae2d986d25534953171eea49596e07b95e84a674906f5f556ef599d47649d0b0268df8e3284f1855226a5ec22987f0d423ddcf7cec1ca7a5ec31b5445a36508dc00809adb16827b2399d33406ebd83eebc48742a32dbf8ee3e9743a352bd8774d4e4b8d07408b854a521f6ae468845e8d359047b7bb711d2481543b047363552babdd751f6a7896682b3471b53cbd19496f39057d08ea984f66a2e5250aa2fe8e0ec491366423b7921f1943ef83274e54de2d9ec1ad2eacbfa1d297d91fc3a4d2e31578ef703cc1b9bd188adc3904316c4264f4ba4b371fb4943ed2ec99cc565a0fc1b07e2d9a0948758743bc796c1ce79edfcb77d62e2fcf1c7629a5e017723255d267a23d091d08913189f5c7ca011294ef77c4edeb84cf8dbec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
