<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4f781ac7eafce86f6337bf3318aff6a88c92c738722dba4f66548360ad619e0d92fc52bdc59a67dd3d9930fdf328ff37d248d5f26620b969c883aee8d86daf8118d5c975b04286adaf0a18f62fa7a0c8971f0d5f78221c978c48254cda9e00a1c6f9a5f653d3ef9fafffe2a76f8ce8f3e2cae7ded29b0c2190e5b94e43b224c9666590da258f5d53943884720126d203ffdc703a440d0f737508d87342b81a68feec6ed68bc1c9fa9ae1f32070232bffe2de7710a31e8414ee984c414fa771718b4c27ee395cd5a1d2e8e274343bf38866383848cc0fc1c20c93b306ed9d44e51ec256572760f179f15fc0e9ac7e3eb4e88de55aa33be8cb35bf7bab86f5f14557c2b745abccaea433250e0782c06151ed97425659fa95b371c1e6345416e114e229495eaf4abdbe5bce0b425a1ce541dd73b6523a1b9e12c2b460c99c5e4b17f421b4555726182a1d94d127d42936920533c73b361af0820f4e978c6f4afc022a66e7c4bd84c358d661fa96c916e2dfa3741ee2b900e9f4507fa4dde39b06282dc3df6c5923cfa3bf7fd8fb085cd8b0c3aefdf5acba4aa5d9e4453d1d4d429e06fb447b73567da91ae010fdf4dcfe0213c7e057531848d292f8d2cbf7852f7039d59e50efd3278e8921e343dcb8ff40f8bcd6b6576e7472e2fd7076ec71405c28a954abc5404ce6d69f864cc781d023b1f63ae8e6739ff1ca80c06cc8496fe61383a96f8de958e815578ffa2071967f5709c69b54dcf3e0371efa68a1e0ff4c00550777ac9c8395419fda55d750aa8aba8edeadd4580e00ac6a56af5855fdd351c547429867ca4681e29a38c90c907db70cd08a37475d09d418e1320b7197634ea021f95d5f28c2d7d776e99912b52a1a0a0332b7b521b6fdbcc5557ee0f10b5d2dc8677807536218be693cd1856d3e4787c514e0f8e7d776fe58e5c7c57aab0a223c02b5122dc4460872bccb5d9a3d225c5a9a2fb6cf81fac5f8bba8861ef909b7d4c6c86058a35f4fdc9222a73d1dd1a80d3ca60fa1d90a59c7b3a1f2301bdca534aff838b84282c01b87452056c8bae68e2e419e23f057c33339c39bfcbbbe4130ad87675a0503dd9d4e364d5880b44ab5c5bcae3985a699151797f3de61dc3d3d6e3a05c791a58b074812af241169474ef44d93f6241842a1c5ff45c4605e9489cd2dd3e32d0ed6f5991712d6d86f2a764bf796363cbfcc6e0191a658274cfcf846d320bb443af798034c3f1a947301f44c23ec135ba90d3217dab0a90d3667c60482a4605c6e637be3351384e9ac715f9d8a91ca88b171981554bb3279331cf967f8b56a83b5ca68ccf40d1df59030abec6ae961264e2eae9dfc014609f68c3a5ce592b5fd74db6831086ff151e8142dd10b908ec4ebcb73014b55768d5532a5def5722bc673b87526061e4810aa26109e68a7c8c0e6c6e570a247089e929832e200455428c9acd18d8c418cb66915ad729f7321201abc774e9e1bc1cb5696e53c0cff231b8b395c9a00685cffbeabfddabf1d4331d03c0dbcdd33e1068c77bf3b2fc6f8a5657791180cd6c48ee95eb3d9b9b8a5da653c63f278d4939b2aa3cb095c9f1c25e30ce7ba2b112e70a87b80c49d1abd2b1d1ae2e7f91809fbdec78b5e75854f23b40245734ec31f92719ba94e023c3de51ca85b3abaa48918045f46c71fc417b7851bca808d0d7e30cdf63552a24a4c52f5bc257c49dc9ab8e7e19952592c8db62feb8c9d9118313eabcfa03b6cdfdeeb4b59a5bc6621446ce3e6b00d2ac37b9811f2b82e4a380c58ded30a1991f66fbfa402af2fa8babfbad357be284330c0d164dc32a357166289485971a04b7a3c74ab9af690245fb35860bc6204225fd232adb5a648c8057081a0d3c5b181ca8abdefb6df8dac84c7e2012abf6e326693bdab67583ea3c7b14d5f2d875c0cbefdbfb68cf94fef0d1fd39f0c282b8fce990926e31cbeff7161f774da57cea5a7bab319d59dbf4ee862cc19a3ecc8ecc49e4ded8ed2cad575c1bf3c42a9ad5c1ffb6d34a7ea274ab08a9ce5d08d3d546fdc227ed3ae98a97803900cd738f018d1e67b06a7843bda40ef26ca456c10296a3245531de3a3661d1b1932c1a69d435f917b1801ea3f251cea051afae2b3a2f228922a3b9feae67acf6a73ed5b179ce2ac524ccb5b259838ec46c0292e461fb515b8b7f30bf7817784bfeef7db44a17833c6ccecfa7f599bc5424b8a95ed2b7e767d3e8379b8bf9dc97e599459fcb8aa3cd73635c7c1a6b3d92ef6cae895a1e1ec27afd45d982b87cfcb97762c4555d17a947032aeac12b5b726ca4df7955e4c2bbe3c68bbab882e1617d7163cd7acb4df79d1c719173ed7b02ef348ab0cd8ed400ecc7b87ef7349bd91031d9fceab52fb0a26035483807e6ba7e8f91c867d4ccfb5432f07aaf2e67da0b7e8264bfb96a5385a5b7e8fd6aa4fa7ef99154d8b0dc0a9482bafcade8220a475e6fc1ee94ca34b05418594bab5d73dda05295b9d68c7e9be525ae346393b3cedf0fedaca5010da359e6f67a1e573b8581aaf1c262fb2b371acf79ed9e1924c67ed6d4cc8938b52eb56e3367ec7610d4bfec94b9c2964fcd61a37d9c88aea260e5e80e647129d9614d2dc3735fb8eb130d75eec7ab3705615c97f752f1d73858e5841a460b53f97f11c532e222cb71ef2bcbb5f98f3d15e8e03c1bdf7155bd2e1761fd99d8a978a76d5dce2559acf237d3dbf316fb69da8c93f3223ebec1876c9c3f94efe2d637282349eb2a1478853499c87b56ae4237b73bebaa36dda5070585be3fa47c306f4e6ec95232848ccbac95375bd9e3bcd14e5d86ab5bff17785afaaf0f457c14b06836615d8e1a9794b7d9e7dd497636283c6c6225bd3ad44777b7bd5fa06707e16777336a89dd66ddad2e4ac0f2a079d4445b99553c9f6d8e71c9869cdc8d22edf63fddeaba9b013e0f986abec44bd4ea40e7164cb38fa18b72b4b656c955fddffdaedf1def6d8380157e28db9dcef9671d2261f638fb1119317f978ea7caa10ea2bf2341113e6c2cef7f3973debe34d925eddaf9b350ccf33e07acb223e98fea750986347ac108d553859128d141c3b6422338122b12ac41544fa4db0fefe1478c4f5be2a645eb51c79aa28e874c3358bc450dd20f0e1016638b4d37011575cfa75953edc6171ee097f38c9f077be4282d9943970eaf297a988f8f7e0d469cb611cf10ee4861f23fde7de0199d92ea18ec6cfe36b500038ecff6263767a6a38146f6674546a8227bfe3feff7b69c93116c5579d224681e4a73f34fca713ce69f8dd1f03b655b513ab255c5291e8d807ce8f5b8d3e529b5cc5d0ffa1600df2a4847a7124cff85dc45279ad72a73a1be07522aa9acb5f23630f35bb88d4adf56b75965b5bc8160cdcf2a0e4538d328f612d38bf1ce7bdfa89014cca8497e0811ae2ead40908928b3df5484fa752340f6e9e73918de6cd84ae5e70bee025e260b6dea56d50d04e1be354054bc9e657ef51935b046ebe3fb7f046f8664fbf0ebb679eeb1d4fd55fc895f24eec2552c7e9ed4774358edf32205b987d391bd9a1369fba9964003f23c876f4aa362a3681f1a293aa3d4fa53dcca532aac4c7ce1aa50e1a01f82bdcd2b40ef466d24a080032ec8d5ea20a13deabbcc2da872f420df9445bf67c0701af40dad72b82fa4a5ae2471fe1cbf3b87d92b2c395244d638c3538f6798b14ac6a84c31d4fc89d704b35ac58dd27b5043542bab58d3a2ec83a9b45cfac157e4e42f6c3f2661cf4580525e8e8d7f53120bc8a8feca70dc2424d04650a3973f4e6760e71688b0b22e8fbd26443d8cddd82ade20aee5bbbf3e52a66fd4b5ed5f8b1debf53ee23cf8c6445dc59d7a1afefabbe24dd0b4c31bd336e0ad6d3695713cd9c2cdb3d571e3303991270a9cb25ad9eb79fb5872961d878495607b083244129ff066c174b04ef515130f2d2b8899143e8b89c9dd06312b52244f27ea62f51b9a89467359f73dfd4048647965b22d1d6ac1eef6782d8309f332ba2493bd1a4b4a5977bf6c7d76dda2749c71553543649d1892896764bef9b87c1708a21a4fd484acf3e2df07a5a7a8e8fb8805148f8ccde403d567ea709b56c61427bd95a96c671cabc9f888531fad427f40a4962494321243b496d342ab6341d0723935ffe7d32d6e101738e704ecdc521e2d274d43a6ce36500558158a5c4bf4e9b80cc7404c874ef523abba4890af07b49640980e6cf93d5ada1c5f06ccefe1f505cc9348245f7a044d7286251ba362c1ec88e3e2d641d59d632b6fa18b38b91fff56e9ddb250e26f7fdfa88ebed79b73fe6c616d889dad814868337fe40e022128c64fc23f3fd560102a37d271607add4cec6351fa86a661b03500eb832b050a3aad15b636b6ba46f0ad96c7a9881af7dbf7b5e538679b2cc3f0b0e2f966e9b2f219255e8167e78ac21c4638fd18511bfe32ad3a1e59e216d4ccb7d834f62bed87c2f6d0cde13f72522980cfcc4a0da4ef9c09c03e02a6bf9c164c7fefeefb5fce6c6d6b7355a2eb3a34ff0325aad4a97c6a2f6b6a489c74caebc883ecce31ce429a192986cbbbd2970bdce20171740a66f2b6fc3d240e9c65562061379005fe8cd48f5448f4176c8413d9b35609dfa725423d2a562b57956145b0a5402d6500862ac25c186bc2739f525e22c065caab9ac0d8766d4e9f61b07d5a45d4da8328281b667e6cdca3920c518f229cd5acbcaca53522214e66cf66d1579505682ce31c617bb0b2ece4aec3c81f9f58d09f4509902a7f0d98d756113792f30943e436728f12b75d902210c53c9461d8ee415f07aaf3f148325cda54ed3f9a33e0ff5368c1877ae3f80a233eca5be5b194c0553f23817c62529304ea3d4485d7d589aa295c1e4efca1362a84aa5359b923bbe086147d9c81df31a46ae4f2b51199a02e57eb0bd21decb84d8b4a6bf0685681affd1d78d34b39f974023ec8e8178d91888a7f3acdf8dd88ea668568cc9779bc8e9244136390ff6b955611e2479e633ff25c1aaa51c1c0a100c392c4c2948991ea55910c2f9866cb92155274242cb0a1c7c03293225b9f7e9e9e0ec70bfa86f391c11f30bbff2cd4e3a84a73ab9f96267ee81f82c0ac3c343513ec6cdfdbb1e0a26273e7e08260fc3dd1d032e47079de628408836560a28c5854dd2e66f45041f0d736de482adee93b5ab730f624e3ec5fba959671e923e261492a3a698fac10bba8d70e0f24df41b55483963a9fca97a980f6ec2411088ba18cc6679d52e1f528e5bd43b8f966d3d6b6e0dc79b57a60fd99b464c26734735a339b624097aab70079d746789c628207a7a2d86d9c28187ecbb2c6656e4a66317fc550959ab8878804d98aea933f85c368cc40345353ea3877bbdb1f736c808b31d26e23e73bf0eef1b819f72b299a384ce8074fae84959ba4504aaf112454ab73c4cc038635dde8318bad1ea429b1c051cc97fb4ff19809347e8842fa4d1e24a19286eb3ff5585d9f3190871c1b7c923eef473af264cabc33b023d4ea32a94032985f40dac4d1d92099e7ddda13f6eac4c5d232c2da0b5c590c2febcc596b566efc2acb3d0daa9383b501f24c1741e126115f066140ff327c7a319bb1787636635d45be8ab08e0ecba971a0f39b69c185ae5b9e4ddcddecc6b28ea0e540c3851c7c175e18b13353cbb5b1c3659209264fce5b84ac3c1505ea073ed637eb6d3c502ecabb1e39d499658c4e82faedc712c5b316b5c8ebbfbe66f0dc7cfb97cff6bbe36a0a0025412a2ee352f67d0d5d25fd2f02d09d2c1bf777e87d5c2a28c10eeac549978d0d84e5817e1c027c0840469f884fece4e64a364fd9e45bf0938d9eaaa67baa2f0e28ce150602dbd154c12bbb11288c5504ad2f20a95c44a0058f370501a2b69143a6ed109129edffdea80d6b07b3ecbc297c528f40c1b44526c5abc6f3ea11f3600d50ca42e9839f700efc7e84706e2f4353a4d0785a19f3713234850b5c8ade0cc4dd798fd150d6459ac7095662e4602c4f29d6d907b2d63c233692c565b3f3b7738f66d0c7f651b1503d24cfe325097ff25f69faabd8845b90c0646ef7a485c2350f218fe4ce6f62e6af8b0d5a151bf5501b875f2dc3bbe7b1acf4b4af958e840c61a2fee3b3fdecc6baf4a33e87c1e353b5fdf290e10165c9cce74fbfe0d0ae7a3b0da9e9cdb8c811df604c394c1ee60a43e95dc0e63f6806cbff6538117479d39e965f49bc647679f3eed0e964918bb208f7ad445c8bacc7717d01842e5c67b632d4f37b29a10c29e36b14259e327c15ff101dac369293f3958211ab8574bf89e5267d2b1386853b367bdd26deb5a7c0e64964be23fba57eec97122f3d18ec6ae5f1ffe7b465a0d53b4a413ad213517ace654ec7feba1c35f6ba63ebab846b1c531b9d2debd42d6205c37b3c79a86486e461a442631c405cb9d905f1711120e367da25e5b3c12a3487fb901ef2eb743bf49fdbd352c5a9b753e748dc190f8c2ad11a519c31c6e34854481b667cf15fc986779a52c83273eb33608caa56e0293845ff96037bc0a7c886c320523417798dce4df1e92eae77a3f746a487819811dd0016c067c639038b9c55836c95aa1c893ae3ecb269d59e2fda460f78fe3da351f494e54429f329c09c7a624163b77ac816a8ed7c7759cd491a6a704925f207de71323a493bfd087f3b94fc2e04e9c5b270a2e3e05d7a859a1f71add1898fdb5ae40f2ec18032a4ae4a98a58a768db26f4679b9facddb36d0c66b63a0628de0a26a4069bf3dc7188f0320c18070d655daa6573f587d3960b54d542c1e1ba65d62cd919885c1f364f1217e402ae59e79fde7ab71f184e338b863ad6a2c0e29f4446a4229e1560627f24ed082429ec2eaaf5497f648eab218bfcc1b8a76abd7adc543e01947ff6660f3ac1d263bf4026e6fa3b535cded802e9de3c78b38427d97ab7f2dd6cb2b2fac7fa38f8651acd5fb5c9308f49ade8d1ebbf370a952e7fcfc8e044b982e1712312aaf25d6ffb2bebbd8773de6bfe03614f86ea05dc46c53dabe80e3dd6c1d2da5b7296fdccfbe8e8e86e6ac763294b4eb7892e0d2cc5b24dc7fd85415935c27aefdd91fd7748fae5dfb2cbf6c95316eecc98901786f43246f53a9df5362d4bffa61a8c494b47cd533f13dff1dc79f390559c6ba70e3f24def9e84bef7a5a72bca0c91c3a7b376a6aa6b76236b60182208cb14ad3b0d3805848215868b214f591bfd108b73be5b84b13ece460ccfb05d3b794520ad127721c2b85a283c465ce3abc1f73908611454da9d7205873362ffe536bb3615b01931cf130086296d7026a5039bac2cc07f810403e7191b425e6b0ac908fc8c838a4a0e983e973b23f286c23a8c33b31ec5e0c2adcab6f97756111d7c164acff4dff9186cb8e9c52bbda27858054e882996af1f7ead9f7c6f3db06e7b2819e2866610423e5b896ac2c8f688cf85262c0b2ced92e1f74cac7449b97d9d986d3e6bbc82486e5bd3a8a4ddee97f9f04f71a0e8e69f939047300cb902d89146ba0b616e53221cbb7d78ad35c5c254d87a7763c70247e1d3b2deff059577d4dbdf8924a257b81f8a3ac34c3777bec74d459e91238358728adc06b46433e5266c354c6e1cc7e7efa0c45f02db28319560d404811e492b84c438b62c5c4bb2580739d86d02053cdab9847c4e6a4c2545800097563acb6c39cc42041e65e4f08682cad5dc64e58d70c19d42bbd50f31d084b8a261011f172f2c06618fc135103ddbf041f2df6f99c0f41fb7e99698aebee6656cb089f15069b0fec6981177c652dbb3f42a869abfab359c542d476dee4c3dee37c1b35b5ede9260e03b232986bfd8febcc4a94f1df7130b6d4f0632ae8e98835b6cb45431594dc00aca814e14cc2f9ec3dbdd7a57afb90c6fdd0b95cee3d9ddb9c72cd4dfcc00cf23a80b25296cf2f1ec2f07652f3d80c0119b2af4cd3d45d9b1d4cf565fc293443d32854059b239c90b56fcab8d3771d56ad7a71b5dcca2ca8d27f5fdf7cdac5608292f6a460b2a39da54249dedf3975bca4752678565266de22f1e043e2b2c5b803c3f03577e640a0e9b445933ed1523e818f7ab335c984570fc1f0d8f7041f9e2dce7baae02d437e90b2b61e5982661d00364e3efbddb81471fcd653186bc210c9220c8a9e98b8073cccbcee65ab9c9ba0cf7f36c9cda11bfb5f963d63e4afd1514ac81dc56e3803b145dc9d7c65fea3739351057daeee555c80537442f05bedb0866d940c8ce53585721d0507194ac9a208ee61797eeb35bd04906480f91c92e5bb47887603c990c575780670ceeda319b3f4839a98243f9eef1e1183932e7ba31150f8373382ca27e23904fa9b84295eabdc58fb316ace0fe1c86355654c2fac00e4479b9c68968d604c23a55b76cf2f7390165074564d828d19b9089e9a83b41a2a5cab0dca2346b6fae22d24d2ef8828e4d61c5fc5006d55d8981dec4c56d8649e45767fda5ab9ed547415c0fe4d372bb44f95a0b18cef3e043dc80779680b043285264c729178477c180e669436690fda50d28f4242b7bd81457f0875906c4c446db2260d64a7e23335af77334dc6450b4db71e7133b29ceed2296ed90835bba57ecc24df1447651cc1c4bf8d4280d387efb2287bf5cf7926747487ef431b544a3bb22c672a8b89d26e3eef93c3af428f36c2931ca5255e334b0a633060dbb9f5ee3dbfd9f88ca059ccd5eaacc8b1345069a1a1545027e9782e29da8842c343ff0265c2fcca6c29ef63221a14c2fdb39383059a221c02ab2bc4179e4b6f8b4389609a245d60f02dc4c2766562a00407f8b7f2b7bbe11e14b3fd4c86a4c77f130d7a7b794268bae99177737692e8cef028932c40e5ef522b682f6d6f8c9410493da25ae0bd82066697d35dd43e2ab05df3c18ce05f0a88bba52682c50c3517a926d0b60f7a6fc91c6bf2f836fcb08d6562cb9cbe547f1974b0d439f544f114ee034ed5c1d02ba6681521b99c0b915230bc4e3351ee122c7d3d61a7856e59946f4cf765884e13ee486801edabbb07933d207e7f5dc4684ba5a58bf21ce30613ff5a92e3a637ddbbf503ab0751a7be106e16dbcc76f2a783ff3692e6f90f017bcee79641defc978b5fd479100501316ad7c6b0e6fd244b6f72220c69868c49c8c4753557a85906f75de3ab11d49f0f2e102c2f42dadb02fefed1c8217d000ad230e1d3507ba79471def3b58ed0f3b2e96963fd83815256d9ca45e79a90b1318c45ebc835d110b42d515d9dc43f2e9f2750811b94866cc8bd147bbadd405ff841e846cc1076209cd5fcec6811ae91f326b4c5e8b64b490772034198fbad49427d0f99ccd1b01190db7e9f41681f8b4981fb8eecd1c24881797ab107540862abb71fd889aca1177f3567ead21aa1479ba002c6012bfe6ef0892adebe549d29ba52e850882befc5b7641793345bbbc59438c05e6c5a2d55f4bed406812b8d27985b88b18803dceecee1a8064bb8a1d7fe526fe8f39564d37654d160caa46655c9b02a22a55ac281a7a03a875297d07c9d857e14c0a1108d510f2d071053ad0d3a37a28c872fa60716fdc3ef7a1164d521e3f72dbdd6b5aa042668a30d2744b237c67719bc4f9b794486b46898dc5466aa269ebe3e4a384b7143eb21d6e893d5a50daaa2062abc3c337cbd214c1f4d3c2a59ed92db85ad045097bf0ddad987f64fc5999509ac9e74d2fde463bd9d3e8fd78f71335ca7e3d7b9f286444098e942a462d63cc4eaa06af8fac75ac6279d60d57ef80760abec9c18e2571d12346b336c741360afd9fe9f9616640b92b663f4a1a44ac7a57cd23508450866ef5d01212f39ce1b42d9c5fecf3029231d8da9d9e81d7347acb6b0aad38bd12740dc894ecef166ac6326cb2d2beb8cec1961b785ebc24712e14dae172dda5b06ea306759aa15657af664f7cf2f46f68085a4c10ab34c92c81dc5ccca08a14194272dbb6cc3215392b24731281ef5ccdb0d92623acc766c0eec1e4dfb8f0e6f5142c1ff913f8a8eaa81ebf7d31be125d64588a89be128e08662f356502a89ccf3b0713282223218ee9a0f68fa034f7d85db3da58b5bde77f632d5ba2380390ff990cdfac8c1a283bb84e7f993dfa634bbb7c57cc350917107282d911507792c6d1bbd5c7f39b9b8a7ce0794400828de4d824d30e06792f408cd05b94f78c2fd1ce2c9166e9df258ecb8793a6d5c7f5b98d1d11f21f1e169b62f0a0fe2c1e5771f198dd82a33ecd0e464b65c6e3947503101927d54475b445823127ac80ac8076f0fb1e6c0b3e284fc2eff8bd8794143e755a3b26fb10079a3c53b8305f51bea40b72a5cefeeed186eff2643300ecb9ad3609a46adaa3ae03ce9f782c728d8f3b33c0035a83972983108ba57ba643425361607cfe437ee2bed0b15a7857df478868bf547811b2f645343a484de312d77a12dc2624e18513fb13761f6d672b8dbbf388d2405f24a1992658f19e0412743705fb6cadeb6b535a26960d3be461d862776fcabf53970b0f60ad6fff571647d16f105a6c608c43d775850a3a2cbe5074da5596589a7095b3dc90f8bb67cb031fad2b35c2f13a5408194dc9e32f403a8ff1940a89f886cdb43368a6c03053f9d366196de520112bbec335ff7b3cfeb547d4d5d1bbdd792ec9e80b429f9a87cd53043b53ff4b1c91136bc6bc40b776440f395123d02e55f94ca26be0b5b6eea8819fa139a67f359f6e2311a429c8601bd063b2608572dad45527365f30669fee4de52b99988918daa574ca7637d4817bfd9796609e611bbfb45a0a418fd22578f351244549e6edb5d2584768dfa4ba479766c8e1f34ba767b6918cdc251e957dcc61b418076b0afc1dcddba2cda88b6a1f1e513c750c90b1f6891e7cc3d4810aeda4f0b88a554e554936cf64b51f9a3c83acad23d81f25ea8e9138572d9fb211bb801cc7c361f2c3f980aef7ba09da0365c50005a1a9784b396d1e4c2a6c603e7da9e62e7765d5ffa9fa73c590ea976ba58e087876f1152e953d154349a602c3aae86d5465bc4902f985e839e349a03dc4b8c7ed69eb287b7d5357bd5c71c8031266c5290950b7cb62f7df139f75dc8f703f4f1fae3bb6e6d6f4947c27a945bd035b9a1a193b9b942ad95aa3dfe98f6e63ca5eae21e7ba89f58f31b2014fbaa8f1391ff0b817ccc71232252e7885813310539e51b2081ac6885a9b33ffb83e514af5ff66da67669752f132c8374c279481406ac7465baf40b22b43a3a80e563b6da40ec05cd04b8d39f5533424f196b0f68b4f3410cda07f6cae5de1d39843e78671ad49b2f50ec6a59f76f2dd865f463605bfced93c9955c35f2fdfa1f34e3a88c50a07c8ac6cfb7c8232cb399282a1c0b5a6d6dfefc8bf73d1ea22ee21554896de5d92d9877fa97185f0b3f7b1cd08252080fed325ec5a1e7f29d53d65e6d27d96783917eabf7b64eafe4addcbfb41ecc47dffac2bd1a207826f96c9a30433c6bafe0e0ebc1d7787308375ff7bc5b85c4d5f64822e213d74c79e913f28444fd6751b38fca1d01928194fa84c68730626479d255f6b65a4e104336a982b84302494662854882c00d01ddd55fc9093f34eed9c0d525eba54e7503499010b2044be519a8f94475ec9f43c7bb24149470c9ebd8c1b0c5b318f40341181642209b5c27342f1e171775b945dc1597f3e9fa7af96249c9dcf0a5fbe77707e4de84388aff114fab5dbcf9594e6b9f74c8ad90a184e2a2183ff495a619985664b8a864f858936f777bb742ce659c980975fab692362d00579d1f29cb2fd9b93b75630b9056ae4e52dc72bbaec427cb5c5a71135f55753d2e8551db32cc897cdd05ff1d76ebf07d07d3d84c88fee641b82f18bb6221de027d384f209a143999c06ef27010a4ddf242670e14f856edc61224234e2b7afb84f0211877d1c3e39f2d4413e48d7ed02f04c3f1a96086e50b74c8b06d9ebbad039e7ebd287712c749f9113035810246e7826f5160472e88d8cf37b10ccad30709ccb9e0033a9a9a093a2c7f567672b5e933a8a5f67a98c80901cce6a5536efd8d02e1d935ae67f89b98189d203ce46a69cc7ef23d2a0da79508753be4854a3661acb41cc757263f4196e82327b965da05fcfdabec3d399c8e658303c9935b86e505dcee189c1508074c78142ee717ef7c71e426ece73643571f938c4351947585ffb1b0e4abed3f2cb37773a51cb44d58fd1e63142c159ed0579d94d890829180896c980b2fa442f4cdc49f2915bee48dcbf09a296c7c07176f75fcbcdc72814268472a67e9a8e8232939138039dc92cbf64260edb7f781c9d891b7b50e6311ec1fee7f873431eee3010d0ce98c899cb459585832671f59fc883a367b0afad240d09e7735d46311170279c1d67aab0ffd266f80dd6e244beb424f0268239772c0c1040a6137643364480f376f487bd976c445cb8c881c245a72a7fd9223d2f0105c249c80e2b1efa733862cd8142bb23e8d92e1d44614e3a7f5379728349fa47b082e6a3ff26988efd6b20f34e1231711910488f7090957ae271e7bcf976354c13bfbecb7b070b063dcc2d19df3e9ef753f5d16070b96c4fcba0b5b75d00361991474fb38940d199f4c64186b5f36353b28a9617d9d9a98fd3cb804e536b81bec410e99c2cd13ac18b48b1dfea1549dc37ab9365e730fed6b85987ca82cc93377dc75eb097e6eac743dbf76105bd856ecefd2b2bc9755dce1a62c539be5138d791c1b1a3060185d7780c9cd7a92d88a3bace3acbde2d1aba71cf35a1e3a95608b45d59579de72143e3d89839d288b88ceb63f41e2409ea9cd0dfccfaae7169321f24fd3d052d91c056a1995c2cfb2f62e410ca528f576655fc91f7f82fced3fe05c0a129d58b928451c2b04b8a08ef63e21d9d8a621364ce720cb8640d5c35a9fab405c4404f18e5510112a50d2dde04727d5a752c355aab13f4f098e03bcc24dccb5ef87769a6eebad40753ef4a4eb496b5962c537ceddaeca5ef76432247b5a6f7719c6b67c412b5ab9640f02bb9b48f362ed0bf9239754eef5758bb550aedb4d078df174759fe852fe8a411110647911bb3765752ec17c6e22b8cbd3ab6bd71cb79db4c72882f8a1a683acc4b1747a8a915d958cbfd705bcac25bf1a81fb0f720be932954d0ee184dd19d04ab0a92017ede1c6270fe818f9d22db968889aaf1f270696ca893b1cc1e2786df660317c3d0c7fc3c19f5bab6ebe482ba6bdc80c213ad394dd685f6874ea92d4e3f966d6ffbe99655080b49b2c3c0238e595422e594cf5b306225d9c9333d4897a6ffddc1d44e97ec62aee9b0e4551e9ee4359906c0ab38c3bf675fd1ab60f9693ea1d79354cdff4ff2d02c58fffc7bb08c53a3571cfe5fba183444b53c4ddf9f963897ff06d438ea702a2bf135864c45e9be7fa6de45338ed71373ac41a0aa291795d905d20bb6cc920f4dbedea8d80af5e91fb2f47f50dadc3a91848d267bb7e05fac864193b5f57a1152f281b95527668a54b29cdeaa902e52cc6312f4c52c764cb442ccdfd4c97d9e35b69a0f56e31794c7d616696112cc9f9ec0d400373713b57204714500c5c7391cbc7ad2cd781747b9318ec1d28e878888de98ff0d6fa157b9c3f11aa3fdac040175f3daa3caca72fd8d1613d10dc5360851e0514ab920a7e0e5d8251f82493d879c338ef8387693d8e14b5e013238500cbaf797e9f842aa0377f8bfdf27cd80711009d37c3d9081d57adf398027d65ec15d64b1137980adee71f99e5544d8276e5e56f842e309e795eae1ba86940f9305ae9d5553a79594bc7d8a07b6bc4066b22f6682e6e9588043d31002b65383e3e869e4855bf700e523bd83697de3c770dd1952b61951a63e533a8aabc75e7ef950cf87ad1735dfa07f0f96a0f54f541275aa58e4fd29f34a3a47a3c1340cd4fb02368f91a6f6ae8d371787203da3efe9eb07fbb41116abc15367d9d67ef0bbc84c04c6004c87bbae2d4aa1aca394917a2179b2707497f60808392d94fe8f47858e31ee144e5386812d11455fdf3de8284cdea48c7eda9a533b02e5ab077b831ad739469e1c181c8738921d7c76166075c027c31fdc50b381d3a1fe7426ab2a0f65fd44f8782007be7ab7a53064e57dc4f5718dd4702781fa798e011c39502be92fd608710b783e058ccdcd881a2474845821b21ebfee926fe3256c551dfc1eb95817ec4131998a30ab73681c9e1aff1518b60598a847f64f1034dfef0ffee9249b09e2a3e39de0d7689a2e3e37e0a4fcbc42061a9238feec5a621cf2efaefba0a5eefb5b762b4ff5b39b93f3b1d7628cdc037ef8349c558624b77a6cc18f0655f0346428d425c65a95f39e34f3fe800ae08ac108fed9198830ba6b23a6da60978e157cbdeb634b8cc887400951d22ad918890352ab9de1cfa1252590193664e41d9b61853e7c3404e8c28ca77cb05e91a379854d618649ca52c8f2f603bb669c6c01083c3a9355f8367e8cd71c9efad1c01364d06851973a9eb703186f29a308ed04af5bcda907af105d6ae495725effee169955ce50646579adafaaba2d56c876580f9efa46b60a1b4c137bad49a35be3c53c662b11b0ac01d8fbb74ce067e0dbb674b4ae7a4519c1552d1ee32662ef818d64eccfc0686139e10540791c52b3f90aa2b71c9d044e159b55b7cedf011d5ad74d472882e21a0b60c0c9ad9d0e2acac56a2df5fbd83e2ff1a7af5c2fa62ee0bb9784abfa838a17b0fea481290fbc8b46c304fa1bd0fce8a72b1acc09740cc3ccc77e658c9da7c59789de7db51e99a1112e1da309186b8b7a08a0df47ddfe82f0531042bc8a069be062670569725db84a4911982b6363b4673d6226021c0ef7a737d697437b188b327dfc47345ef4307f516b251b5235295dfc3d9493dcef6ff93c2d37affd9b3ff5892711fe322cbc9935c99e4d9415abf41cba7324003667b96579f11f00cd0fdc00bcc03ea8a823a1a2643db388f88f5f5d4ca9af273512d75da812ab5f921c49d22b66f965eaafea4472561a936987d00172c24281da898c61cd22f63936ad479ef460a95ab714581f72395724ed8eab9e2d3f6a76799c7f4a56593495e733a150ac048743809002df59ba2d5345d7e77f9e8060c55a5f87d2d12f4176d138e1acfb46010fbb7bdaa84d1126ae81a435f4ee6b81ffbe06dd8ca08d8c85bea0fc07e20f985baa0a0657df8573299caea0c65f8a9de8fafcad6e5f6f2a6ed1d2ba5f58b4f00676010773d3676db93730d8f6625d1b52b5d5c25157a752fc058851eb0f1c976dd0713a447b259d280c2cb64f79119200a5ee16cf306de5751b8bfec57beea9bcafe7370e83dd1ea3ad2bc93487cbe3fcf6406b36b78add8ebac074312dc9c115bc989dc6ea679017889cea4bb4be8d6819e0254c2d326245eb76aad1f1875fa603533f45f57029fab5bd5c35dd7e05849278a7edc115c164c17191e543d2720dd1260fd3141e7674bf9eda553757be3af2dfcc42e6d6aa59543e747fcee3907ace801e6e6a5a2b76c1daf783fac60e026fd47e2b55b85a817661bca4f587b889073a4c2fd24295cd75912e5aa85339bf9782d2a3161b06c0a87c82a8ce79122366b7b19efbb1056d1ee9783766e9e728aa81ea751b032bbe622c6cd9640152fcdec8b1605b35233ebf19df7a3baacc259c61cb8ede44dada0593e21913f13e6c8fbadb3fea1f16b0fcf21633d355ea71e5362b012eba7d9464b3f65c260d6924147b38b948d6cdc65199b404fb03076c05cd430aaf5ba6503a76502048196a394871beeae1baca23c58cfe3c09a4cc1bbaa66ebfd2023e0c86dc4dbf4f064de39630c6d355d9f9f79b5fd16e1e8ed58846868356661c8d1da20e39f99df5addab447abaa557af8cc1e96cae712c47a44c41732408a6bc86ccd8a85cd991aa2c57847fcef5f5978d563992b28ee190d37866c60a51e52e556ee8fc0862eb98301e9b3f89c631eee2da2f0a866371c81cad06ad291c9fba0601192e496d1af10fa621715180d413940a2d427bd6989d39f4fb999be3df3ac8bbcb3f6cb4369f866c75fdd0b232ee6590771a87816118b015ef197767fd55fdd48451cb52d087788f6e5ad3710447fa0e9e493d99e52be1ea1e462a2d8ea54f027d01a78e8250a8960c2fd4f758c6477e714eb14444c76315a4729d6908aaef476eeb7034a2b5862cd0d8c5d5c11331cffee39e0420f2a3daa722a8e80a83b1b386773b8bf96a8a2d1ac4ac3cbc307b3a754d8f6dae43e43d2993ebe91f694845c9a0ff0c5e62a75b48a72b58d8493e6cdea16ed9b614c9cb211a4aff0d5ad151e1e90f21a1e0fa7e0a6330a132c950535b1fdee85f68a8dfcbfc98923dac91ef27012e36d7b46738b59b03f0158da8755af728814097f9ee23c524b83ad6129883a593512b6627e2ea0067c2679544756ff269ab283cec691eded438c9faeb4aeee0e4ffcd051db12743a6bc54f76845ab3b4fd3f60082c2036705cc245785ba2a19bbe5c744636ca10d575e15d6c4449442412a5836c91a886439690ff09bb1b0bde0018915123833136cce5bbe8b4658fd2ef5aed4ee8d8a65d48d71a589b2abd291ce2b25255057ad0062bd113e4270dd9065fc7486f3180ab5816f2d6414d7018fd674dc6840f69a8d84521beb9d3aa323c06acd0cd9589d1aa9aa4499a057bedb43715de52535deb10f5618a049c3f94338671afc2e4ff8925418fd1b469f16eaab3be6c0c19ce6d44c338109f606edf644f386217d073bcfaa7e6b0ea3cab47d2066a0fc0e1cba9900886d569c585686373dc4c9d389b7cb29c3d1c4ad8f9c6444ff327763df70fd3bac5766dadb12b4eb6142b15d90356abfc97eb275dc4f721344d19b8159fa86a840d281d08afc36516abddb74e7b542462e9331a8de7a52721f06c858927274c88ce6687d88eabf201df0c1d20891a872cec4f515b5fc22d1cd7d7b39d92b16a4e4c634cc780d6e02a444bc7063b907eca42510c2ac1e601e06a7a59ceb4dd3a9604974c7879a17f60f0639f04b72b6385e391462c94ff168854b0381d597a4f2bf6472127dd7cb3e79f55d0ffe5825572c27ca12f1d4a5150778d6c5cac90bf1b3ffc5221def36a7fcbe4bde4ae66eddd72b9ca1ae23f0b77aa4fd36acd46ebe51df2a0468333611866dc04f834d9ff8d4b79e1ca86a013c355766a315941ce6a82b2388eccd7c980c6a9a07440b1bdef4eb3939489824889fb8d16466167fbd2e2e6746e3c4d3195b4b88ca7c939db10ff11d24529bb46b13cefb24798cffd73477a9280904099aa45a5b3888282897d06062b1b0a5541619658bcc9ad7fc888fec00c756262c3406a806ae96a7363e08e82c74ff2ca0826e593f3ac28343d1ed420390a84a6003500778a50a07089b9d0fdda57cc8b0a128c3ea6e7e866887fb3b1fef5a61e2c903381860a7712f87b0ccc2664791c34bb9935fc2fefba68a9e7dfbfda0be386e59fd17e1908495cf89c5a8603d819df0c9a36eb90cd16bc1b2c2264fff0ed9a01c6e0a57968c1c6329ff2d0d4762f2c64dd31e2cc0fe47ee0a5d69b2043bea94f6e2ae21e6d2f6ad29e1300b7ada3a0538872f929bea7aa18e63a9e2f921c9cef41a9a2528f500318c3e3341f922dbea3dc33f179f76b659e5ca04e429d05f350d7df1c008cc495722933472f6301d810cf418d3c5b9c6718ad6a8ae32236206868cd38e1d6aa7a100ecce5f455d99139efb365c985a00b1686ca50ca9e7a6cf476afc8207d5dbee3442545f6025c9b0e780cd850e633f51d0b69983a6ff7ba6006f91c7669e80d0306bc3f1c416609f35bdd4aae76644173bf9a8e4823afcfd03e9138151a742910fb2a2964a47255fddc1a0e659770a5a628da5627348acbf2871e6d2aa1864954e999da98171734e98e94a0396039432a458c1b00cc911ea140b276ae486f86d197ef1f98f3abf400408a4c087a973ac05345147cc105f6320b800e44c5d01f70148e8f343340b46a0a5df21797af4d65b909716a5648cc15bc20b2641a1e0ccc0048eb3838ac9c8520899af355fb2d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
