<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24c8ad37bb124eace72767540d2a7977a1c4e78c0ef7736b30936af742d997e67f446066113db4fe8dea0d1a7ec0afb97d23434e26c92c9b1c5b239b7f2c4d14330f1ec30b4caa90e06232059d3586717414ee5fba78218ead0bff37aff3048c2d6ca4831efdaf878dfb088e6940ee65e3f3a641da4509250784ba36d6d508c45856365e0a1ef52922e41f9c2f42f7a2cf65192815a96e60b8f771d1f9cf53234303820eb704b1a30ad83dd06af0ad1c9a2a2d0011dc0378a85a0e788a738c2bd74a1eee5326ed2075a7b83ee2ef32875540f22f325b7c22bcb6a2368751ad92b3c4f172d88f15811ada430c3c7b4512742e5887fa1ea44ae21a46076a23cc2edc26f7cfba116933943f1aec793beeeb7b61e23ca82454b22a3103a407b34a6b076c4524d005071b34b3a30cea9f58f0a9cd1aa06aef6401aafaeb724c8bbd178510898a7277f7c5bc94b18014f3b68a8edf99544b1df4ff5e112cb027cb3e9fcb69581f7134c99d7b689a06719163b675a11459272e7aad18ba8c25d5827a61d6d6c15686514fda84c1ce75d394ddd60bbc36989ae9eae104aab237a198a690b0379d041f2d7bb2d385074ffa0d408d20d28c403e2283d9b569737c1f5ea5514f9febb999e19fe9a8de08185428bd87ac215772e361babfcee047c22f57aea37b622d5a3043aa049535a59474f4fef293df7ec1aedd78b2fc33f8fd32def736fd1eb3c5dda61d419927ded88378d43c818abac5702c67e174b8492e6d8e968c7637fe455aeda26530d740a7527a86286565e9539c121e1550ec892fc10d2e4a541a1558981fee726176f90158e7bc9c6eead9d70c3572af71fe4eec212bc6a1478fe0ba4caf2329c4d9865ed18477d5f44f0687fa9946ca639a83e458c7ffd40173a8610bae20a125654dcff2f9d69f47c44ea7286f58eda288b83dc6707a7b3e3c7d8944cf3027c5152e0f32567b36b878c5be09ee84daf348ceac578fc46790a4c9a83253a4d571e7f3126cb91bc474bd1dfb3ea134ae6699e5102634e844a8f5992bbff275893567dcdc27672c6a1162e9be85c6e30447458913c6d7727f2f75556bdc3bee7e215ac24a1eac3425db800a6f62bc2da981fa50700c4ec36157fb839e3be4b270d8ce86ba8adbe0fe24777a5a407c205a02b9bf47e18e03b958ca695d4a63767b35f50fa0656fd772f8a099c5a8d9f9ed3155f3e4b7041b6bfe4d1e980a05309ce9cde54b2d63dd7911194d7879309aead6dac58792ba9d7d4c8f4db5b20b247a60a01d4c1efac84c52185ea7393678f46bfe6e79441b385054b9ce30213c0d7ea263a7c3debde77508e9bd35d2de6f1c9cb75eff818e08f3843f8f5dfe29420e9e00e33890ed8c69317cf54a41108d0042c92c05ed07ea7915d768308a848e27874db7451ca91d4d394bbd2ab07f1c3a040d0cf8dfa8772944249af0ce63e6b27f2687b5a81f9b1ae0402be602c6845286f8e277539450a916b0e06b87dd791014f8105a953f1d115cb49ede6e99bc08af97fa77d43ada453ae260aaf69bda1137eb49bb14aaf6f8295361580264843873c2272af223eb720979c8fd238728851a27e1c53015554945d01a89af9978f0f579d3330c2823c5ae580552dc2d0092a5896f416f42758a6d75ecc1a7e7515ca9bd6af8f20896f7b691b0c696619a5ed5ff767aa7118b816a7f6f74e83aee459f1c777ebe583eccca8060fb449aec19c87c91318ed10a5d1acd05ded91689cc907770deccf3758ec7d7ac634c0e835616c149bd737e6c58dce77a23f6e3e40c5715f1bcb41dd914b31926af0a624ae86a6ba718a53cd1425625105d4783eed8c4232da801e122a31fbe0fbda13620b8020d9aa20181e4ba7d50056ecc43a34498b60da20afdd797ad1ff197fbea0c278e0be9898847ce540c449bcb24af903bed0d8b6e162d4eefc14c449303ba6ed12beddc5a0b4e869aa714c5b124115ffb3f00add690eb41b7cc7a3548d7d0205bae5a5bddaf17322cc8895441ec13bd5fbb4017e13dab38a0491a147a0bac8afdbb03f2f6a238b7585e559412893fe75e16b947e30bbdc06a45e93f66d6e5163f25750103fc2f9e0d3ab4be5f5abf028e8d9d8fc6dfd3e46d221a75e50f1e0bd661838f787c6cc66fd4601618b3119c529fd60716b8b416ffadf464fbde6c74ba6b5f7f66e1fdc644a8be9db9083de397521e989dd8a3d983ac87acf4e458c126fef9bb72f113cfc303431920d9dacd3449f1c42c22a3a272f1b462ec39c14cf09e3a2c68efa1b7819b8792ec65d8325592ce57a0cf557ed40ecc14450313202625374118e777d085d5082e65404215de9124e1432dfddb582cd9148e0285689b322897e6a82b3c1b5075d18bd2bdb9d66d2c25b94d7e2a962b064e99839b1f4f992d04441106ddeb34d49f81f8b9dacd65b07cd55432296dd0c2ef834645910626d58dc0d1db770631f6e3dc0c9c96a97de9dd0929a52519b383a648295af5eae6a821853e9214f4525c7fd12307458b62a8d29ad9d668351de8992638e3593077479a56939b343568b4422d0aed4d81740d5e64e06c5530403b19e2edef78dd6973058270996d5f8f8237071a3ebd4ad1b9accbdf8813a5250fea59b23e3b0166fe020c0096db822e821c68b4e61c375a81d0d3f27a98341585e8f38e74bcd11e03054e846d40492d13348ea116165c01fa0bb8234cd5ab741f957ac4d64642e706aa5c6c377569b43a11abc10030b884997ba0c73025406cb81746b3b308dd148f5697dad5d99d2ea46b8bbbea84f00c32fdfe95cbd5b77448f6451e0e93d2366b73ac75d8ba3dc0e535ee0d47730b8fca46aeefb14ec9540f1e3c5d0a10525494f60cd8f1f9c2c4494a3a21135e4e6296ade5b3ed1ad945968ff9b79f89b5e89fd368d490c31f7bce63aae2afe45867317d0b200730048bfa935ec707c20a929c4bbe1bf3cf01690a7456bec922dc0ebe1309da37635426e4660865691a2635b5a9a5baace86e720f450afeae2f7f3b858411415eee86424ca05c51f2d3a6ef788ac7e22234cde4c374433707d1af61ba28506d856b72e2c524b6fc118b70544da90435acd2d7bf6173883dc7604e44eda016acb3859937378c5f904f492ba42140c5c7d2cf39a87632574a75c1574c6d90a42d6e760e592bbd88933f0f4f22eb468411457770a59275389b0a8f296b89308cdda6261680e0ba40ed559d32460dbf8bca3814a1b38abc6f5eaebbc1897a4f421f7c59f3f0294dd12ab9e93f485aa1619c0726eb248624c991620612a3a4b2b605a904cea6a0ea3380d1893712330f874bb6b4fe4d4e8361e1d15676ade619646f37b4e3e27015785eae1c2c914205bb7982c96ce8c8f11c10d6d3d5335c36c047f9c2b08ca265dcd9ac9ffdcbfcf6043505dba73aa4b02f91ec49fbdad9964896306b094c402430659204bc04497f5f9c09d254c705ad0902e3b5e71f6f4790a5526df0d467a0dd59950a4afb36b6ceb96b51eed7ed5c8420970e6cec7ae57a443c3e681a5ee122592ed0a1d4262986d95163a979d37bd9bfd7eff2df61a4a66c62251a432c0ce8a15ffe89cdc27ace27dd4586ac1e1bd42773f4d49adca005662036b2babcadc77051d5699505bd66f985f87626b48cc56cc851140a11e327dfcab6a6a9e8974e5a22707ff874043c13c4b5852bab5bc55ab730cec5732bc0a5dcc7c6118829ef54f2e512d024410dde95b1cf0c678cf2609368b17386e9eb0f3b098409da1d3a3c0aad53e129b909c4628500ee461731b2185b6024740db6ab45c6d517d5b11c5c42b422b35d244d539d3ba282c4b1c923bbea85130cef995ec584fe8458edab45b119c5fbccee01c2b122f6ee17cf8337135abf4def404abfbb2576b26b44778987491d7d8fa7d42a75b320c81e9978180c765c9c8e201aee8f93335f0dc7c365981ce8da3461e92e9c2da989a1a953cde3fb821d6f70f77b1b3fad99acdf1f332681ac5039be9d5045080355f80d0bfa39f949a525d06445df1acff55d5e9d15becf30e98e42a786297e602c9321fc76fb16549ea261bbc20db70a260ed8b8d0f1bbdae6923face11507f81e118ae662066c78c4fdca35728a924a66efae4cfac44e03325f4b2fdf67e14801c84ba75ed1acac362537d954db3fb733dcd07fd1fc8de641bcfa81c03fc85376c0b4b06c20296db5562b1b34fe2eb339ce4ef2923067bc1c698b871df32c61c51a999e9da97de1fa041d6ce853f8b1fe675458e10ca9b2ec90a8daf009234d552882096f6e2b0511634f900d798b15a622350558303072e91f4d606b07a1a9ef3d1b2232f531130897c55271bdb0eac86718c281146730cee1b589d249b4aa47a34566d6a366452fbbffa405e3cdb0f2291e51bd93b2b45deb7f39554831659bf8217633f52c7ecb766944656da87928d89ac55a56bde49e9cf21ddd670472024756dfd4eacab6a6dcda069ec2ebb9850060f0ade077d9b383e88ec238e29e08c659b3a4cfa3c316ba588bb7a7f928a0390f1d14b25489fa4b25ad58cf86e50d496c2e3bc631d676bedf1f1c0a87fdc9cafbc458a9dc944c27e91f3b17145033b67b69ef2e84252d069753b2c0c646a7a94982a6264feef3d5dbc24e4bcc80eb5f13ac1cdc4165873b40e3ce553ae1c2a7c89b146a8723f42268c36eba3629249f680ad4b2b32cab9236ca5e8f3e6a77b240c2eb81adf2e40bf50b96f606f1eafe38a018effac6af3df634084ebd4471f76eab4dda11f14d5a4d2f9e48f8aa23a36ee83ee25507bddf8e10c81c290f13a382e9dc6b52452b39d1362d290093612574b7ed0f35c52f14637f5f5f0f819c67079a177747eb79d7839c4062d9a9c4a160b1654471835752fa424c601275349da1453706a90b1a195bd98f04e30547bca5b95ddbddb534dc064492fc3a48f9346dc5a5b2e92df8b51e2a0466bec00f1bfd4a0bdaa0cad493e41bf4f75c04dbb8a80ff0027071ee179ec6d472ebbce65f0324b9c2e4d010a97e9a44c2245387cfb200ee06cabc3f16500f195a218f8ab0c997ffb9235a48c57321bbe3aac8963f217fb464f5a340b2529a5f8f25edac25dac1bc1a2a494bf5e3bcbd0add27e61e7dc43137e7036398239da99e8208390a2d4d9f15808c241f65add9e90e861a7d6392bb1142fc1e5d561bf8ceccec31047708a477f1062217a7fc8168754b8109f85076090f8283d73ac2c3396d908bcbb4173765671373455b64a43b869e516eed03856306db420d6eb335e7d2d41dd9362204ce305ae4975392ca06b3662624de58f974ba80fc68f3ab0564b77d1b759cb98c29083123821fe952dc5f887a74a1958f0e34f4765485405261f3edd133f9755fc8bd06736be265d19025f04699f64bbbfef25c39882da7a769f5ca72b53bbbc3987ad1caaefd02c30ad7f1f785bb7b533d582df782419d9493011f6c658c2ecabfbfd3ee08cd4ce656f23e1184a6ca638892422f0749a0a775cdb7449bec1b70e8271fc9d05670b04f59eaf56de4b83b5f21d24cf56b3d00c466275668d9df1ed6651ff0646def3707c54a2c0bc8df4aafd21a5fee613a2f810983af957ddfeb4fce975bc0e13114b14febcc5b2532113e26e2071c9ba5139acc17e0ec259217b2eb8c1b3192cdb7f2fa4a64352abc32e86186cf86c86db891ae264edf264695f0c81f2a762f305408e5cb60bb4d749fc0293e9cfd0d9b782d9975448ea1e0d15d5b369abe2446bf3179c7a05167d1c088c126b4eaf6f8442d740444543e4dad9484bac401f2e145c764fadc1523533585ec3b4c2063656f6c8f40746a5155dafd666693298704b4621bfb3652e75169a69e603df409d0861a3af9f09f751866b85942ef27aed1dcf2d8eec7b121729f8fe95550183b92226ad6904e0835362f112b20e0a386e43a500e5e112bc35f87766ad19b9acee71796796e70b185610c89323314a469ac64a494da67df12fd1581eeeb4ebc4dc1df904ebb85852e4ca6e844ca3892c02c0a1fa7b25efd49f1154a2f9c4d51a20f6ce5239b4a6c0258eea2b80020ee569b771b4e4e92ac8df752f8c1963f6bc37f0fde3e7f131764c8fe46c2d0bc2553ebb2f1bf670f6a7d7728927e85719ab373ec426f013fc7a83505f12596deacd0b9386c2e6d3e1a7ab32fbf69c8772b74e56518af93561748b847d0a686ef5e41b75c3b52d4bcee28054218b603b297286175cf93fd8e3a16c09c97a3183cbb56b457dfae9cd5c1276fd0ebc5f9a1a5c9ac7e66b9acc65a579cee4dd9b28a5a916036a7bcfef30e3da961b4f0969ddd4678e20f30bbd7421171e1bd372a3beae6d29b58e283d9a66fc615761063898ff9d08fd127199e65e6ab11ebc6a192afd239e64014013228bd47fa6006b9644cd98a5a3a85f803f26824d083f405d1639c326e6fd70e10721d5582aa18cb9ae2eb390a2156a9973f2873bb6f8f9aa24af77a2e25df17360ae8baaf2dab7fa1026428bf76c50b2a54ba359d51b3382d03f3dad44ba5a419199f53255a88abdd694ca9e6de1903bb2582eddad0172bc9b69ea9600ae89b7f6fb9d78b1b017338f03daf4ba1078d57c6080288f1c21dc9688d02ecd839814a61e88a0086a6885b68e76720b9563cb402936bb94fa15f2e92a0aecc83aa57d955d43a62adf84a6c898e98a1cfacf4a9da2f7479e38239b991d1fb9114d57fbacc328e6b81f2141c41c40868ddffba36d2957f53520f36d882a7bb6d377f28eabf48c53d0097937bb9ad3b57b68d37c185643f7c2b8ac6abb58a5118db670f639dd15ebe5a059837a96a32b80a855a28126917c3c78e6c0e1443c5639a7d95e4d2078468f756c924052395d4f034759b4eeaf86a611a8e68e1282d7b92ce847ac367f438f4248cbe82a81dff688579d6954a253893d65f97cb5d84a0237580d715e667d4b7b859b3e6bd31740374f05d3d469677b04f6fe78b98c6bafcaef2419a6e2fd053503048ef240ab3bd94b49c49238077917749815fbe4a53f7a65e820c5860ec0ce4793dada7d9dc5d8c2c8d2db3f7c9830d71f7b14cf2e2b136d78ae6abaf20e593613043659533df7640c5886d1ad39057a11ba55e970cd9337bbc600c11fd96b607e6f9ec3c715e12885c86dee245583784b1a0c6547368c4414868158d7f29b960583404caa1e0a04bbaf9939714a33d6221aa14bbdde56469c743c1e7b500a3f477abc0e1dbc3c82a0973e01c885b2ea152fc7863eb309ff13c6d3c5e228c995fe28860f8ca4c789ad5dc258d17ac0d3caf4e0fdcf6c23e994411c3f6f9855c48586156720f06ce91a44553c30a2e6266d377e6e912f1c8377ddfc34b93cb93a9507d45346cf827e04b0626cc825a4f8dbe18b475037486e6779c3d47d562b0db2809cac4b39d4646d859856abba8aeb97828f995e3f7482237ff85f36c20a0b0b79cfcaa96fcd2c513654415cd821350341d6755e90001c2f43b6b9f84dabbf4093d7b4ce0920df39d606755fe7b09bd4f19e727392c9e8a00fe45246c82fc1d3709820f829e15053a4998845efbf3a23dcc1d6837fb9b280e56da92f27fb7b3de2ff0d213b85418bdf3535a343a914795d677569c55405838550847e57aaae6012f656d917ebd89e7f4e7313628b5ea8ed4541d8e6b871a52c8cce3c034399f9ebe6ae61050db4752c3183564f60b06825f822808321d53d9c5fcbb5253774c92051822fe47708359a709f7b10c96ed32345d83b5853cd4b2b52a2656a67c89affc32161c2986955549331062248576d8716a27bf169f69d6995e0736aa71208b80d6c0dbb4ebf76b75185076f365053b111e61a970a4e32011847d075f2c0c6443285bf92718d00f69b1efefc364d94c190932e1c84852b9775177228748da0669ff716adc10b0cbaa2689e85d6e030a2a876434d90b2272ce6bcc1aebc6276a23250aea9092ef71dca1bfe4421cada1daca81c46a19b90f5f66b5abe2e42f9d879e27f7971a747145c7665819e701850bb227f7e24aec32d47f4fcecf8ef7274078e24db77528891137f8f86c00aeb02a8cd408494707b13ec8491856d5ce94dc792b73fb178c5b207303176b6fed80aba736e8afa8c83af703a1ce62648be021cccbcae1443c8e1fd4261c69f1c7b57dbecd1b4d1cc09bf1021c19597e31b697414ea747c963c31bd884d1a7cf0f825a2fd655b8bd0f001cb228dac9d134d953068cdf1d1e36a1bb003eacf7e0a9884dcbb7829969a21d2fd2055660ea3c4c104085d83b5226632f85e0d4328f751e5fbc1ed4b12e37032e321a572bb0fbea62407fe600fd89cdbea76c9c74374057d080e9f76558bf559a370999cf90d8cc8b688f6b574e251cf844bc35623421656c1ce6fae15f26eecfd5ee8ebdadeea28cc70a31522c17d21223c81564ba42c7a8334d5e3eb31b55ef2c447aefacf84fc5c8c82254f93cbb03b363111c1ff7e4fd99b27cd7b66833c19f52d30b123adb6032bc2747690072036b145f0df750183e58a228f424e957fef55b70def44eadb98f1374eca3d7625d91759f6d73005e2c6df60a3f9a9e7ff7ed4e990cd4e65ba26570e1cf47fd2d19cde3a85c3d0dd31b3e02415946c51fa033491543c8dae5bbeb79006eb0bde86ebe4ecc09211cff184b0b78e316387cfba5376a53845c29732154c6b63c9e4c3fa8a688884aaa9efcd66534f7ad4fdff42b711407b59e78bc99186c0fd9cdc975e0afe806400b7566c7db189207e318c463a75af870d9d32a67fa3a5de42e76867d0ae1ba2c24f334fedeb63786b0d2a2c4d996eb239c46e27341101309a483e361933534d299e674b8c171e6a1a211850746b161fd0fe9ac9865c8e8fbde9ead4057b5a5048d1ef1667dc5e9bd9862dde95536a09d4b15ffef118b0e2aed4ed211877b2e16f4dd01bdb610d36cf0f12f965a22c356eb640a36117b73cf200ebc69496b94226b9a16265e609f90a248db515f4e72c6bedb088a6c9b3d5e0931ab043430ceecf261a5c8fa1500d4e6f08a0f95ec54c80528e783f2a222bece8e0651295dbb12e8fb141c0f6e2e8e571874954b789aa2cd3023a9faddaecec7e2b89760ef813d812e4279ed8120c34e5905adddb7c8a5296808a184d7cf8a004a98cbc11f642a630645dfe16a9553e1273b92308e34989fbb14c871c72d1761a6625ea85df779ff81810130ca574b30a47a50549c81ba6d42a0e0e1769daead02e11bda9b341b763deb1f4041b0fe13e8a288c51572a086ee8cf48e38a9abfa745f95364d8827f26f746d514649c8d94758af0858eaeee49fc0443daec0b4975582c2690dbc0ebf76cb50eb43aa89994566529fbe9ddc73ce7b492cb4c8efaa65fdd6894b0dd9df5a0f6348d36bb2f7b47504ab8b03d7b60746228827896c0c00e97d3cc85411ff34418e9629a578264e98330cb8fe031050a341b74dcc1cc15d4c734317569acb1aff881f9d46654ec4e9dca0ccb7aeb5e1a2651b38c32cd53f6dfd243e3943523b23d5d25d9ac2cf2d44c3107a9576cab038dce99b9a0591cb51d72351d94774a4e61299911e7dcdd4e68092614f10f24c56e3abb9ed7f8736ccbcdc3c7d38add2469a8ced42ba93773a4dd51ad60594227eafaa7a21d8e86c7672df1532ae3357b231c735caad7d33889fcbf62fa73bca60c1f812048c5201a1a9909cb7d6506b58fca751e0bb4056cebf16124a6a74798d3ccc20f3321bad99437ee64e7b18131d387e07998959535adf769a35b3f1db0be88fcd7a97aaa5c1696fb5e4069e3e4743778704f474f913d248f8bebdfebf847aa22b26c936e620b8a93c02d3a9bf01351049c567b769de6bc6a626710a80328dfe31dc645060d407975b582ccca46290f6f4d10ef4a6466efd88cc11e381c6bf1e305a99de59897516f00bf39212abe1b8b9b559e947e17d42267874e270ab96642315b0a88506f99b13fc57cb9934ac0b690e422e74b449b22c4c4e963ed9b0f277c4b15d883e050560ae656ef2ca9f5a7bc3d5d7d58c1fdb795af40872bb801128be0f48e042155164c13f4ffd82d38165ee713173e2f1a62b16dff76fbe4f7ca49740c0265c4bbbaeca897695b8f327b4041048b521ee87afbad4332ae33df560c243868be35babb6a1bc36749acfe0c483e0253ce734ac40771b40d50cff938eeb0e4a57d303e5bc99922e76dc348836d44e26108487022e75632a39d09dd978bd1f091c035128b353b689eca7a24595d3d0a8369826da2c6ad91d0dc8b7bdcd37e013074f248ad1a676d6943f06b578dedf4d2aaacf39f845063d642ed03cba09f3e201e71474e965f71b76256738148443a5811877effc1663d09d5f5b87ae3a2e67a4216adb686539c0829f8fbba2c9f30aaf18b019f77ad5d398f7fd2be1b4ed1345d588f4e1feede08eeb2d85f15b0ca51a5e3ee5129eb15bf3fad95fdf3c6c1965e15b37c10a51db66c83999fb187538f77b96b3f2028939e03e74bbbd313275e221571e74167146f480627753bf0fcc751255a080bbcb01fe9ecce7d8b4076e98ea2cabcad1b6bbcd78b0534bdbf97fd40f8557e877bd938042a38bdaf378f669b394e9af26cefe6cd6a64956ae9061826334d67f8cf6f5efa582de08280fdfa6769047ae6af7b6263e2306ca488f680e014ec41a4276dbe2f70ffd6da0f6d1edfc98e2a21eae7b0ca786de86838f31a9d43c6f7dc3f15c3fde98a44818fde061a02faf820ae0b8b4759ec9672f0b9d9a7a30d8a5102c6138a8bf8c733f50e844cb88373e97947baea44318bcebafcc4d03e253c426406ed61b11db8908316a7445b6525084257b3c683ca8069e26cdb8b9cdc1950a6fb859d68a7354912f45853168abae494a4ec9dcc358ec0c496d15712796bc1f877c77108fa51f4ec1ebbe9f809d4d908cabb2f3d27469ffb003e48c776b53ca7f44b3d8f8ed46f5c08190be65d18dc5ef87ed3eac38b05d67f3e41efb29c50758ff313d8720c83cb2a890a10c2c65e7523b1348e83b60318d1e19156edf7d9a93db469ff0b0e96a39a20373cd721c6179d3b804e6c0a5c244421410a04e2ff6efffe9f74e37e06e88a55fd818f48964006971088cd20dba6e453101d2317d997bbdc230345e718c2d58d30eb1734386c0e5333b147274c509fdc758cb3f2be5c20e03cfcb9408577bbc3f5bf747903e819984ebcc5c56fa213fd60b0fecd684abbea1f7657fb1d0de596390905f88c3d6bdd93d803b679d0d614b2e3bd320bed8c513f2a315d9c000efc3907a6cb25ea4b37caefbe0fc9c0ca05c5e54ad279c6158ff3de4d4fa397879e9df124b950491812a0f83785230991a018c7f29a6634ca33f1639581610f54d0406feb5a08da9c9250fad67f8db27e8ff1e959ab69b838c777d676c0991bbc25928718005d6ccfb84a613b78785b428a22bd17feb913bee29052e61c5414f75b16a0b1f1b915ef97c35360a12f5eff4888ed66de5efbe59aa4818a023d2385cebfcc600ba0a50021c973c41f03c7c0f36c56e7a13f5e5b6f71d0210fe462d072d92ad4c563c7987cee75964c7dd533acd3ed9a72520edf5dae53f8e496f9603053d4307538f81e38467472a00c840436d49ab122beeaa32ef59c7705b3dbe17b6a07b5773860f5d3bf62fa6b438cd00afb0728b3b4cfc71f490b649a60afa206809c24b7cce8ca1990e32fdb145af438a47a3de20d1eba8dc07859a1f1f3228aef14a4119be3b2d2a0dbda5b9c11c11505fca35f83e093122ef2bebcf25b311c1d053531e20e10622127725a67f6030b13832c163379512e99d051e33fafc090056ba5bd73138553a6157413508f0462ffc9c2c7347384a829dc199978933121600f6b66f07abd4156488b828ff82c5a22039c5957352edae399be326c4cb74ef58857ce86e4cf0c4436ffbc83cf872bdb748e9bd50bad4a648fdf35cf10b4f2afd1ead51a0a8130a6b215da3542a3474fd86f74b29d2e5f757486669fa33ca9b8441667d18dc3bd0870764a8d241605c4145e20e25971b37342fcc6e073e0f6edc4511e8ff57b2d0272c131b534ea76f32c079a128851456efe08bcd3817090bb18ed412107502c0cd74d291a132e1024e09ced5cfd825bfb220e0e4714b6e9aa0664bb77e7e8c9404391ca9d321a0e52f99dfc612ea3ce0a3deeacbe29951f97f909acd28f21959d2196a0803b177a16a26aa74299bf3e6bc634f696b44f49989cbcd706542550653a6ade9c8dec3f7ce29f4d0fe390a65f9b2d97c8d9ee0efee6c80a4ba77410d6f23d404425a273e8c4fc151efb5124fc704e48666681356fbdb30739913a5912a0e54f53c4fa034d82fdb24646a8352fb2b905374c5de8b68e8e8d301cceb6565b40cc784628d500cf6ecf2b7baffc1c499b187bd8f18f719febcc610132cd9f216d363fbd86f7d832f378ebe0bdfe13a5db5027aaa8dda166990b212859dff41aa9b4f9b68082438a02d38f2b95b76cc43e43e5a7c5b3078620a6864d20430c4f3b4abe6814f63a1f2aeac36ab94f4fa4bf9f713f51c67caa99029538d49d58e1ee757fdc4b44284707c39bb0b93967d02bcb1e4450f7028fff2ad84cfc45ae63ab4c26a0ee9baa7002971113c5926195c0bb971836fc68663c61efe5132ffc9d9a49999d99139efeeabaa509f0beedd85114567662803b42e5e6a52da24c987a1a79153208e79ea750c2d0505dde651d83e94107e7596f382eee9496f264461449d39d20b13b185dd55a4c2774a53dbda9ae4687bc26c8d7246771ff0e6ee8d6e609b62b8d6ea7d35b8b79b70424f7874dfd8983f6e09dce97f7f8fa80053700d0dfba1639b3c0008f252fbb4ad42966b28088700fe77eccba6c5e830110cd6037c4f6b71a787f449e2efb3d3a7bc90390d777f102f911adca643fa1a51bddab2748d2bdc7ffc1bf5cc4cffee134a6dd2908ed12fb3706cb0349c002fe0dc35b07b985d7920570a3784ae59c07b487b42c9938a40c66cc1349e8bf8709521c5870067f393c120dee675bd2032bf2f350c91028c770465b5ee83f8ef312bbee53f1a725e512169aa5db2ad9a62d5d49fb1266005faf31001dc064cd289e5f98be5d3f86b5ed413608f93b0dc10e5de2e9a00db6b3f50ff062741bb243e3514ab0d54ef30e4f827b374e39749e729fe1dba1d340708e1da07533417fca642c3935aa041b5e8e34a7535a039f1c51af7e00551ee189df6aa830917b0dc8e584059888f609cda22a457ab77b7e95db840baf7e697bd004b07adf5ead439b15d36d1a8c29d398f238775ba14ee1b1eafeea8166bcdd50fa4e944f3e7335a19bf7c902471cee63bf2b57b9f1e0804b9732973f8807f1ab96ac32c3cbb7143905d2f8daa456f280da1b3b3e8b59703a8c51726db8a6e66475a69c792d9dfe5dc2c6c32549df7902dcf129f2e7ca84a565f30506ac24445e7c6857f51e4deb1e0750ce7aa97071b303ce8d20068f2180c6b75fd97955c5ff5478c4a05feb738c5234696f3c40619d0d1c8237849a04a9851e33d0e8383ddc338d24df95237599fef6d461fb24a9fc8f4d67cd08be68860133931208918e88bcee16d3e486227b9310c66d639adb254cf54a4a3f4c696babf4e7543e34c910a8152abfb9f81bec5d846f51013350d5d896832a58883de3eeaf897b7f9e9112359cc837f0cfe0b22bdcebf0620e67205d005a5562baacd8bfbda5921318d5e6d0aa4cfecabd7cbaa57aeda3d006e2eae59902b97289b25d0ba6bf62676739ade67cf2cada00c114ade71270228108a1ec489959a50e648f051e11c0f603f9ba27f750c06c734cfafacf4f616676491bfcc953f2fac679ac4bfa8493ad94baf96c8d5265641272ff7c82c14a3b535f715afd3ae583be402365a563e2e465a8fee4f590a2fa9634cf62eba8dbd55ca47bd0f9870fef37b752e234da921c7b53220fec881c201be82d20d1d18c25550c150154bacb1ec865adda8630b5fac40e9d9abbb703ba186c4cd89bed4f6bc17515d97f8e4473cb23a9b967567684fe67fe4727f113c113f16407ba95a73827a4d7a00375d0931674433802967a2a3c77b988b40da75f0f5c629dffa0acaefb8539c41504de63b18b8d9560c17dc2e0e92955fa9c912348578abffbd2982bffefae59ba4143572402a461797e9b026f6672be429fd37f9d40788c876119bb21ac081ec7d587052a61d0baefce6719cef6cdc8d748384ad5aab965897dd23236e62fe14f21d2d36057d83dd2ec5664694f100b745660e41980c0fb32587836d60efe6aa01fa55c2cf673a7f2569f07fb26a6ef60b8bd4e6571b453bb2b0df41f5ba91fc7e392136cfe5886af63f96db2ecf4d1d28187fb37657171d4f4c6a4633f378320a2d2f9d32daf8c55f90794fcab602090d3abe6d5c6770114f9b06b510da31eccf0be58b15d5d4ee55b3ede4bc22145ba687fe736b6d396c30a54b8bc929268f1fdd3e77506597e948697557cd790f520da9e881abb8dfbcf322967691e8f13feac1f0fb1c2082fee1a3259a6a6ba7846c39adc869652cd014d6c03ad8d4bad3ce4da90e540115becd06961612a1e15dadc7a5953a68c7edbc27d33068584ea1917cc2a423bc02469d5feca4deedf1960d193f82a87f1a12de2719e9391a608a43ad5b5849e8abc9f0286b605b4915a8ec0e086bef54b151d30fb41bc41b6f9aa4b54488a598b6b0a826902aa60bd5c183636ef63c6cf378c33be92498c45930b7005c3560c4a90648a9df1c1d46961ebac6b438897c22282cc3e6f08ffaff73a27005daa7bd4465f0022c5ac2b66e8cd5b9f2e8ca8d76e671c378b4483264ce5e61ff8ca0471e690ed8ea72cc3416a9ecf8e3b5466a0c865402906eec7f99f2a8a5077e49369825d75f923c63c9db4e30629b6bfaa7d3faa0860312a0544e9004675a87ac3ab5cca7475e182114aebed529b8e5872a21c68ed6913aceb9b72d4926bfb35e242a55dbeebd96baff3c29e7939ae481e3272e235633046c070fce9ee633cfe58a2fdd713338bb8c280831e655789989b24539ef5538b988db5ee50baec927a9ce7f56079075ec56beee1c24ceffa562d2bf010460f691728fa6b7b26434a7dd4ce89f8d5c44024af3a3a07b5eea3885ef41213bb4a917ec558d7e65118338827c3dc857c733db4cded11e50ce7f50de3a6b3077a577f6deca9ab98fac42b9520c06ba7fb0f10079897933f3ad34056a31a41f46a2d77d279e9f14f4d534554db65a7ebd19dcf83aa62ea9ca24924b625eff6a0160fb0f55d578a78e5225fb343782692187b40bdbe6cbda0ee7933d53437cf828c6144e6ea6fde1dba33fae265f035784e77fb5e81ac22c11d8b71240d783643c1c9564b49089611f3604f425319e1638d1d9f9ad92be6f59b528dd248f3504d67c2550248dd380bbdcc3c8135de0e2c6cf741ec5b91f9bfb442b7f89c6abe1ac166f3c1f2fa2b2144ed97a6b024ccf1f51e382d7fbf98a961d953ecb4fa3cc1c5599041088f0b3157499b508bc7947bbddecef763e19d093882f8ff4e9e9e75b28d621917bacbf37cf48f4833c46fd1b34e4b6361a0be2791031cd993c3534ac4a39b76dd7b29a5527628a5dcd5248c55b17a0e268833cc85d6000deaa6511e54097baa273965978a3f6af140dbe8f4090051dcd7dac7c7eb38aa8f9d07b3f24cd3ef60b8d4f024c92089cddd6772595b73f3b8c28c83e14871a7a8e1c5e10e3112fd674288fb3dd417c570dd218c762da0b79576d13d1c846dfdaecdb4067bb9987edeb9266cb0fd2c878530b677e13f6616ede9e3e4a3b7b051ff8e3346f07a75ae3460aea0d667ee5d25be5380f639fd8a8777c4cea46eb77b2f74dc664fadf341f25358faaa97bd0e0013520006c8192a24e257134c0215879f83aa7039c02c585370e1767e88634537bd654a978601a90a47c45121e8e861d6c7bab7939f379c9d8d02853f458631b8e3b1729342eb794a66d5aecd585c53a475839779d2312320af05230a137fe74c19fad761aba8c811aa38f84bd53b0c276921283acb78f3a5d62b20ac1d74dd48c05c081b087aad9101ce89796a6b46fceedcd5fae6545a714761b59cb167ca07efb48cf8562c6ba57f856fda1d5c0a3f853d48037d3a8d79214a24958780c7f098413ecfbceaaff4858e0c82f8856705d4a12abf2b29a2da122993e7e5704e6200e9c0a49fe33620446ff10db95b16ccc8f8dc4a2aaf5529081455700e22ec9d7d9f620359e1e3652d5d1e6b8c019b98a719ee37706468293cb2b4d1fa3d153f0a9a28c6089b586400997b2979bedec94b74c047bdfeca29a2c37382aa264a8d5e6c2e21b91fa59536bcbe573f3b85f509de842d156a1a56614d4c08f98a747ee1ef435629090b49233f93d0c80d67d1ce12ae7184a2fb175f11c471b8ed202a8f56146995e7dd514c409a3ff8643e4b74a04cb6946e1e8e2a09cbf8818506ffded2859131463d1a8d6b77baa3146efd89a44ebe2e4ddf2e7c2e049ac929fc12a66c5af1af336d13a2ecde07896b1e54d6adaa5d8d91017d42dc62e9ce552d2502a71957f55da823e7b8440b958c1623789698cbfa7d5c12102b13ad819b4f6dbc2e5aed6c1d310f4ccf76bf2c99832e370a23db7b8cb3b4e3673f30a7c9227dc44579d43df8a714fa45697ee539b8b1ffe7f629d6eb8a05a4c77332f0f76c1e306f5ccf797cb2d2b7c69d3060d49de1b05b8936eb3ce6dc0595dcea0447c849a55aee95decca24d517d9e339f8c69208ecf4ecbb8ac1efe8d8ec0c3bc45ee138ee6887f6f3d8d72359e683c060663052d3726e4beea7ea14b68f32440e9ae79d6535876d48af44d62f248f14af2f6df5325d7e45257832d42ad571f0a66596f774cc57d039d1cb410dc20bad1c2db8accc321c6b7ca42c00e8bf3c6d6d107fc8fbdcd3103f49972436df5cc87ebc7ae131fcfc2130d9bc890388d9eed8b863c542e5f787c5048e304d577805a67a3802d6ccbc3dad3bf7e6f5ed4739617b0de98c3fadbfab31ea2ec9ef26bd4f1cb97eb1b9e9bf34252199b5d39d3ce38de3ab8a6aac72b8f3f20a34c4629908ed198387476b9a9db0e7f3bd645c82593f2143d09aaf90150567459ae875c5cc0c43201a1bbc3d65c5e7e897e3159221d378bad0904f50da03af0b76bf00ef1d96761fb8754abf45af1773f9df8ed953b6e34a56f8f180f7e56562c280d55c76be311760ef8bf5fb53bd1cd46c2923bd5c69a908d1079b2764c172ab705d09909e57f8ceef3c5adf16d18d31695812f6a6ea68959aa839e5e273628c57d29edc082652381a333f23ef9f7d94d35593b2470929bf08bed367b529b25f03d1c396b881913f95212868afcd3a09e7ea1646ecef005992f9ae92aeeae50f1ebf9c59a7d50f460ad480b1663deb88139da617c88ce195541182f918690a605dfa451ccb8f86ed2ad097d6292b2b52933889bd938c54863c633d4ed6ab2157b6ce9c92101b15b91ffa6caedd6bc109a3f2b997ba71c4d7805c4a25097deb46647f93cacc74cf7339a69320e26bee96047d313d6bdbd0ef2e04fe5402b5e947fc3f2673623f26c80ed039c18bcba6a3324cf0c709f870622eb60c00c0daf19896bc7098346f855e0dba3dfec447b5b2c84c812466aeb6f500efec99d7092e0de2515ad5e4b7cf4144449a82996cadbb0622055d5fce26a66587c3c60455065965d424cfa097c72012cb0d2d1d93235dc5906e9e7c915e57a431679597544088ccf8cb7b2d00e4577742de01a19fefebdd0e6d2d10cfdc8bbede579a20895e319fd5e2740b98cf5aa7c017512b933bf81c9bcb8c417b0ff01c0913543e37e8f7bb114e352ef5d510e1a7eeed33ec41b6616d2189a76af735ec1fabe3dfd0f3898ae90b384493d6cd7ba950487e5eb8a1b4e87a1c98c88aa11551aed289fe4eaabae4d336e41a065dcf767f7e4f7fb4852b1a5033b3751b8fb3970117e68ece7c71f5096965d5dc523cb791461223f2ccdce8a14dee34cba86464ea57ee6a4a20f860a42cde08b223faf23ec27bf4f1037f4f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
