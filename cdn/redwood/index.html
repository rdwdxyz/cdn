<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9118891a438fa8242efdaa0f06bb87c93a6cdcbc74cec805a9e8474f72c5edce7fbcdc718dd4355e5b7c1add181dabc6dbc55f48dbb71cfbe0a8f5d6d6129894f1425ef7ec9f6ac6b1558587a868fee2dee7ab0e93fb27a6f7bba4c8c1f09483d487a48ee0e6fc42065806b562f35ae3d4c39b9086371d45ed03aafbbbbf6186b07b38f2d959f4fd6de00e52a674eb919f568a4e6d3eeb9486f1d751a0d315564b354d57dfa5131c5310c186c57c98fd378c124ed4c4a6872b2f661dbeaee59ed8ea49df531705af2f543d6c90325bd65409382c9ddd4c7ba936f0f1b2c62f2a6cc5417f3e4150687872a00db6e2f40d8089a8915c73878b7ce5cf020b2495eb68da35a44b5db43986d9090648715b32e2ad5f1e38d011496f5c6125cf4da6794e6de68d611202556ba848a551fb5a72b7792f2e67de23183a56e4be11a8e9a4d718e20522f5485b318af277020a01e670c3c0df037843f3c04146572ded05bfe1d27788dd128e5ba751b7350ae28dba4b544602bfa47a07c29a3f2333123c6e9885579c2321a62056fe7caf21e3aeaab8b12f938531e1813b4222c0ec0e4b5511bd1919c57f67a03569159272f190a2a1f9e07ed571bcf9dad9e0846a6c4ca49d27943978c5dd84bbc0025bd09438c0f462d55090733518bd74a595222ca525dd4e055be84410f4121ae82a18ad37943f3a986e20d86a49a049f5e7552b35bca8039e3cb921efe7b384e3b34abae952fdf9c7d6f023de301227b1d8f213586bc5a8b0fdea5e766c5c86d46241199ab34427e417de7ad35788ddb134d8d9b6c313d5ad49caab1d86056a3e35e54bfad8c0f685d8c017986d1ae7f08d35935c4baee5c47c959c64e05f68c5de0fbba6f9c0bdb161cd15fed86d7067b0794f6cee1c45aa03f5d8af70b56db626c25f65c95eb9a642119a5b7dde2db1fe3c95b85bc65e0cbb31a07c356ca57c95541972b2388f2e7a359cc07118f16dc8b02963ec3764e23b7206cde62f325e5dee636b90de6a66b03b56d46f953da5e857e53d2277b1a212aa3402c241a8c9b07c8f6cab6ccf190ca747075300f95e8e05177c32352f8efe2945601fd912d131386bea6a92bc95ffe080ca570afaa5b99d4b9229db5b45c6722dc81274af5e8a6482881a3bf4895773eca5d02ee99a3f52780e6522baa260568378524ef135281e9754a785f8c00309e85896d138fc26d3de218c04b27394d3176d484093d6c052ae6f0d7e821feba48b8a4a1def5a84dcf5fe5cf11d3cb689cec782b690b504ed794487e488f88af06e714030429bc0bf21ee48c6b7accb338ced8950f1f3fdaaec47208a0450b7206f88dcb9275121050233360aa22f389a39fc80f1cc5b2ae2f272ce1a8f06414cde176f5b891197206a2204c5a95f270d38829a37cd074ff6072c6edd180c3e15519a0c3edf47500c2970edbb3bd78bb5a32352f4711fe9f2afe541f22e48046800aac6142c8355a9e4fdd8b8c558c705654fe4b71209783714a2e47128564435438e8a8a94460c5555a90b466472c777c0ec0f206c5eaec86929e29514418da9c330cb3c32202616b12e50363929ede6fff263a07ba611406817c6acc29257af58bfcb18f212e0804046417da9558f737381766d1d45ecf334d0a9061405f0718a209bd3a61da712437d4d9582374ef066474de1cf95d601aa5ceba3607b8d15ac9e90a1be0492e5fde44bd947973a7ca27511197268132c30de328ddb7ba6dff1128bf1ccd2c9f99a411de3b806a03e4dba8623c76d0e76e4a7a1394e69c4f5dadb211faf0d32e642c4e094c0e02343c2b3b69bdb537cef8e48d8f736940f7c3a26ffe0fe23b719cdb71808f73d96ed1b24340468cf04fc074a696207b28ccd7a869cbe06d35059d1e31918dcf176efdd9363eba8042b648cbb121eb7fc8aa5a932b399d519f9d942ce2ba0f2ff2c51d2a437993ef45a8010a62dca75f1ba1f1aeae9ef0c3650dfae3626853ddd1f64eed9f39a00b2d4b6dc43a401c8099d144371426ce0d39d1a74ef6bc05e10e08d38d4bc16dece0e5ded28f4689b5e93644fcb62334ce2d036e30fb02c94eebdd6667c32a4cc2f3c41c524cdfdfac70e940a49bf6b80da805d70b5d39f103e0ea42dc1ea9fcdca29c43f1456e10633e392856630a7db7d52a5ebaaf7e5a0416cb838535f0c174639b2ad037552291c29ab399a5a418960cfaf0aca63b62258dedc310e2ebba62db75b594eda0bc005f88d2a350d044ebd95e0f19681c2a09a40831d46271f172bcb9297ba029f2f0adec267462c6e44a5a11bdb0b2444d9e029740e06dac05b1964e3b8e761521aacbb41e632d5d32e868b4ef96c73738039f8730f0a1ae90596480b7d73ac43bf7012a9e66f8f5ebfb4344a9a57c63070384e3db50f86c9353fc1d933f69be51e7777677e9712323b097453c8c84d94030eb4acfd93aad187c0843b84cc2dee96047cb5cedae1b008dfee57180866ed9837f737525bae9bea73c7d059f924ca76dd4b6c70fa482391b953c6fec255817056d9aa67bf6a65ab56b5158f34d7f9fa16738b30434368bec67cf8a68b7339e3fc79da9a5d3a5ae4146bd97ae4f24d5f11ccd4d6ec6dbf68153094af7be4010e978037ce777cc38753a2e6ca948c85c1be6c0010cdf55dcfbb47735008539cb3c9e5f59ee68aad47bf5680578df4808b3a4dfc77732da97cf973e7914336fd6f9094cdb2b7e5d65e6e13d704ad174838152aa9f7dd48143d79529f2f1792df0d838583e59a572b9ebd25ec6fbc20e2a5e486a5db2954b0e794690b3e5d5c1f86a8cafc51d058dbc2628e584da3bb4f3a6a5c8ac84e27b179617d61cf5ed62169e962d0efc0018aebbac6e06244256586f763baec9a26eda3e23657dd764976f503609adfcf8be4ff53993a0e8a5d11d60452c3b987779e9304c399e4f3534fe072ba0faff5d0858e3c5053754341c52aa98856ff79b8bdba43e59f754315bc86cfd33c6a0915895b2b8d82cc484e3926d0f0b56bf1766ee45010170554eea3a4d30855e52d9eee8ca7e6346054d1272d8ca7c75549c7c42f70c36d2dfa83c8778ebbf7e19698ac9713a2f8a8f3be3be0e6b7234189c54ed7e5935d448d12b73ffff2fb23203046b3c10d5f9472081460a250f152164806a5bd7a87a1a1d1307003f13c99d5d3e4037536508f312ff4d429a0a539424c9a44ed1dbc8890ea8ef9cfc9415adf3488e1e5a2e968fbaf064fafa12bc503f0f3b699318a68d0167fd1a1b585a0b598fbc16bebe469a45e3a262a36d02f04b4c432a79bbf11e93228ad7058c53aca5be6bfcdcc52642286a1b18b73530b32b9f08405c31f051c739d6276fe5d08beb3529e8868e89019777bdca8129eb408a5ea394014eebda2b8cb886727c1df5eee8c961c6b3397dcfafc1b0056817bfa1d9afb0dd8f38c68f3e483052f20df310db9bbddc89608ab87a6fe919068c7786747b16e77e0a158e6abed570b4571eac3656618b916f25b2d6766b231ae3b65a1065a60a3c47ffd799f991b80e0f53bd9018a3fd804b54df0630abbeeef3049a6e6e7d47cd935ece615a66edd758b5fea5d88afd30cc3a3de15cc1ddf6d853dbe36b97fbe7e9443cd65fe189aa7d7e6d8c040613a9014d4f4b5510053fcd19fe257d8cb53d25cedf12238b2410ae3b724caeee7c16c90745f5aa0c01053f90e2570ec8dd5734546837b3196fe6e1fdbb08624adb83f8234214b17100563b9ad358281641b460722bc8e5da103ebe45875390437584e90af818eb6d93b97ec0b4823cc60000315d42a8a4219ffcddf491df6f1bb3e97c422582545560270dbc0961b6c3817dfed8c6819d1733d7d25ea1392807ee085d21e1f609628b9a784fc93731538c46744f6946b64e63ec5c73230a2851ef870bc4f3ec8abdee5e38036b68fec7db758c13b3a4ea4c0305eb3325f9e4b716eb6acd7557f5c44b90d7d92c6bd2018fe02a058000ac8b16743bdbaf48a3f96e545bb902a0e6649626d8749938db6023e833a0fa01d28ceb870b26c570a5f1e1bcd4817c5ed58134c08fa15d495a76635f890526e2bc3ff8454c839592c7d441b4279eaa42adc79a04bc9f9a6dfd824546e59b99be2d4e32aec3eedf633ecd9fe5716c1e4b3398761e04bb754c755e2193da7cc747fc1ffc823d0fe3067778e87c83d9faa55ddbfc532c06e0860b800fb0556ef195e1989e59c0839fbea1fd7571b3fb602d241e4e25c423bff7b472ca802884fc6b48108994fe2f5029f6d8cba9f4935e04c6f2f57eb2bbccf0368c5f19ad057e42a054c5bcfea65c5497fc060abc0796376d2c6d86a857fca01d509c5afe8aed5c82b2cf8572c6ddbecbb3804b03ac2716cd411b28f4016202a3f951767a0c722fc66bdc36e812ccf25d6231883b71b40c8fac70a12e0c5ac43b7abd512e16ae194e9d08c25b34402eb5c6e5a6455ee8ddf9183c5086f65e4166bf9b472e82d7914815fbdcb23fb883024698651992caaa9338b50062643001513615b83e45d668aafa11c0321ae2e7a1b12efe489eec2897dda93e6268b5571aff8b18c13d3437e2905e73a60eefd2ca3d3111b955d9fc2ec046fdecb997ef54c9f6c50c0ac1ff98d528e50cb989196c517127fbdb291e35f4a26dfa5d3a672e506b332454241252083d642330f94e9e68c8fa4526adbe5044de8e5918d3c4a8a0df72cbc4f6a652a5b756fa60af67997f0fbd87bf50f9759546b346588751e329f46186979ad0a011d36f1aa131d200dad28e1a15010996626c389b81e37fe09b70995342361db53ee351254a1bcb7c257a2a7a572ba8e26e59ecf535be226222f19f7a471581260cc30dea291d202d1e27fd519bc6534af20b6db3e34bbe6887cf95262a76856c0a6a91da29f8e014f33d360beca71051d343f87d7b9d2d16b0af767d2e6050657390fc4a72346d5e74351214504fd089508ec4f450261e94f522df265c2ee982be03c1c0da27c0bbf4866bebb92701e19a3c887b486a6b00da006698387d946e56d9c7c93168429303f6262d94ec7acf087ab2a05c446d2d984e1abb62563994801132f927c0675e9d3b9b30a545a921e6f887c6bd1d01ac31fdf822b54bb7eca952bc16f81187b91cee9fd8eb12f19674cf9cd054b0305a026d37a77ea2564fb04ffc36ec92f0dbdfb3aad74b80f488723a900555a88583a7d6b161e0cd8da46c1a5e202038433889c6ba59847a8be401216789f855a87592d44917cf67e267ad7d7f58fc2d759a82cfe73acaeba80ced088d85c30a28eadea8d121a343821f4526a0bcf040cf5430aa04840977e7d75a7c25343ebab3199725fa9567f53b9c30997ac711a891376dc030fe61529ba385406e571c7fd6000bebd7dc20d36316a7392c976761526632fde239d25175d62418974a40f396e424cc46365a1c30c41aa27a63f3d548abc9a90038985afa83fe75b0213411eb83e9f85d05e4aaa91e9b80e24b573cbf76ab92b54812aec893088e7d347326b4cbc099092b1bfd058b3c06fd87bacff23060cd1e4648a573e5cb403d887502406df619140f594b6bae9728599b4d7cbd808656a45b30781bad0300542ca6ffe0fed3b7f19e6c6798435b884f9ac6f2a19adfc16d168dfb372bd28507a5e1c6bc0c705b6254bad5f870d85882f2bf94e12a87a59563eea18808c20d6672d791845fcc603078b69a3c45d2b17ca651bab5ebe8c323ae4f2d8cc507f0ca2ba0c5bc55de58689fbf00953f8064fe45a71eb09399a1df6cda6a167aa7f54189dbfe7b8b02a2422064c570ec5bfd3e703c54a6ee31adcfb617af9788656cfb03e5db1475dc315b7a44bc865e94a9a9b2625b717fb19fcf5aa59ff18bdf7e159b28f3555cf0ab7dbe4927f4eca75ea6c94b2540e601a5f9e4109f0790c3b8082ae80e35ac858717c80dd49511574636fc868ad53939054dc817601ff6356ba4cf4268c1e78be513cdc9d3189c5f6e454d77e82e04145c0ac341970b4e9ac5c078b75a3ecad05dedfab7b1c3d37d1ae11be4d906bd41e412b7d45b6b095545ce62c89822dd08ce60dea11a53b0cfe2e6935acffd64a3b689179b44a91bfbc6c8d5e16b74ae60256f767180825f779a4fe5ba8cdcbdcd28ac02a27c868315ff46d468ca65148b788cc98cbe0bcb244b93ab95c1f7e8063f18e604140b10c75f6df8449d962012ad7c2128d334824fd66ad7ba4864266fd24945d6d633b42a087e63c3f74845e093230d648c26860789efee15b6c91a5ae18844a97e1cac16acffb0b98c8b517f63eccb4e121f60a8e1f8f1c4c4f9edb826b6c58f81988ddb188ba27d2911a53f77041c6180d1a41d3275c6c739d5b9ef9ae84fcde83cadc3367e25e37733a1971a09c94f9661dafa01131ffdd6df654f16793e866b3b90b56bcd52d4893aa912c0d7649afda8ed0ee24a29489d7168b848822f7ae4f8df2b29c0ef83b071b0791e2ba72e87b7f96178dd833f6ec0d6c4dea9cfc30682bfe6334d34c78a85c0f8f14f19296586b6b45a062035d04fca02f6b34cf83f68cfb3b8d8108ae367567abd600b6e0706a43e580c30a463c9ef244d7c7ee41fef441b84607c81c66ba05fb0ec70e496dc21f1631183efe404a1bd251bfec1aa3efcc7b59cd197db7ed05d7bcdb115f5c4c9297c39dac93b1c8dfdfffd30fb9c8848212e5736021bc06201633c44cf0585b2279296295bdc950a1e7ab09bc2819d694f3753a00af3ac3658cea75056af805aee952215da8ec52e926612d8e471fdf32c9de548f2dad980d07a6fc1d617ef2502eabf57a13a502ec426bd91f5a1fde83f46eecfe41187ef52f6392e3038c8bf8926eacc1648309ead668448a26e57a7783b826724555a847cfa0efc41d31e33b836a93139da0634d04d71e05f32b19cf0bf4b657bd4f2b95f0c63c33359cf266e994d6d82df2f47c2bf50856187d94fe5dfc007bc7c710d634cf030bf3bef2f36203263852187de172faaba4c5f97dd7a6ee033e8055f0e826d892e8cb2d7a957ccb4e2ac5e727d198996a2d50aa96be32c9e9c48017ff6ac96a275f0bdd48295b3bffc557c5a81b31bf217cd0a55c3566cda199b9406b933608543b6a18d826145d18bdb27460abc3f8aea0ae220a0b1b5e73c51c9a4c80fbfc81ba2f88c52ac1a612db4d12231cd73050b4442d23001905c0761917629dff092431422b369e652c6ff0d01a2731c43de87224d6222d4220a488f25d58c3cfa45c2542659b24e75785020a71567f3a7d2101e2deba660a4febdc59b180fbabf059e5bac306b16f1d1d3552c94e2d145951a60499d8636598e8e9763c1cedc78db0e3a79f60efb2ce4870ed7ab10a09dd891bc8ffbe785c6702bac3527ea6873c6637092c23af6086aa952ac44718ca20dcd6a47b22158fc7244929d915424cfcff983a8b47135aaf75e9155f627826cc4f5ddd4cfa5075d95e1872105ef8b4caacae5c09dd618021503d7c69f3db5d4d6ae4684d284b688a34890c58a627516faa07346299fe81bb4929949d7b62e2ba8746705cd5d55c7cf242db237e4dd54a52506f717b8af28bfffb87a273d606594674e982ccbd17c54001fd1ec541dc1c98bdd4b734cb811329bd7b80f7b015001aa779a6eb022c0a7be8734807ab1eead20ae0ffdc32449b85029a634e44100c399fd35bf5e9f0b5d011f46126860b5003b23e45d7c4d6d75a614e34875e79582f05e9a8427a5948003de79228f189027727d33e1145bb2cc0cd8e7804b5affa24cc7161c2baa340f5f38fe8cb2f5a3e4f3ef6ad2ef732c9590e58bb0e60c512bfe76ebb7324f137b521f62431c05c9b55b3ff91a2b738bf8feb10e100fe7f5cee39073c1aabda206fa8bf508a77c1f23332ac38d395b0a26d2edcded181540f04e7c93f2a9b90fe77d8ca34d67c2a5fba16aa9922e4bd8d810877a4b83a40555c839752c62e7dc7359b95b6188427e59d0bdaee01fe8efba1869e69196a48b874ba70da6138d215cff546c2018137d1feedd5cf7096bd0d799204e2e0b780603c81a8c257a343965796dd88636d5f45cd893338ad549d7c684453c46b060bb786ad88f7d021a71b4f4be0bed48d25aa2c377489c24c73fe5dc90d0562a7d5ce9f315f7fefa3dd04625179eb084990378a10ce0da520be4af7a0848396f437027cf4789898749f8a72ad9ecbee51c8dac29e4a17ade7f5b6968cc59cb03f4ba1d057063f5fd5745a2b89047a6a3841eda5e687de2e1440883b19ac543f6bcac01c7d7ea1c2ebae855364ea36873f1958c4a2c51accf94ba4cc7925445def9d54e4ee740fe910d3c061c45e8155ba0cb135f36307d70a2b6857cedc5425318c80c3c7c56d132a5a539bd72eb4ef4d14af95d93c8d46bd630e6a195cee20cab1caaa7b41263659d6c026957ecb16f626fa05c72931e1553b89a4029fbdf4a7267cbcc02910cb9f83f8f2f0a505bb7294ed3395630cf72e2897f34ef0e52d949388440ca7556b51af978ac5bc37ab125815a14da577f5931fe0d1cf26d8d4a0a784d9fdd067f780b702a0aa0a9cae58499c15e3f98314eb0cd0c9541d7e1c7ea0ce6a39eb7eff3fb8cd2d5a60312fb5a4fdcfae002ac3343617f4fd0665c2e2df25391b13ba622ed7665741ce5bddc3263f56261e466c4bf90d144317d2ec4092af664026f83cd4f1620138c4d29d83d659d3ec3c95e0d15c6ae4609644eab2142be81072cbdc032f1c1ef47a7bbcb9be036a31c3ebec8533de876ffa8882fafe32c62ff2bacaa8c2e5e9d7dcd93781b0920fad1d53b58ae796fa9d8c6434ae54b183973e97773ac48e71103379e2c1c622b0be69c1408a344f7c253459b34c32b416464e3cbe11427e7a1fd395d7c6c1d46f731b150b29e457e98a7d5924ebc408a38fc6cb0c7520f1c5c1722da4fa39c0c76950ef1beaeed0e5dfe24fa6be86858e1aadca059a42230a9fb481978d5877e2724a47f68c47e5777b65cbcf7be66e952c1726a68390e947ce485dded1e16c57ebad7398e7ee8c627f4ab61c1c2807b1285ddc265465034ea17f6f01d547bd63fd8cbc1a88d5dc6884ab80dc305f967bcaf752c27d2ccdd9ef422dd3caec5195679940af773ea8e812d24dc7aa7008ef9215a5349ffd73e01a4f25b2044bcf9a0906e367cc2fa328421ad3ba19d43e57cb5c13829dd1d0a626b05c95f96324a874433c471710fcca39632836a2150a25cd9af9109439102a299c0cd45d5adf119c571310b4cf3ee7e3ff191d16d574dcd4b71b0f48b78e62aa94438c8185cb98058e1dceaebd272a253dadea1aa8ce0bc4fdfbf3ee6b762a143eda26e0ca71951d4381f5d0094c12fc977f75305ef8c54cb8a0e691153f7f174fe67e6c2af9cbf2531c3c5def258e50b5427be17874a8e30f1d7271a1b0ea6b22bedde394c6ec91170515b1c3b1c445851bc40464d9c38e0d13f1746c591ff2b13bcfdbe2e5738267e837bcf1e3f8e41a91f07b835a6b1b8793c2a86787ea1f8bfec3ecb9d6f58e4a26a43a7db3a220ffef3c2c4f9a3317d0d39f4e325bce69cf18b387b2127f80d5719ac8aeaa101d1917cbb4da6778d164751f10c6d63427319486bd781fdfae3a5a72ad18a65b4af074cdccee0ec5cfce033a52bfeb2adf6fb35c426c2f4ee5040beaa6a7469efb555d2b884db2c49dc269fec447169c78cb14a14975b7aeca970a8014f5eb3f4223e80c911c0551d27dd8d726aa10b92bee660feedba940b431701451e3816b0359e0d742124dd698e3e24c21b309579eba419f6bf93bfc0874f4bce8bb5fb1feaa982730d4c25c992b556105ddb2fb2400001ccd167233a0c261695dbef63f0a23380f073675afae6381fab2f80b50705ea1e9e24df728457068ce1d9d0f570017f665c4c9d8a30f6308450cb160de86d52d38ceb69889318ac1be7c035878106ffba3cbdddbe814fe3b567407e7ea27c00bc0b687152036879f9f3b161447da4e18135eba7a1763dd944351370f8d44282b6a0d46051f363453c41b17423ef4c136e8f2912e51a6c4d6632d533b68317c8ed23db5beaa3e609243e12f18544e18fba68687afed93ba4c8e2aea56d9060e62991baa3e0567dca7eb7420359488aaf33bf22048e9acae43bf77d2472602838be9905ae6fc1d5a8de0378a7c6ce73c62a16b627b29af6fe1f0d4d689d5f2743e1619d56e6357451b2307617fdf735288238a6da2b8c867460aa487ae78058d9ffcbf16908865486817feb39e2e8c26e805adf611340279da8fbcd43c7e88098ecc46adbd3b75ad1b080114d45f02d52bc48db9416592d7344d4672867d3d43b2920735627fa5e742b61e32e94e2f7079e9fd43c0420d7f8775808699cf760974d4c68713e7253c1206891d510ed85871a5e62f9b25cc69ff6ef1c76d6d3ecbf87c40766bd7ee9993b8a468d7ff7305d36f63c3bb082ef82c728b9965e0d3628b2dec57d54855f2c153094a6adbd69f323412e81b19c90cf384474b319b718f0788da35480e05e2ba55fb810e1177a6857a0d6d65892ea4fabd7a4c31a3cc3920ed4dc38d845756fb311072a2a35ad9a4cdad5059c5286d1cf5cdd7580a08c264bacd4843020025934d27697582a5da17d5d3bee9a0bf865e02610f3cde0e42ea51fc58e668d31155cd25941e8d6042a5aa8cad0c955c88e675d5fd60c61fecc3c11cfb3974bb753131faba53554408adf0cfdc2945db242295a958a1eba9fd9a0f393f0a76eb39a3e0c407812c3216894e9f48ef23e89b9b3ebd431c6fcdcb182e1bab7990dcba787adebecb30b2ae0352eb130bf09a443f000dc9d81fc9f5f5f93143473edfa37ee106cc164e975c760d57ccd514e7d3085a367f4c688fc5a12405dad44aebc25ef0251dbc41ceb57ffb3c775aab60cb28699154d347fd9c29571451f783768e0fd604c935c6a445e0711d408742f2f7d39ead77424b2056d9b9ba84b4b927b2305472e426c15ffce1c21caf24d5d937c84ff3f41c2d0763adebc52a568ecda27a5c3980a9c7abc314915e46eb024c3f8ce8896c9c23829112723722f0b4481fad86615d062e2d55a1d25e3f93939f4492211571714dc6e8bd9f881c7119a2b096d882315b6742e4770c2ef536e6476b1df0a48cc8967b39ed9ef273199219e5282b46f893e02ffa2d9daf202fdc76f1d9288f093ee6ddc13fc1d96d651ec069ec91f21603cbe4bb30bcaba70fa60f6bcd2452656d18259d5ac7fb375e8d3ec139d288c6d616d352c49145ca3a992a1b4f3b3cc0bfb3dfaed816fb573e9240e8e3451f0b71c53c81a37f10aca3a39241c96aee37ec920805f8da64f87099b30c787b59130bc849d3e07bfdbc9783f582f5c5151f60576aeec65007e8df336fda5807be1907334e0ab5239284d5be340505eadaa980cd0f38eb03506a6bead4176e2f17b6f263fb7cb21aa518eb4cccbc24380338e7945b2951d7235764470718270cb62a28ca375d5efaca3e94e7c8e980fd88207995a0ff2e8bc192efbf8846d0619c3b2b8e956a170f0cd343ca1f5864dbf6c4f79698459d5690cb0ee9c7983397e854f65e34f0230b063bccd37f1fb098fe3382d772dbf1a81188fc5424d6c9f89db0c90abec9c337464d67fc2524271ffca13324ffb9dbd9c277f8b02fc776de7e34b0d2242267eb4b4d7a62ad06446ddc7090ab5b9b625abf18db4c7b58238cc3c093d48f6145e794790494fccecb1d32d419cba08763598ad9034f18f33c6aaa200590f2f91f87f4b0bf74b2c156ef2ac51eb914b9357db3d1aae4c5b84ce5ff623a6cb6d53b6dd01784115973f0b562ab4d2d8adeb025b7bee610fd37df0a636e79e0698e9a58992876979f4a3f12cb8bb399cd55f52860ace3a9c647cc56f81108680f94bbb54bd22417d426ed19e9a8ff4600e79907d609348c5afa1f08911ac77b214dc7b8e95fdf75202df39ea7d6e846c03b292518cbbede8916cc42200e9351108e7c6aabcb77840aebfd3f3a511dc52358a422a47b6f9d03da2605c8e3672bad8bb797eac9682db09785ca133cd8a946fa313f86c803985da18ac71973b2d28a879808a7db19793d439c846d85d6e23769819963d3db12c25d64903191b53681bcf87bcd5aecf51d33b2c7a8158be063bf61bb820fa36b24491dc95ead420c514229ecbad2321cc20dfe4957be038cce9cb96eab2c8f6e7edb29155d1dd2415236de6f581aaef6202dd20919a69fe371be0b154f42498b72dd6b85edfd2c782805ec0140e4faf10dffae68f79e8f6cbe9dfc8a54195c92f29c5132ad9e45bfcd319c991bb772306f70e02c307777f39626f8f0f1d111d8bc71147ab4385a292260015bfb0733506989fac604d5911abf6c758a6a2fa12699c4497e3107fad16ed4897c911d9a3700eedcd40b2c0e0605abd24b583b82b8eba5f91ab3184e392ca6bc4a224a6818ac3792d276619cf1ee644609e67c9dfc6528ec3e8acf4a84dbf400733676701e03f543a2c8d2c525046c523cbe8d7c2b11a8e2ca6bc746cef9f1e1f5732c400c2bec63258634782fd27ee5a9e317a1300ed281ec6de7c357a18ca554d48cc114b14bad3a6d207436ea2404cc70b3bd58a9c6dc142f0aa2b8f5840de699b7e3c6e2eaa9b49779115eb9701640b81b47c6014fadad760f1a2606a16db90dd0b974faf22d61cc3aacc47fb6d76a68c899fba4c1f50d1f478452dbcb5c08cc6677bc768e31d2179c4ea3441153067258c8c7d9edd4bdbae87cae9669e6de0b639180b79fa8584db2d0497e9b915be49822ea206f606e04f7cdfe25db02da3ac43361f491f853875be9aaf2d4c419800887153c8781a89749236c937e64ada4da66184eb9099b07ec53e8cd912df484a157a13962227eadec82c3eedc8ccb3ebae648f118d7610cd57461449db3bf0287ac59b8f0e7e9c8be44d51574ae039cb5c1d12da7d8e2e6fcfb6b15f7261c98169e92e889833b0707a0d50177a7c4ab772887597bcaf82deac83fd9f559bafd6a1f79e81e494843bb82a9d37a5ff631da7d517729b783189aeac869ae2d1e9b5fc40234265f567f1271c7a82f160cdeab44cf41f31561c07435806fa3f5666e8eb74c2e3d6dc96df76ed7bd9134131d1c373eddb3f05fb7ee1d6fd77c92dce5462a9fdab2929fffc977ee3388ec7a229d0ebae36df1e73272bb857e96af8d89f4dd1bf852062daaf5d00672a099df727db7704a909405d508e4e464f3445944046ad61e3e05f1483f0550b0135dcdfbda745452c404cd98f8710709cb79c9817d72e1ad8ed5aa1227884f48b225edea18b9ad4c09c6851e5fde13ba61285ef4eafbc240644dbce14d11411aa547fc071ce7761741e4425db0bc8eacefc0857a17117054235bd95a5e8c86e75e41cb4792f3dd6b150273ecedc7af0a62413925caf05bbac346bc44ce7d5fca35ea30a8fe6baeeb8db6741ce9d5e17155d860bfbba5e3691c786897bbd7d481b5eceb78e4935669817ecf9e0d08013c74715ed4887fc24c70a56d6fa5656f5e1e918d2837528ade9fb55e50d0e799bbe9f2b0619f3251d94006992d7cade789620f059733a2d300e9d5c662370f5ed9f41230349409c4d311dc35707c69a49e2d2a9e30409f6b3b0a8d0eec6fe724fa82172d1a3596b800326d9c51ec37b5ed8d999ead5b3ca2cb934ee4196d304982b617a417f9667a1cea8929664af8d39001c2eccdb9ac75e501f438945d5590bf25125164de907018a935c9a62cb153d79e97481dbb623ca4bf1df0b5c8c3e851c712c4d89ff87ee78d61a7b50e27d6751d3898c8b18d335b6b5ced6450304ddc22cda57e7ecf92c7a2827e1a7259af92c703ea7e07a72c8086cbe5667e6b32b2a88e8b5afc912e164569a911e599b74cf63bddad6e2e0b1c432f3146824f67eb83de8019d3046fe7c4b260ddc41c01284db26b2964ad18b76af5f40a8b69b21f242c8b94b9a4edd5e3fde5f365511294b76f5636de33ce769b4bd3e72a4e2ea63f6f3c72630d1869956c66a0570ee8dd5f892b9c91048f8d1aff2da9bcead942825986d84c49a1bdf10674a528279b2d5136726fa9fe30bb590e001efc969a441dacbf551410cda84d4f682bc1ec2927681af7477f0174eaf018cbe5b80373ebaa3ab1d3c6f145e15acd7c7428602ad694202f8adbcdf5313f17efce9693acf666c80fbdda53db39a83ff13079382c2e83feaa7fb0ff2793254414cdc4e5c04ad04b0243a775d363e407a6a737dc0ed7bf2182517aa9f6c92b8597431dc2dc4939818b4502c737f80d3eacba4b55abedc64f895981a4c4deb5d83bb668877695165d1443b6065f1e12517a56671526a7665d69e242dbbf672ec67580d06e189b7bdc30379e449f30c2fc1d5cd9b98300b5d0b703e95cb3c1582c92ef599cb572229454851df791379529342f46e1616c4bf4c86042315075a7260a9a4ac5a270ce4863bbecbb27b981d3d9bea8be6983b466eaaf1d54df7d6f80f2116a966376b7f9d760e3268a10f6f3b61b40d7e18a9921f47fc43ad8be14fb44d52c5b845e5b2e4fbe573a2166c4a4779f7123d3a183152da1e1d7f0e626b8a27b04a7a0a28c7f0bc7288ddfea71c7e7f48aac888b0e3b15cd9a76ac26f5afc63f1d2a7158cbc05780016b38c792e55df6cc7679d2da25c8283c2af9c525b8456b3fb78168f5355bf9cd65cffee2661e7bf3c3634b10d7d8ef98843a602b5d5ca220a87fd78963dc06ba8eaec93a8df74e93108342d40056a933acbb8bfe7bd94456535578bcd6d2da6845ebe8c6c6ec2a7df887e2d0d90a897ccf912c4208f1ac8653fc19a39a8c29145b1ea822f665f3ca1431e6180689882d966afb24c3fc44d2d3b6e371ef0dfa149c15cf81bd1d1d2d6184c54220d8c68c819a9b6896d184938d9af5235c08b12ae672f2d1323e409e2fba2aa12271c376c39ae97bcb674c89bf2663a52e6f4208b2952b4053095c7de4abb42f1b5703f99c278072173cbbc8d81b4302b35c640d9e626bc8c48536b3cb740a7d0d018da95440f233448343b52b69de5faf75ae1777061d7b96345f2d76ef093e036347e0a1b0f3a155278b08a442aca72e4686e376faaaaeb5ae7f203d01cdd98013fa648c77539c27e2478930cc69737a9111ae497248e030f7ea063ce5013dbe0347de292a9d577b4f403eb59fad2966f389ea7964a9b7a05162026b98d3218ed88bcbdf91f38098c9e04e06fa6ba9f3c9693e0cafb43f0ba6f5d1c255d955a4263a5ec53d3358fce154f5870480f98d11c72e272bc58831b2ae58c687d300856a7d9343e7ddb39ac04d5adeca3a59260749db8023d4bfbdcad405bf4e138c3561dd360b496346ac1819a75b4f4c2f62416aee5dc53cee4f89e7f69c04ef17921029060a82a97b75f80daff91c666d1f341409236f1ecba98fb5b08c67c15b9d160f9056959c2ac923122391d1ada11aabd4e09917cb60387c213d9cfc2024a79a8f59e8567c6d618cf0aaea2a3c826a12fa1b5d739d0e4765a1bdaadab3cad27ebeb90564ae826b92c4281cc315b5d91d90f06b26c8f09b5f5388481e463d220e9aa2cc5c0d3b5745d4291be9210d03b939accfff33ecb001a8b406d3273d81423b5cfdea559eff9cc2d739005f76b9070062f9a6910303631f294d7563ce4b37c84051cdbbdf8f4170365288d486560f9e9b033be5f08749adbfb7647ed6ae9ca2f3e4794a9ad52bf218e67a0ca81a1d954363d8e5a0772fdf3e30a29032c4e173641a2cbe4218eb0891799cd89e8dc5f326141dd91b2682e2ae92f0635f18cb2dc646c0d4ac2dd78103620290ac44cfcc23058e9c36721a65909984cc7f09a65f1db3522e48db25ebf17353e1df901ce8b8f1ab07ab50d89bed7ae09338db58cc9f24bddbab7fd16f1379a58a05d5785a6a1f84e878e5162a0dab6020a84507213e3cc07878b554e1da952c3020f9695d82123d8953f94b49ebffdd73574d53a02b77f67ed807073f6cbfce6d5eadd3eb4dfb02579cc4c559fe3f1a18bf88c16cd7bf9348314c1e1a0903acea6708ec156ce2dbfd39dde55e6b7975d8e91a97740336e1766e4eeb542fef3320d4de0341b90499b3f5f92a561cf78a6b2b83ea436256541d49a4488dec37dd6aef348916cf404d3f4fd30f4dfe257b5aeadda496e6497e489872a257485fcc31fbca96cf2e79489ffaf4fd6321451919d817232833341fb51cf172612f9453795aa0563042b2e65fbda73a8e444523472ff8a568186cc8fd44ac5c363dc57a3b90dc45d64fae788693ae21e02d3d6a914609179a416c10972b9b0202fd64a6d64a2cb237fd60ca6e502aeea19c76caafa54cecdceb4656b2731486884fc39b855a9fab4b43467a45a090bea1a1c2f522e675c437b04c54128d3b42969225a3a0ade65d035a76eb530db6c2a7591f7e24de6e2cf165351a871a76566ffffcc8b71d1f58de4c0371800a4ad00020d859d1a5809f45179e0a696f5d76baab213c16605303d2b4d0b7e1b4614021776b9388dde363d7501d2e557d005e5652f0da08d385212866ae6f036a476f18aae2f76c24e73b72fabd84898f74f42c504e878199729464b83f50fae12abbbdc25753f8eeb3abcd9baa7173f6e8dd2f9b6f659225b10cf5467395b0ef36ee3ae32dc29cd68a669701a70b68305abdaa5a6ede26c96037945856b350c18260e093770dc8c5fcfdcf7f0bccefd2222818b5c9d0a6b836c5455545b947c2368f8f1639fd6d27a455486b9796ec476f3b2fa8d32433b58b75cdb41045bdba7942787aabe49e7a82c2589238a3bdb8dbfda836261101ef433cf1016d7d8a944303f5f9835889c3bb23059c9c52b5caf1983c3288ba11b5c679287c47a284457735745279a1caabf92d1336205a46833721cecbbd0ccf101da58241afbe125f99cec955ea05cce84a0db01e772c7333c95a2019ff18bb03c53200d2e85148bf7959db56f76817da2c1c423f86bff5192d74913343f53a196a99a43d19dc67ae12aa935c2ea5add66762666613d2c46723a0340286a7c94b34346d90c2f4700d4c48e57cc19534dc1300d73b6f0bf5887d788cc1233564245225c34cb2829735d0f69fa40384a8629942e5bcd83390eb254dbb880aafe6c0a115b2ec8391f08909e0fd0ac008324c8f9178b79c4fbfc4856a317fa46d5398b546eb0491c35513c1e6c8872d22bd792be2c4989a87951a218f733bd28fe738ac1743deffa55a3321706ff545f115d47b469b86eced3f4de27a790934412710cd0a420e41784b4b1056611e59d731665316e243aefa88465f658d3fdcffcae3f9314b8d0e886c4756ca1df8befa2d6e42341789081b3f92445f49c1abeddce19f7ae2152b3e8d780bb9496439c537d4b681c8dd10dd4999934b8db12e8fb22203d6e3ae62cf5d1a1acc17303d900eb08b681d01de4c0411bc43956742b1c0dc5d19851c4f62e79f1363609b5a5c8febbd20ad422a37147e113a235d0a0cb0de4e963a46d471936259b47814f65738137c2bb5d3a95197d4ee9610f6204a4d31e69eda6228788cff9819afed113d55a3e1b2bc374d98ae1a8e8b290be03341e99acaa78e2ba80d118f2b55731b73aa492af6725a0883f847976bbd45b1c4de46d48050e3d6dc3c07d7c470c43e072d8b618333603988be41b1fe5e5767ee17594300d7db8faad65b9dbb69195cd21050c870bc1b2a8470108ff1500631da12208b8d77336c975ce870e153c43e19f8ebe84427af2cf801c2108e2dfe9ce34edfb95a01521bbd4fbc626fef371b6dd5f1951e6c1c9226411cbffef06ccc5102a1e8ddbe980361cfa8428bc5b454dbb608c6634a2e98c0c82f78cb3f1a3f2055d37e43987586cbe2131cc9effd61df07cd5cd55a9e0eebdbee98242be03d30917b3bc4814a3efb7e5c0bc062fcfeb0662cf7c808cb5ccc02629b52c9278432e4055361a9e37cdb0b566719290c044fd95b44d5e81d0176973b35cebbed6099cec71efb2884e95802049f9726a86bec170f79e80efd0ec37a75ad4fe7e5f3ccd7ab941f5dcc7b02c00306","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
