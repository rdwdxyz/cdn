<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"316e74473c6972819d7284eaead89179d4a2ba565f57a927417f3f41442d26696e57cf792025301d87145fc854e7f597b88fa4009733809368034724d009946ead5a0d93da073672367a92c9e73663c6ab0dcd1596a62ac2185e4af607c79386ff84a7336454c4e9fbca0857f33fb62a48f0a72c4561d0f18f05da1422535f8a557be2caf960efaf4f17b0e7267358a9a22717f1af627b38f4acfed3a9298ccc41beaaf57b3373e67e465fe77269d966e003a1dd74692b0f03938c131268814343a55f0013e760bf91f041727af42db7c5886d168488ef7f5cb5053b27942e9748df32ac0e372fb73415ff39d7a4403ceae4c1f6dd77016a7b735e325ab7c850448fccca26f48f70700fe2aabcb905d09bc00e3809c59bf78eff6a0226faa06545a3ed82195c8a268522ecf541116b8441b071fa10dff6d5859ab4c00159c2aa96295d456311b3d4710605ac4c42f99aea042dff0e9a4cb3a71676f6add406f7e7ffaa5315554d7b4f958f62bc1396609a8d65df14590800f6f2c2d393dbc65b81f66121e76adcee2a5ff53e169733bb7acecfe7493b00c32535b238ec4ae860b7803e68aaed3066d8de78e54867588df5a14a870171d46327b3c9b6a92602289ddef1d839d01cd28a18df99c979a7c8585bd932116c5d4430d1b5269736d7e90a3d3e3562b13f5266edea977a7a2c146ebe802068cd0a15f0a997edf4b3200aac758000537639f9b8a0d48caa54426fd0b5748881687f38f721abb360003a5c8b102f8f0287ce871809d062ff245b50031afa38f9b8c15ead89e0852cadd3767fa81712f03e0666d98e75214e0a85c86d61ce58e76be7afca7c22854f1b5cb075ebb69d823c145e276d5715ee204533bf1cc75dcc958370961184ef7cf857761ee72cfc126a5af8413c898c9894b6bb753b884a322d24637ad5534f3836b93d2fddd90537a1ea4baaf488ad8ed3841568443ba8fbb5e844253ffc3035c4869e957c13a00670a4fe1132ffb7fb9092eacb5280eb2c0bc416e9e7de59af9ee0f0ac14c69ffa1b4c865d52dabdb462670b74d79d35c81b6db846cb513622cce885337db2c01a1d6311c7b0c64d23aefe2ed5075912369cba9780140c1ecc66ee7d414c049ada2c43ccc20edcc98f0d3e4a6586cb9b57892609a466de38dc8c07c8ca7120cbb01d00759d70a6b16a894840f30045207d9338c9c3236692e67edca987c1d06c678bdb1df62f6999f8e1a212952835d69ce3b724671b37be42e607b57e10e5f30cd631d4fc9c75aff6f608c4d18e83ff419bf90c18b762d9ff5c421bb1bb982a1933642e0e57e2c2315c637b5a11c726e0fa73cd43957ffed110213a5ab62ef5f7a865f203f089995dd3300882df339039dd0ca01a64ff2d80f0dc49212c92c2bd88d7d965d88381db8c98d685fc5d8367dfa70525b8bb6b1063f8a4ff912d1736f27b99b0ff9617972cc18d78ad21f03fe62109d7db36dc1c90efeb821410a596f4397fe1e274238dc0d063881c0d46235303e151c4e4bda6a6097a77fd76e199e6e96b622938c8f9d9e83fb03993e4400473cc1b212a7957d40debb56fa628d214063b99f4d39f3a8e2e4b356e54189c01936e506cea4eb73439c7fdc26e330e76f4895a3a8ef86aec8dbe41bff374abf6fca5e24e860583506d18331ce3e45768bd72a5a32958ec99b5f612f02ae29fa0650d0f7a1aab57ba9587be9d1779cfcae68800b7bc4df0e3764b6263f50b6e591fa837647f787fa5a641a73e441d3097b81e9d2a394308a0ce49daa16624f84f26b99c0f8b2fe093b0f823d4bbbff72ffc93eba6f1b8f10900c6616cd15a9254c369a42ae690853cbce51f7279e87aeb00f6424c839117599d5f912fc675fbedbd49196059c19bb984692b893bd27e31d70c2f08422d305dd3a905825d768fde6d8d8070a33ccd56119301dff044cccd5ee69952da51d2ae6ba08b5d5af17d7f5005d97f06cc88ae624f7eef8c42d71a2eb21600cf70deca1679b354b430d2ce05dee4ea64771a6b5ca7b97356d90251c1f496aa4942fc2ee332956d60fc5fb4d8374c2b9b4e73a8678cd670197da6c39f522637e989ad3449724c2f79b395e183f4e38a84fc66dfc866e735133e8c6106f44b747c25ab84e1635fb9afd41a4588e7095add4de6310ff831160517229454c06c9e3d4a6482736108448924bf0b39553271b6a12724e7b35025f590b666668178d72da73b8a966489c1955f3eb4c82444e43a8d8f084badb81e753e61f18a9bc84920fbff9f2d1280a7df76c714f687fe22e2602f4f2bb4c4df495204a37e1ae9994ef74568c3d369fe3b7b78f3535c7805e9f0eed8ec2df3e303b7b08fd8900e32f39f4d0114a44306432478aa8bfa7fb1a071cf9fb79de2e7d3ff180ffc3bc7d32b8c9d5bd6febd2dcd010e21f3c5f924ada76dcad77b3a8b81b8bdae3130299b45e6d3117d68f9e8ea438dc60ed6bc7187af4a86cbefe6c513e890509698f9809e1d05051a6d4f8da61c55628e801e3f9d0e659745e9359f70d788496968e49e786eb37582bd5ee4bf584d8ce6b3754201314998a17838e9e7416a0a4615e4333d5385a175cd0dc96dcb32636b223090310f4b285854c639bfb52afd51cb2b8cf316adbaa240b58b868b36bfae00f841a3af2e642caad16436bf21cf4f34486a387ef320f68c7f3d5da57c7ec833a839330b7e495215ec9aa42f6da9e9e51f4c62a4f74d05c62f1b4916ca4dddb825117d02fe173970f78796947a11a603919257aadbc29f79e261c562bf286e8f2675047ce40b5bb436ff90a5fcfb4e2261bcb26596aa711d3d06aebc3fd3e116f00bcd95ed9a094c588d8c51d91826997ef5ad9d0cf0207c4881bc9ffade9c448e79aac5e1670203e5d69386aff859d3ea78e70885109db0c5436ef45e96d26f9644c3b48c7ed2e9298f0c58eb7a5d726f3f5b8e1432d68a5d830284aa39a294d161d59410d18ecf5c41e405861a11afb3a22068a7d6ebe24c647fe02d0c2cbce1e82db3e5d5dfe651f57d547b88cfcfc1258f1d9bcf1f7400bbfe1cb1021f8c71ef20f359befa253635bcbcf5d50e806559e41ce81878f44fe8489c8aca220706d983f85740f3ec4f1cb9188898ca35519c52cba756c48ca59a1109ca600279d70ad05e6bf38da9df24c5abfce5038f292454eb623d11aaaca6150553a2d8c4dc29952ab3945443916810f43660b9a6e8d60e6491e32920706815d7eba78975c631b5b79df160a458fd3398221ae924c3b73ed27a28d9b97db0c339d1b6fa1ae5dc1957a8d90e07827234a9ea38b003ef40499d655bdcbe9540ac7e9e7c65f6182c41a5e18be57c5bd9cd05146ac677c988a4ac9a49febf42d78479b73e3936e42b102bf66b90881f4066efef87f8a87e5cc8806caf655b06d4475506d4247198ab11b55f851eaaff0e00b3900560bfa98971f8070d698106ccd776a8e9bc6ddec63cce8a77a34eda8acc127491a21ceb1f9682c846656c3b0dce5ae68057810ab05c17225a6cee3b138f3f230f6c2e4a5c119f2346c481c5ecea5bd6e7cf4529423f387c74f81da43d6d4a57d116a223b7efd22993f8046b9da2765585d4f021d9cf05be16362cb48873e2d028f674e973cee73ccc0b5d804ded9ed2e110f5489f0be1354df5322ea37bf1a72f1eb213717d073a7581b2ee2de93379e484a82facc88f9475788d2fa2e441e8cbf3d5b86cc08742bbe581eced8df82d5567f8e00f38ed8e63672720e67bb6bf1072dc0c1c27ac85f4f5e02e469f5d1ea823d18ae900d5ade324dbe92c4a14f27c746dbe485ff7bb509dff3ee584d26a9fc6a45100625ef1208e461c04936b6562f405420ec89c2d57b11f0d271946850653b377eb02c665c7e59e68084133b64ecb2c28932f4fc6ea853f709b37c1ba923d9448833b7c91222a3dcb85bb813d85bddef0e1d174bc0ca982f032ad9419222d8f6773ec3ebfe49ee43eaf5e2ca4e86387a76f93a66380f95cda67af21a2052253f10ced2629042635f1f55abfd61f8edd0a1a043f45ef75107af5c024fd7bd1795f4ca4dfb061ce6f62dd872c1039fb4d9a7ba027996f15d82de36fc647f55fa04cccce712f8d6af14d9d17973b1dc78cf3378f8bd78eb09654d0b240d5b124eb2e5cac154d53763945581e614af79bc2212da19aaa39e257ac31c89dfd3277967d5d495f377ea87bf98c2f163971ba5ce22eb2cf7abab5366347ba1c7c62d37a7b4dcfaa9d2f8fc789802ed3eb08a5d235070b5dd8004ef7520fd9d90e1e60bcc22f183d3b90d058efdf0cafe7923cb3d47d2a4baa2f4d8607dde8bd0a7ad9d79f70fc6387a2907be3bc10f31f623c533d4a566267091402e3ba4975242299ad03be48670b2dc1dc11aa47434b0efb75a5331e0566d8b78feaf4c199b48881d49b58b8fdf1dc76e5b31eb6662c9c31af8398f8c4b66225d1fb3cc4be2f5c9d683040024906ad83a9aede25cc0a3239061554bef61d6edc1241d25059e15c1bb93330730010a8820607339aac0c260f4f136e1e681a1983e2f038b0235465c498da4f51af90760411387a03a1b4f42080fbe48ff7ee7fa3bc40840bd0d3b8a23c247d5b6fabef33a397e34bc96387ebdbd9f16c47dcb9bff258b0609382c4395a9d8b6899cba45bcffbea953743dadac974a85342e9d7da2366070100f3019a6d9f9595b6b95b4fa1fdd22c16096d9c3064765bc3ccd5f40aa582aa81a83e063f032af84ef7c553e88a65309fe7f1a50d8d3b29e1972f396094c15e8cdf5d77889cf550e6c07775864df502e506bb19e9d0da0da75a10ed408ae93f236d2eea4593e4453a5e82b54bf2a2c8db5a5c48fcd4438657ea0c61d6af12dda9e44c9c73b2b0098b921c6e35d1446485199973b094bd6af740832e479760e2b0d34a663012f7fe62a47f4ae169249571bc115ded447c082fcf4b60e3f9e497508f9b2b9d29f10f3a6ed4921273a64abab8d7be690bcf31f41c755f9f276faab680feedf59505ace133774aacd44ebf2c8f971d3de4cbb248d1a0e99d203d20a673ecaca0e4bb01536ce504605f3ddecef09f5192ffc1ae393c7f6f7f953bff584bcef5800e4316344928c3f862b8bb880d75325b190685996d2124bde163d7bffcb495f0db5df49f8c4b00103549dcff436ceb8f1ab6e9918bd5da28bddc60f43c9bbc29785e44ac0348cfde330465c6690cbdc09d35314373f301e665b8d90f77353bce9e880d2bdc0e0d340d91736c577d6e26919d39181bb7eef475517c5420de65f38a11b2970adcb439520392d50a57a13ed9a0086889f6d0e29c340f7f8d90fd329068b914798b4de269c0d6895b335680765331ab054dfe6390741116b571894409178beb6cd3743d7e80cfe7d15d6ff4ce93d3ead31d2b4ddeaf1b20d88100ac27140a5138a1e98e0dc94c277cc4e47ff55fb8cb9fb8856331087e89353baf34820b995a27334dbc7f4567e427b76eb18194f32222418283cafc247664ff01fb0832659bb831f2a1f06056540f5d2abfdc89e0c48807a6e93a37ff4bcd653d7ecd56e426ab1d9dcc0ad1fcfe17dba56014755eeae6144ffdd0aa257a2f4f1d2e7e7daf48b39d10aa335413d2df5b91c3765553d0a745a47b98cb042fdc255cf59aa26b6999ee9c77282cea1ac33a526cf3795df23e3a25145b4cc08019fb9edc4e3f399315c1a0020221c8a3e9b5628bfe59d637c17294224033ea79be9821cf819e82cad8d231a7f0991b083c94c606b064b6ba1036b3e79d1bb2de1bc262db859dbdf5336dda1bf3b38c547f7473ece55b82326635f4a890a408a814d5fef399f9385fcf2e61964da97685b27d330fe445ef81d033ac0abc8ff636436010c9427dc9317100dfdae14831c9e9227ebe216be2f8fae49ddaa6c004a75be4d9b9ac8472a6008d8f12b1c646897788693a523f2e7dc02b02302f1cf3ca78eed3a7dcba66791d50a5b778112f292a490aaa2226ee5a1992cb4233f7b1562416e01df3aec1bc699cf249c3fce0abd6b580febcb59a22d038cd523660b44141b93ada6f4ae4e712d432e2bf6e2e8dec46a42d64c08bdc315e1beaea5ec128de5801c1f328dfdda0d4ea127635a146a374f4423991e196b289676b8a24aff489cea209f38b305fd85fcd159b9dcef7d771d5631501d0ff8e4ecfe542da36a0476efc0ed110e3edfb702fb6ec68c2280a63e71bbfd0164d1c6b80ce8443c63b42d5432b810873f425712d0037dc33c74271bb638fe559a368bc9be797def512dda70d654257015324717be4ea367faa22436dbe925bddd85a1c356b424bc1ded0f0278d418205aea47f1d157c7e8adc41ddffa738ba650a386394010336b20fcc7d8d4d3844681fa6ed06f58a86c3d427d58f7d8d80c27a91d67cfb3647f2fa296e9370fb338aaf9e6161503746940da721682ff926f2385b313032a9bd5b54f42c6c59bb71aac33cd8de7b6c844156b1a064a6c14f6fa7ad36655a0c738dff178370c3417ebe442bf8a60d10019b2e0fa5a3d75fe712bb9d4161d8afdb7203edf5dace4857a48784843b35005255f9bfdb548a85f0f3c01ab13d12fc272aefda060247a5bc4ac60bda46b18c15810c495c592e045533f188be9b54b793f3bcdddfc794c3c772fa6b95c007fd444702a5b795e19a9771b7fa9e9adcf33baec31604ee8dafe6865809a1ac6a1a7c31eaa5c41592c20f5ed9ff5ebd2678367f41de26716bf434fdfec157a62879616c69e6f78fef16d5d41f92f228d5ff0e1c68a1a2580bc28ac5d7bcd48877235f5331e47ebb8e5c4fdbeced0dbbea19fddd0d3d92c1396de166de8173ff4c54cba95c50aecc07a27701b38fb81b81f01c0f83fa2e50526805b3615859d770a96db902b6e4f97e83620604a87078d682919af8859acfbb5564f06fe92f892c79c89f45d9e3afb5f7e248702dcb1d257315abb967f9bd1e5e2fec8765f999a3d2f071ad84c60b4b4ff083063c8d614e0feee888c9946d18369f80b699ea376289d82832675e0e2daa045e4282e82e44661638761395fd63eb5b9e24093518e811475b36e7bef34d986fa982377df800d75e9591b9262b44e4514ebcd2d02f61203a23942ba803876abeb648e96afbed90f495882e458cc273bb513a58a079fda92063be662039f7ad3221f60e76d2d8cb77d50f09b2a345eab0d0d4e605635b715bafff1e6f1474f84339f40babaa27d607cbe8eecad450344f79ffe5f4c4c00881ab649ce3c1bcd9e3244139c54032cc5849076603fba0ea79fea9f8cd53077a6908a783500e7c1c5203633b2a89c4dea44bb233a0fb9d6d33dcd31d2097a993a1d8da3116d61b89bc97b0ff1b6860364360bb0b9eb972a78649d90dc08966c726e3dc700158630359a301472b2bab8704232efed93d87eac3133dddb40a0b1695394e0a08aa291aa6ce32476ed5e5397bec6ce6afc39bbadfd02155d4e714f6313a84f981b0bfd981162b07b040e3e2f36db07bcf88edd46b4d356ca6608f2ee53abfe4f1e9f031155b37de50688240eef9a528bd6a92379aeef6bf00d33951ddd435c5886177d8ee899cb8242f7cf3cda5fedc9d87f596737e03c0b9fb4c08022d3c59653215671d5fc0cf00e9f674b284dd872eeb61c96792291ca3a37e8955479c93b509455bce9d4e06f59ec9b7f60ee529a8aa37a89ff01aa46b91759dfaf1a61353a6a46af66e622efb5f2f58910725d2df549bc68d4c32d194177b594e5d13334fc8532715fa6249e8c9981f2d5be762c85a42159cb51f9435f92e28b0c7eaed80625bc5b68a0b0661c0c41a0963bc37055fb4aefd16b8f2429f3eb178e94cef6dd9688d0632a947d586ff74f5e47b316e9236de4c16818cb1406d015fc179527aa16c13f9a6c8711386a314a3e226aa9724ab2ffcf43f829c37d8ef3ee5a0eef125fe0d7ca89d907735c0083549688cf4033a7066e00690402151f62cea92f09e43b9084aee5a4692820750489167ffa14aa95a319ec72e4c8e1b09df7e5eea987c7cc6408de8b2f4fa8ba2498c084ac33face6ce81a7f51f5869871e8d6f18c0b4f7a7e80ac0ee19ca86e059b75e14758f7aae7803f593133e4128e8462f6c2fc27f1453dc728c65382a514bff5f8c60c63a800782274937ffcfc099ece39c780b4356709769baa8f5cc2411603d9602e65cd466d1091ca6b8bb18e06e6864ea5ac0d2cb90c073f1574dc9dfe723ffffd0addda572e74bebd92742267d155bf80ce3ee6207bfd4d309b42a40f53fe49911ffa5a88fc08e454ae7f6e6208fb2c3b2b0d2bb0d0985e489af3662626a64ce2fa5135ec7b38e5477ffa1cde72cac76963e62fc03260af91978a47e02da8d0d97166e204e02598530c4d26c91fa4b69314203495628c038c97992c5971edb6a732dfd5e7acc07a6b2d2e80719c9df81deb98eba067ad23a6702856d45949556d8b14e9276a916a3fbdf31b8e260b4a31311a6b1aca126182e82b59ceca53beb37e2648042bf2bd7dae589c135560f921e9b6f60049ac16c08efd56e1cf8f225a43f4c31cf08d1f4963a6607a6a948124a1f69eb1ca5820da6497dd5c8fa78643e240ba040d8a0fa8749b37b6a62bd7c80e5b8152fafea060296082121d63e1e3c264d93ef4de244b5e3931501beb33561e530b2a95e072fe0476ab6235743f3b11c640546c07ec0525dd73dcbe3aa33d6aee61cc170ff43336410b3f704a828f5af2e0269665136bfed11f664ebaf442ab8e9dec8926087c49d68c72818c9ab2a2d01a6b49584b538e7100ee1b991769e11a29101cd84b6c6be7ab644f61d22067fd8c01623e525cf38c59e59ed5cbabfe640932b5fed63534da2f1c14e8052a84a002e671fe6523ca3335d4f5262c68d16d65d511cb38f1c89d97a9a6a230a28f59462065318505ba5a58d2edd104b4513cd6833ba7f443230b772d5c201ca7a77fb51b4e12cbfe0e771b33549ccc373ed4f27c1577e35a4618111c4bdbc3aa0153a57c6ee417d846d3d0fc28ef40c7f108427d882d4fc94c9b78a29ef97ef9352a6b4e83f8637eee8814e0ae2ab507c05bb259b06b01e49509bf9ce3171e313df210995c0936060af5ad8afb420338894e2df0906e69a707a8650210528ba3dbe01348f68d7bb146a5b2aafcb697558d17520e8e5e24eaa71f82bd7ae2bdf71cc8efc9e2c61f14dc6b3a0a4d5b9b146fa66825baecfe634363b6faa407f4428931b62104743b58226374f969a7d388a36061d576db72ad3584feceb96f20e9518a6ff094404948c92b988c918209a58143c53cca6ecdb8a14cdb7c22dabdd79ec90b697415d7070b964fa3a375539880a6a3829fde5de3efc5cab7a2b1fb7a824ce58fb38c1a2cc5b096c6086dfeaec2b7c2f3a670aaaca7a131d4721acf0b1b767beb78a367a269ce480aae50fa3e9ba77d5fe943a848a95a5ad9587ba7df20c05b880142dd6647b24b337b22e5df9b677ded26c61863cb277884dca4bbe0034e1a25c1f37e0d56e37bce4d8a5c6548e35caa210d19488ae5235bf7b1db3dc5cafc902c2c41e631bf8dcf0f0a875ed6657818c7ccd893a383ad0311369a89284aa67b27b163bae0165f9c39e188250e97141e8a04e3a67be13d4a89f056926120ce1f4eccedae9bd6d974840cb4e2b360885e9a13d91835275bb2c9176d17c7a3b27c1d334fdf75e1b10fbf29576d84b06f6f34f1de2770317b2d8b42f10afe722d9e47c55bce11a25de85f4b5efddc1326dd089505325b07176528cdcd66b4c58dbd2f8971a98de1ced7e801214003f0d72782ac98727093af58f463dc628cc3cea13d405ae26f238fef362b57d6b000359820503e96f1b26eab936c4b7a51e2adce7a47c2ac327050fee6d1e004730f6832a8bce28414f9d4fdacf200bbc822bc792ad10be1a4a3266eed291149b7855524d3ca31a72d6ce6da7cab8b3e95bd797af0ccc01aa11dbbd7211c30ec84b73346d9f480391f19c4bd46713f4156b26d239e94e9861edc05382571bbf4f06bd2f5604a4f53117563f04588a658368b10640b411ea7c143d02529002457e6f530bc14523aad93ff1da2d3062c25ce319f157055abf573ddb33abfd1c7f0b3a5ae4cadce92dea575d5fef4735626ae5ab58578a17329bd0329e8ab0f5300de03480f479fb2de6d4659215e058cf6137922fabeabb8e1a571be4d1b2131002500b98f2f4e760bd561f869af74e24b16df9384f57820862fd97a0812d3fd616f2c8465f05698938ae2cdbe95a78a33bfdb783ed12e06ad3ded515ba03c207c10ef6023a681e65f9f6b1ba50cbc51efa04bf496b9500a910753f530b7987b9ad06f0c28bd47f491ac909ba867f7a9c894a792d026b11c1c2561dbbffe009ca91a66aeb724a77e4f0b14325a2b26d8f54790b0ad2cfdc2f62b1d6d890134256bfba6e43ce1cb877cce3561aaf52672030988ff2b9ad876965df085a8d86491b089db051c8804f664036512ec4feb8ccc279f5c4d19041d8b0dc34edb6739b6db75892620e9447c76df2c7e6027876d8e9ed11ee9eb2ee369680ee1ceb377fc9ff7980d5bcf29a5687f8610d713a710cc2af9ede41addc5b3d8579685437cdd99a042f3576673d71941647a5057576a1df67fdd11cf5bb9ec4bf9fe994df9ab5fffa30972003108adc34e7b886258f0f080cc9ccc4441c36662860771f69f69c639407e1abb9becdbdb2bc60d129e176cef63ca6f4c4f3d3e744a88ae4d3808a7942afaf6c4df5300fe56c0ae967f627c017eac73943ede6597935584bddc817fb714711f0214b9301dddabd327aa148c5e99d586c55cd23a4b46e2f50e7aaa7ef24278319afc127eefe7a4c1ae5d960924db79d4e4f866f0d23dc295661c8766308273922f70c4a02cd95ae570357718657bb6074c8b60cceeb39c6e22604fd92f4ca8ba4c26f8430ed31f29e621a36dcbcec2aac8f08089fe35ae7363c8e6087bce6117d0dc9bbe5be0c3fb8f7d093122ee949846df2c54260f0baf4cf00f0a3c4cb25b3ac35bd65b6515ae96fb788637e4ce75acd88fee32d7f8c106b9462060ed34f064e12a227af35058edb4f67c27904dcb85b24959e37ddf1970de0a4cc3cfadabe8d9c3d8a7f3968a69f792270ba5de83e50d101a1257d9ea5b906a3fa5fa2153a1e7041108b79085fd1ba9bcda3cd5ec5629939a37b514f5c6144355719b96640c52eb971b296744297a3566a17853ce0d14349fbf06b121e9514c8de06cb60dc163a87ca68f212e7ee8695b81ce7feafb4b53076f5926bf6f910b451744a096f1e228264c3981c988f31421204041b83c12d879ce7dc7dfce755ef3494b078aa6e42ef50646668d4669bddedc2e5c724c599fe84aff588f73bcbed98ba2feac1011150fad1dba58928579307a6224d92ad7914c43689fe938845f418da1464aa55968b8f1421fbc889d98f23ee5e147264f20b6bceef4da1d464c0e746209e228bb8b60a7efa56e08aa388cc13ff49f848862fe4198683dd0d8c4210e34ceb8d0409ee7766bd4f11dfe28d0c44b16108f5d4fa190a3cfca3e5f81cd4883444e67d0a9930637f0ffd72867de51a948d4a99fde28a26bc13c9183c9aa89785a5bcbe3bcf49e1f6a4236a3b1c03f723a715a3eb05d360172bb46cd4931bbf8f311c15605f65afa1d11f4c7ced43884c6d701a5c164c125602b206c4bf3d8116092710499a5070d3b8fae4ad05163fe1ca93615a30399e7ff53053d7041533f76f74d6433eb82d0650d75b1e571e72b57ef26357825aa7570c9b91e5e9d8f84812d1e0d5d66b0b9700aed1cdb9eb74787d45d0207160db0c1ae77fa142fcf7d8804a15fcf2ce52d7347837d9fb1fb026d0274d8d2bc9d6c9a47527f82a4ac6ae89bc5346f754639ac39b637fd3a64192fc7d4b0b1adc41534911b56a83b48922421461b599b0ba9486998ba6239a8ef6a841289a7ebb487a45b66c9ef26385437f5d9c2d1ff27b39939c64c9a804bc3881d28879390c5378e105772766963bd33e829650f2f7c056fce82d1c64f13b228a0e83cb27c36752bd472b943c939691c45d8c40ad5c5a80b8393331ccb0e2205228065206c7596c7011aab12bdc1a83ab892a521ae97031b8bd8252f115064a80315e716f5105afa94019a09c448cd88809379b9627d44875ef781538feb39c20a17a4040afe2d7711d5ad43c99b91a360474406de6c3ad21cb9c17033e4df9c094a20f836554438a1bf2c6421d2045e6cfa7a49700ca259fea4330a433c8e33c4fc76d06a7f0222aca93dd4e899891082cab75e857b95e3a8f8f3850dcf4f67c7d9c4655e9dfb8577c430b542007f21af1a360a1dd1ec498862b5ca88c7f07ba29c506e038f8437041b8e162bda4174d10c867e8fda7bf12952a4412cd6e809f03d5dddc194de2fc5c8c8e8722a75097d2af34096d6d12058f2a19873431e3c590b0794397f1778ef8cd99fe7f950cd7534f07409872bdd05721cf938eabf79b52a5aff2d1d30f2c910e33e55ca36da56ea5a34f8af5beac689a5113b54e81a2d0d0012f5e5fb820b513862badaee40cfea3543f430b1e19f092dc549274d258b276cc539266f6e0523bd29febfdd5df4549c8cc3cb924ebd494ebdf1fe8887265ac586319b3897a36fef89fcbf560eedd6900b5725879f9f58ad294be3fb6fd9a4e4e3251764ef83cc9c53796dbefd6a397de0e112aeb39efb67f43bc85bf5fbf72493c56346827d27863cb6d9f24fc266f565f6dfddaf022527ea68a71b366dc138857e62a0e3d4783a42b18aaa51afcc95575b07912edeaf74feeb02e89fa1c68b933c6d97d4e652288ad542722ea14bbde329b6bf53324f4b93b89f146993ed7de207f7cd1c17c67bb0a74fbd1620330c3c99ccc40e0bc08fb86425b85596bfc2a5ab727e900219ff0f9c5fbb81320eb3cf6c16f86d14bd9412f3b36ac6f7b0e91371a2fad095f7891b749acdc968828f6fd41239a3588a0091f933b4ec51a250cbc7fda23f6acf8db39dd22bf0634bb087fb512ad6b7a41c448f7b4dde1142fc39c9d9a6c214c2ded76a552b23d886b630250385fd3864b3b1d86bf36eb38d1602cc835d3da25bf6e406219d055bc981ee7962753d9e625325511c96da02942b269e435e6dd9da39f55d80f2d27a3c03007aa931202c353af7fd2cf59bdc35e783a4cd31878fb98b4fbb85d3966f5ce02d787cb1a54bd6f147a7c97496567780f610e4116080a1727dc056eab28ecbf7eb62258df035690884ed86da8f12e7daac7d4cb0bff01377c92b972781af46f298e1b08540015f6c45f92b4211befd598baa96bd4629e7948798030d60da76e456fd379e7b0932b16a459c4ef933cea75f23159ced4b68097f7cdc915e2c686f4633357051263380fbe943985be060e7f04f69dcbeb3a529bf5d6b953c52b10510cc5ce13d22579d5d4141de1db67cbf550ed618762fc7020622f271cbf077e672e4f1dd004ffe5ca2fa0f75b6c1e0343efa59c7a443c3cacd5ba45b981abfa7719bc0dcce809ce9124367169d8f018cb100a8a27cc12b0c30b0d0409c286580b8ed7dba9436029d6226195a8b4e81be09ed439303bf523c17c79ab2862755682bcce4463c662ee38ebf81b30b3aad3c754676b8fc85361723261c471ca297c7534e5b19b03fd5ff1ff35a5c6779443e97eaef19f34d6e07ac4c2b6ca130808a76186b618b1a1a5781fb8b3f3d118658b6b520db0812a38269215036fb7775854f4917a9318f0ad439ffed4388fb5c10eae034db35841b50ddace5755f4d129c60837ab65231dcb639e158bbe2481a75c403cb0d590e40e83e6fc000b278eecf81fca8c4142243eb1f4aa292d6575f5caf04cf777b11855ca348c467759ecb0647e026468397d8d694c6810068dcf9d16c61ea0b2fcc2918ea595853a77ae9c862c0725245dce8fa15f4d90e1e9d704dad112d0b5771e7a5a44217ce91dd8e5ba4d9e8a60cd6efbcb9e80f8beeb154d345efe7758f2925531c770d652290178417dff1ce2bf7e7d40bab742ce3db3aca00e54178affc1901207fe75cb3b747ac0dccd0a89879aba2be5c3fb5cf2f48d3421e7711a636c153ac440525e41ef45bdb60130b866b8390840beb9bb8179a5930a3ee76d96183899d37f4f0dbb2d2767213e1b4277f84feb16edf7db034f00718c698ca2042af21e2a932eaf0a65d9f2277b85e0bb3dcbbe42a1a906e48ea4ebe3d91aedfd04d811b9ba887b9bc4c75546fc01da906a1cf1a17c6e4d17e366cf061635a055964ebec1c92a902d53586735040305835e57e8ed1d4175805787a139c5397cd0335d1484f4178021051ad5c93e66e2857ca272dcced57e1737ee484b02850f11db7e6d23f44faa2ba5dd577fbd4a5b79fde2c171f161cf704cd7859fc9cbeb28c20e43f359035a5588ac096851439af60052b479ff5d8399de36bf0fe9684015b00d5edcae9c1d6daea145d0ff93f2bb54fae640724088450ab022e266d891feb7368a3d6788e6f5d2845fd4d488ba6db7522428eba860e8d8da498635736375b7948a322ee0786da26082ada0bf916ae00a64c010b1a658e04943380b18d990df97a13cb3597b40a3bb2cd52a9aa8148082521e680a082e4384f1b6eb20fb513ee554e579af01090f8b1c5f95b01e9da3f9714fa7e717f8cd9ffc0430116c7862a858480f1aad781b258891a77497afe05a7a07b7fca4d3bcd1b76e6282ed13b99c180971fe64565285da690018d2d7d46e28bf85c74a885b443cc0e6d1d7124b69f79b9a735a34404e061377253cf34c2ebfa6b3c58998dc1c217e145e7544a307a7f7efd90de4aaa5a9aa66c8bc7ced3bc07eaf318ab894facde4ae2cabbc06e16e3a37ae96445bc533c476de09a308e1b2f2b2153665a671351868cce69a38a47a50647f8d8fd3be3a86af74d843dbcedc35a4afe4e8a8344dad8c3d6d03def8e149ee7efc91cbaad2dfe3e374ed6d030873e5b2b906ca579948f1ba8f071d7764f5bb4b40793ef025e519977dab1a93773af00e57d291f0be491e1be729b8fc436dc905555991fd24dd14657d38d5e5f13168245c58f6a910e222e0f941369e2c69dfa92f5f36fdb721590b7541a7f6cf787dc6f170c4128c08cd5633cdbf5ce657ca3b1c0fa18bbec37c80d7da35157cee22947bc14f0f6f224da4704468d69f44d709a69712b1aedc4600746aeba37dc892ae8a20b1f8296a5d01c6c5b64b7493e90e10c9715c3c19424f1e54ed1cac676117d1eb28c866e6bd00833d4672f0d17c40d269c82766e70af028e59a3676f0a1fa8214c01b967c5e63ec66a6c7d963d0cbe50d6807317fce72ae5470f3de9bd7f387620087c1a91c22905ae40a3b792b971dc46d5cd52fe7ea8573b28ffe143a85449ece0f1e02d65b8f20b0d1058998a8ee40f4fbfc93719c0a5e21a71e363e2da4efe86c4b98dada747edce04d1f231153a9f20a2fbb71ff6456b41c3280a8de7c29ff872be80ad21df9d0c6541c19f810b4cf9f3e9c5db791573396527dea10e6ac28078ae467b83383a9fe8927975b0db4aa715125f2101f5a772411c773bb3f5f874dad78fcd2da7c8d4f6f9e7b8b25941f4f2ed30b6d03caa43ef794726cdd17ad41f2dc79827a075093fa73905d44b9ef3a0d15081e79af163c166d1a2bff0e6dfe7bafee17dfcddd32beee7a493ef18c20bf9349bdd916d1b632e2937936250685888d322f14383df3696b252fdaad7aab1036e29a6fc26b54af1120424ff7d6a0cb2248f6ab0d5f99c3a52186fb33123135c4caf12a3f0bfa51367e8272288068f3307c03422de753daac148bcfffc08077a2af793df882f0af4161097e83f4c763c9c5970b2e715d4b748b70e70b33260b0d9d53a264677df7ba473a0e2c59a9c002b6cc60f4a8f91e55b7479394420d906a7fb4d1956d37b43ef4207c434e70e88a40f546124f9f8bb963ca3f41602c2484ea291520f6264825fdf46291bfe68e11325b808fc3ea3466706bd33b0dffbc7ae0013ca77dd9cd429d7394456b1e229a5616061190e1141ea06972d7e601c777ea2627f6b2526c416a9e3ba129a1a30e9b7b979b24b97a760620d2a1893b9e4a866a5019861df58096c6a2c0006b8ac935ba78c5dc63487ad4781a469406009f1c38ecc3578f5dc430aabe8e45b56ba67fb1d917d8074d38a221e9fef81dfe5bf814510efc83ae185b344286f0e7bbc51687179fe8d8090bdb0ff242b7c3dcc2915f6aad494347b91f59ccab906895917f66afe372fbfedb5af1b4b3ea6f51f2f6935b52ed16eb0d946608a244d5c68a7cc1a400cda881cf6c99698f6d6e1ecf87f44f8dbb105f56233d40dab0421117dd2bd6d8efd155e10c2a78f36f7015914ca9d74cef111034b7137bcfb9b56850ccaa029032b73690bafe5a6a3058cfb1bc105dd809f8d62dbdb9d88ec523eb409b9e43dd671fcffcc2f1b16f90f5df6ba3263ddcac62c793679ec038d87b7c4fc3900d072048b0bf679e32a142d72a3442b1f2319a5ecd87760e6c22e20726c7da0b51b8efeb611ffca6a434ab1c9b4dd968adebbf9a831e87c935f9cb7fde30542c36b70f834dd17c2fcb46259a5f5bc754757e0702b8d0fc26cd019c93cb22a587ebb69137ecc01efceb086f4f633187dc24890abc3aa76e3d03df7b53c0fb7462bfe39b78b1a88e8a644a79b4600ec95447135e191ac39dda7be49ddc42c0ca920537b89e4ad1865238d3889153ee1392212f1b310374939ea96e5a16dd8fb47ddde5a1e0c68981b71a56f1a9ed3b8767c86345015bdb1ecf9641cc9ac757de099bb25c8e403e07e971383b5b3ce24ef33bd5895b854dec172cdc328b779bd97dc700adf1dee8f0ce0cf5b6ac3e04140f26975e14862f1f1ed721dcb95ee429725133aa6ea46d280f8fb297996bd9335ce899f689678fe8cb9018f484601291e597fc6543c27f0152485a0418c209caae0265ee4e244201bf380f086b2d9f12269fca68e969434966ba47bc5693c20e9a7e293fbcc2cc7d456ab227e3c868e07e077887222f753cd8e454c13bd3aee48d49bb220f976b65d0845a5c0a3c424ef6abcc3c42163d9d005d2130076521ff98563f31364e25c16ce033d2b7b557151bff253b855fb290e616f74a47f415ae9e58f5b4ea53de65cac608440aae39e3da02d236143434a600b26d07f8aae47472158e0e597eb21d2d37fc0183d98e9066fd389bad9ef4c179e939a7923c0cbe6cb3108e64f0dd6f98eff0d621b5cc47ee21ca73129c41a69af38976cff4ffd38e375804a4d66fbde6722ef2444aa2eb0dcc78ac40a5b78618a972ce101664d308795982f1d1186c42bb3006500d3e22829d896e11b73c517846cd30959a9f2ca9427c64a20a9482628aa3ec559917c1ec488ac0525c24e95b49bc6e3d4983bb31279a992a4c3fc6bc04cc2f543e2b0d1c3805d7a84c1c8e0dbcc0767cdcee5cbdbe0abdf0d98e3676277d8f1404679c4e64b22e68ec18975374dbbe13d954c1d8315b72e419c63f00a8875bdc2c8066dff63099a1a84ba30df09c200624cd9e56acb0146cc38cd52a2a9e9d127f60493f0b18aac60296891d31848810d8ee18f050356d11795d8a890c4e4551f7544ed2802a4b1e382323622dec831278272be44ffbb9af85e0e860ef2166781bd2e6ee408fdd4125b8cfd9c5056fe984b6f8f8f04af50605f5497c5b9371d7149a302957962ec783dda269263b5878dc1fb6e7963cd5a2fda1458de71b27f724c77e29f11b191d77c2d8984e7b3034c6f183ad6b0a93ee4567a42f20920d77ba06a5d4cd0476d1ae9acf3013885713c2aec79a16f0dd24d4e2b6724ec48c2f62d23752c11fe47b64aabfdc7feec836be5cb979f7269faa253d7a4c5cf30095bfce10de76289e24ec6a064597d53f6fdf0b10d7b04f27cefae573f7b5e115d774d5b78093e856efdca80b55c50f4e69a4c2863abe242e2da37c9861330cadca0ea5a7afd7b11bb9f6e8f6b48bd30c7154db13ae0b24585ab703e6d09c70d5c3135388c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
