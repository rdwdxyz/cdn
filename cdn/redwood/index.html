<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3dd33674540ca11fc3d27828c5104308dddb993f15127e4a85f4eb60f4300918f6f20d89f95887663ba3ecd9edb315d58962b924539b8cdb66deb6c9d720b6de3f69fb66f37232508b196a040e35fd90098c6e9b7211c35b2dcad414e039e3fd3e25496eb21ab8ca41a6264e33c363913c07e22d942595088fc5ee620aae83e5dd67c81619ae9d64b7cf110f913b4eecdc48b80fff7e06bcbe8d9cc2b7e75fb452a12d211abca1bf100a74208f8f13445046f3b5a90e64a671cf419971681d6f6f738f01d0f11de5cd2e65a0b9ea306c532c9cb898a2d59506c3bbb98835800837acc86cf0bbf72e64db8d7cb6a68dfbeee9db22bafe63a579afff329a2f33bf947327ec249c94cc8d947b2afb82b70cb78c0bf86fa46349a0c20c6a63259a6290671005524b160ca7c1c89bd861b08d7daed82f1bed486b8ec79248a85ace48c0f50060fc51221d90326c3a78382eeef77defe4395942b29e23c180b006fa7b41ae6bff22b159b37b80d71f6244c524df4bdc21c3075af46b3ea2fa2f84948e505646ab04783b0f8bcd28ac32668f9c255f934bc9ad4ec942a652f69b49d8f64e56e160940f06bef9bd1c7be75da3f60ae92cc02d28a2b878b16690b677f418f6647285c44e2822c3d06378017f3d619b0605b31ece34d10df320d087e2491ee5785c76fdea27ba42e5283ddd91ae6d5dd57e51ae170740a28b61323fcf480d5572e38c742c7e121a4366740bc46bb8635d98ec7ac8e72d993fd622b911ed374c5849cf1f860237858d4608a6784321f38c2b5932dd9c15087af8da3147ffb632d0929d51281f728c999a18cbcfde7977fc33ba0c74a92807f6220f68e9ab6edcad54557ed49fa502149fb9c708365747956ae9e6f7161c9ddaaef52187d05082751db288f77f76da304dc8336541100e70863e8b8f0601684c7ce0d5569d9b83c37f60259d071046d6092d171d60b2635e2ae2ae3e27334caf1930b6ca9bc55e625918924f931de80902e0dc7d501fcb710f33e90de5be875c86f7cf23d300734520400b3ec4d32fc5265f678a89548abb6896fc3da2edc4e1d02955e8ff97d89f1fc9e34392b7e6adef124654d2fd361bb012597085bc9985cc0ef98b4f1258dd975149391c55b1342abce8c839052c7ec85b0b05face62f5f4aeadd679bdff100044e6398211b45ea33ac7545533be3845113134d6ff43a8a69ee8d68c1097f2425b8bec9bfe049332dc08b6ee51286f7257f436ebf4e572c25c496cc725a472f0e63cf606c682f4116babdfe6f3b774167e3364360c58eead7dc2bea51617a3b2019991641ace5f52e33499acfd3b0cf222e505de78c89e5134341a000b985c440d021c650374a900baaeb2124f49035000a335c5d54f1bef5f0b51b26bf35a2182ea9bceab2412ae650286697c9ec9fde85552639d4599dac5796bed8320769cce5d75feeb0f6ea369eb266ef9fc7200450285bb9c42b60d7a6101651bda8b02a3f215f549632d598fce886a0332b12a4bbbd00afd212794531b4d8b233d48a5bb507f666653467e06c1d052e8b7e0eb52a894d46f4b853d12820f72c5e27d5784d28332de8189b44339d5056e0ba2308c17470bcb29674f1dc1f09848e0e3cf237bf87744a233fff3e41d3f3dd621b7c70b6b8bd6b3a42341e4a2d8ec562ca28b3149c9c18439655aebfc946ecb0b2fe3521d0419dff38ce44711e75b81cdfcde6dfecfcf8c75114f9ee7e7b14c1603bbcb2f95d8912ec781f3b5d6c5fb4b3680402dd5b7f9eb2d55f96ea061388486ac9995e461fa84c865d989d7552e832b096f1f00607ca9bb7db92ec5788376611cd62b4eccafd02e442e02d622e1ceee717a94a9a54e3da60faa888d4af73acc99a2d9a021c3c0c942db7aae80c1e6d7dcd35cbb5632e15f1f1a126295707b2539afeaa7f68fccd3945e5a5885ac8a2834e2f683c45fc6ab4e21a9fb612263007f0e0aedeb877d75bb0132c9df8b4564d2633551e4d297c3a3554e6348244936c7641774e140f8d80739d1c1ea0e92542e9c2f0a6eb7383f7e28c7b785aeec0e641389bf1af74603e8cd3b07b5c8d89ee4f9ec52c6bf4e70d0782ab4ada9e807d6267e8ef64cd92ae21995c8e0693e0448828eac0147aa5b029e9d3ad960e011e595483b2e30215e8effc9d590e8f98673b4781ce5496262ca49cfa07b1f2f3af88b4fcd9deeb88eeaa012b670d7685032ebd380b53a165b056e49abc6f1967e94e061082295af95bcf8061ff402260618a3b3da38b960d62e4e4cad7653ab1763c6c3f9104f2cd8b6ce9a3071c00d557c6163480eb37453140e2ac96914b9f5feec04fdb989a49dd41304b570e3abd601b5d14781ded1752cbe0e1c6b19ec29ae408425437b118bde5c8cea87cbcc0f0b18c4aea2a9874f1d8df021e476d8ac6f22ffb231682a1749ab6f793f2628ba7a37615c112e13743f3066e916464157c85647b3c8b3e385fa53ba52e17e82c716578180070e7f0c18422a50860db9b7dfe1efc37702d148e2cf6e8c55473041613ccb6afca33ca193ef7ab6362e718782494c5ca3ba43aef204d13b63835be7f9cb71879b05b2ba724163871b1c0fd75ee430ab3c7d1e0f6009c497301789260fb2cc3b9467c0cc175009d642184244567949d536ca586d33dff549eee447295f47e0c0388bcfe2e2a24381518a02f2ad294c4c57e0ced6ed4697da641ae704f07f19d8dc9bac066697bbfba006be50460b2d479316a3b9e4e05de71a7b31409f90f1704cc65fcbadfd9c3b91554782e5a54e85012ffe42d3a02b5dc424510e1c2dfc811133afeec712b5721799b41fbedc756be4f8c701a4871c2f6b2d8a1863725fef986b8533acc016b2a7fb7962f469c4a6f7e2f07e459fc3a7e86064b0867700d69e3449394052de5566a0575ff745547af63afbc0b9bb21b82152af8bab2f4b5832aa5830ab6dc41c6afeb6dd29533e55f234a4093aa07567b6ac2565a048bb26dc95699d9eed173c61d6c77cd9b2064c517f30bd8e18f6adb7ad67b5d2ac25ace5455dd4a08327755ca3c903d23a9f0ddb8ff1e399f141b301771a03aabb5ec9f35a28a569a611db0e3620fad391b71c782a75c17a29ba603695c327d2f96cd71c0660925263bcfc3d2f4851cc8a6a8f435ade1e2a1022032befd0af20bbe3c1a3c29e43c0d5c3a60aabefdf6b145cd8a91605708dcb34aabd876319b43fab0ed7baf3081ec727ea8376078cc22136fd175ce0180ad462865f4623a59cbeec52fa613beceb147a964a3070c5c8f8f744614f71aa1cb63fc2a667fc0e55912c14bc22c9da3035d6bf3bd95bd24463d8a837fce69fa5ada290d5f835f3ab98f1ff1a7d55bffe3d74eeb8f88312276a67635d9f05a982e5a52dec3fab28add2b283a570c374a900d7c0877f8a0c056fb599827e84b744da94312c9538d7ff609b0939fb492f666d1905a643ca4811087c263b74e71459d9d0df96023059119be19700ccc7dd66af03db711131c75535cb76424f343cc194986869c7dba8923a96cbebc879212e947d32dbf86ba7be83b8e6c8c76c4703c301c5b2b1da7c9f5548cc2921248dfe62a160427b6b3fc5861297a974fb3a548f1f051067952304e67db04716b1c845cec7a877bc5562d6bfb57a8d9db66799124575c0770787e4f2a46b13564cbf1ef498bcfe1b8e369ef663488d771325f42ffe5115fe42c2616e413fe2bbbb814acf9ab20f7afd0e91b84695055d6690037d6ca4311e0d92533acb21aab1e792edef176fd1a8d6895d0780ba0ef6b86e60737b6417f3d1bb77d16245a844163c99cf824c539377be3f6b267b62bbf5429e690002baa1aeb4b1d2c2dd7be03ace14662fc87668b6ba7ab77a506460c5c205fa0df7165e23e2f3c59b75bd8645a49af51c605539d9d964041de1da75bb24a5cd894a1e62a1cc9a74f86b950c4b6efdfdd69f67e8f70578a2d1fb8bc360b5505b191daa9aa0b6c8d46f0cee13b141eb270886fb8dbbb89efc94ebc2ed9d8db478f874a1fe56b37e0ebd94125dafe85bf00cf393c89a8e0abdf362877b6f01ce7fe09088d0ba68acde17231d78d534277c40d96fb91f5ae9cfd754cc00378fdcbb923a78636fd8cee37e8df7ee4edeb1a77c8ab48f39f489fd80e2f124ca85376cd1d3b9fad7188cb01d3690d306432e5f85311c1e307ff17e0f97cdd26ecfcc54ccd22dfd93d29f3a253a395b76621adee40d494d0d9511ce62d1d1a21c7188c952217b0aa93caa5f2c6446cbaec2bab3d2f3187e84a2239f6c4aa3279c7be724d4e1a2c41286f5226ccdea3ee66953ff50eae8e04070af6bf5613bd6faa615b8c4958be48a604c531d7b19846ccf2d5dc32cc9c5823a529445b1490978bcb74db5b1c1afc64205d511838f7a99723ad5370709b929b9be14867ca8adf3fefcd3071f86891e1f03967f7cc1d0331931a4b44644439f79a1c56951b5d3182ee67c9ca61a4c1ca21bc7d6a86e31e94b5ffc062a5f2d0ebfe63ef2c26c9529f9b1d762573a1ff4e84a5a1ba58fd786c8b258b316bd6f43e5b64829ed92d282d4a4174a87150703e8b212f6d2e6b5828fd17affaf783c45d43f7eab99f1edca33acdc0629d7a812c0aef73386ebcf37aba7ce5fc07cbf76912321d5627016a84b9dce30d0f9e57fc489c3bfc2ee2b87b88bd69b17e8bbfaccd9cc392a594ba95308b9fe3ce5ec8137fad72a9acc7989ff9206c286845c2dfecef1bd07c15f1bf1dafcbe99588fe07cf88503f8a785975490ac644d0867708a21153aaa599220267d95dabf832e2644b4a3bd857c95b5e33242c2789efc50d687d080e9642b6de6f957ed9455bfab67846becce513b7735e5d1edf18c5656ed83548d5a34d3885ed0033f48d91cb17f0018c314340d7619ccbdadf32aee7bdfb45f1d6dd2fdd7f494d1d586c7c7462d605fa559ed31178b3957ddaa62ed491828f5fcb5e59b1ba435acd200fdddf9cd738ec3e4746b615a9977d792de00c040de8c9d975b328f8bc729902b95df9113f0608f2e8c5fb5c1ab7948a2eeb3b5ecb8f152c71ccb853dfdf2a31967302e72fa31fcb9882086f4ad9169c2e545c7a5c6d92d971efed0e598a7fe9c4c992af236cd27572eeb0bc2135c5adf800ff888c1d71c3a4b4796c56df85d290ed09688da15a9ccf3b4203b22b9150bbf9525562291d7ea9f986b0e45d977f8510671d0c4787000f5fd72ef20439130e058cfa060a866fb1a52c00daab7ac53c6e7f0e6d02e59c4581dfa890307f1fa8a752fb2c09e2df1695d36c7e54876739fdab41b2ab4b413017404c516c898160df264e96b62a3d1d9a26565d69296dc575745f562a9180122f68e64d0cd653d1e5704065da92845b00f8bc9aa12a55cbfe1e18705ec60873604ac9b5d2be82eea5e892a7d1cba1b7032f9f24bfe6418e4faab873e600b11e4862282d656c271b512b4cdec5794f7c49c089890cc46138e1e8fead67eec8ecc6b81755b7f08ca532f0889f028a3d23207ff2f8c77725e9218d1d071f978b41d7fc8e0f8e5861bae16b9d2aafdb265e6763c3f5c47fee5ce36f7a7c8dca8419395ba652714205e0a9d39ee0310b26c2ea6ee3592db1079d98edff802ccb43afadaf96c2e3b24eb8918ca3f97f144b7c38e6c7b60bc6b6fc7ec0e25b9f1980786d2219a150566079ca7da66251bd81b171fe1e812a424d6de844e3331ca82133adc05f2d09c5a8c1823a06bd8d5ad6b45a61514ad388352f8066677b63004d553c18f0029218f4bbb3f93ac979bdbb9839571da2191d115b625d2038d789a4cada805b77be84430b30521a386cbe8ee3abb20c02b2d08edd230589965f6fdbac92d4961abe7720952bef51a2ffb03d178f5d5f2991bac07c01b24491ce3eb92004949fd844edf9a03b91d4d4b52c2ec547adfdc706a6c562075154dd56e01683a34ce3dbc799ae6a12afbceb403ceba8ab066c8ff457eebfc2612061a34f45aace47fc2fde8ba98784653d4d32ccaf83259c2c1bc908f0447a52365e8bd562464bc4963a4c6918981229e48979c81286eb0fc7ab37e8a0293209b50e652d6154268408c48abda50d908d99013e173d18774b64d0042d6b59dc30fab42ea698a76ab6d77204c67997a972a88c7cb565792ae19e66fe6574c58fd50a0f15857fbebafea723de8fe9879a96cfee18d2f8edbac15faa1ba73d5a3217ee71a1c0e55d21f2403c3d6ada310181ca9ca2b0c06d4cf81116c658d2366a4fbda6175feae1cc9bbcc11b7973229f34f334b99b9a454ceb29483ef311654c624b351721412e667fa5c3028b41bef9980aaea5efc1d0fe57854692d14461199dd098c8766f7eebe1a17334a978df7f124848578f049a38aa98c8fd440202e7ac1895c23fc879ca20062ec186477a31c0b61055110672340c85e46d6a33f518e656bdbb1e7c457d7f1ffe47087e5b813baf1be0be7d9e3d5e2b3fa5660d741c1b9c43780502dcfb94922df3cf8c29e94d1db329e5275ab8b29d5e96f182ed6c85c47cacedad70e82e90bd6c58abd0f6b6861273ef28ddb89767ee49dd1d9b4d6fd1062e2b22f224cb857fbc065d18149f0507d06e52612f18e22a516101451b709f0ba0b776a636cefa942d6bb92acb48e71392caed48edf49b268dd1b15e0df89c2bf55c1372c0ca16347834ab61d7291ae83424c5f4338a92ea1cb17a18498fccf18062e86cf36c6027a6dc8098a3aa37801686c0f06c0dfb15ccf2ae93850d3ac64cdaadf673175c5858a534f90406a7b9f6e8ef1d05e9c8dd56cc6c1b2feeb68b2a2cced6133c496cdc3dae3e979cbe7b5ca0de86b3a13a3f72f9d639a29691e2800c44a97bfadda78699a665193473c2edb1d4cb8f8ae75f2570e638807f1d783f00b01534d813cf1cfd297fbfa079e49371a47787a047eac34f113fb11737a5a4bd226d97248f2717007faecb8245151983cecde5d2365e461f561c0d74329db283ab75ab5bb89095cdd3218dbe3b0c2d875b7248e8d79fa307ef7681ceff0847aa906ba06dcae2000bef2160960ea89a5f10f3769b03a61799768aed733ac5cfd7a233da798de65b3b27e5c63fda5b3e9b2e3c69d847aa2fd700357c3a5cd0b73dfc759ec8204ab4858d74c3688c8dde1e2a677a24a9c00577bd0ed8144d6075ee6ea5621d0e748d8c7a82761889d2e87ecad3bdc6c61ce6689c7823b192ed8ad12ede9c9c7ec041047f38f89c72e994175463948808428682dc59bf6f6dd2c3c9ce409082ee6a03b17dcc09f10f29aa171dd36c7457e7ab2a5933a4b20bed5cf5019883bcdd4684bc9efdb0b0963f6ad94edf0c5bec158f893f94927dfa4ed3732f62074f8dc8d154b979839306cd388bf4b6fab066b083dbe94b74dfca38c8767721ba90a6493df3bea41dc5f8030ccc343c3cfd80f69bc76ecdc792c770e917e4300837025acd39eb8368e89f504bb0176f93d8c28feb134ded375a7cbdab22276e400458ef0d2100afa82743c80ae1d0efc38834db089537e224bd1182bc95fbf335c4bf4ec8ba894bf926bffd0d34f1463c61da8a52dac5a77ca1b326da26ad4ffc9d435857c5edf2df28e9c3a1b1b09c5b1c87425186601731186b379fe5316ce991987608f4353cdf1c0be98fd900ecc545105f5b6bffb55f4aa5bb52186dcc449f160984bced8e80aa6d48cfa142aef5dcf8a4f23e43617cc3c14815452ce32b0cc7bd624414129971793bd4f8b21730ac03228e8a37de2bf30243d83627096c7bf1dc207d4c7d2f69384e813b449b571de6acadbb0f5e1ef7fafe505a4a4d53ac32f278a2f43f1fa8d011916bd8f8b6623207cf7d58b9b511d70ae0f5b92f2a38784d4a50af40fbd0281148afb2bd6e30b4f8d6a609c1d367d92a0d04247cea73ca0589f91a67420e800c27c97f204474ae29f31aae2cd6604fae0903be759af8b833a02ff628f9f7298a1530ef4a930589484fdefe153b36c2b1449f0df6bcfa20d84b313cca22618ef6d6af9fd77a9b859f6c54cee8433e3ed529a32ac432e3915528ec5f6c7dcfadaa24f4f82a3177a64faa57d4ed0ce92a66c9096bad458a01a31121ac8247e1ec15ee5b0334f500a57252e5e707c6a1d836c294c7b5253eaf12ebfb57d3502ba7991ae586681e709c9282b2d23b45a0f09c252e699abd67962adb8f6e3487deece3422002d527311a2586e0ccbd0efdfb93ce765cd0bb1e89bbf39243ed314c14c3340bd1b3b86d993474d67091b744dffd5eece8381c7fc9216b981076b5868e38d17cb97abf54fb616548617eca7ae0a91745342483176afb49a0fa34d59a9c4744a5bf0d808cb0ef131d36a48f340af0f4c5b46ed11df3c6b5fad25ea20a2a069ca54017e82941a585befc82adc198821923802d93ef4484f6d62efe9b683e05c92941f7e2a21fd011d21119504e145787c34dc4bb306707f2a0838ef5d773f467d033ec0827c172517fb46bc114e10d7e6c601c4e24402446bef25787373a5fbe2872d6beb97880d311b175473161de4686a5c7042675c575e3ea8333a244eb52f26acbc5233dfcf81855761c2052b8c2e322d27ea718e4b0908736b6fb02ba9c88b4bb8fca98faec7884c9b444ba016cdd3d7168e36f6648c8b859d229ea0e2004cce6572ceace2ebc9614ae2b9fc602fbda1218eb662e0aad65a876b741e3671e3adf7772b1471d0653bf1eca7a2267e848803a34f9f743114bfa7a5676539fd6b3db2e46879c062dc0725a2497d13b3ddf89ba484d0717d8a91aa63ab8eb922d7fcbc6aef2230d641659946b882617ec3ba9f4f0fffad0902fa4f4db2c84f6c1b1e3550885dbc7f56fdcc92492b25bbd039fa42331c0e80a337dad4aee02794637df90d584cca7a944bf813a09d5470e04d760ad132a425f2e5ecdc39971e35d3a65502f755c04d8b968d3aef6668d8861a31db0bc933b4d69fe59b8f906b059b873a32a836e8c757e4890c55fc6fabc92d7ce9a509f7c21805db45a693cf8cf6a6c54534fe893bded9c81f0f8b1be7a786482439e2123d08fda8ccac56ef0fc40296ecebfd346a9f43f10e4ccd72bfaaaa212195fbcda7a06d15c203ccdaed79b6d961777f1b325f36240ca465fefdda5b4aa6aed5f95e2a72f58f88ac0c8ad47d2a6e4828c0eaa3119efe9534a45c40e3a486841cbfd7bf9860e13bbca276d8be16366c8d5bb3c997cdcc72e2285affd2839651fee3baa3b74edfaa1a9cf1eaa63c610d2cb979b0fb60dff632fb3998d7674ace98eedb16278dff7a878c4002ffe83d3432cc2ebe4231f2f88f1a65253243ebf4f27fcd149bd4fa2f1f8e3869aa86f57fbad31ff9dc14bfeb384d135c9b51e9311e4ffa5b5c020f0d144a34a0d2c799340366305677b4d02bedb84a7cdd8fd80b19385cc8968bd01deb0f1897d3b2fbe06146424b69dad424b61fb9fcbf581b5641c0578a0215fa88c808d2e8f08a2cc6b8e96f898cb60bf0b038bf96215d577782fd1c05931b9a576364f214f847a81537ce5c6080c7f690f4a221ea47e9d92d0d5b0b1c4c559b7a1ec9896c3dabd0c285f817c363c2d18e530fba098a249783a365405720c9d49fd6d0b729ed7456cf197f8c6b0cb17b929e62a4043c4ba1b94b1c3b626753b68de4c41cb6855fafd7e0622402e8f86156fa9998af9abd8e9a6d2af9407c64ca620137458150044993282239bea73eb72e782ea6b8e61b73379e7ec1b5fc0f0d5a6b303bb907dbe745bfe32a2e2a0a0d9546bdbb72f2e581ea5718407672cb7ff7fec041f3fefa97fffba23854cfc7a401cc13a846d3cf99fc5784154c03f2853bec87ae397d9dc1ee6eff6bba2f4812c0c244fa95930fb3373ce4e79d8bacc2c1e4bc58a94c27264095a853c2d7b3b6b4605f66d94bf0237d68ebad4646573f75dd20709395d0545f3530dac7d86a509e56f123230c0274137911a58b135c793989386fa58c5a32238683ce43f205f4b0da73c58bc71fb90d20f8ba61919449e1b2acf45c94c136c4df550f4d220b23f947ee8dd88f1c417adb2c30f27ff33c3693ee83f57ca0389f05ed9a8a76e910efb17d6f312a7ff26cc92874c805da5dde415135a1bc5b24c7b290754ba193a8a7dcc6bde90fc671fe8e7d176aae95e3fc1fa859403ee14eb7d952b51e198b419b8731bd1b810a515d8d73357093ceefbbe926044c73c4859bd265a824af74f7cd8e18468b15f79d678f215870a978077fa698d391e65c2c95bedbc9e88adddcf4ad3209a1169fc446ce8a9a6c018b0a3f0fdeee6ca7e36f36f86cd8333f6ba3db5d45655a2df9f1627f215cfb9ed49dee803898c86201720ced349b0f1b98ddb5b11f1b21f5c83d6d23e5aa75de0201417360e7dae32da9eb2b2e121c538468691fa2f9113de08295fa9b9e341294096668345565af74e0b66b2f4fc13877f6d69d67bc840d593251af62c9f172f3856586d03dcafa8288a2894e9bdaf1a4bb02d791400e38e010b4bb5326b651075502facb32564ca63cc4455359e6cfe689432446ea0038b1615005de090a03c17ecee2c286b4eeaa5471a3c02486d24c1f3c5837349d4a868d6c63bfa67b7e0f58c0f307f508088bc5502ccb51891a5a5d9b32d45b58988c5f9334b4b6d336caff85c3a7331f807f35fd409d52a7d7ace0c7ea935460c3003a48480d9f5245be0b9d7d118518bdf2761beb3c0b1f0fbc5a1fc5b4bd39fbe9ffb185a9a0ca6e2b9848ef76a9c6ee39900ee9f349336c3a504c545446092d836042eb01298c8f0d1e7c10165b9201560f1c373778c470bd36d60968225b9db2b1e170879c9e8f98ea654a0128ad8633dd6795dabfd716a4fa66e7f7e45da026ed7cf88dd15be0f498b6529624f90bc968a3259938b097028e7bb00be02f84db7c035dbed4557c44e52b14f6c7542d652e5ef422b7e73a97e0deebf7077b1dd7678dc3b0b7cc6a9d51caf0f002203b41f865e13b07572427a16dff2fbb986fbca9b11fb505f23f2dc852cddcb951550e9f2f41475a96ca651902704b22ab10804a5ac6ada73b0562f30b7cb8df2f712bb71a193dd11d09581b94e14817f467e73f4c39d7bc0fccc105e8b6e0944b5fba69fc08700e24980b00bf73e820ffe1710d887c719dfb6174c0ae4c6f42ce7fb4a17fe4a22b20c9762db04da26c3241dcdc652daf05533ef9d8f7a6d8356111eee94d7fd4b8ec5697eaf31912ab1061ba7cb72daab4df7c03376ee861fb446d67627e3d3c72aae8f9b0eda37d775839a159b4ccd5d43c14fa2e5555114b831cf12a3f0378e9205f221a4f11ae409428e192106fb90031b14aeb67108415e37ee2290b13722f4f5e3d6bf8dcbbdb271f3e8b99387649c8f74dc5006d2928178040ed5e04da0983eaa40b36b6ad71c37966bcf752645d06e6af6faeb565688954b48bb9a3a841f4dda17790ec3d92a0ca16da93b7f385cead1da0fedbb14bc864efef1fd5ef1682df6d50939828e13f333da6f84f17cdab16f23578884f212260bc04ab47b0ec3e112e4d0555f0a0d9f424ac2f43594463298bcc0d4d0467bae9e54322f78e8181551ad21e8fe5ebd01b51ceeb8eece30231a01ca2fb0358280700d0f1b8df1c62a37bbdd603a7578938bb030f14b3d57981d586530ac6f12b0356e720746a200aa8cbba7ee87ecb452e77704d485c4c2bc097fccbab632d7a898bd690239fa22e51bda667337d4356c7aa0cff2abe0a63f5226483670e972bdb72d39c6401eb14306dd02425cf0f222ec52626ef9981f994288a52dd6a539553cdde7ebc3d90ef0ded88e32d6eb6803bf42547bb31cff42287092abc6ea43f26bdc5ed3b93c033fe3deb05f40653e065d7177ca5b1f5473ffd00cab40a52edf74ca598cde2e1ea4710183f8a00c421e5e191cb1d92ebe0566625e72705c4a3b1a777c46d6775a373f7a019bff28358b506ce8c6ff16e295beb616e9f575d3fd0b299b1dfe729067e731fc93cd515d330775e4f6d977f2dd5721a4cb1b060cebaa2be2f387624fbffe9f0e76229a791c77bfee3c2a3fb82fddba5d3d48ad4c0aec91e091939894a42f38e09e13ad9522c51998583b36782e1f5aa15556966b8835281cd5814961c734d863dd5b1160f5626d5534ac6f94aed4c5b45cf9fb4fdec5706dccba75102a1ef02ba56eba9108bde38731c0bdf9911fbedff21923c5cb000f6e2d4ea1c0f4b30514ee73641ad9c142e1ccb595d11b7a8f8edb84a75230776957e712bad73fa8bacbc4bb7ff9f5bf67b86d0f5f025d2f3c5f67cab8576e23a23c081a736ac987d69d5ee953244f0a517202666fa5e46334a4de8d7930140c5b877006c888d3b8005ea9801fe54496ed621be270bcbb16da2bde559366e5676c86e08230df3cac1dc755f29904715691c2c5b301d938b0f6ba165441c1f84aa6c124b354953f795b837b809d99918cadd2c30da60245ac9bb5fa7f772a14dd6ede0c38249b796dd2358523049711ae145649aa19b333f7745a3560af502a2a9385efefab22f111080cb5e13174ea779ee4142d6f655c1a2444d95f94b8b0c2cd805ee64ff2c59fd2868762b5dc425d25026f929dc3ed7c0c36b946fea33143409559b65e9696053e89f32ed1dc20d549ec7aa097ad93dc847e7e22973844cd116940eeab7ed62f894baf0d430361f7267ad0add5d5fff033bf5aae7803a9aa4c6e08487d23fa46aae40a142869c18043c2a4590942d4530393032829a9b41bfb6858c30bc843e2ae65b225016e5309082caa5646a168437d3ca2030355dee37cf2296319419841248ba74aeff1fc273cc7d143d62f21f6d296630380a73f03cad92b53a917697c5c6c3d24ccedb8ba83038c7ad1aad068a0733546874ff84f6ec98189e170809dd838ef196028ccaeee39586143a0f750e187247389b2e2535cecc4de7a537bbc4b718cd432b469dab3bf7a71f36d45c19413e1b34b9d653cf95e4574105ef40dc8f831bbe5878719ec7e4ea5306b27e3cf47643e710059b7d6e6d124e9fa7e0efa16d498a68b2aa7dd9e1e975e009d9dd6e140b1f44097f76da47058e7d7bc092392770e25ff843f00430c8f44eda8d19545afdffe9cd77acff4f9e113951e111b47ccc0dfc484d8c480dc3ab788e29b7a3267e39f69a5b8d7bf37b568971c48299dc8af489f8131f54d0a68d2f1d79e01d6e96b48ce1455a04552c3da183a899170b80dbd9292bb09fb90731d4338458edcc1dfddc083ecb931214ad8a75bc831631fb10335969852af1911a0fba437dbd936c8477246ed43794226006b7941c7670315506e24cab7c18de56ffe99a4d49980db62e663f3a1f0b26df9d5d7d83489f78c30b9561597d103024b65f5a06e28a6ae755d4d37cd625da157cf5e9150c85d3d4806c5e1b80530fe772957c561cb280d7e68c4e19d8f1e07ca6da3f7b65a910a3939bb8d8de4f4c76763bdbe7a54eaebfb0e9f3536f86890cc3770079e8f6ddc1729b0daa6ffa676906ab53e9ba553e9436118f911f79a115bf9223925b7949f6cf0fd89692de34115e0458f0754d76feac354e2791f78e42f1a812197e78e36fcb136d64f5361ba27e401683bd8adcf6a07673642659406de70a81a69a5cf278196f4043323fa05853426b558979d88cc32b82ad335ccdfad084a87ca563b0371539b3fb3052ad230bc715ce604d4276fae19ff3098f22bd18bc1362b650b50dee98271041f6a95a54d0ed06e122f5aba907a7a19578b367fa8f5676a2fee596ea1c33267796a4e8267f041fe2a21d1f8d65bf7fcc0e912754abe88ac1c7aa6677e74c84d47281f4b385310e966106b870589d48a49c12e25017c40769edc3f9aaecc1d56493b0739561122199b6951e12cec1fb0b852eb289126ccc87e0ed1a40ee1451e5ee9da78092f43050e0cf0aa0f05730c7c3d05ff6ccea4c6dc1c093b76f590989b80fa1c8adce742228d56c034ce08296f5ccb145f843a4381e093e24882d96b74008b37e42a2580c4a0e87438565721ebc55efc242bcf15fc48acefc3b1c20dd2764681595d8c3c6f050b5b7b94aa6ed931aec32cd3597b0b377473e4c50ce6326a403982997f66c56434a929dd06c712fe62a5b647a66c45c06f969c193cbb31bae35119a387cb52bc587c7c5d35ffe2d9573b103dd9b9104f35089070369726782e71094cdadac06d2ed649dcae905833ff885971654a3e8e1af731f845c4048f572430235034b991754e92b5bd02d50d4e6f8806f7098017bd86b89eed2e47c09aca06941bfcaa3d6d9069d65ca6747eb26bd391fe30386e757731b581761c63710bf099a2979aa45d4eeaf51cf179ad65e2837ec87e887a78be73baab7b24c4af277504e5031fe1aedf2957d71d098b4f16983589cf581e217df682c8e2ce64fe19a71f3186806b5cb77b49ab8c593ae42631341fe1b163875baed14d01ed279bb32dae40b866e03c23cf18cb21527dd65a2f517668302d7f1aba546e15beda11446c1533c9288ecd113132ed64407d958324452ef702226438472a5866dbdd82219236305b8036156f01e1dd859dbc1e07654a77002a5d095f2ac433951252b8195632d7f4bbe50e73bcb4e7c8f8f22d97db0804f0dbbf1d3219ee8f7c396b3170a1e7c47ec059c2c2f26069f0ae1648e39aa1563fc96c4bb2d8e0ca28f06944e3e6a60d16f438f741b8bf45b51f60cfd696de0d2f087531458be6c1693f7cdde278a59b168d2e74a0d06b1064e152e861ee0764c846bab9169a329c7fc5c498a56315dac6bd711c3be68e23f9e9b7c2181c8c4a0404cef48a61723cb801b57d6556a7ee2125337c71fc8e652026347b6128ef018f63c668ee9e1e1d18898225e3219ab579822f6c150291951d2c3086869b36386f4ccab3bc41e95dda49aaf55d1bc092ff0f85125d60083f09da2d2848c31c110145241d6f68b6f2422609b271f964716e590db89af2e60781efb5d62621fd7e2f2f694e5a0840e0efad5d9387e3d3d658ed7f18d2a255a7e2101a500b7607b35dbd6e67cd1b936aac6ec52bbbaa2cca0886d804e74878cf3eb8d2c2158fa9b89e711d7516aa59ba04294851a554342d3de7cd1d9347ecde607c79b07c5b45c8bcda68b19ddd15744d8c5980dcab8c5abdeaf5eecf2154a1bbc79845f43fadf3abc33752d9ca2616e8d16d7dca4e7d209b55c39603ee2e33e7e89999ee9bf02dbf26ced906508ea2c6994b526922f40c4fe14293f557ad9dc935263e47dd5cd9aa34692c7e3627671f89dc6b806891340137b151d8f1793afcd77ea082cbe12a2a03b51380fdf0aa503842d80ec21cc61d9d5065982bfca5795fb2b2e1a7bf21d65ebcb5cde2e6272bf233bb989aceac8d328df95b10612aaa7cd6aaef7f90e1b6fbfa0a163a2f111efa23d58cc23dfba7f0c1189f285a373944ecdd33450716005df6b58bcf71a7edc0dd6a542da56d6a848d72584a2f7d01f95af204a15f9475f7dedf13d55066eb5d0b9624d0870870fcb35f31e7884b3800d8041b48888d75dedb308e2c74db4b6f64e83cace14bd9c9fdf16cc2392d02877b7ff54246c73338f97375228590d6ead58bf67e9b7fe1764bd0c8f663448a830c5d0d82c4b51eb3d67a373b73ba4fed8283daa65b9080155157a1a94e0632ef4b4675963ae6f2bfa4e79d79c62c4e40766ce04201cc5bad1425d120d97e7fbfed9cf39bcaef783945fe91187a58daa2d5596ddfca74530ff6eff6848065c3397dd406cb3c42eec93fd5279f985249000ab532d0eb1f9edc43596a205d7476010acc4055918101ce2f822cdaf27dc5c55dd310a4ceb1b8ebe19ba0b15e8175321109c92098e06689e0a6c99e0b33aad45292a4b88b0e74f08c13ef2b19d4fb10e72527cff874d377c5c23b19ef1c2b230aed09fcd49bfaf43caf75ab0f8f24d9a6cea6b0a9ff184d6383d219809e27dabb29212f19813015e95b6ec87a05d78afb755cdc95f37b05bf0457361675d3d76d8f30a255a783c965f413a7aff9e8a5ada71fbef636ccba6aa3af8a3bdc04028e26baee2b5e53191c8c45695b43b5b66471bed253ccb271bf7b89e6effe93fb616529c542d01bed2ce88f1d43a7a813cc078a027d9757e91caacee662b474e2b2e8abb216a7c90ddae494885c7e393890969d8107e7eec7d9b08b0bd1d93f0cf2645d113ede6311b11143f89a13285391d99d6524f8907d93804292a2d75ffee7f2e0a2bae0b6b0b7d37a9c0ab4b783e64da21408c088c933df3e88557ea598e2c6296f8dfd2ba78cf81d55eb87b049847677d31bc2d885d4ac56d5be7b1f177716c70858a8c62573066bdb1ec64e0a372cdaf3a2a4df71324dbb70cdabb11605803c6f7d45977e0152747a8a93c0d2c5b4017cb8e8ae348cf414be281727f71caf2c64589c203f9e5576aa931daaad81c3b66a298a5e0c042be3babd2980a317854fd0ca70794707ecb5d5de6883ef5ff33e2937ceaf70f3275f8b24d4cd58b65fe0a7934ab4b0e253322a82fa32b44166d5796b99cda5d7cb9b885d57772e3a34b1c967c67b0f3758203779901660a5b0ca60e68fbb8f6818a79ebfca8880cb3b578ea10907fead5bcdde8cb13e47d022585c078809cd82eb1cb01690814b5e4515f9979abdf0d8c7c4b3e2107eabe0b9700e000dab0daea346f74663a2fd4c23234ffe759e20343f04f187c80ff374f619e1419f6fef89ad0ec6dd06e26dfadb72f19ab5c93a3158ec19219b58485e6b42448ab5d51387f3cb7ed138c164763e15d2ca6294165b2370be80d7c1e9de5388d6b307cb00b2a109d2e643d4b10a06d478181cbd23dfaf2b715085949cb5003031c9fcb90229c0f77a55197c0e1843f77884e505e77931d2654bcba0a14a45866f782d749f90b45762aead672cf4ae6436a46b14015d645b40d6467d104c4ce7362182f5da8770745786b85239b380b52c172554c598b594b9fa8fd90cfaa917beeaab1c87d2d8847b61ac5dc04e4468de51319194e5c0499cbce9010023b69094a64d71bf219b182e88e28cb41b7f87495e2032190e270e62b61cbb3097f1263421417ece8423c1e378832e176f854cc0d946f1a00485168eb237da564d38d1d658e6d0b6475139f350f4b022053c4c8e0b5203837350f2fd5219560776c021281175ffe0302f9644e67cfdecf1f4c63327e3d570dee923b908a6b16f190a05f47c6dc6ae059c49a7132a174b047be768e70c2b9db84a6fd8e90c153f8313c8bb220e84e2a8f7dc962a7d76912496b4a7f3661b1420fb1028d56c038243ee9f29ebd0116c5b008b17a06348c3a3f4477c268012fa6bf436257f2cf4347673af1539b1ec7391092eb814616281d400096c18bcb891bb333701c2b90723f8a97c804fe122e517d838ffafbed0bd214021c9be49a949fcd98d5c1bd6c0c7b9e52cfd9b17709dcb52779e75dcb2271fd9b2fb5327f08c2968026182fdf0ae32a4eaf9ab50cafe940fb1d235dc8426d73457b0c2426e10d994b7f2fe689c613825520239f667a43d9d8021189557142b7ad97379013114bb1e4cfa82b8cc1e8a158709dfb755ebe1d3a97a8001b6aa8507e82ee6be4ec048fe0e40f612d035e9c70727ad00cd52e124aa9d7ade55dcb2aac548e9d683d325ad2b8d2b3a59aa80e3ed496a3ddb0bac939f421eaab37a364970874991062ff5f5bc77a3e04b3b0231e088ffe9783bb4a0bfe0299d1cbc534be0b50153689052431c2ce958bd391a0c2756638674ec9ac79272aa65a2d874196728b6cd6d238df85529c03cd2af5cd8ca64d8d19ce5e00129f3d76b690c0fb5bcc0dd1d248148aece1ae5ff00e5df9a4866948a0bb44b595358b3fad6d2ccb9e0f2c2375eeb9c259daed07dde0cf853951e28e63f6d71b0cfc41747c7a1f191759a7f2a9ada1f05fb646505d16a56b1cd697d4aca2a423b77a9127b96c68337cd827a746bfe073e89e1777ba5cf16c4809afe6644288e363d31c225b59f774d8a70a245894d1fc96cc4943295abefb8780ac770bd6d9ca35205806f71c7bd6666acc25929dd4543e091ca7d80060db4ebe23a071","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
