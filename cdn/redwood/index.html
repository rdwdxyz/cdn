<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e7a162c3dc4abc48e30bc98ec8116cbf34d42de73ec11154e4e9263247d3990fd5b7d32e3531b72171bf846cfc5c45f55c16a4ff22577a214b80dad374ba62c8e1f847fbec16e94ee6116ef15e6c211c91eb83da44a3be98c78a2080e09bae544b2678c42c81f87f2b496719edde03b857a8d8e086d37d1b9aea6e8aa51dca21dffb31fb5c41a1422b9e314a5b898f347873b39d3af6a5a9354e99baa184feba576f2747704172075bcf0f82c8b9cf0be009b4298b3ea570cfd41632d39a94866e27ee08a8e21d2705427a115d3aab8fb2e0140c49212f5f2a73588fdee4bcbaefd2f646873cc3040a1783231c667be4775cefcabd2460c64a3a80370509dafd5cb7e7f32872e5063fe7fd46b6a16fc34b82304e7f331a38a876711bec54a4e8e3bb683f8efaf66bf00e2797ab34479eba56151d6ecb9a854eb5c657b121ed5414ef607cb324117338e3ae997d86db58d0dc3bff6e327789526cd631767b7e5a872730432e0619473410c29ee608c17914c22ec507e7619f395290f8f8d347567e143af9043059b3a0d5287f8b6e7c394a430c2af110498422ec04fc2c6c92f011d96d50dd333836aa2cc735beafedd1e8c82f4d423d3adaed739530cfd904547a1cd2e1796d0e0eb7042b1216ee5c139dfd2dfc0d7c9b4af8cdff48aa2e74c2af22ac8e85323004a5f08653c1cf76f464ef25a52914596ae1a485664f1323b1e4934273741aa2ac9d63a33c71791f14ce56bcaee908ad003a0cd4376b6534bbc72424b2fbcf190b5a15dea1e9b96fc954c26af2310e9d06c628144fc3bdc3f5fb6be5acd726a9ca62c197e2431c80565db577363ce6fc09f2f82398bf5a3c0b1dd316c0e13cf1193cd335d4fd80ec3072b3bb53ee349a2b38dfacee8068172258ead69a93bb7381b826c7d40410ade8bb6d8bcd1f74a5ae38dd3b186bf8ec9deba25e328d7e974f67b4e6fccf3e0259bd84fb2e2c4ea00d71a7f19a20d51c8b30a9d0e64f755b308b1b38a8095476fce86747fc302be1ff0504d63e6eefe271188988caa0c0144bbd31fdcdfd0ef99bee021a9a492d614e96e1c44f5e2018cd0ab2aa75fccbd997f305a8fc11ca34609ba3882cba0b05610f840bce986c256edc1309e55d8b4dbea4f37aeffd957f78daab5ec490a05a7087a917ce207199fc51a1eacbe5a690866d3bbcfa5475fe9d96953f1c6d4f7e11d416ed0269f0f7c22200efef152b0512d4aeac1645680344c187264ed14fc8efaa5d40d1d76f2f30247049f72b6fb186f19c694eb2c2daeb83cf8683269096519a927e31e59047af989b4bb11d59fbf4e2f605c0e2f9039ba2ea53254ef49b704e5ce475f234876ea2d96ac17a05acd165d57b5d75af68d07e3aee6ddc92da83cb515d2e9aa91d43ddbbddc021fbaed0780e29692e34f098ee2951e51a0b9a666cb2c589c4199b5c9fe18044f7855c405047e163241e54a82fd170fdf936fa57f78f85eb66043f5783832a65fff3acc2276c5093b3bd23c4a1f6a4eff4aac4139d54f416509bdaa7005f968d8a8582cdd63180db59e3135b8b629670dc31cdb2c9e3f7a732c8897fc788bf76e38b7d3f8829499a1fb5f6b06eb51f78fefbbee6bf064369fb30a6fbfc813279d5855bc05bc9f0e680ce3a6a5490dd05b7aec6ebf8115bc89bf1a750e01b09105479efccac55f9627bc48b1b2d6a7e76f7e2b53ca27de6fa4b2e724a81777f38dbcfd7898021f5f9ae9ef0ce721a24354859d43ff6f618369bd19b0522525629d10def5fd53ecfc048c2a5d0e55de15c413ec555e931c4c42dd7c436eea2b3893c8e3841619a5e024373ec5d88240e9b0a8934871399cecf9f55bc3f4c3c8f558058fd15d279afc306d885aadcf1f4354bd9b0e44ecb781b81b0c5e001509ba5a3b4a715f2be219c97d95be724dea081c123710e1cac049c63091546957c7b3a1016e728dc2b4c84a50bfd09bb7a72c115c7bd3607451f41df7f0187c5689f1bb860fa865371b8cb876cc65f379bb1d601c85b23315de14e7cd742435dc1e95e948c0511be3d5b5af75ea9d670d729e514cec09009e95727d62299cf1649f2d0b8065d5c6efb54753d4e20ef7bb20bb4fe54fc2071183dc5c10b38749e583bf83c13496ab6ad8d7b700c1796de06be949e644b8408df928a105d019944aacc526b412dc0981302c92ed3d519f8600c73dbfe47abcf78fee81e3bf193072a3d3b7409ba2b22bb6b8018e65568ce55a505b7490d86d4995d2e16eab65e8920e9ef92dacf574aeaab36febb4aa8d2fdd0eb7a9face0565422c5d667d302e422d40a1e2ce216f1519c6c33a0e2aa5cb31ff49426d995bd5718f2c635a8c3c2fd905cc59f22eab4b45e7a514bbe0ed3366b94d4aa0136183821ad0006d5aa26559b56d895a1e790d6c217d6c693c34ad71b99e31ef96189615d5ba5425bff9673ebac3e84504fb4cd6e9e36d7b4a89201138be653bc2e8e7cd7942e50cb586e6dc58931d56c2762d6719e81ebd8e261be040fa66eb0330d2c935b109757e758499fa413ab0dcb727948d3b83cf37e62a904e84f311e7bbc3bca36d60743108fcc0502789e2e35bb1f4cee35cd17003a20ed1654cc09535e2ab35b419f53f5d05a210a4f95e5f2d229d16e709826e680e899b9f81a252e564695470431e968969a945934dcfdfd3777d697e7f0be824aa7cde4a9298e2a007921d0784316f4d330a26900cf0866df1b8f8d792774e100bffbc05eb5a4fa5a71a6b087f4cd4726caa12e7bdab170a6d01bab3a495154cca07b0bf3196a8c52ddbf6d4b508d4e0ccfbdb12b856b6614c6437d7ac012738652e6ca61a52307b60f1b6f7ee6a7e1ebf2ee3cded71a735c1db6ef3d21acb98efd1b95fde9819279d0b148c24c9a7e51edf3fcd05097d6a9e7e0f2a9ad67f4b2ef75a9cc117f033b5d5f27629e14bd451a074c36806f241e7774221e2d51c02ecb78248cdd0e951a96f44c445e5bd9486fbcd3d3d48329eb5a16b66b255fef694bc4fa9343bdb91cf6315605e09a3f8b4a06ebb51d34139716276cd3c8856b40fcd892b8c22271903a467fb2dd06153fcd57d68f656525af7d863dbf6ac001ca3793f42c8f8887f92e463a29e41411b54710cd8619c34c37bd3a31c74890f5c95c2e6672d23931aa59cd23c4726936798a7ecdf4d4d668429678b251853ff14acbcbd046cf0e824c12d87da0d6a1758e5a053ebeb66d1981b604342dbcb2782d97de18043d62d90a76a7392a38e706365209c9dbe74908340d2af6ab88f89f13fd8e0da03a5f302a21c25114580c2a70fec63c4c9fba19e1e1aa0ad33f2134faf109fbe7e903688ba7cfbf5283c5a94812b67f48ad845acdcd0c0dce74caa0e8ca75dd9e1e4ccc001240f068d20174170946a22336d3136ffb5cd13f2caecc6a0f37bb5b7fc53bb15df48e66fe66a4567586fe5efb2bd79e2f15b87011bb637c84bb57d4a239701b57c6851ba7302394e4773fce1a34d81579765c2f54b538f050dd14bcbccd1638741cb193cb974a006115fe09cb9be34ad84e8154a610f279348a5371febf2e0f20e11c87e992477adc24164d1741ae5f6724341548eee2278a4ee5927cd213c88a4569f7a99337edc31d9194541177f03bbef204451c1849dc33958baac68adf5612bc907a36f619e9551235e296d0ccd5a222b0fdca4af1404a143bdca2b102fed2bd70cb767e57763be726ed3cb05454272bf02c2e03b3a9c812c79c95e145d78d12338fd608ff31a36412524baa4c52b6e25960cbab2cd73bd99c76b98c68b6594ff791bfd39c71fedbf2cb468db4ea36460d0857ff0ba2bb607c064ef60d98556cfa968a51b8917f318e93a9b01ab0fc33df78fd409fb3287d1c71d2beee8359638938204ae41b58ff7c4f02db5a7ab47c0b36c272260003a85b8cb904259aadb3a828f35afc4bed5231b069310b284354d56df751eb16f0129b50684c628b4b44ad206d0ce3cbeb77de8143fe399ffe081246da536a10ff83d648d6a561e9f45cb430875d90293f2427462f5aa5f19d3d3f1913cb1c582f738c11148ca9347aad98f49105d232d273f276408036d7a8eb5ff1d124359b8363c99e29cdc556770d7856e2efa51121c004bee6ebd43d67a5a4bc52463f484a12cb66cb3eb7b2249b483e9cdd0c3be4c37494fe8d3b1be6ad64f25576d55f902830612be128338f321e740ec83c91cc9405edfc7cb12ef927f0377216228da607e4558c8be757aecbafeb948e078a10af5f1dfbc7c46ff27debf7d509ae839a7e763d3001592f333b29e92a5cc8128855f2253dce34b744c08f0ad9fede621c14826e7313f1bde58b9d01ef219d7e078c2cd87e4bf35e932bf34d5fda5a8c904e7d5aa05bd659847cddc56646163a17d46420139f152c70f8f26d495990485e4963c79e75fbf1264f3f0821218feceb550a5494822754e041ba8e67964df11723fd1825753fc5de9dcba555513031427728ea62f88fc3af02924f4df752e69eb288e33ef1f128121ef4f07379f7e6ab0ff0612ff98e73aaa22c13716db5ec595b13abc74833e59f6a7c09d53d0053ea659878bfd61613b7b24bc4ff6dc00f92dd5b90e275df31e8d1c601085dadab855cdfd5267e85c0ebb6f519947233c2f76ae92ca8475c1aae9a5e6e8be5f4382a568100e8e02ad6b97a75792c481695768e3429c9a2bec610a9aa6bbae62e70bf6196d80f4f686b98212592ca5e49d5e48a50f62755df13eed508dd4fe33986c3a3fba78daad6c56931939714be48870d41e05a3a16525b6238d3185e3762137e09484cc118fbe731b5f3f425070b746056aa1307cadcc8e5c089d59a4936720abfa527116ff36a7e7f4e1fba1d22e1f6ed50255a894070728456028ddc0a65bbc69f652354002ef6d769a772d7e35e583f77dd4448067ede5d0f50c9d9b9bb17e398767fdc03a89229f8d916695308ca6bd9e6913dd8f43ada5da5b360db550e8663f13ce3a268483d751553a03c84b7e6a2a3c4dfbfac796bf9963a8ee9b2368f944ddd2e6ad0a8b53ac0452a9653acccfec67841602acd0389765c96395ba83c7614f9bcf0b4b7366b8fa3e5429a552f57c7ca3b62eabb3d78decd40bb89a591dadadcb0cf7f2e1c69369be8635752f6897d7e0528b5a36d3d634b3687371515454d0dae7c46fe3fe0b151b38f6a123115921900ef27f493a7920b7ff44279a1f6c571a7a9af50f2df807e9eddbce00233659beff6349acf3eb4a8b46c1fc46931f59a1d8eddc3472e126ca02935953f29a96aadaa0d821773c86ecac1a121124f39c9e74213cde993ffffce4b4d5ec2e25187206b60dfc193fb3bfea634b152d2d095d1511e1e885caad03690c7d8aec27f2ba3b7edf5b67b596a8fef00b221a1bb5c7c0a1c1ca4cef7ffaa2d3ca4fc70c810b662174acd8da401c055df9b2c3701eaf323cede658e83bf80779f50480abe7ba9c0cab28d31958ba4301fa470e67aa59fd4c17e88ebf8226a5a64fca87ca29158aa93d029c9fa91cc7c7d3b0d1c390d7757cdf24703608188f072c2a17185088550b257c96f233bb024b3ad35422f06cab8b73d1ace473fe94664db466d99e0b89504b7c72f0fe9f9f68365a0e3e9db6600eb6732c06823cc8eae1e947df0feafa30074b3db26042c37037bbf47cfae732d7d9893d4fbf3ebaacc10843c002f8f6836475f26fccdba3d668003c44ceacc33cf935ab56e2429b0625fe65387313c40a4622ae01ec2aa4fe8d7dc2f7757bb083feb1b64a0a52c6c73a579091e38040645e36585e936f8373318b458e7feb072a9bfbe83fd1f8be78e5ca14c2a8660fd827848c011cd8624ba95328feceff69413eae81ddf0a52811f54e5027073cd9251ab9ff0b1ea28842ed554932cecd1330d5e89a9bc96f07a5cd3d446e29524153af7352b59a91760f0981af4dc0725dccc031afb3ee29187527346a172fcf01b9fd611cf1a40f8bf3998b19f09933599e7a348edc64e8962014533ffe39b7f0aaa9d2580837a22655b8f4a27c3b1b94c5d2feee04538ebf07abc75380bd163681b34f2b88e3d1548bd304a3c03bdad4f93d94ce4c44edbf2abdbb01eda296ce2959028a96112b8ce017e61cb54ac2c90c43d5fab7818e4dcd7246192ced742dccbecd65c3fc34fef61e5b893d256aa9727631124f71e56451cb351bff679bbe89212533b29f439c89fdc54ad861ad2088e3b51d5d7622247abe5bfb3a878340d8b6ce602be1ffdd695079519ac71b6aabf85e5a6534547e89d845bbb1135db65f63ac72088600a8e225de05e6d2cd6423cbbee1d01fdd3c38cfd76869763ba977d3bbc2bd759c5b39bedd47d0934acb54c49c50d92b941fb100762a31d82b0b57a3ded271a3d6e6ac3ab36f0d25671c3bc6996bece17dd233e943d80616225306e95e4debc933e43f980cf6a8923c47ea6b6d9a61d8d1c0c1b14d446df3c3c8f1bb54f5a0c31b788c47096edc8b707c183ecd547519a44ffca6d0c28d769f04f03ade4f482476b6156c60f8476fa5f9f43005513dd4fbe606fb2a1d9eaab94bd8777b5ceac44a931fe8e378534fb8bebea79f385230cd85c4868507b2bd52c0dded33785142385f9563808a3e9510df04c9a31639a58640a28265beccaabe0b7f56010d955d2af94f4e872c9f5803e4bb8161b9df6ca145f5efdf4bce50c5eb0f3ccaad6b89a2af0e403fa311af94951d57f518d0cfc9afa17d6ee7cafceb99e6df71a4fe2d89b881d99f69291c16483a0fbf2cdbaa4c440caa7a9a9e45c4b4c5e2da042e4a302d8738db8d26d4ec904509bd14028f80582b1c384cdb14bd6987a47e4fc0d65577b776cc6afbd36e4cb1263e69bd40812f8950f994a2fb67b24306c1012031dbe69feb4e7f99d27a0afbb1936024bdd342e9e11acfa2869f2bc726713770306b502e9832336e168c87ad56b4ed9e09e5862fcc5322ab198f9eb143718516f6f8eca45ff8b74598ec9d468380cfd87bfba77e7a379a18c688f3e01ba2936e722b9e31f9e971af100b5bf22f26c036e101b87121f3fe38bc016d45596e8f061c570d557c5816a45923b923be7d8a10f665bd216da33ed3d84c4eed2dc1cf90fba6736cdb40dbca64bd42c0f7fdee38862d0aed4786b490a2719bf600bdb77adb49f6209a79fee7936f260c7ba33a0b3c569d1e10fcadbf3f54616bbfab0967f07508f771adb1f2e457f29a2f5dbf4273f075f922a16f368312487bb4b4ddcaff55d8e39f4cdf067f338c0c1bf3311bca135919beba103c5eb3a33d919ef9ec31449d78adf9018a85dfec91c60915643288c07fbdd9f894f293ca5cca36602535cffa7f31fa9894456d78391dd09d48be1a8a54773a262d66b5ab44af14a6e86f5a23c98ce4ffbc0c34ae39e50f2609ca28989cd974ef81acc4a2c7703e1141381e4204136062b752cb9c3e6ba1a3ef85be2d9f1bca21d65837a748925b48fd51cf03e0040ff0f6c7f9c6d02a702ea188e16efd83fa490982ec426ca4e1d2e79a52e8c5072d424622099ba5ef0d3fd1fcd654c0c6a6d52b7aa45b627270e31fb705a9fdb9e3d05f0b16058d6e255725fedd2f4e2fbd6ac1e0edbe299a55f75b7efaaaec3f565b816fe23ca01b28a3d2fb85cc609e5fd8154864150618c82981bdd401b4564dbd34f9e557659242a3287722c6b7cf02bf4727200e7e3d78831c9d32121ec1e80f2cfbf1649b61491d5830695440d9e4c41cfb2b0f1c8cdae89b58cef182e215f925e070c6549588e59adcefe9cc3012de66112baef3e5528a2fe7cdeebad4caa4262d5b87c518ffbbec843a03f11955433e2ec4ec117d9dc503439c2cbac72d0a41eea76ca149638e3560b5c5f57ff172ca64d6b1ac8358ce14c8fbb12509b9812fa117003def4fe6693024d1bd70dd5d16bb30c2f4f58154ab3766093790bf3066b806f414c1c8e882758fed783778fa44666d363521bb88936812c89e81b31e039c5f7949462ff5319bc523c359486d917f2c7aaf5e86611987ae602e4b0703ddeac8b730a4f6588182acf35c79459cf01b319c6c0241ca1c09610e25e7598107a1b14d6e4b3dca2c8f1db8e4db66210168ef92b8d4059276b59d5bf3edab2be55f7c2059f6197a89a46648f674461d92813a1d7a3e4de51b6f744dc5b8855722337d059fbf4d6f6573f651a72d1d23dd404ffd1846a3c0c29d1ad41b4df14d88fb1688ce5738e3e00b4e628e831a89323a53bcbc25ca3945665e5d6990f299b4fcc635bc4a7dfe30fe6762a64d7a4bfb5528da282156e24553a32270b18692981c5fed6d8c48f8011075b40d07520f3b06928d58e9e496d5244827bed5d17940fbbc273aa7a63efd74077f7b72b0dcf4726888e53911bb419b88778e952b6dc4e9e7b879ebf9449ae838dfa675994d0b524a9f974ffcdf7a955aab7d7dc8cd95a940a168c331907a5425e1aa429d5c80cf6eb75a40da5b2a6471e244cc6b38903930437ee25b32a6ba4765907f1dd0d8e7c5bc37834c902d4988ae59acfca0a86aa7c548adacdbacc1dd7309b14caadcb90da5f42ce85384b20c4123a7c554e1a677b170c99d03cbab48dfc34b88e99c5e2c1781cf264b3b5534215cb7c57b8f67b18441bbf2d10fe7ddc4b21ce87c32339052c0030b5381f36abd03ee159186d77e358f3055b47da5e2ff5e301f7cbbe7c843295cc8875a1fc0474168f1777bdc132f7c9e45edae438b58de0c9a24b75915d1252b86ab00b83d378eb15eced007a1f4b16d4584e43f4edeeb2b181aa18a408c59f6683fb7632a9f0079f54bbc011415d4ae64f0cbd40fd726deb06ce087f67850f2f3bb1cb862275007f60fcfc4312dcc2a824ef515dc6857a026ebf4928d0b6a19fb3a4743bf6d78d550a87b4b4e5923ade8d7f135462447f5df884ed14286ab76c7c52af847ea5725093390a6d941dae011c9e6a29169e754354d179bf769162c42e963a7630d7e32fdba5a3d8f2e4bd0168ca4992e5af82c1b7e894e09006991ad52d76ba6519fcc67ce4d5e868a652db13a096ec8a58e36d842c92be1d7d1ae32e04e4851b7bef8ec701c94f17a5d59405b6f3f35556db29de47f2f94dddf546556ce6796dcfff7a73009a89fb04744b581946834ac13e465d75e5e14887356064a3e746992fe9fb9d367dcee3612e70f990bbff7cf04504b3e00556c1d6ce6555828ad1be116493f1f3221a231265dc2c656a4fe3f305d7848a80288dc531a5aae9cc08d8155370daed28f7ab7dd7deed412d356dfb54b8df4f7a54e011bc40c5f2e6c2da570610963c2c6efbf3a5f7c63202c09a0d753380f2e90807278ac589c69f17e1e5c9edf30642774adb51a147f973fbe874916d4223e68738ad8dc7415323a73111685539960a09113750986799a371b89a88654fa40ad2d38fb32ef63112bcfe40c8480f90ba4a09097640287e8819f916ed10eb951f5e3de87e8a3a7606b984eb277961c6c6c558600ba73f2103f5d6ca81354e7c8166436cb12ef4e8e4217cc2743773dbecccd03b9ef14a9f8821a054f698d7c118fa3104a0943fb8fcf30ba672e876b7e10b0f86c40759db726d61a2916691e409099f16a48e885459d40996fe6dd7a3ceeb3df6290fd2f0ce10b8852284700ec6b50c797892f8513471af109e89186de1e02942ecccbe9f6b49c255c4eec59258b607b80142403271c9860d777dfe0f506f595d3b9036004d4152397ccead63f2ae79a4cfcd8934777a3031a16fbc32165aee72e4dec8ba260637a5a763be22541a543d2d13db7da085c71d61c9191ea40a26ac91c3957b7b453bdd8e9b1653b39d12a40dbece19a90383c7a404a2955a444fa1cdd49e5597590ddd3925d0b0646ffa5a90af0b78dd0b68b4a0c9d651ab3f3acec5e5ae57e2dbc30b6186abfcc96e8067c6d14ea13ba8f6cecdfede318b61b586ca9dca8be3797e0e7837ef96570061010ba061e9bc76513c582b9ba529b30031723404963a9b18199949cc7a0b138dc01c49c2331767b43394dacfea59dba7956805057a0748c33d5ebfa83db30ec3527f150b661551084f29c3d6afbd316b3e1fecf4b8804f09b59c7f8c8bbd31e2c092a8c3889241c985b494fa6ee7d174d528e5195aebd93cb2518f29265b7bd924c1744edf05721485ac08443706b4e6e6ac127c35a7511f15d39e7916d0df4e4baf4112747a9309afe93130061186dde2c3fba68b70f2e9c232979b3899735bb6517184edf5154e98d12513c77fccb7df39532dd5e2e1e72deba7eb57ef00fea1a7856a7e881f8e372a72d81f173354c9f04b39f6067a9b6b6ef988934d73b861703a5b48c797f753ad8d1e9dcbab490b541b524399ed3058221262e8af5c37ca41bb0526942f10da8f23835446e651925d311fc1d6926b350349d3a7838bf43d5ffd647147a68814aa5cceb1d22385c48ad61d11664fe71648771189e01f980ac9c537cc423ca49a6e861f8c21234a672c9630d5ec4a2a1c8b023d9d3bec085d216326b61a8929eb3e84556a3c080e1af625c7faaa94c990bfb8553131c5de3e1299300ce283f975f838d85b915ae39506a45bff4c8daa81c02390548b49259e1166fd28f9ad23b506d5b7f32824c89ae0887d0789b74af7895173e8a36b9708604b235de1c6b6346f4c3ea55b58d31f74fb0ee415d511c5b5a52bde35e9cc4480b124cede4937dcdef830ce630ad869cda15b843ec6cab030cf810a64d1b8289a14026f80ac78620fa2d264854652aa0be821da4eefd9d2dadd06cc271763c4ea4ef747e28e85da882a6d21c1ccca9830898a34f537b41a2575a2d7feca22bb1ac167a092c2fc0fb9fd800c2df01fa8174459490e472d2febdbfe4f6eb44fd08c4e6a37c32d2920ce08feb31a156e8804dc65c4c7571a4e188fa65cee1fa5e5fb5fa4a2b808b0ed4cd3aa6f2036fae2d4e0c8dabd5d3d6ac40aaf40094197001dbfaf6fac46b728064600157dd3db2521c52e54ce4affeb346c6693df6d202a9bd6c1b7aa715d2423e7ca327b6c358254e9061050370171ee9518541ba004e30dbe88f3c39e119734079484242bcdbf86f80d95cd8f9e7648646ff74edc9b19b98e1c06b24037f59b369121991bca888655c244751fbc87cd2ccd8a9009857113a5a6605f7f5c2f3fbb6b7f40efc256d147faa44eb82d4646681ef59f465379ad9eecdd685cc37d42c7d85a3fd84d7a985db5999468b5363cbd701b6097d5bacd7c035b6bac5d37b5932b41b628f59a3646e1978c144bd9209404ba522d2ae543ffbd52e456afe319691e84a7f6bcbd11c3f491d61f6e351502f318fc1e094822bac4edd45f472a07526917c0fa8ec8fdf120e1bf998f2c30de0e6ad47cc1ecf392b272137423882df5067a8f3bc4f6bc551781da0def391c4bb52bb9d120c4c8591a25f0d171c038e21ab56302747ac72eec5bf0c5c7196a8e388a42db2e3b0d47696951c1104e326c866a0fe3903f5b442833c184f7ca4728c1ab59fcd6c59c550c15ab73f1d3f17a61409e89f5a1f983c392c4f43dae6f9e09af2dc15b14d11e5f0ac5feb1fca7606f3d39d2d68be2822d8eb6a4c09d2a345ef2933020e1adea4b50471eb05767af69510bdc0eb06a30630d2d4e8d806e3d67ac3bcdc7f937f4b0b643f495f787174f9ee71fb56c4426ec2087976c25a8c23693e3d71375787d55bfcb282aaa1f27b19d7621897afd09de5446b1bbd7b7c37944037329db9c3696e7dbe39b96ac268fb525c67a915671541371b60587efa9387253bf7968b5e8ffb7b8b4b32eb32a370bc611dd8caa1ac3b5da07a5e1b7e42008c4e7777fa9db93b3bb8e11f0af2e98ed1dfbeb970dada06f395ce257eb848f3c58a2e5f2e114df8040eb2a3f33d879279de3f56a58b146f49a3819b9f9aeb923a27208e587004171190eb65ddca90d93b82dd6005cfba5fbfc7c3c387abc79f7f4ef1ef5207f7b0f9f95f5e5e10ad14d42b18ad946f6312874eb040ddda39c5eb9bcf4b831f446eca230c8c4f6e79b61cae0e52494593c4bb26d43693e7e99c69c5f639a6a52e28e80ddc6b5e7ecdeb1b505d1151c2afa1e490476ca627eb4a3f027669277fe86b9374259b1558ff2c426040a15541e87f540a46215b5246e040a92a796b882a49135a127d44276acdcc40d453ecca275cec121a8a3df8d80626ac4826f423640bf66c4e1fbcd68e702fd4c95e2dbe2caf19803a390ef7c34d73ae87cfd7478596f02678273090cb64802c974c51fe0a7ab151a530e73d1997090ae3185b2e2df174a628e863a6d0e64e98965a7552d320c15e0c09bad5939fbf2ef18074dfc744cd3d23a2b9d269aa3998bd287f74cc56d9f2703b17232bda0ef4f809193a3b07cb09d66d05222bce811ebc93ca75c13640a4982996dfa6cdda74d271b7fc6db5d2508512d4b1756a1bac24bdda79ff6109fc6fddd7bfc43c9e3280304df5756329a07f79fd1f6f07ddcf4ff858ea0a5c43bf232abb1c7371a2f66d8108ccda5c0182ed644963b9e285686913981a14baa789224a9f42293a2d71fd0ed775b6bbaa52ff4431cb235240ca19534ff853e91b6623fbc9e615ecdf281d80357effbf7e7b9854445958b21bff08f5009d6df1757cf34feb1f4db1c234aec1a0bdb345efe761cacbc9870aff20761f33acd227834cf30efe4bc1d764e9c1837b40326dfb9f7fae5d7a6bc4f77c8e9b31727533bda0b1949dbd049463b7e6f27786a4c851d7a735e88f3ffd89ba0a283aad472a811ac7502e0d9cc950adf928bd8889f1976b33af59addde592137329037be3f34842fbf4af8872c833ac009807d7056ec9c3cafc689fa11f5fd86a92158c9f6d76e30a5084a50dd37ddda565a4dec5db9f5f6e1924caa9515afc04c4945a5fcc4932d8ba166c64ecb12809a582513e099b11e204064d63a0ab8aadebb6cc940346f45f1915e1cf5b2112e5fcd7bf79b74a9e7d6c3c7a4116c743a147578d11ea81e15f2d1564653394a016be324c62c2474a2c04ede28bbb0ceff3102ff40933421e885229e87925dc86a9d4672471637cabbd30731300d72fb490ff5693567824f6f78c0b430fc6faa5d33ca3997084c4ffe2194bdb6b4a0823bb43470535c2691210ab6e3a009f32f4f518c6aea197ffaf30a0335c8e4e4e32e6952fb071a8977155373f31bd8bb8a5a8a41bc5d58163dd172c54302717fd80f3caca4b93bde4f6223ad1c789d487bfab1f51569be7da936203d0ec8df761481a926e8c8e12bc02f06e5180ff01cb702f561b550bbd10efdebc8f5a6e916b7def95c57432395b9e7938e8f60b669b2765c6cf43e5717e62ba8a33d07976576204ff70207869c8648a7a4673c924c681707cffd4fef1c3cdf6178d930a07ece9c6daaded7f5c913051245ce9792a0cbc1c74a33e876967384b842c7195d8ac5bd29f86954f2693217e92ebc971da5cbaa0a46ff65f4a0146d61cc3a7e05cbfa3ab718708e82d9809ff4a26c45c9fc21b319f0a08f686a4f9192830b6cc79fc5b9d3cdcd31d0c1ac4e1707dd29267787cb113faee1826a3364ef18b0cabf98e53830176a3f2e22b0d754742a40da60acc9dd9e168e199dfd4e0c583aa66220055852d58500ae30f59c4c5d3e36b0e8d82c38bef0aba1b9eede86e053c0a17629211802b7e8597450732ca088b54620a37d6b535a9600b55fa6e2789ac10adaf28eb362ca83145d4bbac3d5d6259b2146c08d0e611eed33407bafdee1bc62bba1cfee539cd8a45f4ddce7fce199d4c8f39fae40bafc299ff9392e426a451e9e200a875bfb5b08f21466e0a237ef7c8dbbe0915eeed975778de11cab727687cfb2788a29337ccb353f9c7f5d466b1ac5c54e309eacdd712e3e4c933599c2d20f1a14e0d7b485a086665da90bd671ed65c9a60f8d3e3fdfca45c53c0d81e3ed4ec884fc6c7f42bf8e60d664858b579dd185193c5b8226f50c1f6acdcf58d2e239e1585d9c1b6ea2c7d93a7610c65cd5e13530d24697b352d2dbfbb2d7b3bcb1729e5d0f8cbcfb413b01955955ec2a2e91ec3ca68291cd36856b9aa8086d5f84f4f528636afbbf422e4c5317d71393af7c99ad930f780ebcb919ad12a214bda78e4b0bdbb164893e9b886fd48f178529887642a688877461d9eb64f53a4f279cd8d29115f179dbd34c36e8d25b1ab28f577700a9359f2693df48e7f7f54a689240f71ae1013b9568ee83bcfacfc3ca98f24085b7e60b125c3d0dfe046171b893cf8af35ee67cb9f678b873eaddbac3ec0b8a1e79a0af6a2ed2fdd54dbede8ee875f64b98284701c60819caba22760edc5ebd33add20cca0142c9be27c17514d76089551f678f0bed3b60f8b21fb8fa7f9df22dffd339a8e62ea4ccbad4090a96a77b5e96c4dce741a276773fe254c9be12721d9a36610fa064e90be504f7a5f569cfaba87fb74382b25eaec16bd3ff4cf12d8efec97ee9018daf98394ffbf7114a1abe6baaa39022f7de0f1ac299b868f059cc817341582b0b6c40620461dbe74e315013762ab012fa71a5a98f562dc8b67c7c227514fd73f6115b5e935ae182d788d3e5c070436b2458a92aa856702312984766b555458fd416b2f081e734f453d17e24663b284fd2c8296c93cef2a52af2dc905f5eb6fb777675b1030286b1386952096427303ef026591abf235ca940bf51bd17ca2e4c40a211b6142a8139b6442a8be62b8fa46f98387ed0aced5d24a81786d54d1958f150406d10e3b8134e45ada1cac0ac084b005f53d3b8f529e48678dd3d96cea55ecce13714119601690219362e69e2c5d01dd422e9ce13ecb45844e6f0b1ee291f94b005a4758835de75e25f3cd0a27e65a750f1eca033dcff018cc5451d1d0e8b00491518c9dcab185055e4e61bce01e2f0e0fc3f962116f841d6a262f37bb8e9fe087d1cf4a919db7775457559227d6b7d8a9916e9c520a8c876f16113723a8254447bcdc546d608e4007fc680db52dc111f97bfaf712d28740eea8a3e192128481863347a788748412f4671ee6fbf62c40fb3f99b395ca8e1c44e281064deb11a814fb5ada917980a2116682f93c401b622db7eb40537030e62455088af1e9500e09d35ddb3dee712f00225df037751743727c9b75594ba2ca67d4a0300a7010cba34b0d9c420a2bd156b6b3dd5ae38cbc930df3221543c6e27e1472df448a362d5fc586d9f292aad5ad9570aa5f5910f139fc1a6e5850cbdac020f7f13427017895e0c43156ed2ffccdf34eab33ac7d34c980a1c973d525aa4a23c939db500062152a50edbcd5c7350af2bfabaaa43a55983c7108f7177270a1b93276e2bc1cada6ed3e10ecbcd9fb8da04506ce0b67aa18d24a04876b621022d22351151fa89148d0e41538cd31412ab3fcf10e188a0ba2427b971202270993bb04e12c38d6e62925baf1f04ba6e8724377873efcc8d777e392751ceccabcfd91734e97f6c6a581bc4eee06c03c21779e2528f31571e46773a0708f426e3a48367aa501968e6873c89a28a775d8ae927bedf4abc397938f682c8f407a8b9aa340cf8fc3e7e10f7aeebe13984d4ed6f72e8f7f14069c1342102c7ec7f64184d553090bb4288fcda0a6c004100fa4c3b1f63c9604aeac37a56a8b7373296d395df8c9f29739f2660cbffd478fe435dd4f2f927dd43c5a0511836267f67d6cbdd86ea456b0bcb62394e4123040607e827d5e44c9ca88711723c01a3dafddcc7986cfdf2d3489acf368f6e3f04c187ca19c63f724b6ed49182d86cde042d78a0ada5f6da97071141dae09cff4fb26c46de21a5eeb0bc5f11d435c09e711de8c70a6a1dfb6e2d53de3b47dac3cc781bf7669faa0bf027e4b70aba44d2ef612fdea5102a0a3928561d5733e89d78637d34cee3440de897d408d4aed6e8cfe4968f50665174979bf992b40fdb344f7f8e4853938472ef336113e5a7fac2ad446d49d8e3dfe5be000389d9ab2244cd8a7b15d520ac4dedca96072f4d5d51a31c2fb9970407687028ddb092638c14b056eb448d0137726911848831f67cbfc5237b4a589bae7fb45e38a1165c2e9789fa6080c4b56bddb2597c613131ffd699bef6ccf418a992ba1ec15bf2d729d0eb8d77b07780d27ddd431847c0d6a4ae8b8bf1e4c9f92d0b6bdd9749a3eb4a0455611b7e999be2224c8a8e6f4f0c895b542aaea9e98c3847c61e6fcf2425e028999a1204b9a9e6e394ff9cb0aea302b5e39fbcd9acf71d7ca7ac90fa82b98fba62c351435b97ec4070a3caff9f7fef831735e1ce15d020527a74cbc2a9b2cac141b0a5532427eee0730dd30be87cde9a1aa9fdaff17a3cb664c417117034ae47533ea62be4c091dde56f8bb3de9409dcf7abc226e73f85bdeb47e3cef3b14d169e589a9677539aad052f5dcdade1a2ad2011461d3c68a47653c9d82ba40830ec2cf78cd5ee8fd5a655c8f953915274f058e93e62e619369209e23c9ed8c14fac476cd4a035b9b4678834a0592407e402c3a0ce334e11e3019d98f4d3e528b64be67a4bbf7a93d79dae487265fec28a3b8ddccd836d1a2e27c9e9a9a8523e083661014b7a36c632f5e5ba973914c59e5d90f650f4aa46b0e4dd22494dadb4d4511484e93c4358f92cde2f81ce59adb119788bbe90f3a6bd9021f3021efc1b84a159e716f83f15095889062a32b8fafca20202aef48d8b4eb4290ae8e4bef77646287144097baa4f89d8ce508bbd2a3bc1a5b39981c6cc7e5ec7d79c42e56f611263c75459c11ff92951df15d295b3fda5f394fd7e9270b63d04839e18d7b95df32908a2eae9aa3e30c3c345fbbfc7dcc214d36f7d28750c7887d40265462ab6d530fc223df5d12c2ebac0982a6adbac6786b0e386f0f7bac6727c78ad8ad99af9aeebab58daf724f23b6eb43f32a36bbd36b9bab98e75a47111ee47dffac9b2adb2c75ac6926f86d30388466e8e674062210b11ecbde5030d340e38c6ecf7b6fc5a395d48c9670e82d8d1d40c85482762411a7c0784889e3aa7155e9dc9bc46911f1fa1396b31d07fdd382590a7159428e61ddd470e12519695c50edd22840719ebae33ef6b1953f9e4eb5bf4f939d994dc7ceaa640392668373b4a4981aa5e3da5b1c037708af104bf055bec9ba37cdae3fff2573d574e3b5dc0a7e1bd115c3601c4d332f3af54cb1da75360828680abfb1970c35286c8778b67e66b60780047ec2359fc419cf6e81b03e96117491a48cecb749022d79c6e88c13ff8b0188c243669f844653e1db576bc921f34344ae3068c225ef643e1823b74f66abb90449a7e199a1e34c927af0ea9d807e093a5f9d8fb2f03b8bc24ee4d0d0d5eb267f1331bb1421adc20842158f1d526706b3f5a582b25808f611c93714d03db60a7ad23432e19b13deb32c4c10b91cbd1e445f9b8c91074991ff7cd3e527ef4d8610b3d421070a0ee4a00a6145442a544493a399149aa96527252dd60ceec32b2ce2ff71192eb418c2c6612351d43938a0736505fcdfad3ad96477c3921505a45c84f7756b015e8d7d4533874e72f3269d2c2dee603e7afda683d13c8fd7b753204de1792e9148c272a6f19addd65cff6e6148ff6a97142418fe666b64e8d213f32e19f3cd0606cac5263a8b9c8b7e980695aab4dffc395b0a70925b2041cf0b183c4cf1a5a859e9dee46a69e683e03d7299a15632ff9980f8513d065060c978ba4ac3cc59588729475959b6ebf7eddc1188f08d859f0cd1b20dcb3412f95034e8207283fbf9427166b42a039a7203cf73f90bda69b197bd2d40b50070f579a430ffd278126ecbc957c334f07f0475f18b5207df3950e5615a2378d1411b656f2dd9a6a44fdf9cada0eda5ea056615e7156b7d75516daa8607490c2f60e087bb1deff8b22800febb4f17ee395ccf1b621297544395f8ac016543e0ead161f3df51d933b1977d8c849158f7126e0a01d87045b7ba8042e4b8087805c4e8796cd664311bceb2c158ace829b61b7bf558685260f02829c26cb83401be4601b6c38f2983c77a4b5e01f45ba879e67f4633d24c14f303cfb058ac6f639f13707690af3c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
