<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0c33530808a3a9e2b17ed8e871e1fc076686180ce193900298d2c6f720f2e508f58eee40f47dbe037d92510bb874d998111f4db0f9f591f830d6fdc6a1304b3c2b2203415a5aa959a074791a2852a63e2b964a239c3f370341a83e29914e5fa99909e82c6c57500ef2b523b666784275ea17042467f89f409fd0e06393e31d37aa1eadf4c6e2f007f7cb189dcbd9885da11c738cd62317ce1736622d601a6b04ee8807ca93a12c35dd4c36b0a3ad3f7f1c7671f40835aafaa67a7f2f97a2a0519f5b40e056c29b34a009a3768269ccddaafe3b759cef90e40cf8a8477af1a2e7fd5175118b538c2b3e4fa1c20328c9c14d520521e287371dda4fff39128520fb7a4beee8b0881c05e4d67aa40d4f00029e01d21a8c8a7bf367cb2f40836faf4dbc7d7a549e4c449b4fb274ad31c11a092a31026ddb49732ecae5c3e0eedf8fa74d61790b95273760a90990e7bd9d1f902f59aa26f8d834ae6fe3e210106d3fd7d7feee610fc9a6a0d689ba18f74672b6e4313cd80f6077435ffd9b5e464026df13fc8ee153b54041ac584dbd9a69b6c0541b9f93a229e8da27ef7f6c0df4c60b03f6f9603cefb7c05692d20887fe00f15747bf7f429cb34366e9e9ef2a19aa86e3b1585c465e2837fb6c885bab4d7f5dcb86ea31419c4bf29a052842c13c88dd4a0549a618270920d5581e862b7909247fc50097cf1aa7b251570b6f36dc43ea4c08b8f19d3bc8de6464082f2ee42a18acdbd20a075a615e5f244eb2d5fbe813a5b19ddfd3df8ece6d890f698b9726a9580ece8f1021b60956c3ad1a3187b0c0bbdd0f8b51c9493acf658ce2c4d78d4faf1f59a14742a9e7f416a3fdc9a4739d8d9de12b0304e648354db509b1130f4c6a611a566a079f14dbd6fae401c98d6dcbb17198e674ec2e4dee405c91ae83b728a997b24b30104c070cb92be539a59fdd68741817570ee5f730406d4550d2f2aca4103637d0319faa93133facdab08a857998e95f5d42f38f2f0f441232789fd1ec3adca04c52a88f1e4b085558c33978db43f739775e3f77e04857e7d6e57bffe53d00b5f9fb64f4bd3bd6c4dbe083ce0fb26fec9d03629e5ee7140e02a7d3d4ef650eb31e45f063fa3381561bb9c9129a2a332ca939452248b1212bb083af3610e8d0776ae6f914350dbeb8758df07d6f2c6711cd9eee451ff10b95f50ed62ee74d790a15260623a621b730874a8dfe557665270ed1a965d6b45dac40191f4160e3c037fdc38c7f1bef8af1cd0e78f8fd94e415a7cc0577b7df5d6b2d9641822dfa7e5c8a56762419d6b17debe3b8cc0bda8363d20b1f27b06efd19f8714914c170a9eff406c223d2093b2b3b608634d9c1b8f1d66dfcaf1358e652b3c9f94861bd96b9017f0055047f1a40871e83b05376e6d12620db639da19cf561afb88bf711a5a610c018daac34a9bb48b3b3c0f7e32e96767faf17cf83f3ad013c3b47584290cc603aae60b53743016e996b8e8dde9b9a24eec393e6ff9abebcf7d6f0c8708a17788cfec2e278f9273c66c40fe47e17bc8af381fc309601f3f33413584537d654db187463641538a6513803ee8b722c6635d734a5854f0432913f977eac3c59f1e7acd2a705a412731b14ec3df0e8de4163f077af781f9410fdf63278a6c6804db67613de81285e0384d2644f436b8d3fa8c474e32497145670e38a0ec61b1ceb84da93396dc5588413be4232133ecbf6255860e8bfe1e84078884aa5fb25a87e87f1cda8f7c640368e33d1f0bca60962ee78331361beeafcf5c90f83f95b9501af93383c56cdc574d1a3a235b7678930bfd1f93ab60af32b5db9c94d8a8e6ea9f3f8719e450fae53c3f81c4de348dc3a349387e921deae2d075a29f3fecd8ddb188b26ec796d4d2ec57c8ce101f88b29ee52cbdfed8bfbc4609ec1790878c2bdebcce057cc31fcb143ba8465cc1f70149d43b6d1a5517db5df1840e50271bdfb628a4d372a705199491420f1bca6a31533172eaf46361a365a8c2bd56f84d0c9d35f70eafee2bf5b9aa9770899965cb61a8bb7347052966717bc118b57e5d07a4883bddb894c90b781d8aa42e8bb894bdf8428cfd9280ae4e89b63169e77366e798783b4f3a024a5b2ee60a5fb44c253f781f86c695ae388f3dd3a26ac082b8aa92a821b76945b67c3cc3a73cec8d55bdd9cf4cadc471c54b26be92565d00b55b0494f8abb91c1268a15e8050fb02c4bdbd3e812ba0aa4db9299b17777e7b4469cc6217ac82d0d0def71e61fe71e4772289fccba18845bebc14ab4836edf346c8b947a77a9beef18adbfa88413049ee491a92f2ba7429888a2f51de6d263b6c490338b24d96c319f4f51b75d538f06be570695ba75b1ba1b2f1f596d83795c66b3e73c021912e3f59308c8b16f2c92c1d2ec42dac3fcd444d5fb49f31e9ee945acf0ad56897b128266df926ca24c9f3f37adf9f1502c2cb192ccb8fa428003141c5deb1cffe597e6ac29ace6ab71e6e36a07f180dec0972203425463044eb8144d66a6218a4178af115b31c604da06033d699f449b30d1ac326c7612c954732540f12989610409335ee65ae3e3363d60470cc189ebd34e767be759a0f992dcc50c1385670a9666aed11501a47c58bfeea7c884a3fdcf58dd0ae66f9de906df21cde5e4780ce1b543f88f6c7b5f7c50e3102cd35cd0e1bca2150bac780571eaf9290702acebb31c9aa0231d87d3c34d4593a7dfb0e90a2a39b2234836492b5a435d972551b7eb0b7476050a39459a16089155c44b106265ee9f6a4b6750475d06404cdb81dcd26cbbd29d97263717c57a2d6ad670ad0f93cec7bef9aa04b314bf499eaac4fc2dd69b3d8b7851ed29d8d5b3e9dbbdf927986f39582a195cc5df7cb5d709dd4b4ed593c39fa029cfcf12a01c2a80306c25d2a443077e4f873dd8259d736c6486d4bb2438c036721c3dbc8aa4f7e6cff71983b4dbb5aea3d26a2cb4127a91f78e59bd7a28a6871d28e302dec957de2b27e528c814297c2f5083430eb187690eac647733ee76e77290b777d1bc5a4c68ba66887f2dec12c5a197d191acd609550dd2d805acb550699af19d3107305c4b507744333a2541679db6b666c88f690b289bb2ee9484f8254d3a9f60c777ee353c253d05d83c49424f2f6729467271112502a290e42ff97b0770f27f6f28aba29ffbd1e16377650db4927ff40ae08e4f742038ddbf5ac8ecba7257acee147f5c6013f49fdcd1abc8bd4792e5bed1b87d8d6ae3619881ddb15248b19518510c1d77f518aceb558d8f74689b53b233c0a2ddfcb0871c8214cbf4a3fbf2b3a0dfddb6cb710d018b451cfb7071c4b53a1c24bef62467a851a4a66018d26825bb9101cc1bacad504e2c5885632d228c1651e67e0f1946c02e4f5605ab62816a9a0b7d6733bd9e35f11fc2108a4c01fcdd67d4a8a387399c39fe69516407a6261cc71dc65bd4781f47387be5e29636f8669ba5a8ce2a33a8c60357ab95c32fdfe621f72e5dc24f126cbf6e3cc33b29640c8ec4438c2afe9c7eb9159b5d492a4da8d33eec33d78118320478e87a623bf7aaf9f5b75f3643b55be8c1c4e4d8a050fb7fd72e0bae64d07cdf3c6706c90897f386c0aadba9b0dbbb10b188a20aaaf44b228ba35af9e1b214f046922c461c4304cea194bcc0c804a3f485b4d924df18896602dbf5393b7e5e4a7954723d40981830186887278c4f4aff437a5fe4a53995ef78e94b8169ad915637eac2e3c01396c9f9cd98d2cba4f78d7ee37a1448db09e72799092132dcb1cd71cb3eacba97d22edea69766eeb4095ec5afc5bc5cebb81007ad1bb747c7579d1aeb4fb8083b7453c5c9c43d3e59fb8bb742419fd1ce0f3f08688a425d10b68cf768fc3d961aa795877b762905260e6a91d49b593dc7398088e819a346fa175acd47c2851d684b9f47862183d4ecf3cbb6e58139a29dcd1ea94eb723e58e5e3c5ef743eefabdba55eeee29e2c8f930c9357b61472af86bf61b1025c04eed788afdee04d980b67a29b83cb680c4bd6ea0e5633b8b62ebeb6300e68a6ded693ec4b760a0adb2aea1b85f3cfcff9a6c28c48bd899b1aef143e386477fefc22985aa0767bbbc0dec949d5be0aa2676c658ca0c1aecb2ae69d43abead322e8120cfee01da07dc5df0d194b0f7490465095eb36334e4f138ade9706bc87d2e70c51a33ff9fdf6f536e2071e2dc8104c4632373e5c951be710a61765faac592aa277c2d2312ee52a5408bd7d2ecfe8dd2b601af89a871dd399dd1469a512eaf21e320ee000f9c62106c75b295dbc1f493d1f45c052aa083b14d34fe46d8f57cef97fe713236d06271554791b3191a3d0bf28aeebae57d9322c6ea53f2fe5c7af9498b40c75f31902ec68f97b9f63f844944573e2f3a646928bf3df2457814b763e79f3e2bdb54522da4a0c54118644020e8d1bd64111c870af1092675e0ca1ee5527c415885db9227d326a7d93e31100dfe5c47fda04f2239d4216ce50c1a2510df390e2d1a736de9814067d58e52cdf8bad568e92e58b08d8b9abcf5beadb21f83c39a3298c6d891611b3c700a4a2454e176094d2f91941f2d62528fd394b8fa90eb692c2fa24d15713160ab3d8fb459f2796fc0020d01c4fd1c5489832707c662908bfa3167a6f31171c04cf074594150df775b889067cbe3dc98ec29bb884fd6e100c8f0d842efef72c44ec3e4055978746b595f33f39c3fdf6ba995e0b3ccf03c0ddee3501513125078412dd61ee1ed61293e27cdf90953547941e5079269989c172e02d2e95482ebd7ecdd5711b01c676a0359e2ec283086c570e596fb46b30f60f45016ec19829ab37c47f763162fd083b12a40f342169335d1e94a76f487b214f7b7c1d3083a6d0f372654306e4e6bea4ee1d15cb1fd51a6e54c5afd95077ece393ccb9aedb108add51f6340a702490beb46978fa8238cd19621217cb7056b1efbb548db91339beb93afeff2c0b79695d96788dc8c1fdec21a059e6634523b2d3ef067e7bef3e5c3980377c19e1fc04502cb5b5222c36e22583b8b9a8df094f2a631c6ea6f1a20f34918fa7bda60b2da70602dfa6c3921d61dbd71dcd1808b5fd9ce1750a7a6a917598304fd8d8cd984731d37704a9e319d4d7489bbd5873849a20aa563da4ae2d6b7488e0aa1c38c2905433e89b2e934140caed8108dfed8ca00706457cdc4b9721e66720e0d98935def66c2a00c9ddbe553efec5732e1a26070b48d537f7006ee411f4ca329613941be90754224f20d3ea96f29c1d4d8818732f7e6e1d0aa2b36d5673a14672123d214c2ebf362fa60b6a6eb5ff6d1b22b9b9d6fb6f671d5b2cf1f8ecbf98a6f59eb85e9d1971d1bb678f037adeedc80717d5365be623093a776f24428297233cbff9297d749840974553619ebaea77aef7932b551ee0182371d38ce58b2cd9ed9eb3a351f13959f685e814dffd878a82f48d5075a8305b798027736e2280e00cb6cd47ccec3334b6ad87f54dd5fde63291360f5b3c47e3079770f22e9cf419d9edc63e73294fc7cf121ed8ed8d2418fc230498c7467e8b79d6b5cfdab1f63c913ea038c2d7aecaac34824f5159a31d4e45c542ec99630446ff324da988c100cfb37289aef58e858868a218933554507e91e8a6f2c8f590a83b293d34d845371d53fcff2484b496086ad26921967f782941fd638a57cb1cf37d4208421c0037e65eb15fb6025d387e550e6e16a8d5f6af1099267fde91d87cf20410820744888da59d8eae542307b3ea77c3736fb04a2ac25143f9c8e452ea0f41ca2dbc6f555306b6ffec0989270e3813be4d82e0c9b12780f4ff8ec1dcd44faf08131df8f0ebf8dc704567c77df8ba1796e77e8dd2d4574ce03fc367efc35f037b42c8add7854b66a940c0c90d0cb4cf6061f8657534ad9fe6bfdfd5a1016a462a861757389b5752c3c4232ff4f68fe7a2972a057cca9d086a656ef31c10158290263aba2df06f01fd7c9e3954f3d1bd0007d3b4f12fe3719b0fb8590f04756bf6fe4b3a015b5f4bd5882bddfc1ccba5eca3a5e9a00b1ff2e80720c7c1bd73bff70f1d8a2131b27464f8fbca2400b43e3e0d9a995f3bf791c6607917f15337a3ea9592279366f8319e969fe64a7a9485cd0497e5aa98288977c276e2c7ef86fa212c93a8bd5c75638a1efa31dd63ae878beb3bf49806f769308919d4dbe5e2b42009068bb24f5ea145bb088033c59801c9c9446e22d634263df90edeeb910fb86648c05b20930686fb877ab6fe982dc6ea6151e9d330b299e08c0e5eb5f3e87323aa48d13d182ca89a2d2535f64d128f0b4259241c8c598c8c3529ce7e749a6c711057d995bd3884fcad756db23303f9553909d687ccebda294f6d459930f67bcac4f3109d652462296eb037d86790394eef587f6f17804d03486ce3baa9ab88f2b9248c5d85e126618cc5a644182485f6b3d459c329ecaab82d775aac45d62f22d9b292ed05711c09f840aa970a635d9cbe8b7a9d7fe3b636c57cda81a28c891b0c47fcb29ae3c7f0817f8a23b60995834a41c8ec9dc61eb997a74ce574a689ac0b2bc6b5cdb5f6b29aff8350fd243fde1bd0badf448221d3fa0ad6d6665bd129570fec13f0c91ea612acf12a39be7221fcc1ad02ecd1eaf2ff1b43c0e1e1c58385a277d1c24b77cffcb5c48355217885bf03d4a0bb49bb20590a8952337e93022c09f24b54e8a9ba95daded9593501493973a9fe4524c7f77b9c9ab9b70daed838e0a2297cdb7e242ab4c1b800320946ae8311feb4ae583b545dcf778ae6b34e047d587e4b1604e24bd317955a58c06e2152751ded9f5cc04ce200f707c89cb7681fc265d667cfe3bd45817cb0bbedf222635d6ef4ef37b07980866c11b7d0ff4b11cb8b23669cbaf439cfd83b105bd03b3b6419ea56fc9f380095ecb97e4f1ea6a2cdbd201f74e18cdf0e17ff2e574ed14eff5c284961e14e197d3bf2e6de39a7be32dc9307c0f476c753e80a6b8432d640326546b9ead0e3ef7939519038c12c6ffb64a47a8d5b7aab41d74654d3e78bc1ae1ba77a9123c755d7ca635bfb2f50e97ca4eb304e519c1cc2938e91e2ea1541caf12885fe21f216e613b061b4524435fdb95c8de682774773eb9be90b9100cd05f427f7724e0c869e2374966f329ef4c2ae88f797e737d538e182419d33f685aee0f21f7708ff706c6d2117274438529f539c67f3a3d63577dce27592ab571a1cfb4a23707fbc2873b0922ca7d1b0862602a005011d8a5daedcb6edaa2b3537e50f63ca37d1b7ced867a7509b0dded22416261c89900520b3d5151e68c8055af331bf3294f45023e4bd90f0035eb9de7a0c91db7910620ed1819e3d73e6559a5f6a42ba7e8527456b570ae224617b9bd0e93b945222df38de614ee0c0c4e55e0d351d6d0655fd99b27c1046e7a90a71a68247f2b725f72bd8a8fea4ee1f79dac40287d7dfc8c7a3fec3cfdb91b468959d7efc7124408795fdcefdfd48831a5d8f3151a3bedb56c16e2bbb582c327989b51f8a03e2cabcc9164e830570e3e69a9f0197db19b07b069b50d4aa7b8ecd8f59770e1f44cd777a838815a31c968dd9c35ee6472ed5e37e7639ea4e40890e5e055e90443f9aed62e0c1cecb57fdac42eb15327164f7b7b67cdc950fc4a9e456129abf1cd8e863d418a7b241d19e1f7a464890374dc1b16d5659bcd8bc0a5bfd78a6b11809ddc04e59cb938b20fd81892ebafcd7392b1e1b54c43b5ced75ed8410e0b5273cddded05e3e6b0457e57a5ee9ce48e6ef1f90925212dadcdd733d2d074fde62fa48c88b30e4c942aac4d5e652f8bde08c5f9ec3b330217eb68be76bbc8226bfb9228e464ee3ff665f2b37b62634c17221d96893ba0115839e4dbb7d3a8857ab4ae2b1dc0b1edad76cb79cb05dc6b47e1ec7499dae889b11581d5f67d70e264fc816cb38ba075ba92d3f15646d0b928ba6b5530107b08fed9b61ed81eaec1ac9cfdec1e175f64c1873f65b56dc2bc332f37a4dd5aa1c48cde5e4125f3ee41f1712fc7d3c0e4af63e9e331994a69f89e3345a4daf494c1be7c5f657864a16816b3f5728374c2bc001d090107e9fde6cdef1e3fe48074412d079f69139da01818803002c575730a71b01d2a4ec996db9862ee1d30d1b9d474f48d1605af72d2213adb645379ee29925a17cb1ce24b85cbb3e7f0c5758de471350a57a35b7cdbbbc2f93b18a033762820432cb4059e7378fdecba388d0feadc34637cacf84c02b3f67b58066edace453464e19aee0996709d481670d08326030ac4fdd73b44db38d8e5e140a1d115719cea6c73bc8b626ecf5f011b0d3595164bb8f34a31d286105786316179372800492a853eb21dc539c86bb27b83bf268a54f5b797a729825ae661874752704538268a27e3f81abf6d8656f22d25472420589b8211212351ff1598e3939a6d0f7118607a316189066ba4281b5f643f74dfc372105a56787e6780a349a15801bb77ee9341480ca82347fb491c7316339b58f404e538f3fdb2791d3fc13b979bb72c385920ec74b8dce8085a7130e367d84dfe22dc85f1a8737b55eb4790c45337b7bcb04656b0ee246f180e083af307bb8e48f0e088f70548ee1dc75e8d69030df47522f153ec7ffc71494bb3ce5f81225e1017dba5541cbcbfdeee36d85f726784abb6d1288153f200e91762cf61658ed6432001dda959f4e31aa3523e90b6fc001727cb6e18aa72ead1a086211bb00b2d38a9df90d5cb811a1e7e0f904b98046bb27a8b33fb4cedc6f98e766bf3302ca4f64e9ac19718629471d7c670a64ec2b50d4f6143cd39f3789609673347b43c08b6db62b3605fa5abb263d32559e819e112e359d3fbc1b9a377eaac4e54e1b40d715564559a13e79233ef5cf4c25ada4444a5114628d2909da2fb25f55097075ab2855e46244e8f95912f4817cdb0ea2f015b3aa63d56481c13c2c5a6151ab7aad2103a77fffb5c801d97e4dbcc658443bf7237891db74290c8b6727e7e993b8493c90189ee546986bfa401bc73ff2e28c71f6771d2fefce76aae8fac4a407e71ab88c43be7b57a761af02e662c6fdda8c5957b10c8543edbceff4ce9aebb694be7a004a05988164c50cc68bf9fe2636e9d91116adecda948950935b5882b5a7a1ee1a4391894d9d6a4ff187ba34147c1b53d6cfc40d92445c792c2f461c43292a27c481cdf04bb385650c24e90dfa651b26cf7ccfa567f4242ecc77b591e744f6dbd77ac5ed806bb724eee162c323d4ad26430911be01e06a9af82603875d8e9c13ef02c24964d52154d1cc05899c58ec26e1046c3a02feb1574f3e679185fa871c136f155fec39fa8ff0d67a80a6c565ef2850938a50f28b55c95f76c8df675c4a8aff59a524f6aa5bd06972fef98b04790de116a4a7d4cb12da03c0ae62b907b2fe8f6f4a862dab3864a39f39fe997af404a39c6c3c6d5a135462094a1d564af3f9bd9bd2d94b2e1e045819d792818316d7485d762924138e76b4b947c4f594d7a3cbe2becc2084d717c22643ff3e0435f474363dbaf4beea3afe5251b18b36c0f8c555c3d2dbb2ff758aa28cdcc5fbadf8af6bb059ea765c6cc557428bb923ce59a9a68a5e281a62668a4d5a6e47da545b69ee55f3aa3df55e255fcd72ca117be90b69b4c8240f895140bc83cc7486ca288e62bbab59f2ac82aa2416b88a4010811e0cd91b9f65d67ffc397ee70ef32b523fb7d2d7d3e975a0e73febf3a504c60d27e0c1e794d8c04b6d2999f50e8002323c86a9508024fdfa47f25f4abfa24a6d79f0ecc81f10a4b35bca8f2a3326c295acce9e2b4bc7ed3d2ddcfc8be51381e0d7a2c6e8f5c998481630017c3527a7f5ca4dbec85bbef2cd30757838471c282ff86c04d3574e3dc9119076e1450245c5aced2b15774250f848ab3067e3594623328a5641d49c5643782a0881a749bedac333800c4b1db3b419110fb4194b8300771d84e1c401a2f12e642dc784cd218815c2cc7b5a0075effd7dd878b32a23fbb7bb153f530883e75caf137fdfe4f1ab89e42afff31cc430d899af2e4264a627d5c2d6ef52cdcc42ca13b07c00cf6c0bced304efbc46811b0e4917942b2d4c84ebb5f48cbe7a1f7a928efd40d6a2b2ceb960a76a415e1c066e944413504c2d25b6b70e1e9a542acc003e892e9248282aea8a7db2cfd6ce6775da45709e0160f954e3feac99545b641bbc4d2f5a8a7fda56108043243db5822949acac05702604680611259a4be5d5a0b05bb05611a2081e893406ac38f8ea993f1c30bde3563987a59649d258e1e1fab33e272fd5868ba3035a8e70cd8c4886dd1d22b37da61c9dbc28c64a5f4b674b75bcab0f3f38da5366aed710566c983da93a6c30acdb5803648e053404","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
