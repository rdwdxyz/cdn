<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"524011a072c8ae76d60e029b763a580b30c8b6c3b9ea3628579263825de64ba75131a3b2ae1aaf86c280791bbcf8d9c8b88185fa22e4481488e674f7abe48bbe73da2df285a5c7e1e9f306bbb5d66b3af862229dcb2f1354d8ab187fb64a53c68110802204ebf6d03bad5ae8737c4ac21e099a4ff420456967f7b7bba34848bddfefdaa32e6a44fd0f102418598d3cc8d6f52ec32021242c64b958004ef4d37c2c1c52eb13b0762421a6620d4dce56109651a692edf76fd6c50a445d7f1c413f1d263343ab0094d77899abe7019a8981b9f17fc161e926c5a56a0ada07ea97893f3a639563047099fb6adaa5431116a578d5cd5c7d7c4d5779dc410c19245fba93be9adcbdf077651df61fbd1ed79a9a56c2c69b78e53c91f934d28fd521360e56119e97b7887aebd039a1e21a5c2ec871323732f3cf300856db42f5dd34c8449b3734bbd703bf0928d3835cfdf32f81e551db59db4faf32c6d04b2f366697702beff83a48f5aed3e5c4d237baf0e60b30eb7352cc25660538d03da5e902d4aa8a1424068824a413e42d98b4d593209fd3df74c78bd4898be35262fd22acf3d5f8dce0cdfbe1a383f37109d82c555481bbec1e61326583b5c5a2ffc34d9752798503e024544ced4e77f2d700db39d5a1b21a946bd277dd4d6acba05c0daa65473fcfbaf658fdba23e2c19c9c2ca1354b646c2582b312ffdda5a8958bce276fa1f7a5880106164f03bd8f348166c5ae308a6739772358ed6a1357d626804902eaba98cb65b47cc1148583833c9af653ad00816c3819a11f670d070f825c3437ad451b11d7c963a4a1a6cf309f0664c141380528ebe70b4f3ee61e63834ad52a3fce5c3b86ec99ce45cc81b91f85c24e0303324abdc8b8843bef75462dffba1fe4b931c9ba53635700bb1a85a6ff865b220675bd035e837c9c879352d12a6e737c27b121d4ac4ac3a1d03d228afa7380e3c6873f1fb96fcb8b103f2e4c30eb9fa62ee9061fc5a47f1ba7706acd639d1d359c0a772515fbf8905ed5db1c54e0512eedf66ca9282782078d6415c376303e2dcd81a1defb9464965bf38e512fc21c75685a07761fbe9b57f54d5c6f0c31d9fdb814016ab09bb0b09171c5c2e6575744810bb6f322724115c5197ee364b8ba6ee5b57e5dfe7ebd2e6500b68dbe625f958d2d09f685d7b173b570c4e8c5653b4dd26e0574554ab4ddd8f96f3b23365eb87a5df3fa6a2036e8dbfe31cbb7d4fe33c0ef6e3b0e3fe2f012f00c0d153f81cea12c034e6e2fdf98c5d27a7c997a1b3480d7dc4ebf62c1197b317e07307b1989d4a885a499437451db10423abaf8ba200576a40bb749dfcc76b78c75dea42aa60d951a072612dd28e7a1575bd8b564fcd456e65c2bfc135384cc79cccd3ac093a38165458d7b047e97d6e12f77f4165c890a1a38463ddc9a34f16923ffeae38c7aa66a9883ea438d9b88037e059a0dcf48008af67e9238dc1f6a0f6b534ceb872747653089a26d0cc2ab700eec9dddd2b729929baf2105cced7b09b87f734fabbc361c86131287995ce0bf47ea6843012b581ab62e67bb905234a2d3561d5a76a03ce8c808116d14d6b5b47b6fd2475d25557bc20a490b7a95309a9b02a3fb145b18ccf874e1b57e1743086039fa8dcbe785e3762d8785e10b090f5b4af29adf0ab4101490ec4f7c17c696c7c946b0c35720f0e0e9a7d6c85efd75588a16638c8679dc7a400cd785028930274d168cd51001584f4d8a74447fabbbf3e1e482c6fcb66e126094df10445aa2201c046e45a708ce71ea0b6e9ee768415de8e06d341a61bc3d3135d8f1cc6e672c94b7d8f45b163362fa3bb9eef70cbabae08bd928a41aa2a1221bebb7e2a98895716751f4e8f039a2dfe8781ae0c2d6284e04202cae7fbf4cb4d380ec92fc52d0e98794ec986ea18d35f857064781e23d8e02587a018ef1518ac501bbd67d5b51fdca3fcc5070ce66bdb6d9f85b3bf54bab83229bb11f70189d6254cf1a1dcacaaaecef5acd981d9a73b905a6f141e0c710bd6281d80f0827b0ab23b3c809484b44c2ae8293633e33097dc2aafcf5556b53ea90f7c9ac12a457241a20a6a88e5ff1be2b2fed24d674d78c1cd47770e9acceb6cb112e88e2f8f2ed818d06b1155b808af327c45f40aee3e38f16c17a392d8e083ab01291e02f5fe70dba12620cc7c16a6de0704367af6d75fbdc12c814c710d215d27da0d8bdd9dde6787970fb3f1ffc9e21c925aa5165c49b015c9df2bbf1d936f4c7582e60aca3e748717d6d2295de80f1ca666fa067cea3de6351c906f26bee0eb9044bbc24beb23864faedb7032cd9b0a821b74df64f0c1f903b6e915c8213a42effd5e19e91b92e741318edcd825ae26ba500f8210207008b1c001b9f6fd077c4ca92992d885e4aa76c72f043af13571388428b445773230d716bbb8d7fef34d08a56a03fe720b00a7bbe262c3447076d5ea66768663b9a19c8fe9d72e684f557d4a1cb41976cdfe7a2db93b8ca1e1a54958161a0d02a60aea9e9bf5f2d77cf5b2f93319c2d119408ce015a1fb3e283e3f5673197739eca9c5a98ce6855560ec8509f0d7c06d18cbe4eee6a07f67692dc3af07a81764857d628481efba964966b47f26a1272395afd0ae5c27ed3a7bb9dc6b7656bfca87dfed7a88ab0507b0582991f95f50a8c2c918c76ac1bf6cc8e5dd16023a4447621c9b99387e7723b72251ebba433fd5ad8e037889033ef532037d557b6585c3838a7a602fe6b7b8ee6ccba70ee3fb7f2ebeabc7a66538629ec4f417942ac55f8fc42c06d2dec1ba6cf3c11a04f6bd2aac076d7ab4e4c8d5f1149f9037eb32f6924d558ce60e73ef48cf660b17ea87d04f5277f6f8baa9ca77e068993462883d2c1baa4ac47dce0f49bf301cb622413edc30c2cd73e77cbba1010bacdac59a52b21302af12dd1a6b00195b75a2d8bae053e459266bbcf1cb45f2b43767dfac4d1e71825309eb834c1788b23fb767b427c137b51565efa15f6a473149fe5e96072cdaa1d4e2a4d5ef0908416f3b93395d6b1a76be13e6eb40773d6ed219c296716b26825fe13dd1c01b8b46a8a7ae9bc4c0dd599326a412d7767fadcd886af9e3aca2a5a4b91ef16d2cb3ba45dd3ca97a6a8f1083f4ddb6fae3af96ca0af79bdbf399ae30f8443b23b8391547de913f4bce07d043f00ef0522adf0728da674bc190f9e9f9b6ef13cc612e2a38c258e6381737104c71ce5599474f18b7c06421c4b90c88b9e2749c58533cc5a010ba74b259c0ab8afb7501ea4ca74b56ad7ea4ecb69b271531900ceaee56430db9e0d0a6a40358994bd91b631200c2333515e9435aa0f9b180ba3104e5ae01dc7b99e62e458b3cdb503c437572bf6f31aef4eecdebd99be4718925ae1e5d859207d3931610adc41e7a9747406c69e6da00ac64b25693a10d0385c11c13584f9c55c0329f3ae1a5fa4d53b2585baf59da885f24e3aa838b6c0c27700a60e2e56a051e0cac4906484230b2bc725e2f9fadc5d9e976045ce8a50acbd777bfddfbb057ba14da5a2b711c88a11918a10141ecc4e0eb3f0d46ba709a7a571b76338c519752ac440fea33aec58636266901282d3fa4709eaaa841b8ceeb31249fb8aa3c51bef0d1de161efde274371e5097c76d2ecf51dbb10656a0c1e89660fe6efc8006952915329dfe9aa9bf1ae22115718709a74b41251b6c0f1eb8a9ea4b386e8d85e232da97644562a9b6b774bb1a1052d12f7e4e7e0e0709c441900bb3e5c49a3660bc8c6176d10135b1928857654742998002c984636b0500522419441841054450889e0e40a5b427c474f2a9bd5aea5c2044780a575c6c7b78b56fbd77ed172878f2e9fa4b59e0f907e0b466a24456724ab67fb2c9ab76b0ac75d870fa75ceeb946725ba40ec1fed594d5fa37d52bd4d2fc5cb25ba2158c6d41201023966f10b26eb040e4c991bcd59ffb9746c4027861e1eb2a7b14230f93804efe1b92d951f441ee46b1709d5a6ae26c8c5bfc8e0852b40dde8df981acad2463da2cc2a4dca995d0a8c4e0038814e6f30c0e90d873c0d77e97fe0da59c2e1d20aa87d566dc1033c93ef234856cdf518680053df828ad05e914189c72d0c7910b1eadab72e1847025b982a2c4bb360eba8fc2f0f20388a33b17a5cccd2ff0db42fecc434ddd1ceb874814e59277f305bed7d8bb41bede57dc6f4feed8eb41d191a5dae8c7e9b361ced3b281473893867f998fb27f768efc7cc70cd4e88389bb850dd53ee9493ccd42f486d0f170f4f216335ca23e0bf65b97d172c03441974000276e53773a0e21604f5d6242aea6b5c0f70933b88f70493635e1bcd107f4d9dc343023be85c320cfda4d6e720b9e92131e9251d34976f6707fee83c305b479478f03bc240c8034b9e9ad71c61814c1a6fd4d56e84a0333dd5b155fff5821001d12a52aba8f79b5cde8eda552399191350caf0e452c1c2a5149cff1f4c017e3f3c57f52bf2513f9471dc7f0b3cfbd879f19ff875f0ac158536ba577f3eba042a2caae516f1f3909d23f0c75fb4d899b347c3d56df0dc357e2f0fcb59c63c2bac8ca41a2024a65bac58b5f96fa0d3b1517d208c36576889b4b5cd2c8dc7b33ee7991ae9cb1c5e94935f79c73256759b2f3ee5c48cb774ed9e6c6b60dfa695a84939e841bdeac0dcc160bdf0e20aebd139e2f71ac089455a0db16157b285f5e1ebea4147ed1b059b8f6abe87b123885c5fa0fe694f05f40441d3baea78889609c1f1e798f38d85b588a094983b82fab246c5663d95bec74decb9e32ee42bb9e0740c504b79801a738577902f3f7c2fbfa3d590559f8d8e90b469656b4cf013353c0ba6c0b799b27d807c0d84ae2b5015e920af37215c0624f022a47fe22588b59b8c772ca71daf414bf5ea3708af1c74b565c87ee9b801a3b5a8ff836182705bc61e0d7177205f0b96073cfd91895f10156ca9a2c6c1246746f5cbf6710d1e6433f784c9ce1146ef76b1c3e2db581e611f4924b32a791322c1eacc8859fd9ed57dbc1f7d451863af9336d45c6222db592f74824cf363a299d7fab7b2113aa1e87ee4110c2d7fc0391ae7e15014358c2cb108a136179b5a48f1f49341dfd34fd35d04623b8206c16fe93e94d24859eb78ae99029cf7fb862f7773aeb01233a75c415a38e1601af5085402287e2d4e909c0781f634986029803c91e9f2da6e5e370a17a3ba0b618010f774cb22664cede09ce8ea872fb3e8d7cdf809e42636ce7c3bc1636e94a1304810bdff3ae0852e602ca460cbce71a6a68a6e454cd727ab68a3c2240b41611eb55db4264a67d1afaf6c5e65d811813be55be586b48f7c1be7a5cadcda4cc4293867789f72a2e0bb11a79b87c5da8cd521857c09a9c4690902df0da309b2258da0a3fbab22ec3df69af05f47e324df7dfed6919fa8b44e1c8b1252f4d3f14b708c5651e823bce6941fb82691731816c9110d1513074bd88a8a8c0f1bdc20649436d6438b322b961c18871dd27e76428eb55d3d0590362782b6f98fb338c5e64f20a5359343e965f1aaaebce25478bb7abda3355154ff6a4b6224b97d65e892a72ca39619613357e45895fa3d7ba50d1edf39a013517e969c68b06bb4ee058b337ad24210085cb3eb47b3f7d7834f914aec3ed6fda7a9753d86fb5f61e59dfe2e2ba1d8a3ded0d51f8db9663dd373683590afcb177eecdaaeb4204abfdfbf3c1d234ac85a70fce212ad9d544d67d6a652152b991eefbb89d516a43b389d7747e7b9b820e633ca29bb07b789444bd5955ed74915471d10f520eb24dd2d9a5bd6fa61ce01c28b032762795152204553977c031e01ac2f11839f9f1f770bf316b7b1e991062a8a9fdc12016688bd44ebf8724a5d1f9d6551f9fca0eb1ec9fcbd06d415d7288efc6159347f34a7e769398bf149c6df2a9d289edc49858463684cde13d9d8f3a66691a9d6b8453ed3af52ffc3d603317ad57ad7ff27828b71605d33640b2ce41b3231a008c660b3b95268bc04266020af7ee17a905dec7a673992bb5269e4d0fadef25e1a9bd5304be40769e0559127d8c3a13ebf0b13fd1f2e50321184e35a6a5046064c6e29b1fceb6b5c2a62ba31ba8737256581b88e7385f2c6ce1a5b0c9237687e2521644257bc0c6688f220d077c2ae64ffec73917b8f0cec7d98a3d43d37bc9c66c76522405d9764f59936026f2ddd955acdb8f7bd72fd32f2c5b6f21cb033adc23000d38525534b51ff60c1e01f9d157627fb74ce99120732a1cd8182668047eec5bcffe378aa7db184299fbebdf9e07a8b89f5ea4ec166c82dcd64b46dc6c9ad4e204fa90ddf4847d3598d6a71c33521e75ac28a3b5b59158df70b142aa3ff813a465abb160167df61140b1e1aeaa638a0aa21f9ac0730f32bd5a34c2691062e00638df6f5314ca030842bb344f533e5a82422fb70a516484ca6d789dc28c48abf99be97c088548f0c1485294d399403b457981a6420c9d79afa5f4cd47d8fbbb1ddd9070340f1ebe372da660dda4ec90da9e8f4029fdf7b02d48d086a77f558a116202029b8df72e07b5f55b61e147aa48516d9435bbf27d27ec7efd5849ac999b04d63972ff552e6b5a3b59474bb6cc8f6928dcc447721c011eb78a4e3d663ed37750d17ea6a029a2ef7430c0d26031ace5324feade9712b5b2824e9ba86ea84e51b4eda8b71e32dbe101d0970e5920ea5e76e2924e4d72c5b494d3ad052b56541c93c35e016a3ef961b34eb05e41f46282cac71af5292ad9f29b99421f464773faba061f9b479cdfe41eeea5661d7cc3c62e8e04d19bb605d472410bbf30c7c51266f68a12ab26c57a3436f06fbcfcdbeab1462c84fc4d4e417e32e585281c6356725703e3c0e477378babd3bd385c0c4c56c355d2dadda05cc188602f011f02678ca51209067d9271740450e4493717a972d6ac36b4d716863e94a297764f45d89781149d5a5c991aac8f7be0ff382a8e794d8da8859efc616bb624b5692b39ba67ff9014a9e0f17350077b5916b25cb65de7cfe7462e3b5720f6f5445f629db3e7ebb183e6a425ddf1484622f0f4d15867198f787ecc49cda9266d7bc0e07e239cc44afa4de8e85c4a223e82270ca088c026c729a9f38a75c18034728898401c3e7ce1bb7867711011993ea61aa1fdf8d8bef7cf448bf6d68791c4cf26e68cf323f326e86193fce8eda35abce2650cf6e9311c460055aac112a3a4a4bb53c2a44a3a413927052c735ed25fb57acbf6201257723849dc6f51d1672923447e3ac88f297198a4a8aade97accdf98b186090605cb4dedd47e9ac66184a0e4d53b1c37c07c088b0b716c73fd2e880575871d2cb95e3b8111dc8e515667208e33777cb2d86c8a0458b525ce12c897d7be8334f077467f6d2fe01321902dc10d6877d5e9a102ded4a4c9076cb08b09b68b60bac4e22c7389aa59aa4d51882588723dc086a29e3c9faf860454944cef84551f0ba8f17f4582067b5d73cc8e9e460dae75364ae3e2f8b3400d009c775b841dbe0d3ac944bf503ec5df9a7286d1333b3366ba02dae9e6d8d584351da936217ddba999f3733d9db002d730c360217162ec6add125dc9dda98fd6567210b8cb588f949587d4fdcc54d7635f956e36f993916bacf36d32403e6b424142ec16f167075086ee777a0156fb58ca67d6b4f04c8ff3a428906fc5a2e0fa23e14ecfeea5e010440078d6bc229bea14069ffe111a7786e340a52bd25a6386ee64a930d45763f42c93ca48684e5b49ddda6adb1106f02792baaff0c66387826aa3f8cc9679b85715ab7a5a3d05d8f3bc14ed6401db67a6af8f878301db547f2cd24b0871c864fb4b991a99b250d2470abfa5e0c53a5f77e790886087b8886e550a390b72a5ad03f0099f743cae9b89702c28768c982cfc3761f4c2c257cbafb959820586a05dd2e6e91fbbb3eebfdd7027b5c49af68b0c30962eb8e5ced3a310e61f139edf0cfa74be717bb49ca236ad8b0f289a4de2ea405bfc546431f374836485ef705ac718bff83e2ff857937b5e54e2ac11566afad316321e8cdc1578a3c9e1fb12497c41ce7b262820a43bf36aa5d4cde93b7fea9e67b39bd98cbe23db04b056eddf5cfae9cf2fc146cf28afb5aa0f79bc191387cc7c0dbc259dd530d2f7ae842b73d1e87b1da83eeb62967449bbb8801e00864e214594bc7d7e3519acfc85db867cfe538193c38c288d5ecf52c5b428c038257a3988d0d01b3ee7fd0fe71dcb8875b1b6f2f103348638cd0754fdae175d92315bca2d897ce9825103b56ebcda94802ff0c7fed22922a534a2758df9f8e21fb37315ec17e928ab8d632b016e11416f5a0d3699a13739295dbe723a7b2c5a40357569c5cd6446de60b8ea2b7ab592ba4452c27e5133615d29a43d556879d8d5f0aa31f712fab1388bc75f4c42976cceb31c401b8c3fb5c3e140cab165d20c8f3b508c8096f342b84bf66207f47487e4163ca4dd32a11545b2ea2c17cba283532fe1ed915c3af3f00621dc92acfbd945b27164869aefc006145d819afd2200149a18900d36903335790b2d35c99fd622320a35c2b825e831c054e774de0f008f1430d1693ec77296f318584424a41bd1e6918dcd620ba4ea016dad54906bd487f0159fb41c7268c4edc951b16cfec63bfbd8f29f0d7a92f9874c2f28dd8cd263ee7ba9dd557dac23b50a1ecebf5694d0f26521fe2d2b3711e12d50423d4e5c8c8b7795e59b0c4cee817d79ff2b35e49c2eb3c3533f0a5ccf5b548d709abe3ae84f4671b8c6bab7abf63ba2511eec82cf78439ce10dcb800973c329cfe8b2ddd68ac28f9b3e406ad4eeda614d1eac76c96c738cd0bbbd4247d9eeb2bfb7c5256f8d367be6b79288989c7bc4a940b420d0d1858b062f3e8def572f838db9b7c6319a4bb8d37e2ab55d4530c2e35255fb3bb3aa1853073e4386e563dea0bc7307e1d0ba2991286deac63e9fbb730d369b537a58daae450bb6e96a1ca00cdf87a9ddaea7a9390eb496073806170ce55739490601feab5e6b09e09265f91e0b92ea673d26721b05572f01e291d9c47814ff512d4151683ecf10b74c21ec1d946b24d2369f8546ebd557cfebc54473fc32765d4962721572c84407f7128504753cd0e66415969e301dac7c987b6aa8bc820f98b6211f0946501b6fe3b7be27ba0f62fb6dfe0c5f80479851ff41187c395f104ed5816033467dbfa1a89b6f6504169ab9956cfc49709ccd26ee1356dc0f34084e2a5c9d64f322a3e0225c1d2c9fe97acc7c17800ff13d9bb08ea452db88568d95cb01884f72820b6e2a746f879edc6d66365aebd675d9f3b3c86788917957f6d67bc260758a0b67d155622c24d4f1242a3725271d0daad55d6b3fe90e62a43da344d26181ceaec182c2b156be3b16962ca604c4e3dea7cceaaf8269d5c34c4b14716694469ecbb2708e3176372e25a60700a8bf70edd6212d122bc7cd75b96eee029111ec76774ff7aca60cc9ec9bcca4812ad0dfb6e114d7b634bc0e178542f52c0b772bb339fdcfb2180429069ae5615354416893d777ec510e47a6fef237b9c5f7472547f7c7aace3a64bebdeac6a97c592ea7b060b7f96ef6fff9fd4a95b0c37fabc61fce489dec92530f7d40ad645754da29e70b9c67d01e2c71963ce7d46a1ca35cec699541c491232744230970b80c93333eae3748cb1411cbfcaaffe6a8d3932602bce2c7a7bf0aa055c28f609cd32e9836e81d1e6f182b7b4306b4db86c25a82ac4a46613f945cdfc888b81edae44f7c082bf07eacee292b40b60d6a735700cbbcee4edd59af1672d6a4d121ecc1dfa1ce2e717f9d7e682f5c38f4f54d0ef0594375df2c43ee694984953597c9c3a42f34fda17408a1c36cbdbe992a0350ed15af542786169f7861f105a9cf87d5defe4959b0f774984b4a754b3c07a320435cfd277e428d82e5c526b1ec54fafe043dd393604ca6ee9559c9898293e2e115219f12488cc5994a9a7409f6d9a9429883229670b29c86298f725a10ccdac753ea85f62c0ae6dc8bdf50e29bc48b3fee97c1f0e29de8fd46670943d5eeb95175bd36280aae7c9ec08c27191dcfa4f049a370c8fc68c16500c1b89a9240446275d6b2e1bb95382449a329ebaaa7e4f006518e97b92f458c72dba6e8777233ffcd92b449ee40235aecd3d442660c2e147e7636cc9a990746684a6a05a2549a33d8e18d8eac45b350ae11b68b9ef8b5a0d21c0acf3ad536a6b63e15fe27db8f5952effd22d9925aafc3ddf6f63624d4606f316cbb099e33489963b4cfa168becc10e48ba8d8c4128313386ca271f9862b765f0755d1f3f7ae487a99c4977e5fe2ff3df7c428fa3c7df098af39f9d51500cbd6ab9572ca4913aa537514e0c282eebb2102d89217f81bb8eda8ff57c84ca41d41936555dfdfc92e2b1d5cb3178481810b78d8313632991cca110f685c6d8a5aeda9a0866e8dda820a6e8c29595488de6b24cd0d6d64c8b7733a147b68d8d3d48b83beb2ffb48d6f917a8149e67b1dcb6ddfe24f35163ed07c9b20fffbab2aca0f1efeffd40bf2ed028afe20803f0e17374e901fcd5c82af8008e7831eea81faa48d82fd082c79687c9727826b7e8f2c0db57304645a04b6ad8a8a0f4e3d91d098df0544423f75e6db510c3f8311d604f128847fb25039f96b39d15c6fa1318842423eb07a9ce3b420539838173aa8d09f0849ffa24e6a00b665bae5e44f1b64880119e5309dee05e78c799833bf155feb2197a31f115253c65690e537181018f936ad5f2ca0b203a6a1cfc94eea234babef6585f502067ccbbcfe64a6c96b521a2347b1d0c280af3cde2bf5fdb5f67d39dc0ce75d6222feed773201c0ca8fb6fb37910e7f6483130d561ec2c785db81943d7745fb614fe5dc0bdc89e156a7e608643cbbf16ac7dae0f900ec85685d3bdb5b16556cadb7a5969098967dea83ceef2d4385d4f00b44dd23217a640f448387e562ce210693590dc7a20ebbf1d94a5313be6a8b41dd4bb6e81c442e52bbb0447dbbd02dfdf901026874833dd949cafd003d41a6d3c92429c5e23fbb28b60866300c06a58eaab3b97934b7d39bdf7ee952a250ba7467d6530e42b2cf207b8201fca8ce61b3448dc3942a8c6ef34c28a8e4135cba7ad664f1ef596c54d5e6c6b7d0aaf3808a4b5f20197ca7a1d703e7dee0f4ac09a60f959b04ac96d870b900d75860b44f546abdbab4dfeb1fe558dcb56c79d60420ccab6273efa09986461b2a09ae2ab8bab56145335f8d5b1c4cf7955c68b22d16b0247eec3e9742469cc665704f5d8d3ddd0f186004ab62618ea505a252033dacf64f33d54bdd85a8ff2f99e01faa2a34b12bdfff783c48f52373746caea3a1d2104009f32f600a0a42f701247d903d07d87c4e8d3b29dd4f6ac1bb862cf049d9187fc03a693c80a6eed3e61bd02b8123cebdf7378036c03a460dbaa19944583bb4463e862d09428b4982b8f9ee419fda7e7b6993c1fd6142b481e7161cec6cefdf06535af45f1e3e280debab1b89c338821357aecb289dd915f2689c99e20f32f893011a58a5f9012f04e7d000d2f5282f6676e65e31eb8ac711ff87faf0b56473311121f697e181173f6b829753afc4e133c84f7094b21ad2117a56ec6e273a15b7be82bd92adbc7edce80c9fd4579ab98d186b9e4935787eec9335de6a8390eac63966d1311a30381841852e93a997fd29f75ada2aa9655539e9dc164e37c686b7ae69358a2dbfc8c37aba3799bde05d68641d164c635ace5bb80a0c4d1053fa2571719e63d46e2bf5ea8006344ba80324cfe9b8382c83ff0f2081c1c5abd3d025d195b2bee252eaa2419dd25c49a462aea5d4aabc867bc2a80ca60273f5e82baa610fb279445f6217f18d2d9207123c05474a68812ef020b712e6bb07df196d5dd2f8a1d2295528b76e9515f21b7c44b74d04d62cc0cdf613b2f22c60377105280ad8b4ea344e9b6682b6cbe5ac50c476775d5f2f3499e56e1c6d828f443b74123808c168af513a2f9e18ee235569357418a259de8b8e465c7ac7a6415989776d51e3aeac52cacc3c977ce1d7f63684338ac77da68e42f77c2757bc8ddb46e0a1ed43a0022b31a68c2a316261ee0e40c684214715fceaa96621cf4d804b22d6c3cac8104e375a163439261210a2ab3256f94315dc9ffe8590930fd512428342040d300a1c3e16a113c096017984a2c5de7fee640eab568b8effd019f81075b24d3b4dda716c89cff7e21a379fe487a8d41d72c601963a6bb395e538a97ed5ef5f6628bd2d8197f6d5792a2ab6cf6ccf470c01cfac8c9eb10a82509c24b87b100ba027fb673528340ae4de623d98f408608e980b922426ca1231886f03ce918d0049610875d3028c5104125c67652200f62bb2911a41184237ae2737b06e770b16d5ee66878e541e9b5cfb56722872b3a566c4b270ee57fbff408fec837f37abfb2b35a776935f2618960dc04893433b82ef5464485482028693c4603a0cf9f0a04bc7046551f0d0ae6e6e86f14a95e80b6b00c2bb6dd7f64fc53706cad0af516cc4bb52e463c936c0883e5f6c24d454d4ccb88eb0f426930d2042c79c5d2560fa325766999d58052be3c83b790d6ad2eac0549b9ba90574b8edc4fb4d52297d0c83281a5d19355001482b9fdff56f8650f1ae2f3a6e5c71b16210e7318696afd8255e942edc2ee669f271ab2f8ca03491ff867c17b1792eb89e764ef9ea2b3e9168420f254a26877c95776ee59815a88ac5e60f989828039a69b68aedf3a3aae1ae1d1776bcb5a494b3c32c4202dccc02040b480431ea9c8de2166f77ff066873258ec1b471898f00e88c148be788b94c50edc0d39abf1516b155e4994c05e9c161db64360b056a490b620f12fc64a6a996bcfdcf8e47f1af07e9c0c31329f2728a090fc0062f7a3be26e3624e753c881dcd7446d818e9e03380e03dc76cfbf93cb25eaa8b72d9a2232f5d2371e06a8ff21aaf54313737f2e61a0e9f08e91d3dd57776513beb6b0437e6e9073c6c80c9f52c3c0aa488a4b07df34f67844135f12187ac4b64a8783db969906f5aa0501a678007a62f6da1f0e96d85bb07cd7993cbad4ec6d7e0e0cdf737f4f44931fc9f6be05c97441f549555d89df0ac6e5aa5c68594ccb451e52a85bc89f8a1c71c034f3ad92ced0422db7607cbcf8ea65065fd7634c3394da358d6ffdb2b927ddb33c9a9929f2688bf09f99de43eb8d10e7c75ea00d14bd85f7afe4bfbb4e5435c2efadf97d0445fe0cf94625bb2aa7fb6c1245aa391ec402ca1c847cb1375f06affef2c4bc504f46d770cc84d3280bda33cae9733c68027fad4a2faf82b3620a3fdc8da679c4bd786baf3280bec7b05ed7fb46113c77c4ac6aed787a4a6b46654b5feb35ab9e02f0a896b44337a41dd21fd8fc68338ec414655231c159e0a2b34dfff2956522df76e6b7b805cbdd9935aef2f61f5f90e7130322507f6ed5ab64aa4bbf8228dcb2094a42c331225b2687e0c6f655823cfe79f6605c830d811d99efb2be1b99039504ef4bb7dcd54ceb6a72ac88aa41c2f4ce228e776d24b9786f3519cc7b00b02858b19d44989d42b55b7fe4dd2d15f3ef825a1cb8c48a4035b8aba2979bf0360e0883569f851a09d0ad096d37c44eb87690320ec9e09c61554ce84ce3defd157cbe093e50ead56f2a8c8fcfd1be09f34d51ebc97ed04aaa327de4086db88037ec3ceaa21557cd2b50dcaeabe9e2aafb1420c379a703275b77315f7216919e0e9eb80b0b7c4182e9bfed79d6fdd213c97266c3786bd9d66dc9ad84de002959a0eff56e06646fe14b146031ee5bbf7d75ace20f286c0cedc8c74c20bd3c2cda3aecc2545c0b320a429086dc202d36e8b1af97dcc4f1e2f66868d6ba1c131f2cfa6f4c78b65f956f43d73b6f4be75bd1636eb306ec96befe8fb86ca2f0c79065ba866ec987e3d5114f1a354d437885b06f2451fa94006c1e1a227387e505b9e6534aa2d02df90cd2ba368bc61e394b25c9bb087ae00791c0e370de6ee452edda5a2a7af12e2a2b9560e06afe83201dfa8f81840a212935706b042f76a793ab1f36128f40f2ec20b127856a41bb297bea3c984406ac038bd6746db993cdcfd340de27e1b9fde6e7431ba68d9e59b4e26dbe83269c44a76c8fada007c325c07fafa68bc411eb5c9bfb0ff46d42b1b9def1dbeef97682382dbdd5b237ae8b1eac608b7b0c75426d1ba72bc4dd672ac8eb29309fc029bd633c8f51fda32a6fc4b5391d8c8d5d47a35107e4479fadbd4d00c2c41a7572862cde1f0224914ace1628816411457219ebd6125083dbfe4f4f0ebf80c3710db67d47ec04d8117d3b18c580cd3167e3d08aff1dba1eeed36cfab742e40ed897e995bdc59647141c0928051fe1b713ffaa6ba110baa4e0b893d9d80768099f217737451c03783f40a8907d25f6e04fb50a6a5fe693113f721d9c6e6fa38ee73595fe15ea419c35db334e76eec1dd96b45502ea6f9910e5eaa60ef995ab6890265f3bb5a9bfc53fe8d01c569ad23b3ce7754e92dadde630c157910de6cbafad8817ed55c3df06ccb2fe01eb1fa8942fabff209b536acbca0b5e2783ffe4e1482c64234d61ac25a3e8ab780efc3687cba5963d7347e3af899a35b2c03faceb0041fa0278118d276c0770ee38a11f066a9148ca2d53a48706fa049b2e39e6904b896015125ef5f1e524145b97dd7ccaddfe3acfd7550be6b2abdb9b32ed754711a1d7e94a55c97162bba413339a05267db865fb16fdfcbb744297256bff537d8e64c642fc5c528f3a757fcf291989859ca0e3a3f0335412988efd2881df2592b78f4c29d0252ca7853d4fd4a2958fc066dc1c88845a2b2a69404695edaab5f2f14894b90b607b95b1541d493c595fa2ff70f77ac089f2536c601fd34304242a5f0bbeecafa2448afd740facbc62ae1b943e295451ef481616ac397f1dd8e9a15eea79c740d15dbc3479cfb90d3d046bcd1cf4845bd57604bb877bb4b070c2ff3ec25f6c4e999d2f19cff432e1c55ea141f0d77766047bef883ebe9ba17c1add4893105c54b0f3da8d0258add34f83e3e6f6f30cbc5fa7425339bfeb02268a04ccde7d1c00c156b36397d361cc714fddce8ebeaa779b06f35452033665b021995818cea908815efb341128c60831454fe946a5a3449b0e9885253f987706bb9b3e3792f97efaa77b33e4cfd54c5422f10fb03800ff531c7bea53bb8a2ea59165a40703885f956367593bc4ebb2f26f9adcfc5cf8c9b9a4001f4e062e9f2194dff652f8f3bfd6836402ceab0a71b77c042675e52a3292c899f88f062b29749f2483c26d96e4e11b1124602e184556749cfa7079b7b95d1a6d0edf0367370c9e7f82ac80db7ddffe91efca5793d9a55aa6e33969e0395b65dde99ac424e61852ddca4b0aae01c4f97e44aecfa11119a50d12ccc8d30601d17f1f21b46766acc08d5e04068b12b243938f86be00acffd77b8b5ca594ef644dbe0b2958833e8e402d667f0ce3a816f13a857f5eeef1a06d2e709b2befc19d38d43073d84a6cc4ba1b688f9233f1704f07809f05dc475d333cc58c92c923eb7e8b0b8b65701bd273596bf1083a466478efc4e7945ca75ae3dfabc49ac95663ab5487331448fcd69da546e8bd4638cb98e3708ee297b5947efd645ab1ceba849e1854bce9458eb94051dd3af1809b3901d62ad3d089888c384f2c4c4a9d830599f96feccd986d73ce09bc590d022997369dff171842dea97cd9cd9c5ad3828cdd1b7e4cb2bc1a70e1954a81cd1cc43f88515bac5e702e35112436e9af279e748de3aa2b2193fef43d4d2ac2a9ad4b3bc0784744c4cd144f30c09cc8dd21af241ae6b3cd8208e68261d4a0eabc01dbae695bc5bda11708d02306ef599f29fa94b7289e6448bfd85d118a47ac62726cbe524b71ba2615af0d7880f19cc0c33ac94d48496d2e37c5f865824239e06b2dc4aa930f0d62d2e5852821b75052905188c7208097dff337caa64a35de8344b8b5a22074586be204f83d8d0aae039b3bde7847150b1da1384cd48a7b5b7eb9db6234cef7f04f9bb27ccd76dd2964a44c3c0ae8f75eb73f32a427e86c05aa18c22599642ff64277bbe2a0106d07b8341ef50652c70b2d4be7f8bb6084522a76458549e216c06589a3643d6fbed452c640c7604cc5610643938faa1f0957ecbb137dd8437d53289012bcef783cc6924ca5e18964207cf94096ef89096806cec02ad72c0136b6660dd2702162101d07188aa7ead976cd4ca661130332014c5994bfe4069823c25f79177b611646189a4bdf1fd16d79a81ae48bb52ad31a1d9b4f480b404ffece9fd0276caed4a98fef74985e0593dcde214f5d6b726ff71346e123f7bfc70420d2b27708d9c3aaf39760bcda7072231d54545246dfee9000691eaf53cd15903445e4a07814217e52fdb2a9554b8f5c7c90d82bd7551822b28064a5ac76da7b66d8b391e22a68a1af1354e563c8b1270bd16b635ce44244ffaaeb5d3d94bf2bdff201af062746290ddab4ff7e6de784a2291315e1fdd00c9f36968b178185efdbdf026bc830c634932f67371a71541dbc02d0b1f46c553ec22245585ea3450118561a41190841d6926c9f4e3f495ab524d5f7fcf1567324c4b8663f07c82aced4eb8a99a36ca5a4d97c2cf88487ab19154005f70e1e309c58c168a39ad03679a4d0f69952b186cedbbc2466ecb9d7fb982de332dfc84e8847142dd91d923f9b6155bbba5382281cb56bbde68f259cd1c98be29e1e49f4bdbb6d208c28de9d12ce2ddc67b50c466b7956435af26b7970de2ba4e60d4bd6b9a48b869aa98c8d254fd9a4b237d18d0f0900db4566fe647db128c041647ee258d0864d82b684568f48c7c75ba8f1cf77acde6871b15bf6cb83d3ade284f7800ec9869492db3962ded7a2dea2ee5bf4cb7265b3839a076ce1b2c98dba3cd211c5d885053917a72569381cfd90c1c59f6fe3e1a851585626e223939fa2d33efea2168be03bc686c25d8227bdd6fd8038e76367836df7daf298deb7a4c916a5fffde14a88b8c86368c603782ebaba1e9ef9794b1adf3518bb4e7aac3992630b9e714c372af4ee7b7ae765d387f70c1c850cc673d9cedd7ca71c9abd580b868fd58161bec87f79a028dfc21ae0d585f55471cd758ea2e2628f030b6d0485562f9df6a437eb39ebd5bcc2d6eb66c83295941e29cadff91d7b55047c6d1bd623204fd4c95e0ba63d03f095714532594280198bd25db5a09b94066bc239b661f53fab43651defdb661f576bd47e9cc66505aafdeff8b68405a4993de6dd60c7ffcf24bdd1b37166a1b5cac5ef5da762b5b184be4fad0ed9a13d62be97374f5c091e2631e83c6e00b1a74ca338944332c305bf7ca95abcaebbdf2c56de1f88fbf9523d8933cb17d64b697f5a555ab0b2f138b29f22b6925d8b64cf8613b981390ac301058a7762236fc0eb8f13b5b688ab8f56f6df2715b8c26f2c51071d391e01c1c1f58605d4ac1882c77b294956b289103e49472caf5a06caaa648efdf4ea6770ab8711f75b6929239506471d95baba66b59af0f624b9f334b23c3cd5299e119b3f134af0cd85ab1c06ab4edfb919aa3bd1c2448342fce7d7464a8714e64b9b577816b02caf224875dc57514072a9c7db5f207d97d850d89e9cf96128f280306df8473dfce0413eb5a9bb08e6bf50289cca4749c410471ff93996860cf1d20f60a08355f722a4352b5a25cef2749e5ca05ae19902ab306c04fb5d9b401446563bc3cef01853ee5384914461263543206e6a0caf075301bc7ad4524c64bb30150486b3d09070ee78340be52d6453125729829a16eb82b1a17b2101c389fb7b5f0a5a4c9c9f309a949c8177545a45a0586283beb10dac4b2b18f7e2d86199ffe4776a50b5a4eff8f5f4975cf948821f3c57aded0782002e965c4d0224994e0ef0a23bdc5759f2d2c6174977caeeebc125605bfca16b3731e1ab452dd977e5b74e435ecdd486a3d9d9db6e1546044d4fd37731a5500949f33d42a6abadb72fb0609f9a3f2a3033a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
