<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9dfd5c945a6cdde44596455a11fc6cdc83a04601ddb4492170f6376a9848d28a48ccda93904d9d967d26742b3ee0d9ffad75323bf384d30ffd2a262d0d79c214bb9f10e161750e756127f3e834e1eb226b55005d5bc7ae5717ea7c38797e176c604ddaf823d9c1eb25f2f37b6b115e0d90108aec91e9176159bb249e7e6a119a58a1e0c539e274e5edd70333823c7af9c24cf3c0090fa2388a15e01d58992096705376e33562edc3e29f8734c39492b0f30e3e2684e41f978aa59009d5b93d31aa0847ae894f1ba510975925c69bff5b59a995bb31e6d7e4facf565cdb4bef9ce2e0028c9118a5b50c69ec20bcb5e4de2862991838ae27b13d9e48939a5d4906f3d499837fcbe441a4e0456eb39a2dbe96a245f036572c6b4b0b9f40496921aaf0b6bf807e10902e6aa4ae72524a5e80876fa51652b63d9be5d5268a83e7229cfdf7f7b000ed4d6e43f6e4d071314b84ab6695f74fc5387cec69b3bc663eba2b86530b76442f4f932d21ced184f3bca651ac64e5e5bb40a24648666187c51060aebc07de76a87d9d7d30e9b9887665d2b48b2b5fee5af89ab912214584cd391857d9174488d11b8c656e22e6686e5dab2a37b42c327484b8531938d0e270829b0a23fd666b0853cca4bc307c0b415965a7a7a857740ee04b9f077492f193e99e172a081e65a357a1f5bb7ba0838a41f800eeabe20c605fcb75d2983953975959d6435eff81e662c4989e88ff0f6d177579daba53a3fbbae0fded10630f9acb2ad7b8e7cb50439d0de62e333ce06eaeb3ec9e745628154d7e7e0f41e5c6f16382faff7b3917b78509f573aab8936675894183fbf0f77dc199e35c25480ab474674ea14b2b608e58d154e9d67e36197410af1f3f67b40b64cddd5a4b9e7d2c8a067fffdc1409e43a75456b3aecb11258faaeef0d6ac4876f1819dc66539ad9cc4d41fc4f11bc0fe7a7dc233ddcd8db9f585300bf58166971e9df6500aec10a3092c1a2bd1188189853158c5d9843c794b5f2a1224f4c7b7fef0e53eadab5f2ac36a466a8967ae5f12963b88ba3862485da563c671162488d50944ed937f6ede6f5510a3e0d8534c906343f9ced193759d6f83765168ec52a0d0a7128ab2f4c87964d3b4d7a9a7177b05ddbd9f5ae28378b49fdc33e63a37d5c093f22adb3279cc32b8459f1f0f3f5628b681ce461e348661b22ffe760c1b8f935733f47acc26085d55872cb1e16f34251da22db4e9c8a3ebd89025a9516f65f21fc37860408e493f0b9d71464854f18c29f92dc83f0f44924d37ad6ad9ecacda8f756ee9ff6211e8dace3506a6584cd53ccf64f75e074a26f87e5784611567de9ff1c88648023e3e8ce0c1e0f417bdef03ccfce8341066bb53da18d242d85f89cce29592f3616c54d2de7cb46a992fc7010606ed04a92a17accaa3454b2ff8225944ecd69709c60813072e744bdc5ce9ea562750a8ff10c97a212d344a316f53dbec78dbbab2d62660c5cd9d5ce7ae42bf5b6a1b22aa7f13ab5ca7b26f5e5941252813325f78b72e8e905c1ff96c1ea4003f90f4b0f6ffbc35ec5e19b6cb8cfedb3fc08ef97853dd0e510e19e0b3f9d7247e21193b1c8d729f6cfea32cb1633d6f1e7c619a6d875fad45be0ea98c391dffaf46d4a5c1afd670579d64e2227c584b19ce3bfaaabb81d4fef97d1a0f65843f58ede4d12fadd276eab36bfc06e504bb1d54d9e24bc968f7690e8421d00d1d71a0d7f31705554109a5ce647fb5d210237115797025c53fd50ec0479e8380e7edfbdafd8d35d16c59edb2ef2cce6098724ff4f9159f1406cad02faf66d7a3cf660f7defbef835d42599cf89865c012b98a317603babfb4cce2dbe3d80b781c7608ba97fc830b577852ea1652cab587463aa0fa3fa1f4b8670ecd060ef1e09b316b1817981e8b45a002dfc3458839744f266e6070f630f4db956352a6a791d82a4c8699f79213f7dac0a793413cc4954ba52210510b425d36c97c34be5e43dfdf6487d8dabc985e50bf14eeb5fba6ae3850bfcca10490174d8a99b8384bef92901bad5c4cd27042810ef232407687aac9163682247f68127ba527c591f5e4648d60315e17b5b57126a0672e21425f19f04323bf8b416e3570d9327e9434e31f9ac452350d9949ef0057a7584622f3c7ee80968c719e2feb4344e8a861067349274516f664275bc0dcfaaeeb00aed0d90311a2aa2afbc76fdfcde03fdcb4f81edf362440c2213bef68308f9e53a920754e8aecba2b6497180c361eba06d61e1d169053a03a3f830e57d09f9e4f8f0bfdd396c841b00f31e538b271b0aa71bd3ce8e918cfdc01594759909385559d76e4fe8667ff6032d7a88cf9d7251cd31488817347bf5c164e395b59476af9c3b9ae696bfa3c67c67fee16cbc38f0a211315ecd0db66087153a41cbb1774914e566a6b80957991f7e15a1d99e1b00cae2e3d3c961743da238ec87ae4ef4243209daa43730c0b463aedbf08aa112206a2b4dff64d163e30a058548116c4ad11171cdc1cdb6d15d47dff77ed95a8e8b9a86691e7dddba3888e8058b7d5f62736553ef36dcdf7ff66def09b1c322f21bee58d2b7d0a23abad3563e1efc354b146bf3e2133e995f433f81bc0569590e9993e1fcd60813d3c9aa33e00a70c85b9c1576383233b78c15cc4412f46d497c003bcfdb534a7837c99946a3fc246202ecf3d4b2beea2e92227a230c3b96eb0b99856da253e45cf502dd48078a34a67a30124d1b48a0ba7570e8288e78895da6a550dc06eccbaacfb7d893487a4b7759683992223109b55e6f87ea7ca4182b9e17bd963c812977dd01ac18f236de1b505090352ab5289e832010f3ae9f83d1b307679faf31f85fa5dcfb44b6d22bab92f28fdb372a119dbe9dd9c253eea0b63204597e6c3776372144972d5682bd2d013dade17d62aa95b60938a68fc3904c2985b8050b7f53bd9c28bd1fe3845cdbd5a450ffaa6f8fe0150c8efe29f14c87a98086269ac8cecf3344f44f50732ff926f03a6b8adc34fa556d09a84b2d44825270dd1176ce93358472541fa93af06495a975e31157a8e3db45d8b2940b5a4eb92b618b4939bfa12006d07fdfea87d32dbe7e975f1ceb0cbe8e705488f8594c60ecb2f0c1f47f63613b0b56b28a58d578007b415456554b88d0edcab6588479b4c3bf1d735dc86a71135506ad38849c6aa4873a48e7be0878bebf1484b8005a852996840d22243297251e3daf6eb67e21aad9e8f029228a2ca2eada2277e9295dcdb4607e23ce6c7c595f4ce2d04b66edb1b2c544681fb5fc45fe1c73e1b7adf02a94845247a3f947ac93c88c3a51d2256f03d647454145a6ad1e45efb220010211b70f5d21881c549926804482ea8d1c714e93022b40daa13da848287eff96e002b3d6f4c500d0d81527667c97593aa5e6bc824ee4f069ad4fb98c60c690caa1212203d1017afd719e5bce5323506030a6339e24a68a5434f2f55be7a6201d77b6d0580db3312cf2d6c1813afa5c338e45e093d91cd09b1fb4d89d79e805f904c0d7985b4ee2e7ee9826960fe38ca0510651fcb050bc68765ece96d74a542658901b53fea90e330f73afcc09db8a5a9f6f97d28d894549368bb253a536d34cf23ade2f9df24e73dcf7066f04b739240058bc6090d73930fe2fa2225f2d4448a03da714cd2a72b8b505648fcbc5fe74fa5102ac97207ae948bc4807f750599f70a6ef594c510c2a7c451f49fc66ae5f0650415d6aacb656b88d9b3b292836274bbe41f691ae261a0f7fd95cb6e58ad643fbd0778f3136be950ea70a032dc9831c7adaf4cfd7b82eab34ebdd6918c01ba7dd095ffb70998b08d1ad2b25518889a32161864a997786acbaf78540e9335de01918d48a984f09d8123bc0e669512a599e779166250b2cca4852d4961cadb9a0a01415b9b65727210a80806750e59bad1c8dc088f35342dedefcaab57074478e9e7901a5fded70e3846d0339432a9d03a1a54b76741917ebaaae1fe20ac4af868c07b0ab9632bc4afcb53913746a6802986ee8235af87a10daf08188eeb72d76f43e2fd6ac2133e8164240d2bd3dd9b7078dbb20217f0672ff4bab4933a08b5f80a6d15921a30506eea00d6dcc2d8bc39bdf13b93c390dbfc67e647dfd0e1a88704464baefa70a31459344a1f00ef029f8ec055a686b517308120dbc6dac6ee96e6f4409ee39ae71a02465629fb896d04c9fcc47c40725d0f1bc6190de501d24749741d676d5c3ebccae3c9c9f164eccb1f98cd2395afc885c3b8355e6321b4ba64bed96e4f29c68a2d0db73216a6256fd32ee9eae5eea81810c041cd5e46e7a22da8cd137fde5a1cf009ce7eb4e0e698a8508867563def67d793222948e4ce7baf102ab427710af06590d5c8a0426fff9d0644376f3527e04534a8583cff04edfe843add4f28d44639dd03eb59aa0f85ae2ca1b590cbe99ecd47f46ee5b1a7c6a509a5fe9483b7b674e6278573b9f39cf87f7f39fc455a72a6f7aa749cb1527f162e6b67823bed9fae5b62d2cbdaf2b8c29e6c26bc34e1623ee734d8f1570d577cbc33c101dd329ebbf917c583698fcbfb9ed2b494e63a646df53cf2b7a7582f1f881fb0685bcf62c192f1ab36209d2aa6f12dd6240c15e4424b59abf7f6de063c7206889dd9ed51620a4c2d3ae7a17e05b5a4623eb6c56ec507ab12e0989f279a4512d4639dc1d3dcd9df47ed8654a57f593a5abe796e3c456441b4d24a1d7de72bf89c4ab554f86532f1a8c30eef225a248d32dcbe5d18ccd6d7b8981cf1412a6f1431bd747782f6ad9c157d7b953614fc71a647a29bbf2ee375ca8639991875009391eb279e8c072a9d50320d6205369dc401b14fad54a98aa1df7f86f5bce5cce9c438d495174279de58302b5bc0e60fbd3fc3598050a253abb5bcf3f59e8d396cc9f0605b2d418e8b5a9bc42624651fb9ccac3e574b1bcf0633657baad20f6c3674ad075d64852cd5655abd7f6259ab6d69984f518cfe4a64d54f4ac60ac9c40aa09adf2dcd95dfe6fe2d64d1ad38ec70a4fa59f1668649bca93ff769b3b33dd3c17eae15bcf0191298677884bbd7754bf1428dc668ea263fbc7227e77e10ffc7cc5c145407f1121e2d25d17df1240f634d59bc1246bb23de17e63f9ba0d446b763b12f4695c5f5cc0ad9466e4fe165c0439c1d0aef29d0c73de078cffa1e874187a6b68cc3f4a79a610acf8f9588b150d906ad67f9f7bcdf36e55183745d89135473abef93746e6fdb6472beaa04eff85a5e4c5fec99f001f71114adea6b220b2554be762628b4d3641ac6749b4a3516436a0a239155f9439c535e53fe7bf4f8da22d3b4e6df0ed6377ff33fb67124682ed3ebb4da04b04dba054474369332453f7fe6023cdd52cd3b93bdb66e1734947f1312a266daef306878e92d6ffc361e4000e05f0ae618f03af9fe6c454962fc23c086b902ae1272ec759b0ae6c2ccd1ecc5d5a288ff159fdd42d6208f0deb367791d59253b25c51ac27bd4ce4cdf2ae9161d159fd2a3957def3b62d8a3f2c27eb088397b764887ee14525716495049f4f7b11cfb5caceed9ff267a6934c78b45a39780cdf5c5cf83138ad8e3594e0f263b4e8d9fb964134c68d8996cb80e00c865368855779bb93f0c1c844fd8316b90138a9cbd9533fdf455161ff09b10cec8bcb8f8ffc8916ac45015dbcbfd84038bf55cea3943ea888a50ebcd7c93f734a9de64e8b11988e036fa62b9a86790efb4880386961b501ac59812b7b1e1dc542b97d1c96e68f9c0758ad018bd23e90cab6193c4c20d47713437a9c5c99385a3d862ec28f99b187541fb439896897d461c375e6eb7286ee88694f8488a3157c0a0e6e10ab3c23f43ecdbc8ca992aa5a196107fe5beb4c5a2298608d0f320982f79e30ce25548b6bb8004568fde2f0ce6ae942efe87df9161fb23a8084c68b376e9ee9b7bccaf17f11b65eb66a24f43061505822fa36f203277d81cea6f28d886b652c62970cbaa9aed757641351d66ba753cfc3cd12c900789d874bac8311e2bd97bfea17287ca67666a2195881088b0ea67ce2565a43cc21c4de264401e8fd99251f7b31f69e1048c3ca95e9162163846d848e71976917cf39f63214b3eb55905110998db2a6dd253c12ab1685d01334b6aa0c4b0fb795400b0863d3202843afd46fb6882c3b48d166c38cc26e324703b4cf103bf722ae4df25b71c8aebebba621884bece5999fa3b18375b0f321fb578b463a9777825eedc474b5d52f0ee6c6d2b1d3e09c959289e7a8176bb7c225d949a391a3b8b27ed407e8114cfbf6a25b7bf6021b6b6edd218d028e89c5b64dbbf70f7854c467284df8a2e805c8558e968dee86701d119b15717a99701e10c28b2d3b2c2e849834d285b8b2a1e41d469f779fa2567a82acae0dc1c1d4979e55b23f1c2f090581dfe0edb74ecf87d9f66dda9da7781be9f8474b8591e6081f54ea197b00f5fab133a5cade8aa6860403e01b46a23ef560d8305aafdce4834d45ecb255c0da63560cddfb01c7fb3c5bfe8e52a7eb427a87b4fa114407e38b8959b961c07f3c13d813db7e4e07864ef5d57235ad89e94ac411834ca1f11a60b3c74c5cf7ec26d3920817b312f1cfda04e85f0628926018e33a1a78caa798480e3df2a34a608b05c705b7fc104efea724f69ce1114bc4108838967ce6fedc9d97659b15508045e6853343390e32b10929a2119cd987149e01703227d534867d8b6691e35163ff21301a9114b73e65d1d66a27bdba0d9002623e18a295dab418bd7de1490e24f437dcebb03201c47d75f7a226ad7563ebe4bc657d40b134218a911ca75c86ef1d73e66bddf8fcb324bd8b5244a48314a5bc7771020c6526e3e8f0b19b6bd1f3a7f8334c605c152a201cc16863094ee419b9d211bb33257a48b3ecfdb82905e6956f040334d6939390fece4adfed236e0e87360cc075228d6683f22dee3d946fe81c2d8fe31bd06564d3d1f84813b8cc6c298311ae01babc0a6e63c42e3148c631cee2ddd573b3f5c81c77add5fdd530b2d85671d45596ac43d59ba9ff281141da56d85b37d3871360ca8d8851f4b547a5727d7afc2c704c12b9517da16f6cca15e3429bfd2ce071f7d5bf4b1a5fc78fcc0d1d3c4939e416282d1216fae8a4af06540bc266b2883b6a101690bcd855984404a15cf9884184a76bece22f461c620b7afb0055d7a0b71866f90c96ac551698122b253b97571e2f73696fe85ad7ca583cc46de1bad8a934e71b934c26eaddcff64fbc67674988da0da8aeed2d38979bf1ad5afa9e2fb29ee01cf9ad75f7051407255ec3ab6cc7902cc81aa751d1ae38a765d06acbf8c2263a2f80c33a169de790a8134e79c817d6f0c3696a83727d66ce8780c90e7b0b4e69ee838a592806a270c044d7c601e1b4bf58f733216ff14e272142f9dfec44521448472cbb08c0de5d52b38a8264ae8365022594cee9fa6317ed86eee4fc83eaab97bdfe6cf55eab50cd557dcc6e5b777f6f5eba9fa74dc1dd315ae9cdef2c6d7c09f15efc1778a45d23a6216f366a83cf2d0592b2e25908351954ac7797c61d12f5a7d62b58bfa973bdfc842b6600e285d19951a5537b31c88d68164e48f761af835c691eea858182e3324c757e6b18529c7edc01a59f98a0d13845fdd8b17b0041727ae0722d11ced1d0889bf1d9b160747c49052dc0c13211327acf32a4f00bb703f19fb284982c71bf324441d9670aeab212480f8625349a75bbcd575fb6d4ee859a17e48ad47b588893c6661a86c6e3a39eb2910e0a3088b9a1ed45a33ccda6bc262101a72af42ec40d5591b1503bb90885d6034a059dbd8c97758c6c5516adc2e51007046faae52eaefde508f6998f912db8fac2758e6733468a3cdc948b00bfecfc8fb954651d1dc79689c0759fe52f28416fdb23751bd2a1fb5cbaa6f0db68cd95e3232e1cf6d28dc0d4348deef8ff8b975627769100ff6c92b3b4f31d55e0307daf60db53b825881dc124571f0e8e2fb285b9c5507a0abdb38f1eca524585dfad9a580bbf3a9f6e3df3d6b1ed4bd67fbd65b56fbcea774a5c7a27539fc1667d9f8ca695109cbb8ac5e37861b24f881fbe975e9c4132ac0caf78872dab5fd77cceccf21c08672268d4776b84f9dcf1314d4918802526f14a3d22239452ab6469e5a1e8c753f004bfce415a771d38e0cbaefc00e14aaee0fa0d5c29b9bca7196b176af6c93c39b9b018cb09b8d13f494f2897be7ca91ec5712c4283cdd76ecd9c716ebe30acb2118aaeb114c3bb51606016a9b2bbb3466be97b6d82b3922cc757b209fff4d2ecf361d6263769407c14455c96676ef5f8d220c3895dcc037687717eeb3844c5c9d2782cc5fdf0f889160c6a9d91d81ba36bd85ae49ceba5242f6971507ad6517a80c6b3ec7e453ec7f4e1e75f9f939fe6ff329ce6b698ffc88054899e49e3601be30d41a6b2cd0f767f3af210e391d0870495ced753b41760fdce0f083a6d90fe83d4126bf8efa496198faf9193c01ddc416128b8e2351cf2820ff01a6f3df9e1048e9440455757e3d80b0b94bc71d97a0b5c6bae2ce62e85fcc622318b4ad581d41cb70811c1af17e8c1e3a4c83baed59b0248c7602a32f5b19f4bf0bfea2bbe708ff822eeef40e489da4f0b9f9b6704d122d9255b1a0f56ffa759aba72aeb5348aac74027f70b3305c5ba6772b67634ac595871e1344d82c67d52bfa64d1c1445703ce81d1e2dc5fade8483b1b26afcec3d71d4541a19943558148584ee4aaee4d508908db7a2f8a533b760b92423bf1ba755f77bc807cef864f543afe2456a9eecd4c3fbbfc2d56989c242c218a1db9fb5595a22094ebad5c220086706aedd0c282d1a0e29519c4cc4415fbcb5de016352be0ae44d2eb711542aa25003da8a688c5f7e4ed0cc81bce1f4dd6ca456f1aeddc890b4c6140f51e7fed8753bdbe5681ebe83a5cd61c0f9598ea574c3564eaaf1d4db0306782a0c7c4d358892f4d535e945b40374dafd324f7291808f701e0c1d7c07caaab8537e3574eea0841b91c0d5602d1ef00c60a4e95a3b8e4696ea99cb3ed9401366d54a696184e77b364bf25af7d2370fb5697c78cc89678fe55acd9b991e6376bbbed1a51663ba5e328f1619456a9e5cb4a02858ee24c15dc9d40641f32c311569c984b2609881e6acd8774bf4f410b9714ab4e7f0ec13e379fdcbc15bf9ec58cd29546f4ceef7ddf2bccd56e189a23ccf6ac2b4394414affc930f9f9a320a8eb8a082b5bd515d6d82771cba2fc6e0c50b3ceaac84b6add712b0bfa0d6ee9ac126b973cfbef004110df639d6f19c77398cbb919c20d370925d7dd67145a133c6339cce84ee00f46948d052b3727a79bea57049ba8977905e063d5b5fb0e94268cc3e760e2d91dd60ea2bc156f03bf3ea90d28c422b95e6c325d8496ac0c895d6318b96e5c7ec939484c7b9665fe7d9458bd4f53ef5eea5476773075f5015e55924df00729fe6e1325ba2f846b64c6b1019edb14efb3cc3c4a2f2a299b22799203794b71cb6106c28875c92b56e308246fff8607b49fd9a92d44403b1d0c39cd558e85103efeb81383ab7199380b65cbb859336591008b569eac582317ae69610343d2aeb8a5f1401a876b12868abadaa00a81a7426585c3b41f1c999d279f8a1c898a4bbe74cd24ebf56ee75c8197317b7dff82a1c72c9c22292bd0930844f78189db53f200def0cf343ea58efc5249378416a7c9de1a0cf9ef3f44824a84dc0a4cfdd9df27f9ab2121b21584ab5cf671fb8a09dc64495a32287884fc153e2813e90cbfa59d49239dd9ad6b8b6a31e615c45453b11f5fa0ff347afcdc0bbeb86ea4a260503f6d16701d9931e9ec79baff5eccd437855ed751ec5eed14d6fa7e7ffd7c31d588332d139503eb897c5f057891ca079cc4b7da40b174dda72275a74c7d9dca2d3d15959367ae1452df0f6d62f22225c0d534bf3c656f1675dc3dd842e83a1c3fa5ca6155a48327d895220dae1a7cb3156de55195eed9ec9934735c9fb73973b19f491526231fc78915d95b8b3162681ee002f3099ce9282321d720d4ccd16c3d0f5aebb15e877a6cfc6805b6e970c9aaaafc401dbe767196a2c9147a4b5db12118fc1479b13d0aa7a5dffa01653ee2d44156faf511b027da81f50b8398fff2f0e687dbe99bdb11ab2661902ef3f85f8098dc4ba2934ab70b01d1c3424989233929d158ad8822d6bfaeb85ede615fb1fd3fad439391630a63c5a706d6a844d6cc461be5e8c7a26019524d080f6e2ac0f9dee266d585b946f94bed84674eaf04f4b80289d9d5e522a81b16b22a8fd192f490557d1a64acc1d180b82d1294d2034ae36ec1aec4ea4a9c790f451ef7078877c039973ded3fb4b7a41235b5bdb1ad5978cc85cde151b7a9b00922f54a2ab227cfdbdcc3995fca3858127b67f636a031c39e43bb353539caac8ffc8aad444976fd20a68c12db468a6d61d0d884d71f4aa591a147029c1d4eb92d8db02a0a978fc0a08ce34537b143166344a313a6b4d10827107a1551caf1a834f13a559c637491ee4104dc844a3f11cb61fcac4884433bff8f510b9cc83bd87a6a1dc9e80f84b4dda5a7856714c0b7a87e73bc5a2da8f4d2954062b9d5a5cb5e606d3df70b602f252907554a1efb974ad41d15c1374fba32394e083861bc8455479a78c28bc0bb5971763bb3a6c789fed59a56c49334d3e641563dc32586fba45d0b4962453d608d71ca0013cdbc7e864ac50e150b24e12bff9a56f09bcc7452247106918f48eada1ecbf5672db84f0d4edf617c4516b168f71ae69e16fb5c3037825825308fdf6aa6c6293819fb33aa89d86ce543989af873a348897aec633bdf52d1c25048166e8b880fba008adb9b35e5f6a608986a1a24908c3aad0f0307af610968366ef320a0048d287f0a4e870fffbb7dab2c27347ca6dda74d11107167665e094cc1c618d100d78031f1fc478b8a606ec9e30c9b023a41bd29b37194835499b95a0cfce2191847dd46e393164ebb2911a5f47872b24513d477ca9ca92fff01c0cea23f9cb468b2a3969c29e9733db869a551a0a61291a963dd258bc1526d015cb0f1d5756306d8d7c079ba7b426e92e6b86209c6377b62a236699ecb0fb87921357e57f1d9c18cd2cd7e8582de21e3740ee764e900982df7c0b8fbb9b461f9d68071b4d2cc196bde2bcaf30d99a40975532bd72df93c462a73ddf93603b01a6fe3737f57a58e24200cbc435f8d4eb388131b483c0899dbf99f65da202cfa564f633eb0c5f103c59d416eca873667d9674b1b794637b2f9535c801c0d94abadd4ebaa8352162914d2765e0a8c399c22ae15f4b9a1aea8248659fc1af906c8990b2130ca3f4ffc6615a96aca0a370f078ac2542528e810cfe73349377e9d3f29382a3a7676004af19565008f57d3bed1ed6d4bfe141be657175c6969d342649cb4461ec93bf831b7e4fb27a8c7657d4c841d94e52863fdac8c330ad19ee6f4132b94555779f6e56e5e44633ef472c5b549799b784a73abe93a989bc2cbb10e41a957cb1b69abdbb9373abebfc365ae13419b96bd253f5b6e2c529b853e47ec82b62b29f931668cb4717bb9001f21d168e023a4d08735f78aa60875f5f725fc72975d6e532821ccb689d5e0a138698f04c02df386824f2e24e72ed5d1e9bc68154b4678d7a758a81ad9b43080cdb06da97c21d2c7f3dc555c3c82817d579ba3b7eb62583c9d76a80765e98617669ac7691755455788c69bdf12ad809dc83c9fbb01f3b03fdb490a4f4732911ad9bf13f733618da697b9e64986fde93b6b628dfe72ec295079c62644585a919d3a06a84eba18692c207ae6c99f566dd344b90df640d47541fc8fc036ba06dca1930cc47601d21a453496d3425a0ed37a0acfd5c97068912d0a23eb0ec93bdd4a79f30ab1fd772d37b6e542baa116472d2c355eba74cc286e97c5d23c5819768769606d72120bd9a4515b7bcf23a659f59dbad32244167382b7fcc3fb85be4f8a064c4ec8727628a0a1eb9342347c258f88f631691de4cd04c477f50e7e737df2a8c7e9bf40dda3d260ea4b7f57bf721f5a14d56077276d92976eedb4528abbdf8500dbae44b18677d4f6e463e25cc9e38b7e3417ec51a4380f3fbf29fda283633d23e6597d0d3a7db4cb59e8a2d92fcc41de6c72197554e28c7e3495ae836f0fc4d0f222ba87aa6a008f726601a43f6a219c501d29e516bcd2aeb45cda994e2eea1de07aeaf0ce368996b2b99429b9503e56eeed1f2d62519fee739d5503f5413378341fedc32e8e66b5083e3989ebfa047e830520f721fde82b3046495708c48efd47c617ee2bc2857cbbd69730f9fa90b82ab44de56eb93480ab8a2311af8932feb7c59e00752aaaf81835754faa7f0bf3d2ba88b1fe121ce7e298522bd3b5e78a6e257db9940932c43df314dfde9c73469c0a80c6668d74f528af9b34157e8a7d1684139530f07517d3ce0ee4c72a2f5e239b8ad4e82adc22d79897f0ee1f25e56047a975f53b1c7cf5e48cc0e043258482e5e588e0a78a21ad9bfa7d4267f5425252733cc220ccafad72f0ef8d9b24e9471cf64e2a86ac8a10f361722106d846e44c2d3438b98e0a096b0904813a572227358e87a36f1ab17af987664417d5a0837dd9b99335a3017c76d48522ab311bfe5cc18f64dc013d24e1a57065011fa84a62b14f003b8750eb6619685fafe87da2adcb8bcfe762a86055ca0228afddb9562ecfc19ca3479954f63072be8360d23174a1bc67468c511b6cc765cba835b0ef1c209ec673b11c1acc55220c30ec32485db4ee57af80faf5e3d8e9029c3c6991aeff17592aac439a202fcd790ace47d2390ae7e4aba337b8ffd43cc72e95787630894ca10d0fda7bf27d1ac0472a05b12086b1a817240ccf7cd99008c1663c5c415e07746bc7cfee28128917fa2c5a332be0f8154ba307aaa74d5a52dfa1737e5f790dae2ffe9ea803ce696120de9ac89040783298f085c9b129b45214a0d8b9044c6dedd28b5bd4a78b4d3e4e0ab02ddf7ade677c429839c50ebc9e09e295df761f2a145d1e4a7f731b84d1293aac5d164949e9e5baff997dcc2b7394ed5dcac8c28be477689c9964c389a8e6e1f15423cf6ce77484decd9e9ae5d728317dee992432c3f2de7cea8f81236bfe3f9ee8345afbcda31afefc62bffcfb43540b07e5c623d7af957d115d7da99f8930f54c5814d2383378d1cc6d89c95d830d44abe61cd327e1904e663199aea42b1854eea470246b25414d659cd39e27e9c771a9f197063bf21b63f7ba65bbb36383a288c60d09791dec240fab54a8bbfd58af127b11396dafa10caf99bfefe105fed2428c4ed55d9c2ede597f35431ab287b28721668a58ed36ed7b0fb695f6e83ca37a6f6241014dd1b21e25f09062b9d04d068dd5e7fe6e3c824d79b2a5f27a5786f49d4fac286f62506dc81b851bb79b0743f186a719a37ce0c44fefaef44b0b0d90cceec7406a3f2a648f20700fb14793e0a1d802e2a66eb8badd3d1486d4aa418bd9a9653a19cc6ec7d316a3ae5318552e59e86e090b95c2f3c108513462e5fc5d54a7f1360f4933de7eb1a67ab54630c40b905b4dfb572edc334d91df5800a04e180bda979b58fa4a3a48f1482f860d167eb4a794f1cf0aeead5a51adb47391aa961e7281193f01115aa20109005905be34d0d969818c81faea782413c097f87209ca35458e3e230a23fcbaa892868c2524eee2ac4d586455d8574bf7262d8c29e6c9a4c0b147873c9b970ae77d3a395b8eb299510b85e9455d2a6e13a1fc95727cc2f0679e1befd55a40d8c25b43f9ee1980f90402ec5d9d1791c59a9ca3d3b2b1a61eb0cbadadf89caf46a8252e3a68d51fa760a50ff129a132c1987b55ac79adeb67d79e1a5d805e773b4cb3da156f30fd6cfae155e8c7f066b71c1dab0f1c59c4144970c7615805cf797bb7323ceef6181f02cea40e11362433d94dd9dc54debc5675e04c8f5398434ffbaadeb323f13a528d8c23e8500a5093350136d7c5ae8116edace69e3d0f9b4c4966e37410143e0f1a9934cde6c3406ee0a9b9b020b2b9b1f5eee02a60408710a8f85b93a8688dbaa0cfc083bc963050e20d34e4d0bdfe6cd73ea240663524016f258b9ab323c378959e725dfe33f77481b60a56ef72f54814af1af1d0c4c0815309609bcb27d41d9291787b1ba073361f91a20f3392ed05a891e4b784dfebac3f632bc9402ceaa5d0a5ad0b647669a5e3691532fc848d40556a0376165c96d173c4c2b620999a357b05ee7709f4a2edaf90bc02c0a3bd25d39c9771e04c3187c607d2b6562f6a5dab33788b2e58b035999439dd9fcf0160cc40595957c3ba087982059afba57ff4426ebf4c9a1224304974178530011b211f34291cd6084c71bde3cc3bd7eb92c1d4e68f0228ef0d2408a53d6001b206431560e467fc6d324d0278efd877d086a1ab2dc3304f15ca0cd3f6a46bc84524c7793c0b66af27efe69e37b19ee0f58c6e97dec9e063ade8176337742e4f02af80271fd7e484d1d9866bd59893d23aaac1e0fbdf95e4df4c3abbda0f9d4dee567b50560612f21398593f5f13888aa681776343d2d540933caaf0599c5730d09a2bfcf4ce12badd435a28e1b6344090f4eff019a5297fc073d543c7223328ef9517da47751c422e5784865262de4ee2428419c07b8170a33e64e854352d24034b07acb09a03f320479849aaf82a3078c3fc83ca79bd055c7db7fa721fa2aff315ecd2e92eab3389309212985a3261fe990d152530ebd6668f252bd727a46e12a1ad2baaaa6973c2f70ee4b06f763a2eff8e9639993b950d6a1503ee9ea472ff9e75cc526b9060cb468509e2ddb32659faa79d3aabbe2b595664382f96476c8323d335bc16a08254e00247c3c3c7382ca6ca063762803b6e468f845f512f18de14faa4fb118c748da70d56729a56c03027ddb1dd18d7f7195ec9a7ed0cf6255c9b90bb112711cfe234c2795fe364c1fdf48fbedc774aef828a8d5370e43196c382c0a4e629dbe892c355b33d08952068c3f3374255cdeed8a67b9455b52f38167e063532a8dadd5b12e15cc743298af19d0e1e8f9d1ac9a65b25cd8db72323fe392871bd15f43bdf4560452a1c9e6bb61fa3b5cd816c46c846f3f402faaa222ce5c5e7b04f54032075edcb6a9b5b52b7af82ee77aa0bb9ec5ed6212c46abb6956dd41e0c5de0a4782336d079ff5cf73760c0ad2b5060c55de71824153919e8ec4d6bc95449ce5ed02bec9bc3a2bbc090a160cea3ba19694e989b0011e48be8b27d2955e383ef993d44fa0cdb91a130ffc408a2e9c163f5bd72866bcde172917860f788c2a5680692a423f6effd99e502462b743b2c7076b83dc7c7a114c71517e7919ee1adee4ccfbdc7d48b17637aeb970264926f486342f65127019aa2cc5c76ed733d602d4b66676eb9547a440060c0558dd4b5df1b8484272ebf604f13df0ab81c10b11bcf08995a01e74a89dc5c653017262bd644e8beb5dfb28fbbb18943e2198f02709821aa1305f80f77e1667788fa70c14b1b86f44f0b17c36fdce9e9d104fab66ff3137da4f24b1bc6270266b28b9fd467958a914a753c8d7e6f11f5b258b76500222980f8f0a6fa81fb96da59cfbe925237c65aeabdc490932db004eb7e7db341962d6ecd93478fa62629da40bf00f1fbe1fb0058b7e14ba017571e11ac53c4f818d3a0d3e04ee4003c4b1eab6421b9099109a9147574b63dc325f2a49386a72d4a2c4a9d87b5146b1cc14048087beb315d0f77cf82e4535a4f9c167bafff061b3147423de1a977faecf93009e1afb87c043b32bfc1cbf6550a31408aee00b1a9780a0230e4e4537b330367a316177591a376ceeba420ac15d09480642bd294bc3c4171774fcd348dd5e3af0564149d5a7902b0a053d1cce9aa5c8cbef4551bffc7089cd71225932da7ee1f3cc2293dd874c693623cfb948415be289a819f17359cba69561964b6cca464a5fd8f6d726e9a710a5421eaa76cdeba0e13ed5ba71ebab5f241f7b344e4b38d59951eb020e149be919ffcd62a196987f26f2078548e11b3363b6377115cf6291e7f7f6dc1422cbeac27625573e8e6a5f2ac3eb3fe559f7554180028b98bf28b8fd6ceb6a7b8818ab66bed46318c47512385dadae8650f9467ab113d04a0e3d904f9bc954cb4e4d9b2627679e6466fabcd140a6e23c4c64f19fb36cacad05c94bf313638089ec6366c7d0fe1e632fdb0549bc2a7abe9dea39d4f587aaa6eeb18ae238d42b19bad57ced0d41fdf8dff6b2d27708db2b4bfb3b817970693a4136d87143a28b18e7221ea252c10e65de27396283bd250a3540c8e66b3d42a8fe034da534553c4a926a108fd4860622fe807615ea0a52905bf06024b8f7046e636292ae8efd97b8522827623f5440cf77976554be844a24b862d4136601374756c3f46a2b607b0d45876caa7422ac080a73aff0e03fd06827f66be46b3d48c775623e4a3f7636d4e802629d6681de8fa36236a8d6a4bd0f03e2bd1165dba126440ac8a82fa7435965579bae70c1c71a39dc164f1df99c513639687a97b754727a91068037825ef66ba265056bc33fd93cd77c72a14532ea540726b160234f28100e5125839d28521609ffcf83e0285f9fe8071dc0f2b63ebaa7213488d4984d88be6af10a58f85f07ee0d46f509ed583b4dcf84a7b95b4782cbcfab63215d356d473121ca019c195734f44b729e0fbec39e50612e05f20b41e14f53d7c3a792bb1df4a7c9da5b05616ed39dcf01f6f0c2c85d749cf380c9f47fffeabd7a2752cff6fa75bcc1e250d9a56545a009a8515447b81c80598f9a1101c88f5468ed6e946fac03cca84eb1c64ffb9289cdd1d40e8ea617675e4c1c99ee6a68fdf2189801aad91f4e56a4acedfd7c862e4c38f343c1a627083f2f1f76671d0eb2cc115c2b1c83cc54b140a40d7e5553bdd997a2a9d14ccef332d2542c1e82160bfdc906356f91d971d7bdea4e3f11e9717d32856c9a706a673fdf6cbfe505b1c63655141c373c35c6800707143d99b8688c1b2eb70d1c2c83c37380fee847e7a8f836e4c1b194365e5e49f1d459df5518d4caaf23480ea79281174ca76b87423581ed137e1eb277b1600fa4fe1243e83e2893a0c3eed2d8a94a987222a9e963384899040204fe6243dfd8ee80d100d68bfd04aa002aa6a02631a570757b8112b3932e0bf9499e91eb61475be221aab68fbe8f3d55960b2c1151ef78cdb39b227d67ead04d6742081561e73b9eeb8cf42d83ba963154fb509bbf024e5836e67d0aca705ed5023afd5ba9228eae9fac7fb7a09b81d989dd11e3edb72c99cc177584c3661fc9e234fd37cea69d2459825001bef662cd9dad30de10688a7b8946b6cb3924c8ff9b4c511c77b089f32c875244fb2fbe90a78f531f196764f19b0612fbb9d71807ae0d4507ef34bd86daf3ba3b9daab1ec47b2e376ac9906d8099b92b3ef08a2a5f1c2f5cd145acf051d97ab7805ed6b9548f7e26e1987fc11bf30623c4bb235678d03d7e43afb8c7d4cb1a0211febf7664b724422398738f709dde4936457c7f24ef363c03b941e423e20b01683f83899b98087c4f4dd6daf2aeff368e4295aea0055c2386008623375549e86db551a0ba059d722f556f25650318b375a8cc50cee397945deab33b423f239a5e4da490a31455f19653280af15a6ad54f75aa7b6a1dcf7c58dcd11b62791beb5a94b1f0b85ca4f6c960b2e9990d35ea5ef303ce8e76e80d0ed66469f43f9444c7c03dac6c46ad8ad59d4b4b64807604c6f8fd0c9f7fab494ccd4242c91e8cef9022191ec4032dc763daa685d7375d5a98a3dc8a9824b6b8d49420161a17d960f0787999f77e84312eacaf6054d4d5d7b1dd21dbb4d72fbab6587e4fee7e95c4abdcaae410ac788a06eeddbd8a36b3e9e538d7fdf05f71d98f318a1003b39d23f1a4bea443fa7fb1e1a799915bdb5674ee3cbda1b395630132cedd6b6e6ade7602145fbfaac7a736a89a6f1ae6d08ceefaf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
