<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"90da9edaebba00b86363b97a803ef4225be3c1d0c95167410f3dac85a0dc701cd6fa060d7e5b257dee314240b126b18acdb65e8a85cbf55e18d8867442ed0f53b9eeddd357da37f51adc5eb1ba394eda1b0e9601c8e902fa21ed032a747f5ef09e5edc83de99dbc013c9cf3846e4194da4076d528ac19cd851866052220ecdf22b78aafbb1982809ac78e00daecdc51e37aa450ffe11f43c9f033a421f6ec866b5352e8fb7a8f1f2843226f1d455df4e362e69437bb60443aee6599c6257a74e0474dc102d86639338e051ce6243a0812f3850082bf40110686d6d03de8c3375dbdb3b41e018924b10bbc735b2ffa1201c65838481b21184176f1717639b73d216764ef97b65f79576a4211a3a226ca9a4793e7ac32ca72a1d11ea2f4d28d622d12be90c4a5b5e0df6b163b59862bdb9f8d742c3af4de26406e29f714c7e1b916854263e14dba93a895b8a902988b169654af0a0beb5786ac15907358e14b2e8f8bd9c36097d4474129fae5a008d1a4a3cea34ea60b6fa052b08175b4445a3f3604810d5fcf30b13c7d614e37f9c30cd8e62c7d36b3e0df4f4cb125c8c5458781516fc6311d5f8a1a3dbb86f26b1262ccbc1b4b2db04ea5b26693183dd12cdf461ca2c83356c9ef41db7aad2b7194cfb2f47b03c3ce63c8cdab1ef6bea31279c4ceee26925f242108ae41493f00b10604eaff36f4d53f937ec16860555730dca19ffd0912483b27d408b89ddef9b298fd8b2cebbbb07e94e33e6100b16644426e66c33f26fc06189e536339983a7eff3c68c56b61f91bfcce3dbd60d71680e1d2a682a59b7df6a0d5fe1232c41aacd49ca671f65086d5a2994b4a607e5df43c177836085121b858626ade9e721771bc8ce825d3b260b8a70c7f0a95e226dd253e03273eda2fafb662e2048dcdd12d9c122d8a05a0792361e23056aa70067cdd778ef1667fe8073c0ba99dda75bbdd17c365aaa31e7b788aacef16817c9bb2ebeb2c77cc4a1bf5acd164af5704f9f04df973312a362cda5e5ce4123233659bc3084c81b8a22d21ef7a8072fd64b7e3a25776887c0365e4e4b45468ab39e702cf685932ca0364f4d7d0ee27db51aec46265d481d9cf4a4dce0123f00b28999425351a9fbebd42dffb6f8310974517fc61146660dc7d07d798d036be75044fc13fb42d8b5d6ae01e63a0500b813297ba69d261989f0b56eea0665a54c3feec7605d349cefc169e1342d474f7936f61ade571faff3859604489cfc4763e09badab5d1accbbd2f9ca36ae4afd8432d87dfa61a0251c776dfc2e7ad95d3444d6eb53d30e4b87a3d4edf23052c75c963874c604f8b4ccd16bf013a86a4e3a5f8df528606cb9259f95ffb2d4e363bbf8fcaeb0b61e1bb17d5a5a388e0350670d8405b12a4c900a874126b7bc55f135ab19f6828841faf2d1af983b509706b944a101078563a46c9932bab4e12bd78857487a444bc6f2df414ce3b27646115c2180823d2f3cb49fe9d39d671b80fca5356fc80ff96d6f8520d3d07a22cd1bed624524f540534252949e168d8d7a0b28f1264568e95bfa6d8066d081498f49e11359330982d8c988f762cdb68cb07b4488275bec5b93713ee5de9c6302d0213b22f75ab6e1bcdcd7b43fa9f2040d5c7cb7b05583fe5abbec22a45a42d1fe22e12305929b56a0a397472c330ae81ca71f471b67f3536fc876117d97a82740555fbb02a498f42b2a07873a95376ac4d8cfa5f822649d1308675dbb85b1e2272a3663be974e0090ec000ba88ee83c049d3aa052a9b89c4fbe73c17aaa1a2096118442be80e2a4422ed6163ef6d66e8c435ce84b88f046a7ed4bcafcff965b45ea2034e2c727dfe403b790f5dcbfd04c1cd3d62e2aad0e618e75f62f1f15c0849bc153e2edd501dc3c620c485dc8446a0776c5c5f999b0c6ea60411982fcfa185dfa7b3e0e98778f984adfcda37ec38dc73f17d6bcd0d19c923f2820f267b941b7c7fe9cc8e85d0b7ace0eebd7393a25430e07242557c8dc59dda0e5c47f436b1d39e60498b3fd075b9adc65e02dbcb906fb6c4b14b172ddb3da489518c068fab5968427b13d1cd8aa1be8cef1b352c0c3a7bbe46cfcc6fa7fd92d03d8dff01859643ba5727a278fed9b09bcbde4ce9611d7e32f48ce419013877acb64177246720a1dcfe729b15ffdb8ff57c6a1a472b5eee6417d9fa6ea24eace59c4f62be904178b6ba10a8bbca7a43a5a37249dc1ed2e0f5425d818f032a2aa13eb163b45e035d68f78321da818a95925110b26d819ee8b4d0df7ca20958fd40599b5b655f8743977b98816005e9b65e7b3d4aa04c06dc1705ec1bc488d6ef315b0b83a9883c269ac6e85c37adead3a821c4a79dd597c441568806888332e2d364c6d66c7cd7142db01b6e05a2f5859d297545196ad706fda9d5c4ae7ecfa8aedbd23b7f7f07efbdc52498cd33cb2024d8294ff528704f97b9d9f42e598bcbdb34f6891f8610ce52ad902d26c5adce4a8580fcc712ddce11fcfbc174493833c5cf0cd3796dbe7786bea3be52313b845089072d7e1f07a21267157a55aee490cc4b996ffc6ebeb50327950e504e9d536fee6723df16bdccb32524a9e76a353e748c81fdb3023cfc904d3ef9c7d40d63f98a4e577393f1ad6d23b9fc23dbdb2997470a18e426f0f20eca38238f84a7de5ab6324cefb16b08dfb194fffa6bdea9d256fa86e8c57fdbe66bcac71a51757e1ed775ac7a3aa6ee739549e95bb75a8205d32c2be7f3486e15a67716d456feb3fb1b42692acee7677b88b4a018fa3b64081e6b237b8e483d10c17a063ad7e14b1bd6cff82446ef782533bc3d3073959d9acc36f21222b5206444b0061b7162c188b8fc56cbed058f9c6d581fa6345d1268dfc72d3fc6c4c0d32e7f9028d6552e2aa41f0de30b6c8926b8b7647200121b5730e32b003564cee0552378f16cdf7283fd613b0eba5dffaa9adb834fb4ea04a57efe79da1ba43ac01912da788c37cf1205e1ed0d09aecbf0456bad971d57a29e9e27b6756a8d59ad7a6cae5bf1c825e06acbf6a5d3cb7f48a3111c6d801637408baed22403d9978c7ebb6f85f633165ae0559c85b8eaa06ef3209d4755a1919eac987b4a69b91ec354945d381a33e91df355c361905737b1eaac4a442772652cdde5e9d349c4e9f49a662a72e7176d5531dbe723d639e8ddf343b92a4a69066f0ee6d2d8b7f558019195f25c1d60e7c3cf3d273c9f311a66d17a7276711800b8d2963948218699e7a0889d7818688853ecf1b293568b34b24c151a46148fe1963765dd39738fbfe32827bedd32169f5df935c1a72bb7927c759a8098f11aa1f6154563e82012cf8a700d11c6bb4eac7572d84c4087ee0cb011ecb8ca13304ba26ca3b1001c5899ea973e41c99bb6752ccbbf8fb548786257b16cae363bc527eb28da4e4f7cc9693e001ca89d1dc35f4b2c62157aa7d20b2a20b2137e51b6d2dafbd54b386ff5d68639c37c35ad7ebeaa0510b9e8df5ad341a424316f0cbc0787ac32272e32689cbcf9640f7ae5a0774f33a35ac05b9f3f244533f04ede5d80207d39c4ccab22fdc70fab40faf3ca7f02bec5de3b5cfef78bb963dfe8901e397212b73586231adfbaea6f0f3ac5c25a0335f1b0eae874bee214532a1e75c3b84480e63ed3574250346dc76d1eba67e47b136c9cc6dfe4ee0e0e4a70255db4f0e795d6d107062a41ebbd291a2113a6e67b2b035cb981b256a6b8225c6619cf6513b1145d7f0bc5e4905303946a6134c93539462589f473117daff7f7ed9e32ad5a9f768609179525969a163df61458a30e9db92a720536a4098de685a0de14435e1fe8c7a643d7c4113144f4047d09cca677c5c82bc9c3b38c99eecc263c12910fe00611212bcd028cf06f821d93d07a8e252136d819d04dcfe3020fac248d40f157065c382d9fe87b4706fe79f9a0f4d8d3f943d58417927c5522d7fc0eaa75f73018d51e850ebc7ea83bf3614a46833889e52046737a807226c4cebc71fafdf6c837588167d6e6b776397176185665e7a05dfdba77829513b992559695d741eb6fefd82468dea1ede0f70888c1691c43de2e9ec4ed0f167f8fed402488d1be31c09919f12ab1ae1b47a0d98ccd49e45f7340f326f8e01aa9f9f01dd7e32334f1ff08fe136f657c0d50fb9d12eb4bec7593185314665e987069bb139dbc54f15516318456abbe3a41405d3224a5af23ee621f7c7b5d4df011f4738887169a7c3f4823fbb84ae2919e5dd50e3024802089d72c67855211e27b57638f92536cef8cf278deacd78c2887ffbd0f2b645df50757ae0e0529a042329db1a256fe6797020f13ee57a18db3ff43ac213e3d1e6a49d4988c85bd65f0ec1a5f317b390dc46c323dc537774c746241df68c66924207e7fc7ea1d52f7783b931edd15b314d95762b4fc48b1dbbcc8bab1fc09019e0ca4ac04e9fb0a6aa593d4530c94cdf14d9d07a76aa4d05d74160c2bb482b38f98552d18d12a891b6fa9766e83ec4807772ff39927042a664c92ed54ded1dab25e6e6941f870feca1d68770b65d5908b62916a185dd9a8ad99ff437dfc4285f3d9396c6a7fc31fa408e357fe1589fb4be29e0829ecb76ad0888213dd0182db94b16a593d2b01c66979bb00eddb3673efccc1d6e69f5930cc0f881b6f4d50b3820e8da1409ed94aaf1854f1de7b6fe704b21e6262154ce0ec2ed8b7a1c0ef19dd81e45b2ec427008331664d100b58ff8bef8a0ff7841054b9ac5b760dea6135e71b51a3843a96f0ec285258a1de1a8e6493d459ea5a26994d0dc040d48d4d478c2ab023fe521350a8bb3998e25b0e3342bcd240f7648332360d96c61441a003784ffafd900074b9c20eb8e2b6905c26b4f105a106fb51c6dbf08691adb48700492eaff2b797b3c14027602837bedabbbf418d97bb3bc019f80eb5e0a1c613d73bb2809867a475093470550163653c72afb66b33be6d07b08569bff86c66cfaf5e8541524e7ddc9ad7f72e6578f47e0795f2295d1d04f4241d44b300a36bd3ab142a4e9550597004517b877b5d77b807b5ebdedb4ad8f6f8d3c9d031521c75a96d844fcde6390273e32d3b54b991792fede52768c10619de9300fabc7f215fee25958c7055b42756d9ee333fbf4d39d04b70d0b4189917dee77313ed81cb9fae280fd10b8d03b369c7e569efe3201b661e69d95b713a32b5147a9c7d4f725c1aa85ca2359c6b46947970e47d876c657d177e4d32b844c884d7a8618e02e63b1bfe555e31a6ecd0f7f28527467863f86f8469da4d666c35ff698a05919daf48f9a9e99b919be7bc0cce06a8e3aacbe0b8c509c7600a0bdb8405d11a9d4965421498677fe58339ebeb114f096b6eeaa8114ff2583706a37e529be394252333cfa2bcd53ce0e3ac56f127dc893a20262118c9255380444f9a2bfe22ee0fb24758b4cd993907f41e4a78d4068edc049b2f9a784cc159ca7e209ac743edc00de9af647478c11aba62a08d14db55788cf5ce75bd05719b06cb5894fcdcd8cb99baf24a2a750204119df732b030e532c04294e33e11424fbf857340b03a9cfd371cadd4bf6e46f6fa5f7120b787755eb2ef0c8ef38d499cd3e4845dc19900a9915e46c1fbebc813f31697d03368aa8c72bb0f951d00d3b288573e6660b1dbf3775bc9b5ab737439f21a37b714b68b8c2c641f12f0ae5849d94b58e5b606169776db29184ade5b47adbed9c6e8f31e05b376947f73dd5048de63fbd04d40d6071d7eb9659fca7ea820adf822c9c5bd317a7baacac08a88537a06da25185cbba443c9d3aff73a03bf7854079ecc2836caceac35403dbf8affd524095f04abca335b1ab322cd860d8206fe019126764db75fa2e57e7453dc77c9a1046cc62a3ce9a496aabcd7a92af026ab6ace3d54986662d79f405c3d722c39f463273729085ddd5ceca19a2689020208a068a0dd8fe718974e305cdcc70c1e7fe77e7999d6a94509fada01fceee0ccb976e47f9aa679fe1b7b0370d9e0bafe98bf5832b566aa3347e5aaf83286aca7c5f95b20d16704d35faf3c2f6fea00257b0080d268cef61bba35ed20dc25778bf8fffff0d1a1b7cf15b426cb689ebbde85d360b68f7a2da37091d01fd4d9e0bdd41ac469318729196271799a54472a273de0b34f4ba80a7dd219cfb1635f1a90384ca62197630c977c5b591995b3b1b1dad8f9999804afc0741b411cc9e0507340769ebb9f734d7d654a88dd35f624009613739ef1d95949c4bf20c1c5f4edfe096f8107e957b608a107125a5c66d7d290769ea9cfa2c686245015bdc876197278624b5af27b1fedd3be0e4d53f59793e720f5ae28362d457cc4b1d2719435105c22cf5025a9941e7653ca187d2818e126153227be1dacadadb4586fd02e43111899ab20e08571e9a5a9b691e2be871df0f02ac19c55f18f5756de19811946e49345bdbf6cdc6a670db22e31a6355f3dda283166c40a5be09b2bf5c58f82c752ecd85e67cde46fa3c447bf9b98b8b47f4bb7fbb50bc6abb37113363dd9266e063d7fea1c12e489726d7c1c1753106264e02cad78016fdf46d4ec14b1a7a1fbf8f7dfa65328e058cb6cf1b04b6f665150e877ea3f485ad479f488c9cf3c0cd398f7bdde3bb2943e55c6cc91bc0a5f84bd98970d88c706fa5257dcabf431fe88afad03765870adf97dfc51bb0036b458f422fb59d4b4ba87fd676b6357e679f683e7c1bb39a5f804bb01f0ebed3a9e90ae4019e3e406590cc30df1f8094ff208c0aa3ca39bca3b4d5f297bd7e109605582bf4b7e43e9bc313d74870e6f1a0f45d4cf7f758902f5c85f1237aa36d510b34609c71c06634b9b42896c01f49f30ad3f4a56a5f5fc42ac94cc62fbb4970a7148c1839e370328cdf348ff501c25d63205632da1cb29ad0b0b3bb67f174142e2a024ca015f66fd03ea519cbc470df617ef73bddb4282956691b82ee6df7b210b67c8fd1f58b8aaf87a0f86fbe96c39d2fdaafc528b11b70c4f308cdd634815e2b1de348ff8423c16891cde38587130fb94d74794c1caf2136748d9d616b4e6011adc38493aefb29c3bda352702e7da3c873a86cf5a86b501551b9c324b7552dad4b98c59a0ba991f9761cd8cb2035098cb50de64e9e7e34e9bfd90df120e0462960f129516b86bf629945764a1d6af28aa810d7b235b221c44159720ed94da02221f6c8ed62903f2727df30b1c2f47cf085ec6860a6384fe61e31870cfeeeba607f54e903145a6678f6b05d6aedd829099074e56453371057066bc0c4761136664c9485a3c8b45646c54aaa585909b2385bfd310a48a9a6914e7f2c56f7af05e715bc0f46a4b3195dd884074f08ced555688663e6a65a21fc1d74e112cd3e2630b327cfecf5f1b7106bad505a3696407c3d487faa5909aa11be9fb5786860e8e071ebfd82ddcc562278a45582cc758fda238a64c619431dc7ad32c731018641ffed9b1b3d31e35579a0eb3a3bc9ba69d8c201bf2bbb335e1071cf49aa0f957cbab456599f54c3eb8d38fb44ef1815f60321a3b417a9bfac59602bbcf701ca96857d6ad4ef38b7f236a6cc9547fff896df0065cab558d704b65fb0b6a92b97134765fe057d38a0599a3cd177d039da404f0cd370ef2656837996d0011dfdf6e23eeaf14efa8c4c8bbbb6d884669e562c60b88d919d9397aed909ca7a910a89a8c32978a954891ee258c52562a5434df25371c7b4a0112913b3a877e656dea3898d8210d2fc3f952d6cd7b6eb460204168fbcfc9b80c02ed8dc044050afed60010b8f0d065e914efeb38de9f0592c3be9e217acabf0dbb405d787f8b05c2dedfb96a1386d9330104778574916184a5f08dea8dd863ca6fbe21795d3938d31e702b9f2ed3fd1dcea9c1410ee8d149ee1219773b657233af76634cf74cdcb010f6be9b6763b2dbd96eb4c7f794a28f06776798fc5c070f1e23aa00c55647b258f3b52ab36efcdc669bbd27afcbb68378ad60f4fced4fa937421a6bab0322a1abbbe290e1abf21aafbee4c2d254703c85409beb884e67c925bc4798395d82591f2948a09cb9e6eccc09c542138f6b517792b16af6ba10e30f0d4e1c0caf5ec2fc51084d97039df7d7ac24842c0df66b0a10d8dab008f4bd16d1d365b14e7951359e56ff42ae9aba51efda8904ca4fc439b6d51586dc3fb0700206dfa8b1c866387868949f85046f4ab812335777002b6458e466eb6d5c8aec33b4cc3a016ca9fac865acc27fc5c7db594577ae03ef0c8fa17c9e09829d5e96eb2fc6914ce3cc8689bbec987570937da4049280138f7ef7c1211eaa44761f6bde6c3d19b104766af8a5fc138bf3bb2df45471e8f54213a97ac3b4046b64e7025a2c3ada55048b454362656f9c229c5f6ea524b5436faa03f449cbda03b34142317af2238171dba9a873d2d693ccb4d895d818f008ae2ce45c253a31f915212be54dfb0c1a0d3df2ae96a45751019e8c52d6f7f59b5ff99bba09aaa568a7dd6299850c1315f5f2536ca7900ee2fe4d4c71d7f7ebcd16d2744b7d9754652bf931b6eac2ab9a65492ff241716836ea47e0a9f273ece0e543b7df65bb8ed3dce686c9b0a6445575ed0c146bb91e0067148e5f93c591808a1dbf71360290d77f2592a7f9c0a7c5eb02199aa1bfe9ebb4a2f1abf7583c903f32cb3dbf3396181f7d60ca83d39e0e852ff9d3c5baa423cf3b3b969e2cd9569d974e710e5a33d36043f1d13abc65d5af7878662133af1cdd218c90cc2e0aa2db42c17b87c6c9acf7ac14866a73bdead480cef24b21000f26d158a8d7eb501615877111ed9eda0dc38aa477fc35dafb132516f67892585b5a674aa833b76b20116cb3e84601d7ad189013096ea55af33f58d3bb725a42201b88351dfcf31ef0c972d0687385538607a4468bd0a98c9db9a5a4a0186cd9f66f5ca0db34db03ad5774062dafb3000c31ce911a12df86f39e8a9955d4ca4628b89d9f6fedb1aad9371ee7a262f651c7be1780d226c4cb6255ca42aa4b902eba1e69537eb6f950dc01b025b7a01491db0aa951ddfb26ff01878a23a94e8b2fa21470fbc123476357d0de5efa71f3a42ba0c63c8420d2dd4ede7c6e4238e79beb78800543ba1dfbb2384b4f25fda0c8d4faad2df4d933d1f97192574ea6195eb632a18d7cf466c8a9bf33c9669a5b5120ef675b870962db0039a02bbb979a4f30cb98f30e2e8a633ab510d1e39371ff8d206b643b71cdb2557ab53151b20d25267cddefb705f37ea91556de5d05ab1a147dc766f9e797860b3508a7747bb312547b7c166a489daf8dff2d50e1fefc4cb2ed7814b77ff725b38821a92d5c2fca1d20658a82a00f2136754a295d64d1a74659333e45c24cf9ab6fd8cb735a5e8c0fa94ecc90b7e8ab02772314d17b4998a667798a983b0b3900509cd2f0ea667e762994274a9dff9d08d98db3d653bf7d61ba607312309cb3be1492fd08675a67dccfb0fbc61bb1c0656e03cb10cf5f82fe5cb86fcd3a0c55d54b7fca87e552aa51c8f8842a5688abab2a49ce7d6f11d5fcce3d16e46dd0661be87288379fa428a1148e70448f2cb56e7c97228f8861de1c244b2bd1d06dde85500ba8e66fdc0d7f608a421d782521d27292576026529d78fe5bdc5f2c20d802f09a961c75e8794fea3abcbe5f7e473e8df60a24076c5108b2f89945b7e64964bd8b75c6b21223b5da180a4e3eaa5e7a344d2d6330b73c231103eb3477028c25ace6dc88318fef21e024474f64f0d492bee90ff1247210ec9f8788efc7ec274ec7dc682e67ae83216441091e486ef02cd1f1afea58907415637a79a069067bb2bde086a7e570102ddd45e87ba17af79a49a9978e85ed3f856ea194293b69cf37ffb324ba7b3d100fc349e46203363fd24e104cb7c1eb542e8d94ba4e87397d353a1205672d17a40769237d330c8605046a9e659e249db27add2b6ef532372c9e3c4824ef13cfdd21f7334486bb0e02b3d4e7a743e92d8fa4eb452edd1e0ed84fb77380176841feedf8c7ef065265f2d676cc7e820af1b320951769d0272b73cd74a53abcee487841c56822db47c67581632f986715e38ed4428f3fff3fbc0f7cf49a11bbcd46d828f7bbf95920354c7427f4177fe0c2f4cf4b0680c165fa49c241f4badac66232a8e528658f3df774decb7f47790d971e69e40cab2d80303c7278477bb46109fa0cf2a1a5f433c8a2cff02bd80a77220e129ca902e13f49d847558539df64268c77bda5029ae2f56063b799de76328f546ac04070e2af1f6ea179b274d917b86bae74a38f3dd3fda2771625c7da0fc05185f8d41e62d62b63e451a5ee6c76e04efef1f273dbcffe8462dc403838847e03ac1f5a6abd8bff74e81f34a0c88487170222eee5b12351f3405a4d500b30ca14ad4ef734e87048d21c64c646ba72e2a559f53666426a1e8bac83cfa92b20ee4af91a120fef013e0c781f4d57d2bfc5ba1be283d213748b20073f99de1472061a9ad54270db35fef363027a9b40b7a5b59cb57dc87c4224960cf09f0c82610030712be6736be92016d45e9b6e6b11d32a13bf9b503ce05d072246333c542ba6d54f1a1c2d5d5ce99a336fa6bbfad3fe7e8620d4254f32be9c71a2a72b79d82290772c13d91ce688c7049c0feeb026c1e7d2330c8fa8ef6c649eefc5ac9d51aeb63280fe2bb7cc6eadac45f7ba947237fe18548ac3cf38e7796126319469865977468b2c5cb459c774c68fb41e4746405875e47b6809338f2214f8166bb36fe602590ba8ae453c17a6aeac984c467a86a22a0fd807a008ecc2b40c0de27a3b623d17dfa2d0161b008c96b066465132a79e7eb5298c2627698a6138b5c7a745097f2f38dba009531308f70ff8c456f295752241c276a6ca97270135227f95148e1cc256b619518265ca61eb6ef217660e5617b8443d26f5525a59dc0a26265fa63da55b5a6c71831ac64841fa97d4eb30211bc956820138960da00d0acbc3691338b3a48c64bb88a36c6cbf084098ac7382abc8eae167ce1b8d41bd4f9d205e83674b25d15b1ff44d3bb671869501f459d61c124b582de5a9481f916dbf9e9dc3ef60018ab997b42f789bada89ad7559cff6a0b9f4eb9dfa38570ef77e4362b8c946ed5f6727045729b2309a095d455b1c68476350575cf1a08a10b17b3c1a753747cd43424cb4dc6176d93fc5677fb04ff241e3fc77a7bbcd96574a5c71bbdaa49e8932f54354ed6e9f7c232a31e694caca26bfd0e15752c98db405d25bd2d2f17d466fedd94821407b330e18680bac8589fba64090da8231b670f00003627992cefaa3f57f2abd5165147540abe7ebb76ac2b9c2ffafd91e825b3fb621ce3ceb9a164e572304bd176ac9d44dc8599a8046af359907210fe5d4863157f329b48b6875579f4864d3d5dc01286721b31e68278be09c9963cea205545b88a1fa0040519f55d3d61c3ca60a5dbaa8616aa799616cf027c88d0fa2f1d6322ce7ae7197b7c605bbc6336b5942824a536dfb2a4524a8fa33d70ecb3f4c3e108e0ac39daa2dc0e4a6d49182227ed294a6e9f9b233d27fbefd95f9f47a92f2e90d52f04d77144a357f7b5891659f01cb20d4098d75571378154a44a08e3a48905446ed27c073767bfcfb4ee080b06a5a1ef56e187b2013d0e8bc365c8fca952c0ebf202916e7cd7528486589b859befe464918ba266837fdb005525aa71bf740d82b9fc5eeb065f7eadecc649fe3dffa30d5509c21428978e53a2b708a31dc2177a9bb5d3b25e42fb3b819fd7f701734814ac7f7b7aebff6b05a0afea1264b21345aabfae037d086f515e4e010036df2b661e9a70e4e06fa2beb29d662089855251569578ac0a659d7a5322937519f598c292c0921763158ed915932a8a6b28ccec127486eaf9662d16528305c86b0ad02dd54b0edb9ced7ecd44a2f8987168b29a87891c435a0f5b616e57ba32bb20e135fac1ebb53b3cc9e15e347afb8985559ba5388d5ea0b4e53e36268a501bfa0bfdc24f70c0d016a66a2d163afc8f01aabdaa500fda094b7fb6064d13e072e9e12ec18a44362556e56ede856ceb232fe7e61c112209ce5f56cdac6d4e814c3a5873824820b1cce4f93f17f5bae5adb670f12e77f7dd06127bcc2ed262f12220eb017ea21ed475ec8c7e63dda1027335ca21545fa6d2fcadd71ca8f886ed60e2a1045de1ea69c75bb6329147b07cda843bf43958c614d5c00e55792508bab350348cdb5e125600fc60ab4cdb3ec456b825ed2a650da267287bcd4f27964467de48c2e9820a47f8aebe5fe6ee3562b767f7ba8d99f751cf6fa66f772cc7c0426f1bbc1c8bab997af4cc75a2712706ad94008df5c3da73f844298b24d298f1fad2ecf000a4aa4636a4a6ac3ff3cdd09f2ffca99c0009e3dd1842cd42089ba984bf37c65e2e5c5d0ccb2b2383c174e52187e6e1bdccdbb3b2ab5b7d26c7809f869eb9c3882a393a89a63f251e616db6c346e6da4c5ff0fbf8477b6aec2255a9f91836efdfa2eb947f2cafcf0d618a3cd6d5adb04e07ba2c6d73aef1e101a5cf8adfa972d86878369b1a18d42c56a12787ff20b24430fe875d5de523fef873921a009afcd3b45ad4322d29413dd923198aeab9086d6cbc2aa3935e53927aa47359b3556c28211a405e3e079200bedace6dbd598d13cce9ef0cbbf52356193ab7fd65807729d0d21c2eb32fb0c1b5ae19405371334dab026767b5dc3fd3c40f65d6582015121a725306d9572dca8980cee3cc3f1f1036ba67264f733b61eca65a8d62e2b4c1f06ef545aa0ee818b44f6c082aaa8efe0f4026f67cf69f73fe556e724522ee0392cba4962949819e6604698f42fbf95c4d7de0517bf1cb8f42c4531bef112ed5e7d27e9a00917f425bf5f3e3c1b40ca69bfc0a8687209fb5c17c31fb48396164c37b036f71b10ebe4a2544be40f2d3e57cdc064f7fe8b466702002bf6977b82be463abc73eac26dd18647cb309c5c4da4af93e49b59417b021ca6a8628539dedb82d913139d6e39ed35135550a042554cdc022689d39d3a526873de25334c81e83de35c055baf918b6ce99b8a33fe2f08b01e1cae3d3d3ee3ac209c68d68ce69e488ac6ec0ed0a830bcddbea38c90192b4d9eb7f6ebdeda71bd70a7ae17039432e1d55aa69705a618d1b0136b5dabd1a5adac35a0da41719a080b6047d9203ac49873a321912eef483eeaf337c7372a97adcf6c3c1d42e98f11f137302e659ed3f2a81c53e4070379faf90ee72825c4390b59da729129cef42c41d711064434dc4b2ec73d4da5cf3f59e6b7c37c77ca56a2db3e82307c48def9b8e5b5b43d5affe018961d91bb444a9aa5584c3498f3c70720b9fb7a33b0983aba4c2e0b8c76f09caefe9db47ca5697a02395f402525311cc160a2129f7c20b6be85c839261f6700c75a0a48842274a751544dbb965ce06f9f9e635b8993160121b06f7951a6e0915d6fe992d3fdb9b77188183e5f217b1a54dd9092c9090bade6c80de4561df4a2954c7d86f3d7c8aff9e1029f7dcb078713b9c98dc8e061ca0f83471c16fcdbeb2e89035ed12c11197d0cbaf13f265fe48c29b94efacf440449ce6a974e370c1d1223d1e5aa70fa44baf55406e81d77be928455e3f67dd1318a8bcc136b6a2a66e61562ee13376c8e363916f04d1761bcd6a842a360d4eeb59107574aaa81553137a58cb68aae85496038a092e19c19b0a85cd1f23ee353d6e34b605350155f22749fa0e0e8154892a31af85558b9cb7972a8da1be2dc68b7a9dcc324e0ab02a6175d3d6d299b86792b5223e7d5d01567c613982681f1cb6b39c9e8867c3236034e611f58006932eac973b6f5da6b60bfbc35349a3a7a28bf403154a576fdd8f1e129d019c99fb84912558a4f41121efb45a238c41fd8509578f26df7dc83dc756a8ff831f2f178df7ac7163b778c8657e8e51b6bc81c2d05cacd00227480823410861c42c219e6e4f293256c593c9fd50fa22c695cd26fea609556c55d88a60d220d8aef8056ad1e29163b63700c2c84ab1e0de87cf83224ae73d1f4ffab773f2199b02efa326e71fdb7019854c29a93d4df90b843b9b8324d08befc3efefe09b44b565b8d7f766b129565c8d0e9ebe4fa76a6ab0bf144c43d283f3cc54624bc9a1bb46b64ef36de7a123ce18040ce05d00fe78417556fdb45d52db146c83b6aa9440494ae2696f95b0f93ee19bc0631d5eaabf8a703aa0729ad7585ad8911e32521ed7164a333f0f7253b4ac3cd315392847f9b11792f447652a57493d18cf23a9fa26e25b9fde42d81682e32df5f8d812668b18034878583885f577ff9f6d688255f0cad7aa841b371ec8d741997a291ed8d7b83f4685caa58dd42d5fd2803fc7de4fa01682e7e3a061b7d0c4da8971cda4bdcd720ff9f230066be852d77f061ccc0bd4ea5128aed1f03bf035467ca453891f6bebc5677dff290a878ba00d0a233c464809bbbcef3b17f05633dc9da6d4feac6a2ce9fedb5544f3158e92bc1cf823c56ea5cbf066179d7d72c876d065fca1da6f85dc8c851ac180e002e412fa61bd922f62b73ee783a7a692c2bfb640e975ddd4fb926f6a798224d6d3ea782924626e130bd441e9c96210d7f17c1ab1e4ba2d90ea1c4a182ce3a0aeb54f9a5a918ee6d595f3ae39ed4e818feb4f40cdd1009eefe5ae7de0564897d56919511cf430defa359f2b273c77adc327d9b9f803997a718d22eb4e681652f92472eeb81dfb402141aeaea9bff520f1640dbc1f3de5724c21c071becb3f13b22f6846517164401d7d74f1c236c03e5530a67dbedd05ab2ea5d67bcb4c32a375ca550b4b77489ee3773c40cb299bc636ced10260f8dd7ad38d4818611e149d7a084a1db5f7c8b7292c212720bade9be91125316bcc0718cfa831160b75b88526f4e589568ce7f6406fe028d978afc683a356c06ac56d031464af752c453e9a623a6753a6d0f3bf4f74a0f6567cd741330cb42ea5b8fcc0621968c6446498f77bbdcd601c57b0ce5646701ce345cc2643ca83488fe4a0086ba7f3453837b4e76b2d8d4f1c89ddb94fa309817eeb10658ae27ac248b73a3e11f55d4c88b39007e7b56f83b672f8957a70a05438575cf82204c11987d9cbb0a82310e439616a784502fbd701c5f6e7152cbdd81c0456b6b317319408bd700b4faafed0f4ee9babde572dbb0324713eae83c4b9843bb59519f4ab6d511b3358eb5ed495ea9dc493ffde83da8f0f87f67ab692b2208c61241af5a33c9f402fac844a202991b35f315342531913ae95977829a642a9b6c93fd586d8f157eb278524515f6e7aa74a6420b5da2c3ef329b97980824d64e5d74257f56987a861c2fe58ee34019b4b11c772958d78f34eeb8549671f18f7f40fca2e595259ff6de03d64ab6c13f0a74ed62afc395fb9f095c3d81ff3c13531e1dd976585a7060410e3ff6e54429d465aa113ea211797168ad2741f4cb6881c303f5aa42d16e96f1ebb0d1087a2ebbeba725f1b3265279ab9a65f85ad46b7f3e32108987c4411df6f40fe09c5eb7ceb5920264b27c8592e69f488a6237e1e89434f6aa0130a50f6c9645ed5379535cf812284bbedc125f303c33455e8a1454076dd5b84edb772e9e615cd2badd709b82a7a3f58dc90b126d50e40d193060db25487adf2d0fcb43c42df55212ce20aed71658bf4d67ab9695d40055b669df4f41c46e0b0a6944bcf997f402ee75f53fac31c61cb39d0e69d303ca56849ce713cf837bc8653ee15757867e2b5dd11135660f23ae36343378a1859ba5c4d906525898bff3dc854814ecf3170e1d779964058b354c2cf7a7d0ce537769376fec39f2ab4e5be7e284358faf9e17b7897f26d4f1d22b5aaf240c93cbf97060a942cbcc1a1a5771ea2b4f33db07812c0022ee0cb72f0666c1e5b295c748ed69c7c3c89bcdae6c19c9ef610acdbb76c4cfa00379e1d385fcd930ea1a614c34f4628f402a1be30b526c332ac32ac4619f59adbb13202d68078de6ca06328f51904dedc2519ed9f8aab3d452c8292c8610c4548004ca0b3c0280e8127a56e1f8ea0e8a71030520f998f656ea3010c71ad8403519ff68ea2987e3d1aa5fd77f849900aa54feb512ae18b325c97930eb1b78c29b64a39f91714082ffab399f79230f9a377a1486f7eef2c755e48b8016edef6f8b496204eb01d93ecfd0a3454d454b18347cf42613662fb81d18e9cfecc3dd9444b615940b1ca6d05d3aebea9f640d6f25f0842c7e8a8e0041c62010723a9c72ecb329d7b26f801a57bdc9821d970f062baa6cdf95d939d1467d07018d20024d0206d40d048ff8cc90dc0eda62f9715422a0817f498f3f37e46ee1048efd01ac0ec234434ec8c88300e66d15ebaab70dbbdf92ec18f08f71d56ae756f743a55100e39b7dd12ccbbd6f5987d679f1bf061d2a530c4e6d3dbfea6e09c5c1dd01777071df2cc96c701e59d46f8f85905447db581291221ffb9256c481ef31d6c7bb2167d87469f1095a4e01b8c1f72d65b5331d6a4b0c4beb8bc0df681187515a4fe0e924744863d48ee2d7b7259eabb5efe53d8eb555b17884fa869fa4572ba6de469ea5bb02fe8b943497386a1360ff6a68a17c1f2f3ca97693eed45f57cb5f3f947b93b6c14c283aa7f1cf851844f622af38bb78dc5f28bd7a0c523aef6f915e69a81fa443768c93e7edbad770c4706c6cacf55b13c46485e5e0a3452f93666de8b5c785ae506c402f5b89a59971da44159403c74b8748d27a17c904aed787c828cdf89336e555fb64fc4ce262730cc105963ce27d4e1fdfb3ee1140dac830c90c0de148f1020818b44708f5a5c9e7f6c618bd95122e9bff8f7671a97788c1a3be09b1745c5d8f1c8b83b80b47f4a23c1904b4ce7a0d337637e15d5e1aa5ef472cda014dbb44602c4e9763a75dc03a4e0dbc985a90d23368982a830ad709256e6b026a013fc7202eb5dff114e1b4a7278f095bb905bda9536155de750c5689957f5aaa8abc672d0336a5ddc49ebe63afd748b71fd389c1251510ff7f24f7ccc3078380b01463a6db22fe020f947c62d2552e069ce22e6e4235072f23122d0ef487115c68faec5d91936a479bb5bc3bd62835d716f047c6a955260cbdf7d0640e45c199ceb9caf092542a88d41ef98bcfbe54c94a208b44f68e479e83c4e790bd7203f5d92679d1cf3ca8c7c618ea459103eab0edc0155377f5ca554b4d0993d9a0d705bc1471380d4e616b89487c3a353c1658aba4f1b7e2f1ae4a5a6a8c7c57ea8b0ab456c85272d6a38929e97a5732f1c89e2e8ecbb5066d8d8b4e0576e1be2423a0b306884ee350e17a948c35e780b032046b466c5ee78f39ffbf0d246fe8dd8e4b3fffcabef46d8d18a5e017dbc61382d897e96f9287318a553ab7587e12bfa5c31e2f9c9ad56a0ecf0cccc7c3b4b22f95c4d0a0754436e936640654f60ca979bc5e0064405ced506e1fc24a17d20ca741ac9f8f24549e7fbb08001579aba6a26e633a0c6e0a5bc1c18eef712b591cb605336540f49c93280f6989109ccbd9db3e1c216fb09e70343179c8f9ad5669c3b1c383f17806c27e728b4c99218bf33c8089d474ce0fa7c427e091b445e1702d859dd0bc1da943fe1d2aa53bce42a46da0c5b4367f4313cbad886ee45512d6a55d1f9b193069b058f0e354617fb5213116742d6625508672639e9800310178d7e231b616529bf27901036ff7066455546fa798c28c5f9a9affef98d96dc2fcba87525248264b3dde9a6390dd755594b15961d048162485516b7541082e64a22a00d5ca3a21638d749fcf418ba9f3db1a10480568485bdad2ab224acd188356a727ec6642f4c028a9bd1f8b62bd2e318e272db28ab9bd327dc491b0534e845099c08ac24a6cd15c08d99f5e1b50ba990656915619cd2df6a89e8dbccbba29a4f1323c8451e9482537e5b5bb843a4bf589a25f98cc72bae15791eba0b03afa636d30f460ffe6d8dfd98a7d620809a3172c205a493b18174f6f30e7f47764bac239d1d877824e637dfbe4b79314ed3f9728e3390a896fd93fa6dac2fb7f1f19a39ff0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
