<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f7b2730b11616ae945e41d4ad07f2d7a91cb61a28664702663f84b579ba2e6869d4e7e1de197ad2d6cea53bebd86e247c84d708cfbffdaa6d0d538d2ad30c178d4d4424cdfb9860d6e36a5887d873961c4ca0ebc320ca4e003102ac7764fe572de81f26b3fa00f652405594c2647600f876c5d211ed9a0daf1c4afe405a8c9cf5332b42a5633cd25525c642a9b65f76087b7b27197747f5d6120f2a88f8a12d0d295b25ebd9cc8bacb055303d6780686ca001d35f188850ad5a525bf18895030d73c832ec1e24a5fb07dfb569cb1ce9c45668d49400b75c6dfcde753b6ab1e6b45d46fbd618ec99179b74a5447db3644b903465298374efd5a9e67e484de38f8de0b7bacbdfeae45253060518725c4a33322b9c3e7e6b27b7212d4d3773d9729167ff04b49e96b6a37986f93aa0abededfb9ad4ac1e7636869fe7c125f15b7ac3f005a578530fea025d5c35105998bc23a81552a4582c6f0beb5f53d5c3394509545f46e589551d03acadb707a594e213bc60a4bbc0e7942963682968deba14b95173d975b3434339d3db81125fc93064c13f89ddd5674611496efcce3a20ccad4ad306a0c22279b30da1866a62e3b8923aee305444fb9cf968ca4b3581cb20c0d90feebffa3265e8e04a73838bd736d1134da2171d1e7ee147df057548a1b62150dd4b455fc3f7fd40c37f507c6fdfd5de116ff6d45952571fa4c2a134339724498629f9af4666bcace1719550ab468fa3c1aa365c133e57f904621930618b5fdc8852c09f9f102aea17e9830796104f34fbfb6a1140a957e343a471bbe9791540abb081ae74d798342b86483d1ba3e48a095fbb82ecfc311ae36cbd17dc005c828ae2315093fe545fc752f11679f3d782469035dcd75fe4b16a88df6a17cf07c86a864c584f1de01d6dd7282d347f3e16c944e9dcf9f849de660308f38742033a348692362b0624d54bcf9ec9689e9213753229e84e0421a20219b3b2cb3afb573b628d5064028d447470df698c8c5852ebd66c8dd6677da31ae7db814c39a3b6f007147db6dd66cf11aecb0c2804e710f5cecfda89c705df9dc00a97a75c9053661fd5c8d7451b250186eeaf84e590f4d046d18300fc0ead291fed6540490452f0b8b7ee741294105a4ec35c080a7d14c4dfdfc05e04395916b8f42dc22bfb50b6add9a3240f2510ced3383ca2ac03cd8d156425ebfe43d037f4f004a3603504c876ad91c18c99f172fd2c881426a5144dec07415a6697b2c540ee43b9441b8a52fa48f1f8e7ee252995529bd4bf29b741407fa25afc7de57300a6fc17fb0e5dac829f63345d88947f0875b156b38a4700f1b31aa96ad161876519f3ec94c44c4883058490cc810d0db644b5558d64a5423cd5228fa34fd7ad36e027a321c789902718421e08dd100ceb83ec36d5361384ce43660c647d08f65ba7cdd0304ae81bdb18a9c4575a804289b165157bf00533e5034d9753d88ae347025cf97108f670f4eb7424fcf99da69cc857842fdf8ca9d2dd8e79893731763d03cbe6d4c7c0735321538650caceaf1c286dac450135d21064b9b6cb5c5c874c87d9006cb1f367156ad783157981141798b734a457463e9f13a4bfb1cffd763b257bcdc83dd606f9a85e17e9f2f0ab01e5b10f94a3c70c747ff664c97977ffce69d513e6b8a0abeb266a29da1da3b090b89facaca163939c699ea6310f3e467d0076f9c1fe52b779c6303523ead3a744b1c57adea2fbd1e6ab6d844d77294e25bd8aeb77b2ae6b0f13bea5cceb95cd1efdcecc0e9b07ad3d7485228ab8e7dd6ff39f0d33c1e81573f8158197283bae941fde21fb48de8104bba86635568172a95b81e7597ac6cb5bd0aaa12cb1a21d085b35837bc49710a7eef14da5e46b3e9c6942060ef344ce21f61bba3800d33c50ca5ce60d5369303457d0503a649d84b3ad9e0ccdb3d166eb93c3d0d305354be0a630a7133b876584173fefa4a1ef24dc6a1a8ebcef7874250f13a0f417bc44ed8f67eff2f67bf2e92908ef67d9699854e6fd7c85ee844dfc202d6d9bc6adb56db197f4ba99736108445395c1fbe34272cb125d354817860763eaf8ff5942939b5d19f460d5b722d4725b728a2e195a789df2bf9eb84311f94cef5ad58dc9b3272d6e5b4a3de20b85b77c8ea8326cdd8677233f3fe16c968263941691c311c26bd2205a97e2f2b5dead9a89be36e471a9dad75d3cb5a0187ea0ab316c0154e1fa2d0561682751ef16fc205135b7a047d233b60dd4703fd8f4992a36c55c49211cdf8fe8fece8c4eda04b6269550f2093597e80642e2674847a73f287bced9ed3589f16f4a4e1d887b42672dea5810421b632988c4f800c503f6ade4aa2390e8dedf10bb49070f37f2c0f64e4bc75ac4386d36e09cea96cb6b5c87f6948f7e038bee8082ca59a0a017b9307d150b5cace79800f16058e06fca001d43309ac8e9404bad601842206fd0477d2d9e667d40a1cad4467cf9cf4747d2e97f037e153a843104005c08fb054d03a07f857a2c61e311de4e05221e3b316f7b1f9d8cd560614cbba20ddb38f36116317afdcfc4f7158755355833f42cdc81fd7aaba93b297ec88c6dd46636de330b15d551006abb3b7b4910f4af79a07bdf2f8f7cf776b9c4df47c8906fee900ecbf35152eeafe32302d51a42156fd88389cd786775d86b0df26970e98b4b4d033983b044751fdd77e6bdb13091d868ee19d30097add9e3b6f25881956467996bdb0231361413c302c0865816fe5d39b58a60cac9972df3f68e2eab6e48734a35ae450d2e5b53586812f6569ca5c5638d5e694b4d4d1885eec08778c6aead467eb27de1ef518cb723db1668566f418c5e380bda4475533efd5eeb93c67365df51d4f009e26c40d5090ff37641f0e8433add7e0a7351ff34a3ef684515f8bf7fa0a3394084623f3dc9084c3bd4aa031eaa5d5b0fc21b2f9c80dd905b939a07b6fda8ccf1eda01b30df754d8abb5a4d399c9bf45cd0ec7edb8c6040d5857d4ac574a037d9ba2f0c18ea61650be7f082d0409ac2e18702c5898abd36f51abb14eddc64f188d6a361f38220649937de8d392c9aa3029a9b7cc753a9d906f675dfb4e71d6d79b23349b481bb4944b7374d9e156d9c1c1cd3dfeac0fd6e58808a6ca9f3fe0aebd8be595819c5872df64a0e48dac4eecda8fda15aea1687fb74430a092dc8f149f75909a19af624719e2f169d269d734bea5afa11bb4663c4dd30f692ea1d28f77a7b02b45471c8f97fd988670429d715003ffa0c2166f3efff4bf389359b4fc242e4ba3586a5838f10ed987c8cbb8a95dc5f27b3bd951fe531a45e4f0cf17541a39cea75f88719c24d5b3f9896cb248db576e260cace03d25577bfd71c8fce5b4691933711a597faf38aea33b73372e5c351a1f78970a8733214955eeb5e382d0bcfd9fe214050a1a7a1b5a83e463b00e66dc190f2305979839058c16e181b565f346cf9e7ddd51313477517004ddc0540cf004c34a41b51b83e7dfd33378587afccc9398763c70f6f47316137a48c0949380407f2d66f5fe1432444c484a9fa76104d4931b2f09952116c8d8205f26908a37a348078fed06d81b476e6e838cd57d936d3f4626af172d6ba821fb811471c0b5029946f99c954e8ad7555f72d998c526b5cb476b38e998f29812f0a4682b3f032a5f3291c110dfcc7bc45b95183aa9f76500cecccef0ba9a6a18b4d6b7a3288cf28b34e1bc8c9babac4e71c2e3293e3c7a9b0d1169ac16e15d8c8acaa277e6544b2b2fe94911afd56ab42200d6a9bedc45be8707d287328526c395180368e2b82acbb8d47fd3cf2460b844e10f50c7cb1728b7358e2bfdc016326d657c15ef418eee5ed3a7c09f24f2fa77e9635b50f64d0c9e4aa56655ab34b8a40fe499eecc482d701299b2bccf1828e258268f4bea22cd671775d074d7274c93c93f2148e553e615a96e06249180fc81ec57b5ccc4ec13f444f19aacd5c244f08bd0af8b68ac21107dbbaed12dd3eedf2a6ef968e2921e90d5512ed52a99ceb551c52dea0e89a9cb0315598f46e23054537044f53295ec546b8b35a7519e84191cc9f5bb30d2891b322e10c81e4adaac5c00a74d6cf58036b48fbb61ce8816d0d17e13a34c8327246c8f21b2cd343b13d7a2ed22f654320fed6670b126371b6f202d07bc4d86340326d5cd814917858b5528abfc2ac8d16c73e6040aaac7e92f6e4bc456475a237a926a5277d093fa860b720766cef8656698c1232e7664217ee9f5a42b2de47477a6b5d782b857901ae1063bd38f32e854f4aeb7a1ed0f5a6236dc38c5e46927723991e16f71faa43dc7f1208bdd210c2539de11428aee17d61deaa446948007077dd1e12772404f033a0282cee64eed707d9b9ec3c5a5b03715d63b9094b60b90951461ba5eebe9bbb4e5e6dfa81a675b78196dc4264f12e2f60700407f1c9dea10b4be212808f82e783973df46b16bf9263ec9dae2bb4426aef009210da8766475b36d08603fe165a72e8222681823c414bf25f9ab5f2d7a44e3a6c06e4043142afde39671900f3cdee9a084c5096d7c921d8e22565466d5132dbd8b74b54ab43084b897f15e06b37190f3f34e26de1f2565f3a14decefd711f0667ace460ee0e842e9b921892047caf0e746c1462751711b721e46174338a708e9c49b1e94077a64281c125b04f3aa3d19130ed8aca4ec7334ff7a063189423b87de293ff3c60d8b1b13a6886b3b7677602bd140c359fe43aa6b6e15e447c7d919cd39a3199e325ccdba34293ec54ff0148e7efe8f89fef5cf773bc6c7a6b9bd644066f6e21030547f668b1031d3f492faf1b588c4079e500d35bbd172d11e634933e404b14e56ffc8b75ce7e3bc462a732f4e55ccf29d9a7c92d5c8d57eb18fb06ceffc1f034e9bdeee42551c1b5cc5c8b13ecfa025a82280d4db640c4615a63ac9dc81010a21e3b6f73ca86bc8434c0b51ab277b0cb6be61072cd4a8290c2743a3b5fbb4d8640fe8674ab1b08d25dd3fad0bfdfd2cc8fa0f89af416de407868e26a16c6828d9d4ad44fdc454d84d531f36cd1672f9f6225dedf00d97e99639d4869d604953d9f4451792960da8e00b0f6502283cca86043b8018189dba8dea781538f9b159b078e6641ffee5678565596d1cad12a7f49b908e5c727dbe41f1e9fdaabec4ede8bac9dc67e85cf06c592d871a1ba7e2a1300309a5ce2d3794c626c074c559dadb41bb4dc76c0adba57dae4cbeb68cb457b6e808f3c6bcfb533ed9ce8924b7c7765cbf7aaa7f1566872698a9a90510374172c86ee6a2cbc4e812280d47f873eb2e63c45f183e0a8539f7477f48e96ae6d4394df0bb0343323c1e73d584bd28dbf7c4a161b1cdecc3ffa0afc35d8a424687684e1e1b60fdb5e50295c49e1df70ec723bb8731b3298b8cbd3298d0d8009dd82191a42081f823310bad80f9195c4adba335587890c2ef1e501c7cbd4dd177bbb3a340f37f8a0465d540e64fdd571d17578f336f96b12e87dd41cf1406afbc21f2a13a8121007e2dc3070d1e66b1072a0f50364c55a25fbbf6b045f1b4ee15c592fe1651553c241da1ed718a83353a0f51320083fd301be20fce390e08d51bdc4a39f089c4942e3ff09789f4b2fb37ae998447dd7ecea6888a80c251f5638ff433ed06767a9cf3dffe1b5be686347853a94e274963296140027dae01c614ae6927ce78a476c8f90903f021b170181e20455aac53d923c8d07e28d4a2a2d65329f5a785c884497a96b08fde4a3ccd7f611a4df804482d984759583555503f8b50b2989e3a2243e7cff90a7a84305da71ea1c6263fdb80dd0a3ea8b2de790a7a939e3a16ec8c16cc35f0e5b2b5264a77b2d8a94405b4f70e7da6f32ce8a260d004e05bf2bdbb9972eabea1650daf81095ef36cc7ef109e61bdab8dfd40970c1848d55b2c8384d74c73e830d009210d8bbcffcccd93232d9522edefa732bd1780e225c5a4433f8e20bb2de2bd4a6a6c2508f91d35dfb0e28954658c70fe65f9c37da004540ed9d586ba01b5434119ea12c90534e1d4aa4b4985b2e29290fc1ad7538098836963afd656f1ec22f74f0909e185e310639fa50039ba76cd3550b28a5d23ed3bd517bbbcfc4f5ecdcfa4f3d1639a94b35814ad2199a7974501d23975993613178acf1eeb9edfb6470e0743b8adf2990c5d9faa7a091dfa4621c947ffef2b041275ad516c06372e221f9107169a682b38e0369d855fbea3675ad4620872aa2387b0046da954e1c62ce1455f1e387be14c197a459a16b6817d8c503306a1429644f0676de2ce9d2a647c6fad9ec7a067441311f1ac505ed1c6e06cc6610fef075c6aaf92d1bd4cb42cd4fdc1d4966e2b153d6a6d0190605e4debcb1525f311d96f4596155218b48dd0d20219efa0152a92574dc6e1ce5f512d305edc1e7601810d6ec973dfca389ec67ab1f37572127fdfed3c9326c55c685b26b4169f7e1311bdebd966450620add6b2a0ee387f36fc9d7d454adca0c0d549df987f56a3bc259e98d01e5366d8b2f7f1375cd67f3926b394773ac197e1ea766fab8b40c51f8f0eb0761ec91ec12afd69691a99d3a4264dbc2e810bdff53248895036401a80a47ac7e8866167cd20faac8da2c98493a1c1059e5b5bd1c703ca1d8e1cbc26bf289fd28a4991084ddb5649abf4161c0d33504c9e86cb758970b82dbda6ec2ea6dc72dacea0774224db471389f7ab0c909918f5e49c18e3c26a09fecfbda7cb73f8d32ea0d7eb427b3c0084829c0d5c55dbd1a8aeb7131169aec7c6454dd7406ed3910c079510cd8525b20cd49b92bd01458ca82ce6aa5ef194c45995a0398ff1dfc73bf3d95efa6539df0adacfe601de2887a414d0199c3819db9e6296612f9301d4c3b3d5ab129311ef6aa4388390cff2c08068b8767c53eb238a3c5774e5ef18eab852499666f8eb1cddfd499940db3b47ab5b654b6ac3d78a2edaf2faedc7094987bf4b0961d5124f1e0bf6ef651b37939e08ab3e0aae6fde7f0d30a5a5935bff5077bca6b0ef961cc0b7f5cf59653a164b96a4345ee99d74a9aaf0e3643f789009883c2c682b210dff41ece7147533967ebae57506bc78b824f3722293aa23505f9484224c0cbb37b843b134cf22a37b5669e89564962632b0b3a6b69403c078cb43e618989d5573de670ba8d86462cc7915596ff9c95e298cc6cee95877e183703933415768bb09b3f4c616912c4229c0a261053bebe69d9a557b61fdfc64b6443cf4da1e2418b68fb101f3da7432e06591f9425c9fcfce3608589d9e144728e96afa5f54e12267ace62887d456d7ce1ebacb807f5724a5615ea53def65d419267f9a741427535da3e75a7650c759f7ef141e20604f5103d6457d82c97fd969bbc7d1dd770b1b35dae71519a24c664bcce4a1d38d20ed09fd39e3bea5d9ecb8cb6c3c865df9bbcc7013860810ef05fca34021a33756f59be7f5ccfa480abd7248016dadd45f7d99612707d9e398b545a03fbc3287d749124d8183d1f1335c44c464274a1ae23d585a0ea6fd86af853f6a9045e32857612695cfe9340b235ac5437bdacdb3fd6453a1310b5eb57a0aa31582e3b7d21c912b9036a16ffe60a13f2e42e7167c083daaa74e1a4abf3c6b1f76b727e309e2c1569cec0db1a4a9ede19c731dcacffe9205ae2a749c0ae4d884e39f86f0b02e3212f618bbc4f309a1c421cc25e6eebd4a2351ed62ec1ebc92126043d23101b22811e8cd5e56303f8a894b24d3124e5bb853eb0962ae62648fe8366654b5d4d90c48843d8a780217134e2f042b71cef5e3fa44f93b06f7aec35f91acdb37e70ca68b1cd7c1282f36832361a1e50ba80e3ccdcb097e4119b7805bfa1ffa8bf10be02b415a394ca0b2d4457bf1bd5b2eae4220e820f9c094fd0acf4e59cd1067a9cd0e47890656c995706799b6b71f38985dae80e1d6006af6abfea9898f082010f3eaa9b4d25d596dbc9bf9f9e31c810798b5f3f7dbc1418c8fcd7a3193e3fb6bc2d0c43b486e0fe6adf42cfdb544b3f96a551033a36998e759a1826ec03f225d167b1a4ad091a5fcac394fa8f2a602e4ca3e45776fcb58afc6ec3ed3add483af33e7d6f26e5c359097cd421e2cc7aa566ae33694f23ee09805697252d4d7ffd7ae29cf149eee264783ab0071688b305b2870a117f110c5059b2f6523d634f0ed7cad6eaec2d557f0c21fdceb67c2b490210f12127fac20afd43b31d2b1e65183fcb940d2f93945a24c52eeb4e30af1c41580108129dd11995a9459493b5d1af10b2e383c498166c5043e706bee09c9adc3f9fa1a03bf2cfd485754992e091e10060b21adc2062fd35fa36e5b485384fe9cdd3940d2b0430e3601f4055a744fbb354da223f04b662b3420f6b261a80129b69839c8738c17541cec49fcfab533f0c6f0c241c8ee2239d6577baa80c9e8493a58a3cc27dc86e43da31f1af65decf9ead4eb84fb934eddb52ca0d6bfa98ed76f0c263396e27967018d11a2e309d4204b4a6fbdf278f8de79ff9976fe58b60602753f0382c5242a99c9c8eaf5c9544881bb0e2caa98d18633976a577e41480f73431abe126c09430a017ada0372c7ba088899bf331b2e90fd78fa96e9d18e59a60c914a8962d12c13d1a2b1a552b0d6be825c98826dd9908669c6778c3d556a488408db7a79a9853eaf24cbc53f0f6893fe3f3f8a0450fb8b66d5f714073c9af1383d44606434b2a9c6142e73f30d433aa9671cea005b5e9aea540456415da5525c645fc30c40e62607910907e60a188cb80ca1de9cd12e7b7c5928a16449e4faa39627e50042b97092356648a7e85ac39aedaeddb485a425b402073ff797852fd1e960cc15f9f4282e2804e4b540c9847dc044714bb3cdd7e922d77960f7e80a0fecfce0b8ccf12d8e275f96ecfb19b9cc246d7e19e8038848f51321bed356dca3a27d87d5c9ad3a06be07d6a95187f18955f28b984542c378c6f871f726f989a43ef53a206ddda4229f9e5eed6b6f7d302bf4fb78a5d4e694d979ce9c00749f6bb782273ff5446e32c7a7007f450723cb6f2ad508012d8b70439979e9df754744084a0ed45982702617ae327e0648961ef0fcd820d71089e0cc447bad5f20a0543fe77d219e4a0a3a3b26cea3db98cfc42072b0456d121f79ca98fe41b816e4406c8e35be1b320be98b8cdb7f9496dc02b9e3ca910f503bc1232a2533fab7bfc266e4d2ffff33a1c842f63b41f4bba0524e0309ada79ca3782c2c9e8a1af9b8fe94fd228baac41d1068f3f770b85adf2b8aa94650853d12b1ae89748d249697ac7f5e4c820c00103cf8921ddde0f0e186b86741b87bdb6ebd6075a4b8c1513057617be55f401bee676f48216e0443788c6d7b042ea6560031c798e36219acd457ae6b40bb4b9f5a92fb20c39e0a3fa5298e2c99f5476c3e86f78c550e6096a6a93f25f3fa72ccac7dec4f030ed3f2eb3e7b7a5b13c452361988a524e1dd3bff0eea36147274b98040d21db22ac4ddb1f44dbf90945b95bdef006e84b24ac642c17401820f5a32bf9ffb51607369114293f3d8cbcac982261ecb6a1e7bb97e3670b092d40ceb567455521350d73c490fe311049620b3a4ae42a4f7e97afb8fafbf3a2b97a029aac69e58a66feba1043157897a5908acc881b69921688eb77156f7de9e641a5de528f694ff4303859729473b404cfd75aff684e1882905f7f4fdce5cdbb4bbe28f4047f125ed348218a1e0f7619d81c91d5377c71deaac45dc4ede5116baf674771f40328e20d9d1f0de88013d57095546121c45a42dac1bb6c8953b825d4dfb6562c48e2802a6bc6b1334b70d8277ed153af40a64054dee4c205f766ed09043603dc3c8f2ac8c64e2583545c73358771db0e7d8f50828bc08444f63ff078d920f9944191861c33825edbb505d8a1bd6f42e0bdf8cfb68ea5ac5b477e1107bc5c58d4af7e28b6ea4cdd18dd9e56d7481840cd88a4564b5c340207fa7ef2e37bed1df5c3a05b18fc4b7692837a8a21f717f46ab1839b2b29b64d90686fe70e37725ffbce39e82a7de02de1bbb4ba0101e7b2077627301b616b9adbae2a410f6d04ebbb36d233964c88438dd3a6c0b86e10abc4901067bedd94099502a1d0af80402eb7be7cf910be17570e1e1c869fb1237f9d8cbd2ee44cef2fbbe4385b1e27dac4df754fd350beaf07e02e826a5e294890b470fe939679e905bc8026e3ab692f84fc3f9f514832fcf2262a7ba50c21bd1d2b2c21a056d9584e66468c3bc77f605bc0dc50968ccd5eb7895c0b419c28c484cc266d594e48457a670dd489a5e7221cee00f0bbb6a14fdaf51d314c7738e029acc1a523acd9fb0464ac67e275f41cc247a228e2465c63a127990e96f487b1dc9045bec63ab555208a04b8f9597f370073a69577abcca4928d9d72a911dfd5376c81f6dbf63e5469ab494a76202dba3c658407a16e13bf39e8739a0a6ef8bb06d950f794b163db89026b3290c93fb17b1810b460813cb57ff473360332b40e5b7de35734368f77788e9a2fb06651fa476bc980ff1e143b03616506d0a2cf62cf7d512464d521ac8dea6ce8759c5ce43820f1f6740a634d49337587ce01143c120704ab6542aa166906a1aa6c04f23efc48e9bf722b7a60a606a7f824c1e50d7776b42266af99deef0b84861ff4831e578c401c3b20dbf3efe8f88c5680dc47077a9c9b18ad7b60ee25899359c3c0180f8b7d0011ba3abaef8dcfd5e92f6415e598a5a141bab189e0948f1e640bfea060fc5292661ab430922051cbcd81bc4d09800d4b09ed4b9a9228d954d462d859f6c5b8e97195bf2eed88fd0880a2e05093604e8616545fdad53d063907a5e5771a591426511ca24b5385eada6893b5d4bb48ec5d8452f1624896fe2648cb71ef4b00235d2a1f32d46b70debb1cd4a8d8ebf3fe5acdbe3696d844d8bf53fcb1d532c7730983ee29542600c60f3412823053f18e2d477bda54a12ef555600a985519a683fbf776ea4e009d70dd1872ef704c9014f96414e657e6c188ce1832dca67ca3e21935373a0fa152004a879ba890acc2f5e49e3f328e217090eb0b977edeea644c4ec1cf45898fde91b96e6ae67068c9db64c32e26d5360836c2455449cd4f4708aa325d0d73f4e4c97c156bf0b99f23200c8ea6642b2a21adcb7e639e157cc04026ffcea38d6c4fad1a1019945fad43d8d921dd851a0ddc04d825347819881a1d891e74a714cf6c8176c19a2d42d1ba8c24dc36f504537402e4e9b55cda538a1f9d028edf958fc751c31fb6d476ba86fa9acef2f27a2230ab8bb652c982e565bb8b20e438d4fa9461f3c6a6d6053554b5bbe85d776c2bf5a1072cf046402d503b761f3515b644177c5ae343f3ba0154d2d8ad510e616dd4952fc4d4268d0fea364656e873131f5d1cad465dbae891b46f1019306031cb36ccd4191383c3bde612d3d060fac9dd59c81769a60cbc53aac6ea458968fbb56eea45d3af923ff35b2bd0f30209918ba443d506888014bd792957b2044398260cf5cf51da0ef67cfadbf5c2edfd9354d8705ac18382bb85ad386069432fc16407429dd0fa2cf5ee51f131d64bc492760f7e6293876dff70c900f11eaba60e0786db53c876de661dbc13e0e447df620452f28d68e46b79b2526a1fc8dd8d4512a3e7eaf9b6cb922dc4e22d5d8782d7c7ab7b7de4b26b514dfecf02a49f7748c54624555fad88c2280385399144e69576a55edbcb65e01fc91c564ef3ed0795adb535d72ec1c915f121aef7a00e75b20d65fb852ed0464ce7e2700322c83685ee7881bd18060ad17cdcd68bda7827f0b9a13d55440c5906b71822a9cc0ac85c64de3b669bc85a34a42e99ef78f893c4f01999844a459d98bdcb5882f6a45e4ec4fea7c1797313996f0a0c955f455246092d19c5a188555a1beb8dca0d073bb3fb632ceb7c1067d494b7e2146fffa93478837d2678a49f58fa2b9da6c066b843747e16851a0329de45b3661f37f1faaea7bbee53f97405deac01e64b7bb1193cc9582219a1f0b629511837acf3328abbeb55fccb91f6646118ba9a42cb1f9e87b028886c6d206edc8ffed2fa644eba32a33c39f1614fa9b011cd37d2587dba96fc9ba7f1bd028678b6818f75387566b51775e1f701508bf488d8347e0c6cdc0f02c1bc0b6c7556ebeae73c03d2eb8ae6bd6e1d39f291f8e91f7c1d68663fc7c06905100486de19ed425e8e99efda356b84813528153abcbbba7e5929a0e919eb8c171a3cf86072b54850eede204012178e341df9602ba6c47c0e5d81eb0a38e00920e80a77723a8678067d229adea68f4c598f8d3f6a3b8662bfef8d9d64970cf9bcae6d14c607198a56cb8691092a4bd37e4272694273c52f12360607ce152a8ea6f7d1fe18824f9d538f58ad542ca93c0770058e3853f43073c45401deb8041b247e2348abd251710b8dd1f1ad2aeb6e5fb543a9c9ed35a5465bba8b39c6fef9a54a5eab6ad64034ad058ac89b4160fd713de015b9e5bb7193de9fcb667d84097e25f3babf68e0e4f8b44c2443106df67ffeaf33f1e95f0e028b5674325e68be98e72ed8f6f0c37e67a9e7172c327211dbdbb7be22aaf7281692f41aa6946a02075f2e5cc4169e2e6578274ef03094026671efef2519d0613f7abdd83d46302bb8d576a7de49e256eca8a897abaa4511978766e421886550e2abac73481fc1842e840244ac0cc583eabe1278e57508630b63f4d26919ca46449d3e2b0d163f7649177b870438263d436cdaa09179636a12e68021ffbd5a4fe01f5f8bd528c7215bb39182ef0e2efee26be3726cfafc5f11bfc4f04420ec3ddd0c435377780a776c2c7cba3c674a2a86393525dec0d8241e2f38cba5178bf6a69304905732d20c3daf4afa4e2096d45b81af23fd67f36f5416b9833449be6b7afcb2af3a6fb84a354ebd1cf65e97960109a8592edefa75e7856628af80df4c46ede52742f0e56d94f6461f9f58cc89d335a9180f3f7c825d15d9fb1d393a867e1bb4a240dc24ea559ba3be7cf23c952cb7a5adf9f330a9128061168e9487d03d0dc1eb59750dcded51ced941e6be5861671b1d5d709c561746f1c8606b139e408da0d68b1e7ed357a5d48e44a3e7ca01cd48560c7081a89abe49e7c4fac606283d7a52125bf67286553c357a767da7782a5fe91c8fc9e6adcbb69e18dc0af017352e1962854ff00d795d8d7ea0d1b2f11ab9b40cd1ee9455aaf11aceaf53e94d5415b55a144e446d7960f8494a47b6eac455efb59dfc4e1acf00015cd2e5ea4a94758fe392481e2f0d7d55b7e333d8e052866e018e34be6db7116930fda7e9fd226bb58e7f66256762593ea7eef6b59d65bafd20da7d6aef1476077950bd6ae8680b1a49b3a801a75359fa3357482d40ecab2a35ebabd850fa075754de955175609f50979a6c0fcb7044d317b3cf879d6b77b6f5de13f38b21410461c0a3e8dfd242f4fc301611850bb7c546d4e61058c9ea09269b5f52487f92316b4b9a797d9200fbccb66e06decd9ad56f5ed0e5fca8571f2d99a7dbbca0a038404f072f515d32a4e24b530dc13f99738b81bf35052c99848967647e6000f96c8d5f850ea7c31e156bbe9ab66ca47fc041394e7b584d5b7e6fdf4c0de94a42db0fd4187084c347295f2a3c29b7093121817de035a35caf952df7ef7f92d60de21b4d3c636815c3379a476461745678ebaab90eaba3024c55564946e16fe85b37cc072026df243119bed4fa614b625d37eb056f5a0f192c19db6b09a9e063930465a03db3e1a542ba141f4e9c59c0b91b58ea97fc6046acf1aeaa7598173f94305742d161f129fef04af2de98007322d53122c9937d2a547d959df43baf26a6211eba9807225e143e7c04ce94bd659b7871f73b73c6b4cd6ac574bcb5bd27083ec1cb232b18c83e0b7ad7d0277fd36e9db280ee2a301631bcc14299913f338f08d80e66684ff98f9277ec9b9a92f94086b8c49315c9c16df268cbf232f3e705fbed449af22068ad4d4ab6cb458c3ca109258e4797ceeb9eb8dc93b4b36fd6b9d667ff8591bba8fdfc78ef9f0ae0c59e74a392362ba86a72bdc6e8843b29805f46dd39fe2f19aab01bf81f93ec49f7e78995b442ac59b7628ce407b3fb42b9e7b9a022e9e21af9df8a45c55f3927d307b489a668e0d1b742de65ef9fc7d4425baf4e53ac289f82f53dd0665107ed0f2073b9d1f0bfab626563e421b8256a112acca032d1832bce69c7143b04f57e08f426c99fd3cc6758e17e07af70961e108d7aab9410379933194ee1e4243dfc352182ed8ea2d95ad08c93c1d8e63a39e858124b5413c33c28a10b9425ac9584ab5a0894329822bc6bd68e3510027d789bf2394a8a26d8a649c3d51fab78b03d443f027cfd89e9d8276d4c610e5bafa5a0d50dfcab8a3adb784d6e0824685ed9fea1d6d418a9a24e168dc03d67d01491a404769932bbc46c374901af98ccf692e27490dcfffa2e600a135162837c1c0b808174c80fef12b72d156ced1ab5458496277ad7b9674355b938afa14d27f2e2d29f5f7e4bac9e03fd78651e2d98e6b0a90c5ad22497680e22a02f48b4c78e5514e4d83cd65e67f84bbba3cb06665b53a17ebdf045936583cc29e367ca16611f10a01a7d4fa79d584cbb028eaa21a3b62e7295f9afe30a9d0f336788023bf5af9e3b91e9c1d9744dc26686696635d3fe84e02cf835089b68cc7c3affbf1b28418ce99fd3cf1034f2f0613d51fbf80392ed18d9d37f156c42ea2890d33f403e81a2ccd03494864c52c27c39fd343c9a72a6aa6c3c66b608596c9a46b377e1dbb822e4771b0025650985564da5b5d0b1b92e01444339e3ecd07ad74ada1930bf4139f12d5a963ea4f4d3978d51f66ef65eeee22659b00864f81fa7c5850e369f41951819aea7343cbf9eff8a464315e2cb7b1c600bbb66bfb2534ac680f130adea096be370abec87b8e4cbea9df370f140ebfb0a5ed35bf5de10e5c690c70791b47f6be36e0882be42a7bac09ee42945243671ab2c1fd2a0c3250da139275ec8747279520bcd68b892eb8d9ad77c3e0fd5a9855b7c787b882b4fd6dc17f99fc949cf104a1ca4c7396371eabcae4fea5dc2648bc31270db7fdec3f85963ac290de7f693b6f66dc1a085d3d91af04447c1e6d4278e75a95fbe38f44b25ba0760a95279e4b36ccb3f876292bd63967cd692fc943a2d6d2687624509cee98ba1dea721e77cdd4cee30d78e46a259971e3370a7ada9cac4974fbc7c35a8f9c962522b523ad691fc0833232a059f3d2773f23370bb3f312c51cb468519200ff94046daf1e2a8cd9873cae97cab69b0b69adf516d0ce7e34906af15f09193538dd956f677c991abfe9ed8e9e4adf7b2fb9c50d8f6476595d2de4757e9541a887a0095f0d6d69de75101eea4b9910176b0706fc054f819887b44c4dfa78278b416c94aab1f08b3e5a981fae843c6f7626eef34fc2896f70c0abad57a2810ab66e38475058426bf4509b2f2d1cc773916554d961bb774ac14d6f0ddc33e23370053506f380ff090870dbea15065648424afd6e72c9be4b9f10a86087943cf4c3a2898099215c1da574285d84df7b8d9fb877747cbc79b27ee8ef7c57faf2d0a0a9d467ddc8c7a71ec4a5e9f8af792ff89621267d114667a49fb1daee19cbab12e9e41b04bb0e4fa556d170c45981fcfcbe198a44c0ca0fb6a502f477839d41c420630c15920704e6f7210910fd1422d0c79a8801d56e399ef535454037d96b3279b3a40250d36297dd6ba15d2b8c9cbb7e6a95e452bd0af02c5c253651d89f39a03cb9c136019097bcf3262a7b9b20f36a7fde9eac2c9b637f98394d2988e98dc355b922bc01855b63d2699128dc15ec4e14da6045a846cb33a5c5eb762bda8a6cd63e8c9634bd3a4e83556815bad57bf4385323ee4087db3acbe01ee4aaff5865d5186f93c4300629c3bb3cf3f4ffbfd5232c841c00b0db5e6f9682f4c6645ba608059bbb4fdcada60ebc15acac995d12f3f59cbdb23dc460fab7626e344a8623c91cac895f56b9e32d7b373ae107d5561f24aad5b6127bbf3d19e7f97e56c4ffbe76ddd957cd9a1cb8d67e8e3c6a5f8035ef614e9a164c46430028394b6cafa1582b8acfa83da2948a9e5bf221c38152868ffeee5ac3f3f6dbdefc9e9df7441a16fde1c8db9b9f963beb89da83d3401faa067ba321af68f45835dc8aca79bcefe043adc5f850e201bd9558d61b1e1c26a40c8a36c0b39f6b219d3e74e7a0bd784d73f6e898a5e3155cc75629261cdfbe298cc8356d3cc0250b4cd4debcafcdf95d484ddf7d07b06c698c2e8b0d3dcec2e11bff95bd8a7a207e18d3ae2fbe5c7075ac25a3fd6de7b7735d4bccf31d678b04aad54b5a29c2e40f8a9da07a32f7cba2a8aba68903408973c234e0571d4b390ddedbd9ac96552b2eaea81c5ce3fec868c249b8f732922846e786f5146335b63dbf2c7466f07a0be360cbb9f19de7b095b1edd7a007a02986f2e2569c792865a0bbb77bfdf0aa4798c3aa9b22e4016bdce9dc87da633e98ab64f65d43ae4dfed6e37b6a9dcd72bbf9830d2059ced31aa88f4de09ed8ce37fb8461c1147519bea14e28dbf26f0439422616e02a6b2afc74f12ad2ba70fd493d385c2a957d1b93a846a9d4e82e4871c4480f707ba80f3c19f6bed86c4dddaceacc61fee80e7da60252f04bd22a891cce5a9916a59b276107ea2b6d168a28f40d17329de5b9282162d091855fe563e6f551a9195034aee070be71e2bc623788991059a30ac48d2db0269100e247c5489d7464b34bb58357d12e3b66b80360bd3c900832e399d16648655f1aa0a75a03584b5f978b47a12cb7f87bec6d10142d4a757ed98bdbe256f0d3d5b7191dffea4ac8a3756462630d7cd9db293b33f65f23171c3e7a1a6e4df3adf35a1ee99dc494624e18db58c1e779446256994d8126b5ae3e6b16970d6104a284a30560009d00587eaba1f8c30e9b389e97b9095c3994db10d397ca24525388d57da20bacfa827805b1f16eed5213cf2c3880ac0d5531dd829dab60deac5b84b76d35c269655ad2393c5dc6164235631a8388bf95b29eb8dfc1b11547a301b4c651937b9a3edd294edb26555f254399910a2803f1d18db510163b56ef084f9e42543f78fedc7101900aa4bc73f2ac4f6c2690cb23853eb90e992c527b668ecd31d1f4e94bf9566ce626bf5af3a609df1f626712fb1192a3fe7f09230f0995b967cc1b25a6907f790b0d20bbf1ae4b6e1eddb28b648b0016e12127a4a77ba3b94665872ec527922ca06ffe39cc9f7deb2be96bce12cb23d40b54214b4e343d041a11e9d86050e7dfe8bf3ef4053d171c8be4ecba46ac6d6c5c3ca7d6b5979e46fcab6f6a975b41bbe5076e8b1c1ccf7e0090517bdbcb560095aa16bee919c62b619e62f76907ae1f00e156b0632e1027056c01bb4e68ca75a4597a042731773edc3025ff6dbac9bc272265529f69d80fee21769ab13c9b095a4ba19a04a529328408532b17592c0617f7b60b6a4e2213784cfe268753d82d5379f7514867470a6c2c754eeed77d74902511614a6846d46adde9d6b6ccc61ef069f5fe1997c7aef1ed11d05711d3bd8bb10cb7b1f95ee02f7431b2b0b172dc3813a278eff487ae9e57681c360163dd79bf01a1f3581c195cb40851f7b125baf816ad789f2876822b8edd13001d2c9eeb550b257323d1820d8169263ba98a5e4a7f7574284c2e2378d4bef7e5a1fa1b33906c8de3860bbd3d834b729cb119fceda34a42ac86ee5ccc475f2758fb22d3227ee02075c13b2bdde964c1581213fc1ddee398fd2bd6fe2844c8376f9f182b4b63a75de428022ec40a8d2bbac16d853382e1619efce3b9699716c7ef9750e8669196ec4602cb64c0e5a9176ab9344607b4711c7851a58fb5290c6da702bd41d3477c2d6f0ed88a04787a907d084053e9e3b655691f9cca87b7c539138116b99f136d8fe30d75d34a85293b5f09069bb635789e4e435b4ae2c1486411530b42f93afdea9faa9bc28c4bf37691cfc1799f6cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
