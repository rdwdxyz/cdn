<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b6b3c0cf62155bbde00a17549c4b2d7c14b9754e266eaf8bf8b62bd77b768962526222e3aca9fd44e291c3748e608cd1061e956a3002fa4c45ef56828e4c1a3a46445985bfdc2ce921e4cd109aa0c0af2b53f68735cfa0640b67461d046d5db4087e47f1709bbd861d697288b2aea3ccfa49e82021ef431e63cde1db618e983139f15a558fb216bbc89da9841e981a923cebde1575ae6f5af60dbdd26c1dcf6e86cc5955a5e44e23accb17b63127f3cddad400f005f888f32c8d0638e8c90692a73c649a348099c7d97b6e91a6ea150c94b727c9749dcbdce89f9cf5c00f97032fa38a47b2920696d88db77cb9bb93251bb60c3a31941d03596094f8542749eb725f33b70f139f96d22e80675f3d72eb887c899e1917846b67a8ff07c1edc711723167293553a05dbea799561d253e27e23caec2153014284c213dffa03e119847c4fdcc3b1602c7e5b1bad612d101a66c77c65e0e341432c02a1ebc64b80aae97042a7c717221814569485d0f67e716e5952998b7b26c34deaf9ae4dd12ebd618ca491fc603b473141a3abe4ec56472eeb1f441cc074b0b4ed9c788f2233e72a6dcbbeeb85431d132875423d70f2bcebbefad995c6f8398f1cb07a894186b820c999e0bebaa5144a5f9e47f5a47d70945b1594c4b43ead33a18e528b5eba0f5471db73626c7533d2b4ed05c90546a8dcb218e0a436218c939ad6aa2a231cdba49272eef12c57ff6ebe21a2809a345b7d8c31ab5fb8fe88f96e4683af17343df21a6340f060ad4a5fa195bc88382f57a354a1796420f90722560ce1963a29f86d8471f610d07b17abff3ca5c08f49cae94cd4a7ebbc05e9aba8701b097388501cabc395d58728c6227c6d7f6cc90b272fdb3e33d46293a941c986cf5b52837957f60a220c185fe729f84ec6043581823f71aa4c085fbe5dd40931bbd6aec66a39dc2072c82d44d76820600e2ff993df8c7b7115ed8db6d76b7d8d42c30b9b94bc59d33d3e400c66eebb2db7d6d208f4f6e37159847db14aa206229e8bb99b034c06f81b5b91b1b0ac08756209061c7637ec0fd690a1ac711bcc8205229115925a9450c0fb3a14197cf04ebef71a186708608065243b9569fe539944275fad5cc146bf868e6692a7c74491761b8e36d5b1b98acdd218b10859bb5460d187dff147bc1c4fa0947e94a11749fc88c0a07d46770b6f6f12ff7e9ca386d3c4e163a9bf795ebf056ac5d47568a48de2f624c5ede7e51120b0fb0b23f75d9445408589bb280eb8d17fb3e23a67ea02124b77230418a8577bf60a127dc9262c95f949c5d934fcf0108eb8b8b25244954adf4962695be0c3ca5f56871da16fa088164fb689e3bf835fd3dd0732f4d6fff960b5e5c3d173053fbe861525b4d7927f2a7453365d2292ac496c820fe1c1e3831bcaefaeffd659bb3a5af6001912a9a67406f13285f9b59a1026b8af520e3c45d792aeaf7b49295874ecc4982cff6ac2f3ccf206a53c6007c4f65acf6a51c4567653abc491afd19918f1146794b7a74a4bf88d8c50e517f382c18d99991d94230ae2840c4d057e8edfa33a5283fc6a7943715dc922d4478596c4754af41641d1f649a291c557e6b1addc6c1797a9f1cc39e40c5f1e66fbf000c3e8bbf70c17fdd99bdfedfaf747da3080528bac8fdc7544bfe2d6fa1e1f25236f55682be5369122d6747cffc687a915cccfd2d5341585b6a38f19e1c4ab35c98c19b0fecc0ee407e51a39a7377eb9f12f8558134d02b28f9ef746225f814163a69ab2097d83eb1a3f41d3a14bb62afa466da26e0dc3ef9f2c8e9380e568fa4245a3c4effb82b0a77fb256dd9953e65465bfa90d1502480016ab61b136e15a9bd01d95895a4602c2bcfbfaa8647f4ed7a879f6407a3463ca659014a9f73747e892f157b268472493c3801688c6f97ecadbbb97b7dc9ab21296f88a0da708ac57cfc6951beeeda3ccae3094e0ee43f6560c5733505dbf78a108c071ec7d5eaa2a4a7aa767d170796dffde32c73b0dcd8ce4cd4cb92875e1078ebf2a7ad86abbea2e50475a672031a1ebf967b05dfb9fa2bf98885fa5c39a369a0297acd1a99c44d3cf9ac3aa16ab342e48c0add75095613a719bc7c400f48d5abcbf0648af6bdc7a2bd4edc2b69e624ef1021fdcb2b0ce16c6d8def21f73bb85138949e873b16a3574dd84e0db707fb9606ffcf9c3f1b744ec46e5d41d8afa170a1508037658480d5791bbd2dceabb4c1188db04ce8edeca9af4722f5790de381633b35dbc9d98ba4539e854acfc9fc09c5b25218a8ed4fe7aeb7e028d8d321ac232981d624a8426df44e7404d1dd63e299021df38f2ea3625c4eb6abf7e5f4ba4c9fcfb72a099d43ebf35ba6d7ea838337af3391a8237f98ec7780a315ad538b61c61cd920191a7ce2c7c9d5a8b5f55936320bc453001fe49ccf779875a06fc14f69473df936a2257b25b28a01ab9cb5ef288072cb47a52cae8d6b4d0d9d512a0c4a3aa8c18faa05101c975b8c38e13edfd4e342c50268cbfa5afd9095c4382cf4a7b891acdc732df69944ed7a0a7b51fe5906a854174c12e2601b2184ab44fdfed6990c4f34738541fad058fc72671ce4efd73b063d6f7c932bec90fd124effb3121ace2f29c4d17b1c904e943e04b0e54aecd454ab271aa63c486b4666fb02d9fe7c3f98dfcbf9454871f16ade2ae4689c70d5088cd8dd6e3caf8e07ceb1e452e4527a339cea43cf7676b88a93c04b658f0709ed220f17964637cb6d682f6a5d24a24ed8231c226b930e5e996082c68ae3e622dbcd93d3b92cf83091734063d7b22ed7593bada826bf0b698723ad07573a3b608caed5d8bc03fee4b27d6e9431ac3792f8463198510ee4694139e1dbab7066bb9cc3ae2e71178f98d38b23f4daefa901638c152d8885a02c5c1f2357c2267ba1cc8acf3aadb85bdd8aee5f5c4b938bcf611839e0611bf33f3202d9bd33750aafdf4db72b8b397c5ee11d3022643df12d167ecd54481dfa914de3d7e479a324844417eda01a0a7b9b0031dd7eb177d678d7acf64cac9ab43ae22f44f23924bd76928d6da5549a98178298c1795accb883659d8ee497d1635d4362cb0b776e0b00ab349b595c2c820c5308a87c3d4ebdb2e2536d03358f5cc120b0bb114409b188637a863cc0ce67976ef31d91f5c7daac7d7cc6974232893e1a85692d07ab6c64ddfc723f80214f5cf63a22e3caa657537c34dd90eade39698f5e054fc28b55b80921db139ed49bfeff81e673cf4680e2b9656306a5f6aa28ed25c82f19766b258b9565b9ac498157e294f38e99446ba1c990830692510acf0b0d17fce4399ce51259def1d02ddc1b63e37a4a3a5c04eda05050ee316f2adac7d96cb225d5bda86e3d9c921e7d8653923a20eb88c36fb6b337d2cb0b48d008c0c071ecccee2adffbac5858d33ea4d5933cfded12377c4726786257e98479c8dc69c93b2d292b4a3df3562d4981df505725ff27694e3ae1992bba1d348811049715830876836e524e732f497b3ca8dde651d82cbb0e5a7b015417338de7769007d14a56889f1c13734dc2d943534e38db204105546618630ce084953b20e08087b59175e26a470547ec7f6b2ab4c981332ee60c02e654161cfacfd18dfe721054a8191111085e64cdab1dc0b292dde62d454ce26b4f43e9c3148074439fb6f990fef476e18ace11552c33df99c76b4010451584d1ac0fb82d3ff5e331c1361de8e9f6a563c7dd10460596b8ade3acbc7def6edb5a1b8241355b02b5fa127ee68c70e9e3148ad6cfd2b3fde4a77c351d44cab13f3f8bb4ea7903f1fcdf02a761e500257d5e19135777607b39565d8829d6f7db353fc5f483be06cc807487740a21a8285405ce40e4ca6d2d5bc1d98d69f285ff4df009142f53b600d42d0d2bb0e7c00b5477019f74303f072f7a7fd14b965e0918183ea7efd852e1ac3df31b69d72cc1f14127967bf001e77329d53a3b3be17efc34e6ef6898280522290040bcea68d709b118a2989c49671fd52b7d2ed16de414f2813fdb0fc5f556f428f764bc158bd2824544c8dbd521f07ba8d05a3c8445fb5296b896d273ab538154b6f32df4cfa4188cbbceb8a184806977173316e66e13ce65416aabf12f558c8e5538ad5c32dc5400a0ed5521516f6c9629980825aae67b2d0b03a70e1f02462d30a4f3bfc8d7c9e36b6a5834a1ea72384d207e8e375f4cad6a98579c4a095ce36b5f35e993e898a5f8789bc4b2b68deeae52bab6f767c42652a69246ea4c9eb065e3e57b1b331fb6793e240793cdc905d141b1454af4e5217f945e81236ee747ef9b4b63851238e0f34345cd00cc1fd4315a4425b41010ebea2626e1e45c201b638c8b0f1d4990a1d78b3108d1a0136133e8618f25eb6acbea8ff708f6d29094692cf9ba8452e42718dff217696ea230ba4e55cb3f7a4960edce698539b930580aabcf3219f9db47b89e3552b7fd32e822aee2b09cfdf607120b794015d59dd564f806bf48612b914fbb26f0619f473ff0336b4a637007869af07cdcf43aeddbfab7502bf6d8f6fc77be233986aa21f3cb1a948d207fe108e365427f1a19a45a69c18f33714e184c9f7b6be04a24c15e55507ccf7fc62cef283ae3179c13934d5d419a25eaf3108518f6972a1fe1f17c429ccf5ea12bb2350f7a6feb675b7a1fcf61a68b2a6409e4498fa5c458d4b4c0b02ba664262c5c9162554b53cdcd27c7815ec95b79b7cd0b35c26ed2c2fbeb90313fcb2f23cdfcb4a5eb5bef4702a9138ef18e197707df88fb5297be4a7d07ad3ab80b5beb418266bc7b4886241f7041a4105df8e3e311ea8eec53893fdeb0eb7754fbbf986c3e307cf792594bbd796c494e2fb81e6148ad743e9298ccaa01dfc2509aaac79373416f5cd1b9323a2eddadedb02705748a8d4d87103c8f7f83bd27673456be6862350b096a4669055169f85713269ffc650548893ff6da497a1ab8fa8b7c9386a55f674993135ecfa407d1b517f5d53d021dcdebec90b30c1ee4cf48e5be765a4711821ee1b5fd14eb036ed605626ca068a12f47c7269e0f42517101094dff5a9b38a480f9c579cf56df2baa962c8ab86d66fd33ff0728ed1f3ff188886d75078c95600a7d0a671295d1246df059850f2a3d23862e0d5a7f11a93c15a4c88cdf8ef40d27e27f254cf9d6f4d7951544aa840a4b2b1cf3a1e2da8affff0d90b8cffb10f24b236a75e2dc30122b0aff77bec1c2e81dd45e4ff2ff766b372054f70297acfa65129a9ab2a987a1d159343f54d700ca85b640679e48f94c4b1e14a224b5dac8e4319a4ccc7f651bc58bfac89defa1ff505d07b2e97efdc92ab0a13c64c3938a2b91ff2d270f994fe1a07f1ecc624dddb7d03e8b26ca3b4c32f3110217ee1d3de8357024aeebec5a57a9416ce80fbddbc75d93d8af40ea83dc26526faca7bfda1a2d61ee3600342eb77f484d78d8bdbb25c2e267e48da6c8bc7f5c64b6d36266773e968ecc7e43956f90ce785b075462ea66b786655ce3cd036bcbbd5a28d4e1b2ad97c8f2308739807ac3867f1e9d2693e8a3d7c0ac90a49359ddd8da9a7a6adb72e1bffce530fdc782b263dad05a4e36350c9dac484fbe7c6a64182bcdd6a9d4684410b20bd9d24687db487ac13c0a3206db170cf333e50d52a41597aea1f9b2e4ba5934c44feb693ee4b6ff2e7f472c39f13e62cd0d279c94caee45f8d8b4690ec2e86b0b3843ce9fcc0e03701ff6dd5e7340d7da9c507f4bb08fb82ea1977703934284f5d918578d6967dd35650f447e7293ff671a784777d0b57d28a5b2a2555f429393c9031cf3cc70900f5b3b92118468bc6d863349ebbb3d450e53c8027df390b4eb78d32e3dbdaed676d28438dac0275a7248051dcbc1e85a1e1222a97ece09a526a325317f5941565d202c2f4266feb9b512e470e4dd4c32bb272b4c32b44dc704db1b3fc74213e33d7ffcd6ca3c6c78cfb01820e0de98e4d4347504cdb1e2c1268fab7d0fa6f768b039c3752f899315ee96dc9278ca2b6534c79df883a64e6dfd3eac0b9290e1caa38126ea0ecb182aefb575545edadbc8d9c16f603280c0075e75d988778ea0de3076c5a8729571afd6685e085d4968c474fcecebebdc70a9856697ab973f6d48cc84302a0c0ac36f139c77398af591c2e6f6a097adeb48f6e090a60eff096d0703257d884cf11d7cabe2144086ab6ef919ba9f671f9c0979fcad97c1d981047f9c17c5f75b0d7a9c44c104feb9769f8cd974ec721f293ec665f76e8e250c02cb90c68305190e37379db9380e400e8114413963b2603fe6b2f55a92be62193608aa752c2817f9e1c2d1cdfb4645a2e063807e241298dc66716a433dcf3a3f1fa15d3e4462e3c3d9664441efdf767baf02901dde2555f09d945c8c2bf7df4eb30f7338c5f97f0b563b2601ad2c8015474ca07361a950901b7095a4a80c06f983e6b774b0ab96a3adffeb5bc856cbae05c3c46d0e88bd13a7251063cb4ff999f1981a7a3fe0bdb857d04d97aded85252dd3a61f862475ab088168bd7fef1d3ef86ea43382d4b53d9e8ab1cc876f1ccd2daca0dacefa4b1953b6635c6fd26396e55722cd9939cef65b271696495d2910b5ad36f8a61213c5ad684a7b878c20b8a507b510199a107cecd28a552f54a639862e882303847863f8667a38d4bd4855a1fcd0b6f485c583e16177ad3abae88f630dfcf99c1134820fe54c04c6ebbd7d9a0d1730fef94f6eff099a63000291e3150284605aeda838133eaeea47b6c476bc72a3115ca20774d46e14b26e69aaf1b2c569ce235cb841cb1c4d05630abc9e8b29d51c4aed6cfaa31136f5daf00db1a221fea3b0d4bab2b38e7ee7539ce4371166f6aabb0ef49ce65e3a093b0e625fbdff9a3501eb97a31587ee3cb756a64d7692952085e35152016dda116b3719d4422aef367e2f91c3c452daa7e7f6fccebb2dd464d2519ec2b4758938ad106803d44c67e18c023055d531c6c20411839ff2ae2a3e3ce42d7ff3a6e8f3f704e3acc90ab94900bdd27902523dfa04ca1e59d9bb946e2e1c107e6fd5f54e81aa66c4cc6580c830647a6f7ade67865f3ec0f541ab873d40e017016ee9254fe09869fbee7782929b5957d23137cff6fd32b1f0807331192ae59b64993425c29d6852039e1fe0b5e13f4a56c03a9c231f97827925c2a70cf3c0d0caa6d867ba09291d685a2b83a7fed56f13d825e8a98b33cf07a8beccab1ce7ef3495a21bb368d14fddb8482392c4276ac004c431c737ebda8e46e3e39fca5099f9aa3373f142008480aa5fa6b30e82edcdacf5eb6c5085280487a30beff46a3c46c3134f216d51e82a2a6ef1be7bd3cbe92ce4f1bce9cda2010f5e9ac474b51f3b0db4f104ae0b0d4dfb929d43a628d8edea674cde4687d7ed45590be4682ea36fc8582de3487bcfeeeb94856b447858a238c30a8568fb8799bfe7f71bc79d5d298a754a1f25074835c6e26152520f241726cea61eaa04312718b0f0d50b7d27df863df1ca9fc5c6b129ade782dc5919155a7cc58e340484501bdc8c678ed19971be0cf8f7e0b132c4c25e5f8171fef2c9fde41cc0d8e579974cfd31549b13a5fd7eb4bf55b95cc8a273c6338361e927e13ecf782ce4e80a6facdb50143dac65f087c45ea51b5a20c1bf1159a933e3fc2b9b33d414cd3050f154873fa60492f4f6e6d627b7054e96c481fcc4371a225d02f6961ee1aab0cda60504c39a007a2b72248225e1845f1279febe2def15f2738b36e12a26b884004135d945f98056d3cc99ea932d4ee14ab2df28ab8df478351802aa43137cfc5ca7c3b5bc8c7c4350926c3f0460a27cab77b169448a5a10bb2947ddd9508e2ce0595a9425150512db214cfb20fe72f8eabdde94cfde33598967e02b9d9fe0793afde89c666da4067f90043c4b71ef62b9713fd5ad0c9c22e99a54eaa28974f1879bfff840eb556d229b19bf2fb025b13670a7bd10c874e5b89ff1826d5b50963162af2a7bb59ca4996b9e9b641ec8f7f9c21909faf6aa93297772b0768c606841a143fa6860734924965199f5e10573c196f644e788a889a1e2434bc66e4688710b10c799d6a641188a5f0b45441f840738cfa190104faf86c7ec62e5cdc75aca5b87b9426ade090d4138f27cc08a8854865e007c0064e1438a155c25324d054012ced66c3d9af64546b42abbdc76cf3b1dd1b534a67ec8474bdbe9f9c9535841d5b3e1ae3b9f67754389310fbcc9a63725c4e9eb6342cb5cfa267c7994d2a078ddfc99e00ec21936e9a2398bcc3169dff3a47f62a459fa716209581078a6202b192c15637d712ba990e7c8048b1ad415db61910b3026e1026674b884d5f168e2a712e1a9238750e20c0328abbc65a6036759725843fe43b069daa033691371a3e33583de71e3900acfbdbe5ce76e8dff5d4aafacad05eb271c44ba192762fc33744683bb12372c20a531e0d8d97ae799cbf6dad2efbc211cf98c05be5df3ade62be8b6b11cfdbfc24496a56954dc44d244b7c949bfcfd92587d80611a5f503733c7a194c0f724b357eda64b80ba64edf86e430cb08aed0809aae6a6dd5120633cf616a83d3d82f1ec7e218e359a11cf5062adf8733f52f0c2411250bec3d5f897b6d3c7cf02ddf1918218323bfe626a9187f6a557fb671a8911d4fe20ab8717822780bf035b24f72df11dc78dffa302e3b0bb8ffa178c09b15f477b9d28376d57878e3467a042557cceebe676f45458a0ba02008e3e29718a4c78ce70ce202b2b5ed594f05e5bde5314ff2a2e3a8befc831d3beb17f3d8d2930c80b6b896a23b0871df8af84dc9c11cbe0c833bb04a7ee58cbd95bd09f15dbf99ca748e59ff75bb07e1ef234f8ba27b06a32b1e318f19c64dc6e36cef84f8d99980eb33438dc6e12437e7b0486a6fd48717f6217f4a40dbd2718c86e2cd2db077cdb606b0c9c4fec3eb8436aae634e849254c57166c794f358aae0a660d1104c6414da14c19a717340e98830bf46bd5648b5b224782d83f7ed3249052ce2970e079f7e8c167c3710dcff7a5d69b21352ced4e40e304c827258b9bcf96d49295919289c3fc0fdc1d4bbd13943e387566038c6de0dff7492edbf10f6e0b7a99e64827a2f82828e4bbdbf742a636405b9d52f815ace778210cf7b78873d7474faaef7f780e8585a99a0d64e6b4fdbca0d069c5c16cb7ea62d20bc316db0049e8e24253e5c5db19de9cb82b92b3232024d6fc6fe9114a230d8658cc8c586a1b10c9d8ec36d2cdc3b1ba0d1f0dc8656ec0afda099c2d06991ed28a341893484ecb17be7da44122f5d825fe4dee4513fc46b1d7291ce6bf381fd6b6af960b3233e5f1b5771043fa0a8ce8d3628b5be09d74dae9f78eb6a329f6f971744eed331501dfd18ca2c30be7f31ca4719de4be942a63801a29e6a8581bee3a23f1d7b6fcd2faf84b0a594429f19df5677ca5aa5b85554b38a45fbf1c512dfe17ee82214a912158a7a38aedbded13c640f06ca80dd4ecfd79c9c59b7476719c35d0c625f9ad365dd42054003f3338f3a9e1ab5e41d5191b431ab54a25de5729960b91198aa7fc12d970337ce70a74b19047d829d74ca1bce75c882fca0085ea95aef1f62efb0b729777a3e76fd97c6690c6371ac826f45bbe624ca5daa4a99057020aa693887789df0681d671afc686ab9bc889eb945d6ed0a9f4bd5158b8471ed49c2a7b15c490c5b1a16020852aaf063b4b2d155febe00506fa21a36f6031ddac384e2ed00d5110969f0a5c13ced61ce14fb27658568dcf42817a4ef743431e246579f8656a33ebef248b8cdcccb6479f51549bf5e382ca70ac1c5644e4c3006e4f8239a820725114c50792de8382f45b2c7c08c3246b89757b93e543626ea7453fb7a3883f2f7fdd31715ffce60726369dee7c7cc035ba09d07e4bc5afbd0c7f5a68abdf41b340b723eae4d4645ad3474b3c37cf68541aa5e76eb1c3c7b6b53e0dbf55943603e70bf4f3eba158943e3ca43aec3794008ca67bdc5b415834e23fa2822b60bd2498ac66666701869cfe5992d3172911984a5863a022ca1f11359710ebfd4e7334eae6827428510e85bb484cc798a9d73db14ea1f5b45eebf1fd63e3358e5affb644dbc407778e306f20418a31fcc6bc0398662287de21ebcfd5516dd883a36c900b639cb41b8d4fb04925baa8dffabc4fde0b6f18a848344e4bcb7240f039097b556ab793a00c52244a0b614917adbcac0c4a697d2ab05f9bcb21265bfb3e9934f04c96bfa0b79160ae2f13034f2becb1b1f74801394ea001f11f18b30379acb6c4e8c53468ab544f1f662af654c04f4f6505af5abce7b52f11bfe62282707dba62ef35c3b188613ec8f8957e5c3d244edc7db6857bb9001af397a7fafb404e4a7fa7327094b27d1649a926ab7be9d9c6c6a4d9c57d2a0ebe79acdb2319b63d585ee878100c93ffe3eed209bdfab65b00afdca490b3e40dd536fb6a65ac7bf976581c8b2d2fb50ea018429d68666f30dba737cbdf0b1e9dee65988ccf4e342087c440215563acdfdc087ae9e62028e15768856b1305249bd60c35491ab3808c46a2f336d579ddfb4e454b781aee39766885e77e732f0613dde2c0bf749efe24891c5346109fccdff49adc2225c58101583891a6f72df846a444b52a7c4ef2b07630df422e6a249bc84b5af92acce35fe4a3539c37f3efebd2c9f486918d59026928f41f81ac4f6e410e4f2cc6c28879ad2cbcc53c5bdab9279121d3a731a6f053143dfdf7d828109e980905831549a8432a09c77cb0beaffe1ecaccd315040b04c351f71e866044320b9c119c9fe23ae1cbb031468e613f43089bc5f4a01cc7ec4849a6c081a5a1d0064d2e2c5f47b0138ccff51037de159938a9ce6a09fb8b758ae10c43cf35cdd6b91356463e562c99a53ae17c53ff58a684ecd13e3fa4b71012b9a89a47d4b5960ddaa336ec0f59697ba467986db8eaae12d4e568e1ad67c49dc88dffb48411de1b297cc3b1172a252619849b57065a1d642f06dfba0ec9d8154253f9c1befd70c174cb816973908df26cca8431851f81f81012ca73a5239f545efc7ef9fb2779eb323a86d0208cb1b7a526075bb1e6ebc62a9b1e997f195cd4e7fa88606c26538dbb935d05dd61295f5bff55bb267c03d22a45a48d1af9b802825c83b3c943ab05878892a9bbf4d8039f350b44461b908b9902ccd7a5e70fb791a3614c3fa822ae7adc2d8b98fe0cba0034f5fb58fe6a954cf0760aa4f5af81661a166c6cc1cc96222027d22fb6bc97ac61ae6a8e101e7088b8719f77331e13dcdffa40d36d2e7ad409f41f785bbe73754730a31d61a9d11f55863d29233ea97027e7e6909dec68cb3b706623f0125d8f6ad697d98ada2c125122756f29460234d7c3bd29bb72db59c5a28db42c1b578d7b83db0a14c1d3bfa9a77ee30e7f9aa60a4a7275d13a61a5c897f4d9cc9a269fb5f8321c61fd875370207936d05a78134164b871dc12e1402f37ef7aaac26b8d72ea570de21a770e6edfd154b319a040343cc6e205d9f62fb397dd3bf00080c37386e6ffa835701cc12264c7c87f023d39e1a88006c7b0f12c678d514651c48fb29be14d102502e5cb0822b20c5973b3e470662554194b932b164048a9e27fa808f1bbf6e59f0dd69bb42548e583415527809a1373a7074063e2ec7122ff7d5cb6d29558ed42f1e773886e9f637684e05b8b1ab968e00859fa2673dd28aef7eb2020955af6271e3e2a9e054b3b189dd5d0437d3ef6df49a5c11daeb45c1e4d913db4b490ef6233fd289b7da4b1adbf3147b776f21995564a0f22070177842f28fda09bfd4dbaad8f3afcd97d749e5c4444d34728820296169a1ac56b947effb8f8db6a3e2e34b175591f72e1cd62b650550b084567283aa05880e5f55ad86944de81b01a3093ccb9c614779e4f72c7e0bc1539eed91e52f15db32bf2807a883d24b15a80a0973ff3035c7d0bf3bac430ae79fbbd71290de159b84f112cdd13ac06c70fba5c09c9528bcf729988ffd5fa1561a57f35f48cd67f6b3fae3bb3cd6fd2f60d0b40cf0dd7b6d098ff40e046fa37026d22c2720ef7877ce4ba05569392d0c69f22ab5bfcd45602bf668be71e1b26b4404de83c9846a9ff7246795254010346719668ab906aa12d2280bdcea86253dda8aa6b20b75d9c74b9b9f2f2f70c4948fcfba00ae41c56404e3da0dd8788f896b1dc6778e011b4fb59043d0e1a674801b87d1c9ca7c5289db8bdf36df60d9b18e868e8770b896bbd983d7be789390416ad4d851303fefade556b0c350cddc4dae8b9bb1d233ebcd5888668e5484bfb6a005770e956dcba8dac6db8e2a1744205d6086297121f503e4c75b9bcb9fd5c2d26553f327086358b6d8f6148df02ecb225e0c0127e33225b9013b642b7b0d841318bb69eabbb997f7135ce94bb74bea0783f1aee4333c6017c30dc961e50ebd70f735352f8a16ef2a1ea9b481b9e3338152aa021f94d8e28f82638d5e131e55cfaffb65b15e97b7d9b896fe00d1efe5ffa9dafba0cd92e4c66b45d1cc4047035cfff34e73e0bf5aabe352dfb8cb3081a770129949d74920bd9cde54d70b5e7a2663a3134b03257250ce5456f906b308ebe0cd86ade3ad7535b0ee20e0db26a37568993c1647a6c36720e1f00a39e0007436e50261e120eef221a9632f9585d39b6837926a8eb90c252e5f9a10d8987dc055f8e933d126beb9bed9b999728f9f5355ea67a9c910cc70b57155e2d91ec67667fdcfdb6cb4aeef92c86ada874bc7bf612da5fb440d008ade4e951a8dad3ec015c04ca093e64df34c55a3bced7b7a925bb345326955c1a301cfec4885042f2ca13d9e47157b2143e4b70cb9cc6077974e36d1a36a31c6dd88b4bcae72961ba886a1baf368a1e97051c964947dea2f96f573ddc7ce61f174a067ae8bda36adface98ee75b04f82f3a3ae8725da49c530795428ec1ecb074f487c7100e2099b54413015045c911c5abcfd6c0bd8fbd50fbdcddc8162fdcf531e351507030437ea46b2c81e837e613e959578d225e3cc2b2834ec77446094f15b74853b58c7226652760f8c6929e3ff6449dbb713829c3de3a442ca1bf377114c02e2c8e645ae1ebb37abaa27d97a6c5a996ad076cffe6c8d31a05d71f3d7c9d72cc94c0200a0bf99b9305d45e3025362729612607b7bd6012fe59af76cd7afaf9951bd85a0ba0d233389245c844621cf8ad043378c44e7bcf0401be96214e9862cf709dc4e689a4e80e13976c267af0954ad1e99c06334f1b5eeba80fe25c5e880724fe0599fae64fa094ea9b6736b496bf1a7ce8412613a63dac64cbe4fef5cff70b4bb24b9f8729531fb1307b03ec85096bb76bb457836dcdab06542a6b832c81ceb8e8199de8e6c47bbe7919251ef21678c140c800f96e205581f13e2920b8dee86198fd67e3ab8eec0080ccb2c0d91d77e0f52fb7e28445bfaa02751963ac4ab0a3c27eb07d84ef979a0541cf58b3a99750bb6cb1f3658a3de34924508d59d98c9ec4260686065053c67e071a8d829da715da912d1e1dcf997463f7055945edc040347371a16e95143d3fb6e6f8322e28512294c43af9a11a94317dc79b831aa9bb70f80afe2244982744e9245d6c6efddce9d854fcc6e7ccf4d5ffed1e6c13a1a92e68ff470942b0255f25a55f61271aa72bc8940c31a681dd181549ef3b4d42a43aa2fdc66fe8365a6af8f9d2d7c25920e6f2064b50d58fc067ad87bba2a887edde68ba004139aada8ca9759c81d8e64e9974075c357a1d93ee30bce727e1c7694cce950fda6fba5eb9094f12db156584f47cb495d7adb2a339b3a8fa555bd47243d61f2b3b4839093ed802dee2423a3089044b16d9dfc7f4fcacfed072622178b63109452f3df00c5613682c0c880375feff409bddd184c99e1a64feb33de441531d6c9e19bb8c0696a838134be2b370763944a47aeafe5ab92378684d9c76b8d5f9fe0b2d21e0a32554c9f1acf644fb41e8cc440ff043b20a1cc725d2735334c49085edc5b1a5cd89157c51fc7b971356587bdb9b9108b48d9efbd5f141f553670daae5836881593e50accd8f952e95a4add5152468b40265dbd95e12a946f56dc10d1c44a4df8f5853d64cda6fdfdc331781c8f0f966f9ee82ca9ae867e476246c5e4944f6f3d9c58c38619f158551d30a50ca0c3e85555903b974c6e7672e3ad2a78504810c5e151c63caa8dfd613534324aee3aa319658180a59b156cefa74a557d1c3699e44fd7eb65fff00b35cb5020afa4c43dde9e283addd2673b5725ace94f5b82793edbbc2bd0c6e0acfa3f6125a58d3566649bacdb940c61343d2b8e6b269a9b7b12cdb08fcaa8d5586cb3860ba4519da70828b92914fbf5fb18cf1934eeac5aa465f3f4559e88921653764763c1f025cf06e8792c955f16a845b7ab831d0158290637de281adda8f691790180377cb4df1060ecf19df3d1f472157e2b4223f8938aea646815290c92c7a10264c0ccc1aeb2bb8da4392ebb46c81cd21a2d14d7a9dbd00dfc90285bc75e3b015a5ea833945d842662d1a9233ffc0bcda642ffe878677a004dca44687a3f91026c7100532e0d560e93dcdb6e952104eca117755dc27cca4702e4f1679b7886bedc9ba7efa7d8f92a345c407b8ac8693face7b7572505ae49922d4bf2693bf5e49226e040f7b88516aabbcc56da96e40f04c5b65b160bbf8bed782bacb0e6f9758ebefd12a6972b95f781556f014a3608e405dfd44bd49342a4040418b983edae38e2388583ff57b683dd02bc333c6d448af4b9999ef3dd2f3e34680e0a7ab6f491292ac9130954d3378d50e0755b18097c9641eb43c3f0415c842345a09b74b43d1909edd7385279aa37399f452900f62ace1496d9c28fbf30c43d53864fe12aba4d106c98182d20d690e1ae3335a4877ae4d30555fb4395d1ecf238172c47b62ff109da3cf7c2278e6d8d36ef5de7009d4782357d529ef0f7fb11e1e9f64d9018883933583f3f47c8600208397eb449a8fce5334da1795f9d2517c11d5cc9dcbf5fc8ddbb82bda70ca500bc807588cf70e52d475c334981a8808761e96f3f61811a46b17187827d3aa0ce7bf35b4badef009de60bed4b3a17886cf8d9b76098a2208e91f1b881b0481a1a5dc9ea5375bc3f77e2c7de7e2130fd3e62615dc9c4f252c0bc4c7d4dfd446cbc09f6356dd3107d2c9a01a456c7a24ba504b48343b14c3ea0ea524d8ebaaf8e6b8b4295e6a761d1669a689145d366279e14a387e70d1987eca500217c9140d1716ed611303537c497e5233ad8e9f4c63cf17f09e0111209cfd5b2acea6ae733e9c62efa50abe48405dec5da3e2532d8523de3f9e6a91364d3dd0d5b65df93c05ac6bd1d61ad31e530455032d9939c3d9e5637ab52149bf30b7db1f0653fa113c5caa8bd54fccc7099c0f5cd73305ef7461f3de25efc6b349732a129e4082a20eb297fa76992821d4a47cf3a0b7e6eff3e99858c897553d8272d59d0d5f0466956f7476b27ebd098492f8c879ab45d24159c95f35a9e69b9d52d6c59eff3e184cc7674768bee050ca91bdb3bc48d1c68117760ba1c80f15dc7e326cd55992365e0182d2d8272f136a09f6cdf173c2ad811cd11f3c1917ff917915b94e2ee60bed40b9f109c14f0a1d520fd77cf0833ea394ec40507d2cb7d22fe58b1610ec7f9c5b85cf235a1abbf73c5599b8c2761dab4a29fa3d8d3fcf1fa7c96327b040debae34a46a794da4047ce888bc77fb230ea62ec0bdd751ae52d55dd823afc57d1ae21a07d87bc2a917391e2a47ff32729f027d8a25ae8d32b29bc18aabdb1dbf55bd1472a933c7100707d559fdc368fb76020e081ea7cc874448d7d0017aa0176018424f4e87e390ba282f2fffc69532d331dd118e3d08c1ec3fbd551a98da099d821849b882ea712280e8669efed69f9e8ac51917618300fadd153e5a7ed9075237f0f9202dee6a292423b8b2efbbaf5163ea4480096750eb6e3d687996fb81c8a48b48e8bf74c0c0dae4aecb8e45200b7a57f4729dda7c43571011c4cc79481957f9aae9f2d547a46ae7246860c811b003c90c16a9cfd28f674d13940ecc344286320f2c0297476fef32b45215011d05fb6abd54c25a603086ad32bcafa4cc87b28d086a9785dbb9089be4071612fbc2c56038b404f197dbd261cdf06de3077ef59c7cc66734e976f74e12a29b0d452ba1e0095335f3db56f252e84816c7c043b69f420d1a9df664297f89381fdf69fee80a4794c5b6938629b6dec9e5416b2a2b7a90cc40681c33573982908a4e13afe8976e6c7fddd5cdd8e788f76a12852ebb465a6dce23dd6dbc46fbab1f41f614ee83fdb7f9def4cca1302e9a5241eb5222ea7a4becd9fdc4dac641b094dff9a66077a97a736d813ed9492b14b2fa906606302624bc6627fcd79027cd7b290ef4e54c1662411c6e05df086bd3cd39584e5c883751e3a5424ba7c3d5d606eb397624dfc42dd5733b59f69e9697b63468f37b88e3c1951ff21795b127ad1ca7e7ba7c24ad6240a43cc206d7e396a25029dfe14fcf31fbe5b4756caaba08fd8dc5cc0e0d2efae9eb59ea5e7f478fcafaf700a81ea2ae6200f823b4327a4ab1da805ed8fc94de9df5db00c8fb45b59510e64c2342618975d64f86f2679a9bf169534a5e2739252b394b81b901ffd8802c6e695271323405dfa50bcf46e5418350b313de6c24145c855b97524bc4c3ff516d163498f5f9ac83ee29934be27bb0be6ab6729c17c7af3fbf4df4914d95a3f208561a54238aff408609a1c2878b58bcadea3d31f5f7c606d727e1fc0dc3722ef9e64f0f5d1f19d156cca65c39a5253cb901546423e17e3730587bfa4ab35cd26bb3d5770ee0f02b719897ad88a165f81bca4c7e103cb4d29b1f1be8babf122721217d22cac09833d74f76a7f0a08604962cd723538467c470c0ef1a66e59047b1668b5ee08dbc3e5f046fe896d108458cab96de1a7b15d769b35ec4557bd22d72a6e4d41dd37766365b8c7ef6dca6ff87754b5f3854eb7132f0f472fb92ace054367bed3e77df43e31adf1506ead5082b2400d41e2f9a4d3b278b65e93415fe4aa49e9d7c2d073df872f1df53d46293f591600b97f681619cd52d8221ce90ef86f1958f9c0ea91e3261d13bec025c52bc781e9448db94b02bdb77f2e1f7bcb612677013b708771ab25826eca7dbb9d53784c36bfff38713acb5eace96fa7d9316f7fb0b52d190ffff6eea13951b6da6be4323eda23c3813ead86cc10b6c87bb38b9cf2242095632dc76cab347ce88af15a32812537ea7150eba74beaa63325c933f6ccb7a80bc59d2efc502fb83de69d709abe80026bfa7c0bb414427f1aa6bc0686842b4d01c6b257c60e14f009d38f8f4a2902890868e9d1451edebf88ecb438938718df8436a70e4a687faee1787831231af2a6f2c27aea8e5ea0bb34ab164f985390d293c54b738f4f7ed7f9dbbd18d5a5b891652bb36cb79a8be1c78ce747b0e9f97ac77a51c27f7cb99f46f79e670db5efd78f5e7b8111d9066ea614b063264a428602651f8cb9bb73b907297b2e89d2af35f3bbdd48711a6e1db0c0b83e8782c5780a443fdf3a78d7bf275f9702bd6a9800bf537ce38756ae3b6791a4b02f9a8ca9bae21488645bc34dd817008006d2e70c77137da7dc12ecab67681dfc216c5059ce591f98b777fc91d2157cc74ab7a6052719d7be65ea016443a019d9e3e6ccd05bad73c4e572381e009b585186b527bca4aa22790d6b062372c47e30341d8844893892caf44589de0e5a0d4aca21aa174e46a963155735f7f5da4bf11da1c2221065a300d6d8c4701d1ab0858aab178fa3dff7bcee032e39729549512500f397ae75ab46c43146bad67029fa33010097d61a62838fed111dfb89baa645a7f20fb7477753634d8da042810c867f6c3214b6b81ba0247b3e5dd1ad2a6537e5437911ca2b8e3123d8959c88fbc0a718a9c5ecb3cec9554495e1a8a7e7152ca621952bb62426656165181de6dad209302560adb729df51bdcff838c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
