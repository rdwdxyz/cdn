<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9225b3e6d9fb84188041e207753a222828617fe1cb1fa0f837753524034f2eef7a1d6c6ab8779efbcd8b2a323df8e6a0f7c4cd0c1933b0a953c683c0bab8d26d4f1708975e2cb6d23880e504ea6055c1ede8255a7da2aa9712ff06aeb8aa98c945e7f0ce8fd0bf68e3abbb97d5c89bd9c8e991c755f6e749a052fe23e562059b33d9d3d3c63fbfade809404f763bc2d2dfcb5eab87c2baba5989754b7bce504a09fbb52d1c438581e3c942e3727f05db4b6980ab73d1a1ee57357bc6b5cc6e2553a2312306b3850a72588b5c7d77c9b0403d063da6335c512be390555e109223c268653818328392d995691025d6fd8150b120899078ec488e48185158a4d501d3f5e111602a4aecb30138f38108bcd47a75e7f0d0fbce3a65624fc0fbacfca80915c5c2975e02ff30173dc9554827e2eea1bff449ad293770e2e03cc2a24392a044ef9bf1a4d1d5c160675694f4a3196b014f67690eefbdcc08c0d7b0b9dad7de65c16f2e014731272b4356a0aba040aedba7ffd27f69ef6b78ab1808d8bf8b1b92283dd2bc8d7ffa51e1aea63611f0a59dfeb56b52388ab29d11c999067258c154b85f72984ede5cabf86f2fed91f0d5d5cd2c3e988f87e323008685f9027bff298d2bd9832ac9cc1b8a6e9cb913f9430e704785e5c2b01edf64b666298a65ed40bee3ecbcbbe8f21802ce874e7b1100d90d0e3e0e4744fe8e725e0be2d4f6f6f953f588f8c09a782a9087e370886b7db20909dc50ff1981ce0c9dd947f7de9f88a5e85cbe331e037cf702fa6c6dc8a383e11d55f6fbfcdfd6641b0e803a79642d86bfc2a9c4e15080b0789a88a4480f51befa32db312f70857de62093f91d21b5fcf469a6d52d0e2d126832b2fd57e5bb3a129674f6e9289980acb81c0eb4c1a90c182511791fd67c1f1be22df397af4550373255f2f5f0374eb4f9847a0a4d58b366a85923e07e02aaa1ef9cb13b6ab97424a09ba08df29f69129424f87b251cf0c504c551a3dd7198aae8c0ee8da5e5a43503724a94af70dfada40d12e2d4a566eb3391ae7a8bfaf45cbe30606035e181a9a50b731ee3a2c389ac5a24dd6c3aec1090f39566341324e2756180fb29cc9b0bab9b887fa0fae25f67c4070d99bf467dc442469b3403ffcaa5b577f825c2c992ca58bff13cced4a898b34becad1a4054bcd93887b463ed180a45318da4b71040ed2e206c60c8ec9852e0de9b5cab9606847eb02c699054e54e681f65de5001677d726e5bd787cebace18d14361ff0c0535c2a30d4bb66bf2ce3f0084634e5e95188be504da4257675cf761dc0424e7e54c80b9debcbf98e7ed7736a00b180577f91b5f8f8031cc974fc64ee5365b932fcf707d7a7bf2a8cd4e611099b22e5ff1e4ce7f2430d3f3ead438f725f806cf23d403f68608a911da13285962280eecd8109847cc90ba8f4770a9914371e364fcb49a757e5b22fff0e2ff7e9e92043102c32d254055ef384be5d11739e17b3ba2d346be7c0743b9f8df8a079b39efddc4a410b05fba99b4a8cf63f6558b915e1a27e416d797b45fea4dd863dd5545dcd200e1b564a728e5ad990a051caa70b931c4e40a466b9e8561a1f43ba96a2a145a775206c5f16c730367825af17be396692ac148838f545ac56f83d3a2c5a35d0876effc7c5e4477e95554168ab336b2d46fc9e9b54a534b5a47f1217ade417ac46c07e05bb784efce4bdc8a673250ec00054bb24f5cb91801ff899ba4dfe84f71e27ad4b85d57d583416fa96335c43b722251068068170f4fbb3c3d3cc08fa8f9c2409c90c71d4c07c9aa4e32408b68a4b76af26f048e2297adb861de0a4c0546a64d6601a3cb82fb688ffa2c01b97453e9bee27952c18e6f032a981049aedb1ad24f4aad672d87cf678171cdf572e4434cec8cc5577372ab55c251a1c377f8cb39c9140f3a9dc8527493a9a4bcf23ac2c4bae34b5d46891e94bee9d72c2788a8dafc564ad9375101dca58116c3fd85c33d97b5cd00db111ca2dc4b9fc24ea7fce59b07242652edb1b1b5dab966a1a42570dc75a76be6a6800c17abb9a49a7816b02c048d2e37dbb929056f3dee67cb9b5731065684665be8140338433d6d08559dbe9657a55079c13e354f7f541295d01db460660e1a8d179d38d7b1eb180b2fc983619fedcbb0205fde6908af633ed8c42aadc5acf8b96985ce275847429f39e292125bb9b59ab118c0d50d575d83e95fbad6c411d24fa018c78390740ec955922a94e0fdfb8f7797ca537cc44f188a71d1ce9239eab13156681dfc47294963f9c506c1ac42c44e1e644ff968df97badf06b817b0da366ef0f5e1315a3d26900fbe631e3453b8cfa0b822759af408edd44e3acd68b7edc40723040179c3da985a6824bf632abce6db86381d580d4f36d58e9610e16fb371e628c7aa2fd38ddabec4441b4359c8316762ad8b7d207092ac555ea57185b073064dc1bb882bc106f4c1f4ef19a22b7eafd3e2daa4acd03dd70a559e6d2704ae3a5fdc6673839f8270f535af72a68770d8ca6ddc670d30019a95b72d451428dbbf352c464c4dcc6b0dd3e8eb3286213d478d3c26f9f965175636ca4adc02dee5fbad90ac0b6b1116dafb088977c79eab10b812291690eac1e2b0835976f6dc1166e5400a276c995a91b02e1021a1a7ddeb2dce42a9834481e5a465e2947d07725d79e7954f8c693ae3a0645dbd09af4fea2cfeb2dae5a9633a3a6ac5dab29c11855752387bc0c3700cf0fe3bcdf1f46f49f0976fdc73f595f045308b3271e5d235d7daf39201ca9d438ad100bcb1002aaa092d470ec7fcd47bd5b6fc3f58ca996a5db93d3954a6b1faaba52a54ff424e91f3667f855af358cc3b8f16b961cf0324498d6b01271aafd3765da2de511403e1263bdc718bed8bc7df508c21c845ebedb36d195c17e4f79dd8c50232f989b72bd63454e876edffc9a63579099ce9cf1847a3f07cb1811de903a3031f8d65c3ccb3d739ef43b93e146f90a4469c14f558246f3bd89bcb16d6ae63790599efebbde27c09d265b8485fe0372dbaecc973fad9735f66aa55bd1e8632a4b85cb2071a1c2d14725c918c1fd044df150b1035dc5b8a9f00d5d0e5f78473fa0ee88ded7ca2b700b381ea520f90b71cfac484e88fb274c3ea445f48e67772a810fd30d77ced3110d7d6b53265611daa5fe9bd630f6900aec6e7205c3e0cadc216988ed5e9e4c17d1a6075c3d472d36af8aa70432194924cb13074ec0a062a55a10a847e4e125aa026b9b8400229421e8fbc9b28fe817f17a38e81cfce072ad2d836a16d6bec863eee393690613d909985450f6813d8ea9db4b91c74775d1f724366e8a43585f1935a736276e3fcbeed3e6a8fa5596c5517aaa9d93e3d88754ad75cbb2a5de8e8312fb605ed6705752394726835f75a48b24610a9bb0dbf965b5f976f931cf178e05a415ba5a3eb76b4ba8b413901f52a9303ec3942e40f5a616e0cdb25619c864271abcb83e51381eb4ce692e6bdc8b768113b68bbefc2738b847fdff440298f6d2b7ff13e30dddcd4331f9631f657b8e852a82ced6958c74864809f6baacd788e7c71a95adb6990c429c42bee64e8e3009f4a3fdd5fb9c7e7ec0f5289c67b5792ddd7547f054f7a9c93ca47c71cbd9c34fbecf87f4c0ac23dc95b97ce050c1a5389d02b0988a67404c53d603d3e9824a1ab2fde2cd2d9fb0e53b95401f24dd4e27fffda13dfd94169fc847c190b5d7b9ecf7703689e523e2e1468a12545e06f00711b2438c1d76a3fe63e9201f948c00f0b2141bc029c68e43b76ad7f284c31d6ac51c3653b08673a27f4fc1145283a863212e9c8872451dd2198abb6f6d52d4efe452d77a534f2cd96d222a13658bd00ab32836713ec0d4b00c4986b60ea698c7079409c65ab69900c06b6c439bd8d022dbb49a7c01ab39284baaed1acb1f1d15fb6c508df71f7675977bfb62695c3bc4f1208433cba33e139e93d3a1f5f35791a175dbf352da187f1be407073cd25d9b4b1bb12a75e001d7f0f5ddb030b6d8ed3cdf9168e88362583bfde8f49f539baf94ff8938f20a07c4d429ba562bcba2cdbb93140933846193369067cdcb585e427529b3c1ee99b4f2f992dc55f38ec012fbe0674062b888c12eccadd1cf4020f8b3bd451f5b9b53b25bfc80553b1222ac850b2cf90f2f3bc52cb4fd9c158adc7b423958437b7d140d6122f67ea294fa6b0ded50b04fa8857f94885b6d2ae29a3e3bc7da5272b0d20cd3762593f60835861d797af3ce281463320a4181843b0e5feff89ca2b810f730e1d464767eaf0a840cdac26d54798ba1d5ce0a0150ce08b6b92e379ff97fe76728f176eb8c46d24e8b8b1d3dadfe0a2206fbe6dd1defef4fb7fba4126388b034b2eee8eb59aac10831084253e250643c9cc4e72142fe25ba370e6bdf9fae0aec7a9393ec454fc3a0d423d938b5fbefe67aa43549372d4d106a1cdce9eb9baf8eba7d4a4816fdc6207b209db27026f950e4cc81ed9e8ae654909fe638306d9d297bea97edf35181d4526cfc75a67f83d1d8bd971ba743aef6cc1a0979bdcdd9a2f86dfb881c1aaf41ee1af1fe7bbf954367eb96e3661f11b17f93587795412d21cecd488422007d7126dfa1207c5b4fdb84df33d317e5ad0debb82c7045a7de6b5fbdcb4c4840453a330c425a79cb0d1a51c52635acc98dfde3ae4f45b1fcfb39a2a4698c91fc88aa559b29499ab3a14bd81a16858df4a11cb2c65a6d40b678c8145b243f413d61a8efb8dd42aab55cd1d31081b26608aac715eb0464fdf2247a1342ab4b395a1bd216b5281d913a85a4d057fbb5e7a7ca7250b3ed19823703cdfa381116ea7ccf9a5c361e1ba8e74b9fcccdf8b6a6ab0a6d011a31d2e49fd390552438388bc451d373c5fc5f1a85dfc1197ac0b3f60d31033720ba54cb65ed8345206cf57b19a81fd1e12ed721d5bab136d1af5d58cd6c9797700616514523c114ed7d842abb87fcda65857a0e7a44ed6d48f91f0099df77f27fd15c7559d18f0102335734c451f3c8d3835169834fe7eb6ab03a5fd99ac91d08499d720bb7a251758c16b4bf585a5cb7285a0ff7e2422d3c26d3fa6bf00e6ed8739d4cf902a0e0d04110294dc92193441b27b0010f63793cd4d237d63b266fe549afa691757ebac352a45aaab1a6b75ae8aa7d0303444cecd9219fea10336a32cb8680502336f4f0c2336c9431bf01a2aa38de5dd2f9b565d9193c1b70e5b422fa1cc162f0fec3267acff1323f1f5e21028067ab7cc58a0349fce5b460f4ab1c30be8ba295c9bdbbecc9d806d11759aff462640d67fa970c22e7c38d3e80cc3313de74314bbdf0f7198f1a42467ac732cc0067e3eadc8882c1dcfc4e7f14ea29e980104c66d071dc46016b9ee0e4b0743bee12001efa0a5f0ef4961da14027b7a02df1c4669974f952090e22d72ba9f207ef72ff38fa971bc36827f806442d4c2214883e9883b69b30fd52cd664531dc5a74459040b4c776bda65bf2e2801476c707939ca3e7c7aa75ae9a766b587731728fb08c2c6d14f838376a4b28b2c95d7e10e10f0318e06b72cb5b00b7a6d26377a15398e426c44b7e807b25599cf69388c2358bb9c5487ddb8f931e28954602a92ee90a9ee57b4583a290c609eefab2b3ffd85b8b213c6ed27fa940c4ba7b361ac6cd65f3500466546a5637aebb442012cc799912ed8c05e94c44c0c4b98987629faaaa45f15bd2d23e97b0fc7650971a6a0a945f508a715cde88a23f355aabeee10370c044b3e240ec8a07a4acb119df10a8117b3b7879583841d0a8c774c41f48a344a3f9d6170f2e08a29c46f614109e8fb32a7c652b660e6f050470c2d91f2da438cb5451a5cb97bc388befd3ec596f80e77cc762069b47e9ddac75116be4ac86392d9993041e394a55fccfed211cace78691517f9a4ffe6e36de437673aa7d1ecf8f5d99b25c32ded9289b41848e4e9e218aace3269bfb7ac1cbe93479cc74b0ec3a7a7fd7ce88311dc6ef0fba7a6d257bca71d1e588d96bb882d6039ea5a5e579dcf302a7f5cbe621b51c78deae63903b5b51b6b1a4916fb23659b39523be02c73ba2e61ac06d6c02c5fe7fd344c708b4c7823904af533c79ed11b8527b2d5aa810eb11c5141970be65a778904af6516b65a92244e51b8223462ebe90d28a368cd45be85519537da53a6dc2068b5d33ca1b3118e40d7c8a246e361fb352046453c4940ccf504a960c5b130d0937a3e4f2de0e70fc4ca984bc3961bc76067405e4d94f8f10028333d92ed6b711c61b63d04c3050536376b0d01e235803843d2b0b3de98f717477941827b02e3a89ea053097dccff1609e379483c33c91a1349adce56005c27b177e71ca2c8176013662df54aac06ca3f1b7814a9297eecac10827d4e432e3886e2be0a97e9ec262d04b1fc0bc57f02ce2a803c56cf85deb456936848f92b2407db02157f03d06e5808caf131f40df0422382d5c2f54a167ceac8c9732fe8a14740497650dedd830217ae5e437f537bca399c41f86c416c328508d4780b1724d50f1f973fb094da2c93a7e93cc1287c64366cd94964a9ff7619a06f533a7013177b4a7a53956b50886f9b408424c1abbd09f09857c0579b492d624ddba73f0d32cfbebeac7ba8fc146fba9bf96b5e66c9af2e28e6bb77710880d5c61923b305367007cb7736d09e23b442163a0ff73e6def32ab7877c4563ae528dad998b061202c4c2fa8eaa998034c6d6f63a2e8efad93d49ac29b6d94d88bb86f4281a59971048729b6ba4157b7c598ab8ea504aa47144969002b2d1686a3c5b705422ba8b10839f4684b6229daeb371cb35f6a78d71ea03baa1382b6dcbb2fd086a3ae581d95d30d1e3eabbbc6c4a65e1a70b63dbe9118d9a4e8fcfbdb13db2254050ed80a65a755d9927d1a0ec3a4a57d7b8f54470c342b9dbca69c90fed2461a9df1870a9982c2d701cc4f0f059a32d25a35e752bbe9ef3f665074f15065bce94f74db59fe05e46cd65833f827919c182e603477831ac1ddc7e36870f972fa912e1669c609d3dd74cd6e0d2f2091c449606e02a28fc652083b39a1c1eb915dd67abda1a2cec65b53adb7d0fe349275e5021221af1b05721a91bbda1840c408cfd1eb2f873b138c44cf2c6daa0158de2347a63a27b885acb8530ac84ce76a73ef44cee67f5a35e184959b524efcda1a6a600bd96b061d3819f5f29f7317fca3391498a799ee47a29e1ebc11aaa49664d4855f956ed78b87871a5c78e5f163dc83fcd8fc0f9588aa709613e6e14bae313dec1f7d13c08adc2beb85e6901ec7853fd7bae35eaad2922203ab62a30f9f142c3b65af4d3326901e7690e2eaa51910f64f686a6aa7d7781894b0290f327a6327d4d87e57c98b5766896864c90d38984c37f6b60885dd300661fe56311f20fd7bff6467dff80104c0a5f20db417e049b7770b449be03abf2e352b00a9dd77aa25f0ad6526fd5fcf4c3e2fcaefbe1fa36d3fcc1400fe5f8d8b2853e6580e84025fafb88233e33c278abdfa13afd6ba6c4e7e00ac8552310fb8f8d6bbb087992de37f232181e06d43861e71673cf3ba15fa667fbf881246963db01b93231b9aa014811d2e54f6259107882e36b89f2cc87fe20ea6998796de57baecc56b18b2ab03afeb7b3fd4c34b5779ab60894f04c0cb6bcf01ee7c2761e40be70875f53a9a773ab9ee2e5208d05f1b593a857f8a095f36e7181d604d1a1b419b692bbbc74db5aa8345fa444704004d82a672ed8881670041cd479e931bc43ff58dce352057c9626e9529d3a6562f0861349fd6a76b82fc02dc544d2c6a93c7e84563ec455a823e5a3c200a978f249f3ca4978a844d5dc9c9fa45f1e555d80f06b760288c9fa8753f71366b5e074c2a08f1710a4533606af84c618e68a31f1ffc1391cb8f2062eabd28c7aba08c99f6204d9f304eae54bd1dd97847d36f2360adb57aa8382d9899ce74b42789f8be517109cb2794b8b4583b0bbfe0583974763376fba8ef91d9315ea3d22522067c39d62da87c3db849a8d7217ca6b89e782001c02b123ecd843f99325e6d2c02b6dc503d64bef6318999b4cec072746036c85627a311cf55af15d8d9074272ec17fd4b1c11d59f775b0cafb8baf632fbecf99f7e31037b0a108f55e0b03dd2cf86aa588d6390a043540f81cd8bcfc674789af287c4f29b8d84446f8e335d290d6e85562dcabc1284b43ccd7db97eaa501aa36a437daf62078711c96a41a27d70c4ac83367945ee558a3f536c753fc8c77167b2c6ebdf688d98fa8716b5bb872a265e5bac4478b6a7d15c106dc2c8bad13d0cbbd6c9d4c08c19c52f1f3074c87b32aba35bc1ea0ba9cc81e6050a03275d2c9f687be5f7e04a46e885756c6dad4d28caa2e58f7fe6884900eb4e4c64f48b845e0638010ad33db277cb6e5b737af8959e2e29622dcac95d36330a90d7dda927d593ab4af31c8a637c0067a5336660fbbc06bc172b620027328adcb6f56c62db54179e5fa147716981d65a77c4afb205acb4f18fcd8558a1f489820e6f21f0ccb9b5504ba7e329367bc30e996eb1af475f7ee03e6cfe2916dba8fe4dbbee3674eef2f3d438116d94b83658118bf7797530a07151eaf7d8bab1cf7af2e016cd97460631a559a711a92365e0224bf093cfabf31d9dab4a95f5be08e91fa121c718121b86ac4ea22cf0742c1240700dd2008a964867adf33d67ebf969f3b3a0eaa5ed062e44de44819005cb9090044fc4c8e258566a9cba7703dfa155d97489b777c852a90be675f9b4869b380bf7d80127a2cbc8c92a7332f4cf5df6d042fecfc2a5467025f0b58b48c751014516f27eebb72cdbf2036bb1f3c3564a11348de2b212765ec77804c64567a63a189d02a908cd1dc6e19cdd3660f7384a856a03ff9d55f50365b1447c47325b9d6f68ddc7f734e5fd5ed141e10147635f50f82610a38459cf3e220de3ce9bc312639a56a41a6443f7846605fe0c4c591c59d082845eae8cbf638c277de04afdfefbe9234d3618cb3d01ef894c01000b70986178236cbc5415c69569a86e1cd0391c7b19d31b066478569b03b6a2817b9b5e0a1655de3b54931a86e5cacbd85310585e267ca01d1ab8e2fdaa035a578ba38d47e93af2ab505967bb525b36f6d27b73597df41c05f7700f838da03836de3a42e52e587b3a05d578e873e5dc13337184ae0aeb845c02b7ea3883e0dd75f0bba29386ef48b7ef967e95f2c0429ceb3c78464d48f75e9efcb0cd7a5ab4da9cc628cbd889e0ad57a8856cdaea3db27ad6d1cada4d4e77bfb53f37ad3a5958c01db32feb3cd2adcb955eff4277410a8b9a44dbca4da18209de1c96ac793f378dee2dd92b3f9cc8f05912285031198e6bfc14890b56c5a7e0f2e937595ca96b993167113a49014a2c50b8ce00d4b72c64cd159c5abac9285ac7ec2d285a928ab1fc77cd93ebfc96fa87fd02c44da2cea28ef0d481deb8185c46b41fe97e40799b4d5efc02bf3542a0d82199310873fe9f0b19a7607af376f88b1dbcd45caf281c37ca987f5656f7a18bfccc3f0546aeebe94edbcedee3d0162f5d2a1b529be4f426e48e7a7ae7c555888d89e112923a159bcf0114b6e93dcc4fe23c4ea1375167f12b11b89359a5abcd3bb208ddbdf062896749b6b0c493361026bbc40e2729e227e267e1193be83d920fb2f1e2427b9926b62490de20a73635173e47c203aed53d718d2f5043150c51ce3b83a9e56861ed9171ed39d8c616c22e379317a127f6ab5a1d499eaaa4fe8f9797d2e271529e29cf52204b66abc13874e7b9c27f04a357f0fbe92e00e5a3ccc4016be0cf262bfa99a4a261cfdfb7abf978fe967a10b15f673dc583a804ae808b917ffd30f7b4700af90fe47069d5ce7623703515aeeb0a5d75a50efe56aad5d73a2ea8b5e90f90d4bee64d2fab4c27ada39171bf427235b06c4f3dfc81b2dd4ce1a466f5a99ade9b40d196ba633748291f03d2ee15e25513b3bd113a00119f0dc7a5491102d2bb7c379060f282fc6873cac03321393de8a97ba95a39aed9d1732c4ef967cabcee971ee2c5e9454a30296c76fc6492f5a10b63245c94ca0467df5ba99fa5bd60a2e72844b4914f74c97a7c09277d1d50b216458fc00a1f66c68ceb19db60c9ca819b68c2a9493d7f2f8d80c83d3695aa316bc41fcbd0d052ea2cc55149f8a109785221df010705c9a1cc16a53d52ee24420f16f91ea467bbae0144ff1e0e2c0cec5e65ae4fb6bfb7846eae6ef07e401e658d51eda7ff44c0ece67b7349d3665b799645ce18be2e235ba0f8ddbf54a4504dcf5cf12aac9999492d4c767036925b9358bdc97f852969bb0d5ac998108a10652ef60d4291e98133eb44e05ee98a3406305b0f0ca967a3b80cb7b3104c527f6804914f00cfdeeb5a3ca207d30faa408feffb55ea3dc3fcc9dc00a5a25e6e8f556b739a4436c6c8644426a3f1199b756a6bdd9be08309d219bc72570e9c7122d08b595739e367d170ba5830760dae60003a744527daef980de364ca54c86c62ac68e1dcc27599218da7fee7410c624c4e7f8e9c978e215ad7c182ec6e36fbe97e687c272e3fe8b363ab45e6c16e4fe1814dfe96476b4312ea1376353553c7c8b657551b8ba3e0dd3de3922c01a4005db933bed893ddd4be4f2809f121f145daa8896cbf94774a6720d24996cfe5a6540c0a211b64ae8615b1b1e5785964031230529df2d6cc2dc1d8520f0928c6c501d7111c3203b0744c294daa5361f4e26f19a21988191316b3b5296edafbe2ccc0d5b1ddd55db54c2f3dfc904fe019729e8c8d7f8c97af1a4ce73e8f347347f009524b17de4cc801986e5687d92f68b5160af6d9e039d6e9330b3c367dc7ccfdb13107bb81460a2ff2b2e3ad48dbb4c3bea21c91daac96b1624d762be3a9198cbc9adbce6d3d029a9554cabd0ad3dcd6f767bf3365a59fee856a652e991a180426fcb341de29e073b6fb834a9984fc5b455db6d37dc86ea4c7edc5b001c0eb603b16e6b4b6c858f9f8652b3b653c39a19a064cdec30a1af3f38a29406479471cc59e2414d5de6d431b7f3cea6ab84ce4f5a7dec452e6e42e5243fbf4a1c06a92c7dd40c32c62287b38cc2c86e4038346339cfac2228036c1e118c41a1504b479a271b6b8864130e6e5d655b1cc3ee8110526942d8eee6e74aeddc8ee7eb3dfa35c17af311b1c80090fb6fa9667d9f62e65b4a18ee130a8f17ca1a50fd87c559968f040753e08930820529da2ffb755fa897d7d2aef2d78506570d186848d0ef7dd15fc0f126faac7263928e11292189d673e32fd822dcf223c929bff457b60ef9b0b68813a00b1a364bf83affb7fa7f1d722dd81b4fad6a414ab2389714acf36bb4cf47ad83c45d09140f17fef776d91d9b36417d2df4c2fdb4facd67a25732d0d7e4862817c07ff285a68c36833d64b4d28ce74aad523ba3124d4b1944ae3056b70eb25f99253b3a5174a17005e6bc6fe30cbaf80cf42c2fe5d4af22393dd270516e25de54bc098172d37ec676011cb510fa302b6a5d3cd110aecefe7a2559e7d285059602fc8ed400acc7c91dc88e36c9e6830ad76e02874db0d48f6440e67d94f962b06dee8c5a2ee5dcfa15d0552d3ce2788be3b66f4a5485125fcc127eb545ca87155198514c1d8ca9d6aee0320fa07a781d4d8d64a3a35d0cd5dc23a0451159d48284a5a13ac195f4efa7ae03aa10b15e967056516acd21f7cd406647966b60009eb7cdcd0d93f8c4d611c265c3b0cbfbcfd655f253caa41ca9bde860a930b71b2045560e0dd34899830de3e922660a896973d3fd5b504d0feb93023ee1e152490205fcdb56563863ea9b0563584162b5d3cb64aea964b86a73f69368506b8afb10caed55788764b407c9ac8ec6f83f3c59ede9a7932bb489033fb4a615de8800014d5cdbf62121ddbcd1ecb2fd51ee4eac06ed11673500da81e686c68792e4680e52aca24f6f7c3348ced03a003af2bc858d5c32b9973dabdf32529383a8a9bb9b61aa4ee550e7dc46eba0de9c64c479a14c4a3d600a41b50244412e57131238f3ef1665e09e57a4f0b36675aa9a3e60deda6333a50427ccb98716e07b9a95df99611f3a5db7caad0e93c6a386fd3157e5018391d94e0b7c684a28a408f1531522d8dd23fe3712f5db73396cc48f4fc949042c917657197d7bf943632ccd902aaa2c23195fe64a83f9203369e4bf8cb8187a0fa61b3cdd387b45bed6621714daf2e4fc7bb98f25b935ede56a9ed6fd2757b6d01200d4ecd3e736c1427ec7b06897964324b3f08ef8edc986dc9a0f3950fb12c39d09ceac28f434240131c80f30e851a391d7f9d458b486ede1c7f80e649c32e9ad191893e1f6c237f6a65b7c848afa0ec0bc75b77a145bd6d0fa9f37b1da2677cadfa2f1e8a0c9037a91f7432ba4313904c6e7e422931b7f809549ede10baa99c8b9eeff908bc357a2cfb146169e02d0a4c37a953ddc68dce049d6c49ac5cbab8e4179e62cd64f55a35ece82c6916ec6e451815cd1fe7db01873fadb3ac86f1ef2e42f7c31b53511304d13badf38c3040ca32ba3b8ff291790da419ccb8d1bd4d9b1c8209f2bae14b05b3396e24e3a46de1c7b2a18211a93d309489bed69e466874a500caba88e940a4bea668a156250480bfb063a8dc8304102eef385257c4e2e9f47e1b768ad0e16223582dccbe7fbb6010894d4d502e8368bb316e547fc820d3bdd057852c0c72f4d31d2e950fdbfe52a884412c5f2fcf0bc6c6dc8695ae73f9862ba5a8b640de8b3dd62f8505bd6136c36a6669bc56b613348dd2ee69e47f361c6a64d655fa42ca53767dd3f55e818dcdc0d3daaa1f91a8ace01ed1147be087b15befadc8ee5b27efb1a041f67c53eae851eee64ae614a44b2b6af3cd7ede0a8da94183ab1024ce5877b001e16b1a985838a842f5c8e68733539cbef63971dfd924d931a48d91aefeeda7e0d4f9c594b6947c69053ee61a97cbcb58cb947f14fbebc1668f5723cc56062fde87277a6a80668e6616201055ccdb6ec8c1967a645faa768e24b76802a3beea7e9471f98a020831da675c52e6b88d7ad8999575a3a0361179376d66ca23bc7b9939273030d32660d571395786b155eb6a8af6e1b0f37acedf76b31d58cb26b9dd8eadcf17f556b5ed5ad3883ff87cb6ba718857b6ebe0ce4646b91ea7478f03ccd90cf5adf63b5ae1a43ee80a2860e9ded8de9c1fd2143937547e0cc3af7172f1559a259caddf4c5e74ede2fe09f09a88bbf093d83f558966f453bb2a88193c1315b2334bc5e19e779d7486424b35717ee13b42c2080b60aee950f60e7a4f17734074cc0a1b9b6f372c74c6ccf51a370b03b6f24fe7331da99f1ba5ff0ceb124879d7276765a0216a1e92c31382e3ad7f11bf32324b06ea4eb9874b3535e38dd3745901c8cec5939a42ce126b0701aa8ae98f015900f82a9445bd9e8ab09339b095d619559300bb60f35686ac200b35141af0a82b689f36a02fccc1c897e0e7436d3ee4f2d4aae39237ad822b90e718c788e11e2c205e5f882758617aa3df863ccb93f7b5bd4f9f3f27894c01d2dcb828538826eb46d7d5936cd9aaae23aae75304a465c9f47d2ee412a150287c6052385eaf0fa6e5563d748b84d65a240e067777badd4bc9b70223ac82eb6b1e31424f1652d67ec1b9fbafb307e8340d4ac40e4733d66b7a61283826cf11e1cd988f46c6465e9b0f1d657f3a33ff10187866fc0759063410346dc5ac2add5089c9ab4923696901fed395e870d368b4300363912986e90d2c3595f421a30119ca5ab020f2307b61791b43ec1ad10a6a2399d8d48614e2accc9bfaec093872615ccb91a496c057ea15e93ce2518ca00e57979b2feedd5f459cfff764aa0ea601941e11d02603c4f752c465470c4e7a640747a25cd3a43a0cf21aa804fcd12d9c3a03c6e7f5ced23d74d0e2d14fd4ffac3ed4ab0d218c5ec9cb0703e195b7e3a62a27aab57bd3c920b676428d3f728b04ea56adddc0205c2de981b59b7b35fe2dd3068a5748c7c78c125db7f0adb06dd830d04c01f0f10b26e46647b8f59030663d271e198f343583618028bb56a4058abb434d800d01cf90e0ccb4c996afadeef281a1a186376dd9287b441db96eb2cd063d91485d7bb9220a0e87e097fb066cf20b16649c24bf1a0dc866dc1921fa00a90951c2876616fb1a8b91b856eff23602fa5c0b17ce66044f364ae5e0dbbbfb982391abe4e188c2451555a3ff156ea0053b49f43cbc2f04f021686a8d7e3530946eca6727a7094ff345deb7df8c7bcbeed0a1eadfba378dc0be66fb271ed74e621184d93b098b5f6e060843d2d6700630be3d81db8b99426e08f699d85ca56931ebaee11695a64d3e54f491721153eb1668a73d445c265cf7ffebcce8414c83e6524007717e37d14cf797243dda509e6708b52b72ad258348a9199da9b58d3bae8059d86d90f07129fc9a0cd461fb5fae9189ddbf64e61df6b8c54b2deb4bd67eb6dd0aaf59b3777ea5fbb0699c2b1c7da750b252a0e7e6a826909057b1f16c99e089307e23073b06d02e95e1ef31c70d763f84c77235154daec2ab5ece8ad199a55259aa7282fb00ab8939bdc512c5d43c1bb69a2d045fd39b20c3aef78ba85c7f76f3aa7703a2986ff9248fb1f2489d3ca6c376154af7a9efee62b920d9355521c2ca944d1f0ed0bb07d7bd53838f71d7739c65581cc84814a765c246298c84e55f22821602d63ea6ba6d233a4197d2e8a551340b21afcb2f967378dd96f8b79a26ba5203e84af6c02a7375b370acce5f0bf63d952af36dd8eb96c29204a6ac8da052f42268f1bb6a8e00bbda47f48da816d7d57ee4907393f4cae6a447b64f9d49b0446834bb4a9c551d2ef045797a0e6068bb4f91deb617316e9f96880585c327f43b8005d3ac241a29c3715f8f2f7c9c80c5f007e749a888cbc2c91001b41c97affbe4463c3bc4107c1ed00b49d0a1032096e25ffc06bc1528e07c86bb205ee6fd6aab450f42bd8343c286178b23723873e76f7b2267dd98ed43622ce910bf6db9b2f29c56baa9d939f78d6c970dda0d88d7ecbcefea98ff5c062d58cd122bf3d2290047a96c510df2ff3c21e9056cdbde25fecd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
