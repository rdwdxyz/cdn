<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"98e2d256a96e78701b0485ee7f8eb29b4ea0c7461134cb74aca7d4340c6bb82233d85be62860394fd1736c307ba7f0c4a226fe4d1d7e1aeea3427b49619f7a4caf9a4bb519313cabf8f8ba26f820e0e73804b9e633fcbe07b98837a4c8c850fe3b701fc768976755afa44ad54388579bda8170f8e879cb922955f868acc2352845429c707e0a53b53fb64aaede3db4b864216f663768d947e7218203982dd43ff2d82f195e7dbfc6a3b01aa83a7f3ada340df06b029e0bb8dae6ee27d89b5bd1c6b9e004a508036aa0c66ae24c4f4fc786495a74ebfb1f11f0872ca593ea3f1c6615448e8c2d1db4be2885e514f323771871705d2739950ac2765312d48867452d873c0e5f8c5bb13637fd5f38a1b05deda8e7c658b55834b62db113363836ac80c42030f783b14b28f50615951f9e6c5032c08da0be0973d0cca593e316063ab12764952430c339c2eafb9f8f812a2c8323e298396d4cd842aa5091ca7d78fc534cc3e4b38600fe97518433ed8e268c995890c5eb54ea02c2c1eb3c49988f625cbca0cb70f3a8e91d37e5bf669d28421519d4c1e955c0a2474d30b173a71b9b2cabce8a66658eeb0c338103695c25a3205c024dad10ca66a88f104ac4d9d90212ced0a063dfefa11f9cb61bc6063a4073a68f3ed9e9cfabad00119487e11d4d174c41b7221439e0f08b7a8ceac4179e529edec89c0c0fe6dc3bc1f49ed6cacc5422d7abce30a1083cc508b13725ac8eae8813af3c2d75e11c4531daf8b6ce9b1e5b3784ddd4b3a4cbbd752a402088a2e89e9715b8a84221f11eec0fccedcf1efb4a30a0e825c02b41c70ee5a299a7ffb230ac1e97c96959932d0252e5d48bcbbae4e4decbf5196d0099c83eec986dae9514d1808978acc2505cf0933ef4f0306521cfc06c0d9df66ccffa2a1b5736536a29f625ced04e7d9b8d11cdcec8e519a3854353edc2735ce224c156bccf94d1a1c50933f57b22925058596c5171c0a5525bc3b4abbf081cd07f484cb79f6a333c9f0e64331f89d29b6f8e2671f4374cbe41addc671481d7a0bcfcfb030fa43c2154e64048e19021b9f166cb1b3faafdac73ad436bf60127a5c4c2ac099aff17d3cb91afb884b2d6ef04cc8ab85a552aa1d270cfeec84e2a19b508a0ba72b831806294ee571ab3a05e9e00ad53a0a31226522d085d091065b7c536c3a360b13f274b95f7876b45d4639a8fd96ebf589a130f8f7d279195feaf7c2bbc1ff0aa7b0728992d5ebc47733ef4d7bc46bc3ef96ea34ac83b3498a2146373ec56e51c0c5deb277d894494994a7c6a5a6d5828fc4960c40ca05604795082d9ef274a2a17ad5fa9048d308def5b2c83a0b8b137240734dfda8bb8b0cc76e1a4ce1c015429336d388c2e6d79e5fcce1d469c551468592ce3742910b51418bd43f403b7d7313343d9d7a6200b2826e72feb66a89ce4bb241181b8ee5e99dd713c9e65153251ab99f91cfc9d69a4a923f1eb54aca456a5602cc0eaf3dbe0819bad6a37aef2049003a1fe941a4997d9193fc253e7f4a25389d4645a4d4a344d1b823d29f2fc15067f6637539b425c5de67413cb013cf20b4e44fdf5c76711ddd23c455263692461dd50e65f101cfeef1c26c53e1b7c590da1f561bcea2e0f18e0794601102413c313e2e5f3c89bb440a7c9fbfe0bf6d160b3e527bba2b81a2c32d4902ac5976d70a9f51f4ae29d9bd7a90ef92edf393c7ae90a664749f015ca071a3983592d65af170e2381628e41dc78dc185e231e3a9b9e6560a5c2eec96441a84c1aa60d334051f6b63486293747387b9c26feecc402838076a9b584f707cdbda1ee2fd1eb0f8f6b314babf427f022b66512502ad5484601b1e2f4300b1989212d00e6e6e837bb01ae4edc597fb97aec086abf81b6dedc854dcf8c36ab7f81d7af5365a59e8aa8e578832630647763f556411c8a32cd8f53b955ff932a28ced770d95533ea5ca4a792ee4949e00b057c502665fb805e65b8e056c7d36b43cda8bcb45b96178b08ec0f7ca1dec3b967e5c38765fc75843bfea4679298604dff0c79d8f8131fda3403d951e880693e09fab9a894aaf2e02a329bff5ceafa15cb59f0311c58fe6f44c9bf89219c67c87868f04a4632fd7ff570a5361d5ccac9f1c5b9b1b53c2a8bbb65f6df96f758f5325278c089e6c0f2800eede8cd57cb4f069e6de9149da05357ab877f7744eb71c5188d6acd9e25bd24ba7c345d7765bfc7adedb16bdf4d517e79148195070b30fa01e00a994f6c983a1384bbaf3a989269bdfc0b95dce8242082340635528e4f5edb6d3ce68df9793c017aeba790f21ec4770851a9d8617ad97cf9850279b58ecb9388e5fc3f8ee53abdfd65f84b87cf80a06c0e049f7e5f3934c4dbae9cd57f273d736e7fe6f71929584430ef072ef63d5c62e63cdb751f0f0d72abfc8c48680f70882d5c376bfbb5dcf1026e09ad2d4e549fdeedd592caa782f495fed9ed2cc56fae93d24b0baf0db21cb7cccd51166e0431911b010ee9b67ee39dae92321bd187c64e74974798793606286ff4aff776542c02abfd622fadb30845f4aada5c0d1caea09a55c65e3ebc3bcacf5e86d0d9b3c7ae95521a6e343ed92b468cb82450beedc83a59e4badb305ebfdb05d7600f1697cf4e197598e3d5259af4723fbbc05d8af6d3adb0b8a8fdd08eef3ce5ea44016c740a21f791d0884bf20040b5d1525bff2e45005d48a221b46d05d8945a229d0eec83980603c08f8b1a0c7b91148803b9c8b37e4759a8fc502f434c86c9c79335044501ca887fc9c6bc19b913145ca8845c50006d9dee6d74e829f0496b90d3ad833e9bb8f1139d469fcb02d9dfe3532777bbc3461bdf60f6a68fcacd390b8cd4ff7e5f1aaf3d55c1baf61e4b06b3d87919fb2c6d8564c0ae5cf45ed59a8eac6448a639d477666f1864a0f145e0c9f59d577b3a62b63f4ea3c6be95be2dbc7bb90558dbb8045f3189c3935a079ade5521ce403e2f10af3dafe00283b499d2e17b2b408610a9d460be9cc2ce87e544c414c993816b7d37455a35dd41a6362fbc69eb7537e1e91563f3a131d2df617b5f8d2aa15d473c3da493609b44fa4253568bbe190f1b4a5487cc97615775e42142b32bcbabbe0b74a228de0d81e861fda0231dba08ba0b1f4d6f599b1ffac90688c8eaac2918bc634b8048b01800e8cd2536b98cf3943c328699917f92791a6f25ee616632f8cd4689ff8ad825c8a1869b11fcf73cde875e6765b13529a28f2b163a672c6eb934dfa28aeeaca6637897f48a3a26a9696dc67fe34bb2687184727a5af40ef21e1dbd74afad78ce040a45454f145626fe4198408aee9f6252ca85e1aac9c560224e891b7928f1f82ba52405019f80deaa01d2f6d43114007b68edced5b6084c5097ca60d302648eaa4cd4fc2c97d834f0a7206f54a10a0d9428d83e7f15e806771adecd82bbd5332a385a6ab5ea684a5ac499455d3540098ed596491d6c8fd6c690e31303e91a04eb63f770291d38217c639cec8a3ba1bbe9a200501447f1136ae4c22ae83302c38c7a8e0f8ee4d4ebb4933805574773133f708daec55b70346176949204c7966c152c93b20a14cb89e0bed152f7829facdf8f60cf7548c22dbd2a76dcb34de15d9848c219bcd751d22c3b538cf486d4cd1948c45705470c7a8555ee9895e8f11d4780e9efa85b7eacffb3f89e7508bb541842f249c5891ae42adc95f9812a304d1b30339274a15e373bc552cb11de329f514387acc1a43e7b0c1684e7e88cf2378937c2cee414cf1188ed96e26cbdd2d11dcc7c984da7d1de83867625e8eb2b0c4f94776ecd2a0743d9d5edb4fba00d7cdc5c04b969ec9836c86e55c7ff036bf09ebeba6fa8dd6316231005e143ea15edba2b88ff0ac6323f96b32a9bfc5f10e8a4ab9219c1249580fd48886a489df5e1b620e85ce934f4abc56061d22b2ea705e451c4f72457881331762901523297fe15fef15e9854c328d97f9f11d2ae01c02b9b08f3aa5b0ad94804c0b0b3c7e9fcbd9141785f9513135b1d899033027d450e4358fbd4a4c307d4fcb750f1f1053fdc110b80454c7faeac26461875e73b554fbfc3fe4abc8be36749bcb1b63677f99367ebf7e2d79239df14cfc801d6ec19a0346b1e2ff443192c0bedafa92f61e4a45f2cb1598edcbafce747d32864b4ae4bab927ef1b1d983c2ab100afd0426bcd3218d4c7908b3a6956fe582903050c687870a39c9e33033863ebe1b9094f703621001ad6c53c03d58050e74c5b8bc0e43ad4bb3fbba90ce574374a90a8aa68fe79aae3ea737eefa7344bbef4700ce7b7e7fd94ab76b285fd8313afc2a6b6d324266223fb5f218505de2a59db228f393101b4d57a40d82c20da37a8d87497797b8749f44161b8f1bccc2d8d99662abbd771ad5f3be0ab7ef41adf929019d4d61a129218e29b152ec9eac40c83937735ae839160454f64791b7237afee4be27aa2fd6994adc5817eeca8a98a422e09532f237d3cedcf7e5f62c0cdfe8c0517c290fdab23817be648c9e3e9611c647b69e8a7aff6eb714ac49e13279cb11a5d55e42b82e603561694b572041652eeb7fd8067326196f9add6d63789b0954214972568107f4f3f0e6828aed919dd06506055c7121b31663e001e286ce812c99eb1e0119f53331667ddf2428b658e5bd73cc0cc0e912bbff4528c3c16f6e3db678ecdfedcaa2d4d4bfb842cbd7b79732c049867837507aa1dd00bc59d5859130e562d6ea33c79e76f6961ac0fa97e6f83d861f28095add73a2c74298fcbc6fcd9dd923184cada058948e0151eba218531fee99323a3d8d5b5cb6a288b064ccc505bd91f936baa0d5417c0335a6e66f9862ce0ec40b509e615ee02c680dd1d66e94791cf635957ae0c67fcc38e421a4cbaed6464284894976fd5852b43f16c1308e75a10f9ab5808da740767bac36d1758ccf99a995ec8b67fe2e48a62e8b2eb154c19aaecea086abe506a1ce55debf45e360a59ddbe60a1db191def59e6bf3d7c3f55b6bed96dcc9612a379a468d37a2988c2b10ced62a7b2057de1754d4e759cab1213942245898152b3863e0c1b56e011773c1384674911abc485a294814ac2c2a496e212dfe921f0521a76622295ba9409c184b47b37ff58d50eaf1e012c983d384320812e3c4adb4533d7edeb22f87a276d059e0256df7f922bedb731187a4f71887fc60313b5e8d3e25e994063b2c6dcdfb383d034ce69a7d58b8341b60c8f301b8a09b635c288150ec386b9f9b31bc11ee7febc330a31bc51ef29e986746307e7c479e7efd754a0f4fd2f8b96e18ca5a8f9daff73cc34c8280cad5faa0a5217d92a4d0bf82d691002399dea4f8de43e02cf408dcf6310f60b2aa7bcf9a993946ed787bf50ce1dd0cbd6be511f7272fd0bd94addc12d671c007bcb401f7df07876aa5939c78cdd4ca8e3888375d3d5af1efd49ae9eaf1ca2e3a759b2943d97f212a9d944bc280f9f7b9f9a25411806797025e3d7242b405f9b2be717b5c198894966ccbc9f03aa8d00a96eb6c7ff0ba623e34f6490a162e47775c19b4781b6abfc9f818c35d53c2a75924c33b607d7759de21aa63ab30c571788fdf6e7dbfe217e8fd5239b6b9a2dfc2765bae5897539df5d8f1e7ef0ac9a2c4f07b06ec7285c76facde8ddbe2713ab521e7a416638f02cb75fe4fdd47005ed06af6e43efc631a5e9ca82f7520f91cb01070811fd10d8d16b50882113bb93be37e67f2fe60df5d6cbad57a6679aba9cb2e8a289654e7ce2b04eb2ebd8a71f237208db1bbf9f0888df513d6d9515dc39b38e68fd4482c3446b10f3b0ff205bee5b92714d7914a0008a1aaedec10a04cc64326ec9a984108e523d93a2885f94cc058208235e07160762c09e13adfeb1aa1624a9024934510e187a0616dc043bb87200cdd5554662c4e138f8fc57e61b7a84f3aac7fe9747219985cb74b30e5fc3bbe6f73ef1208eacea885d519604e2237a573b4bf4f2c28636117ce3ea8a60e65f86dacc23264e8a937eb7159afb9ac20e8363235fdf4b833799d52d6951858277b64710bbdea20ac00e0adde744c4bb4c7d784d77741def9f65d0b5cbdaa5fb8b3d93f916607eaac0bcb5ea73872b52f715f4e364a6c4ab82c7719df8a834e65cf4f74e52bacf03333b894361bc0504607bd3c51796e422d3aff69a6086d5aa98943be527f506740af10d8fca9735a696fe1175ef245f49edb7023302980e56853848e235296b5d1ef1e014fc97862134dd8f1dc7ce9d69b77bc131688a74f16874bac29bf3a77f62beb70a111e5846362e2933f508d61702f50cc3fa2cfebf4fd8b78703fd27f338d56a8fcb6cdf44211e9c8a8f0057e5ad992d0ce3ed8f77ed73229fd3bd19a9d764f59d45e4b33e963dd62a210a9f665aec8dc9ad3028490db7fbb9a1dbf5317a0ef8f2c1aa61c2294b3e265868377d9373f6a2fc039e67e92a2d5be78e07e6b2ecf9f2c0660582bf7269aac815d9d44a8113a71fb104ba725ee9b8b54b73a3bdb8ad65a6ea7393cdff0d769a894e00060d5eec12cc1d8364ef36ed8f556a2a9a24a434aefeafd38ee273947c8d946d4dddf65cc1ff283fd8ee3a3143608d4cbadca38351d73aaa4824432ec3616b7e6c08a631b14e749ed7cec442daa46435fa533c2ffe9e543c7e2383b1f7c8a7fdc126cc84aae937b3b88b6c5a206300e88c0f879f29cf83b4a98b9158460430aa569e57b775b62b661b5e2249114bea3ba6c386e852b916ed40da088c0a3180919c0339e1a1e7fe85d7963374a393a8ec0126360d0cbfd7f8e591a88cbf39acecfea27d9ea0686b8088bcfb7d6fdd39695b17a6a5e5bbc9a0b03e382d57bac287a92dce825dee84f19c6cb443485ce4fb79a8548b8e7458cb545a0a130103150701d59be4bb7a1b3881c3e8d3345546188b771d07374f2948c6f6e0e7c9e8dd9d6b704b0bb576ca2cfa73c904f12dae1db4764375c7e7ebf9daa205563fd42654c297fbaee6beeb2e859003bb82f8eadad7538dd3fc55150ce09dd76ea9b0dedb2446f2fbb87303bea5fbd107d61a566f67afed25fe38f3cf58e8dfb68a993fc03696306ce14f3608bbbec66b5e53587475ddb7d4e318e45c617cb61735985618f0639a617536495e10169ae22fc19774267f9a9924dcd68b4ac291381352f1f8da51bcb3edc4305bcb1303f70ec1fdad81fed985d39f73e3ee50a2c657c46f463f692058f714beb7e33b0c5e8e9a94719f4846c69b5a17e4630ebe0f38ad63f954be9b3eb60d8e3e886183ea245f0179673234d891604d848bdbb45136e0db8b494aebbc870a586f37959f6f76aeeba2f6de0d0a2d24691c7dcbcd7a6ac1bc70e809578445ce941328f7f45c948496455b61ab17c3a127e31a7189785cca09374ba2d8dc692f4f789b3574f31014ed9462f3ece28156e919832a0481c06aa01edf04eb7d4fc9ceb6626823056b268c3bdc28d2c2af6ca975f08cdd0e01c37946bd82bd85033ffdf8dd970b6b4e13ebb9f62033c39b57aed66228983f14c85cf65f40e173169ae7ce8445fbc5afcd60cfb5ebeb3f475b49ea74d72795496de6cb790d896637281159adaac2408250da955862f84689bf334a00be0f4d3c54680a2a797baca3f1ea3ee32e90804754d32374d4d4c8d284a7ce68dc019427f67c81f5a30332b97d7fc7d1b52dd782725004d4eec88ca33880482c387ca76caf564ded1d63a99ed17ea7323388b0452445732e7fff785f9c09348db355c51ed6aa5b6f72e343bc042ba915c04dd320750ca3599f3b880ac9c2a8a9c89532ed6e900b46c92257f3737cc15da1ab950db472821cf8273e651a80b224dacc6dfa041f8b211b4addbdbd0a8ff40479d8f98c1581c79b6d0927a8c72620f5fe7ea8a737412c40f8110a1118e9647677a1ae9a2134f3cfcf933e5fd541acec9a52dd0b1226fa5cdf84196be664438c6b4ccbd770aceac06a008b00c70d3c60ac2a969833cdef0624a444c757d8451051f0d7b96fc63f396ce9c1007a78efc4c69306080291c46a7d8dcf068479ddcfbb2d6d3e6e136a3fa227a562e1d2723e2c33dee71e91c71c77a7110a426c686356b3145032252194a32a74ecec7c62b0d246bfa3b8a6eb9e910fa98379f773d05f2c5f988f3d3ca296e7cfd93b3ef0bc8373c4be1f65deddb0e73981085cd43a043ca282633e09205a24c212ad0ebf7da4d7c5eeb16d130060a9f54f463e564875b039fcc3398af53e7434e53057fbb2617f8303af2358c42f44a672c4908e60701c830f2e79353727b3ef12dd9b6073828e3386d2d5cefe10cbfffee79c666cda50e8e90c4fe7c37b589b128ef23db9fbcf4697fdb1adcb18e6eee876cefa8bd45bf4aa84a24ffd8a616d5dcefb7f32d5cf4075d5cee224cff8daaf8448f7ff05b566178fb214fe942e12a2fa5a0df94169def72d9a6f7bae56279d54cee1a93134f3f4e48fd11fbe01e63d310659c0be52005c075b565f784766a120d5a29d52829e8b068bf99fef496c55902e153513e957d62307ebb04ec21d316a8892563a886d9a58c36b706ebc08876c105e4e79ea6a79058196ce59f10001fa949138a1094e8882198e4c97b187d93fda431a0c8269e6ad582037550db6cad95bea23b0f4f64a86949eb37ee5d3ce1e29249b35d0e9f7b23a64c05aa526d1392a0c0c49f02dcd7593f7630e0990fde653db49d01028d1e9b4727c6eb174796dd92c1bfdea213a0ab54efff17c44d06e0a267aa82908a196cc775b0715617ceafe97e290bcd9928017a63f81d6741af34f152528a7c4e9106097529c985b4e9495899bd7591b29fea4753944c1c140ea7e4a261246c224dfb4c296a2f47016076005e015efc60cea1672312cdee5b4f75afe959dd2c3f601c713be0d82d09ffec9e471c61cefa572235f820e7710dfc928dd1a2ccc010a485513c5dd285a9b3559bd66a96a7468843fad06b1160cb4259f147739aa8705e734614816ff186ff9a6a07c3d3ac2b27d2fdeacbbb95f23e1818a3484e286d1abf0edb28e50ee9c7e5fc1806060b5071bb2b599d3290055ada8d830fa41687d8eb060dcaa0bed685277d23748723b5345a955ded04a7b269d11775dc562f77a0f0b248491bc3a82fa9dbdbe5a53ef8fb0a3a31441b34fcf6f1828cc23721b1d4f1650f76719daf650bfca86299ef6dbdd7f8d0be58f37770e80981ba3a742966c6700cf7572f17317cf04394144e4eac8770392db52f03327b02aadd68cf0c8690ac7708a3335d4db30e1afaaab54a38b3601524b5ab5428908ee2429ca5850284797ab19ca2a9ea22fa187953b19a39fe0f0a750fa5ab7110a4c539a923f08f01d56731e00ef2cedc9c9a466ecf4a3f0d496d6653f92e88fcf23d61b2739534e7a6c61f273041fec9d40ca84bfd7091eb2ec076198e2cd41d6969fc7f7387fe6e78e4bd1bf53b97f8205fbfec78ae0779b9a73d836c7d76757d0518efb7cedefca687137b7a51fc298257748567c17bc8056d49bda5eca9d6b96d4e13b72b7ac0565bcec2811bdc45e7545aced00104a4cef0fcd2322ba3dba24d94938064ab52760b6071efcc26e08f6910462fb29a541d421d20740fadb9d0e2d6524879915fda61e964d4503106074cccedd1660f3fe4d118db82554bbeea7f9b7848ece5c1b5d03ae36dc7d5a6c089ffce289624f545603534e3fb1531712885af970ac9a063f96f44ad0c4ee6b022278ac383bb196617a118e768c89753850f9d66911bef8da5c8571ad1c70b6d11b9c9bb7d9cfbb22f3fd410d8435eb0db2e288b75a0a5eb030a2266aedd44a979c538dd3625b6cc10a2a9f13ef02704bfc4daaf5e29228e2d3b8024840a6dd4266e7bb037ed07f3043a8c58f85c34feb2e966eb27f2d7b6f8aada2439e38eebd83fe28992f4a9b4fe713f8eae1cc6f9605d116fecd810f6694bce15736573afa6d1c8f63000e7c96e888dd54deca2775ade4d9d4f3046401e9317abd7fe11987c4b56e0e7fa0199eefced496e8d8cfc87f166233e49d9b482e8c16e3d172381f7698d0ae27e2655bee097f02a2dec27aed3c025726f2f4a65df5b33894a181e074ea15ed9574157e2ea960ecd61ad4852175ba4caa49bcad7ad0c3ec4ca94341f85884a891eac8d7a6e3a68db2a80b54c4bb64bc3df6db14bc324f1c00e54ef0a75be58a30902e5e146f5f163551c32afd5761468dadb027fea4bd55b7a4b9ab54ea3e7a736fe53b0db58ee3ed24f1d1d042d728b4381a07f0bec3b0f443d8700b66b6a693af6ad791a72d8fdee2fefddaf8334c6da6f140d6d80d12f1bf888ec2500cecef69ce7a9537d099aeaeb9384281317554c2299f2143292a5d017c5f82f4b4557ce7acf6f2e46069dfc0b15c0df3254643548352246710f27541b7285cea1492f5dde87c2a0d6c6036ce4ae6f7dc9f5211b1cb53d323987a7c81eb8c922285ca95dd80ed3d7942969e27daaa32d513070b634b8bc2b6d484ea848e8bfc5c4916346beb34ea2f95a2aa2fc2827b60b402d354da8cb86eab83ab247fb44326659a3c27c0532b47bc2fa54b122b79733a5231d6b8243b8f70eebd17750cf7ca70edffb69a75bd69bd32bd08aa2bd9040efaca04168fc6c623d9e19eebbf97170843a5e684589010c20766f64c68a2ca5c7ea1e398815559a57feb53621b8b39a358779d0a3f2f1b4d446774ffed5691bb478ac0480e1ba53b8bb5d4f238e85bb3f43b2b5ce295b7c20b1a38906c963f4ed40f811e7a717dcca1a1a91c8a9dacae2a96066891855522d6a743a87cb864ed1a8f5ff384c42e8e3d5014007881ea260f44c448b747ba481c31867e84fb943876605ef563a4fc9b0ca1b156625c040a7887d57ad0fc0bae0268bab49238de25d1c84515f185bae5ee6dc31214b79e8ae78cc50e175df108fb44b100158d6c69cee1938e5bb3d95d9d167bccffbe9d8bdc4bff9f35f35f555d26cd6ee5923d2e1a17b311d53dfd684562ec41ea0a6d911800151d2f708341a2b92de78c0e96612bc67c1c297eadd3a7f1e17e000108221d45421dab497c3990dc743caba37b6576b5e1ab0e3c3f6e78e13ca963668000c4bda4f82b563fa4c3293c5cfd4f5cae1a9aa84cbfe9ce7c7843c96cad74bedab822fe55cfc36afbcb02184b839425292a5def2c52d76dde09f8cbb081f2b538aa80fde588f13db88af79fb7d1f65391cd2b0bfb5fab11c83d7856b7724100ecdc21454fa7780ca1c4b4d3387a6c48a33c7f22b1fd689f36ae9c7358e573fde940a21532128de1781b36f2bf8301e2c73225a21138da04b3802925f55ee4630c96c8b1686800538cea504c0575a2893947502ae24fc6bcffd378e0f0b17b4de6c5611dd80d7488f35862c8885fce66306a3f7f7dfe7c7c4134390cbb37bbecf1f3f6dc520b66bb7d799dadc92309967df546ccfd7809e2fa173f543e7662b4e315456b965efc50557090f5c8050955e8b15871ee0ab6d7578548519a615d1f12bc040c1759f883dcb6625c76472f47236d2b18af4c2169374f482c7a29a1c12d82d571db3bf6d58be5ebdc723e1d39c5793013305b44000206ec0f0ff04d942de798276fe8ae4833e3f77ee408d90859692727edb23eabe1a4a80b292601e58c641a0f6c5fd2b43901285aa18b0dc78fe2da7f2d03764965c04ba4cda9be57121273de4a877ee445b9ecd00f46bfe6f60391c4781a288435aa9fc1f314bf26ae8199c910763ef5e581aaee15da99c5c693eed83889daf2a2b0449951c4a9ded4df94033b9a5e254acbbdf6ae98866e69220671712e005391f61d534c720cef04ee8215a3f40aa09d78911c5ca6650090d1cdaedfb4ae849c704cdb6864dc6b168801a2edc979d8a0259a39f3a7980d574fab6d25e7291d5039a556d0fb13bfa4ab44e5c14aefff7e16ebd8e243631b350ec2e7ba7a0122db0274d261c97df1fb6bd732407964d36c841442bd285e30f92402389af4478c99288ef6016c3626d9babc129e0d9af76e6abd7c22fd403481a5a9c4092360b8f07674e530b05b3dd8dc458b809fb665ac9fcdc30d6b4a262535a61f131507710d7c9e04600e23c16c6a787b56ef69fd3961e808dfb4d58b5968f4f3f6b40906ce30b2e48bd1d9e6955758118f09ad3f13033a6cc74cc062d7e5ff19d98d208fa86a8bbe368d90ad75113f87998286a53e9b5c43b8181e0280676aad0404efc4c6b3fafc6d8f83c433f3420fe5ace40b951ad6d5d408a17c63846c064973e45a40d554a8a1d6e7f7160fc765c1bacba4e737ed706ec9dc07e1625ad94f584a8c8b2c52ef94eae7508e4e1524a24f7287cb9888c8f59b60780cff0f403c779a13803e41d4e6eaaf223bb516d8a93f5776c5063d6ff71f1aec152ed3f1196f730c53147b5dc7fb39f7dd02664e451b5fbb8abef84b1a438a08a20cdec1c61afb5ff5fb5f6cb4cac0214e9243ad8576557eaf014bc4527ef228b5f0729accfd3e1b8a806e510d7fd41bc3cbd5fb7824fd6769ebbc787e457ed02238a55e0b6b7f3998bc26f24fcb66e53266596bee283c34b9afe2c2be768e0c514062da6edb00d68634c8f4cf2216a3d22b51804199d57791a58a51b0630a3b1b9dc6f98ea2bbab0dcb4f4b37348662a304bfefcb5b5b38d6dc01c03b04170645be4709d0ceef699f6111df822abb2ecd1f094317f44142e4593b02d6b4f99d6ec6d165627452951c95ef725c6879cd6e8aa8dcc265c47649f0bfac5571947504bf1bd807c50173e123b684d979f7636a105389aa3475fd45761778c76393d71457d409b15531257ee0f74e0d223939e7038e0aaa0cff9b6ae06c671050dfee035cc25187da178f6f2f719d355eabd328f08027fae344fd117dc52c28fcb44a8a815734148e1f0a06e508a3beaf5924ecf1df4fdccf5bcb7076ffbf4c7d600ea8e46e71f6e48b83dde3ffb3711b8fcfc978a1fcc7f74815c9b1135d37d9395fa1a7f3fefdd361bd81545e926f072d0ce2e5a3252d3472be8f823e5c92b92729e616c21853c658744af8543d20f78063aeb983879ced06ea868506393974c65459e1018aff222794c06a8273b8cbcf1d1962a34ddfa0f3294e77c629cba1df7ef41e20a258632aa98a88acadd028d147db54dc682658140ad9287bdf942e3795b574ae40b3e69781b8c86d6b9ab07078437ba5832083e31327f7ebde7a900e5d546eb6807a426064919b3d64d36b14104cf3d7f7df49ccd2a3f39686fb1c5cfdb1b7b5a0e9f5863ddfd93c447871edcb9f5f666d508c71828d2fd8433425a69adb1f86a8e73e9500da12dfd6bcfec935ca95b7f63b69d6f7d31288b2412b1c6500dfe1afd2eb8df4d1cf217ddbf7b7cb6e57c1fd75202080abd64d89edad85da3da1aa34c3fc1353c04c55a4f8d1e5a78a2c9f59db0e6ed8c3becf58461e4bcdda9c6ba96735d357265ee69625c7bdfb827e189186aa51584d5fb032572570de5c1dbe463451da7fb6d550769ab12724936266cbf058e1248b05ca730d9f6146c12ea4c4a7c357fa77a0e3799aa0794d02683ede5f1d8014677770ae76dad40d09b46de65c3a0a193898a3a9159fbb43f780bc306d3f1a734b3775c13cf0f7110bf59b00ddbe51d4e563ccfbc7bb346e2c57d6c0198a3c481791434bac7ff3e100b991725d9ff3490b3285f22602b3c504053fdd719a6322c858956c835662dda4a7db25c826a4933eddd319685f99d11dddf03730fc72ee68074b66ea2ef8b8a6b668b8ec3bc8952887a07672b32c469e50de8ebf97c1b3f8302bdce4516053931654db0137da11f3f7787b42e7d27af7fac86c6dcd74e6b2cccc74b7b9580e4d178b92cb2cec99ff3ffbf82011cb394e071a9bcc94ad6127f8e2cb028b7f1345438506bc675bd501d9ba2835d0134ec3da486342b3d5697984bbc5152d5f83ab2d565cbd6e245adb6e79c12cb94f6c15575c264b2c3ab99a2b39242780b78222379d6cb0c4fe2eafe675d35c73288eea8c64226d16a4545ec99039fa21675f08e4defb352d7f74c69a099c69a250d7cbe853d8476c7820be9881c676f60d51ad01b2d6e26872948e3412f5fabb804bea7dec1bede078635879adb53d71546ea52122c6c3b831d93827c057e9ab0c173de434a08e6d9dae5517c878fac0c6f9ae1180b73ef8742b615604d6dd0ef361099dce9feb166e014df9262865095c37fe3d6dcd1418d11f68b09949d41602f316fe7f667f28fa8736270b3c0c4b8ca8e3174e230636c8d517e8c39d95d8f2c16359d0525affd3df3be881c67db7b3063070c599147877520320f7ce21cb0ae8f73dafaa18cd37e93ad6b1cf9a215b463cc3624d7eae1f059172a8defa88fa7b2af20cc9648dc33dd81136f3e7127eadfdc6ccbde128c33a53e5d139613dfd8330878ead774b50a9ec6dfb88a44525b6546b6bb4ecf6a9de133b713ed66dae301e476873056d3d23c7baaf9af8a1ef45e3a3a9fc963ba06adb414bdf48fb94a8c9d52b0b814650edaa4111eeb081562208506ce311325f7a0d407ec4fb313c4e5ebd27821c405dcdd360bc423eaa768acb6472fac76e8f85a1c43df7537514fd4d4fa54dbcc6f5bd344469662d7b0428f9a3c29475baf647522e9de32eac3dffff930ee81772e2f933b8d7f7ac39a9632e4ece6a68f31bb8cff6fb795b4f3bd2d6f30dec551b885e599ac7c056312a9cd0cd8ef9755aecb88e6a95716089a07a079df027f8131de14891baafa80e4a32f1f3678d4ea8cc3eff010111c5d2c31c1dbbe84c81257d84de1da7e795ea9daf8995c164a43eb74c3f6dfa96f15467641fc9cf25206b3d2f09673a5b7aed1e6efa3c93d7c67330e9bf5ce7c7e04a79fac440dd1437456e7e49df8175cd8521ad557b8d5b3f2846f5bad05d0c81426b971ea3aef5cc8ad62ba8f34549432f0111439c2cb77a81faa746f28de2ffcc56ce3cd9bc6b5c1b7ae6ecf9430b53cea6d23bdb3e32a1bc1be31d05d505696ad0232ece003492c0440a3f9b84e496d38ef72c291db915a85302f0baad0057e9405607be19b7a07617926164f68e0f61ead762c3e245c621fe52a44f06ba94b23d86241d3b4f7b4b91310e616119dc6963fb0e44d310d56e7156896a185ceca302772222ba516a847d3c51fc34e5f7b87417c0687e2f1b86a2327155374aa06bdf70b2bbebc08be87f22a15b9f848264a98c01495b72eaf26336ea64e82fe4832c54eb3e6a2f4f89c3fa96a2412e2ef6bd0cb78d8b5f8104c66a198bc1334be4359873bb81701b17ec87a0cc64ad2cef010bcb3404f2945b9e921258948c3a6e896b2ab3506f31365ed0476bb3ddecd8d31091d4f90bdc5ac772c7dbc94dbea2a40686a66a3d2f1f07de4fb4170e4b78339291dafeb7e84b0cb13dea9ce83626a67e650545b5c72062586cc88a823248110dfa28b981ec57176c2bc059bd2fa9ce96a497571b87805e1e797b9bb2645817f21b6cb33428e3a677411a9d006236a23a0a61360f98671df78d2fb00c3e61d0591f3c0e247f2e18ea47e0f1fca7e347d69bbf3a20a9d76d1ed29dacb8cf182d0a49a1b2af2b19fd0a75ec7086477d057b814bfcec6e59b57b6885eef0c1fb85e6d1c16d08ec1b73842ff91e55c9111662ebfff210c50c195b84ec57354457f7489c873588451b148c347447b6910d9b30547d8b7bb02738273ea1f9688ab6c02531f43eebf7eb358bbbd836f3c96110327dadb90baff0ebba6404159e639c445c6bd751cd5afa6b82c664102419ffbc3eb4bb41d60d6b960abbd43d60c4883873efc7e7bad0bc088ea8162e3b2d9774cc93dc05cd9566fc2557f5437e93523f376adf8be282985dd95fa42223bd79d6b8c60e42475a3be5e9cd39b9109194da57b6db358fd288054d7c8927241142e0e066831d139fee1a661c18cdeb508b5cf711278fdca9a2244d138819f96e873e42ce8f703668554ddbc4855d960ac05d3aa6c6956e4237bb9f59c635f3c9b6c2e4c590b20c48377c5384aff09b1326306520dbb50ad66aa50d057086ab793fb4b9808064724dc9ae7b953883fd30e65282e915b38732df429f41befbe67637f15b54747463d277838232b29a667a9ddea50cd0b22f365e6d0b637a232eac3b719fc89a973a32a08bab272f028dcc5b87743018a159918dd961e7fc9147a0c22895903104c2391a3876e5eef349fca04b226dcc2283247fcd36a8d2f6a14c52153006e9cf7775569c694b0e2ad61ff173e4388efff317444493ea4dbef4b64aecc4412dc394727ecb95f71ee575efef0c82795510f6e37b0a06a3b08f0227340695b86573fd80457962de4142982d6517b90f6af82ae2237a3bea48c7753588a074ddb066ca52fa26072d5db5dba3c2b510d61b526b5d574ad15819e79f339db52e446204a4ff85df3c649d8e2de13429157d80d86aed32a4110fb977a318d30c77598fae860a666333894411121ad623b270ea6e76450b16c02c54bdbecb0eb4c91df425448241b59769c4e08c72221f7eec73d76bda0b090f5c2e6f4035b50db61f87d008b9251706b5f773329b10baf23212465a25d71264da9c64c65b9305545117629eabd424a1a7ba936ac8c49141800472976ceb3c481e96067978f81a29445cdefc6a620588c6834bb8f27f0abc00569a33cf286060aa078e6a953d719c0cd96610b5eb5d3733c7a1a928cbb501e0d91c491586757af35e4fdb0a1ad9c9377cb4bd30535226376fce8c22b44eddd51070e9b08783b9d184b3301ab5e21db6c09d468e280b2cc267a8c55fc65dbd015c6aa8644660c454f4ec366c3b7cde458e9f6953fc327c4d74af65568d04a15cfbe130de466749ba22353e966797adafb0b70bb8e73bf6380304fab8f41838eca83cee719bb2338c85b243334cd41084329d7d7b4ef3743012cec789df2a536cff94dab3d1b2ca112415c78f59e0902e90cb3af783f4044106ab1a1e97325c4dc63c5d70158ba00b865d1fce4dae5f38f8ad134d515f5f0e35d0e34d97f59e419982c4892cc5faab74db336aace69a1173678168ea6ba6b8b3876960929b7ae7fe8b537b42a0b8a76d709e982bdc7163435b3f76f13b5ffb6dd379c8e71a96460221fd505f7717fcfcfea0bc77b1bbfa67519371cbc4efd9bddeb85fec7450d8d8d1d16d4308c19d6d9a7ea08a29ef3bb16738fae443fc44b0f3c5cb8e32bbb504a37f055d5cbc988b80aa19aba11ac91daf6267f47e0b70f6bb098560498605c0b8e2ea9a5d5e754695235a387647f6b5eb8529a663961fd75c755b40fcc1321b78bcbf222584dc378bff47d9b0184a24efe7e6bb37c3d761f75dfb7531a4534021ba2e2ae5f90279a12aa6f88fb11d1cad4124ad429c909685e860ae0fd91c110ba408a89b0b8effb7d4f5b752283f50b1ffc9551144c25be9757553f44afe2ead2516b820dafb5b9739a3d696c914f1e2a3c24c7d2154ae6eedb838e470aa342a8e5eb850db5ca815dcb4ae3191d7c8f98f5bef3263534af2c80ee00407ef95240032250a67c798fe9a87cc32c8a6a4336ce444002b840f27df1d33f4061528c402b58179a5cd0e58287ca3848c006d5cd657d96f2ff4f9722a4a3fa4f8916a15fff74af2963b6fba3748f832d31c165e2e618d65d6c1c98716fa5101a0994dc8240949b7d70193a55adecdb2cc85267ce34844fdcd8105c94094ddbd00aa762558ed28fc8a2f9d193336cc9c758c46316ccf16c082a409fd5137e20fe3f94725433966a40597b0655341b3306b45772b8f2353d36f446d335bdcd5e3baa55e28ece10a773c6c1fc9ae6c9feb5f16faf2752c5da8d20ba8b61614c6d3bf74b92c2877b44233ba28b638d3f046b149709fccaca5021ef4851f5a67d0bda4be4d364edb27e923c40afc4789c3502706415e56232e79e14a0a96110aaee8f809bae8dbedd2f6f32f19184cff72962b8b38fa182af5bfbd4d9f42c2709ab2a0b7beab65def95cc4681c0bca3e75ea5713c7657436b673e1382443a1ac004a200f6479ed04fd579c4a04890b2ad47a228cfa8cc64e2c37eabf51c4642","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
