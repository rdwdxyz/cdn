<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8499190b3b3edf5059cc5227e99ce70a17cadd2eed1336b7057e78b7998e42daed6d8faf08d100241b3d63407216c67cef3d13f39629a59947f3e1c3b0e770f7fb210109ae9dc8df6e493ce3c221c3f877697ae7add1ce623b67da7aec263070897a41f780efbadcc225aeea062d13267bd3b2b21b78bc31c2ce89239145d48711c3a50c5a9c4971584985beac1541027d588e998ba3aaa2b1073ff51d3e737261f55f67efba535dfa131689eb925407ab75cbad4a4b98591b6a19ee1c3f5248135c6d28180cafe5f10fc7e17f6b664dabd2c6b39f53e0fed346e3b408f65fd746daeff3f35e0712b1115df94da22f208c7fc7f1bac5265e6f0c3e06039ee7a43967cf0aa9cda7f59c815696ad42206b8107891e0ff36b5301430158ed900a59c4f7d5c8614475d3187b888790fcf9c0ee017a42fe78ffdf87dd0d6a888c576509102a00de48be8f9c7d161191d52a680c8c7c41602407155756261877fe219e1e6f92c5326abb426141af36e3832c9e30bdb59ef0bfc8b9feabcc16cdb2d0cd8118d691f7dc5b4b4b67c119c6eb45d83db20e7ccf244da6aeff729166ad36cae7bab9148e5175c5078f2542a5582e1f0a1c538ef3d04f357d2af630e132be99287da7c39dc35c89cf13363d321611bb382edf3da48e755a6551c4a01bd86e94be3d74a393be213cf84246f0e7861ce88c432cb0c7a66f9e016f6c325c6648e93eb03d17c0c6096aa1082bcbfe04e75a0b3ecc3be22c4d7cb2d18fbf9d5ac5700f789b2195c737363e592a2464b48105211dd5cdde547b8b0f01e9a8e38d7ed1701dcb844c66b14fc50a2f80e28ff5dc641da2772f658295d238646f5835f8443e6bf73db18c4b2c5637ae97cb9cd125d0c189070e177593765c11394d92306f823d02bdddff14d19ba53a4f1abb30be254c067cbac8bd73d762979d2d9d7aee51437b632897006407f97153af106e6bd100444f65068447fff8050e6a2ed1e33ae820d732a9c59cff178ed30265bc5666bcbf3fb1029721bd1298103daeb79aadb0c9d828203fc2285c6666ba7120f2a14061e24d7d5675a3ce730e3c238f8a889e0fb6e1a1c0b63e8ce9a032753ce20d3c12ddb2b53031918f0604072877740a14b514cf7e882b8de8d95d8c40dbce0b8918f32e62a172aa2f9777cc810eb41e19376abc9292e9b5d92fae7efb1cc35a377e7138aa4e21915bc7469133b0bb0859fb3aba89766df27c61ba1955c7be35658e0246879dfb7cef1d2dc19f6c5e78ad6d3282c8f6e27a5b4d3e60b4193fab2a86ad4d35c1173fb87f83172a975d2c6bbeb1a24e0435b9bcbdf8745d3400867f44ee68b8915f06e807faa31abe6e5a9223ee3f1af6e23457ba660a9f2fb00b6303b60fbb3059c5a6e43eafa42947792e4fbbce8b00d2917e63e132c284aaede130e55b533972bfce181de51acfaddf8be3678014c7815e0fa2114d8745addae0f14488cd8a64cca52270c688b9003ec486368780fa1265ec48b4b39046cf2255a57e560686f34a6403381c2c104f9d6f4751fe6d2d1a417fdfdc884d481b042152615bb9ca7e7a47191e2422a1be5fc709b3cd3db700dfe7b2315d6a2565a812e90d34692d5e17f70ae552221e83470f5a4f2a4dc4d13bf20729995f626fca6a4bbdc328ac73c25eccc2e368decee19c5807b938687ee84d6097bbbfefedf3360d15a9b15c49141c5a44623d7f69f3cfb2ef0642562fd1fdf9c04e3ed0cd83a82e2761d25bc1dede2b0d8f6ca34a792b2337adcecb846fa67950b1cb756f66e07d426e9e9ce7b7146bac847a29741ea97bb85abbe8b2a3bff443b265c37a757310ffc0119ef107461c5b30f1434cfcf5b3bbabadf83abdfb2e674ade81ce0cc9c3f115f7b89c8b38d781008351f5462861c5fabc1a61299a46210c21dec0e84a406281ec33925dbc76ca7aeb1fa1a77de63ef9d1744a9959472b4987e1cc987d50c3981cde4a329ec7cec083d4b8e6721e4b1aeb9db1a25f8f0dfec7c9d0fa036e220ad001a5a13a10949c76a6ab9ad831f24a6c6fe59ef889306b015a0174939c9fd96e4d38b8155a6065f2f5a355a0d92628d2eb0fe11f426a4844af5d5e721868683bbfc8814e5b509b3b95efdddb5651efb314176350a078e58885cb8df64af5e82decc8ececfe4e24ed0687ceb5e99fe1a4baeb632c6f507842b07e2df9d55b7533690b7d7677f68d10dd6132aeb2f0518732185bbd2b49a381088ece75b6eb09a3e1574791838a96067a818264d74bb1fdb71286d8a47d429320b089396bc376608fbcb84087e6c54b59eb673aceffe9017bbd7eb0d04832d76d32c313cdd6d1c6fd7c5b084bed067920aff6c9ab07e2423e94950f44b30b3bbf77d5b9210b119b61b45c6c834623e7fab133b6fb1eb8092d1fc34b6297486fa019638b3e83a1c4cbee00b34da3094a1939bcd713cc37c204926f4878ebcc140999c1f6f61a57571e144d39b1b503f63523795442e8f3c8c866f660e3a4bed9d7cccb8ca24ed3dd16a3ea4290f44029f8d36e3779c30f35f5ed3eecfe566328038e0e752459eb91c3306b49952822b489bd9d7fd289a298d86568917b1eb0b635e9486ab4256e41a2d30391b1a218533ba664fa1a69b60b09e9f8f4916b775398c96b1175a20e929433c36351271ef8e9c1966a1472d68db07100feda27aeb5dce070b5fca26a1204d979cf50207221033c0b0897c7fd3e81b408f93900af48279d1c6ed24d103f2d3f22acf1775299a7a19d97771ccf45bb5f8cb4017adbd94cd5ec53f3880c7c5c3a672e38659307885d019d38916c4a7f25da676a9b63c0c3f205d7e3328ad8c146f4b8bf9ff3b4f4ab5d96c501c4cae6c20f9a7b48384ea14ffc3b1209099385786e103abe448c86d650690e80a655514dd86f864a5288c6a517c82e428e9f7ef0d5ba7ff2218dc2b48424524e8208e58c05e91ced354b180f63e1e1fb5670ca93596cd2d3400379fa951e82dd935b242cf7bc56a1b0dbb128d9af026f8042f359117a02d0662bd440ec228033904a57849a2924678b0f88e5c35d83f277a323370e0157e6c7b1af1bc5ef88426c2ea3bd84a3f0b25ef6f91631b6bbc9b9ffc0786542c71582d2cabb65e86729873d3d18ab51c1d5317d0a0841ed96a284a3aa110daa97c399009fa3910f10b5c1fb445a90ea3db4445796acbe66120a37fc926ebb4db0cb84492886f049c4af2139786ee2d9b689f92d11e186c126ac0667d22029627b0498a140de9f43b6ba0f6f947c3c272ccf8c566087f594a6646a924169beed87ed6aaf74b41f00df719d2f29c36748d00529a5916da8f449492c6137d16b147c97a534d703a99af29277561161c74066ee4078d96eab604d6580a4bfefad791de422d2da3d8e633c5c3b78ae5512ec4a34f7164416b7f07325dbb48f40ecbe1f57a118c9b603312f4ea864abc4e4bf8091cf2d77a312944c4c22af99718ef68ad09ecbad014e80cb1370cdec263cfe2490fa71f695f4c117d674ab022ca0fa2d8511a74526db597f4e84a39b5d04717da9f7f1496595cf97dc315c83f8ed3709eddc02a77e77920560cb628d9e0ee14d9baac470fcac9b297304abf9187bd3c7eb385f47dfac8c33d0ee31cd38d41f7438c3e522d1cf6bd886b73a6a2386d19f720374ed52719a6742e0f4f9b8605bd9318937d30f7e6d44084bfb35a6a7eec4ccc673eafa732e51149ca39866e09682d504f13e65128c551f4b24d8c3e95e3cc0f401ff5b9741d2a927ad15b825c8920456cbd34c165560667b085d53cd58bdce23a41e4a2b831b07de745ff0954b7f22fbe26055dbf56cf72962a8bc296f6dc5f515b2fcf9a8cefcd9c129f9173d89b9828869d30e2d2be75b3382b81eb7f43fcab47d466d0d4adb71859a2e5ec9894b4acecdd0379008b3558b03d78846c734591135aef5a04f08f5965786266029a42433ab5c55ec19bfcd13f55f3980cf75b65dd96b991e94b5602047757f9cfc91ecc98219f794b8cd8cc69d8e4ac9a14e65975f87b5b233362e3791b76165094c9fe0e7d888c444c5100bc0c7a278c26757cfd9d783b63037559c574c6e8d57f265b51d9fdf061a11f9fc3cd46b25d2923698f89d7ee5194f87179c34a70419ba74a8759eceba175bd5d2035fe7969743f6f6f8cee339e9394428b12505b3be380fcdbaf6ec20d0c48ff2da2e7d99890e0e2a975f0459a96ffcf42a77e615d3b89a742c56ff7138823e102e95bd1da1a697c2b6601552b405ed301beae5be1bd0e7cf091657bb8e88673f3032a2ec48eb0f4eaebfc7ded3096d433f1f190e3388b1bd84d459be28bb9e093c59ed6962aab2a97b672613afd5755e570b763ef062e0d092aa551bb97d7a23cadb6958f0dcf3e7b2a94b4b1aa1c89d55626678a965009eea4d0345422de6039564b29e57fd0b344e45f0f600879121c1237113201a8e278b33906b3ca341a6e970561136dde26dc2e3ebf591ba68f78b33dbbe242d50272336aa5fe9881a8ac6703f1b29b3fa7baf44b780ac71e60ba9ff357fb5314d706592a190061f960b94c75e68a2350dd1e06d09d67d980d83c4cd5f65b9a7490daa7c777e86a747d616dc1d1c1fa53483cda64a2a0207a7721358734bd91c4be18bba67dfae08090d2033bc5276203ce92c63a709464f3cf2bf54741d71c53b4a0df8fb19d901b5eab1e95f0d0f5ca8cecd4da92a98242621e797fa64dbd7ba458babf6a24e062e92328fd1d5014c5d750200f9c3aa31854ed564722b5e5393fed7b832692420dc08781c7b2227db0574975f53d532789868d497c222bb4151a5dc480add8c2c14c3ab21d4fe4d59381293a73a23e65043e9b2f6bc897523764ccf703d0aa763a56aeb5484356d0b7a93bce42ff328485ca20cc67d74439a04d4643a6ad98ce3dc6aa9007214b45f8bd7cce07c950a09af3aad30628c89294eadc27ce6078e6d0e083197846c85120e77636cf9d397e951798ec0b7462ad2512ed1b785d2400d91f4bfcc3bfec7a3c6a949095ecb3e565478f28af6209bab1794073d6e9b089173c3b6456a5aa437a8a91ac8663bb7b307bcb928301fe6740ad0ca1ce765cebfb0902f94b13ec305770111515e1929edc1bfc25af452a3d26d7f56d3616d7087910684a34415150448bdbdad4f66290131e04d3592c91356d211d09b56a325f644e61c5e6a0e8bc9f8ef686dcc38688930120254effbcb89167f4fb070d76c3547476b0cd14ee655c7d57b8124cc2015903c11e18b1e513d7edd32ba21afd6b092690adb6dfafcf2d1bec6c0b39ca4b4a16afd47836875fdd2774c00c6c0de04557919f65928f961c3e51d38ac70938289ecf7ecf2f399ad3a88b6febb220b4d1512012e48551e15c56fe147f23892ef60d836f7e30de1e546d1238b206d17be4d61f2b9da8637da60e813c31837e210aaf3841a7deb1ccbb6c8238aac0d4853d238f42e0adebf82458e6ba01c2f81ba9f31220c222b78262677828d22afaaaed785af24ee5d9dbca5a189574211887774ae5ac463c12cdc36f48ffd3b8d583b7718303f214d1947220ee617e6e49f68a8abf5449a5c09d34752bf79a99044d9eb9e6262047d1359b0cf54c121dd7ce5385da8283fb0238ce28d022555999641a1521d28b26b55d36dbc0901344ef9d98144a6d1ced95cf3cbb7e3be3d33a7b5745aabef14eba1797373376f741d589a68c1c72ec92c768afa0e619fe39b1e2c26e3dfb25c8e5c4c8429d8938a024449d85f8bdb03bbcb6619a7f273a1db5d5625065e3d33800ee3fa406e2e5a01c881255a4f3aa8f2e45cde756b58fe6e3d0cb19f9ff638e5fc2dd656a09aa4ea5d230efcb7179fecaff498859f5bb185013602f7a2a06c86d2ad1b4af19c6e01030783c58578c7b025fe151f59122f802417f00151c97e33edd991d761794864d10670fbf943b2b6e1fc68d82be22c041d105fba8cc17fc26466f496ef7cd2570387f74cc8b53030714e7aee2cf00c2e3d3300731cad1977773cb46641b56ea75aff1c187278fa2e0b84d5482fa1e18bfb9b42eea1c1ab6a77f89871d03879514127e9ab3d08f0fdab60221294265c549ef981239702acd00eb245bda4f31098d8fde34a6c4133d42cfe222af3b0148271ec49dd1373777e51b7680b165f183e63a81e6085bcebda35c2f8f64343ef5cd45fdef42c942fdb206e7a0cb7f158358572a3b17f71d728b2bb3779cb06c6bb736ff803c252d59031833ca452f338b8ac38b8e056501c8f95fa2b326c563e3e1b193396893ffd5a87427ceb1ea3966e18ca57c84ced1251e90f2a2da706496bbf5a6223a9a9aef32701575dc225dc16323d1d53a6dd8292fdacd32fc00da81b1bceccb35ab8cf6debac576c7fedbb7ab49c332cf1bbd8e798a90d2df3070f09019f0bc861c3c7d23c69e2001a23c8831f0fc3016d42f77159e86534ad7a7829939f2d960c6754b4c14fa679573874c35f2b0da407d7a99fa97832c065b28a3958460acd5c2632e55d424ae7c74c05e67ab433b5930e2591a0533a9ae154a1166eb12fc1ff250ab66c2aba7a3c0fbc274c83d3f445f6f18bcd9f5df990663181be10a442d97825f706798857e42673aa513d962b9193af35c9402334bd55a264cd18e3a107bd6b0ca2de334fb878f7c2dde38e64dcc16357d521eedfe568ff943454db5260da8327084e58197d02bec18e7fa15f1e2513fe14208fb9f621b6ec8ce283f3fb7f222bde02988c7cea1344b4103fbe3d41999e2e02f19fbf7e9901ff448f18af0d1e18236f445ed8575fbbfc5af3d9d086f3569cf7e57dd932bba09387be921c16475c5ab973bff5e26690aaf4cecbfa329db7304da846e067ced31c508c4c02d251fcea1a3e7a7f47c58f3c90eb24dddabe1239b6bdf549fec7a5c67ac3be804fa7fb1856971aa985da0bad2a7fcf8c768ff935d210fd69ddc337f4b592bab09953e41661d04811fe224902f4919dbfd6656d544976429aa9f95f06324ee69276e14b8e4578c1888341182ca8e1ce851b0feaad30cb7bb2e43602d6392f40a193d7dc2ab1cc52eaba2a5bfae0c7b4d3fdf37393cf4a243d8b157da577b77e189f1999bca965cf14e55ffc2d905417dcb6a7dacdd60f11feb8d3757246ab85edf982950aba2482a823be039dc5886632d394c006d34a15f75dca0d7ac88836d7730fa052652d4d7572cae25d6b6c520399a168e9daaee189d8fd53b0288ee1ce154625f1936920061f0db0b7d3b10e47bd7bf1b45cebc1799fae6f30676e37aea51da677cd7e1990fdb23a86c1754ec4d6e5d6cab647c621475c0aab5fa6893ba801826d9e04217eee725b1b6f40dde6a0407dd2139786455e0d0f263f5d565ac63da204f969dc287dd638dbb0c5b4dadbc977dadfa95731148e196ac7b1ca0244ff40c2c08720312b589a07ba162cb8b9c8844128383c5d5d237bce015cd669d9f0d9bbdbe64df84efb5e617732fce9d6018045586665f7e82b1219264999f7ab64d76613c2f05e4590cf06c1d6e18e921ca16753a974f90cce97cec7d4b3b8a5336ee02c69c8f87e4feb7875aa44c4626a20858b8c85f47f74fd24bd160adcd64f6beed8c08bc28b9ed218f640ed562022e8caea9bf64ab9ac88dc62d94b1546ae77677fe59de0415139562fcedfc3d18b8e00a1e40b49920c5c5c2a25cf6b89754a539cb42b23849e35c1ec7e2e58f6743661c5b6d8740aad20ba7e467c6581a2f15524b175de5ea6dba1680631b13ad6a505b7f2772465080b5666ff56b577f235d338b33682afe3cc8d89f9cd4b03ec309109a339d79482f77aaefbc360b64dd492f79e026763dd7a33c6ab31adce6d6c7cd911bf636808bd5f105439a2d698282bb95b01bb947e6d562ec65eb2351760769787444f7cf326bd1187acdfee033af2150d7e49e91382b7be58e6d785e24b97f0d82f4c497c52a00fa6dbe75b8fbecbeafb4fdf940261ad792888f2f3bcc40592e12998411129b637a6418fdb9662949082aa582a6ea0f8580ec0d962d61830d7128e69d4a764518881c62d5761f123690bfab1a2442cf8a44d6d7ccd5132d651eff41a9ccf48cc7dd40e542101b7c69d31a7163b7cf78ddb6549b400da83f143f5ddd60b8d7d5776b3f642fbfcf956fe37cd830c57411da297e71bcf97c619dfffbf087d26153d630524e363c697b020550ad0be952882fe4eef64740db5853a36e078c661c5e04404153e52aec4f96bd7a1654401ddda91f6207366ec7f06ecb4b21fdfac585be8df90ef950c4e2cba284596ed59552e6cf2fa278c8596c1ebcea57af377d54b6f2217119f250b1549e509e012b4f51f18023c48f3e81c7971a2176d724570fe9342fef67f5337eccc18a5cea0af4f0d4183764de0371b7ad05e725b0a2d31fb96940c6d09c01af47581c52e0f81f3c12dba199abebe1b30a8a0a291c24c42b4e76fd3f025554689b20d06e9f5c949577894880c2c83dae3a70622f7cc210cf5f6eef2807546e8f4641365c74e4d6207b82e779671af9f34281e28c3811c39abf5f02d0f00287a9a110063617b5a6f01074b44040cdef0f3bbaf1e747dc97b5bae68cbb268bc530424356612ef829512c57ad31c75cfa14cf916b06c2851e60e8ee45bb24865b98e2843959a4cf8b160232650a085f37156931e9e6c24efd3f3607c3b643f074276f46951be7aa9197e84b4e0348141dee36f85e48bcd27fca25f27a60095511393e0d498f2ecc3b8720f475c21f91073d2801400a2d6c18281d19481b5e9c48b652a0625cecff872d30ba607a56fbfa29a589bbfd2b44d53f1e66211d481a0baf3bdef1c28a7793e3296f5a981eb9cdc94a52ee5ad98387369623a6f81019938db4011d73576ae000e65f141a0bb49aee7d2e451ae7b8f5ec2efef05fe5f369762ecc7f337b8fabc8cd667defd09ea8bdaa8417e7ecfcae945eda766eb402a71c0a3cbff932943ec91ed6338b91730a718c30e661f7c3fc7401b3934d9c75db56d3ac3132ad69af0bcd361f2baf34abc2092bfe0a442dc8a95740d75f5dcec54f76abac2b5969f61a4ce398301ecc221c7665b42519c6305628e7261470d0626561dc5b82dd16a25ac4b1bc7d305e7441eb7e7894963e47d0ec40da27b9c50d96d4c589e0293c29c79f0a1edcb6035ef0dcd8e1c8b06223393e8b68115f05655ff1ff8d48854b2326a5edb991e07225c421bdb486e61be4dc59500c24f868aaf854d04033e6ac8f2cf89f0a265d279d6616d139dfe2d7ee14db811b3a1908c08fa0b0c1d73d11bbc6d95d11b31f76a5cd89515ca1fb62d01fe1d35dae3a64c440ea3832362c729c18d62d44be7a5a0456b2d5a7a9297f8c45af6ca972b36594eeb16415c4bafb9efef5c3fb691d24bde534dd26e0ac21a7ea610bd120cd2e5a2b18a4f0e5a167673db6f97f369658498a43aa9b7ddf62768310f09b9b68bebee6c1243ef617654cd805c3a6be576a0a748f8ff1ff1a5f3e996f6d1bccfe69acec225bbca9f49e118553d53cd0104d2581d64b7bd835e56edc852daf9c92b93ba02f2d82e91d90786bd975bbdaf01bf34fa8fbff04ce9dd3df0aeff3589e4c842c9504eed967d648cc98e8b826d80235fd22b65d14af27d5153e8baae88ae5f73bd139747f442ea2b2b4a1301f93c2cd58b65b271a1f351db7e54fbd27576ba6c11fdeabad675e60ee5aa8f154322c0e5d3f120f0cbf7638333194c0708fa1c1f493ab4be10e482931b037080785dd8e857caef011e291e169f82784424b678c3524aa9ef65a4c9c5beca5de51798db3ae05b4ed11188da358e432f0948e88096b7b02d7c2caaf894756f56dd1624ca7644b80c6c6657a963eca524ac2f1ae4a6540bec9610a295376d942360bb46dd85f9d966035cfd1329cad8ca64fb4f0801a0196f9e0dda7ef24188bf22bbe19210ab1c4465e440c1340c4a989b81ecdc2b82f1a61cc91f519b47899436c92b81d84e7496ac2cc7f28ff566df439374bcd4255afa8d82d6257ce76c5c3731bccb823e351e73297e7526a8327ee2bfe83bd5499190aeeeaf4052d637df8b48b2c2bac9e1eb51766ee46c71938c8f2d80dd78de523048700430f3e707b82d0d36f1fa90a6ffbd1b75dd2a006c7cfa1c5f62e63c39a255b3c6aa55b29a90da6c962c56de172fff977413192aea08713cd70e9fb08eb1576a445708c5fee72412ec3e52d35af23a09687259dc18989a3241447cab016d2ec2256052424e38a102e57b8544d36b85a47922677e990cbc050a1ed5c66fdf0b7d7d4bb14c476fe51c6afe042d1efddd2ce67208643332cf948a980e432fdc3c2c1b2bcb5fff4348936664d0e2a77b0b44ca2f3931e75f2b84d248acbe7735ff3bc3af236917382c0657c94f2f1bd6eaf126ca7421d119d64e8f19c5f06e50c9c9ab0f59b44cbf29aaa68ae6b97aad480dc991c3dec588862555c29a07d9657dd852b73325bb42e923f9c5a4141b442d67742eac8f8593812199b7cf16f0b594fb950108a13e27d1b357f457fc1d31f62c7e41baf838523a08e5081f481324358d3e3983df40ad61e819fdc9208be8f9f6161a2d6c889b617826c67e0160fb6b4100822c0cb76099494343eb6864947d17d2c2ad483abe8564cd91d269a330db3e6563e07c82627aeeb5d32a0004f839e3dd6c320d39827e02ba6bd43271c60a5693ee717f6565e489ca1397ca87f7efa568e8e340421e3b689ef21e4b25db2fdbd03eef3c518dd37a40edf893039fe16a85916b102535a565c36ebfea6fc381af421b008801a6629f348d68038afffc45b85766f5d21af3a514cbf6cb732c205396eb7ef639b7949652d9230a7f3b6871447b969c1f276a6076529b442f08021045984452709bc9f352d55d2a0f2c7755ef7ccaf012c11c8b74c36bb9e8a94c0bf0a705c010f1d04a5f54b5eb0a5c2427f715b131e04979b1e6b509e4f17ce73eef200250598f2d0a807f2b8e1419cbef2fb6fca8c6ca83571c18c644ef78c1daed90c76353cb2c93908a273740b7c0ce0b2abf15c30c9bed9e013be9b447770d92b600d80b1d305dc2cf8979e656b2df642b6f4fa4373931fbee60d71e156b9619ac85adc4e659e8c2b82a927bba4786c2bd8a825162a8838836f47b2e18f9a38987a7de51ef3c84fe9b2f8277da7de6be3094c235489b6304cafdb7d63dd0437f8928164e129321990d539f9002d3a766ef337e5c5babee415b89ecb126c5744f7b2acc3ffb86ef275d1d992e906c1028d4c25284a4313abb483e8fc567398207435218d183840fd3fb22af2188909ea3d587c75f0dfa7f8ed4f0ec1cc1f2adce8b7e6945dd79fa9f003507e553506f148f4269f3424c56d59b476610c3545c290c54bfcbb2e34a91f3041ef77556c8280d2bc1be7c476259b65ffbd6a1e3485d57c9f2911e02904f899c06f2d6396ae2ea3aad61f782291a240aef332af3fa4910e87a51fd4a69b6020d89e8b4cfd01ba30cbe815c040cfb922eeb72cbcdd4dbe288dac0655a831e17027eaabd5a5d6fa794cb925e55d0de3248347f092893de60f3be35227b65e05f2a0b67af655a02c8b5d3bfd2709b8495270a94269817f935fc83d5614e2846ad04eeea518e34dd16e75d4486ac2a4c2da7e17e05d474a34251d157e81c76565b2339b4856e30fd47a1fc6da8bf9755891eda3e42f1fadbafb9214842fe1a4f06f343158aec9ee0e952270acc65717901b66c38952a41de023f2d23c108f9779c019812d26cfc9b7fa36982a786db4d3c44f36d7ff1ee0065c29d95d262a81262f91d2b997dbdca7ceaa04836606c169b70b0443ca25d35622cfeb6be44a48cfcd0c7cfe958e40655def130b261f9deba22d4ed2082dbf1ffea23d8f71e9ee13f7a082b20d100f65a7c061cc90e6d13de8a808279c8ec36225637d7e787760487b2719e11c61ed81aa98417970c913128e654bafe10ed8d6a9943eacb1e3072a5c6f90de50442c11b2fa68859a075ea2567992b8bd2b15da2a1d5be23a3d488a777eb7b52af5bd8783d569fee2d90a24c2a0ef157e75ca1eac99da0913cc7653614d1cb98e337b42b1aa7adc1c99b64695516d59deecade394cf104134434f47263bde78dad4ba4d43ff7c91668ba4ae57c27a3ac19a8ac9dfee3cb8e6ee24224ab22649bd3c06918f4eb16bad88146e27d5e5e30de9dfeeab91c1c5f4d02e00902f8f4d2982e8a9ddde653e99c210f184cf899f02481f5dfb4e6d3c75b9de3b9ad6d70e98434cd311ed9be050d60a23a3c04491db89fbd6844909e23cf082cdd7967a8982f275c511f67dda7e94e197125b4892a903d01317e9b45030ad10bec069047af98bda4705b518c793523c33faaaf36f957d2be4f19e8edc7bb35199dfea9c78d5b8a44b9fe9957a3a679483f04297d04abdacd4484af7f50781c61a8788d68f45ec002303a4fba862447689df274781ed24be450aa45781e1871f339566071e718961eb1aae0b7920c4b1530601a3dc585c5a404905ebdbdc48055611dad81ab5313c0b88ca427d87177ad1e57341a700e0907cb6e6014abb7a6d5939e7d49a0348d05f16f91e97c0acb150855b9b652c2dc715b9fea2fdde903fd4886d4ade73f1e508249a46f2a52f6d25f3dfa25531ac1181d1ff615c7708ed3c8b2be0bc35ad1e56affb77df060282008e08cd85be52df4987a6a9e32ce520cc021bdf57ee899889bcf1fdf3196048d7e367bf1d4b73ab1659b102b562e6c9b1c8ce902430cb73a39ccb7b666be63f70122a60ac7048d66ea9d88b0c2ad87ee404eb515feaecedd352f1f60efbbee4f3fa1cc162a04a12dc998cacf1a427e5215bc40f76dce90f20e20c64039edb52b040ee60ecedcf457881dff473d06de52e1f7d9cf4b33dbe5e813f5b2c8d0ba0abeec0851020f057a94342bcb243a452d946fc9e44d47e66a610fdec1583acd183cc3e2e6a0ca11b8216fa04d33220d270525a4f30e3e51a88db0d17eafefe5e05bdfad3b9df7c65dd33052cefa123580e058045a7555d9c361b2141247e37b87a6d756bbe02fe6c1c101594ac4ab731109e1da49670dd2f32c9b053fbab540b960e06660e329b155ba2b1930c88a03ebd1ff8b45063a2969c3bdf45b12591eed2646d5c8d5fc0bde83b8be3df85ea7a2ea83eb9bc2862afc988f50371b11cd664a90e5cf2b8394dffbd16cddef094fdc0d7b8fe74f2d375583bfaa7a118aa4e6577ccf51fb0635d74b950ecc264c452e93c060b3549ed5f41146869c1e12fe7e68db66c7c7ea9fc3b6021ed7ababe6a24c7c69c14edafe91a28089cd5371bbebad75ee44ac0cc733a42ed5554a91f625dca85cf2ef7aa2eaa2d952f97b536e826b64f5387d5eac92e9f966fc47ec9599612c658c68fb07e3704c2685eb2da0c1eeeba69aaa078596c34056851b0d502c9c3218393a5c5e69a3c3a9e39930eee3f4f3495e41c4abfd272da58d15f0036d7216524a6f32dc05af2a1c922f3c586daae07b2ce467e0dc2a122acac22ce679c73bf3f88f185379df0192a0136bb59580f3058bdcc1e7e5efcd769c5e7deee81b1e5a7ff32f4d64195ea3a3b1d519c146554a91a44443e80f6d217872a1f93a6421462eb2cd0ad59679d382ce3e93db75eea098d465ae5c89f84b9dba84c902c0346486cbf69652db9a03c29267c85fcd63cc3084414cf6ef7351648837b1c63e0e7133adf9bd916fb0e6d139dba3a16e59fcfab7b2b468f1f3e284ba54e71da5d5ffaf6a5811439f5e83505e2a5e963cc3dad61cfd4b023d7b6b66a5568fec65566bc62ec3060ae6d98c2bbc9c354726c28bc624c1fbabab23d2fe1efc44ff652a3a8eb157b22815814bfcdec412a459639cf145686cfeec7b6e9cd7c5f63172d5c18223338638b2e78ad7722686424c7c27f37d3084ad806abafa19e66a1ca6eafad3b41648d58224d72c9207ec9338ef83d0714160eee327885d70185592077c06f6b59cc824d1cf489bd4ebbcbc62d0b9edb065401a21d5a4bd9fc45250d1bac4a2ff986f9dba1e7b0e03ffe7a1489163ec760aa8d58d9fa5ebb4d466b038d8d5de19e8ca1de3376efcf90e14626a456389246d3e1cd18e89697d57356848e7964793176d3fe551a88a3e583399fd2c71b86bfd192d6c6fe6747fa1726bd2b50447ee21cada4341423683a00f3918e7e7f9c61011449ec49a1c06691b58235627e4025849c6b25dd5991be35f412dd9ce26fe7fde79b08cbc26a6bc959d03bacf50659f7237af7f33b200ee3e3a8068fe8cac99c880aa22bef419ffa729b428ae9dec77d3aff194bb71c8c22a0851fdad32760b448f8dd54d68506b02285d6b7bc1d33bcf2360ce08cbaa091c4991d7456976bc1e5ffd94e16df8e468c8268b36880dc1d61d70da9ef6664b4418dd2341ff3c51b04f7c8e808bebe6c66d0ade0fa748e87b7dd8b35c63d25329a7e324f9c805806d03a7189d444a62d0e6bb9dfd7f47cc75694ead84c0fa29398b8ac59fb0b4217d2c2c6eb1dd462645c072bd8d3ff723606724e7d1686b981139367042c9aa133d77085e3211d517a53f45e61cf357fa242e35216aaf386370596b9ffeb25f8b16291faedc3c20f8d1ea9971ccc20d9a10fa8dd1720de50a443c014576ddf41fdbd7643368c09717a8f36ffad1231b528da10bd21f88416ac18dd28c3a1e63690f96e955593b41059cea85df7e49e6f27281877c38eefb1940d2ac17e2b86e886afd5058f6ec2723a7fe226212e921e2b6f8835d9521945d5371c9afe7f7403a0e90f0998f6b27595cf5d687a5ffd3c94c4f137ed9f5f37f61c996aa889270ae50d4e766fdfaa19bf1de60a0a448dcae5f122a767bcd141c2c23940b5957d6dd2de8d8a050d2222a4e97c4e2b53d01c0c9becaf0067adca98d7792970cfdb70d9a16fb3745d0fe847410ad60d580bb55bd986ef51f2d7acbcc047aba9b805a68fe514785a7483298accd5b001ca01b4ae7e863232a312555f47324cfa4f83d924ef77ce7b8f5a49b507766e79c0fa6afe2596a223034c523a9fd955496725f18c5fb4da879850dbae5cff909fed93f3296291e77615402688fd6bc3cb25c203b528e33c259c7aa63783e63c1e40405c91545ef55d659c02a09e4eaf3e439a61a192c0265c52bf21b380cba921e762e3fd2dbafe84137db5346c323163234970a88787935eaeb15efedd1e1a93e5b6cef6459079e6289d8c4f4b588a36cbe0490b064c4259ad0a07a45b3a6f62676307dde1b450182c16eb14ea482a3c0c267c932bf8b93a51dabe0495b43132dc07baf863098839d7cc5f80b3dbc03b30bb53e89f28f84cae25cbe21211deeddc6e7ce42849a10f4760e3117ded7d7f408cdca0d797a99ac00142271dcd6b56bccd7d623b2f1fa7c38f108845c2c233134842320fa33739c2da631f262b1213813b7a0ab30352dfa7b64e874f4e1731b1e677ef48af84f232cbc774832833739752ab48536c86b35466af5aef3030c4414948c8012c1d84090dbdb5cf44f643d6360b4cea196e49abe0fb5f6af7ead1aa0e324ee11fda858ea0b81e511f63a3858c248f28be0c8bb088ed93c82cf5bb6723006fac364be2c18b100e8952378909b8ceba89e54444745c4ad600657a94a310197a02cb2a8d025b18d7b77f83342643da45422931358bf29f62308ccfbd5525e7fe5b5d72a14315b5240d3755839fb6b4301eb9ddc17549792dacdd299a623f686f8796cac1ee6885efd5d39f104043aef36e6891adaccd90481e9a6b6e87e7940c2d3a1e6ced6fb9ec01a0e0abb158072d3c6d7afb65d1a3a59e40b1ca5aa18405b8bf0d5563414cb06b2c2fc4aef53c85d0f42d125e4a56861dcef655ba3533c128996c0ec6417da64d51ee8bfe5d6e2710d2856ec6aadc20ae2ef209710bbeec1aa3b7bcd5ef3d7f211bcb51ac86da9ae6597896070868e9db766a1b7e43c6eadf799d9299a955f9f666ce9534f571870f8af7f0128dc2055402cafe3e27891acfd9c9beb8e36e26caed3c4d44842a78b0d25cdeed2adc17786676456f8a452678992fef7852dd3edce2e1bf5524e64a7a7ba44fa177d313fd7fcb0c670910620aa0ff2cc1ea8b54f82a6bad80aab32b24a48e58020193935e1f9563d6a1133b65147a283a2a87f5e526f4798f63e66947aca4c1e04224b2ad6a2175f5fd40d846b94ba54b0de2e6f5be74083f7939720df468530c8958d952c4fdf762945dbdb831222c33a8bc82bd9affbaf747626850e2c62050028d7e35c8133f79a5a399538a89f0602d7bf02411952a246a1d4c830f8c3174b3f01a50ed3ed0b6bcd33fbe55e7f96553ab6ac73153ca3756012e0b6e572751062c4075e29849456ad90599c1f05d2a840df9a4820f4c1d9a35eabbe62fbaac3c0b11d9e8670b6f79b706ec3e9da5c11f044c53d8f0179bca060619d177d25ebf51d1ef84663a11f34ecb676e3188acd6fcb145ab2e052255ad034e00ff12aec4dbaea643f43e625f378cacaca300c8f94534e3f15ffc2879e157a903bba19057bc990a40e948d1658dbddd43f6749c09f6b59bdb7b27423476c77ee4c875f4c5bb241541a1fdad99027c179f34fe33a01059380e1c05ead9375ae948f1d4e34fa80cd57c2ecf96af7b04c389f760996716eafe8fe7ff00afffbb5e5adaf10e897f7bf3ef63763dc0e65bc9443330c5e9e3eaaf9109ce2dc9fc0c43365a6cf78b6551292e92da1286d50669dac9f0a8b27b67c496bc9568b4ea25a862ce2322954b9a48fced663b5e976a76950f77dc7398a6164f8e1e0c52b99655aeb6935c12179dec8fda323c74a755b43b09c40a00c15860add1fe330c765566a8d78afef51f7bda44db5bdb532b5d62142b5260161558d38ed913f35db43071aca6306cabe17f893625a1bb8c4472bd9efa8463a1ec9ca2e65c1ad785c810f352de5d1725b8c21ca9972a5e3704ba21bd655a9fec5a11fb65964607b3e43225454e7e3de58f3bce3527dfa4614ef96b4c9d801129339bc0dfba61974f0c92dfd27890d59b7d187b89e55d5eea2516beb11893ee180b7db3256e44c6b5ef7b5e0e461a4139b9abe0fe50030720fdd87980f5a51e70c4ddad0b54dcf6c4c0533f062bc2ce2941525581dc8274e3fbd7badc4a1311de984fdc82ff28710c0f746ac3a30c9e93e6c66c719e234076bdd3631b441c102f0d0469d86af5510be489d89dd4e124f407480bda5bcf304ce3eaf93ab9b8a62b35afa21012d9c8211a6b8e464a6a2bdd5f2634583f3f4da2eb3dc40f16d0d4ef76c106960503f50bab0e13ab1bb03bba2a27f139a84b29c52fc4493ad340637199fa36c3940f9663fa60e1dead7d5ccadeb838f459a54a446cccd314bd33def0c4bc3bffbe938d5de3dd674b2e056c4a83359bd03f1c40538612f96734e0629fb49cad214ca858a8b608872dc187228f029ac4194b8d4d3c905a633786e7d856b9fc6b8b30b1e6834d57e9d085e35ff54f5019215128c4010af30f821192a64d7f681d8575a659f5e7eb660e1e955d73434a08f9fa7d3f26c28935081ae0df65de1f2dd4a2e8ba053f21a8c773e124525a4ecf4f24effb19da88d1d1aadd1ff39d3723be592328aa1151a4f3a5f426bd99b96d8922229cfb2c2f3a7ea84221acca2436044f9744fd0fc9aa46323cad0a0ae33e31adbccc6f5fe4c65c8f60e15b196c07c6c8b60ef0839d97a098cc2cd4190858de295ee7da969bdc0c22d227e48ceda29db10a9e6ca70a9f780d65e3682701d6b748feca0549e50e4a5d0fed64627e4cac0745f3b911e99b1c8629b9761b82a6ee1e3d31047a5451ed0fa3989eac70440dc518d05bea361404d649b693799fca73d8a0ed738989fa765ebe43639e3700372da194c6f2c4d861df49a73d816443ae7cacb7a5a6aefccf342899c7641efc9172fa6dbe1cff3ab4a703a40221fb4fbe9e44cea2159431a79b728e12a5e036845442b10e03f8960e8a2429608f4df6ea17b9bde573fc8862cea714c85c84ae9918e2efbda565d3b603619c65b50b80ecaa2494671d79341","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
