<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a29ca9f3bf8838dc009e18030a971e6be7f4c08b280ff31b0e54f4e756db68207e1bdf79e605e2272f636acb653ae8eb57db1e4c442960981f052991b251cd9a042cbdf02008ed93da7ed071da4aa590de4893db984f6e170e6ca694de559824624d9481f3b10a913cce984253836d13ab7931c35f94278bf3a547ee97efd361ff52e6b50c93adc7e9525777c295f07711efb43f7e1997f9f9c12bd2201e9bce63ad327f1a5643c58af99c63ae6a3b838be60d5128900880ca9a2ef123e74c6a2c9b896a04e4a351f0a27720b032d310e830ca3a63b08b8ee5a4a77cc1b3d6019903f31c6fa6ff28751b417dd5393e5ae8f49a74b990fefbf6190f30900653577b97a58174fd115c6194f5d0999437bd894f85e9613cccb93ecb9209c9ae3797304415eae9deaa4543f9201e6142c6eda63ee8c41b2e8d15bc873d0ca3a99c48282e397a0c95bf459321521ffb8f7d8e1b1fb83db02f7b6ed106c98ce0b2f80728a9f73de397d7cf0cc4207e43009d846b5a200af5206721634f6d5aaec5c2b99ccf019532564744f222a3b29d5895ceecb66a53387a577c9f92471024bc262bfc4c94c89acdbcdfaa9d5b7226d8b66d3abfa4f56fdcadd9c16483805453e7b0c715715886105c94783d9b68a1813b8f194678710eacf51a71af95f3e3a5610395e80084d7ee1ee7bde7214a739b811f329f504aa263a402958dd669981a9ce4f6b6a033f525989b9396d500ccb853183f43e51e846438780bd8693fc5198a67d72540756208fe7f50e47f49236f09f8f0ba8b4be20b84341bb8ec54b5b876368a0ab4b9101336ae2b624c4d44134df8031a1e82aca77546285296341f9eb527699a3064666f4b55a3362856ff5ae30c4ec5139c01f2ba626509e1fde252925fc49e8003a86fa5208898d7ec0a3b2d01f26f2cd23b06ecae127aa9f465413d1c89cf2c2ce0d61bd928e1499a32d710069579d78d6902d5e04c83d215807744e6c4c091049b407e59e8705e80545eb4f1784d8ff9722f7d0ab415c14b897b795a85eeaad73de45be4fca7cd98ae9bdaaac383186b169ac707fad66ab4944db0cfa4ff5da59d5eac05f35087859aec573323a1b99b33c678623109b1221cb724a3bbdefc381f00d774dcc58b8a5a6eee85e7fadb634863eb4aa04c949cc7448faa33e5fdfdd66ab315ef147d1b3ec9612ae7cb47a254cce873c41fa858bd35089c621914571692498aaaa1ae7b7c1c495a6f99bfd7399f174c6ca43437334680925d5de2acadc1d1c0e90037c2bddc473fa5dc25b049d23bf3d3a19248062cfa0b84eefe88ea6bd0f0517e76b6d528da35b5be8b5b42668c0d6f4cfe8efebce0e357de0ca3816a3a07e3125b864bf7eb2b99b14077cf8da5345fa3f9e572eaff0a7b4802820458c4dc48bffebcb0253c0b2ebab316d1cc1fc10d96144d4d683325781d4583784677e6e3d22ba81b38b3567ece8ca196e3bfabcbe1b2384eb56556fe572fa19d8e1fd0fb4a8d776a1346c32c827fb83c8bb075c3f296abb7c394daf1dfc6d8d7e9571b2b9344cef0b56511062b00a547364c296097212d3e4a83ca05c6e1fa2ef6a480df0757bf38cb40302aa2662ef8e150e24841a2293b37c2854c83c8df2ed0aba18e3195f3bf8f220995287deadfaf1d6b33e834edc024950c295fbd0c1beaecfb64aac1a07081e48bf69ca5c5a214e999b07d122fd638af4a2f51cc7e0906a79130e674ac5b1b7660f56e3db9b95d63be4ba709702e092c5711251234dc89ac61a60fb59012af8323a60bb9e6c2ebf6043295a76d10e7ced740431823a84ee747b96e81ea51d82296fe27bd441509de98b97891576a397aa6569e208e743df16224c098711b47ac2dd9a7c46d7ac544a8381fd4415be1870c82dfb4c98d4615be27351cc5ad0fd53b99d940a922022aa1384b9a755667e34b2ba1a20f5ed8902c1964b9f7fa2113202a2e494779bbc075645656c4b33e715ce59744beddf352991cb0063c9b07d3c7595aae37bdec60bd5f64a7d381c8dffca9aa0d1af254c81ae49c905b9d2dbdad7a3dfa0080012ec95cae3decdaee819fefd4982f855c17e0903dc99d0eb433af8bb493de62e1c368cbc66784ce106a7f5213a422ef5bd24c01a30665658785ba7280df16b51c1b2ca2deb6547f87496aeea2ec3e24a1f7fb1e7900822bf736bf0b3a2183988dfe082537cbd3f2ae88d2abee68358cb933ae8ada83f667f46b9cfec6fd767d2a594d817994ad7affa1df3612dc564626a9952aa1c0a529dc3a062818fc3508403e6508f49769bf624c6f666ed531ff55d493bd08534da909f8d403af1cbc7baaf3a156b7dc0b1f8b84aa73ca22a4f77b4ce733d6bfa43958303de144cd1e9587126e14464856b795ecdb5366d4b83fef177ee8cfaf0066ce3918e46f4d56cf61bbb4232802abfe0e5dd2426b4dc43e0dbadf148e341441e9265e774faad638a40bf5d724355227dfce68a078aa2b08c4bee35a77153bdb81786e61751ac24f075bc8ae16f37f7c67f1e5ac60ed26058d8b2ce3c812025923be881f011af959ca2cd6e3560af4887fea6f103b422d8124580a7353cd7d4d977b5a06e8947c9d737ede02151e994c24c9736c452a6ee0d09a6c6fcf2ef2be16ffc315813bd240344c49366998372322524671d68386f749df0b8c25b04ec02379998d6fcd4b7c9f10af67625d291a66aa0fdf5334b8f41e327e7be71d8492f62dbdb44edc19c86381e780d1793767cd3c528eaecb265857cc6345a27497c9aee08d54189733d1dedf4678860081cff19cf0f5289069d610dd542f3045703bad1541a7e0acb367e3c63a75cb8d98012b646a2ae7cd93e8bee06a20b7de4f2b9fb09a324dc207bf52a50080e9786f7e65177535ccf327c1a8625689ec9f89e63e7cebcc057f1ed8db38af56e160fb5605783000728e50217571e8aa3ede44b63a3b3950c4668c5a1107c26bbfd59d4dfaa6f952cba566286f3d51d2a52c7e1c25b0d4257428556161c9a465e5418709525a0393ecfcf89f8ff4b0b769b2ce3701d6bd66276f7839d9afc9deb2bc6b8961cef421d5f03f64e577556de0f5ffc1b7979c77898344638a90a11e7901502d88b2ad86787a190ed69faea68309a4d251150a21072200c008e6c50e5bff659c1a5c59062d4c0fd2bdad32dff638501cc9ffc206d1ac097bb74c38a5b4d793b19dfe9cee12c60ec6a9097998851423408ec54d3069fc166e35e6e12240f4ebd58484616b9f0b8d50e97cd52618f49f5c3b27c1dc712a560b5914ec299cc8b0c86d16330e5ee295e06258a7487feb81a3f8538fcb93778bc60bbd0a800a1dc9621712ebfdce3234f9616c2bf33511b2e466cf95bc0e0aa280cc237787cf0c5a416e89e25207ccc9d1a397077ff74f1194add75aeb43a6ce89d4ce1d1de90d105caff7667fcc34260d1a2c1135a1a4c1ee49a8ff5a529951062662bf7d93d38152fa0573b3281027e8716723e7d61dbfa1bb1f0966ecc9b51d3fcb09bf19d8ea8e52a8e2e103d33e9583684298cd84cb9e2d77c77ec962ae4f2fe535fe4b30cac4d632ce95964a204aef728fca5c9eb7df467c68e2741a149321ab335baa5d14038cf1828475dd2870201b59c8cf7e160fbf1a423d6a108689eea723586b5f9d7a443e1a6d9881b1ba3763a592f07e78bfca176893db297cc35bb513576af7a7363b357fec7c654f1d175f4d2565884c4d9586f23b2141de092d21fd01a78cbbdeee96ab49ce77adf25c83d18622d2a4ea214f02502358b8982b6a308afa5cd6f924a8b03b2e7106189d8e14e846677717b56618ff9de53db446ad7a5f1680f984bef041728e6a0dcb83da30b742ee7936335e36da3ff116e654a6e43b7fde5aabd951d61a6b06743e4294b69ff603ce420059210745e9cf5bb249dddc617cc370bb85096826948719e8c0dda1b89d5ff0a91b0b2582215c9553f2a8589a993499ca853ef8b733c4370531a0dd1dcad126c48c4baf0e7c8387b30ce2329da54dfae3ccd0e7de24027971ace790315cd251bf7b7a34a95d5a47b9aad103c1877b3df8018178fb1eafd4ac8f0ac5155167ed9f35a0939f3763f20e0f12be7d7719b4d034b063d7d159adb31e233946a8d7ef4fb2b4340df983c75cf8deab32f5dfaefea66914340374b6c1cf0c72090e9ae20c9fe2c46ab9baecd52f9a91e8c0331e80ec517208ff0f9112971efe36943da00f9dd18f688cab4f08154d1f49b31d910c0bd24515eb6e23a5aa8fd77a922a34dba81d3d307a5518cb95244efb4cc1f8484e09976899f63fbff77637e6e5820f549ddecda4334352f2cf7f43878b4c1f7c2debebe130cfbb45eedba38ba8da9e5b274bf45d84982033087cdd709efc165c08e2dc14f6f2f48df5f1a2d670733770a7d3104dbf249ffb5b3fb54d18cf68e0696b469eb8a9e001d798c7f9c7507716c61b20c15cca10b76b7ab6a8c667abdeb1d513e8b70a7834ac93cd748da74a9acc30ba6e28238213b86162e5692d390e13d3e573977e1a71bd21d4d33d9614953af64e77a24043c9dcdfb6a9d718a475d6ebd711948d68f24309d3e2af92253ae5ac444f89af960c9b2c3e80377dc60cba7f549a8f0bb43ad9dfb5961165b55b1d34f00bab18629e82b23209eecde096b85a7b76aadc95904a54677b03df0b46bb8efe4ddf04917811ed27bffa27a868ad6153e6ca914a3812baa12886b5daf0470781d571323a53312527d3c8608fd56f2be61b0b5230f060a3eba684a209c2b6b261e7f8b7d4866db9618a7175ba09f22afd671c777db1b15ad597e2bde8e2957e1708455596bd66c1d62400c5a06f22c4deec050eb69904217b7d9fb8a4de16d1ffb9fe46b805bb5d3b2c35441cb461d1d33df286f304fbb78717eed14070498867711620a6aefab91159ff5988541064f0a6cf767db3e8f46ce4de3c1b5f30b827ed8e429b53390a70dea65886aab3c291746d9ff8c93f4dd414815decefd4a84cfd5766dfd0d7090a0e858db72c3608cf7fa77517da14d3f9666e6c12e9f95b8321779d06f110be532f46cd3f6c60b42d7967887a2f188b0e8c8abbe1174c117d8f7769b7ce1ead5423fd0d7322ee782a770ebdf8e2a7d3db0d9f95846864aa9c1154402bfbbae7bc1a463434f97b10a0be76a61490e526c6999859866716c796e5ea38b9d78a54f7aed2b7a5d56b6a8bb5934f0a45b0b82b5edd166f88cbc6a179167d7170a3cd5905799b4556f092cdff20173f059eece03afd83b0b21fb49cf126f0f869b0ce31e0d295582d6b98a45d808f725e0a1d401b2be4edf4efbc4ca58a3cb4997a42223dfe28ccc96ab46be03150d25cf303ba1914b9e5ddb8fde23bfc723fd14ec0fc1d17ee8cb9f7a108a9e532e63926de4ebfe3cdffc5fe312eb4c94f6eff0ffe7a93e3a1892145e8f7c31ddf3e059cbe95b4c9854177acd6b2af895b7192fd24a884230ab31c5f664f3482c85525fbdb4dc9d652193ab095a165116f7c6efbd66ca308727e5b9baa1eb2320ad25fc3336eac78d3eb500f47a1593e4bdc0ac170b85b35bcac834b7cc94143697e1c7ede3ca9061883c53489e364e8d2976af4dfbb939bbcfa6e9dce7cf86a41f780297eb4e3aa8ca46a4bee3b400ee9799401b6585760c0c081e7ae4ecd638cf4f8b818da68d5ffcf6abf00704073005e1c94771a62b8ca78b368f61d9d3c4b3b3cf3d27afd6f17058060660a682e6ea18f822f666760a65896d5206df4417a62e5ea6771429beb8a71bbaae4b6769b7c4ee29f88819d679019974dbc2805f38736cb5726e14929adeda19d1ebe0245742d6f3aec51fff68d33ac171554b7dfe89ea27d26e3a89a91437cd68c7eb73366678c270e82c6f803f43eb8036d7066a37c743b5c4846e530068b3862a8cb2542eddec00721ffda9918ffe59f8a3f397bfa2c727180dfd4535694e58546c36bc6f9baeb21ae65b6c26d1f3b9bd633cde150e1640f98e22746834d72f606b29a1c08b7303031668a2b174b29401498016aedf30e0eb99f473ec61fd79dbfc0ff9d048630e7848e2f6e4b4b44e3855a936f0c40826d25adea3a999b0484fa8dfb0d001c3916f408d9400c5597500e5d70b93f87fda846e839aaeacb5b40ab96d4ba2a19658ed6bd31e0bcb35991b046098a3f5e00ee7682fd6d574a08bc29f1f5a54e03a6f3adbf23d36c10f70f7e3d2f2872ea01779855d7f73a15344196eca32503a5823aa8776155332fbea137c05384bb75e0f49f5a1b62fe76cc67c0899d52208fcd3c213fbd1d4eb71e5aeb577610ea51be4bd5c926a5d2b1109a54a0bbca6c468a70690e8d9df546008aa69116ab6cb8ca9f54442a957ef225013ef419e06c61d9248918c3f527c0fe8ca87905fcd78dc65197888c443e93dd3bd8dffa816788b9eeb96a412f1f99f40ae3b0e9a4d15922a56facbb927e81e833072033a0b1ad6e59349787ce4f6098af8d269411a25d38b1d62ef87c29c4e9840c29479b5f3c6bba9e615acdc0e8e4bb41575be9ea376522261352f534b8e86db01f82206c4e8e4619bab4faced1d17b9a94a3872df03ac676b58c60501015e44807e21add999b9f711320f53d03d2c08b5e5aa7afa8619d8196f2b0854759d41e634c850e6ddacb52170c1cc2a4867eaa1dc50d37446b2767a52c0da1562e4ceec6e690c11040dd0e9cb28fec8ba3e9f18715ea3eed278817d9fb6f8ba4d39fa2b54b116187f5120d94e2de26b59847aac4a3aae870e8591aba45eef1b6364bd5c8a1644e993bfb261b90be69aff08106f659d1935389522965b49e181d6ce5722ba1caec44027ea823ecdb1f5e38a42d5e372514b34363e7b24e612d17ab0738b82c54d957d6c8ff9c0e7cc164f4c23102d88df597a6c4351a9bf330fc6dce42807a2baa45756427c85d7b6d5087baa662d564f5a4f5c44813b876c7c76e1ff9fcc3427aef4017f7b16c01bbf25d97b96a00c6367de17a8d851104dd236dc9bf0fa59e5b87968213966fbafcf17f6094e19b8ba6bd8ca67b458679f0bce53b3b6f670c2ca4e7949ce4e6f8ce8112550f26a31675d7a3a3b8d07b01be2d7fb0b016a52b4220e55e587d80316ea81546f89942e2dd1767459ef4aef978ad9d6e4a411ac7071e434c0e818a590c66f8c255405eda6d6d8a0f1e4958b9fc32cb0d0afd1556f7c9b35eafcadc48d26ab82c0502f5691083ad8143eb545352d33415f2fa8f7e28f92bd6d528eb29fd3a4e67849f44f2cf3584e7c73e5e8df579a1443f17d67792c42974b7aa402b9f074bdff1cbe67c35229fbccd21d041b7ad14ffc6f21551085fdc0714bfe14425692d7e15c1c5b84bea20ed883186776dc9e3042ee0be6e766d62db100517ec7846b8c66cb8dc545a94520f885e935bf017936b88ef6e31ccac4f9a38be3fab77b29a3c4af47f5bd448425faba33edfe2290d26b265f6b72cd8f329e9fb77b610d4fae977f219f1aaa0b0975589fade00a14fc425439af123681834bce1317540cd054ae9067d1fa9547a6eae534f11a58c235af8d5809e5ca30ae85db49abd95aa09438527036bb6b9830db9c1d0be0fed8a9a62d8cde6bc1175db307e8ca35c91bf6864c4bdd62504f4044f56c91b148f90ac510de1a4a1654cb78071c761405eba100b6956acc22beba42e7f519a3ef4dd0978f7596099cc8f3f008b13b6d6cb2f5980736f23b2a722ff2a4bb853d5933ed902cfc4fe5a6b9a7079e846696f36a8b30912e80560fff48723783e52fa9d7311ca542abadc4941b016be69b092b33c7e3d2064ed723e3d037ee1a1c02eb2e368647974ec57ed0c729f328f0f1b7c07e22515b9dea880b924ae8d78d196023aeafc946726110b42eb183f6f55d19c89a5b2626cb6e46dbfd2b710e53b5dd5f8a4f18e6a5e77a1d49bca0051a51ba72bf4b68d1ec123f9b9ba126878b77f6ec4fd09313edc6ade577b360aee68f22998d87e6c78846a66210f88af7d1b64cbe78c36954b1c39de84cab3a86d5dd04627cb68aede0e24773c0f47cf0fea876d83525d5924b5c80981aa8ed40779e24723191b979eb7b577cc0d1b4edff2ba264f8ea0a67745ea6f746f3b8bf0d988737bf86a3f7b864908888f83278f7d79ec87c600410d5a5bc21cf0a7f2518383ce6fa37f7fcc1f1f9c5a8fe87b8a0a5336ccbd392d4aee6b9d42a982499c64ccd6422a361ca45a0bac342dc42dfe5c936a7c58389e5dd80d6a7d4daa0d0c4ea5721761518485383580d7939471d1ec18be3f1057b10a62f932ec14b498e3ed0a7a9b3ef2e099260836ff393cee0ea10da4524b19eefc08aaac4871d1308ee31f96ef1427266ced87b679756b160bb805e094c14aae2fb857c9a39e9363443a10f7c949434c817c70ec62eabc160c089207e66f8589cf4268acfdf5847e6d65650724b17efaf6687bf5f5c1fb080c538a5dd54af2eca21e83e33ee1b2b1a5ef4e85e6e225fc4cf18ce8452611e2e4b96dfb5b08a65f6fbfd5e4dbf388bf0f480996a0685d35ce7f6244f4dc60b146d37731cb7277a22fe8ac1dbfca0b2dcfbf251e93ab6b6cbf6aa42e133486356e4cff094ee8d415e340683e3e4f42ac3f3d967c0d7a6dbe3ec776b85be1fd428cf96ba2e7f0b98c8f2f28f5e0fe7a37e0f7ca46c9fb1fc055f9d930c212b4ad8e92e606b7d348abb61dbb242c6c6d024e5304a859a73b8b0bd666b2f425a544c7a7b00d7b8c5e5f3ca121d77b62ddd2d5a6143bd74125c86f7e679ef78645cb3abe02a2b142b2de4dbf3da96a449d8842f70667f5b79f09c389d1d86bce818f6a730a3695a12c86d623c0f05474ae5d3c14a05da890b312655571d87387df876d51f3930ba29b644aada09403c548a6d73bda8bf11766776b05f4507395fa34b47f3b470cf998760e909c678ba131ed68ce29f2b5147e126cf1671202e94755e47ac9c91890a829cff95d766dc254ced18c87b0eb946abc44260af374c0e35f8f549b4ad3a1ed812aa0f4912ea149865e9d21774ca77ad533880c523e21f3796e93792c120c7a35511305f3e34700666afc8c41d92bf3e67ea5eaad537f26b1c15ac14feca2568b6c0a38d823d99c041fe8034815a774ebb2e249fe1beefb83eb50127e87cac85fbe7353d5d5bb682ebb9f5e45c8f4697f5fda2e00af2984396405ecab19e227fe64c4a7b6e939170c1cc1a51c2ad5f6512f713ae884dab14b39a8eb1e96fd50da15d5f82ea684269e288348a4db96ad3c3ac92115bd5196584df922482e7d8eb86b06f9a99e66b9ce7e80dc5ddc2962649c5ca3be19d634b950c330a3e9cb5c2077e2e0b6c16ad4ee026cda10bf572d9ca8d4a49a4727ff2a1f5a739250bc9c22ae1dcd9d581547f0a682392ffc2865108975e3f68d70e05c9842bdcdc2fbd577f4c0e23dd329fe3867ff5bd8f402880f9043f585531708950a8527487b1020d7d8444ce18fdf5144bd2f0cf7312a2b7c59bf423a680fde932dee001b4d1b70afeacf375c5542d3bcd46dbadcd0ff62aca40def1abbabdf78864f528befc6edc52a9858a92f563adcc578b3676db9ff8c2f1d21f44cf23280d4b49fbc22138ccdab296d94d998a29f1c9fc65dfff6a0e349f495258a22e11a4677b9ea7559592a4212347ee80406cca456cdd5132df607e35caf3e9f7288ec6ab0ffdc2ba6c941624eb7cb41cddbd9a05f283ca743df362abbcc828feab22b672441bdca401c3824310f74029870c78c652b75a308d703b56bf672243ca34407ab4754eb3dcb5ae723e46be99bacff5a94da358adad23b462a146ab9e8ae925700f189f16bbbe6fe5cc4c927acae85867d12fdf765c3e4144e1c119ae24baad261e74956ac3492848017c6e20aaab7d7598d8b68d353c76ee59dde260f3b045593e324d6ad8ac8807929efa59a3ce5f4129294789221c52796325c43f663b8f4e6e16fe2a65574e911385f29f924c191e680f91a7209f2628482367d8411e29f2cc0a6cc6b028c1b56fd4b980a1134601c5834277174f983272280bc60a225a495588a688cf07c6bc4760362e89730b8ec6a635e6cc653719f6a83337d4f9c193d5ee550ec4cc0229cbaf82ee7a1f924fbf54755ced637b3bd6cb6f73f487af8e13cfcba08600d5c9f9d87a1a8ec669e8518a31d48331934eab776826f75fd94c1742ef030678181391eeeb8c75a19930c6510fcf2cdec91f7ea707c6dadab0b1a507590d8db183633c7a9c18f481a2a108288f3bd7a4b1cb94f81b9ea73791b0f6db9bcf6a42bf8860a777098295751cc44c67fd00267b064d6112df2a4d5b4604adba2afe11feee12eeb81e20fa58b42b935b7a6b8a8853828d9ab51553e662f798c3032fac2e05c34b2e163ef7fd8d23a05e8b707c2ae549ad91291539388a3f350bfa165082f11c97e931272496b47791f5fa7d64d1fbd89ecb9e711affaa8ec439def1afd2606b1872a726a3dc51361021ba42624c3d12fc59743bfc7b52aef1e28ac710d2a146b4fe3371dbbf55cda04c9ce633b1eeee543f27147e0e6183cb1d4e80a97601929a3a7911b71f465630c4978b9ba2e528ecb152adb71931a4aee400e1e30f03202457d982abf5d15b7740fd0bdffd966c41ba0e2721ec998967ed394e3f6fd203b5274954178928068f68ec950086b5e1547976c25d629b7ca52cfe3c57c5232fcb636cc671ce08508be47689aa88d0d9f2ff303f15fc44faf4a61c683367fe62f973eb39be7b62fa5265ee1264100651850dfa9e5618b982e1ae40ab9f1ffe9ec7b9a543853cf7ce4d902046cf435f6939f7b9bd8bb08ff366f5a4cb3446c8a26126e3631d0a2e19a9799a82ba44df3fd7ea7c1556a9854f9e5323d13ae99efb8997ff296fcb5be224bc8125ea838bb2609c42c69b7115e6b5df556a252ce545ccfa9b273e4750faa8720e9ee55a059c3227966f9a8fd976e7f164757db90090fe35bb5d981791c205239c255f7e5c5e2b5112c668523a92d27115ab8945c10f958b0105d7f3cc943e834874d4ffe1b628bdf9da9cf501ccc645bc1c137557604c2c66c53d99008991445e440fbdc667f21b3e9b909f340e1f64cdc9837b31e3e864e30a1b49fbdd5c06116251c031130dbb5137fbfe2923e59f8d39edae120addb3637637aac826446a564557573198d4c71a1c5419d9ba3a2248288155fa75369eb763b6b3c91f0e75735cfd95badc51939b43a8485a075db6e3f581839926c109b7cbdcc5d88f399730d10bc0b027e81dd7d91467ca6436f424a85c89cfec993a3d11fd677e362ceed6735d77cd25a0353a86708b706ac0eb328f822996afa344eb4cc651614cdf7ca9f4bf80c609f5eb471abedcc6ceca87e710b7d1d41459b2c44c01deeaa9f52a46bcec25802cd2b9988896b4b1463eb1cf22a18205c0aa0eb7ed629e401fd125c34e40e441b72df703557b3c28a21071276cd6e2bed7a9dc4e84ce029c0181976b8c14be0ef45e5a16299dff892d5ecd6476781d19b21ef4783e52075371c011319a6fd9d320faef869d8939004b75daac271f6d7a6f832ec1835e404be397ddc8fcc242f83daacc9e44a205837b5cb76cc2d64f2dba068fa07fc83193013e6414dc74722f90660080407d8fd1624eecb3153b6f34cb85ff39c0981d164aa6364d4953b1732ac94492e4a0428a08a6a23ab2654b4b84b7f4ce9da00c626ce081894324db80b35f3d6cd313ad73688df969c9c2687893e0916de83db0e745babd656c6f45bfa209c754346e55f05778d55827d5b8ed47a8acf13b44cde5d4048e872ba0f35df3300c7a0394a3ae1b73fdfc10e7d7eaffde86433e9af5ba8af0a51a8c983e3c909e206b6bdea40e5cb0f0c23a4bd2d9f135f2772b5251ea582bf3ca074be6d96687d84bfd536ee84383f1e2d1cb01f36c4369247ad78d675ed6cee7bf31158c3b91cde195a8b5c70ef147cff46c0b27a6e1225580d43f4f902f471715e1c07e0288e86640eec2d9c78ea10a6a76a1f9f34001a81e1f48c747d68fd76eb55b36fd217954748f67c0ac4edb6211f9bb7b6fd827fdfa6749cc1d6b1e0ce9144e5504d04cd893914e9fef8e671209f0f4a372248f0b4bb66fec7ff294a6cda624497ee5923b3bbcc7a8facc8b75cd82dfc35ee5a8d8ed0d64a93eb7a64a61945b963a073f7f10766cb9a3dc409ca17c8d3c6a442bfa0a83610205382b37d97502aecbf87fb0fe39760e6b052dbb5213b678029388ea5da526129e1fec67f985bbdbe085cc2af20fd3b9f7f1bb0ea5c2dae98f96854a611206ce367a785df9a4bec351077c0b27f1f642e7298080460be943180ecfa6b1119955e9527d6d8448a1a41b8a6d8b812856b0fe7aa2e375a1c5486c62b096b0784e4d01d61799a5516d247793028aefab8334c42f2af8797b9dbfb88f45ed54a5f83567bfeb7cec85505891d536ad2847f6534096a59d0ccf023cd9e5530475b52927d9453bc2a9f58a7dbc863a72ed9d801f82d893d340cf1b944088c882463b973215890ca22460519d09cc96824afacc019b53b9e90ac88b1c8d8e390da72098c7fe62dd72dca063967e71b9d5ddd003ec8bd8b06ee5bfe9001afe02c26cb9e9c09d5c8dd0176fa3192a5da153a1f16e19bbb233314897232e8fda4c4a56ac43f9f88336e274e6325cab1171e4ecf9be00883889b8b519677270edf84b68720390a26f6ba4984f3f29ebd8ba0f0b1d627f1afde498784a9380ff3fcab953fad386a7c00da948bee3fd59956ddcaee5e6aaf834bc675857573d9457e6c10ab652efce0cd48ed4709222384338eb03454a46ff926d62a2b5b7678e46b79e55d3753c9f36fe3ee146ce797ecd788e25289a5a32dea39995e3e8afba6e7a330939ad728cfcb1b0b8edad92add974034d1c91eb89a15467b94a8c6e6739dfaeefa06f7cea864aaaa8d852274ee70c7852ba2c30d2ebd69264cb05cdae2601ae201254621a115028d4614b674989780f4e77cf39335cae8f7aad097c6043c74c665c146a8dde2d06d15a75e1361c737ef75131ff8ec94e5d67814b0a8f39f1a568018e6f82222ed5cc8018731e16fa3f403ae7401b07c08cfbe24436a4bec794517978a1783e51e858a7380de9326e103806b9a7e95ae709330240ed146e900388c6f71d5e91a4959cd06936b3ad0b796a89551c5bead33c92b4a4499f625daf8dd2f9fc00c2bccbfcac223b5cd3c9f61256f7c8ca0dd6e5632114141a7de3817b2dcddfffc8d3acf16a554c424f84587a6338cdda52e0aa32eeeb6af59fd20ba6a33652fe3f0407da69e6bcdf6da9007b27c3368b0bcc5dda2b69bbddba5a6887e8f0a9917d0f551b89de055e3ec768a3da5ef21734486122d16a5a9821677e9427a2eb4865d626a7f843e6c3830c5e900ea318a93be1af56969a1031a3082ff6b0fe4300685167cf4590d285ec01ea64152f4a1ca70a4c1743948d4c9f97417593edbd60889d5425bc491a4fb0dc8bade2ac2da7349f19e941f1e8d6137aaa329f184ac17988eb0c37628536074a7a4383989620b12e423442882ef373b8cb4227c3e8fb36d7ed34dec0affbf9e4e0b223f3bd2d879851763b1c41b89168e45633e2e66d8c8aeb5d3369ccda1f5461d4768915fd27cbef8fa60893b02e943e94b364b83483e8a3cbf69dea2a05c0fe632ad572566811dbb1a565be8e85f47f4363f97283ad71da20e79f5eb24a9d605313102514cf26c91a6a5c40080663e25a0336dc22472d56ca941bc997d7c3cbbee1482edd623271622d5356aa6259f9d8009d09477a8fe2d830520158a9408cf7ae033250101e07e563fd1ed4fd01b12f14d1017d88dc9f921623cd326cf5fbaf06a9fba8b0f1d6d0348947217267b990600e07f89426538471286d9df5de9546dac727a7c5f9b8a6ea5dfecfe2497c28b97ca5bdeb4bac74aab359ad26d312628632f7ccfb1a41d5a2dba904276ae08406567013b5c10a0eaaf5bcf698cc0c0c0313086244d2e3660cf3825d9183cd0d2bb7c3e0501e83dc687bc41842293e798062749fb53abf084fd58fc843021de0dfb44e376d0ee9c1a530b210e226d8f27fe0a09d920982aa5a35edbefe3e78eba71f43c376cae2dd2bc2a76333253fce02b2424e3b66ce6b38d64e16453b8ee700b9d137bf88e4baacee8e35862145d284840e30e8c25a855022a3dd4c643e7ea1ccb2c82bc5633cc400908795f9760e94a960a58395b3f71e8d044c21387a9df37ecba8a892265998cac87ec0c729a63b98546f36364dc67898907017fd423e7b43cf58a67367e8574fa69a9214e33e3b640480717205ebed048429bbe776d5533687ff9f098d8687db0dd2bb201fdeff767ba8f26b6850727747691d091a4de627d513e5a3a896d7ea200699d7c867bc5e17fad043b50d5301c9be936a5a1aefb77b06e74276174a6710491f2637afa5fea0fed596b6e9ca5791d8e27af870bb0bba5355c9855250cb6dd9520d82b1d8bfa7ba4c61db56a2196249f7ed8d67308505c75613c532a5491a49bbd8899794dce2bda7908564cb36d481740a67d8d656de30903e922d841fead0fff1a655aed9251270837a56d89da8ce4602f6cb9bb06b5dafc126f3d58b78e51fe5691116ba3ba52afe3723679ed64d66efc9e91cf849657f7d8597314cd81dced283863f197dc9ab353070e728a90a75cf40f75fe65462d1ebe95c70f732415a7d84f61c46e2a6ae07bccf1119c021bdb34632b1ae9de8100b199a3db31bec6bc2f3ced89cf8ce423b637d595d94729705306b7aa2b47f4095b060ed565c10b7079e2f03130389279d8e2317c7aa169773a5eb3e24efe85391a6e4432a455ca764f5fa9e0ebcce5ad28b031bbaa767e23ab46e36e5c709106aa831c590b3459f57cf7d5ce1d13df95bcf89dac189d9d19a6f0084936e1f768b1c503005e1a3cb650310348dcc8a537b5249b593976998f12bb95961ff5c9501375a60dcce54bd3e131011dd181a7440cdc5554ad9ba21bfdca75baac7cf22008577f5a98fc4bb4116579f35c05f99193d66a28b612591e4b41ffa210a6925546f1553719f12d7cefe58e08baa9e40016897e37df159df9f69d1805d75eeb615f60740d24a470d528a8836c33156c9c2313950f56edd8bf029c7da08a034cbd6cbac7b0d8271b3e47c1acee76ddb1daca3465eddd7b9df7c64dfbbbf9507df84acc82aaa1152519922f3cd7d005aa31a4633535161d777b96d6f13717bd32025263936ffefd419db64e1637bdce9da65148f124fe9b7c26af720bd034b49b9f34dbd3f2aaf2fbb798587c6da0db861dc1a8e47d239b7b7ec1a46c28f7c02d08e0ac1aa4b47bb02543487f9aaf44598443aa306392d2ebae084d76548bb2963d0eee958cd7544352c61ad44ee2ef83b5386687f0faab7a20fa3f8af1654ff19663e6e445436e37468e24097ae1501cdebcd669fda0fa9845c60912584fea89391b4572594f597ae5a1fe7c7a33c29807c3169f04411efbdfc9b972d5d61ea31b8608886ac0f05dfb8142a247ea0b62f0bc8a2855c26f237f2f527e6b4e101a8140f3b2a14ab53d63b4b8a3a0cddda50a7554c268df2333be9c49b0e319fea6c1bf52700d49634835aaf836c5ebf93154242bf04faea0487281665dfe5e9ad580b6c1759930eb3387f5715a58349eefdb953475230ab0d7946d56db278dba28c6897b271cc5367ec0bac9338633881cae40d92cbada779e013be21033032397790c31d8bc17917161b97da5f087700b9be36ddfda8143dc1843a9f2a12d9d7fcade46cd7663a3a3d9f5df839b84859fc84fdf7aea5cf2f8b066b83bcdf07197150e95dcd0391696951ae9bcdbbb1b8714e4c224f18df313beb66214af3f70fd3cf57afd1f79c70b4958c4d1ac363944bb189918848274f9afbbed01e3f1f71106fe345ce9161d2158af21b1489ac94a6cc1b18b21e50897c7b5614321cbab1a974a7ff99721b1629d546ed78a6b1fb3759e617cce4c25e3c9be99a2fe348b26cfef80958740e4b28e733e309dcdbe18fe45f1c7b9e38604a200af74d4100b1775ecaa506f4fda732e6a1cce291f72908dd2a6d85d8609ffd4f39129620d75c2ebebbdfc87a406a23d696ff0a650b23740d83b26db8e1578de029944d4df73391cfdec10c2d55fd526204905cafab78fcd616f5fdece424a49bbbf4286779739e821088dda4a96285ab8237e1850d52837bddeb3ecfaffe46d70ec9cb1ea2912591ede2d9c1663939cd35c8dcaa9dd9be09720cb11bc29576202908f4cf18ccbc6558b7e41617b584bc7441cad6bb34871280d8cc498842ada6ec3e3db318e3957df4747220e10c6f9eb8eeca2ffd8d5482bef608a99c277a97921a3f611afa63c1265167f6e1895c8945dd73525deb044da3b435f44b982f79cebb61c0531ec11c77672b513fc3a1026ba339e05db84debdbca576b0a27be4bcefdd737024d0389efe9846b4757a050e061a33adc6c1124a988aeb5a4c779a32f868047e454902f734b8b4f9d34c959c7ec03a82100c2a4c27e7eeab04fe15bd7f1786023136c00fd1661bf2fde02919d2f43d3605c680cd68f233284415a58aa9ec8078601576c92472c048caca9eb870d42e5b8620a29fce515c4200b5498a10665adb60cc390946167bfc4c3d7f9e2c276f968152a6dd47dbd04cdc125108a5dbff1c6e0b44a46913d370328ba42db73d0d13ef18bfbc64da9c3b73f8d335a3f07c74d69f7fe5bb4ee75b731622e4112df15f4bc8c7f1d83d5aa73c286ea95a5ffcf0b132ba759356fabbbf419147a912d821ed2967112e3a12f37f932dd62249ba6305bd6000d56a4478c5adac9fc1b5ab7b1cfa19b7332f2bf4e7e56343e6aca7dc8033598d990348fa56107474075c7780512ac73e54430b53a58861ee4599d1bbe04227b564b5bdf6282d947334875a836cb43c54eecfc52b3aec86bb3b24ca7f784fcf9ac38ae2b2ce06374cb38b8c95ed1089f99f54e828fa72f998d92256e006e670a5f5f227c59fcd595966cf21cf64b8d14ae6235330d94735b4af2d030e8daa99dff2ff5ee932f70df3a064e7e547ec672c1580e4ccd6744530852c9268c268b99f1fde8fd3ab89e51712f397eeb4708fae3da7bd478d17b253aa4762c83480c3c9b689b8c2e618a5d4091fabdae2a74fb456c6ad5bc82fc1e18eb03c8ca27e54ffc2a65262ad8a6645bb911b91774d09d934bece8b6e47eab6256e4d860f1dc1f86d82bfa864c3df47769ab9ef6eaa9914a01c59264373767f23b05f15ea21b6343aa650f9dd738ecef2cc7c7f2cdb1b557753782762b56da0d44c31e61fa4339cd0ee46eeff422c72eca80fcd594aaa82fc3bc03e1209bc0adbf39270516987b4ce64704f02888342681d5a2bddf52b255b5092c03c613567eec94b08782dad95e2acf93b33bbd541c47846899721917945da5c83c8f96f7db557cf8f878152cbc184c5fefd7fb96f44723983fc04393b5b31a63601643611cb775889fa0a4ae5be9e93094af595e6d2681bf712116bf550d23e04b0763ce4373275fb6bbca7d297cbc00908118433603a91e557faa932b4e015165cdb52f5c339a4d58bcc295454f6b86cf98b77e7146cf05fdb7df74962fc5c7da2f14d5236714c03db850be090ecce095f598de73ec264107a4c25558753738aa8e728079724292f40d2584058c5f0b8e9c4cfecd5edbf04b89e440357fdfafd5c9c2fb211cdc7dc8b735db7c74804a7835cecb04be0d977e9db45e08de1038f29624e64909eca33b69c915b9535fffb2d8fda0c0786e8ce3ef9319c1260d36e14e641cd112aad7e9f0f93f48d739e10906c5989def9182f232bafb720dfac2ad4f52625ca4a2634a862a3741ae25c38715b584999be699e8e03a8e111a1c1f8a8937f895b124f9827d1d4c61d8c30881022acf9b35ed32953e5f6fb3b384031bac74f883524142b241875bf676c973a5f3b78900db75714000d9c680a054bc1ea3dd4ceef0cb15c54f58364063aa124e4b1c0b6874a8670c15e4c70944868c689048d0813ec41c89c853758","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
