<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d6e25dae4751836505add87acdf230d0b4ff92d05533eaed3d162bd7240c6ae34222fb9ef9eb4aa4249a6b2bf2e20618ef0460d26c3fc252cae1845a396384613142c30a8287a51a8754dda0ac261bce6f68c0c55fb5738226155637754d22f01f8cdfd8541891b7c70709e1600a1c08672318c9f21666b4fc23153e7bca9c2dfca8fce61bf603fa4fb5753af15edee107890ea0a7ca55601a5fac614199ce078d2e35e3a4b8ba00fcb937b769c55c0a747ef7f7b4c851582acdb2a41910b73b0a073be7e9e83229887cb64573bbdb0f0b5865df741e5b9f0376752650b1670c06bc69d4f744fd01df5db00e870431b45758c725dc0793bae92bbaa5b0b803db8933ff297cbf5246932591e89a78970be5f602018e248d5cfb905cd967ce09ea83d34f5e2050224745d843b30b9ff5c04bdc8a83abe0b0c097299b34ddbc963304a5136588cb304906a64e73ff98db6c32c51250c29cbd8dce8c4b799fc6f389756d6fdf7b164d2c4142cd182b2e17c03f7c5e51c6aa226d9afb91afbd14a913e8dafcbd90054e1fb5d8ea4055aa5fed93a23ff1ff91c9f9b784ad425971145b22aa92d6508112ad4ad82b40ae4bec6d308947cbe44f61435f75e259a8f9bf37f2f88cff084a77319fd06fe327c175bbfb7cf0986185333b68b279a024af87b4e1c8536d21fa01f08a8bf383bdcd82777c0296d3ccfc1f05a48817e334ba940d9fae899a08619b2a4cfc59f65885ccf900d4764a0fdca1576d91787d612af2d29000edc35da66ff5d23137be340cf5f54f6eab66f9eb49ba6867817fe39732c9d67ac1ba847f4c169b9f7f2b2463cba1c267c2fa9f99cd15f05ad8184953a10ab263a6eccf57d5ae510fde94888ce38cb7936c92e012bf2bb8d1fbccbfdac0d4b9dbba3eba063547f6f8ab43612d2e8ead831cf72e909bdce0882aa84d2e126a0b65ccffa8348de947693c7fa2b7f0f3051276b094ecd8ab5ae9c7e5ffd19afda01ba0dd34d7e38b471c87969b3d09d0eb8aeb6cdd03e6cb97df4c4ab972bc53fb10ad526c026f712d8ea11c6ac7a9fa16748c4333ed2999f9c06e0e884697ea0d9c445af55663f581d2e45571a5b416360ba7d53ba9ea12ba3b3c24a7d60cc8672c83b10195539cd88864a3d21cb78a50f2ac33d075baf3b244cbde2f4ffc0893b9137e4f1dd30285cba14df39ea2003115ec03d62ea8f02722be7f7b10c688517023e864ee9e1247bd33b994dd0cbfa077a2daf9742c72af9ccaa63e10b45f962ab159f3cd0373118558ec617b8ec4f0a85448a49283041842795c61a8ee840f601e1649fa413cb304170dd5009bb76d1f189a4702e95b7e116b5ae23e64793093a78b4e0d86f0a0272001c5fe1572f62564e0f49f90604139f320ee918515679d45927f8eebc9e6c155e5040c411ab9c6ea89afb99c27ce3e2af62cc07798d51fe29fc3208b55efca824f4748ac4bcbfbf87f2964cd3b7d2868752f5277f8c3ee956199dc1fa2addc2cb24bf01f1095c16df1cb5c780381ab84cbee7905d40b061f4ea43e8a6263521aa487aa293f639b6f23721485a1a5ade92a3c4911acf354dee40d02272870bf50e20b8bd84e47f93ef5554b5a4b970a87e40eda5cfa1a4f942b791482466c613e61e7b4684b7b9241f7101b6d701778396b866479f98d6136f3ad95370098fe4351ea588e0c519140a935d65419925d4fa3ac1b3a060f25dae2c704f78ac4576a8af7af3881758b92d99774bf121ddcab7df7d1954a1a68aa5a3eceadaaa90118aaf02de15473755f704c4f71e447219ebdbc1255e7bdc2624f315228a91fe8b1c559815c0fe21245fca2f4d22f170a46c199b3a411126116eef6c555190ccf108312a0aab2ec61cf04ca540e50f310db210f50691b107fdd39bb09b67c3b5336a7180325c56aaa42521cbd40ddb18a308dd0326a6506f68ab9b9ba806f5607b3aa0e4182d5586d029a2a54f5faf0b1efea944bb662e9bac9812441e3b451ea4393f8a99eae0015a264619f07d1092cbe113f3fbe7060f65b8d9849ac42819473c7a5a4bfe06555852d783097443399f83cc0071ef4c623cf2e6cd081c463e24005e2767e570a45ba5a48a550804015d8eb68c2dbb80e5fdd648e0e706e88585b0fb0ad24f79e30bfe015b4e6d4d05d4096b714bf3345646fea7e7c2f3faf58a6d1a672fe3577b16e3911433024c9b9613c9e3bee4c828a899720fe20c667ba5be558a77b1f54e489d7f58cb250155c67bc259cd3dfba0faee3ec8be2d0bf62aa8ba2a85c97d013e153f29aec73b52732837e641e58beec9c2af1e7e2fbc00eefed1b56cf7c0ae486eb1fed1f815081e9ebe6fabbe9c307a80989ae04e7cc836375c27710ace1eaec7a80fabd46d148eddbb314b9649b85eedfaa82994a465db7218375470499c09037de639f3f08da58ef2087234f53888e67f79f870c3be649cb07e9c9cbdff88b3f26203672f9d1f832d480559b04adfb05aeb37be4d126966ed61e5acc491e7cc8588351128db1fd100c4e5fd73e211e8ce07646d55c314102ae0240b0b9bcf8233e3352bf88c6d221bb488885f0280098762a678e9b876ae98dbf5c103c4c8b99bbb3adcdfa9b0d384a13c2611fe96025add0c9be889495472fa437dc0caa02db039091eb94f56b1fb4757080deb7dbc670111f590154858d1015c58fbaa2766cc85bf91821b1ed465a10d9cb1a50e1fddd9e091a81c3234310d2bdade56595fc9340e0e64c944e9c09397a123798ff617d1c3ba8e97b064a04740b3a6c01840d33e541b713eb924fa8dfee2a5b442eb5d4a8a743cf2116d980441113b8d1cbc64658e84711211af8cfc3bc6530235ed9c8970c495ff45fe6d48c086952e5de5b85c1aba6c2d4f96cd398490b2a0c5761d5e215c6c2af7f005c47cf04facd7afa134610f3c92c2f7be3e69ea1ab78e708ce7c9aeb3151fb3422950cb4657eb67f0e32fe93d00683eb1e1ce64ecbe2f47891c1fa49c8ae716273266000229bec1c46f6cde0ae2e7ed7e78f57a456f27ce3c13b786139ca1b7d3475b530cd010337b85615381d315be29c53d728b6a76d00883351355084992a6106b43bb2ae89135e73dd838a4601f4ca103ded6ea223557b7b15248ef360e41278aaccacdf5affcece0fd233b390e0b2509404ed8016e39dd1a8a99e17fd70fa5172577a0b8a4b6f6c2d2504b150a95d6ba0bd5919e79d6f268fdc12f9b8599248dc813d93d687b4be981d4e7cbce79f622b12384602e7a48be8ac55e8ae4f73a587cd34c2f29e3c06d0c6bd3dad3b5e8e5d8a2f05ad3baf606ae45b2f6ac4a21386e12ab8c593c3f248c07de22e82b4dd3724a0d0b99b7a49c73dd6de2daca6f1d98e53d459e7ba6aac0876f106874368c6c0734c69f05c1a17ad79b538c21b76532e41638c323799f4610392cb49530972980ccc6c3ca609076c5045797cba8d058f92d4d586b1361c7e61df13d377c038a5210fe4a674da20612f13eb01e8eeddd34e0bbf62b8ce5cd8b63abf487609204c9055bff3738cfcbcdc79eeb7e1835a8c39c8c6a23664dd932dc8b0c762890f3b88958018b60a3340f9298a418845ab758ff2f70c1382039851d39a6f1a41ac9f84b909ca7572639316315900f8aa5c38d611db062eed72955b8b426bc1dedeb790cecb38bf02bff901e675d06caeff16b833976ece8d7bfc2683befb95ae6154f41b8a2c5f57351dd10175d8709c87e1fb78e85a10105b5c39a80c34bea4813fa63cfac469f18b3d8aa0effe2860745033a83514d349918541aeace81b1d2fed40449acb1fdae8b2d7f707056cbd7cd5a081c9a0fcbc438334ed6836c464675b3f49e9ea22de58006756793da72ad02815697d2ac1045d96d99a3e0da4f72adb5024e6490734d4ca793a43d8487da4e6548907810b00d5fea41b731dc927420d002daf11eafb956dadcc4a884a2cdda609fbdd3cdb0c422a2c3d44b9ed174d94f4d44a83afeef98c34432e5c180a66d66ac9447b24a58769a337ec6c1059cd2b9bd461d3e9d7155f04a56eb937988dd836753d25f9759cefc55b16247a4080d400428a27ad637cefaba1fbe0f21ce9ebf38808159f1bbc5670ad2ef0a3d95df9e3f7c0dcf7470dcc9fdabb271e048e7d43e696f4dc1148127e5344f3c51b7c11c324aa094bb18d13a0a11637fe7f8b30128490456afadfc8acd51929d9fc36d16dfc0272a4df32ee050ae03861fff6e3ee80f211030859ded7edae9e2cb14506be3a0b950d0b529088e6bf8f866cd26458c932b8d384c54e162cbf3806814c688f5bf6bc61ad43c5092053b3328c7dd312cdef11faf998a95572a05257e9eb77aa98c19e312e9dd63b01472f12fe84ac53bfa4ec8a2053372b843c4c247a68af07b1290bb75bbab2d87ee2592e6bb3317c090198cfe399563550eb14f2d39aaef6985ddb0ae890dce1da90dcd936880e70db7ac743556642e108efd92b0bbd8d182208deb8c2b37761507aede94bc2ee5faaa592fb4f4059d756d2399dab531e561c28c140dc0e286d13c94cf3f23207eba41210cef4b43881946d9629153d211db9d8cdf8e4a08be6aa7ad930ebd620b32778ee687a0c25b6160aaf1f517640aacc2024853e2e94e1d24426fa0de4b5e5a6af6319418e52ac479eae4a45191f5b5fa778fe67ea193af74b525e611f2bec2aa7470644eba4946f04627f1fed37e4aa27a2b2fa018389f930f8f480db553d073a5fe1d80e3895a7f2876a528b510f0dfbebaa3a900fae6189060efe5fa8cb10dab3695aa92bf8280b6eadf6d0729408e76225a018c99560fb8e1fa449d9a61084a91d5a8d6e4948958994b57572dfea1b6d2176849c5e77b6b5d4baf1a3e6a7938ada2d961b7b98b5cae44935b8a8657a26d3ddb73d9dbfca156e7e8a681580152122dbf0058aa8170eae63a6a26f7c4d7150a282eaa3bbd8e1a1daf77e0925732085e1cab13b5b6ba6bbe908ca64585ce47bc83604c4e00b62e6d7557e49ad299d651395240ca5c2fe307a2f8e1f5db9c63b5527c672680a06e02fa4a2bde52899b915c9886f2de8ddc044ea3b16e94c9318bcea79ffc593708cbf16c892ed13b76b58e34e7c72ce48678e92b4c6f5f74dfe1c6b188c499955f41cf257721305b4b7d8c08daa7261d9af506dcd517db4e6695f1681e3d0097e860473fbabb50e3fb12ac4276e66ec7d0eb982e52113c482b619a7d97ee7f324a3e6d60dda41d7be8bdd3e460b1ba93849f78e8516e8e6933153dc5753f5e62e2b33957b054f28fb9ba241fc5307d8e265de1c8cc4b71cd0db58360518224cde4aafdfca2f06d61a71b6d7f15b2f1c54bf69873d5c087945f4b9661b8d7344c42ae0cdca75615b9ebd3e2ad24082505e22a0da6b4d1eaaff49a3e319854909b5cfdd923c91b37973b2f67c0a72d01c4a6138571ed009d28a19f67a4747fab8f939f3d3abb0362e0c1c6f5ad0e6b62cde064af53f8315914b89dd3edffd9b4820501d192f3a2e389676a9233761a01ef6039fff805498561a67beaf8a474360068d4ef54d9f9d2305c899ce80a7790d353977b0bc7962066db11eb4a32803f82b2fa1b66442e7eedc3073d1480dd01ce0137654bb015a5a6419920f939bf8669db632deca4a64cbcd11c1ed85a409a59aacc2a3f3fcee8c7ee8f0b5788ff216bd2178b4cef9db27178c7f72ff84f7b75b005f06ef3add00ff262955b972bdc1c06c1abd3658830fd45a3bbb1f22c81089feab3540e80a96d6a5d46a5f1d7b07e683c1f3e43e83b3ed364879593ad3dbfc10a829f8af07a04be0a3dd632168e2ea97b39822fc60b733e22477ff601720f2cbee713cf42a2ba3852875e73d40188e034f5f138e79b9fedb6065dc11c28c3582bef406eb7120a6792f3691fa97b22ad390ac18a806903804b3d966c042713cb114a6b5ca837ebecb1be12816325f6eec4d2a216a2c8161225087927c394984123a3b576d7d59d7900dc9c0d7ee134c655a910be77685c2142ed09c9389c7218c0dfe5264d1df15b296b0c7a959b5652de88ff61ebdf676dc6b65609e142991ff664cab05a60049e054309a5a65e0d4a5ba375bf8e616ff29b015268c1b02b742bf7586d025a407f95911d4fd0ef51de4835abae2c14f9b282cdc2b735c74c0a4e2d69ee258bf1c4de672ff5749c19b069f040de23b348771bed5ff7dea92b307cb10e254d5df6e56049c6410767e82d8cd246f455b97862fafb93b501e3bf4a8e4e332043dde4604179b6f37824ceac8ead48fd59d8057edf562e75585b7384f431e7f18cc02927eca1609589f2ba034e0e3f9728dc6ccc9d4117f494d3a372d09422f42f969120a5c85f7488ac74eb20467b7dbd2d1919dec2138a36eed0841492b0b1e4c6bddeec4059a60f53e2b8fbfa6b21f2bfab5cb9806f220bef2cc367e9a454904eded09f08be451455c813c8478309b60471c8ea88f05c6df8df2cb4c785d9b4353d920f6be097644cb4ead0d7a532c6c06cd3f547984ba8bced00d7ba9049f15d24d8eabe5447d5caba3d34952dea5d22ce235d61db83853523c63c51836b0770b6f8bcece8efccab6ea5bda7ced09bb457b062c023ffbd739ce453805654132edfe85500d1e3fec55cb2220dac5aac9ba72c6d8e96049c1431c4020b39c3ad5a90b9b32c0618546c9b2cece4bbdc87f098228e553bee67b1d438cc0c74100b6bd44353925c31ca44d29024818936cd8e5af253f0bfaf69438425b6ed288e83ce80ca79b454b60bb1c647d510f8a3d5eb0100b72cc8ccff69c991e6c2a99d286d10ee01562cfd97ff3e59c5fcef06a2568dab674436dffdf0ed1bc96fe590550780ae9b76e8e340a0443481075a3a046e9422bf69ea3bb00e0a056366e98f20cf908dd16cb6caf7f33e507292355b03d4fed99bcfbc597c44f327816c2ddba07ce2d9357b6e10fd0dce227d701ab02e03ef731c0a37fc775b7d3be3283d5575784f677e0a358f2e04755dbfc6b15ac074daa11d4e95aba54dee7efd524a24df9e2a4422edeb293c4707e4b630eef8191f3e3915ecd952caf4ee4267654be7e7b89c3145633ca2fc648d6667a974d4aa68c936ebfc56b908f99c3c03c511ecb419f354b9ab944bd20ca7e73c51cabb8814041a3d5c8cff2eeeb1ee04c107b72d3324f7b3b552c3fc7448d91f892e915919ddb93b0c6d18c6588add14805e47589a05e5a571addffbadf4686b28f785c8d415494e2a91d952338abb283c6fd21e0ccce39f882ac68f33e6121c1afcab2bdafa4a27f19f4889d25993de1fcb9267813b8a291c2a5fd3fd7acca009a3e1c60723338408d63969a781d06034b83db4a39a43b2d29120582cb0e80b8836d6ea50f6ab3574a84dcc2b77fffc87dc9444a5fe83646c873df2c27a12251ffedbc48a0cd974902d3dee0017389299723f2cbd0f34cecc0e8f8ba6889bd426693074cc1cc611a99ead2b63c0dc3a7cc7b40f94116eb5054136b1f9f367a7bc1c0687ffdbe57600813d15df1865128406af2e74c9c3256e63e5d9852ac44c911d36cf01959d73c9e044eac44278c2b27c113159e6b69c10747bd06b56a0eeada8775bcf0373fb9d8e073000bba2c433ab9ae1cbe0ca1fda7fb950fc530fc01bd968b6c02510bb378b6369838062d2b15944a170143a6268bc154d3f22a307d1ec2943502fc8ac7996527336ace1431ebe156d864446c8ba72c06ce5ffdd1ac2b8f87c6e79f4c7a46ad0ddf11418db8dd993ffbee21b65128d45a433a8eab89cc5cefaf705074bac06fc7411527e12c8d6cdb5bf9b28f6a58e6e81737fc8d589bf6e23d9b54491a9db56d5e40f67c9f2f2de8ecf04a6d630940ca4ab3f13f09b6a88cae525a255717cda69c004f33844bbe92a68f900573cc3aea4ebbde5db1d72d67335dba5d6f382a400a4b9dc571a361a1efd9f9728102460ffe69feac46d243c26e6b9c5d127aa6c654f5d30dd185764fed7e90ac6456f79fccb5efd08f731a38bc3b870ffd75835a9d925d0e246a533979cd22ee58698b0e811556ef983758a73a581cc7a88664a607cf984b7c55f987205afe39975e9d868dec12297cb1aec24b185d1c97cf7d1a08f41fa62abf1285883a57f972e96bd8aaad16ae585f2a5fad36a32bf7c7ccfe9b610c0b600d36d2024fc62907fe0f82489d65f04e0e4873fe37d71abc94b8f4c8ac8dba4a0875f8f5014f3a506982220d245e386c24d625e7ad62e3706f3ab6b32ae0e034bbcda7fbc1b6db9f573b8167ad62b4f429f56440234ea23e0a89fbd55dc4f0e2b82784f6f4523d8de6727b5f8a4be3f04f722ee1cf0eef8095f81a69ca6aee8b5d0de4c34bb20136f3bbfd203ff11ef9caf365dac58fb4b845864c6118e41032bc0ee3dae9549e0d87300882bf6a5dd55adc1e0d976b14d7bafd04db9d3daa6e183d52db6b9033e50a717db3bf10d96a4363568500b0c3ae15c58825388f64fbeea15e17edabb396589b5165d00ef8b607460e51d5f1c12b3c12812b8404f00bedc6ffb94bd2d935e4059e73ce34c92f8218a146e6efb85b3879dd53911c20097efdcda71b3f832511f478db38a3b68000183717bcd97206028d9b241fbb7e75f36013a5969e23f86cc51526d7e311f698632c7c241fb02ccecddba44a60c106fa554cfcd156157b84a821817b0cf731c76e126cf29610e25b08306e34bceb9d3d1787b5f61a0c499a3c4333202ab71144b8665c8ab4f8275e88786d6313151f70d30cdc92a829052ea88e70e70d616a1cd9a383712a9a524b49fcb4ff2d8e0ce449a23a1095e48eb3af1c17ee15144afd7417adada923f82140083e677e24d08d60c4d38322d5242199b186a5c48ae3da58716beb3a4611e58e8325384a65167654146fb11694bf743046d296261682aca49d7306d2e3dbb7e6a83815c9865eb4fcf84262ad9ba1e22bb3acf3f4bc2504fd819da6ec32e35784f4b4b045bb622d29c457dfa6f661521f69287fee02057dd50dc7c16aeec47b67d667bfa77c34fe224815af9b3bbb86c6523843512d0f711ae03f7be6028ba0bd74fd7cd82f39876f00cc11a81d2ae14fb86cd4e2d3b7c0f044ec0f54c643dc3d93c95ceeedf84d81997be5e0ef7be99a09bc4a4517697b6c1d1095ff57c034d1d1046dfa66ca015bc35a827838deaa2af3b1c479191cc12f85ad70456984cc77b39a81143545d1176e0a7256e45d2bbe5cd42af91ed382c48884b5bbf69183ad5798d0224431b43c0ade09691f4329960ac7994618bf8a9c456cc5362fd87cd8a0e62a62ff790f03ea31d8ccec4ad5d6900be461d4a4f14af181de634a0b71f909f230bd92fa04b9f4100fc252e710ffce6b08a11fa599a3d593bc5dde0ad122fd1ecf70109d4b8aa1284c45542186c3cb7a1346bb14ce77b7de6d7243e60010d8700e93bc7f0d4d37eeba8d74a96250b9a368d4c2cef32f6924ad54d48c2fc5f355fa6c7875c9be2bccf4123e4692c9eecc71d35ba2a6dc7d93d52cdce6f17fba25713c8f9865c64bc3e47cabd08c5b457f31a6ff9b051cf87fb9f4f1d6afbb2af862ab5efa6aef06970c69fecd3df3fd894b87134135cf5ce527c9c7da24625418c82d52f9e03fe1300e403ac4c7e8b365144364fa43d03158884e41adc359bd3049270229f897f6e1dcfb0f45da148f169b8da03cae51103ee398e9cc587325b77aa7d10466a557f980626f6035e158efd6ca4b18b8cb50a9a86dea449c2b79d71f3376df011d81c98ff02a65960c3d7776e676f17838f5465c3f38233241271e185440b9da32a4970753127d4d317c21416a0a35f9cc44b5df92fcab157aa970f6c16a986134bb6c4409e78c2fab2cf9a4e73c304c03308da853044c2584a1a9992fc81e8e57e34b4f2f108fed0c2c8a7333afe969708d4a685b5953e862f3ebd51eadc14947d7043968405a159eae59f0f8172b6d9575e40efed9ccba27919c4a4b59d4b676aa74c382a9f90273f5e52e94c8b48aafa58b5502d28cc58dc1e76b7202ea2853e00e6f1fbc938a8b004a6ce7deeeb31e7f1ddc9cb5cd85ab1b71d4bef24e21f2e484d5f3eecf2a5911d6e5169d7744f40a3a23f2d03a9439c5a8d190dbbfc2d65b9dd3952a44c53a47ab676921269e44678523ffbc3b9ad3f612f0e5c2c8b3ab7c2cb72e6f8665f2f43457dc6838c07322ee90e6887a4eabd7acf563ccc0ea852bcfc8e77485668c0a68c6b9b34b616436cbc5624bfaf26dff93d784f8bf7ba46cb60ca7b3872387210abb9fcb5704cee9afe14bb6910ad8d5648d32a28ff289ec8e8e96752bfc3293c87d2fe6c9285e9f0564c69434fa168b90e99fc45cedd844db30bde72f21b95761bd9a7e1a9af5864e1abc9758633f68649e1384132b008f17da6759be417e6851806504fd89b8e80741b18a8342102240e2c3ea181c074a8e4b5bd52d3b78ea47fd53b42b37ce6951dca8e3256cbd5c30d446a639a9947cb94000d645f89df70f524e3e0423b475f8526f330ff84c0982fbb7a7e6d1e6e93961e75f1cdc3f48b504add734a44f5b1f1e81cbc26a8e5bbcd186d4df432face6bfe5a67b09a54c8f36dd0e2bd993eaa2239473ea99eb561212aaf53cb7679b7c299bea406cd2cfc81c867b75cf1479a592a884792f3c7ab70931abb6fbc5d4b564f43b7c342e62b1a1cd9a6efcc4029c08f22c7904d71d2d2c02a5f988d40c987503133d88b68216b3ae291f3bced7969e0656edfb4963810f2a31da5027e03dfea265cc2cf592328ded400d912d02856318d14a8e22fba5615aeb187008a14d300d5a03a5154c665bfaeacd83193fa0936f18b1d9a11e547e239d38d37b6f2d2d498d090b2e14922614083420d1abd21e8a1329db82ab073dc7fc04d915e4f5d1630efc225c7f674d6c085ffa00e3d5d17e614c9cfa7fe00dc7bb6b5b09ef9bb4ede7aca5a2dac83d69cb71d280bb418623c839a8e2083b66da55ef78a80ce77f295d70a3f7472f4c2a5233bd8d49ac6bb1094856f74172e0c91cee8b51bda853c203568b5b54ec6e8312082764d2590176ef1e9e091d7992a6312fc6966e457b8889b055d0cfc18f306f79b608b0a710f39b602451681c723eb629810c1fd5e7a2a193790dd31313ba5eda08f19ca06ebae26438d17a126fd446d2ab62a34fbd2d41fe6fec9854cba60976893091f9e82daaefd6d7d307531aaedf930f6bbeb0cecafb124a2c5f9e819277be699f760c6d672d7de73b1ebb910a911f1abe70114d3abe7b251671aa13d1a99bf87d9df349b44e59824f5176b0f0a4b8a87214643716303b157fdc346bde628d7fda7bdbcde9d8105f3df25cf5929b892e9cb546bf664710188958a6b98bf67b5b4bf0086f824053279fc793ac7a6c8cee67a17753e2445327a2f4080841e8801e4af325ca1be11a55b68eedd13f32a343ed8d9bb6e975516d2e54487af7ded69634850780fe0c746cf6847ea9bb3f19a76d26b5535ec692df22414d058fc1ad55964f3fa0bb88e5e7146f09a4060d6bf3598e13c862729c40f4dd2c8f85dfbfc6c03f08fbc2ed12dc32fb3e6dcac7a1c31301e86909f28e0d0a3bd7f82db3faddd4ae61848180c44715cf5b03383ac4fcc257f8186c0b4a7cddc7f014863d0c3e60a981f6a5699197845dbede6979999a7aaa0e0a129813af4794e95f5789301c026d79469c7ea246845ac576cf93117471068c5d8ce18d972983438d1e1b40dfee4bed8a7d8672cbfb106bc7ef2a2e549d8d0ad8a78ac5d5e498b8ae8805333002f1d9e41d8fb8a5ad0f0d1693af51682f1ff01f1775bf8fb99e616451395f9deb7893cc9335530b55d1d228ca795eb5dba33a3453780a6b6257ff46b4903b0e9f368c39ae644f66211d4f8ae1f5c5233b01a9a71589af11df3cbe4da6ffd1a8ee7954885a7f832dc7965fab163470cc7b75ac5c2f03a1954bd86daf71597435d67d75bd4b0e33aca7600eddb99ac2439c9a7aa3778cc7756d11fff7f2842c16feebc47060029d5d0438016ccdaea8a45620d4692466d1e1e46918cef6e7fd129bfa6491dead71f4c7703af73cd28ab1d46e67858d7d27e34d173cfdb56ab516bd2eb3f74ac8897aa4f5c985e52209dbdc377607f35ebc8398e082fc16da4355cb6d8a34b3d9e937fbb6dc249745f3e9db2a17f0207a99071eb1d85e4414c793e64b7fa2dcf5acf1004b1d1add1b8a807e296955db1fcc050022c7f3b70479d1d24d931812dd57c8716e153039fc3ca92fd365f3c9cd9f1a5af5b4ba3f28898823a2d04afbdfd541a18105f31160857a9c604e0c4fe120b9c0ea2a05cc04c0a3a8e464c44afd23fdc575415c5c9c363472c48c747c9df79dfc46ab524b2cf8da503e117354e97518c983b0f790367887b26bf756c5ea64e6b70640696b7a670c9fe62026319ab7ad3795cab0fa70adc067d58fa7c70e98354fb14ec45e2de51f1cffed97801522554c741afe8eebfe96c9a406ae578ad28822a54be50f6ea00ca04853551c1b822dc661781ed4cc9f561bae160f410824e0df2044a983933a2073f9070108e2707fd2e92f2cfe4c9cbed74726b2524c84abf7b78d0ddcbaf7358ac75036c82eedcf965ea23193229fef4e72baff02c4a68463f571022e73bc82eec5d2100ac0089fd3c21f40cb50232679d494896c401d890571acce159395dbc6a8ab8195c12eb366c679361530975a87cef96f6649bc03580c7d786cf61fdfc43b8a6d1c63914fd4b2705aed8cfeaa2cac00aa3708b90cf9382fee9dff08bb92246d15a57190f44fb8579aca5a3ab94faa100c5fc7d62ead2f7163b0bd6e3517a484fdb2481675a93aed4c5bc44b0287168e92ed13dab357966a3f171917b3105e536b5451ba5462758aade7889ced1a03bced8fbfe151c5a636a6d89b9b25cb1f3e2a9e28a596e870583d5097792fb4754bae83065dccf944670495b0cec4022ef8e7e01bdee88b01b477acd6a5bcc8d27d8b9cfe417e3869f3635139e8932c3fa7ce1e107d99bcdf43c0aeef3b0a3013a9b68233b2f367a37af8fa54fedab8d243e88b34d0f60f31fb14c51a0f776a82d45fd17cf4371a389b11fb3714e812b844346cd8ac895b2e97894c0930a61a5a7e7be74575c00d6a0107c96fdd3b7c30e71b48ce0fdccddbe0c16a6741dc3d3f88b61be472651183cb3240583c8e3175c0fc383b342d6cf6861ca9b4c92a36a64d665990db8e2ea3995c127bc7f37c96a9130df03d029cb5d7dfc3eebd4e2e4c8185966b3e5b2a6b181bbfcee96041d97f29ddefb7aec400909306193d091665e0eb02e18be7632ed3a59fed5b537655b928a78f0026d345ce659664351fe90d3a8c20f2b609c2ae07e47ee8176af482df0b1513207651131aacb0fe6391bbe48f8a9224e868b63af1313096d21829764f54363449c5cd53f459c2afd7311ecaa6815767d04feaa60cfe00a6cc836a45072bb5d417b370a90e5b3124b6f72a162742557b2ab5bf076a054e03aedc2fcefcad732e9edf10d1b00f422de1045d07ca621c164dcf2d64d0f41ec4d1eede77aafa0aa6d6b77c458a398b9fce5f2243ae97203da3b25a2304563c287b2d864c3a9697ee684df9d317f29d49138ea82cbed8040a20ea2f29b0a3f92469051229d45dd75659bed43ed76d95540d17bf8008599ebc81bd883e0a9c0324087aee4c12e01398f1c86eae1df6b4811e268a0742bbd335f5ef5e5d3b363c451891a5bb4280e98fb4fbd2784bcadfbc619cafc37298c4b9e67c77f7c745c688ffcf517e3bd218e199384ced6dbf35ca508b5e73a909f93d41d24bf01ad27f51c77ffa20c2afeadbb5bc6483e896026b63d64209d4b4751ec0a64c6551dba87908e953828d4494e179a5a129d1ab59811a81f5283d29d27e1107c0d2eb6abeff0d231333b3db55fb548ca9541ccb87ec7912ce9217992e208c24dad63456c1750d2c848996f7c88de91f506a46c08ae04bf8d5325f280db66aa46563e1d73c3a77717147560a0e82f95f4cf3371a7485abe6db71fa03ed66ca70cbd988b5f2196d8a3068d52cc48f47e3e7cc0b33dca7ee10405ab1996ebcf6a1d8bd9f2be2fafbb633a1a6ea47780bfa791cd6bbe65eea56d20663f1aef24c488192f1f2136134b2286754fb1816f4dd4a3302eaf7ac6b752c12cf37b1015aaf6709640f0a90b553ceea64a9ad5cd96baa4732dec140e994368cd09b9de4061d141e5b63cf7f0e29efb2bc8435c4e0bd26d24cd4fb2eb29f61233266284cfa2ab26890c930677e355ac516d01f7965f99ece35c909b4c6017a1a27545957f24fd41bfac8294841b19996792db05423697dab95744f701b5dc2026631445c09d2aa64e1b5d121c41c67a8a76b1833764ab6083e18a13b52ab3bfe9daf4f7b501e33b61c2d4ecbb2d666f8a92e3ecec641510ce87b283032691bc6c75d1d57d32c8995a23abb44befecf889cedeba35e7e3cd4691fd9c756eb8417c4671873f9d807a5fcf896465a87a242cfba67e0c54bbef47b6235dc147952cd6b35f91a48ca413d3e49d0cd203dfa32f4fcbf2f69f6e78908c4e60dd80104aff4086865bbd8b7a707bb3028f24084882cc6ce143579a2fe12b3ef4909775e2c0e1fbc4f1a8ebc2f8febfb9a7550e181c1a8bc7aa76791cbbdff2c81a434845616d51e46f7c3a1e5a35a2bbc9fdbd02e1ef8ec7bd4ab4b8f62c1bafdd10cdd053eab01b374e2b0e26cb29a84255fa63ca6f38d86712fc49c012f02f202c63302cbe585a67bcfb332d3382750d4598b5a12b37e958d9f709eaad6b315aeb909473194b341a3647d752b6c360821ffd4fb50e18bebd3c78aa229076c29c5ddb19bcabbcc0b1e121303e3e0e38024b38c5e051c4d34bb119bcd173ba5c879f61cbc84e82f67eed8f24143f135df8eef4282316c9ea5e0d95240484e7009fa4b5097ff9627a9ecb04cc379270fca3af837200e21517d86dd44a130131259cc1b170f0457946e43f632bcc159e233665edb8141c4132c7a3e5a5e5cc0b562ad9c9a7c38f7368a9254a0a2daebc0cfb4573a9ebd45b572d7542f678accaa9376836a0c51c0418f43014d0417f1c459b1f02a5de43975a5b9eac88861b8595ec0300bb9a99fdfa5fde69149cb131bda31d3940357569278bfe5060ab7a5ce6caf80ede13d46a8e74a771c8083a65857f431573e58ba941dc404d2773ba05fdec4e1593ff2a7983ae51d5ca9b1f405d9bba4144c30ba8c2e8e91eb9c241f7fc645cb91cad60c669c25c7870b2eadcd8a3c04fa1e1433d3136b2be3232491eccdd808bb78513859bcf7af4f108627383fe5fb4c4dd352fea4556d76628ee18e4462055626dc7773d24d36b60641045ee2535a5b4b692dfbd1ad0e57dfa7c192feacf8aee5b95469e76a9cd5189a640676b5b025516a57dc9967ef7f662f5735ad1a7dc463dbd52f2e71af7c85cf4d5da8a7c415a23bc809cb7fd84c20854f708327f7e575384c6f3dcdfa5f4ca9e204bec859e3a5865ed57fed2acffd9877043c46e0d170bdd4c30276a0c7aa188392409393c3db53632e9e8bec0e0f814cc9dbc9eca5fd6ebd2958b2f860a32c2b3455cb0b8782b66522ac07c8dc102a3f2593a45b26aa92d45a37db8e566ff34bbf808152cbfab437df850b6190af5d51da67b06ad86842d1be491e68d620dc3224001cb9d364b5199c3da6dc598a3e8f8019c0ba7cf60174e1fe8d193b890e99a651f7d0a3e212594fe0b58538fe0d296df94c09545195fcf71837ad7ece9ada6f8adf05f9557c00c811be95308ed4a5ccd4ba79074730c1222dace459cda3714ed2c3790ba80d691a8c2f868bf2d9a1b49b3541bf794d8c18cb50476810cc92b55e01c45a472fcc09b53d563dba35d69fa70ffab2c01ccf204ef14aa5cbbfb555f0ed03b0c4f8274c346c82825bd2aa75f6428497ea4f1b263ae6f4cae0a76874edbc7742e27c912d5b70a5c77d710d5744076d0e5e19e3da094d7d58e3e05ea1f203cfc6d850860909119b15a56a67d8173b328718c9cd720ac72af1267a183c1eb0f98bcb936da1060a9c5c2c24a7c9250cd6698def3949d6063b455b758d3bea161bc81443973e028fbbbc9b69c95080bc48f2b144568f5091dc0217060ee27637ea380695561741467c7471ac8d83294678504c3a9d7301edf0ca491b6336bb23d646b67c273b8a2ce542a8ac4a87c768673d10279fadef44d870dbe95df25ca815352be752cd9fdac957d267fa8d4c66943bb3e6e1c1f883d1c60c6dcc8b4a566e21c5a407d20cbe717ecae98dc57c396cd3894f102f3f779c1346357e02aa8d2f129f6e9ecd26c7cc44751ee5db41b6886934e78655ec31f23e9f9b388c375b3a058806cccc5de21649f180b147d87d9c50dbcdf67a41da5689da5ad1769b126ad5393b0d2788e42b33d9fff3a924dabbbde29b81e20745cbcca8bb43cf6ebd7e2184bcf4f48ac6fb35f8f62c5ffc4e62c91380038f1d080d8bbb7ca6a8abc64f757692ffbd71c6652eb4be98e2b981c70f191adabf8b3b638b2605193de48c8ecfdc58ca4150675018cb8bada3d06eb6fa983cd7eafe4bd353bc8cc1a581680703050834cbb1e3f2b7d01ae9fdfcd88828860ebe846125cb6cda98128d2a8db85462a96e5c4ad50bd03157b759343c622a9b34a0a7cfe41d5ee197c4c0a456b00452c47ba826f93932c2ebf9517f22e6f5454e7b889ad806cd3eea83c060c41fa1ba8fbf2fc7d336a4f27ccebc97cc27596a4dff87f40ca36284d6127f87fc3c43fcd70c236363c4bd4b26e0dfee129cb7b4304bfda51427d43621ff840ffdaedaaf73f59dfe50677c111c812f72ebf049130fe356b3cfddae7b33a435db8331eeeef98c53dff06da59342e604850246959acdefcedceea1cb93f1da4f147477689c615e2215cdd9cdff279016750164484584551f99bebbb4f8090a5885c5ab889c0589f89dc773fc2744b7413b7acc5ff711b7215705c206891e95c73baa6a8251142a3e38a1a73d9680555e5e129226e3d80a47aecc1efd02d3ab4d1f43faf46b3e99f26d551ec9b0d2c16be918f09b1b848197bf28e7fd506e3e3b4103c860aebd152ed76a974a94367b5c64a739cb66e74401655f97ffe53c9cbaa13b9533fcfb5d90be65ca6ba48af08ba4b29c003aa81d2626aa039ff617249a1f6004256640eaf141d52d7729aeff93ea16a0d1f98181f4b2c4a1ab8007b3747b80451ce485b65d42393441444ae0848650d3987288f6dfa469a12a3d759f6f6e4ab74ef79bf169d8934c56fff8e90357d64510c0f5af64a07af8b47b96b61d72f0a828052ea6c0ae066813fcde57d0b096d45ff0c97f5fcc40ea39b083e2318f904d49421a2d7214a0d6ea38251ab4dcedf9f6233f76face3fadc0c0a8429d3b88e711583b55f0355738a12edf639defd6b4e5d39ce4bb8edda99a114a87bc0ccfa7e2aa914f23b572f61e0e612eb4311fd2b10655421dedc25334782e59628bc8fc0d424a096c52facf6745a9cc6f196ae4b140adc381b1230de10ac0f460559066b7a95e0be8af712a8ca44952dfb4ae23ca39d46f1dcfaf0c37d11596db62143595e49cd5247deb8b44d82f51c16e8e4c7a739fb02b176bbfa26689690a4f426d1e4da369b3748b9f835ac87d2724bfa24076f2fd7e48eb5f7ea4272f4c64acca81d0a6999c101c6f9230a75796734745c03fdd6fe9140c6819a5d39dd11c0a40285c7a6232579575cdd9da01b1727627d97392404e1621e3ba95451c46d84b7e6f5aab457979be05baa8a8d7bd800210ce84cbd503275c1645792f6896b308f92b805b2c4e07b28d43247b54c8fcdd725431a8930dc9270ba1ba5c6cd6c2d754ce2a94f18b292972dd96a9acb29fcf5501879a7a26d10ffbb67d8c725776621add06347efefa692be188f8c170beda3f5457cf04f98fbe48a3fad497535318bb3ad7ef4a51dffbbf2df090b042653546d332057827c6da32b53b080e063757be0e7eba90da0b1ce1469a0f0006836836f48843c25fb8ad3cf9f25edcb8b3039ff3ccda49893f5bd95736e30ba7b619e0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
