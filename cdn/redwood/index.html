<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"268612b73a296583b203bdbd07b6ed48e2f5a25c62aa90754ceaa41f0cc2c6925cad7b66b70c8bd5beebb68c4a952288a0378c43ef3cc175fa8f5aac5f25354a6968e33a1f77d3bfc0654fc8497025aebe9a8c181191707c166908d9cd2388e802fcee6dede60565c91864ff328fb594b3d1c2e756b4be3246e60e9f686f7f621eb52217b101b675bb680e569c6a057c3d629b89451346b87e2248cf6629a86439e1b34afbb941681b4c69097b61f07c2f091b29cf9a2e25d30977ea359f98752e582da36661cc2a0bb61edd13bb445e3aa559dc6908f42ffa0067b08bccbdabc98c346685a493b040232b58051755e8fa0c01bb5e3a505d04491c69d139fe562b028a5f6f322b1f30aa551328bfda40ce52613f30f8717e4370066a787a4529de165946066462738b49102cdbcd5dfa24c2e391c69963c160ee57fc9bd8342b2a0d480a8dfa411f6375616492ea7ac9811d7528d843d01b49d97f63c7693fe9b91a97d5d3588e40effb66910379ef82b770b4a447a139f19168f553ee3849a24bfc8263a44526246369c0764375ae44fe4024c8622e4f7f6868527fa6de1990932887d0e708f9e99c2e68350e69ec37be798d514ebfe1371e0fe11fb0bde35f252295face17e029ce648b9bcff845a73ccc49733aa13244fa5a9890cbc28f9b8f4694d09c942ff44cfa53287a739d4d5f7f37bd1c6b3eb4c44d1786113b8bec664a2fea2bed8075057416fb73a1af28c277cef195bc7178c3a120db7fdd0f694d2038726d7a3c29f09d0fc315da2c34e7d29acfd974ff5fe70462ec37854da82bd81d613d2a64f124c565bb94d883a6175a11bb51b6e2d62360e0b6af9f4a2ae2944ad3aaf0f2e05b03d139be9122b8efed525b8b35f5f0026d28fe906df4ff1967888558954cde2c5ade784a64dae7269fcd9fffcc66d262e9763de5db30fab299f65110cddeb0a520a1381f5fae62810b3a16bd40e219cf18dc6bfb4b4a73a388d2ba7edbe91582901fd023ff81cf4128f1e0b0a510abdb6a594bca7dd5605392b893ab54057951a7868ca2f872a6b84f87e1f449653155d5f770efabd27ba69aa3206fbd17eb000acc1329d96a3e7a868d1ba579bdfba6b330f9625fce213e25f123e6beb90f7f1817b7528057102fed050b220bf5fb4594be9b1f360b00e89d4be86359867ccc549c21494071c7bb787e1fd191f25ea1857a1ebd1dbf2c4431e44938dde2efcd669d99177290881efdd46959a94ed0562c195f791e23a444aa723f3e78497d370acdf324539fa7dcea11bbf979711642434ce04431540a32ce7ce5cf041d05032c3f4443587c61eb5b67dc612c94d6be68590b950187f3d3bc8cafea1e1ca469d6e63c581e9b0b8c674af5147d5ee6ef4c2c95acd39243480f52e4ab999d8d01f97f6dea5f61d1cb0062862b7e672e62877d6ad793eb0cab334f2db25c943deb363b1045a25d2559049e0543418ecad52d7bf4673485676ffe75cc390d0ba06b7d5bfff8eefb7c6b2e4f9bb103e8b89493871def1264dfbecc989baae4e133612856160270d0b8213c6da4a2fd9b0b8c5f61632ecdbfa899fa95127088a2835ca38c7115c857d0c7b5ce3e962873d5b50744487f122aa99e66b7df26f5f20a413caa5dc7c0ef0072691278a5c463efc25677906a6d9cb26b1508b71dbe1eaafd0e01a2e0e2b3f57bda3e6aa60c1c2df44934d2bf3b8c33543d0632085004bfb41f61bd69b79c152a723cfb92e98e50c9ac9fd100d85df618a6da9743a5bd09183cb63e9d9f99d4c36fe5754f1e76a2da796d015ec3cbb141e163ec5c59b8e6c20570afeb5b197760da30607206a300d26b49524ab6d7f295bbaad46831d6561ca262780fa457caa4294dea37271e6498d425a641027feb9d530a98bbca2aa69cd0255c8b237212e230e47b4fd0fbcc2fa9cc25162e57d54e8e2e558f9cc6e813650e38b14fca72f8462a270d53242d1cb22f3d9f846dd4842ac81dad09907fd229dfa4abcc688ac5bf9bd507425ec2bbd201643e8a50e78c32c48cc389b64b489228c466436a5925488329afb9dd61d3c950e89b1b668498b4c66c78b1a2297acd8857353b89b51818d649b21dbd0a79b57a40e371d46e5ff9f778ccd94ab8cae2cc60a6976fcac30bde1bd6b5d630ecf766f5d723978b54fa009c919e81c60dcf5443a4a3bc619d927ac3afc7a4948d1bc0e324a2d94cd391de5156f9b1830064afa0060e48d5426ddecbdb89fcc94706fc39be9d83db3f87974834b50a5e2f04b1ac03dbccd1ea8c9f5aeb26c93e617958c16cc1d16acd293e7877ea47b92845121ae1075382bda55e588a286a1d539d91dc2fbdb1dae1564a92e7711d9626003334b273cf15201053f57311cd165f6783852add633c0626f39f73878c4a00e57c6c32a3ec91dcd82161e0f8373f0784202f540810589d19c4bb986f48168b7f2fecebccadc53aab9d7a5ac5a10b997ba0b09d8427799347ceb21f2621df6a1f789183a3b46bfa5874274985a54db8fa7f4c62973bd2b6f452bf94215993ed6125ff089fbdf70c2d0a2af1c4505f070608fbfafb56d84d5a96cf4d93ed8fd5a7ee670e9d08eaa5927070a30127786b055935f044f28604f7e1ea5db7f5025ed91538be0dc811032a7ee117a57b71c9bf8ed3ce85bde39c5753ad015024bdd75457eba984e987b2fae2cf86739c32610a3fafd966d4fab168cb621492c1b90918651484c874be2c29e58a34f678cf811419c1ef7fa0f2388e0dc1257116ac5e3b4c15e090a1033f82549c90bb5d40b0645f8052b13f7c5bc7f88b770631cc522b7f0bf579beffce69fe733eda17d616d65d36fccc0be06412b0aabd90cd83738c259fb2c07b205c2384a4cc63c3364967e85de37722cfa9df20fe8023d377f53aa93ba5d080c908e70c80b55980f7cf05230cf550b851f613d1c9b1c2bec8cfa68aa7612baa61df9d9ba3071874ccd0003b9768abbf0b59ec51ec04ccdfcf849e61962a0d22e14a1f6d6a59d03fab3b5068335219ed19fb6985b74eb7eb9e5be6ee32702c6fddef84366dde7544154d001060130bed879f9cef4a94187d1b029ee1023127e2f06f56155a8cd08aa41dd3abafce6713fc719a84095af28bddfbcc1df93d08b8b2ed8b7e4ccb2d37ecafc6e35b69f27ba332acc7fa5d8c25a6db72dbaf0301e26774154c5f69b08c2de18f23b1e21a75fe7a62205ef8165e5f56f3bfbcd0a141b680bf7a0411f489dafedd2702ab95a111fd76e59497df728475ecf9918577270bd02df09fcde2ab495b3dd0d8cf4c11f2525d5d7b86464951b340465887221c14c7c8625e86ea7f0c4bcc5ff0af904f0ee25e3d2d1c4d0a7dccab5a65a0a469ef290a22896000bf98d366ef6d63c3b832a0364238b7fa83532fa07decf4bc13c2f3a3eccf34411f6679ab28cd02a8d1c52e33b478683d04e8de4655579dd0f9b737bc6961163e3689db1cffa8e6038ce4fca24e0f6fa63f8d00401c6198e180a0825554733adbd34780ad9320b80ef893c2a692f853f51f33ed075dca75f27865abf42fa815778f38b909c713600dd2d386055ba84943463960304469ce533f9fe77f9d5631a5df2669873f041ad4b863ea95d42d27cc89dc09109b4a8fb3468d740ac84d992c994457aa46a8f7409ba36c84d587d66ebb4c2f881bee313db02ebdc9644649f2a03df694d4789d1f0c204366f433f1a650f9682d1b6a6fcbda1cbbfe7a6b6274e8c077ca580fb04591bc354256a4a8bfc37e18e370769f42aa4da329cca9730ea1287b8e786481daaffaabcda073e87b5df042a7d3139770260b53c44f6ba89beb49e28c134c24f3a87acd1e8820f03ab58433b8271f3626911084e90f15800d15ec3093b2703aad3f284cec8bf65ba5088456c685258e61563c24a0db0c34004e871a25bd3458c336e4f040ca2adfd9ae122ea4c0497a839f73ca94da21b28197fe44c5cbf4806c0faac7b08dd87e24525e80b4422dbe81b7696b489d2533227c9b7e5c94e4d2143ff36b43349183114cf084bdec427cf20cae177a3b105b86b68306688cb7adbc31e8609c8d592acf4e3919953e4bb5e4d3e597739a21cdeee3d73758d3eb50d4bb81a3758e2499385e240e044130373dc39cf8ee68909496ba1e3b68b6fcdb8049ae57189bf927885014633b2646bbf33362ac77f5acb3428a7fd0086ddb9c9886f1c16b655bbc30258c326f9c76aa9cdbeb953942badadc400e8fcd55be85da80b7d4da7e18621eef61a505cb4f5166c9e47d17bc167a527a8a3587875ca0a14f62f37f49fb9a9f55804cdc0eb2b6e090be2451cceb04eddde03898b9574c3dc7a7985de47474f3718b859d23d7837fa7f329f1ec981792805719d29a98e831f9191cd83604d4b231f556fac789db1afdcba6382bd443d2279d303ddec67c552498b1539cc25f7d54e1b80ba820f0bbce93319ef68f259fcd49a5501b0baee976086b28a1594e4f36cfc307de036da16a28e3e5cce5098e4040f5fb7a1ad32ded594c30608b1d161f7352e495607eba5aeb497a18d8418d271fddbba01bdd6a685b6c39153907235ad7b8749d08457edf4ecdd1f1c545a80a75500a0551c8da7fa5d3e2a9d3a59c84e046e9bca0b51e4ce94bd939759bface3560bbc58b47a7fafe86f2585d1c75d078626c730eca10ed087b51f6748b41b8a15781959c004dbedd9884a948fed8dfaaefd657d275c0a8946fe3ad3443edb1041b95e5b82f94ff269003031ea7e76c22c13c40fb8906ede15537967ef1385439397e014e9df03be96afc0d62489fbdb7bcbb775426379ba6e24b26dd47cc59d0c77042f65c24c3da34431953529f78e5ffabd3177482df874a3347021bdf3a7ba04d829fbee990475a7f4e19b524a96b9f7fd0cedcc99ce47dae30ff2c4b099e1a5c62be1390b6a0e476c79618d58ba42d995599adef7f1dea044be93651e3447bbd6651b86b9515a87f6a028edf62f6aae776591cd761b5f067134232394068ba446388377bbca83d4f9c71ecd29746b8931014f598362d83d9c8ec12c9e28385ef03ef135f320b61077099e4a0cb01e5de7aed8c3bb60fe2dff06fbb030dd7d389a3531ed43603f1fb50faba5eb0928e21462e41fa96b442742d9bf183c3fad7fbdc2353fa17add76d5acae95eba662618adf665a2950bad5353536b22a9c882324bf35519089fe8ebd6f2fc8d4d90585ad8ed2dcedf78d28b67820ed3b0be6d9d59bf2aaa29a69a05ac969d6fdef61e70d3bded71381d4fb5e9ba0c208313d7e3908a08cb819557a5d986c9697e531cd01d7cbc440e7100a57a034141702a2617df45c6d00f4d17ac653cffdc7b56839b14c778fa9333db97aed21d72af415135f08736f32fb0762dbc79beea58406bb5befd7160f182e36bd8469d5b852ae6b62d457ea0e99d9d0a8589db2c2cb2de49c245e1625de41ee5b50e4d3567f241610b25a2686be8f757faf9dae9b018c63104ccbecdb2f96f9733b89558ead461137c6dad789b981d3eb79d984e1a1ecfda145ffd019d63c4761fc4817d75ec4735c20a06ecf4477f0feee50a6851733187ccd6547bb02980302c5a1d2123332b9e17a295309ff3631e41a70d27d103f5c6624ba1b6535742536ec47cb45d576ba0aeb956ec1131e791f9c20bc9b9310d0cbb5d8d3be78385a84d45eaeeac67ae522dad2f91effef25da24fc81883a540cd1efc959d492731ccce18493242e94ad2d3c30dff12280e72d6977122413f902a7fb7177520dd1eee6cc4f705b6355a395e36a7d63e78b11fbdaef041813077bbfc301baf3e5c14352d12f214c97f39b7baaccca101ab1ba496c007ba40ba067b2046d98595b34a27060d89483e46f14ed8c96928cc5c51eec802be300d9936d0bb0d2421597e4126e8b9176c906f91a32b4243c02282715ec235e18f2a5923f0cf07124a723d204a5ba2d086466702ad93f7fe563cbe0b4ce53d0a5600136983dd4ebfa2a8e9ddced52046c1678e5d7810b24f8ce31172da89e7c6a75fa3c436c417b398b6a1813a3fa890c4c6ff4f622b46e5d002be03b7b6633454f1076680068db92059c6976498c1296d4b6fdae5692cee83368775ad84996dcb2b111b592cb990ffeefe34376fe77bb86858cb201f8d45964f4399d7cad80eadc5e5048b1385298ef8ed0cde952c76acf238fdf9eccd24e8d3ccd99dc64186e76846eba2a773db70ecd63eb6775b52e7f359b8401bce5bf20763bba8436db633835d066ffb273df7b7a66cbf56ee93916de59483e60f02c1904badbf3110d10561b3d3a9bd8dff8184dfe2e7dac05f9c48d002511b5eb9634b9ba18738028357efaf6f727c77019795b25bfe9331bdd56810048984c52b7e275b626ba750cd60a3a687eaffc92fbbdfd6750f0389b0b5430c8d45db0745b482058800b29e3ac18dd26598f7d6d13688f0ae59f549d7970d9d024161002fcc2f595fe2ed9849fcf94aee1f2edc67e84ac592f389c5e824fa95271a819643ffd02b9fd9260d3a71f439dfeb5b56982da964eece475884fdead4269de2176e8ef00d62818b13a38fe72b8f76d7f4e7bf850601e8aa661a3146a8103f28877e6b2803c0a8773eb4f76ada07f48d8ad331eac6886dbe6e000393ce84d4fc62956b5e5c02492f142487a2734f69f094e9253cf7511f7e9eebf6ab3f0afdc711049e5dd53814e2fb33accc5ead97d3632808fd55dc2d42a57d721843e9c729241ad6f7113134be9b0546a710ffef4d1d3d45f45ad9c8e7d83d45fbd2fef62ce2583522c398a1b91020e28af58da8f4645e04f5762dae94776e88bb80484bdf1ea36d2ab6555a9b2be514c4d01de26d9d7838dc2d562ac74ce99d4baeebbede2563ebd75a03dd116c302d6ce40036fe0aada13ece36c3c53be178fc18268a91fe23ee71fe9e76a6c0a5d63e02d87f9168e1cb7310569e209da934085bf3ff36f9c71a5ce02235a95fde0a1cf03bbf4de5ed5392faf90e5acb7a96641b60458a2a05622eba4e462a73162b4b0b68a191961a50fbe316c698d21fc9a730af0c90584b4da99d6ceab83add382bb2d99910b54fbe565e0b9c3de2867acec3e7113b92b9591e1c7a5353a9ef96f89fb9631276ac96f8a66ab3864ff7c305b515ae0d3743fdf3c3d2d3b2dba557a43ae2090d3dabd7890c4234d7fe0de2b7b5a87a253454a494122c8ff59fece4d46a17628f62efdacf10fb5e11e40de8c25a757c744ffa87c349cd292ce6df04a531446a8d5b55203e4524767ed81197c9f30caaa3fc0e5ee9a62f60879d583249953c488e4fbdd331702d6de43d24f9211cd576979bd849ba1df3c1c6d2e20ab9eb7acb482a45d6756eb75321f0274bf2c8744123d26fafc2cf17c38e05625fdcb5ae59a0669b0dbc69fdb35854e876afa8f68bac4e7bc26e60f2f7b6336e8278ddf20aae1d48d04f9201f4cf462218aa2b3a0403179f8a42774c4b5b221a5635f088531e1fa5fa9bdc67e74d7eccef5d94885445c4c1a3fad6099fbec40c0f61691c5684e46aba0acacc763178de8b53ae11f0223737cade455ec586454058f626ca7334a79482cce07ee5990abd0c2f1cac99592eb9244e784a42fc86dfe420294a9b6cbb4e2eaadc8fcc701dcba15a66a21636899fd5f3386ebf6d5b67c15c42c5506e4b3c68cdecf0e937c0dde4d693202c182416b3bcf2f7e949e23163ce48cb4ae9b201f1d8582047c99d5beb9807c0d155425da0c5797a216dc743f7f25080b799256e71d390d7cddcf93e1b3bae207943d78385d038a6cda2d227b5c09b6622c5732837e0dbde065ad4fc8397b9ae5dae76f89c66af2c9aaf79ad209346bfc3883fde37cd829610508b7fd7d010bf9885be97c637a4ed8e60968d62306bb1d1423757522d57fa4517e328425b4b1b76c48c5352ec9993ae04923874a9d97e26c76fe3ecdf2c44e459c12c0efc5d0c2cf50f2622fb9f86a75cda6169c66fe8c53666285896ded01d7742d8721da08b61490ef6993a28ee13fa91c4a4bfe8c269866f4b6062c69532deee9deabcf43275af78bb55b51d9e7e4c9347c269fb9a65b0b5292909699b12e08d11f279701d1187010a473a39cd11557177679aa4d662d82d16ee777cb0f577299a8a05ce5498fd309132e2fa22d52aa0893e867a94425ab236fc3f41f4e3948acc2320546b19b007999686e2a4d54df7870d3c7d5a5903148ced984939f68c9d05cc2f586ac34adf17bf2cb6ad22ae2587549497c1193055a1e9f5daceebc04e60dd28a3ac04650e12db7eca0a56a0b0308e37dd0ff5f26a7ca544b24f47ac9bfefa7f3463401fd27f7226f4af627027d7017aca136731ff4d84f6cb332994a2bb853eebc29f8dacd68317923f97c85d244d5d11b5f0b22fbb7c2d2a566828c9a605a7344e7fc91e7ff8371323ba255f697550a28e5ff595c5181153fc0d7da3f087dbcd720d8b39d2ff2f61e8b7a34521b9f30735f320168087ad44ad36943e526105288e615b412f14d5c9468261a709893fe374d4c89e0633e453dcbb94a99517fafd3e870ae0a4f2531bb0385946ba90d8aa94e99417a0b8d5e23a60b20927a70eaae9a3e394a0925020e6d3b7bc6198d29a6b23ad2ea1297cfb43b6c42109cd12227527d04effb61dbc029f4b28bbbdb44b07e0acce21bf691b47f746e309f1c1ed30d10c8c69e8e7456995e8ab0badca68850a4f0cc707e5d22861ee737580899892201e9824968893b31b62bd1cd5ea756451f73be6ff616e9e027ae99aad3363a16345b277585f05f3929dd29b3f2f58ab795b8edcfd1592d804a87f1a8a54bb6b487617ec4bb83c48103c03035f379b48c02a97de4b79f53478998b9cf338b7a4a825c9207d6790aff97072681c4e7e24afe82bf5ba57f91e9cb9359d38149efb05af496e3dcf6c5ed62c73e01cb8a0e328cf7013f1f0f14477f28bf8ac7ff762a5c152975ce0ccba1c4b5b4ca977fd26e6c9be5b9c97338a0cdfee0aef27eefadc1fdae1ab30d6bb9e686a2142215dc33b56f69372bf56aae21e306543c7b19b85698df77a1e8247ca969a3c0bc17ce6a2b4c8450cc413bb883a161778a24261aac61b4ea1c2457e79bbf82acc1f91839a1f56a8f005795e63a3faa405e4e7b379c40ab09eeb29bfd72153ff62072d7bc9728dbf5bcab26206e391a02859eeff6a2ee94867f2ab9b88647c7702d69919cd9c75aaad262bd76fab66f1ebd7171122988098fb92e4625f69fe1b0450f2f0682e3a7da6b5e9743f28a8483e41731cc1b9b701587da992210bc1a13fc385c199f926f681a36f0fcfd028a5be90fbefa580afa035733af24777ba0e57ea805ab30c5f4876e53090dde478cbf03bed92c53b671b62898d196aca4706f813c982049326d634dd6bb3f8935af4b34e97540d816d9fadadd003885d66ced880a9fcc39b74a9e2d6d3ec93d7887c7df939bb1e3034b6aa0335d354ca51c8495743deee17d22982a011d50fd4716875e6f4e4406bbe8f556e9818ad6b1eb29a0021b42be310420faa44a9f2a6d955859cc577fc70583c1d6f59eca9d734896fe1fb77d49bf3eb6d5f430e734b3a6da0dc7d9a77156f81a060800b5ed887ed087cf4f454ef6709bc9bbd5135dc27ef6b89eeb16a887ff57eab47b9fc733c8c7681384adaee76cbb6e9700c83a07bec08a3f9c9f0331adfb9cf868d3ae51f52fb43f826457aab177c1b9db4b91266b4489b10e9d4d003457397a95970c2b7bc3e1047ccced393acc4e44190cddfd5a38d6de60208ca783bd2174f36f03cccd52746c96587763ac58cc2a296f83eb300152e040422ce499346ef906926f80ee6ac567c91422c9006bd1cebbb7e79d12cfa94b8cf25d78eade4e61412341c142927159255d68c3a24cfa928966f5e3d888a8edac85b88f50a885a4d8d0cd71f8f3c0177079854efac95a4108cac15031e05e4499c8b3e1122ee10f0bf7ba395e85c47b075a0eecf4176739f05f2b437bf2589bb503acdf512fe4ba6bfcdae5cd2a46bb4ed6e39d6eebc3f24bd400b9274c6fdf4f0d7bbfe54b0b4539eeb21ca4a4ce34db41c023fda4501a50add282930958efcd68847577c7dff17b621380e5f8cbd72ee0a50957485c3876d55fdca64ecedd136aeecdef9f5d447fcff3ed6f69e92cfd856bab2f9e1f76fde72ccf284456c94332a95e93549c47d42f1ee0096145d929f9c4f030882c74318c7af5b52a368ff5f107616629da88edf6e722df2bb64cb8b4087b81286d508aa2759daf8670eaa80a7ebe91b0564b15c1e5d71f86b6828eded9681a6f49c059bbf05bd003f73d0b67589853a477b9751388cf8617ae499c2be7f78d40aaa2dabf755068729e9cee80639ab43ff44613a2aa7f3b766a36fd3bd8496aceee953e82f42f1ab39789b96c46339858393058030914ff039321031dcf2bf2440e106690b39f2d43065dcbb053c5004580c1a47b574de5a1a9d8aa015a8c4de41266c158b56752f4dda16a4c48e9f50e4f825963500c75b410f126caf11d6505feabe0683b3a976edfab14884849ea4872e501ebf1eb718857ef5d4fcb67ce204b043b16a194401dc0f91f73b757ff1a2f965e0433c612358ab73a3d45af9281b8191192f1f57272f41a46d7a514202aa6704d12746694d347a99ae8051bf81a4343b0b4dc8cffa4ca70163b2c159491f86884a40aaae5a17a4e07d8ff8f248d373f1166b65e5292982c1e8995a0f12906c0aa2411d7953a634a20db67d6db4e7fffa3df52c785f84e84b2ea031f282333f659133c09fe782858942fba95db3aca8607542c50fcb29d54ca4397693beaa34c25eae22b605fa6fae53b398633eada90d60bbf4b2e0cd1a7464e3723863532f6ebbf93ff9a14d927d6ed2f8b8bfc426dd6286c1f0005ea9f486b188ef2990acc60ebd537e546164428be5b31e0c2eda9f49aa765fd91b7d94021a6d0c5fb0ef146550d068180e9378117382880396693d594e09f5f2b840ea05d2abe2bb2f806f21b40445d8254cfde8a1993c709e3bdbef134591e5f10c9fa707353e1198b9e67945f5d42dfc63c6f48fab135aa3900702e824591426001762af95d22e710fc7424b1aeb274e0291207529fff5cb66ff6c99fbf9527963ab2d3de07b76551b36eef81b0267b1f654ce58c41218a3ad47a8893135e961be9ff422a9ab583a986989a45721fbd51ad9d2ab443c8570778db2d2b3015bd5bbb77ad63c743fffc1deca9c858c6d2818d459328f3d5dd7907a8c824405dfc7f83f09014d6e07d54ae5b52a7b98511d6c392a3ffaafe1240d64d5281ec20ca691d937c45562a1772f330a86d8255a7e074251d589a71598d6a0cc4b8c94dcc32677aa0512b147ac05bdc362254f4ef09c8da68c7766c52b425f78d44d525ed721f4fa4aa4a319c69387c0f774329e20829405ac4e347959ffcb4bf82a2a7e74f25c19cc2da2b3a1aa2dbf868957d3f92695de0ac144e6fc97d7b77ab3c22625d9513b1da0759ddceae243c46b22fa4b9a2919e38cc6c2f24d50bac2f03c756294cb2c7490dafde43b91b38dc95f5c1483bc1c32b2e42cdfeeecaa99a3a70937419a7add92ff5b13787484d147382c0cbf83737163a01f1dad3f262dcc404182ab5420e53e82ed365cb592f091431ffa0ba0976a41d9d1e72fe3b4d5fe4ab74fa50b096e9c48ad1fe13e98e7e607133955123ef2b4a487fecca4d6dae8bc2499a1c4ee9de7373ed3ba9c8e57fbf0fce31007344286fd015fd2c34a2f3093611dff22f7c77bf124252cf8c54daf167db9127c7ad072fe4ebabfcc1f2b73d240a7d7651cb05685294f2f27d1c7ed24784eb73d0231f88d0ea2c36107819ad9f9426c42957f636736df29a9af7109ca8a842f78ca97fc7d4ded8c16ae11d841586e2d959d1fe042942d5219bcc2e30b2698dab1b1343e5ee6984c72f660d7b89d07e0b575aa8206de3eb5e8491a4a5b2aa52118181e00b1caf6ba9650d2d7997d046506b3411ccaec99c782a2085b181c288ee1bd291da8702fce3242cbd54d2030833b8a5722d41e682bf70afecc52c6f944eca956f4cbe3801e83fe766520dbeb6ca475b78cb570f8bcfc420d7428b73535d3a31151c0955cf83d020f612ed1ea26677c309ea8b09c9d0522dd2644c5b7de4448a35aa28cbed3906707dab656d86d5ad5d144dcbc9e3ced90aeda0a28e81bc5adce2d759089e01846c9dd171905be160663b9b2f743502a2a75025d814184ea0bcb7c94e6b4a9cf66417d438ef20066c11cd737a64737237ecc52cc34aecbcf8020e61e98238cfb38ec00e99ff20c0191c3b198247a952d7f8e2c53f0208656710588fb72db440305dee5afdb6c145ca2a08583ed56e315cd07728c3b99b29ea207d277149f4ef178b1da4f4a920a9bfb74e0c3231a7bcf1d24087588cc1433dfc19808b282f44920e569089dbd9cd1f153dbe50ef5b3c8771edcea4eccf84ce1a39f658be8121f4694bcc8b22321bbfc760f8642a91895aab78299668fae5b1f9aaa3852796cff2cebb1120aacb58e8930a70ae229f6675597b56335e93a6fd76cdfd1ad11bf7c8af6f8bf8a6ff0db9b360ce259d85d56b2aacf1e66ee40a5a66ffdead7787387e9031e3132131fcb86f669ee713baf84c7302bd0a4a9fb39c5943951e74c0f7c90e0849cae5ea3d1874ff8e19fdcf045304e57726a476d41a9eed9c1a64a143667c53512a7c6ab8f2c6898835a6f3bc0d8ad81fe208ebc5b41c77c24505cd1a39d0b45e1a142c18974981fab982bcbe193523a57b1049b1c33ed12e51f5bb689cbc28ac2ec98a976ccc7362e55d908af9b6ea2ca90551c27bcf5ef84ac539d9fe6f709ca147a7893aa903e20017c19be02b3b60bebcb38f4b1d0745aa67ff3deb4c8411b10418f8145da1910ea48615b5a2f7541ad1b488c1305dfa2805659c9f4363c6478d34069d6331a9d3b69acec5d6397daf7b644138f82c55cc60a08c074deb29222435b20bfb0f677b63348450b461294ebda7573ca892d6e5ac16af80c97259c0ab8b2c59c4150c139d97046ba4f8435e6ff4d73474d0517b420adc82491216060cbd601294016f508b22f017a76102e75d4c7f63ad669afe1ecf2e41f18b0623d003198dc0245dc09f5bef0c2d65b10c2c5901694e46fcfd26561468b9153a0bcf77c682a86892287105bf583e4652e173ae25b600cbabc6984649be930b1dcc0b1e2f0b53adc794c20ce21cb4fac1e3ca183f29d5e0ec98ffc81b57d34987041e4f2fba7144e62d788df1d7d13468e0694943d6b517ddb48886cfc0698af72397c819348c1deae6ea405af97673a8edc912d3b7a747c8504125e9159d9a456c6ff56763bfd7e2a8121c380ec0c8c790b00c651a5a66a7856c23435092ec2736ac12303febab64c9a46689a6bdeb2a90a55f752bcce270c60bb47e8980c92e9b7b9fc13bbf89bcd05a76523d059a48f8f1923741f19d7ab97c4d5c24f06e8093c76e6b730651fdb2a2adb4e855dda7f01506dce89f571e7225abd155c3f9f31999d87481df03530af5c72b3bdb6be6ab296411b95e702f18e43f0a44a7de506bbd9018feaadde4d167c5bd471ffe8b5f66e1b5b2162ecb78888723f0929fcc98094e53a50a1a31a8b6fe87cb0bfc195d8f383f468c5bbd3ba014ad540ef962e7efe7c694028a40bd8fe2f359c8cedf9abfa748e8a8b544ea0f242a932d6ec862c9a0c78da47b332e1bda4c57c9283795d3c3398cda7bb47b714cd04f41c523ff95a4bc9451c7039dd73097dd5c2a6045136386101233713259061c5e2b2938e31e4418f7d7b8e0c783ba51284b3bc749757d474e1b2541ea5a85e632de9c869360de49143d6372848a40310e4d085c7ce1d1dc73c790df133d2497fcce2edf7cbf84ea41ac64ba845823fe09822e592915929471a20fcec2280c16f79050a63b2bd6fcfbd8f68b7c481b4c8e568e8344e5947ff00d8916930e054e4c10b97ce5e453d23f401a803dc5e7f22d7ef88202bcc33a402fdaaaa4c4d93c4e1b841446ae2ddc3f45ff8b439c2f3eeb75d50bfe300b59e5742ced9f9313f4b375d7ca13f330d1d00a23915212120c807cc0f9740daa280311a65907b05e53ee35a4ab8e1fb2c6cad5ae396e3994c47ea4a25414a72dcc26a988ff37b5e0d58720b02165c6596a1d39f65b7f5fa255bacee4bf69dd4bd1e21c10f1e5fc37528a0dbe875af8f9dc2069bb032a14d41db9b6398a198ce8c6acee05306f0739f459ca7b5b747a0b6f45f372e618301d7363ef70213886a538b31c548b9a8519c8371fc4b594369877da42481a1813f8a57baa650cd96897618156672ca9002f120e117accbbd66fea751c1e306c13610467d3d1ebb7cbf764fc2216b6dd7a016c4edb57ebf78c2452bcd3206acb3390a9eb4ce616f6c7d5f9b8f2eea344b03ce514e984d77bd0de6dc5617361e6292ecc16bf49a660e9811f1f76348f293f336c72d73b0d8452ead246c260c9537600d33e518ba761ae67e170a320543b27ab479d164babd716fa7582e7d51a18020378f5f213152db46c0c0069409bb15f2be71a30de0680ed576fb40ddd70612dbbcec69dfe425f5ae8cc4896d06a924d1bbb19305954341c8ae796094bd779d8194e107120008ef6bea266f148846b2ae89ea412840157bba5f8cac83f95af69a7c08ae7565fd4fade61f0371ca64ba31e526d69d1bb3d1b97d4b407ca07e126007af943175a9c1b9a3b4eb6610a2975af5ac31242c4ae70be611c37d9a069d82eeff3c5c7962cb6d3e938529414687be6d8e90f2706e246e06e2e4e306827247255ed6dfbb9daf3cf4b8a467a98cd522f1d48ef1e33a02c7b6b7b7ef2962a94ba0372afa9d6320a4a2c94d06f602e215abb7ba6cfb2b134dbafa2105d0d7cff55ff336e04be4531c5d0313c8f472f58cad3d43cd87491c37e87bf0b14bc3d2a42dd91fdbcf0f75eb6a75be5224cacbe654954cf710f62b88fc36c852c4fd35b49efb93da48a01a68e6430e1f23963af185614a76508bd8b2e2785d76d7986eb2ef724a33364a86bc01694c579d482a453829eaa64e3d24733e69185595e446351eea5ea8d7aa88fffaee2edfbb9f6a512213ed8556e2cbdd1dc2dbca3fb6c018b84c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
