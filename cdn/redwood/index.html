<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"00a132935a6aaea5a803ffa9c16ba98a9694aa8e4905d1584e46730bb937ef91aae2946c52a15686fd6e0c9cfc9fb9dfcb23d0af1c19d5120e4a4d8404404e7d61ae5b62f10134c4c4e1761d99ad6d41119f3f56866a34a300ee38529ea44b23179766ce0d2d1ee6ec76c0c06a7d13ef4fa6f321eb02baf983141635528fd744f3e080ade8001eb3be88194cbfd6b3ce59fc5b1ab87342c225e4101c2bb78e30f8513d0db73d590bb704ee791b74438dc96ac184787e52050db48235ef106b086ddb058e712d0182333cca0555ba3c61ad10a9dfe98260cb98ceb588577b1eb9f3d4a28ed463603d36b8bd3f671a8f944fc0031a137391722a972f5fc35c0b0d0366bd4adcb273f193b0e5319ef04ad03cb684f54f0da99a745980624a4db50781b5212bf1095330f7384815189f971322b012a36b04359e7d04c0fde08d0e912c9b3f7bcb8eefa25da64a7ed94f4032154c69af3d85261e7107bcd028d47d1d6c9cd23c69c5603a01a5da829f07496d203b36030837b29c506a35fe09f02164dd02ce38b137356f6dd9f69defa832460e819b281e24243df01c41be82cc6dfb7aed7aed465f661a8ded0b15c94a9e720bcd9e2f9cabdfbbbb0293d955dfbd33cfc5831eb9e643af8e6caeb053dde1f08a50fbd6e73e681f54930338b54827dc722e10b767b1cfc64902ea7aabff1f812e98abe463025ed3373a989f03b60b03812ca06be8f75ee8f832b438a8bc5d2114a11624d45b1a3cb7a17494285de950dc1ee80d0eea12a8e71630fbce4e5cb8285b18d5a142c93c8b65a11b6606afaf5c6fe77ff460e3d5a84135091b3a19ee05d788095643cf6da7d509985f491dccabd1aff62293a12288a7508da672f2243431e046a8a326eda11d548f55961ba2eb610824191596ccd122629172ebb10dbb49136a02dc69f33946015507ac744dd5d976e9a50b8d48a3a924b7a6b530fc21af1c8c57adb3c223cad0cb6ee855dc96bc4e26706573f49a2cd6f4e1c26c05d440170022c188ddd8ebaad9049a41fd726eec4ce25df80e14710ab271cb375f2168228dd025f0bb852107d068cc927cfa5776c74547ea63412c4356dde12e795988c8ccf61afe332f28fedb850751ea8861ad545c0aa4fb663326c26787808810ef622c39ea08cbd8245cc604a8516f8fa724919075ea7aaedc4ab736d8f51a70be876be32a7a00807df08fdfaadd129d36c4538567384a598371e62e94583ea55da5075a5eeee804ebec681fbd10feebd88b16b1d9f971ea2f3f8a757ec5af63115a7c861ed12d6791d7c893f91eaea2e216811534a1aee342bf853b5f1322265adb11d6446a61cd73fc0146db1ebaca9dd5b63d1779f0dcc47768b19d35b00f2f4657b6c6759d9d7423cfa60318669674d36ff59544eb72359aaf66b63ebf4127d845470f242544238dfe064cb8a9f65b82389aea65bcf0572fa4690edd92edfc1a60b3b74449893ab840be17a71f753fe6db4e68f01935489ec02cd31e4b24a958b3f1bca11a26eb14f24364fb649dcfeb674c46e699be15a3f26011e09f5ca50e2761d9eebccefa797bc217df1edb4522c5512220dcdd51ad8be65f78fb9f64ad6f7ae9d24429376f025715a675171b04b81e77e203ee9e5b9fcd55177ad5f03d8fd000231a7607c5e8e46b69c5e48cbae917e798958214465f62eba831aea064e08bd021392254455aa381acc28bd58db93d280a67a659f82ed57432b966494c3bf033cef205b541caa1f7c7c3643e195e51a0bb5bb7088946e08b34c4862bfb827457777aa51ab943953f0c38a0217b578de75eed0b34da0dc857f8f9fbcb3ebd63960350c5391939bc8a5fdb1299b90183ba51c2a59be813743ba9da624dcd3cc36f9d22fad42c7bc3f085a63b9e16d2387834540b63c1b2c6f55be29f15174db319a578c9e355ef0df00dceaf72563817b8afff12e206392aaf358f1dcfa4109e3fde546442323e3bf520af42f4dba8feff6399b5c0666dea1058842173c06669eb7742997d87f3743d928a3aceb12a84c1fd2a19b750347de160fe73137881e50ff7b8e8d986d18de18cadd07617ebc656b91c292a3e72747a48292d484ae9a386be91f938f468929b67445226050646219bf0a04d2fbfca19a3e98e25a1176e6762762ccb028621f5d7efab9d91d6958d68459712b15b6c192324f73a8e9f35e7af8fd66a97cd2e80032fcb9154be5beb616e3521d86f46e17b356c4ee62e25fdb9e90c410a23ed6ed3449f4c4fa2a4ff6a342034df360311d48c7c432c938489496a3daa0dfb6976e7dae4c5d70d2e72647ee730c4aab26281f49b8bd09ea5b879cfbe950c203ec925c643ddbada7e62cbbb92cb30a1fea70b1105e56d4f54214b9b0d690658ec69a3d48cab61f24790a6e6ce72f88c195ae36f3d2d0d1f403594aaaa8c830f5a42d2dc0b6f6f4687dad9be28218c60277114de2294a029e4b4cdacbe157053a666ab176c294204cded031a7315f7900bc98da34288516f3b273e394202750f040974312d4654b6d19460acab39a302eb6987ed644f2b93207204a37d5ddd844aaa31d45af7b117d81bbe2c954d3460062561a93ca5f31deb9ff0547e861e7b35d07f4ae330151a6bc91b6697f38708fc9540d21323d65d72cb1ff19a864a7b3a2afab07b97468042c14d322dd0b302215e3fb59952bc328fd8aad180da586e4ec812c81c74cec0654eae5af63bb96acbdecd5afdc8b6715fdc7cb6b22dc220756228518c5c1469037b17460e127c5ef16b0b139d59ff6f504f71f51c0cff1bc55fa8ad1433b08fa3db0c75e41d86b2fa264ef037cd3e15147a0f54b7b4ce5f89672844e80a3b991154bd76dcab845cae939b8fd74fa7dd9b93493940fca6a6f1fad47ac0801ecd335eca4abb120cec41882edbead54bf8215041a8d4c73a9e08f128e09347dd55680b1e4d60261531e0080abe43549d9e9b91ced4184f8b0ccd974b41f8f2e7295f4a7ed04aea4f4b91f9d25710d1ae8e3db7d3a6c18dc8a68bd952aa7534ce1009fb2483bf28dda7b7909574ade786395022e47e12321e9444c5cd89a1c1147ed6643782d198c1c4cb8ee43b40c97941933638e212e88a31d6fb1e7195dd3dc57079b59b5618f500eeb28c1b5daa41ef9d702a9be6fc1a09a5f9a688c9947d8c6bd30a4e7406a8ab9f7c480cfaeac89a4edadc7e38adcab9c18fc917915ed5a6b7a314afd8e2387b70a4740da618077a6bc4ab2da00e2a565896828e5b8652aab8fa4abf14e1694cb1307b98e0c0baf907d5411c067e986d4841c5a5580bfabfdcfc71063e3858363ac7834d36f2a0400a945c665daacb20849f44e47a6173143275dfb0dfbd9da62be9326aac8e0d139d8a6e692cf8a800aec1de11dd2e4ec01e5a898df89c866db25b4178fc36d92172629ac5a51b5331d92220ec4887be245713856623bac03130b2b50221de38fe3f181387c66a2dbe6abbbd71144022f9c4d0f6b373c4122950a5883eeceb62298e421029c3662bca2662004896ce51699a12d75712a4f6e2706e5c3f832468e92766df63ba9a7f7c43f77277fba9f30f57af060b5fccafb17cdc4401e6b9c7a21ec409a4bacdbf94ec00c01f9d614dd0b5725cdfebacb847a5fc3594e3acc7276c2c9f2b4fa780d1bcd5e06668b422e7a5053d4f48be0ae3cb78ba2da5d45922a8e6156b6a61e8988012fa8694014d2c089e50aa034d3baee8bde0773f1d3e78536e5059e67e70ba39543867f7a747faec7487de2895056a62850104e68de51eb899389e343506012a48cad3bef0c0e75edacdd2a97615e99b5f00dbc7617c0f9ce8aeaec643074aebfc067a066cc51ae03b92b6dff536f37ee3c82c20ae7634ec9a0607ffa88ce06cd022e8a38cbdcd5fb0f956134d10b1305aafc9110aec98ed1a11c70d7f38ba56acefadb0089c64ae1754a07e967326c3b3012157ca40baa530a0c72e14a99aa1b78b5d4aa1127a424b5aa938eb8e713e05febc5a972170f92b77b8573cb07b073759da3dc2e65c72f3c13ddb8db32c36cd9048d0aa0a92ac56fe71c67f9d30aa26a97979b9e99c677aef879c131262ac6139a0f697d98a01763ef011788570e3557414e94f881ef6620f5c7040d1d58146a95e3a66b94ff44d38d173a9eb555d5201e17334084513f9779f33e28d10913a4a005ab61e01015bd68921d23f7df92482f84be4d72cc00c948ee68df4f3f7ad0d70df9e86c24c5e1d047b140902c61fa2bab4f249d8b3f3e120934b6667670f087f74bbb52050a920f46328de5bdabe64d4bbf02f2a35cede70a358b107a3c515828c2b01bceaf6fc17897e7744a7cb1030b01aab4e3cff5eecab6b20751bd5a8a005df3430601f93402d39ca763fe6a0fefdc70fa6aefcd88567e102a0d697620fcff3bff035d54a90a276bcb554294e2c3768783603eacdf717970c7b1763f757841ea92d848ce6e8382b778a81a4bf801db92b76ac6c0283f5ced2127add9496ebf7f1b457eb22a9b807c5acdf85481563270d317320afc0a501cfad1c13fee836b3d972a4888b221cf3dac9e8dbfdd96faf07e708bcad9577f193a628288ed58101b750768281daab161c167bb87a7481b2abf718f20d08ece44fd979c635d9b42c3c7c015b743f719f1c90135e6526c68d5a0fec919f870924100ebd42a6c931f7a7526d3548a80ca8823bd705c88b4b3a2934b4fc162b097cba6a2bf1c49dfc4e8fa9b6762c82fc5eb51a632254a4d0efd7069f4ca6fa9c5311d9de10e39fc8a530f42df58896b86459e328c98e4a557d7fdf925921eaa793d392388fcacea6263fe236e0ac95058d9cf9d0e1c6f00019b646b5f9b763bb4d664cfc74c9164103524f8fa136022d46b20e322dcc61d00414532b3761fb80282656f430a712c321f90ef8171c9c0e56d060ad078fe6b03b3e0d2dd55c0ffdf23b71273d7e1c01de963ededaca2656f7d1d982f36e80febc71246492fecd235464a83e9aaea238bfbfab4a0ab3e72524c9ec08d9e08c4b6cefe6895b02a6e8f5b257a0f8abca4dafb693cf602a53efd24e8a2326a8807e9a93cf9a39b59d13d0d0d4abb1d91705020bcdbfb69fae415671873661f278aacc024eed13e221605c4843c38a73a3b154ee4f2bc42079e57f8ca7238e30f23cefa1b0f35e1afc5e9e36c2bfc6ae5a896c513772cae777839e79f6bd142afc9bc64ffa7c6cbacf28c2acc660dee1ca64cfc80f934982758a00e3841352ab0f4a54cf414e87feccb41e201bfa647dba5b5aede2a069abefb9ac9ba28e41726689ce08d71bb9e8acc33d76d2ebc6f245963fd841de9010d3820517c14bc87035c54f847d08c88b8ac8122c6a8eebd2906071005a5b6b68e457fc69ea4e280f29860b2ddd675040fe7b2ee3a9a2982a14a802cdece1b9b357b013b9b2205d658398c519ff2d03bcd23dea3e5937d7d37a331d3853ba4c6dcc7a15d43a56f5b52506ae18e38c5d5f95f8ada3aa7d93cf374731a55cbfcf376cbea05ebc232c0cf5351b0f2f2858092393539e1bcea66e26c554a15caf65962a5518a852379e0121b9f3335dc861e34ec80d6bc0cae9228c4d7f5f5657351207cd634d67eb32f7ac4043e3f57687c497b6424741e8a4983122f35d02ba733a32e440a41617928b73b3d283f4242aadfe5d6da5dd942873338dbd0453b92e0e0ddf05010abe26d763729125a8c2bb12e6e9483c4c93afc13e19ff63cb4c6e6f541f307c1be478f16e9278eda199dfce3c8e840c2a425b0700bbe4fcf7f9a1eef417348d878de89a53b7e2b3e29e51374c20d203bb4a4790374a3cd9cf892f2fd362b74adf6a020c75640c48ba2d6a7e2f2f307853a51c528ae6775dbeab8e5b64c3b1d9dd3463fc5a432daaaba6a0a4151e44159975bb9cdd9a036c61cd9cfc4ca532fff17022f208527c2b0bca647f32f6fd55bfb1c3fcbb002b51e194bd2a540717d11ee1416cc3a4236bbc4d4a80c091011c5440b20e7e9679a1ffe7bf8fae53c51751412203b306749a55f0c812d52c32fe4ff9b14b33d6493e0af6650f83d7890f7c80300f059f81899a8275bc1317d5cb1e31231fbb381e45843b0e7f1b72f82966bd690c4e79b497b4244ea06f382a61463912fa34789364ee412e793f10dd7e11b5bf7750ae4c7e16917db79d1f820d0a7c21061c1639b66199025348feedc1972aa78db550afc10c0218b24d5f0b49642324064e39c9a3a00bb35d7eb4a4f2cb9f8c7d0f0a7f39204379a5bde94c1608ff01a5d6d707920795bc7d7cebca951d8f48b8b5bdf44c532ad4df0d625be2eaeb86fcf8c98387f1fea17f0d7dca7ed5b2a51db37b7a6264a3597e20e510f8b8e3880043c823ed2f57ba1a87f5b05fb83005dda3c24d2c0dd1711e4772bfdec9b3ba6af5f100d60d55b9217451b88c9258719f719e1b7657b2f0c71d8e824f54e2a02dc2d8f0ffedbe4c528b59ad925912edf2fe6f4c779d1363e1df7cb2549813bc5a9ec4f5a5b65951ba4c3372f976eca5ed77e7eccaf184d9ff21480d7d686cf828416ec2b20f12850cb628c2f05ecdc69351979f08f944c2b6b910cc5e4e3feac1a0093bd4f777b6496f305034d2c0661c3a59ec01a51e90d64abdfd04bdd4ed54b4b2105b0223f80ee7aafaeb735cbefb3c17aa2700595fe9fc181c2f2829c158652044a235ce3d4aab8dc4146d3da35d97e9199a69c522a1d95ae26d212000963f405ea1b7f13788a99790c6128a65b9ff0acbe907324297dec660fb6816101dab98b7c1d20e0aea53354ea9f7f42a5bdfc677828549811abc948b6477cc5e95e5c70a6d1b0987043c0619ab2fd14b1fcc617b616019bd76a3ccd0a38e5f093f71abdc71106340036a22323a30b8444ef9c836c4db848beba9c57d764eb7a852d7db542e63734fc1763ad24c67fee7a78887ec59385a07a297bf76b830f5ce5bfc56ea2f271e9fa2ca23f866f15539ecfbe7622f6fd375f41dac101d62b827a7beeeed5531bb82e22a9701cbc342d14ac63b61abf0ff9b90bbc8a501349413d8d4f1c135d9947fa65ee4f24270fff9a73ec965fc00cef99fcdb88db5da2c9541c17496ccc3c6d6a2712902990ed33fcb1a433fcc9dcefa11aa679eb5149ae0efbf05173c11bc2149ada3360760ca7d4423c38f7835e027cdeb6c610eba29e84f92051e2d7394dcf060bfbf1b6d63793d725b0813e463600fa7329749f7c4094b3b710bc8ae8efc9800e0a98276dca5eee9f46f8e042a374d5c5ebaba2e92389b575d470d7817f3a9ddbd54797cdf5bb2c892afc8b38bed74f19cf0d6350769811a51e7b9c84e65e5c71e07f6a18e5c09316f39e3888e8e4b43fb2945a5e69bdf229ac6fda10fa13fc0e15e8d1d37d19b28c35e373d55d89785fca081aa7ddd79d1310cc1b40d2cf10ce5780c66ccd45f6d214798b30547e2175b94aff04de5aaa2739cbaf56f972df827941e90a8e89d9bb7452ca8894ff45b57213ee57eabb29e446e809929d0b799bc66439cae00de3f00eaf30511b5399ec9c41a2ea76617d306017f333cd129d485193714f8a343cb22ab066a96511a444461c1ae70ff7612bed780c2b484be26df03ddda75ff3f388516699bcd11c2e777eeff333174281a0d168f44d6784ba7c7a956b6bd099956e96d88371ca58384d2d3d808dcb6c4b365917cb2805ccd05043e81171a710db87e017d6a365c51ae0240bc429419d95c9e2dd137735b1e9c48c1e76d93d20e6134405eecfee1e720742f961bf79b149caacba364e64a148fa96b43b31d91aa1925454217c47ce0f5413cbec26f19045be9748bc11df75005efe5e31986732501c10c8d1d0728f9f4850cfe849c0b817b04ad02a9edeb3446e17343dedbaec72b84cf345f4abc9f47b781aed1e07a25355c2d046c9b490acddf615c97b88da3f0a280e84a535734212d03da8b82a06229b1c89b43eec8dc7769f8aeeba9521dba02d009cbe6533ca9fc9c5a0b6d84d7c4e7bce563871e3bfce6b0ccf33d0aa13430dea54df0c10d59fc119253f80efb1f390381dd4bc50f879c1d3182d7725fbf14c778b6d5753f45a037598b3587d75651c188e3f99742bdefa3772f75ef172c63987e692f4b3a058f12019541c4d594f00c7642addcb47bb9de8f33fa43dd31068d320b761159758a5d6bb4bb508946337d67b6a3ee9a6ed0723bbd42376aaf113750199c5083acb9788d40652753c5dcdec785c12e07569b8ef2473959baa1d554a19634fc8f5f50a859e3b5f82e7e4d5aa2a5e013cf8dd827fc04f80b649e5e9e48750d9b3443f94fc9b7295cf10c3f8b18b5a85b07f2d6bb674afaf1736400f2b49e05c33e9eea380dee3d671d141f06b026f97a1dec57c38ec93df87471240992de72546abdd61b2b99ee46e2fdc69d62b85808f3195d3ae9b7f82841a637a92103faa7666a946d92592a10a14f06b1ccb02a9be8abea49e6cc66398dda64a73ac43d04b564a0323ceb2c4201dc1d03780a8c1605fd2d3db80ee10338d9617ade50cba0a38fd5ff95cb962753b8266ab613c568c8cef9df0763553af9a5b0f3643e131b0cc381084f9f309f9e03488a2e940cd65bfa39004e0413f449a90a7d99746cddf03688759bc40e57f1aad4bf65b3759fe9948bbcd765fe1de4fbfd67ceb81cbb8acb8e0ca7f07ee27bba7d347a4a07a277718dc09879092b52e97dd5432ee4f438658c97513c0e3aefa342bd777402125b65a579956092f37dc95b9edf5b0dbd5d9ac5e2eac37f5fead25423cdec66581ea4169bccf18f6fbb256f21f47b051d4790fae1cb54edc26c78230d30d8c53ed38657b947450ef116b7beb47fc29fa7ea29b4bfb811557b065b1e805b390dc2d821fa9cbe06bd581a1b4598fc97f4cafd62f7a0336d09cde292ca10d1e1f6c429ca4756f45e5b709ee4e809071e9b23dc1c96fa64df9e7c98bc68bdbd6f13d7e4c18e11d95658003ca940fc2a9a38e383298b9c958c3a77333d0447aa5a34109f71af3b3dbd8054724b3f4dc26278b380e6a42d0b4022dbaa61a3441484497d526901e7b24f3599ecf94f2b0925cb69b51215f496130cf829bce3f04ba37d1a2967080effa9322d32bef970845db02bf15861689d84d2b84160afa25497ce87b6911e9a4bf2b005a03ccdb3877f3711edf94447e66f5e9e8ed4294d16a225afd9b9820b32aff5066dc523c0307c4f7c9731d914a63599dc9d7257ffdd0da97385f9080550afd75c1ddfb1fbfeb35e509f916a1f029b64015ce9766e1d7a07abe5d0a4237b81b08cc780ff3cfd6cc8491d600db89e3c3c5d1e1411ab9aeba447c43ed1c740efd02b5b4d512d5b31e94542204d44f18dea96a3945e8ad88b0f1ec8c5bbe3bc0b597717c898e0d8ede23f42e6b87206e8a10bc699091fb9160ecbd1bab58a7da61ff6b565267f816be2d2af8634f259bd68b55ed76b53f33a7079b12d1b62d64d90273dca05750892a1deda5830c60377394674bd243314369e6298071a9dfbe2f05d05824e95b717fc5e845de08fce4b948056039dfb4cc39a57deb2f0fffe16ecc3efe9581a70e1e2a58d1d35e7d4e14e8daeec5a60a0fd52166a236d7b1b3442b1c50e5c15c5c0840570fa1fbbcba4baf943a8482888b559f795ddd68c1e5fb4646851f5054823c577a24f312de1ca11d0fb4c8a25f2704d41d120ae532dcebda71826c37396d6d4d298653c2d302e9c1b2903da7d38c108bdadc21978e91d76eab929bf02e7a33a6d342379e442a6e1afe1b5f91d3ab8d0c73ac80e6936c1aa8b351bf7dcaca9a7c6d8fe1ff3585417f6a89425cd4e22983ecd303a91a1f7f353343c97310f6d4a4a8fccb152475ba2aa886ef0ffaab0df7ce40e3ef3005177fbdd27a623c77e14dc6526411ad39bc9564d29034192d190df1ba50d6da27c9500bce3c14d7a42b362e54b0e7155ede141614605bda0c4c5f1ae3b343860ccfbc83eaaacd2dd2dc747ec56ea92177e3686ed045cdedc30023abbf374ae2be6064ccfd9f3d10300636d2242c088c6e9700abf908d75b07d81722352b6890a89ed3b49eba542b8788fe296dfd4e53736441ece9761184ef8b088dc015492f1468c33845308dec4282470b306dea735ab55770a01a20df10b11df2b719e376eba5dc14dfab2dcde5f94c3e3faf807be976209ece0f31cd3660c191cc13fee782ab23a7ad81fa0432d2d012aee2b4c12fca7ffc16e7553cfcca8b3a952a732e3f7f2e13674ad7c12755b035868370726b7c497fc34e638d1a65bdd20c561d5a1c4e0a154bce73266b0f2f9d8b8f18aea3f0ec03479ef649a64309427c29ebd6f2f0b2e6c9db30a45580c32825c911102fae37750c1a79b5ee4edfea3c62db6f0ac9e2b6071b825a0f2ac2cf026046153848682dbeb0740213af9ec82cc9eb8574180f9c7054137fb9801219095c0f625fac8471305217ca8ca6346e30c50b53f369fcd0862ab2e2589f3b18fe2a7bd1284733f03a94dfac601a7f5425b9c5222276ee16dfb4a28f7d30a9feb5291d0b3fc0fca67d47faedf1954bfed32e46b3611decc9470d75e745817d3f4d5799e475d5e0548066ff5fc066c86247e0f3cc8570706dab12d16792c5ef0fbad3f0349ee92b6beed8e56a0a74eec09b7416c15e64503b84099a6f636be959765f2b626657c83b8c9948cd2d6f12451ee97e06883496772efc40802d09c14fe2f2940b77f46a97517d03730b6dfbf52762245ca6c738573bda1466801667ad3dadc5802285e83a95d66d56206cb8a3daf228373399872718cc21aa2988adda8c00f9c2e48def05103785e175bd590e5d7b70d4fbf529ee81df05765cd854d28db6519afaf1e03ff40ed3630b45a8bef19b1dc1e68f4b70a49d528ad401e71af17cf4017a24eed8be2190c94f9a4d3c346c839392c4ef65584501bc576967b30c96d6295e5969837ef39215875baa8712c23fbf54ecfbd306eb367568347710d3824e5d7e4db30647a6a78429f587199500bac5256c09c228183120adcc7b58ad67ca022df4442fd5d0726bc4f7477d16e8c75ffc87095a6ba5604c829742f21dea596e70a9f5cc2ce5bfc4efd04e74fc2d717d81ab03d4a6e208daf5bf5bed047bccc75f9aa4b1fb921450251a852c7321d384ca428c25394132471e955c1c2e4615c97409e3885e20e18114eaf3479b883ba9363b62669190c8a8ba3a94b898b55173de3796e125f7f5e319f59360feb3e4bcc18d04d839ae304c56bf8d6e371dfb805360bc77f96f0004a0b02be3f9d45dad6e688ca785b8aaea40c4f9f7c5fb34e790979df9758692c2ad634fe84eea1ebce1e12dc3359abda77ef014b19610104ee4a818615f534e32f3366e8333e14e02e0f5c7113b80e88031fb9e92bd2dc2e54beae76f4295fe665ce56d9d9acd0cd82eb074796b111ead7711f2dda658bc947447def05ddb42812823ed23c0336f7356531f63c1efc611497b998d8942f802181967e988e818c05b3fff380a74f3293d4e51c247ff130addcec5ccbba2704dbe1c6380d8e826243fe3cc70d86d61cb9a9d62df881b09f84b7ed0b56fad91b6f83958bc5889d3fefdd7ffbbde3e77f83a798040f6f94890a099873da8242e1ba1c607e349d733a6ca040c28f267f3e69f79e867da82dc7e6bfb87267f2c6188a8bbc2570cc83a64f3c73403a7b3d31466c5812c82ed6c7543c02d1ed855ccc63685d1868f02b1658329e472bdeeac8fd965488c48b552fb342397c22b2d4bc5416cb8767139547253fbe5d9b553f56e5fb729a417d248da7acc9dc1dee46d93f2b40688545a80328b217fdb24d58791660eef8417b02f1caf76b1dc7de51994b4dc0dde4bb2828dfc432af09db316dc24f7f5fe22aee3ea6725129d702e82b00e7b9f44da5898c493f57911b8d536c66f746c33a0ea6a754c7eba11e0b26cc77c70681b15c389c32854b661903cb898d537ea89a5ada434a8bd68e0025592e475a58d82449e414c4ae9ebff8ae2d31e381657093c1c3a7ced782e23b9001bf77fddd0a0a4e6d6e1c391e7e06b2731bd61e066e1778bd71b8a15c8d212f8ae392b4d219d4d7f56e157ca7013a6639c2564fc128ec44a193bada1c7f53658f803637e0d43265d1d7aff5c5cd3eb2d3f0fe9019ed687374064a88e43b77a640cc98f2d5907bd322971a1cf2cdbc2ccfb25d845d01667f530f7c382bc9071f4eae80706906fce8392a12438fb7d0e6b9751db33e0af657d0c29a989efbf7860a9759681ca041b93b456b52674e5364133012af5167460c289b8eb3bb34442d3247e97814efa90cf9e0fde9043954a66b12f3d01878ebf62030abf40185a9a3a8bcd10102a01c939961c446b17f2aed9589903cc5cc9c87a771c706b49e94b163ef492758e00bfdcd5daa1d891d534963ec695701bde16234f67be381c753c8c76137c140f3d6f93110e03a4ef249edc39e297e7d022dbaf416946244d9c644461c40666472869d4699803883ea496fd95fe1e6cb77c557416c4501e3b904a83a9f38094ee4d7833150b60a70a7000e666add7dd075e8fe22ef16158c6c1b5110b7c6e0d81dd322117342a252dd86d20997ba2d9fdf3222e8095a97462e464255e8a5292ae2e22baefd8a74aa9a2c8d1da1e78e29a61ccd82f832b4357f2ed1dea653c98219922127706981d5b4a0846b295b4f36e2ee428f51e04cfb99002cef4d03f844e69ee010a55412acf0549a002566036c347432931a34dd78605028ca9cc4d5f13aba5795b2ffcb8cd9a0e9751a60a61456e71b2c69652170f45fdd68554a2af99c54f011b2383a84735f155936db469c95019788fc34a5bcebfd10ff558335e3134bb1455c3b6d3d8552fc3a12036a05e5d0ac2c8753add084d09534c571347587c72a0b00c922ed4eb7b49b21abca4aa495db183eadbd6a9f2b784857cdc334a58a0590c3618e083974e01a585223bf76bdbc66c5a1d564205125f9d254551ac6f34a1076ae7958bf92ecaec3b6e529af3892972608b91a2fa725e313fdcc25d3baf3b4d663e86adfdd6f0bc8eb367cf10314f6b0b93317902d7f88bc9e472fdb790e6e3d85a1fde498595b001ca4d371b5ba05550f31c38b2a115ec5cf665293f1fcc4a55c7ce489d537a713102e8a5fd82c5db1d4c1750bdffa190fa8402d056340a3c709d8744052bea1a1ee138c5c7633f7cecf73a300f04a9e8107d956cf07abda6b1133f6c196bce220f6f3e88fb08d4a0be6934e9a6b5f505012e910ce6cbf2bc941331d27603f99d575d0c55ac0bb2c1cf7026bee2ace5e3ea35f863c8f5df0819ad6e853ea76050c2048295e8566c18b048f5490375e1dd234033c0bfcafd255d68aa0cc6fd27a407704eb7c706c1f0c704abeacede1d79418214b30fe9107f5788ca7325b168492d4919b926500d36ec91686ff59c505a15421ea14116ee04a980e88626d73feb62affc59244c4b8920c0dde1e1b4f5c9ef52b9406deb228c26a6939c27c38158c7d2e948cd53303deffbe495c9de57a740267f9cc1c1eaa6161518a2cb00f73bcb47173bb972deedf313ea0a1cab828aad8cb56e98feb1bae4bed8e34d09f44973c1cb31ca966aed7b69d2a2f0b4a6b63905fc51d3a5915e46200c5f020c775e11660d96f9a473b37c923361fcb5b0a386f95ae415a5bb30b965605f3d00d0ea0e13e2b3978d24672ebb6d4c10825e00bec99e8d402f1842135a2714ad2ed0a565d43c7600726c9addf38eb9fc714243f5ab0bcb2ccc704d01037b895d1a978fa54dbda0dd641ad9fa755a6b940bc6243cd20a2aed8cc9815e093205ebe6a4936f1e61630192fb5c2a9b3afe49163fbe5983eb78e4bc60472abb2d655fb347ea7ddf795bffbd7027e81681d75c31b6b8c69f9de1d569ebfec034fef233da3123e684b4b8364bde33d57a0b1de1d9f8595f8e4ae8cfaefa85613892b43d352eb0ab6c36d4bc8285b14e4694254df3379cff129e772401be5fa5a321e7b90affc5e9888c52bc34747e39ce1d8c3f7312002664471fedfcf1b9a226e99b3075fb2b98f39ee94db6edb0ad289ecde01744921117ece86ddbf508a041c5609d2dfbdd1cc5a3b0c94661018b296b391a4163d4a0abc872d806788b33244898db6cc50e85148cf29b1a5cf6a65e3ff514f9a2a59ef528cdfa3e7fb6ec0723573f884c5a7e29dd61e9175e6309fa71cf920e89041d0e60b7c843323cedb95aedb9d14f61249b56aca8d39ef91865b0aad56f6f899a94337008b85f61bb9a68b48da02a0ee7f599984f2267a0c5402a52af253b73ab1b4e4e562b7fd6515488b27b4f728d19f7d435ecdef421027ac4b2777800482192e42a4c7e31d73b2d258eef26318077b4bfefdfd2f527facc6611d8e5a6a0ba7154f57f17d1847f23537bcba42c3c58455610497491c3a58cc8c8fe4a82931d86a61cc0e3a3fa4dccc82e8ca864c55d3f57a0e992e66041d49c5611f410c8c6e015e6278abfdd1a77dae6ba9f2ea60060b13e6bc259cb4b614024f94ab192352fd7c501f226c621b7957916ec09e74015cd89154c4f98fad2cf135c13383d3a12394ab29f5ba159dd86e157113c8ed86594c4d55c82ed8f18d9da3797ad4cc6a78f61a231a1e9043b436a71d02f15a12bbfe13961d6a4e46f78aefd2049e7b3ac1fe7bb06cdcbf703ebc683c778701a73548b9427600bdd13cf3d2540ed38d1bbebd9ae4ae0476b28f59c0cda9a033002556a3b1c696dd943c0ac9c824e4e205b9c45081df4489ebf861985f98fbaf81a798d7e70b6c99737a68bc732705f5c6b7790bee056d5c858502663fca880cc5b6b785c35a95cc5668731ea654090355ef294dce764e9d9f642042f4d902d240b4d053f7c8e93e16a49e4aa5250773c4e7e56342f702791fbe976a91b8d835a09493ddd9c195a708503f8f4d15e6f49bc43d7fa1a579c898276fc8ec9bd63f15ea6fdf0af9405c3014dbf2007dd1c15959455d9db23a0137f0e3a025bd22c427a2716d14c1efcbd6204c09099657efc15f33a8f0edfb28e3e5a4e800a62fc713c8a8f9582d18a01583f1c06683c32dd47ae624baf812b1b4c6f556f7ed44ec94c2112ed68b2e134f7386591c11a1f22e3ac1564d48fe510b0f33a811537d5aa7432e9fb5361144ed446846f84d4c8979ac70c1be5814f445a49058904e7995fb7119de7820f7508f25708625dc61d002d9cb62b325d2ffb14a575a714ffbe8a31064cc5b15e1bbe9e253f11720930b510f27eaf8277f9ce8c4820fd31daf6ea787102b8d4b39b8c36f82381a0cd2db72adf62ae4c6f14e0104c55de0d5cd5cbd8b8ebf49c1095e8edc1a6c67363f667495f3f569b367420781b64558f5c0ddb4b01b02e0472e45d5552f881d48c98ca77081cb83f14dce43c81d0bdc70483191f83da2cf39a9993808720cb197e14b4d39783a015a0ff87fa7e1f96c23f9d526a22fe1f9e68a2a1cad0d8825c5eeebbb4f07abfcc2c063ada4d2df293e851158a843e83354dfd0ea7347936c0a134704321b7927fba1937141597b848672e78a9bd55ef963d827b0665f6cccd745bbdc6601b53a66a315d8728a4a2cf92ba661cf423a45fa029829a72bab90b33ce438e081fa59a88e60557264b9a457122c95b57d57ff5db3973d4460d3149da833dc31bba5b30af38e82224f9404c777d3f354f44561abb72a6e314dbeef9910a31b36c96b4a188d0bceb34def580cca896547aa8d0286b97cf91554e5c94bb382dd9339b5a1a7acc79d2ebe10a84e152ed0d376d3fbd81d9720fb7eea3f822a9ae3e8ac7efc621e5515712c82b95578859e1ea65a61c2c443ef1c7c7c6c29964d590d9510365d56abc878a2d3b837fdc8b671b3f39c541d170484c9e845024f29d267d9c523db5b6a05338671bce1cbabe8f2f9b1d20bb499b65c4fd4f779353cb991db17367583e773e3509ebf55293b66eb86cc22fd834913e202304fb4e01f460a56b2e35852930d71886ed10458eb4561d1277901cfdf17e329d3567ff06af3788d5beb4ce799f1a64224dcdca5e0d7def6bd26a4e00d380bbeebf558c3e058c676884df62af76f89b8c2c778fc31188ffd58b6af62b71487419dfac434c2e27669247e402115f55217243e6f6e66528415d9b6245b9f905e778987f12fdf68de21800115281e758544de271c449dfd73ffbe6de1f503667a7b76a268113b298f7fd1ec2ff0414144a4b1f73f70e06ba5e489b5ff21cb248d0699516d8a987e9b00ab055a29811d3e2e9d41a817b4359577c5860169667337362015a321cd1f6a4765788229a188434c3969d7466f069c3b41222e23db67d498c2a4f906d272d32a3add64a666ec991be60a938f3a56ee0dfd315105bde298501c584f8e1f09b93f42b5abcbe22c3eecbd9b2a4f3d62c4ff52381ace3cd81fc47cce647c1e6a185adcb16ab75d940bb34c1330da50a4b1204bd0a625e07f7a8256a414a7c55b536ab27af904173a1604d6214b8a64adfc9343cd03e46d55ffde053385309bca2906bfc70db636832d18c4a4e354b51d0a9fb6510996533dbe864c809d49132635aab61edb3269c0d0e353b3764fc7d1391d1bd719915a84d02043834f478de2a3e6a36c1596ae733eb631f202cd37b1037548bb51dfad352462ef6a6e73ed9cd7d02d476eceab4c0e73665d0bc12454c16ca92e60f08facbb8db5cc3898d7f890e8505a23ffc2c2c2d8e44488acd7dbef62938b53be6ad0fc2231d412315e30e6900211a6e4984c89e95551b67cf536083543f1cb0a89fc2072c769c55c6402ce11cf9667d88e1d3abb426db87d40c8125c065d63c01c539003f873cc0f08abe24f55936183bfd02e62beaf787192694d253751748ef74147f8ceb309f6d7f79c1d46ab4737eb8d63302af98f2f6543861a690eab89e8d861b2ee174170bc44f3fb364fa806eebad8dfbab6ccc4652f3f64b4133911e82525928b52b448e4de9600543a2e557bf133a58cebbeb7beb154d9ba8bba0bc38f54612472a81fa19ec4f1523bd78bde3ded7eb7a77dab4b27bca93cba4d4e35d25e94d11c33d4b8122f111f3fad0bc2128caf2270f8ccaf1134fead509ee848e50c54f5e0df08a19143afe36c5e91eae6889f3cdad522600a7573955c4516d5e9f23ae7bdda832157b7e9c14a79886067cc80ee2ef8c52ee57b08cba69986734cefa44e3287534a92acaa9ecc9c44b806f9aaebb5efac1c596e8b048aceb133ea0b64ee9a71891a53878164d774f078c52fa4c6e710c57aba5eea3f3ee99bc596e45e7998033d66c091e6242d594233e3419d5c22b600b55a1a063068f71f62d5a84934cd2c5abe87dbc980be2f0b37efcd0faee7b22946ce4d4df9bb90387b49595f7c10ff579dc55bcd91d5ec3ee162525fb896ddf3b4694b1da0adc9b62866a3cf32f3ab48cbe6f1ca1dbb225a33990d9fd55176734448c9bea2a3711511fb716421b234f22e0526c61235e01449ede6b728ad8a42d2950bfee5ba8d0f9ee8a80a416e9fab0df048223630f40f587bb02817eafd180357e9c20ad9818b83d67edba66d56d2c1a2acd1be4da6ece92a77cc6c6591e2e13a54522ccfe19b609c93228e1ca731cbd62a643b3a6eb44938494cdf93645c8cabe2a258cdaf61106b829cc1df1ea5d5908315b02124de11fa133bfd7ab5e3fd630eaa8fe146f9b13e5bfafceacf91584011652c7ed85cfbaf0fc678b2085db30b2390300c322d82e3873394647f445746f87c5e23de6bd879543df8f4ecf245ef250a0750e8774abd05c8cf2e38e1d5219f02333978298f7b6d0b1a3b39512fb55398773613099b599c4baf8f822b391966d1f3348988c8b64c12ba4d51b2e27a8fc312c62709f7ff180dc53dd6780cc70e7cf9fdaa84cdf7d2217fb69d0f128a21ea8e296f2b5e447ef3b4a5336d4af74f450c371d0812352c449948a4be79307b6870d846c78a5c27edb36f547e4a3970ef67b836dbb815f226659571e68e9e51795a63a84876f739c3af13a951188d5ee930d3283ac8641f8a1634a3649f82ef1ab38b3c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
