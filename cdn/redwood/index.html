<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d09df775c5b8b1de21ba68a37d168510e790b300c5a92b0cb35ed32aa9362320e194b06bb10162e902d8bfd30aa5bc7ffc2aace7ae32682e8dbcdc9646c6f6d83a61fab0629e125845e2c88e67267e7412a474c4dcc68692374bcdb234055e0bf76b546e581afd861e4d615b2e80f224f0f29441bae9a641c35c54eec560818413a6c5977a193af9890075dbde21ef1a0703a08602120ee6ca51c19803f23d6fab2f07848e4b6dc5402b063dd47f2c34adb7b92e188fa66b542f8a94e7fb864d2e22bb61a7ae5ccb32ff0878855fe0a317130ce6a28c0624d4fe68ec46bc31fec8b00ac6a8c4ae880e61e04f92b6f71869b8b154272601e2465a7e5f8407f620867eb25a44a45ed79bdf6147a1a1e6540e176118608727421c5f9e9154214ef5a2a2696d247e85812e32ae677fce75b3f6b329ae2c87c0eaa1685cf631ba0cb0eea81e2c9ec50fb6f8c1fa2a2c312f74e6e363d954e0285e07922a3725c64e47d30bc4978d00cf772f174a9a74d98fb3c8c272c9ff2f3de81209148d204b555416f6272f665211fa04275c943ac7c8f2a5c8020cbe294e0cfe7a18b8886058149d225f9e034e204568bc907eaaa0becfa5f90ed22c0e3eb02301247ea6e37210f6ba87a56e07fa43105e6b49f01fe3397aaeaa8d302b18138244af24f5172aca27458482208376bdc38727927eef8d0ee9381ae8643be659c974c48a7ad1ee8c3d9034ff9208dc11455219e66364516b29b4aac21238282917c8b19d9762db868bd23b5e7871baef15dc026136b9ad15e92dc23ecf7fbb8698cd669edd70fcd75fb04252047fabb2d2f22991a737fb30c98e5bedabdfe4725836350cff82cb8c99354ef8e1ae1a577bcc2c30b7903a724b946ef297ceea61d0c82f6dff33575e95921f71ada60a478318d894aab81a109d62976c50019c39c4cdeb7bf9c9493ab4ada18fb37ba2450f145faddc2f0da50e469ed7700a3b54ed9a225e52c876a80cba995215a7fbc685bcd61750a2eb82eb11326979d98f2b106d96dec783270a7b9fe05e3fbc66730904624ff5c6a407c5f20e50ecb2a65fbbf8dcefa6bc7a4cb388f98f31a984465b96d25d75f930d35c051043860d13bf6058974a676bf59c20e8776f5e71f545d66ade40db3d1e2c191eaabbcc5ba9773ae54ef33ab3127620d42517b759519023e98c30fe0cccb428c3f69ed465bf7e4116b371078a9188182d5ebd3b92066604770a5ec36dea4608dc4528b8d72b439dc9a89c07871f64e20cc39b152895eac2160add47a1daf5d0dcc0c0621d4b49ed3aaf68e0c4a6d197c7f0e9bbb40cd9d3fde3b0175f384b623f5d55967b60814b99e70611163d532285734626c82f6fb7e6fd3930ffaa3e99ff5171e690e966c968573da29196dd8e9e1425991e9dc36edce0f641dc1af0cbb7874d36060c7de6bb612507d3478b3ee046de63e072d2bace6ee2c1cd143923bc3d3d3f6629bab06aac8749ef8318718915dbbf73fb707bc2c1a2304d617b05b046ede88ba15d55380637c110f22a4aebf321cac8e39bd074129a9bd36952f273f1de41f3d09bc6a6ed2ea52c0ba1cdd840474547ab6d2bfde9db04a1b7db1030aa97e46774d89d2a12317f0a38a2bb050f60238ba0bc0f28fac922a06c5ae16b87e27e262a56554a55492244baca77f1d6eba00357193634c1d4a919bf52c0307260e9e376ee50278a6e08e29282dabc8335014be02d09db8177a06d696baadb599ff75a397f75cd094c421c34836c513d44ceff5c5b1b42d81cc918642fb2d537410a3a1d98eeabf6ed9757401f85ad3ca2ff7ac2a263ec1a6ca8cec4015858a0528362477141b9cda3f483c474280554a6f7da3c712b7824d5ec436cef5b29d32affb0afc2fb1270b3ff3e3ea65d0c0c9d7334aa6b91c16bce7c500c223b8de0cfdcfcd0a448bcc4ee91d5449ef9bcc09742c603ae9b0e99f91f412dc2f3a28de80a5a26c4bbcbf9356fcb60fec38ff5d2dbb77deac58af0374253b71a171ea95f316cda2a76c18c66de75e31ed7144078a7417c1bf4ae332193765df7e29ad8716a4595028315093cac87eb7bb9ef38f84abd1d21da913fc2ba65fe7a42e46e6d3f95d88b058c90bcc9c2be5c0441492ac618d9a5495e2c11f22b588df023d068fcb1247ed0b9a16cff63388fc1bae07a074d20c00c0aada7f77a5171c2f462de8db6e84f0a56bdf40c4095a0911de5b85c05cf07e99416ceb66dd161c05f7171582698914cbf4aef4bd309443b5ef085d966f68725d846dfe9afd362a8cbf6ad6ccee0220e85aeb4aecc0ae4589e4143dc6f2d4a6bed0bba12553bd70fb6ea4ff8ab5630b1e249903f3ec6c231c3dff2f13fe4ceb02fa47ea5e867d693834113d88061070d8c3189d9dd0b3ea26bd7ec72e429bb7068c88175738cb7afbc26a5d0dfdb3541fce1181f8cc321f239311231586e9f28811b7f3f9e7e1abb011bbd2561b10eb8cf509156901e8251ec2829e4f3748080cb4dd7414487cbd7d8d9befb7923ffb193401c227fafc39251dc0794a3fac26862aa1f15759453802cc18ae17c511893da6122d05cf2b05da7cedeef6bea73cf772d0fe18cb998376acfdaefc386ddd29ec24721000480b3e012bc9e43e4621d72e47b5562ba1b13c51bfd7b471e47322c0c98a7b084bf6a80c6042dd67276dbc200051ab757e30d628c376f8a0437b851c67da0cc66cb929cda4be82edaf46a434f6c2e505342f4feac290c1fabb1da13f8c756b5e4b5c5f1fcd25f4736e6277ff104d24ccd9b03a2a964aba096e1cf14c8b3e356e5b3acb98f7770bb45cfa06c9e825637a3dced4327e5d04b0a715c5e3689bf994f283b6da18910bdcd98ec85a9b256572a2706337ff35b724d974ec45c73b7b5f811e706513bdc8b9eb3d46ad94349eb36cb7b09f503377e07c7a1fdd3d43b12dd78a597b0a2daae37c257f789e93193b50e8296bab1033a3afd176703f1a4f925814edab9b989d01b6077a6092df3c3eeed019a1f17322ae28d7bf4bec2d82f23e7323a7557974a3246395a9b11c88cfda620866f6955e1b7b8112466af0f2145043114fd88dffa23cebe699eeff3bd9225622ccb6279d7e74983a29c4175c550ee234697510f3d7118910e35df788b2818fd606fe84c8f3b4cfd77ccf222c1745e62b5664a121c4339fbd255f1159242c0a201e5a0204e045c97c17d05ed8cada31b5ab179fbd567467080e4409e206af9a5129d056a470b6a98ddcff7a3c9bba6fec91c1e22e12f99d65665b8fad6a94f79e0e2a516776c6cc3651232709ce0bf372da70cd53d460fc389ba33c41ab246fcc42d4063757e8c03cc89b651251d28c9824f6f11570f726b618b67c3b3c1d398d55f7d2c83b96449516f4376c46e6590faeddedcd272523bad7a78e5edcba8f88e262a8ad34f6a994af1dc3cc9fb9c927ddafaafb16ff75b5f77f568ff50cd9008afe74b1d4eba70be9549c2c9a1871f6515385439127bb007fb7c7350f8cb0756999141a11d408d1020c255e1673ea4ad77e7d326d3bd9fdffdf5e518ec229289c6938c1f7e9d5104354ce28340dd744202a8d1050ca9cf62c390f8971b513868eb9624c9093ff00d592f794997540dac11e4b375d169d8ea5f9bbfef2dd4c7feeeb1a9c97449048df4d05fa411db05ec98cf405b67609bf683e85fe2dbc486470ff327a8707601902cbe1da760c9508ecbdff68de7628dfc68752be9fad1621dbefe4559704aff3f4b0cc3e1ed378f7ba3411dec81f98417723cacaa5dc09bc9c897fd407dc4970b5bed609adbb3d80b204264df712143f481d549b0cc9be35a990adc5e48310ba2267e5df8e754eda34770e6af6defff8a96c1d1d707dd2f9ed0674e432882f67c95d2d87ea8eebe5cb0ea17c2bb09b596fe474ebeff16fb284844a1698f0fe2ef86f2a3feee3468f3cc7d2307a22fcf8915cb550ed74879a0756ef2232147919b0bbfb469acaa53f280b5bf2861e6d7e1afcf9626b2ae21a5b334f534a3938e131d18e3b94825bc600a7b8aa62e7d93585573b558f324e1acdd52622365c7067e752ac6385d874441e0e2b3b939825413dcd457544eee843e64e23b329a1d9a7b95f67c419b32f6f2c28c619f6028748e46153f846cd698444706742e2dcbb0635d7c37bccef0d1cb526c7f880348a1d6ed6ef4f3899bc7da181810b84dcc4ac1bad4200796bf69a091c18f56eb6a0eb4dba223b2d8523a359ece1024d581e1c1afc0610e5061bd568cabad2655eb733041e580397ba86dcea47f11282346a107ea3a784422560c4f14a0a784f397fea9ef0056e8a58539818307b29d0b7dc39704cb2a8baeebe84503da8063d7c85ddfee595fb16d3bed55c99a0a21ebf096bad51737a37eaa5dca60871e2eae7138ddbd511d13a708c9860453d9b6e27024798070e07921780dff187f6aa2340476d59097c7dd3ca6603f02e41e491adc640c31c1b452399d766e7c7f23c2cb50bb90aab47794a6a39a51fcc8d7ce8e1df763881abaf3f3ed13d997f859bf491a813a3a2f4e335bb28aa7ea255b396d1f5c5ceedf76fc2c15460b412356b9be3e8b508e0bb796e9734ff170ece8953f6da4564f1a38d40699c4f93dc77d5dabb04c0d8503968fc23694236f692b811cf97263de89a2e9dc4db9c19c59c3566b0fd0adb3f14f2fd11ee03cf0b92bdc0ca4c90da6be8a69683a0d9d49c5b6b9641c65a4bb67bbb90765d91f816a65e12423c15edd040f907745764369e83749dcc791ba7db6e9c72a4e43114398416759a897cdf2c4ee948ae2088c556f485efca10564b8f670d1dd169239c6721d4d5f5f3013625b518da82eda48d49ac0da441e71b9dca2fe61ea1628319653bedaab9cf142f4da4f3e86edbf8ffa63854c4afcf3b6a96813845312bbddcb5f4a57ef9245520cd99c938e608563ff2ac11e674121c5e0e358a8bb983fee488197bb5a707f66466ef12137d79a577fd337e6a5f72bd1cea403916b99006ffe5698d8a4420bb2ac77241da0ea647ae31a144dd53b35e7afc3491c550f1ad8ef759387dae9179795069c5cd8392b3d0de437d2ccee56ecb6eee96234c13d8baa37284b7b33ee14043747014a1ad0c228d252d366c650d33ee3923bfd1c6b942f7230d37224f7339a897dfed0011f4346e7d0d96ec0297da0c96e5328b9eb713b4dc2f1aa642392c4a7df5b5031934454e388fa803d002540779af072142fdef70788e50e1efa385d790a8dfac0b4e8a6a32abeee3f0ddabef927e6407f6d8db77c69fe5140b89c4f2a2bdb5b1ec28dad1b0a3a5ad75966503116916fd4591bb39036e72902d05bc9e545f2b00290b5e3d09434b8155d2714a361a802d96ea1ab57081d0ed9bf8b2ccc0138e5d4b6042e5fbcde999a6462985124101fa1fc91e532fc5407e0be1b734ffbffa6fd0ef333ac9cbf84cc75772f82148d53456550921b383fd0571b9218ca891dca187b38e5d813d28d18b360cee5b91f03696e323f451078be4157bd3466ca555f490bed711855af348586f06d89483f3312d4d7bf9d59bbf19b083361bbf6ff0361c260b545865042a8d79eb139bcc58017108b65e4e2e1f7766dd8ecfc9b0a6a3f60938be27ab07758a904ac60418210f829cda7ec0d4f0e4eca24409df44fc573c1a2161f3f52b7a6e8772e7d4361516be9577dde72349a3e6af6083c6ab699d76a2a181ad1551f26abfc7e332a4e63a04387137d8bf5a597d03b57dd960f8bb9d821d7f1f20ee5943bcd26a99701e6daa43fe57b6b20d0ee987e6206e852171da7ab5053cece9af382a7ee13ebd17ee54253e6f06294ba74191793b7a63af8c300e7bc534a9e58f409f19e66a4f673907a925b8dd3497d31d7ae3a6b2931cadf50472e182e71de493a9c734e375e820d4af69ab90c55169d41d7d7d1b9b9fccf9d8a9c68710b7dd0706ac103903424c73dad6d6333259c84ec2b0307d39e573e6ab4a1fe3ae1b93b1332b39848ae0857d74a25242cc553943e70a302d6f77dbb5195fd500b9cc8e95c3fadebc4c9e3519ed120247587cc6838797b59beb733b27f649b0fb1e22957abb42d4c2b85f9cec9d706b9c72f95ed85248edd2d98863d2ac2362b1e3e9374f9ce1271c8b505bdd3248386f508e0a2a30f41d1197b72c713622a11bb1a2f7e64cb743db9e8b48eae6aa5febf6ec3deecc14da0c95f926d3ec88c66f2768b20f1f46da623e6069b6836da9285cd1f7e27a09721becccdf7912180a95bae9a09cff150c3013760fd61a33b63fbfc059e3aa75ed143e1a172a847f3c6e5ef70f34da1dadecc559a5abbe89b629cbd8c87bc1182ab5f2821509b85b3f0386ac66c63be019c10cad8c2a8fb352e07b455d5a9bf406054166a33b473bfe2e6d2ba7b78791d1252bbb571b4f2f9a1ea222db34b2af3bb73ece40415418456387799ab18f4c8a40bccee7c8d6eb56b679d308addb106824ab17952092735d40ebe00c3c093d593f8dffda44878a4fb0b4c5580d2e850af2c367fdfecb9d3e97e51bf5dd4ec1ab57ec06287838e57ca14ad1337e2c29c086207c0fcf5f386c32025d0802b9d24bafa55548d195b343ed60f79ca249b0178f04815ee32d57266e6bc6dcaaee167c4f2bf6b8242f8495517fac51609097caa8a8e26b80835088cf3ec29565d2127c3a1948e37dab406b71672cadbcace133057836bb54f4e6ad5621ab497b8f318b8c6de7a876ffba86efbcdd0d0e0f6f72b6a389225819b3cb0981dc040dabf4a2fe25c57023d85c008afcf18e66ead33705115703c16cb30b2712edf4e9376afe42535006aaa2a25a13ca124bc840ac70e25d80b35db442370f4a8b376f0dfae54607c63965df07335f46e9b9e6240be9a1ff0ab7463469e5c4aa6145b99ee2cab49a015e96064beb2658a62f294d6604d8669992205a7ac170e6711a8b6a22a71206d0a82c6963f5129ee7272b1da44403a84de69de053d2be82124719731446c1752d557186e820bb1142f52aae4ec737012bb3a16198e46b5765f312d798425a536d73c7a27438b55babeae9757e4dcbfc5c94b80bc22a4282cf339db39637b0a78c4d5adf9b6f2c3556d223cb87b5bce76e5c57dae6998ecdd1f4c546cb5700177d68c352219f5e9b5306ebde9bf2ab36a7c76554fac043a9933a6ca06a843b9ad1d7f4f4b0fc8c97a3937225054d61a13c59d4906599e625f3056b942e74f83d3ae70afad5a707e412214c1347577ab9092ba6289c17b1c1e8734e60582c14b0bbae19932b8fff36f91ab5dd388ceecdb83bafec32cb6d664f7c4d7b22b3b34d906133089c3a8fc7395cab3f62c9ae2d4dfb2f1fe9d54af59887f0916d1af5d8275c2c2d23dd702704444151c1e2247f21de1e58adf33770581cac961a62316bb09184ffb74a7046b9421b7dcd55e03ddaa2b52a327fc3daa6b705bd6f19caabb114de2769015ec07802e0525a76fe4cf45270f0244e14d727a00bf95da7d9896cf3868cf80355ce9007a7ffe1f51e1165248b921bba6c22928f39dd4f4e6a019fa02ee05ff6543db9f306e6294901f0754fae8924b22ca6a5fb026b583f7f3526034c23d81e4404eb2fa519e6bdc7d32f6d3a20acb4876500e9e58c08dd8360dfb780b5f60cb2d33d489950b7a801a52f5381439fad345ef1b8d24fb6c53001cd1a3a0e277555268bcb689f1b00ee897f90103bd090312c162080a2bc8720ae2b86a1b862679879ab1154c16d298c2334385dd7a54eea7ac589f726d37b38bae6d319f9ee5f3a9ccab46b6d0d8bd1787f873cc96db5d7e6fdeed79c8d92a98dfcca3b0d802ea6fd9004d6a0950ac297ca19b314219ebb4cadfecde3484bf29d4033a39527e45f2805040197d364913ababe96a8d1713bf7c24e89ebb4bcd70ef3461b3d65c19b45c373305609fbb9543eeab17ab990676e3dd4bd0d85ccf42a5adebf2439044fd17a51bd39644f528a4fb28b3e41703b6b7aad9fe0a99c4382f53a1c9d83d33c103221eeba9482d84f31310c5843485b70b94e36227c7b32ec0a600d4c00185031c8a50f1202af5794e6d14b07474051e7d4349d443e2d6bc6154871e25ac691165c9746c168b3f60b3b3c721f999032aaaa22ca3e22d7ec2d6c8604b34fbeb7f6f27417211623da51b52949ae3e341bde67823fb18699615f19ea7ed89401f2f396eccfc62a6922f88bc5cc5b698c128009caf44071c595f62782c568e1ee76d8a4384afac420195d844e5f1dde0e3787a8cfe7b17fb74c6f7f749fb27dbd1d707a9c57d4e1eacfb3d43f15e5c223e9d4792515b15aa633dedbe9fb8783eb701d301b38a83e09b7d7c44e4afe566ced26dbce5b5ccaac7f951e88a2b8197e8b17a78c6373ba859a6a95e7d152ed1cbc75654451cee6a0bdbc1b90176d3874ee9d52fc838fff8984c869e08bf5146cea6f90e1ae08630de0fceaa0c11e919862e7e7ca056fbdc40b418a7ab6c08f13a9709304603440ec995f0e7518e585cafc70c8ca4cdf7c7b47fa8801b62d217ffcc1b57b0fe66f32125dbddca067866a91d2a0bbfef5335712b462ed386bedbff570388787dd488f82c2a0cd1427491b3bb3123934a4b1ec173479427fd522474ab694553a467191e1e69c6e7cedb4fde2999c2481726e8bb35166d61033558a3bc70ef4713b6616ea29edcef0ad851a783e4223a5f17daa2f6bf7e111d36e4b387903c1d6fd769d3d70ca79f3d746a23c58deabcc8ade2646c143e48cce0f17a3d98ca196c293ed2c693d6c48455b43eabeb817e43601e76d3ebfef7295f23e22be0db509520f747683b70d01b61788e3e5d1f32acdabe1e962e2a0d37d7f59e1ba5220cf4ce1ee897569350a590b37a7079458d7e1e60608d8e2c9aacfa03dc6d01d02e41408a6b9a0cdb7eaf96405198ee43b1db2d038548589fdd97c8d12d3d4818bc6f194487ab34ec8d87335c484d5f06d6c9ab269f3b3ba48ef5261ea3a62ffaba9dbc459612ae9b8ef8e837d74a492c5efaf41319f0bb8ce06322eb3a28dfb74db961cbe5a1836c895b54b4d085804586d7f3cdc9f985ffbc6276f87601ac947d2d5d519d4fa3ca4383388f61ec913f92ab01fd6dbf49c8e651699d4b15ed6f29e4ca13a1a4877b5202398ca3b796d8285c01bffcfd19cc4d4c18159c7ecdcfb3d54d113b09b5713e38aef9f06370c96e3efce97922e0522f9a6538944440ccc24b13e283ef7a1e9abfd99ad41306d951f37176f8b46cb15ce7a7a80d7a4d6878d871c5db92622ac5261a3283cb7dd08299941c5538da9206a5e579255c789a61275f4baf385d3a63d3c9ae94576cab98f137ea7535cd81a521e32eff5a5b34e30011cf621273eca349025926017a29c8a5ae0ed7fcc6eff304866c8a70a117da3343bcc7b958d920b13a4ccfbfead5e2975fcc9ae8f511d5302e5a238431d817ac030b2dadfebb1260f8127e86e8662ab3c7a6c9ca2b5f28e450c1687b133cefb88b02338e7c54aafde9345f7c0a4d64284f0a5832a52aa33722465df19d6e7eb378e46af491e68999586ef5920fdcb7cae48b457da909b344099ff4d652a1b03fbd577fe41394adc9a806e98824a585129c6b36a7436d9a14545c2213c630bd6362307533df17aa96efa79111199c6760adc6dd6cce739f358e96da7b923e94db05d097f9462fb874bdcc27d30ac1aa18645e2da1a730a3aefdf5bed3e3c5b761fd68edbd342eac74d54166ee8d9cef13739363fd73df4091edfef93b029608d11d8eddf8da4fefb38d250129d8841f8718e5e539df6aa2d7fb7a4bd3aae98db1b832b0821056160d4e743ef1b1f1b566e079ddf2811a9e29a885401c0b400c08c57b5f0e2479603e8d2a4e80d3f5a98ef4063a25860d6f87cbe366a00ee824519660c90b0afce5e1c943a4f5830f9ca40d5dc241ae26146c440ffb5b8a0eea2b29e89b574a48cf0a65e3b1d345d239f283d31c182dab7fb3e8b522fea06d28bb77b5b08de584b6895603db63f5fefc02b75f43efbbb8efdf4c4a16615bdf7572e563542f3eabaad2ebea1f86ebbfb5e6ff17746d73bdd3d95cd0633e2826749b315a961b163ba686ad85b0a088081397927b88f7dceda4b51bddb823e8e8d41626229aa28cd08b1bd2dd19c998145abebd2dd8f100fd8778e07bfedf01aab3f863c5fc67532f6698240fd43a56928c52a285ce7eb84ce54c4d1025cb555e5dc7cad71fb1acc98e3344b7ff684bc471f61d034a3104fa34034b8ee31933c9eed7502de904ed4bb93c48c2ad835d8e1b7d6fc96e12b3eda5cc3ecfd1bc7b33e026883d4597707db6ad15fa7776a0717616139d98020722a119822da9d97930e46a9d95dfb41f2ddd374a05bdcc1963be306a368c184ef9be3dd48101e1799ac38adc0c3826761f544c2f6055c3a821ac524e5e0a91811a3f7193fe755592ce79c3ec08582f1fa015027968cb633bdf21be294c2438527da8db84b993c58d4dfbcd50c02e1c9aeb5b2790ddfdf5b04a1f85ee61b7f3f1ddd036c27872d9cde5fd23c9a56a8efe47bfe8b3c1d9aebf06101f233e8e9751bda96bdefc7fbe89335e5edbb48643ecec5a023b2cd0bfa04eddd17751bfa4c2da41d78bd63d73374aab3c87e1159ae70df348719a61eb3ab4b1f13e4b8111477e6037a283c3b828649200d3158f4048cd8b2a29c0d13b878c8aa53c44cd254e49dba827af5a551f7a83d8af4b8b0e68bfad8890702ed6f0d2cf8b20a0e59adc686b75f13dcfa005eeab8fd3673a5fe6909b9d250f390c198d4e619835bf053671416256be429fec0e05c265505ba22ce2a0bfdc38d9e84ad3ba76f3f3a8dded91d5085188a086a617962351fdebab7975a3d112aa6ffb163945d9629b6e543f87921ca1256e6516ed7548387fd2ebd34b6375065e64e97f1aaaa7382e46baf32307a5e97bafffface7ab70de443afba1d32ccf9775563fbba86ad768f1b85aac36814c6e0353cac33be08f986e8448ef754b9250a42e2072a79e7d84a65f5e810e5cd654fed95abca49a101a13740ccb2285672fc4d55d6c2837dde0a16b1425aa39945d7331bebe04b5c745575e3b74726cc8e8745993d4a6dc419c392e65b0b57b7e067847f59f66e6528a136391516f901f8b48d250857c2399d8d317080b94da20748928ed005004a8093c8ffe591d089adee8292ef5c8b0b6aadb3808a559d01dc3b0ab246919a58b0c477cec158962eefb39a8e7ebf5b08199cf3483555cb8d0056ddfd4703351df41ddb6602f04b486040702223a1517c8db409717a596a24ecb2aa22deec5f1027c9e2dd306aa8ad140a87346e557102fac87ed9a8711dcac24e40ae88e2079f3498cda5e75ead0f8dd66914088da3d9a21e9e4346eb83ff4634bc0b21d615ee700afda015e7f7f80813f22313c6c982bb804264608a39d6cba6caf09e6741913052e87de5d41b09643e39c10587c01d93872c6b36c1bc8f40841e3f011871891fe590789d2c0a052ffde80801e2a3d20626bbb6a34a0fb37c4438bce5063e3056a58dc492168b62d811be784fc9a66153bace66131e207fe8e6464c464df38dea7431ebd68415101ad28cb1fbe73ef3c6edaeb07944dc667043f9c7389fefad930a6be9673ab711c5d96add923f732f3f7643a4cf45a42320eaf5cb7ae63322425b53192116454b89476194c9c5f14e1eda518690175e000ad1696b1d267757377557c44f2ddb63485eaa80e7d1c819bd1434ccf5042afbc975a5b0af53b31cc6be65216ea9e72a84593d2c57d1d50e9412fcf754964e75437aab2c633e94e79c220dccf88b4bac478a1dee80e9f31c79ce08ddbd1f7d805256c1f59098c9c19b77205503d5f37caf693ba5171f3581d6f85ef5ebf46cc8b459d4d2a6ac03e15b41a110fd7d84fb17d2ddbabeed0cd618526869f738ae7f766bf4b8745bc329c9a741df1e1efd06e0d6aa138b96bbf64f6734d39dd833a6f0d07c2aae0b7d24567fbe96f766370ceef65534d117b3f1240c8f2309a7c8f4b90b871e3d6a7bfc86c16d96050c13cb2373d4eef8db8a03e053d4d5c0093790f03778a1cd0c44dc21485921ebbffd5a395a7878aed737721ca41d64bebbde3476aceb36abfd5384da73f5340fa2c388203523d8f2b24c1c40578e7842bf5a8a8ef5ee7e00db968d24c306f8f94ef9da8edbe1d97ffd5d9cafd6d626b14c11afeb5dc6d6b9c40dbb26bb5241bf63b11a00bc21a0473c8f2e677eb99164f4ece018419feaa7a3faf9d03e4cf520de63eac88fb7fa691e5e74ff153c86e9d407ff188d5c7d8168fd4f1c55631daa95bcbb6ffeba6c0bdd1f7df986f1f40ba7df3f9d651bce9d2216346c98c1dcc5198750196856538dea0bd4084f778963fb8c545a00e2b4af6e3de4ded8622bdda2124e54a2c1230237278f238e93d019448cd4ba7ede31cfd2c256260a60519f00090b44a5959dd52d439d6d565ee736e6e2141b520670ce36b12974178ea4f85f7c1c1ce4cedfae136396d0617e4d6cb497aa02f92daff1cf25ab7320963dd44495a4f5d80e489a6f3e1bdcb9887665cab3f0f87d4c3043e91265f22575901981c7b922f0db3b9af1c558dc0f40219191b9b61ba45053f27695c3769e1cb2681b1b0c3905e2bdb87c45e9d73bba08c6d1e4f81c9eff604aeb2718b50e628900c0275b1e3b9db01d7bad1864330e1b5dad2c6a9a1f43c9fd932fef20902e0489abece91da3e164f5c87efec0522b13651f1749ada07aa7e6c5f113225eb80a18ba1035db554370edaf832e6ed35416923dde59361b526a93770cf7eabe72f3be414522327e4d14d3dae14fe56a60e153545ec8b75b0753bc4f8b0c28b235d89ee753385bcc08f0e4db3769b04c476b3387c84f59707f687360c8ebf4ea1683ab1087bd8e9ff6e4109941e03874fad4385b51635a446aee155eeab541af417f92bb32ef88c8b1892405a33d10929d551f4f02c4d1df3eb9794fd2a6f0f6cd23f5819a3e636f9160e7f56a8984da1963ea7f3c62dafa37c560f5da857aa9c8a64c6107ca27fa29af43e8c38fe25908a400ced00b2f8e6afa4df9dd159db56b0a9ce2c9c73894121e0e8e291d7c81e6c507b7dc876a02a3915bbd9e3a3c530512d7186476fda5dcc00076077c5b3649856636c083c09a57a5573106394ea5c7265383c0885ec2428b023673e73c9f716abba877c8f25e22762f45611fc4fcb4f294d60ad5d357b379c5e1054b79c4558057d651738c8c3005fabf761d769f39f1c137d10c0507064706f2a8990b4ed28451970383d5289ed6970d241f11df2c00b3fe7e097604dbaef5900b7caff0488d86c78f533d9015445f9ed8fe256841d7a33c97150bf00c65d17e3ca844b680332917c1c0f87244642037b1b2f6d76aca828faae2c31479673e02bd5834dbd6a1bf15af16af5364d963f95c658eda902ff6f465ac3a7a3a94a60affff46096b154989b63645080e0bd75c9859929f13d607dd778c9e29088c0fb911115db42a0ff97de2f15f354d2e3672730b26f649695ac2f4ccb6b8b84f26dc479aa805b1a809a1e70c691a070b50e1e383fd62a8bd002cf055d674ac33159c88621c24358b207fd7a67ecab71f10d302d0f01248a342f1a54d550321524bc35ee8d993126ca96d2bd7ebfaa30c941bb4158307922547b14969af9bab9097ae87e4f778453150adb9afac5ea7899733d913ef06b91269d9bf98aa15485c957df6b91f6c824ac531ed506e4de6c63e3e1502cb9fd9941fb0a88a6320f558ef1ca4a6ac336bc4ba242c2fb9e58491c3887bff9ef1e9e7a5959ffa0e5ca56b6202f887685267bb2327222500ddc081a02db76e76d85cef7da5156dca9633cdbb86c230951b3886f477ae146a25661833c5ddce4b0e3942063925b492eeb81160586a200e6442870f0a4017efa4a5c3c8c5cd5ae1f6f971f5589750e1b957d610d94ba9c010199f1c48624d8f588db0134a69f09796bfd74e87ddffa2cdc75720072c220eb5305d6175c5eefc56b915f11878c2a8976a10d4326ae199c79c8f677be01b9dcb6aba9e13eb3c1ea09299c30cee211f3d5481b1de25e63d6c6442a3f99200f69f6dc6f5db89a2ea65bc2676e8b427a64744cab41f507e3b90780e315960c13d0c51e2a90f432f37431bda0031a03e4cd8e6c5d2ae5cf2562fe0e847c4e941f8a179e503c4f70033681acd08a1bf9070b75cfd7ae2acfa4e5a8ed5a5ffff764fbe1488b63972f149e606bc062abd71d2463634f70aa647c2ed23da184e95294fc5d92ff4c2721920ff790cfc0f440ec00a3e3c2e9958a3e9bf9629799da408a7ad25afef0a3c5679a62ef936b71abf7e01723f872843d42a6a565667528beaec641a0f7c1a2cf19921d1db42dba17ae3053646e355d1d31ba35c6ec14d09db4039392d5c1827b120238ddca113853d32b2518d7ec40e6560650d03f407b5ac9478db13383165d7899033331eb58c1beec10605fb6dea3858876b37cbc39e11610f773eaa3168801fc3927b77eaf71d80637fba409608a879582d37433eba983a92b3632f75d1e85d8f56af46a183aad75bcfd5fbb680a5c65279828a75b080c5c6cbf6b861a67d6878818751cbdea8e6edc437c566a680615f53130a986d32b4f56f69c3a7c20227807d89ad6eff343a1a18225b0f0ed3e57ab6e8bdfddcb6c388f6855159765b58cb4b43dbb71d623bcfcc70d6fb504e07e767b56354c0de3029fc83b6a13f69b67626be6cebdb1ec16c8a3baa2d7ac636c5f14499019f9a37fbbcefe5045cb6ebc1d9a7de2049bc54f816d60decb7a21e2acc2e40f7d5d4ab2b64cdf26c5eabffe87f7d509b74b9cb1f5deb72fcdc3cb9f3c9f35869dcf72a860d2d64da1fb6bad2e2be3074469410093726377cc9d634e0a38f47730f43569c7e31984d1ee43251841405e0d6f77a4a2e2c36237dc794c2c23c44108ba0130612b6e21cbe8e64f8203716f06436abe57b8ffb6dbdd08ea60833efb27729487c20e2fb255cfc465f592b81e460c4441730009e8a8ea4b00d66e134c2bbbe6a91071fda15a7a2b87074fb28da2e7ca51ca4dbc11e12bcd27cf2b696be537915a67a141fd1b3eabfe5ff8c51bcf7e4538d5e34a6393e32d91edf0c8cbc365950d14ed7b923f0cbedffaad4e4e2ba545cc6a28d734ff07871a4d9b4cbbe01f711bfb535b9e654541756d9fbe33728cd2a719f62806acb23d68c3f9df49d054adf2118d082cb3bcfa1036914b3d3b05e536ed1213beb40324db1d5062f409b471251ee63865a980956c2e3d2e1f73a4c2ec6604af6c898ee1e40bd5826efcc0af934e35a339e020e5887ea05fe7a5eec95fb4ea86f5c9cceb5440ff86762f7897dde5815ec834571e77f242d6f69b600f53f6c41def6897625369246add746a75a7b13130031116aebdfac9e3b9881bdd59f81c2912793c3ed1a23b82d52f2c412bf75b81137a4a0e4e231e1ad8b28c1f6a23579b5bf3b64664e90df7ae9ba9ca55b2a2c54fa7efdf1e7d7d562865041b095ec6f0063ddc7c402e3955c85b30ca157c7466f5155dbf6735c1849142d4935d2e3f9871a629e6c6ba663b4bc12b3990ae40833e45330db161fb4e2868520c8e48105e773ba49d46875e22f218e9eed8dac2f1feb71d4238f0ecc05f8fe3ddfd458bde966cea05246318aa60600d1abbae39ccdd6cea569a76e00aff6cb2c2e56ca33e57d16d2400531abcce47bf43759f8ca5ac2c18132f19546c693f1bf3368e913335497266cb0dd2fbc4646957303ce0e6e84b5a38612abdfd1012afa712e65aad80878dba68e49dbcc6ac9399a96b594485e87187f0f7d77677df6009e6338f7cac216a40bec607d1c3ed202aa27ab19a0c7ce3e8cc3713fcb88d6b4e1046ef755b3814eaad86da6fa1ba4070b2680f18d298e790e80df9529fb8748dc39e99fd4523c28abba6ae7f18aa03f5cadd116583187359419e84409795d0e6b627c64fc4b0190dfe2861a59776aad1374075bca20eda667cf4532b0081805e2d8e0ef5715f3a4964423b4b3f8c1f10486720198a4a5c61f30892a318c9d7a9a47ec38fe2416af4ad569ee4b8a438a2baa4cbb5589433f17abdaa780e46041c38e6833a81f4363e8887c790aba55dc34d8dd24aa4e6af38d54a1d926f931fba9d16386255835e79845a967e850612940be026c737ebf5f64cb7ee83e5056dd44d090db7b82bcc93a91ee0a9bf3a9f2908ee6d68637028a1634634f16e6ddc7b36792e11c1350addbd2b5ba5619890406fe83de4d4b633b17b4e6dae54cc606d02ec5698bab42b9a2eb5574a41dd857ead7f40585bbe2ca7995765ec8204458f7ac951c390b4fa4ebd176520d0205a4e8f6e1a1c0d4c0ca20f33e127746f5afbc2df0c7e61d37761769138c4a84ed79db3fb848c54f8037653ff9aad00979c4ad7d671694b7c639f56c8a6867eee927b4f81876c70522875e39f5dd35afcedf8303b1a88e594a21b26fb0425f26dfe45e7b60ecc4e9c13cb6c584d54d7b7d7a8351a3160e4b7f51fcd9694dbc24b06aa410a7092d1d39fc917f8a728938ace1d0ab39cd0886ae1581dc8b4e9af3f088cc7fa967c9f7a7695ea29222fe2cf8c25f3e6f3bc973347068cb896a5f60d7a16c91bba4d4b2052ab26834517bd104e858548cab86335de525569d17470193550a164526c41255be71da12312d1e9451d68d96bc884b68875295280c1588a3e81bde71ffccbaacb487e473c4118e0ad949c362e613103f157b70f5d8ffa02dbae2310b8fb86f446b4b74b94deb56c1b9b92d050f69fc147a6c06ba0edec6dbd19074d7cf5f8691a364ad57f0fe468bcefdc0bd7d0cf2bdac8f2ac2ded5972c8dcfe551e475057a88f835abc988a8a0cb04a63ef4ab873fb426aad9f67095247d56f845fa179bffd2fb16b57a3bfe3016ad56488ea9474ce0e7468baf041949b855ea00f592f69b63d300fa4621c23a9fedc044b0679bd91a300e9351bb6148571562564a3f05aeba56004911c0a6ee3e85540a345f332b44f3562d4649131f172e7c1ea06b0c0ee602247b7db87225436eacaa5ec9d62089ac1ec8c93240966f71987bdabbe43437e5311fc6f2fde77ac84851961f2398a3501dfcc338ccc18e6b3fb59dba4666f5d94fa13b1becc098a4615f049f50cd8aacde9900734682e29a1c5ad2bbddefceb60054915abac12f8bf66f18406a3e6f62ae2dc7196069095713cb2d3bb0e2cb0b4bda821b4a0112bf64052a9bd639f2dbf65e9e01ddd3338d3bb0b38212963f28773707950924037b66d1817425b0a240c79e34d135f97bcb3c5a9f24361b3233f80ba5ca0f523c0b028f2f52bf9a330dfc4c13cacce8f338c12af43fa1ce46b2cba955dbcdcba78e7ffa65d64f5ea69b5e7f6f839c923812ba658f0d234998b51200823cc07cb6ba39f5aab68aba000966779f399528c6993bc390fb0f7d784c20a933656d3779fb5e2c8250799606bbe09f2d789db2ae29fe7acf744eb5d56a087abe3b706c06703bf063c4572ccbbc3b9c49287c1fbe91f76914fe4357c38d5c244789a61425c6f1177f047b384417d6eb4f4752c38dc02df31307957005eff46d7570ce55a3f266b8f3d571ce2812a8d0c98020111153ee36610a4bacd460acf0cc487a4591e16208f358687b611626119da2efdcf80ec13a5a2d7f68dc8d56d4b32fb2b79f7df2e6fee0a9fc3705629c85c6f267dee50e9580ddb7b31e37f64703ff32ccd422229776f2a88f8a961b5bed503862a3e6dd24ccf10469418deee290fea9d7a19dba5a3081abbf27278747f0003555fe9a61a834599696b009ed8fd3ad381b8f6af236473024baeb50bbb49df5a5d06d6ae7a28a60e2e042d890b466608ade04148cfc94b7b544f24c2019c87ca6124191c6e167e1c05072b7b4295b76a541d292556b70d2a6e164662f900d15993bda64ece89e7a11835e6267cb7de56f618e2633574547bc177ab439eb9bff17d72f7e44dc4254de98e6003042484ace4d00691172cfcd9a908f382b34e74a07e594e35670fbba2ab7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
