<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2df0a6622108a14254a0f2eac03bc49036794739d4219de99a1a71359f68b56f6354ad132cf837b1d4e4d574ad9132f55ac4442a3a8ce73b793f7022d39e6795289cc3c86fc502c267794610d8ad3a8eaed2aa05ce132c76306e84df6a01b96a626a4cebbac86ef8a4e5e8c9b16b603ef3df021b62fcea8bf03cac18c29f40252b8b4297c09117288b0ea29953642141a42ae97fcbba141ccc5fdca0d335725b17dc62d3355e4d4d329980ec2294018ed6464e8b1707f235d9a98bfd6d68bf886449aa73b110c8a44e521687d0147b25df4d7994d06def4996bee1ec4cbfbafaf61912ac3839c1aedc8be6e952f56a4a90ef87b47189092b165c87386008b3aae1a5c720407f468346f57c657f09b9637a529061ab7bb47489f43d831fa5029bc5e8950841ec5c8b76a220684936002c58b9c61341ac18488943b2eaec18f02f9064abe2b9badcd899d6a7650af26369306478d51e6364802b8a58476e26f6b8fa6ef42958b0d43fde0cdb45d191c52f912b487840c39059e12817a97bb03709cff59581487287d51157cc122b83b1473e0f53e5b9b651e90bc3ee251e41a39f6651ca828c8c63e73d81a617040d97a17b395003c26e6ddd0bf7911f3c8b2d195f4f2260ccf22a75dc581ab949f81c144191fc02d2c51f14bd5ec1f7522c085e79097b5f459aa32ef4cd1a4e8684b3a577c1d19272d55691349916c7acd99bb51044c7aebf47f3454e03f92b9327ac6061f8ac527848ec4914a4570c456e871ea21afc26c32d724f5ef4398c8b65aa5d195489275ddf3ea8819fb47041fbe3f9f2b733b1f733565a3425f5ab79716d558239487db80500cbd3638101a4c561ace935c998402a82b088398b5ef003cd38a5f2a124df2698dbd69e2e4aab6db22e91d1f4cd62c7b58a6080ef5eb6959df4de54c30b83fe29875c3c99c5b5c9f4b142757c712de8dd1023e8654f833e474d04c0beb26121f9735f18b1ca47570b34990de003d6fb1015212a1c1217539f1f015bdd3277e267be62a5048492ac637d11211c2b55cdf5b3197dc67c82b65b780c77ea54337c77e5c52798ac497551704c7834ec917bb15f9c33e20557330835516eb5a1e54a8734efc6e9bfc686728fc5d5b26958c36a71a310821d5a87ddfe4602a576fbe8831ae2d0bcee386c2bec0427408ef55f13544833bec74672d837cf8d15a3bdab2cae20557eba76f2d0faee6b9ef6ec9b68fb8a0494495e96a6288e2f3ae4b80cc667b3d7459789128bdddd785cc7ecf6f18814420749483cac6722c1404e4e7cf7366d686365542845fa578cffc8cab416d12ddca5b837d40d5ad2c2f241e4353842d4b32996ea9f3463c8ae1fe3f55844330a0889090f0cd6fc9d8b8cf59158fa9fb91129630b1a635ea818c6082f42abe8257f597451e372847ca10ab7dd7cba17aaf03171def71b14d0ba6e30b6f9b3e851a340bffa77e3a7e1ef15ffd774c470b9bb6f2513847064efa89b6cdd39c811c7f2ef640dac1d4ecd8b28b0d57d311e39a2023adcb71a5a0b6fa314cbf6388bd90c248035d2dd3e84e21602c78648f06912e7c8cec8dc708bdca54d65efede12b8431826f01f3a2e3bd505c2e5cd9114a7b8874adbad54b1e1934cbcaebaddce44758dfdc37d74d8965b78c4a145c8381a737cfc6ef8b24dbfbed147c3e5c554ada60ff0e19031ab63d57948b00e038dde2bc57f851337dc00d4fc3f8096247aabe5f21ddf931bc60652a89ff58d2f7416b518a43718a41b364e09be34fec8728e8e6f647bb164349705a0cf6cb39924a7b70bf3fa6c52e5b45caf200f03b6100fd50fd348196538b77992c70b115904fa763fd06f31e7d6b0808eaf6370bbd4f635ffaa44193e0d20bf4e58f3086275e6c51e3a1edb6d2066f6e47a1a80c7646439eec8371f779a065359aef04a56fcb518712db63eab6aeb7e5587fef2af0aeffc147ab7b7c99399c437016bde9b54b445196ae984e0c35d31e2fed2127b4f7e9c6921ab34a49abddc6855cb203ba0502e7655b13244cf53c892a599e424b36c671fb25379e14b0a26ccd9a8b688de821fc9420559516d41647c7fb2a0ebbdc8532c62fa8c2fe284385a5c7b087366c96978c0d7c0d5180b8a43e2706a665a029187497f6239199c625e541a72abf2e8ecf623155d351140b6086a51b4f3b8478e7e7834144929f20091c3de9734a3f670112ff6cfcdaba627cbc7e184c218fe8a92ec55b9c772e61fb5be77b1108e3b3d62af0ade8976379d226fee4ac3638d6e9a30b969b23093ff9f039d2989758eb16eda8e4ec6ca2fb563ee3cb3bfc003be2dacda7497cf202592bf16455ea5d97ed0f9ad58dae78e32cf49b63789735de61228ddc8f04b9636f9ae9c8c4f5da00e9d3d33c6cb4152a84c12bd84f2ec9e5c975d8f37c14b7285bb45a182b8b6ecb59a7f4e2719e269f1aed7608072b86937c45c39a116c713567ad91bfeb3c272aac4c0dad109e21671fec349806b7d9a046c1675f9d608e752aa62d04cc3d7a9d4444772fd2fc3db18193bf59ea4304cc5eab9412707aded12896c6664df9ff3fc07cd822c18dfff980db9efdfbcca0127aeec5ed4734c5bce55705791a956c61064a9dcca41f013ca72c4b69ba2e7518139bbff82f957c6ee31946704e09573777165ac6601aea871ba540a36d56909b4be71e6315c99563cb5d7c16f9bba3f5f58677942f119d84fe7b0961bdb7e665c3eab1dc577dcbd03a6391681c0b95bf98ceeec601dff0474536d892fb576a4d88a0934429b0a946e6c63e8afaf65ccd318ebf2ed711a80ac625ea67984b74ee7c81ff80c444a171fd10f7e2ad72331a5b7361988164c805052a60e7ec46ec4eb7ec278457e4b963133c6b82c7170d1174ddf584badbc46088b3372c0f03d7297e0251130c5f1adbd0883c34e821c4a3a76f5101bbeb409f7f5f71a9ab721bb4467c437e9b37dbbdc5941cb583f1f7369b1d928f85be3b336dd2c48794081bbf213a576ffaaecd107328b304ad73f7cbdf75661baa520cb498759c878d31bdea96d3d49ee66bf9983b2ab37979e4b6957f7c47e2776ea47169426f09982a673fea41bf9b5ffd53da99e9093b977cfb2643f9505c2a94a798c004d9e5f33c13cc75f2d77e977924b5a0217e786d7d082abc01dfd4ac6034a3964f72e72c724fa1e94a8d7af5515fd28c68db795b33453d4625c88b064c56b6b0c56b05d34e4b3608a173be85347461fb216befa52db92807cbdcb2a887c02b68351dc0c2ac0770fcf30d085cf88bb227f5da6372bdc9e17a5bdebc0812a7ed8e76bf8ba770f887bab38468b12d563ac3154ef7c7089fb58790ec2c0691acc175f2e0fed56c273031d010aabb53f80fa677895c57f62de4a9c619d75c7d9ac12d84ec1be33201c95000f5f8ad8006b510e49834264b3dffa4c19d552ee7cc6b7227a37bea84264517a4a9ed88f37cc74bc4271ee34a136d4bf1d4d4f9335727a2b73641f45fab95c818092878d8e849b77128cf3834010d6e6a5bc2535376f089287bc2e7f25011f286ccb401fe013bb08abec3a2856ab501ec4e5bad98a7b604163c149a1dcd9227c3bd10b1233d379c41521f804c3f098f2ade8488c44073df229ec5c6adc173126e29882081fdb005886f1f4fe507ac571422c419edbdced5cfb7c080069bdc52cdcf655772925f71e959ed8a5100c45161dc96026b3c6545d63a119df0c2d7b4b23798465578a3b475d929a56f25b79699d1a2903228811574c95776f5ea25dcd2f30cef0c4f8d52c581ee35c3b9ad94f8a93a9ebcf387616c73e0b4bfd68df2dcb16e3c7ea996b867b27fd4116919a33ca25690446691e7c122e9dbb5d5c0ea5eb7de031059e364e4117d95cd9cfe63843805ceaf0fa675f01d359ed1e9ce06dfa3252364b32124c5fbc9f6e27ceb386b51459e8adfd891dbdda50d618c6ac83cd2b329fd6f8a660109b96feb8e404cc3dc3d2a4b00c510c6d4c61ccd698f9917797ba05d9cdc3c22096b49815d34de1d5ac71f8b32b4bc6a03de45dcaaf6437e22f482dae83c8309239b432e3e6c62b3dafcf3ebf261f19fe675ccf1e1ef161bd809d09e30189564d19e7ac89075108c290731671002a75e22ebc4b950e729ac4471bf61f751f20dab6698c9fd2259fb40c686b5196e6faa2e529580098f8a19e2b2f11fb390b68bddb11001700cdfa8a1f1ca33f52aad244b63c4c588a9c14784c46431a21ab479c42e1744e9c8cfd4638ee62db0e463bb49fd5cd0f407c9e9a4bbb1c381bbb515992b4ce08036b60e9c2015e76ae4d1b0de12c8d2f44c1d4a0666b27a658b778fa6beb503106ca136c067aaad4dd166b5720300bcce3051c0ffd6210af46ec24d7a29b1773bc704586eb4d831af3d6880df1e8ba4a58a247e0fca42896d305a8fcf93074d8c713c26792bebc0ce046b356d66274750dc28a07c2747d0881512833fd8b98d5c59715a0a4d7bcefd842884b9e02c0f8407064ee57bf2a7dd5daafe9295eeee9f1ccc12582d64915f2153afc7327b5c70649a8f9e69d3484625695cab2ab75ab8d01ee5e71235d04d70780a5c25485c133a50449ae076d5bd18e552f612e03ebec4969e16088df2eafcfdde878cb81a62fc5429eb67f89d64fbc5546f2fc75882e47d2b0cbffdc24f98048af581b5f1de2d7ad53d92ee421aecb82b9eda80c19867fc6664b7c6d6ece4b5f3382c36cf2945e0fd9342e33d25247a66b5dc916dd57e92dc53a788a4d4a320813315217ea8b73e5cdd7b068452d5d5605a25350ced9b88b0adfdccd9aab8d46c41e231080df4ab52dfb08990949dc56ec631e2183c67c7b17351b9a4433c293f044e1ac4c489d136e3b8156297e0e4a2924f22ba438ab5d85a70be64ce35ce2779282a6622fea2e52136b37788f0742ae9ec4494e699247b97ae51ad66b33fa3f8a88ab24fdb1a04b71ea9e2769fafaaf8040be17649b4a3128b4f12e4b336399882ba756c94a8ded8010e5e72f03848699503eadcd59a08b8804d0043294214f70dd389a7b202d70bc0b2b3c00559537ef17da2aa23d1a54645611d2d830be2119228694a4332a05a6266c481b2535410d65b52ad1e6b2a2f8d0191ff627381039b56fa60c7449eb650240de421d2670125b01b4dd4ec6cf7c1a55d0cbf2409039ae01198d7c03d4e426f9cf837ddcfde6a9d1db089d8b2a8299e732189f6de72ffdda97f1f6acc2e5ff49eeff2ff4e8ea851de3a78afaacad0748ef32e46e70fefaea7a8a3951806fbf2acced1d6c91c7858485f6bc36ee542884b4f22e1e91cfb0e5d2dea458764a996eae2df09efa780fa8a0fb35c77d94bad363682255d7bc1c77ce8c2caab978b17e82688931a49c677a995e632f1918f3ddbc177b823be84366362bbb74c088253d71592df94f5df87d7925221ca68081ea5701a7d78c40833007a8a872bc7ca0dc1619f3a2aae7c55a07485256d3241be10a8f35ecba31db3bc68e8fad7b59626ddb295d135439cbdc4eda62089b9ae12fa1bb215b65950e63e288df13a647d52dd4226195e44f90298e39564df1119446259f909326bf33879cef90d69765f4e54013f8d18fbc66bdcf98c1ad793b015ceb2f943e1310dfc357fe1be618a799087ca7f34478042f11c9d874c1d71926dd00c47ffb34a02857fea312ab3df6fa5897356631d30b04a6e8fd646f7f70a44ac4a488bf6169206a40ef66f091452d689c4ba3cd1eca4ed0b7b72f6b2e51a4834d81759f8b44010ffde5f74ee0184980e045ee78b8bc1e7a6efdc3b0d2ada85f7473afe9c4b9f838540273ad4e48650f483155045e5d724224ec80d81bf635c5e21030fcbfd610a4e156c134b5448e7744ff60515fe2038a6fac6ae1b223932643b1fd858381072a76ed073643349859ecce13b90d3ba098e955585f8bf0e9a6cff1d4c3f888cd1aedc755c6708c3d08667040b39196c41c17364fd6b11a63b2f3e0c4d7f5706e17997c0f21774d3738bc3efea49daa22309657d9312df17e35a269e5f666cb4382fba1139045cea9e1c3226d2721122a77a82f6baaf6c60074ed37ab5e664b9e8ddfda97c31eaecd66a9eaf4e1729b58ec1a9915d70f351fa4f9a3b8f76d23a9d63234fb9c429c64b641310f75b9315947336a78687887b4f95327ce6344dc57199a7c5689d8f3c3d2e987fec18ca7b03dade335273e600024ab1efb0cb3448ff354bae67c44a445a5a34cc98c5310aaeb0279283525f3bbbba943ae8b1d830bec8555f82c55ed9fa06c411dff5117330532ec02e5a8bc98e83fa5da689a9d80fb0eb4fbaac7273481c3ac837496b6579a98b61c8cb486b4685386835f8ea89121e553b6d9d37fbd7815aa1fc51d4cede312454839e3de05d02c539cbd3c7e32648e3b0d1a6aa1fdee9f5cf6a1e5adbb5602c27a1da9e457c37df5bd90265a2e87d8863abcdfc2b226b1f0b539134fe08001f93fec28047271622e83a3aebd2d73263956ace529e086a0518786578bc41215f29760fc107246b709785fffa196b971b75ddbde4fc49400bb48c23fca2082a60702af2e640932d21e67558063ccf9a61a2754cbb4abe57afd93b2a7c5a4a83f126e56689baabb1f23daa8c2ad57d248cec9593487ec3aff63658cbda16f4ad51f688c4fcdf04342c79f3e1f4957db80cac4c2af8ced99aa4e5594bfa3e70172151f8aaf815adb4cf6d61b7d90dc9fffef42aca58ff696b1c58dab43808743b128e37d01bc0294720be70885d3edda0a3f025b3ebfc9159de0940af0c325d967e9edf5d940729e6b658f5aa08292ce7ac0f473382342f1c97aa865e45039c044f55c8f356583879dc890d3bfb98c87e0fca29055b002683145cb4aff7cc02be8797db634cd2752ca32df99ea762ae4381a25043563adc920a213119b1a7ebe62a8d0a89ea847d9b8937d91584449a4a1681170ace56d1db9a157c8bfebbf95df04128b5293ae793f467c790d4fae79a49a8e43338967056ab0a67a28f95a18d811b4091480e2bf88d16604ec65aeb234cb29527cc62ee0b40ff7406983f62b7008af37c999d159c970991baab854873e729694adadeae08e05e6da58e6c5ac3f2d70115bd144de4e1ff4baaa8650d96c2a2b3e3a873851f160ff8f92ce2015bae1f88bf00f297897dac3533ce3469c78257c9e6540b1ed0914e99154e19325d5769a086649c5fcd96176e332ab06b3087ad385e578041e2618f88520121f16726c898e7356a4474980d54506b4e84ff42a89f8c3403c3ccc6573c3b908f503b492601c73646b9ad9fa8fad0b18bb6481f2a071ed071f186593019cd6aad25cf1f12c776397d9dbfd65481c4b13712da8f907bd85fab16e1e0fd5043be31b5ee2d49d0233f367537faa278094925d57792c6fb3a2334e9a71f21bc6f8e47536b72ab094a8155b262721ab05a9d19c696277f4b07ba3f8ded649d5fac51b57f3ec679d0abed5a58e6fc7685df2f7de7637e03f015aa5dbd1b5f55e4ea5f2b9d42bdf0f303d437613347e5ac3f9229541219ec10aacef21dd28c7c8a888e72a2c982901e8384c12b3930ed7e970b02fa4631cefc240e721d686b4806f284c2f4169d741b02a8ff4e7bcca95f8d40701da401695695acb86660aef4b6ac3254a06facde4d1d016bd358d25311001cc6affebfa27a277d68dc1d2bc8d1270fac4baf8901d3893cb04a988f4504d8ddcfff1d558dfd40f34215785b54b9396745bf66fdb14363e62426130d7c5eddc5af1435928ea3c8e49610c4e15a3eeaeee3f669f4888d39f187bc3c187c60d24be4589e06343d94b092eb1ddff259074d57e3caed0d07239c221df7a0c85e717c2ec478918d66ca955c76fa5adcb7dcc4b14fc83cb7c2aed5b1c073e2a86362d7dd52db8b634f92e822f95bc288b5f93e3a2eb5dacd5a2c5ac79e3f28081e2bb47fe37d4e6b0a70eb2012326645bab324cbe86c610051f82bcff6e850a5175da8288be1015db8962e00d06b896a2809ea9d36d84b6f861d44102f1439c836ba5cd8e7859f0013086f975f17a9d7c5a21c4fefef5771e7da23cc2a00ee9f0bc08614bc69bd8b4bceea42a4fcf5d646b201704fd6b967561bf23cc2cd0a071a1015a7c21cf69094d6853e416fba2449cf103e75457515051325797453cc740b7c3d762984ef2a421b6382eb80aa15cba88f694cf49b69959d6c876acc141ac791a71b8c3024948255b6804bc1fdd7008f242f9742bf10f677a279000a195fc96554e33257752e72f617a698b39bfbd21872721d5157f0e61fe352149ee021f84c558b85780c2ecc63e0c01960bd56eead6e17166d5ba961f6301fd9de5e072a0187e3774222cb69dfdc47de038e925b8d98b42cbe893431f46c8cc8610a8ece3b423d0983ef3e57e6f9323b9fb9819d7d285c1cd14dc555bc56ba3155db5b837f1737e2ddbafc0c72cb4621354603c640d1e920d46a7fb93a37040f1ecfcd9911345a8faa01cb6bcff754dc78e18eb17f12253e95041065b44c4cda1fda39b4a2ec57168203b48584f6772f5f1344eef4376d092291465941fc965d9938db7314fb6e1f8d0c4f530b551f066f471570a4fa5243059c1b1b8e4dde92cb42b7e301b9270dd2680c49b8fb0f5fe857fdec455b01427135e0d40a7fc73ed5e820c1dc270dd547dfdcba602ed58fdf6b3c5bdc75c8ad5dc66e4ff578371fd1924253055107104d7d416ed1e618f5f78c7cd86c1ff389876e34d09be974a39f3e8a36cba92d57a49d998d17e57cbd8fef835b6c290ebf37819688f25994207edcaaba69d26ca95502220a7136e5035bd78875467539e15e6d40daa4082b0e86932d37b1279c4f224f7bae6a0982232033fbeef4268b6a42bbcf78cdc37e0aea81ef93c777948a7788d246889ad1157e57f7e47f64c0f59f252a6c9ab48c99208c14553db050c50f33a168d66c552b6324c1a7b3d71da9412f15e6099f351e83de077a01339b356d3bdf7ee7287691b30e1ff5b5b2f4918c99a71423a01eb06c3e73d35655c73295da40a6ed6eea5d69d0d553ffcb0cf7be603dc800d5136fd5899eaed799c6b12281777156e60ac27c2c8b4b3a335d6e7a5e076c5e27f653a58a0a21b202d88239bfd7bee2a129b33ab5409d54b1fddc999da3663a07ada6dfbeb2e2c9c95cd25c9450d9811c8b6b8620ea892a53c83cfe885e9483c3d79b18cff39eead0f02be16216e9c396a5b4bfb01c174dfda5391b7c1f38d4aae9da9e7f0e3b1e9ac06da59defb9d9bc6a7b181882cd7b6706a392a64abbe7fb0c2640139d75b07df80ef9f1c9b4a609de6619b526b790daa1330a927a97ee48fcf31666213252d2a2f3ab44e2669a03cf400cebffcb1315cbc1f23cb5135d9aa388e0ab91eeb382145af0ce78f29f8636923802f7bd90137b208513b213c345baa140ce6c779d5d36fb0cc91cfeaaf98c47f1786cb68730579b22a3ab99ad4364155f01d2f4612138fd8ffbe1d534fcd3a65505ead6cb494d3bca19818b46891250fd649b1ba3fa718949229a15d3826c0daa2e966559b199f6c8af7607e9489ee80823fa9a1bb8e3a675563085964358ad2ef7a47be309bea9c3d2f327c1f3960862558ac347476eacdf6b04b8d920af3622a3939fc6cf9f4c491ba23ab66f9977dad98465f8153d6a8cc280e49a1f2ac96d2d0befe2a6cbbf63acfb2ce09f350efa97bb82a0e1037044ad2a4db5d25e8402b12bd7be1ec2165bfc9267a6eebecb6ce2b82b8e9f4fd077016a98339e723b86e45149df4cffeab6a69c0608f4a76985fb1644c65c08cccdaa72ac5da5e36085700311afe37c4e31f81452031a4c0baba54e9f854aba898138b8ef81ba1c35fd71f66628be40f3b3e125ea54b4964d5752bd2cc42e2b1429e6422833404403a54e572628e298cce4c75d35ce106d6d6d7cea36474a725bccc3ef64bfb79d4b810c594aff9415ed60216a7b3a26281f1c6c771898b044c1da8ab8f7b6f5f80a657f3bf1eaa7cc0f6d62647106e072311bf362de4ce786e67d9f4ce4e3e4ec8b8d9af5c55d5965818c9f050997eda0a854a5484ff63d682b7776731a9e086bfd733019a9295e531a4bff00c8cbe934b56643afcc5c4b16d1982cd9e6a6bcbe51359ed36a9cd4cbf39bbd726a5bc07835479586470332db4047dced9e06b55287508643e604fcdb79b9d8acfd4a969beef9dd96bf7b766ac6e9bcc40374943840ed325ccb0dbc578d74688f2fe91f9a8520a28021741bc735489caf40c0ac2476f8dff4848f912373ead5cdac2e6c0aafb4e3016058d7c3e6fd901d291949b5cd1115634c05e516bf79187f3274b61af2f9e7b9a06a7536fd95ff9cbf38954662818cbc26cca81c05e601d2d75a7b8ab1a0bd4b7c05827ca8aad9954617ca66b202af87022582e9f771beb53354424869725b595b2a3812f2a447993002757013fac6b49fc0a45808d829814f4316417b20ac72bc8ee1152522a30eb2ea25f319fd206597d4d0bf7681dfa3bbe0819548590869944497e19f44eee5c5cbac637a754a61af7676f40838348b4404ddb4fcbb26fc44d174efb12b51f59997943520a36e049b22fa90d99f118d879f9518eaf83b35df889a0c852b7f20e8b1381560a0e0b713048a1219e4ef9692a1d91b7ca9e17d8b5003cd9316406080ea4e917a59d63e9a712427a7a12043dfb3e15f207aaf9a71dc19c2d138f3462a9308f951edb777b8c42fde425795c5eb387820251d969519bbd4849ef3fc2b0da33dbc75826dfb92058865ac970d0a1c13f0a080bc1fb80b6c9560ae6be8673a304754479d88923fb71b424b91762efba20689fce288391176ec2ccd344606f125938cca0924bf8bd7b508c3def2700f7579062701d14fc0c547df41fd3946d0fab484e5cdf1c7e04d63ed879e92a1e25b84c627bd439a52bdb35949bd621ff24b0d618a1cb98679bd1bfa034401b006513893a84d817c7ddf5fa58987fe4a24aa7893b09710cb2b5f93a5dde66c24c80e5061886d313268bf28a92e6174ec2645cca2efbf989ffb2f2fcdc9ddc73945e41ba18c6b41f7b3937c9a2d5b8e0da75eb044a84e15a96b87427c62be58da8be65997e4d4e465501862b8ed182d02e8e23507ae59c441d8767f266c7da2d18808fdcc7a139916edf9c3c630b4658f30e3cfc2862944b857ff3e638a591434021aeda24b441c721b449f685bb7e639eb5748a93bc82815399c4048f53b2c958dc7eeeec149f625e984c38069361803cb22eab7c886b8f9bb94e9710d1acbeaeac75bfefb1ebbbd2d631bda766500543e238d237341cb4d6e81ecc121726c008680ed8f353192016ad7657d00f45734de36b431c357de81b2c7e97ebace2f09142ed77bbbf87c35a5fc8bf19b34fda21629a3dd0d357580ddc6cef216422fd178915c11fa645b092e0c871ff8e1bbb41b8649b5abc06eff7943dbd70bbf4187135a470d5c6d68cd1287d36e0b401359a3d1cee76c5985eb92e5e481152be6156d4e773e25ae6b35c820131a5d8ae8cbb706196bd2d332a267401f32f47dc9b2acddd362bf0faa3ae9b0647c39d38f9ea5a3463b6d4a936e048cd6e493d54ccd61badbc3455fd63407d73fff7e83d0e6e52789b36ad39cc3d964f4ec89ce05ab3aca21c43ea7c3c97ae618f884f9ad616a48dc2503a6bd87ae603120ad2d4c02503b102942c3cd530766eb2d13ea5e6273919b72db4a72589372a458200697f3ae41a78f179cc78cf1dfab4359f008c78aac195ac22b59526b06da37aa129037fc750acd8c95f5ebb7091c50bd06ecf243b07771c127c796cc3ba0a57545bc1b22b47f5291ccf1c54759e79f8b2fdb6276aa18ba55a170953b5a2900144cefaaef6be9da06aea2d98c47887646c81151e5b4a864230af1c9cfdefe887f71f91e7fc52158bd52ec8d3b209029ecd3ed6f2b26cd4edfd54577ce39f16b3b7f711265c35612a2950fd00145ff31289d9982d5e1db6b5b73e70487e2b19ce603f84254dc95d0057716fcf0b63b334cbca7782cf284949b84e348b97fb404e4134bb97640d8ef83bde9e8aeff6a402b7edfcea6e9ffd2663f744aff2bd2ffc068fce9d744319eada559bf89f254545ea02fcbd527c80272da552699022e83d1d85097ef0e054b9c34968f9e7139ba049fc80c3d37e620da0093d6d1b36bea59fb66d606b43e1463b878937daa1bd4b795a35f3bce206efa649e1917ca0d71c2af297ac8b9746c831f1b4bc98fb714ce3584be69c9c147c5396d915c58a901e6eb104a3e0e1b249c75f4921c1ddfa8e0d2964f2a506025da967dd2bd36db61acbb685213470c71997db422d01d6aec7d66906747b5acde959c743f14666a19e26bd3d6221b4e1d90110d7888c1bc7e587dcbc126a56cd10d29b33a23afd6408a0743f321b62a78f5c963bf67c92818a3e0ef1b4abc905701b58c0112821249fb01c9fa39d574143a0d1dd3e6bc5251cf7d6e3725ac2bfa268e2fb77ab4cf4d749b9c35285764153301e9813bdc457c1a5c7a44369485672fb3a33375db2acee51412df31bb4eea866edcaeccb6d440444b6fcf9fb7b1618f0db0393796f05e455c127715cb2d05a49511a2dbbccb8b1b92d7d63a3cd089658ab61511ee64bbcfc92dd0d1e182957b4d63e1f059be759bec016ff304005a2dcfa5006f50515c7689a1723a32a919029de03dc86e61756449c0232fdeabe4cbfa8ee192c832617ee432cfe06bcc4e376e116d48e0f4bbf0a5135664459c1131825340100e9baf0f4ad3450f26a211436832918609e29c52071df942d3edd0f719c84660680e826e37c81b35e70fb8073b34b49e8ab8bc32805676afbb4ed24504c382df01db5cf8aadbeeabeb7a33c1bc31812620673b7e8d8ac7f8eee8911f134bcbbd6c7bf163dc7964676fd794174d9c40d7e0f30dcba2d198642f3f080c6f1dbb560709de994f3633db2b356f05b0f005497c773e32c101f9ee6dd7a945a06e2ee2bd7098b4673d3a4e8ed0c0f267df3dc7c36260fa67205cd365ddc07c1064520d38e9dde24ca6e3472672b4e37a1d41376b01bb6607bb04f7f6eaadd5f62db0e6a8dd2e8033768217029203bc7350e3d2ccfeffd75518c43b019f192fb289527a165d34c3b60a909a2b95acfcafd315df85c24f4a39cf8e8bb4bd4e37855fe0b3127b955c8b89a4c54fc505533440daaa03eb9bb9e483294a08db64b22bdb67d2206c582742a38d03cee42d977ace1e0e93e79b2f647444de5042a1a68850dfa5fae89eca933eb6572317a3cdaf89a300b5ec9a6c12dafa3d02ac716a7b068f3df05c7efa1e75546422fb8a10b168d29c950e48e24d7531593915bcef72227765173cf11c4e8b9c31ab762fb32bec23e263817b2b5a5dc16be806b5452ea856c5c603d0c3e5dda1eb21d3f6a6eb180bfc01f815933f88ec70eeb1c18eae30ae262ac62d44564e16d0b202d84b0595917dac33e01007931cd4b75abb675b40ba4b5f96d10e7f0fa67a915aa25e29914deab9bb988288fb677291d4f46334aad6ce42e8691f514452d1be6cd29da6ee982d176c4d03c4595f3bd1f34c211775dfd9439e77075979ce5b0adbc2ada5ce15b9fc5c97aec2b620adaeaf8a2b350c99f463c5ed8f6a543fa6e233a3a79a69df60b7aea8a3e2c2928f5e4c64b12a14be81019143bc2140643f09688e2aadcbabe8387540ef0b4c6ad3ab6ff40dac48f915af00fbd29c569805b5506c553ea94f33eb67f42cd207b2a0c8bcddede8216882e6b8c775cebd4fa0ce7bbdcfd07e112e9a54c5eb4d21afefe1fc4934221abac9b96a5f1164bf64918bd2aafcee4aca12b86418a5a84ac9356046595f683126003e1a01c4375996a3c932c6fe6f45b6d1b91c82c4d083af3707842fef89ce839b097c937d4d6f725bafd18f1e054b401d1cf03a421a9c61d14cb034c247acf9ae3115fbc5fd26923a775322491985581dc682315a552852b07dda4b12e848036309fd8dd4d17c342af43740078d6649ce33401659084be2213a9a2e0154e19f7487c006e46affc7c180bbfa35d07bc97da4d5d7b997605c5131ca2567b3740e30b2d6221c3f5eb06f208fc702c1dc268ed693e5675d0bef980293354eb96324aa8e477374648006854ed5aebf381b2d47ea11d0165d153bac6eb3098b0ea5bcd9f7615fe4857dccbee9836feb4e93f0e8002de71a8696a0e1efe7b270cc632623a842e4ffd083ffe2ba3e29f4eecd724d233dc32cd79a977be604b31dcfcd0415da3d8c807da52d56f5161b20502b8d75ca9b209d6010df474e5d3242cf18d114d6988c25fc1322fbb290a5bdf8e81b5af901d296a7f8da30bbafce003c88300e80f76117d05238f57ed7fde42f6adb4d9a0e13595bbfc77828d830bdb9e8e0c257fe3bdedf36e242a376152cd78a26baa220b9cc9f670f5c09cb4f96f27719bc24038941737285b2ef54b4da2530705bf4644bc1c1087d322f87892dd33b7b045d2d7ed0135ba13f30215da067c2da3d9b9e073355c5467a8a260d6e45814129151afa0bdefdbff124d6db5b96a96654266b18b3b89c1fac84b592a623053c4a59a0b58ca0a4876b20cf8edb5c6e7774f1855e7f36d28fcd220721784e4b1cef55ab8a3884a5c75d7a2774047f63c62482935879cd28e8372767431b5c686ebcabb6571e9f29031347ec39da28aa3f3b4e3ff3843467b7313ee26984af30453385ed870b6146cc0b919791506fc22c59c0ba6e62426729c4147ceae3e2badbdbec8082798272460fe3de4d76411172f0d608edebec171d3ce0c7695c3fb108abb44f7213545368cbc3e0f4841655b7dde44f6399015ec257f81d9bb10885fb7259326b1d12c1f24330c54dd3d7131e39275090f9dfeb63dde8a2d76c50a09aafd84b5eed5ea943ed2e41e268a644d279ec2f9531f1ad88a8d6553611e561099bb0b463b99792677007a398b7519352f141c2c51dd40848ea905832c0a9c224670402f0f28b93a8808b984a5cabf9823313537160b3a6f2facdc1f9e89eb0f10fc9e69e5b81647e99cf6011bfaee3bd1a7804cb8268c49a960af5f39a260b78e50283b65ba28e84a2a3199a1b6c22706a28fea37b95b1320a9fa33d0ceae0871250e4d66dda963bf89ccdc7d29f8d8be304c35ec7b0500f13fe138aae090fdb28bfaacb4a47b518f3df68b182194e0e64f879c3f2ce613091d48e7767eeafcf5a760183cc0f6c55fdf9089f68f1585928111d998bf8dab42de2f05071d64fb23d7a16db5e0f779abc4fcec8cccb130fbcb51e511bc0fa9bbe397b4cd44e96de92c5644454f325a8d2f3db7d412b5ba46b237b47b1d49d13adf4b80955192921d1dcc59f059e4315c8950e3e7538ba8dbcca20c1a3e421caea92a69bf935b10ff3b17aa9552be5d74064e9f40436c232f1a6aba8c7add7d536aeac1bdf803ab9a543bada10990072e7805381351c35b6e1458868d8d0d55c3b513297c63c29c5950aca6afb590dafc8f1b09d59f85e35bf8a59af8e4758bb52e43e730ee0e461d870df3d7bded5dcb22a73c298b7fb95960075392f5d5aeef90821f594ecb9dcae42d799ca3157a01733f3b78d3c5f6a5411c5a1b8debc7a82eac3ca83977af618ecbed393237ad3e3bc60240771073e045e7ce21931c2e8559f76b962ae02d446fb130764b1ff343d5c48517be65bc52affca519b1f1b93a1fa12288dcae65432e998e2905a119e87693256dc56e02a60926bcd3f8a77458f862712fe2d9d74fb791f23add9dcb262c1d744fc4fc371f68f4191ae53b77e440f314ae540a01af8d832c4f1ffe6e60b68190a1a03df30a4b8ec4d8fe6e12f245212720c286896133d426f9d464a5f81f3150d00eca155c3adfd14b5d098ff33ac0c59df4a782108174767537e24c4fd792eb46be8326204895590af2e37dcdf03e014a3fd9c1bb21fec51d1d193d7bb92763954a537edec07fba7045db3e10a88b34d0d3aefbba0f642abb4de641fb459644fcd768bf2cacfa14c19b099d1dda22f5d5d9e787416edf491494cc953b20e68f14c1a10a27f3fcad83f780420b12e983454f7ce88c1892d1b3e04a028bfca3b7a56d1d35018216a0d2de85952a39b5493ccd9ee3ef8b0a5916af77d68bf017eb149cb7d2da47fe88943e5ed8c59f690818f98fb550c033b5610126dc336a4d32b35ef9ae11e590340140f135d5fe22897fec3e7a6aa020476f33380587ced81985f1ba63ac1e5335783e194f5233e3c90c33e41eb829f317e5e7fc7cbc630dc479f79cb64384b11c9bb29be0d16a9988ab5a6462802d05ab185250b1d9a1030abf2c99bf64bc71df830188238ea404e0b87dcb5d16053dca2e191e46b539bf540223e3bd56f03d7ed74653c0b6fc525b5fb3464e5d726bf245c9a22bdfc9d5730f354d0827719d44786a9ba22b5e87af789e5c33d12e56b078ddad6894a9fc8fd141d907a4b1b3782c77b91c02b690dabcfbada6b3c4781c837c524dcdffc1d680c8b55729a71bd37389c1c9fa01e3573bc70f11c1bffa21b36b624467fd4f97b7fb5e37a57d49db207e491ee06c9e037b1f073eb60a9196bee5594ca87497810ad72c78cccf89dc5683d81cddc5ea6f75f8c1dd95c01b9acdeaa57904fbd371506c614833686de8713d3e6e1adb8872aaf2e0285d253ef08c2c74cdd387a06e126256aa6c89f071ccea190de480b0354d1b6c91a3e164e0237a196a1aba84974425abd5b43e7d2e68de0054697070398a74e9765a5b0611b46074be64802dfc673e2fade2523d41bc0b1d12a64a0d8d8fa546967f8109d1b0b880c5e4f18f033969be919f3b2295812c51d85207ed64b1750b3e2302cdf501f8c279098128685c3a181f29accef73dc0dded2ae95ac1ea41a6710d2f3009eb011f870a35cdc7fe6345f59aa426c0f114f0235aa20b0cc41ed6cb7c3961188d3c22fae333deedccb4a6d97a2dfeea942da765257b09b1deee4598d01178e6c076c2ad235f393fd17927cd922db2f9fec8cb53fa6950ab0f5e6db70a1eacc0bb6098136a584678c8d9346175167285d7027385786488e287ec72a89e2caa5ce5339d5bea0fbfbfb5644dacbcc3d600b8dd8ebb66d61898d6dda4148ca210f65a472db4a4fef0fe8ad39ea01a786cbe2d2b535aaea1ca01472cf01ca5a87cab5aab1ef253b6416120b671fa79ffd2bb4cda208b51ebc872e248aa90bff0a493da8d964ae5d0117fbe9f084172911172ab9d66cccf327e43e9ec14c019989c4506497e0a76628d7446d371816bd2c45294725a3f856e841a19f1f7a8f3c8dfb23e98687eeb587e2716b3c99102cd1c6590f5179988cae3ded0f9e104c46fc2f54db84a497cf2d2dec4f896e04862e4012b888f1e8e373219336c6193ac128be197c926a61d22e7d8b4aaf72dbbfee920bb70d9983f246c2245825b8ee1998fb13738d4aa77719db6f7a87625480c9f5b1c8d390f542477e9cde9906d1000678202b652d6f7b8edce12a3bb0ffc6f44d8f3b0b3151fb4900f459c725110e6472ec0bf67af0368f5df86db9da4c148b2dc3ba157574930d4aab8cc6bb201b3ed3152219dc262e766d3e66c27fcd5eb5fef2b0c14034f5d369997aa773c8e77d32f4cb0162991e8f32665bfddaf29b721250f9719f0439ffd2d2761dbd1f6f268d1d340ad39934b490b1e0eba3cda6e37207413bb1d5d578981456a96121c166fcb217ce38f747bdd470abfd2c9ac782bb91118e928798ddeb7802fdd3fa8249083a6b22eab8d08629c137fd6eb009f74e0bf7146f5e6b4afc9377c1271e617436a18878f50324481d6715bbb4e556bf97ef44c3361687ae7548a7fba4598d2cb6d3d19486b440382424b5bfd4fbc96dc7d537f3cf7ae64ce8a7e3cf0876728e8532082ee589adb71db9ad437c2394e51fcaced7f61afb8ba90d1540d7e58c61e40baa2d85f871c9fec86d4122f5c380340579a69734681f384e16e5b586e780489026b97cf323e190c24fa53bb4fc183eeeb37985bf12b6043964221087d2628914ea43f905baa43d03e692","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
