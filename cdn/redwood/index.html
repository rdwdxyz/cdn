<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"85339d5855dd126655bdd26d35a2335c0d9cb989fbe3c5ecaeb61df9089b5b2f9510b4f299407aa568f4f4f210fa96e0f616f4f46fe969a475d43b00ebd4131f5092e6889d651c7e0ee13165348ef4b85942c7e682d93b32f55756c0a96c1bec9949cac37ec84de403a62a484d5dbd30029ac01dae9cc17893bb37d75ca96b1bca1b18196cb3e96aaaa694515b70e0cd98714fd70b6ce43cfa0b570779d135c304dbb40472b501ddbcf25e16eaa57d88bc278f9934b51741352b50dab2833a88464070c4410a96e77248b7f47161c9bad849ac8182317f8b0473410525722b14d309b05ef38085fc6c961b380425ee1824c1164ba0816bc89e2206aadb21fb745096b2be688d15c50648ee470852aabfc5e52e91b067e501f73a47d9d25057aa194b7cc6efbc686e7fbd2882ef4b8b1adb5877125112b3611d5a000d102a79cbcd1c4828cd67712c29cba853a29d043a97d460509b94e981a547ed10d9d7d026c4dfb585e3b0d48001fe24a828d95f7b63f5789c5bd44eb357803d1166131e6a325f71272dfe2334ad8e6108bd02c13a0a474c06af6fb250eb25ca99a0087aa5ba7fc06365520f2fd0e3b4460155554bd87bd7d6ae14fc3d136cf6ba61b676434f4e85c98457b5ddf1199ea7b212078cf0a4fe354cd713fc6a1e52cff7072db236cb052d6f708eeb794a88b95bbadcaa9298ffe327bf35f6fdd9caa86e9d75436417f4a043f87da9ba08036f76ac2512d7fb63b3ef7c30eca06ae4335be166a23fb620cb439ea1ada5902abb2ee4af13e338990f64c8b4956c744602a11ab8a40ebcb2a08b08d06583a7a057e16089eda67825472b277069dbfe3ba4268b9bb70498af0458aa20881df201f50ebda82f1e249d90db1da6616f6b412ebe86ef2052fc45a25474b2d7640f58ca97ccfe68b8858fca3dbb9a38b5be80fc44e6df69813ef3616b20ef6b5b78736ffc7d5f1b476b3405b370ecf42b16d60dfb33366174a57461a3a7313226c7355baa44ddfe0cb083eb99854317d2ef1c625cf0f4944289b10ba21bd1c0c455028e80f15f771f7a05308806834fd6b259f14e93b004e52e1331ae3819cfa7bc7ff35e47f9a81ec0ab642a6a620a04a64d7dc4bbb180ba0574bb3e09e40362c008e2bfc813ca17235550d0fb92a4e95d929fb708ccb09c6cdf1a61dd13f448ccf59c91b84d90c85ab72ebe27bed2682502c91a966be827d3aa2059ed9aebb6acae06b8e50402f2af7d6e4f49b39fe08fa7b652ea2625503630b6e97061981dc5486e5e49ae03fc11ed46c002dc68ab724c1e00569716401587aac733c77d7bc5f20a0931b55551f595d92d19a69255d6c5f54d9d848fc9d2cf7aa1bf314fb45688a454955811c423ceeb03a5a13226af3ed9bf57526edbb556977516bbbd92b1a5e3779f92cf2cd7f1d2f56483c95df207f0158b0f13f8d98d1bc81156a1a7814ca519d86976a7454e29ee77753afaae95b1194029dae75527cdcb59ecd8c48caa93aeb5752d1bd0e06178cecf8e3cb8367d218607a19c0da87c394b28754585812e1538504731b62d0a418376bc392989c18a6ee70e40ccae18426d901ecafb2695eea6a9f38c2e52ba988af92c7bdf46a8c9bca048d533c326a7d36e64120ccb75c0c8994d5ab0df5d83aed9513309661f66e3c57757620e6d5ec496523e1531bab227cd8a6d8310d5490ee1653b49607c70ed39676097161a9c54f02a6c7b0e6c642f834c15f07906dd3f429f14738ac313c8e94e2a37dd6c3adc5bb93e7d4b6731fe83a7b255408105fc99603b7d657cfd24cccbae82ce8ca3ea71ce97a089b8bfbc0803299c3f21100f1dc0f1abe83ddca74c4831bc61ff2a04679e53559853a237a1b1beef1ff89bca328591353d49b9f2d1013a704234b51cbcdf5cbb98958accd46d84663b7474a6aa2ca33b055bda1a10de914f7341a5f018e271f22b3a8b0b6ac590627145832b32b98199ffd3fa608f08b0b5d00c224398150fa59a83e91f33a1bb91a861232d72672f6685b6e15b49595839bc54e6b20b23d4dea073e8ef057b09c3533e7f1294f70e6997a7e37aa6cadefb493e233b5c7c3dd77a17ecba012f68f5853ae1ec06e7d7ac1703af06ce8dbaa341bd17d6a7468f03ea7e560fa60f7d226ee2d93c36a0aacd95af0a32cc5e10553623633b7ca388e7186c23c0e501960aef19dd4874a8d56e308150ea0baa0517dd6f7b94dd7fb6e3ca9b7cdf5804388d40de13c537e6e19b3ab2ff40f33fe11a7107ab757112a22408220f8b5004043e6f24158a299d5deea8271236d8c5bb8d7f59d155f66c6678f7fc7b8d5e1c83a4761b64195c5756f3d63dc5c12a9e2de8288b658a2d88d7e11b40a727416c2cfb70a385ed881a7f6706e3272bde14f4ce7bf593ae9bb491157af4f6fb2e88cdc9b485cfd0cd93af1299756bb5c64d577d055826159959f6d63a6ad6bb580644faf3c88b34d49c403021ddc99b883a656e9eb4dbc9461a59de887c18e10259f5e96cb387bc6dc06a0ed8666c8e5522909810870071685baf9dd4a73a31fa9c58878e76005f461eb837c372b18641809d024ec4adddd2d2145d00cac437dca47a283386512b4360b214164d997eec0d8b883decbe8272abeac94946891778939e8181c1d8308203328fee5d653f83be79ab6ff883386acd600a95a10fe99e77b696d7ae2194afa4c665c3eedf905d35aced527fe18b5b016f062c43746e25c58af99a3ab349e2ef2782ed53c32cbe4a6c76d7f0bd18a6bcd5907832dcb0a7c256d2500cf24172aa688a333976b016ec49db92834375de2f67829e422b3151649b32178f1da30f1bcec4208fb0c7053bfdfc4ca430f431c81d91e0b1ed43b6b50c387bc32278d034050d720119019b1fd98e5c45700b8cf2d8b66a264d3accd31918a806bbf06a7c09bec24c3581c1146cf4291c50dfdaa7632ae6ba2487804b5a70aa413efaaf309317182e0b2c48d944dc2eed127d7648e6f10a0fa471eb8811768c30b0e580103a4a68a731632877fd3ed9a7ce7b5a20728c9989f79e73511be6201492ef8fc046a80be061407a696698eefd94f91d491f9889343f04ff38dcc5978d46ec2c6dfc03c8ca2f722ba9d1521d353aece0b6c1ec15cfd6227284e4127558d5e5d700130dde02b872dc570d93f2982f4983927d12bfbd40063bc2369f6d62fdd15236de85733bef1b83a4a8ff9231ffb92db6df1248ff903d0a82def062bad6d125ff0a20b59e45ff56c483d441ded649ab18df99c14311917da8a61d2cf9aac157cede3ef9f651a6b25c0d10e63edbf6965402a2571fa9d5ccaf41d808812a112867a9fbff2fbe4713a04f935d168f9bef2a5e14755ac86c4a7ffb585ed4eee122a3991770c86bcb72ccdf81ae4c1a577ee6ea4a6178c24869c14bfd4d8374f3d294e10d0700447c38b8a0bb2a25cf2a55936580e7c871eb7aceca9b448ef9fa923d5b42c8d893c183cbb406f3cc48ea1daa875a2b436f08abbfdc06302f83f01076bbf17190997dffa9840d0aa3ea77020759222a21dbd3cbae543889283347b5f494a708729b4929f69d652ecedb8c0ad6f02040d7bcb3347c40fafd229b8c0c91d7cf225419713d562a6c40bdb106c4db03f971d1f3d583e193bb4d6d5d6cfaaee6dd5229ac675e49660729dbe655af8238eaf67074459bc7370f27178f6d07e6eb29fb4a87252dd3574bdaa18ff49427467daa1029b08dbb078d0cd5d0f3472924744cc8c44e0876e9e5f31c24014353b9a5ae1233184a6cfc334e2b05cb51007221447110d207b908acccb3782c246cd7b911257524a4c750678af7ce48b53704c36bed58a33caa4389e92b48002276d290a7cf56f77785d8791bae2dd439eae674ea905c525fe0447f28e0fef1f370838e81dbd4efd8ace9d48b437cc9e40461b7f17353ae50d7c555ececc4e14302a5e9e9efc70c8bf2a662aefbc3248703ee26bb90f53b1dcb5735783e814c3265c25ef99fb026237f167da10a5b74443e7f1b1257857f18d5795d17c119ef96c7dc8bd3f6251c491a73c501f4ad59370746da21ae9b76cbcd7fff33e988c1ee3320b1b109e09f50e8a8f01e2fe018a1494f1bfa2ed5c5e5da0111886fbfff8b6065929088402f6e33d531f297eae126fdb7777cc03dd7ec66805189181adc1933a5569c2228dac76b5162e588e4c6b56d535fad29592a745dc56a0096443cc880b0c7e6d74a6bd744609a04b7f85244fd5b03acd9380ec69862dfe26514c39dbda5a10b7dc534234ffe6e09211a05ddeca4baf44b7d55896f3240e349575e45027d7f9b0997b9fbce9de55838aa3d193d4691a38c886a2aadea908e0989f6e5f5912b29cc7c55b4f08deefc3a67c39ebda625eaf24c18c57890534ebb2c77fc91e85cd9ab75f6c8eb1ee5548dffdb2db4279db73f6c59715fc8a433b48af172c978e7217a05811604d07f358ddd7843d0f9d54537211ef9b9aa4666d7fcc168c17e321fde98166b3aecf875b559269c14c98c7da1e88ad7389d21ef75ad1afb146f6a2959c50b39697a8cb12e53dfd377eb6faa6a0982251211583673e92b630f18d956089921882be1a6fccfc635a3b9bed9aa1a61d2fbb5673c8e335e2d3a6f0ccf0763940f840b775b35d9cd21e705df87619cc0e0e77f038ed6e50fcccd910d9a810e31c67f79b67166f2aa283c621ba1ca1ad178715f1e4cb9b79c3d7c80c6cd24ef3c98ca47c45373e93376a39c3b8a2d5611e6622d2f71c344a41d6126e8a06d15da20bdf58b74b11aa1908a5d79ae51c2b18300de8740e22c3073a6ed6682ca5f76cda18cbbc46135f5daebbbc8c96a4a85fddf803203976c079e06c167170ec2ac7d4318cb4e7f8fc49fcd30131c7bd6ab992807b69f9a83295b4b043da660f26e376de0298e64dcda9e6e966491c766f075129b5cc044be7572c65e8f6ffd35f0ec684f65a4371c83169fbfbe882d204dcbb2c91b9d259245f8bca01fc7bb4e06d8d60b23a7879fb9b135627954a481736c15fd8c9cc5109bf6ed826fb4a2b24e0b3583521d6a8a744906dd12f1be1e70255d010f5d61a6e2e0545dbfed07741c336a1d798d54733e47e23ed3bce7a185ef1ab0693c9ae54c2dddee2d3a205155f5e106837fd83df08ac0d9e10ef83f5e085ebc9a4b24c6b73c4a7e011c3ef7a7d99ed09b9fc62330559d34f5c3256492ae18c90f7e37d30afb4c07b2877ca6efcc7ce2c0831f6cc7987f2e2efbe8112ae50334fd2e963821e895cac4c4aaf96f9ab81bdba36c29675ea6c612755ec075568e120df20dcb584c78be09bbf139cc9bde82034c26484b4cbecc35fc0b4ecbf5bc2a67a431bc45b64c697bb813b8ce8a797aed1975308888660bd10ea193b40a816b26c223914775e156db409ee273b56cb72ca2ce69b4f04f9b446a978c4c0b6df0590258dfe7b8d1059398689b7564bfa4be0edfec91a0bba0a01d36ea5a39dad7e9d243970453f8e6e8c905e4dd36a9c4441840dad69dd3a072ba760b16db5255f301856ded5882d5143917c92aefea57146f9f9558a1a1b05edd6147eacc11b70532131cfcfa95ec037154c26e75c58c70d459b456ce2330485d97865d060a666b2760c90660b9894cfedf95142e85ed41b62ce82d381f57ed6ea7ec6b6a059eaa5de6e4b7d44b8af7a91873012f19d36af0d19ee5055ec234b95c11a58f5da98c26825cfb314cdba5154982f39ef25c5b7aa59f9c84807183e7c442a1fd3e38951ba59a94d5c45dae0c5a8127317fb95701da9721648d68bfd4f16ce5d71a3d435ffd62451f708ac22d8c4491d9f6c3e7f7d3bf159ea634ac9a213a6a88abf9f839d516c60699c2ce0f083efdcd27c8b6b955aecda373a74df8fc0e7608761d8a1698fa0c298acc8512c6a65332843980d9b906499932cf8254983691661706c734bcb00244f50bdd5d7e87c251f68ee946a3bdad217c49dc7dde4c3e726dfafafe0eba2c12fb65e6ba1ef3ca475919e5c841a4424883cb23839c76689f8446c351a235813fe1afc318d5a8e2c200f03c77483fd1f77157395e00cd2a11fb551afe761fbc99e16dbf1b5a671b6c8d380fa4d98e3bdf4be3feac35bd5d995b72f3985186774131a8363c21b96dea48d248d145eac27fc37c3f1d7dc7e7432859486fcc95326198654d6a2163ea2c7573ac4c8f98b62b33d9dfb5f01c3d2d611b8fa489c132027ca890219dda8b48c83177de3abe569f8557b4007beb623b4b80f1b7a0ad49089f0f77c881563c69adb6e234089de6534f0450fcdfdcb4b2c0d2722a944f523ca21e2c21d780801a1b476929481c6fcb98cd1303c28fc97e28d224a291e86f5b79b80d9192ac921f5f39981269e76754c8abe09555d2edbd57735dd0621d77f93be4f6957a87fab5a64b03e441fdc5db6710ba8e08a12e8b684b6b2778ea8aa3d23b78842c32b1ef82e3af9e54aec0e5443f958077d1028e66d47c06ee837653b1bcd2120e03743a0c4ed08efc0590e31dbae2d5a04ee0b37ab04280ed7c9cefd7188e571fc1e43de614baf94d55ee1ba7f5f86a12905621a1324d111d5197d2b8dedf361d29076dc923f24a876e1b45cd5cc0b4af47491192a017f0a35ed6a50bb99bc55e858c701107d76683fc5df593ad5157c9ad22a771579bc5bdccde7fd0bb5bf7dd994119a49ac77f5f9dfc738b8557222b97663a9a75ab83dbf5c80ce585f65dfa65bd2be4654745f86105894eb55ab2b29278beaf218f56347b8cc164d228cf04f6dc3d6dd85232a841332bda09929384e731b1b7bd47b2fb28a71ad1f09e6a33a66ef46e9964aec8d9dfb645398fa8ff940721d587b52154016cf9cc5beb11dc4b3cb7c8f098ab9c5cad8ad76038500f19e110e4628398507408d8a2b79c38344cf42c1da5c1ec6f3ac12f8ffaf845f1971c0dab5152be262a7eb704bfe3e701e668175fe8d9ec29ec83d3ff1833f00a9dac3e039782c2252fd19c5060f29f6d947c9587c0701e31391a0b2c5e67d8ddabc3594c3847088405cbce9fd3f4dc9e32ab54f074d27d0907de6ad7cacf5269f14cc77a02fa72602475e3b374ac695df9baff00cbe2148ab3ff65d96c5a5583a2838b3936a8ad2f31ad2511213faa18450ef26fb9eb22bcaee81b995b357f75728f587b0d207f305c2d6a40dbd08ef23dcbc4bc69fa0098f397bb0091ad75952be27051650d4bc3f0b205655e8a9bbae430e692007325543b40f350aeca5bba60918af9a07626115facae8ed730cedc72d983edef4b394e0adb51404adad8176630919efb068e4625cd7a5c96c1800342196a9b1c8ab1f890913ae1050982fd3dcda8f1d70c819b599fab91d5dcb53e7769c744aa2f6913323f7eb53d3f28dabb39b44b7279ee8c97142eac6acc3c602c22bc91899541178e0cd91f4d1b73e76ab9f5c7bd45fea22fbbda03fb6a8c3132d80fc3dacf2edd2351d2940484e0c5b3149a144b8ced2a2001cb25fbba4b3ccf5637494c04e7068bf7a7f22cfcaa6e6a3f4cbc1d7d9069f3b542229316b10984b9ba0969b425ffa4c534d20bc2a18a22744ae9f5b59a02d643a6e4defc8338bd51bab75cf95ebb35f8d8c335441237a40111849552cbb74fd61a40b289993825d945ca0bbf62bf2482b48852330f8ba301d896aaafa3e84cb0ea806acc8e5ff9e00181a00a88dcbf59200103a8694dfeb4f2032ee1d57018cfac617838b0789d1eacdb1e9435a255994e8e5e457326e14fb785f8046dc23cb1212521e430e6241acc8f1660a3532e2e78dda092c6fc7ee65d0192192b7083b272d8273fde28747bd102c0fae104a4aca7e4550ce74349b90943ffd5b108665ed4a257bc160453edddbc35c21aae05d97f0f9c0589744cbc091c85e12c99350892a69ecacfebcc341bc091a45bcdfcd1a793a447d322116776585e3beda856517edb6ecaa0a945450b62949c543d0ed8284cfbaed487e6f41041ae6b1cdb1a6d4ee38084a681b9e5396298597dd9d189552cca491f6bb9a9424338fdb8a80343ba10baff8c94860199fbaba9d343ca4cec9bb60c15bc4b5bef6895ef86e0d5bc6b778ab559827d0787eb4950e054aba99181c09cf4ca31fca4b4002e65f5e634181884b9d20713e75ff618538e3a0cbeb5f6f0c215ea5591e90139a5c8963379dce836f5d574b330d4ec503a2da6f4f612f47d2b11f87d25e6a09942b9571c11957dcab730e5f5b1a3cc36b5a259bdc55006a8aece8cccc0fb2ca18d0a5b03c5d3c18c869479536b15c8a6927944dce82a214c9393539fae873227f56e59f275c48269d935180b7431f597f3454387febd012865612e43d739932feaad561852bc81c6bb522eeb8fb0d52545734ec1782a4cb32d5553e1dbc09317c4b9ca2c11e9e192c0c9246d217356dcfa9ef4fce5b4ae2d15e1c768e3e584a0375296c1d43a7a096af4e29311da62659d0fdb9221fb683d59db1479bd335f9f1da5e0a2367a2df496d3607654d24a54d961371b1b72c925d569e53069165821e34903ad940ba634238b137c4063a2000aa11e8d4b908144f1e31109619b00756e70fee10d5b968eb827ee4925792c030661429cdc6113a77e0cb2735b5d34b66feabd7af06d660e6719f572a46b44f75f31af5f38200ef27ed4e2d9d3ab4e66470b9be4ef12cafe439cf8b75f1fee28e427d34166970c2db925c55d8384ec10528284c4831529b9cd9f6478a00cf002004bff1af61cda3bb38e407e2bcfb5b7dfea10a78d595da135e26b47c1f3c2ee610ef854ed8c4244bab896a29a323fa6a0436141d4c29910d8924367ba4aad7f86d2f66d200b834d13fc7e05b82fa7b9c7098fa29bbbd5b97875ce08cee69a575fda264f1a5483fc883c0afe3c284fe6eeabf1962bc0da3aee5ddec66d0221ad06c66787b5325a52f673a8d5a8c386452466a2324bfb594081a5132ea72ca52d56e174085ca1533cbc52696c40bbb16acec855e0d8bce783cc1fb4007ad36c50787f1d79141f064929eb58757de50699264dc2aff74883ea76c0db07c373a97ff380f2a1474fa488af774a2c42f0029f89c4b9616a2b7bd955b731b7857012dee04243b9676f8e34977f807d054ffa1378f75341bc511f4f743418ece7e5b605ac27da0d1f942d62df38bbdd2ec8761cf9db0462edd8c01a6544eaa33ca51cd201d511a99ab1238e94ee1a886529f891d2429aeb6e06b09a53d0a4202393f55f7f883544f34fd839d4c29e1f381e1696113c8d56f624a3cd8d853175e44fdcef8a1c571dee93947efdbc3cb002b47af17595efc2961fe91793566b166c0e4d73c887b98bca37333317f344c66da72b61e5779cca5f59823f3bc76ff3d68065010ea8562be77ceaf4775a91e662ec2e34c65bb25091645d7688f84e78673ef74c28322b1a818e91adc7efc8bcb0e77539bba52c5db59842de9e46e2665b845bf61af6d1c25ab0dae88ff81d67cae8a51884ee702cbfff7d55250f2da2f27541af39efd18473ac1a7d6fb4324eccc82f6b7bff243935cfd06d2bd8a73d8bb8034fdb45ac79813c0637ac155febac2543d4faadef94acd1698b1e53b9fc9e0a697670f93741e8795f1b6cd41b7938d365961cdc3d33ba0c8dc7d6d47f8ccbd5e97a54571d0e97d3b57f852063a91dd7f52b326e46aa29dca5a766e7653ff2883c2404eba22c5f9a8b1eb01e782178c3ff8b89a1c8668042d37009ba7dc8d1e64ac7f60f6a0ed4d4cc29c7a40c894654ff9997922e01495428f09495050d7b00336bfc6e143e4e5518f8919c47cfa6ffaf9e192a4ec3e40c9a81cdf7805c093a4e5bd71b3f6c729437115c201c262a78ac665b8001138411a539acba45ae2f300d701f7174294b8b33c8330bdeb35870e80f6f963989c6a538b8ec5cd354b514455c0032b030e30f4d39a3ee1af295821eb646e90d1bf37d5a47558b1bdcfaa9bd82f16de42ea62c7a0260ada600418be23231cead96ae9827c16b11d8c10a8730d87abde068e7a4f8e5323985ac5037b115ca4912d032c491533d11eb101117dc5dbc1284b85aeacdda277883ec562db53a565248a4d4a7a9d5c033a2f72fda955f98061c31e27905c04d7c92de74160d87337e94211fbd47ba0dbc64b3852fc559f921691298cb984c15ed9436625853c13063313f0cfa88c196ddf359d21c121834055453ed0797cb9f36d6a45283a13baad2009894070ed9ff0acc250825c24fc2c2ec9d513819495d1885917a1bda003c13242e67caa14295aabb123377208d5f2b841f806877ecf7c844a2d59f7ab1bc14f084dcf0d6eeeddbf12dc3a3325562ca3638e479b3cb90e96d9842145c2edb99ac63ee1797b6e88820b106977342a4881fb2eb7000a0c3925d7615d956919354f61ff0d28cdcbf242171db4174ffafe8f81cd2565956f9ad5292139248c875dd31a829da313b8a4bd6b1c4c6c609baf6a43b6be7cc2ba182bf59d80138e3d18e67e95744410498de83ce5729adaf06a751f1f5cd560dc43871cd3326133593b6714ab2a9fb95bcab387e9afe29abf0e420f04d14cbbbdd78c757e9e1b273fb9797c580a98c83d4d1938b5c8527cb65e4bb92190df54c82b32c3193e4f323eb54eeb8be1cfbefa04d715782463028e8bfe1843913b77c2d1e3aedbf871c10468c8dcd42d106fbae25ba150f4ad5675319ba82bc0c8554bf5f47abffee05ba84380cf9d661bac68f98c8b15f743f3eacc8e4f49702c206b1d91d7fb2d38f0207a6442625e128627c1b25c04df123bcea3da5483520addc13bc420482e6c728cfed75028759c62ce2c67a0f62d9059ba700b9a7c5a6d6c99429cd1f5184a8312c846556cc552eb8cbfc1d9bdec27329d56b8745a75884f731eca577e11bcb696b106d4a1a4f754394a08d802cd1ecddc69bc70fed78d9ff8d5b5c84d27abdd2eab9c5a69453f6dd95072321ea06bf2baeaa7b114f5bbea8a066e722ae68ef136258f4588da402c79f0623cc735cf75a06b5eb67097302ab17ca1b6e6357484d3819ecf7a54ae24798969a0fa7621c3a4fa309012577a51d8d1881a2a3d63b3badc1cbd2d871eee44112a73533da99311882bd005337c68b77723552d7faa4443710cc5e57b5c85ef8f88f687e7e2af545eab79847fde8d02a2017f64ea119ebe96219eca58c54495316cfa9afbb8446d8ac091983ad04c98ad61edd8a156506be13f31cc7d4f93a87bf2bb7c277d514f40a9122bab1bda57b0646f741851540c7471791ebac96d3d10c4ffa3955116c6f8fcec158a5b6bbedc2e7d73e825d11029d33041f2ed6306581c97bf7b5ec958f803d4b821b400319abf4687f88df2bc0a121600f90eb06616ac149e4efd0924957e0e0b1c7c197c379f68edc7b6ec86c6e9ee3250075bd1aa341c99c44050e11f888902d2ec5a3383a472b7e4f6b0c5b440992867d92d1fd24b4af9c102b6ebf26d1da23213425d477f001e566f96fbb9414f84ae09a9bf611d9a9312a39fc9afca5ebdfa9df771990596d0b3c4cf0e5eee1a2f680151eb00f42694cd6e6b85ff5975a834a8756196c785865d66bf16469621392c1737ec74f4d2c892e283ef5cf58cbf9c9b9d485e85bcda4ce1cdb5263f4a9a828d264bbd2f745733506a2fec0aa092175ed76d2d914a6a3d773e24281320871c5d29ac0552114cde07842e0a29dbff2f12de3a075ce19f1baca69f6b286f5ea64a59ac529964627a4e607f33add09c25d785f99ad59ad97bb7069892d475db6542f0fa7bbcf8dde2449e1f9c46e53bc9f8b9ca8eb3e2de806095d44c07818b3efc778f448f508e549ce8fa419e5ea77f1cbd27c0784c546ba42296bcf54f731bb350a697c0f8ccc54dae320c1f24d9f3987664dd75d58750ce15651c2c6e8af89799d0537adca3ffd624e21dd6e8579105b8028a783f9374cf99d0f35fcdc919e635da76d899a04e7edceb00773788d5decc11a06521b5df964b2bf4f8d0344f1a44cf667f263ccc85db85a4927f0d11c822598d70c66a5f4bb0a33acabd678b9111c3605392dba9fd54b4700df551d3f637e928eb348f9e420061405f58eccfe75192cdb24082ee7eb4a624c68c06fd32871c0be7eacae4c22bffcc47b964b281f956bb729c45c1bdf97ee925e4935424b2172c219b6cb03ecb242a666761ea924f4e3e9dd5b20a76e22937a15f2d0e2a2db21d8fda67e96a04330531f0780953ad583111ae01f4859531ca38df8ab95f76d18d3b2559951929d9f3c7316b3de57e0dbf6d65e77cc02132504d2ff00bdf97963035d94293d73adc7c99f40c8a93f91e7f204badee8ab699ddd662f33a18afcbe98842ddd4e63dc165e430a3c9f0d53dea4980f7347efa3db4e7a1414dfae0328f59fabdfb5e2048eb4a4a23144271bfb6931cfe3aa8833bbdac4bbcf5c605e6de91515f4b9e42ddb8b42bd310a25fb6f504400df23cf5c6c6707daa253a6a19d082bfc59c7c937b4a38e42097ed3e368b14ade6c92d06166f12b2c62507cc151a8b2bc6f811c84986ad1230d0b6dc798e569aee0179654704f77a73846db4db6826b64f6e2b1257023154fbb69d494fa2b4376645f3c73b3c5f805db327ef1a40fcdb238a34949b0e0cd38e1dcfb13812ed2fa8a5ab075bb66d12c74671cbfc874814db7c79e421c4ed44999d397cc2b4ad5aab0a1492e786dc81f33b0353d56ede3f657d1a611c268f497f928bf4e0838a7ad531ac7bf8909e51f4c35aec73ebd15a03180cfe06c14816278bd9b44040b59ef1e31599ea18a38c7f4eba709a96b38f694b6b3fa4cdb0ef98a6c29601769f716b2d6f5db0d0f4da73bf21741a6cb2025ddd58c40ad1f4f2c24ce81d9d5b4b0979a6b3d9147ca8576c6de67b7a570647881107a097031adfec2db5e12558a9eaf076a784afe7d3bf734770b9d320df9d756f1a9ddbac9cc0059e36028a3ff1aa4f918568cf19227b2a1841964b3e3f9916cdde339e15d73854eeb6bc485324055dc86f8d77a1311c980a61603c4ddebf92a96b147c1df4ea9d83a0b370bf5994f263fd565d894867c5efcda805e7c219a4f726d26a8b306ef357228b6129c97e554bbfdc63759f420b1c92b5f12546fa5ed9d0b4f202f48664b33705c94d3793c7e6cbd2578f277107508cf609b35e30166db7508b24ab9b658eed99d4314957d1f7136027248b7d0b12f749c64031595a4b047142bc93c8a760297e0fc819832735e6e629348480ff9c07742762856c0669be9303c862b99ad45142b0c8e63ac2db2399389206aefce925564fc0d325cb5d568431b6148aa11e89007e44f657887cf81421e1cec97b1fe1bf394414c1445fba3f0d8df770e91f0cfae19332233a4969b184573371de104382d33a9be234b1fdebf22a559380325538a6b64f6f0c797caa05d9523219a306f0dba18ce1e0699577d19e90745be9650c2245ff13d39456b5e431da5d9ab46de317eccbe51474d9512f0acfc42170b1c0c8e623c9d7be49a1226bbb045c37a1fd700d1ebdc6524b8d86e95526c51dbf3c1c62f290b42043d540d478e7b0fb913e4c970f01a3f9a7afa4410bdf21ff5b2d4aef5dd1e325e38362ea27ba4b7456ef0fc3de7d2aac2d45606d9b5fc3e2c51d3e916f306f868e11ea9b130e31e571504d44803a9e870efbe7fbe630a63bdfe60d390872f078a4854f12bfd9d972d9237f2010127d58ffe76698b096ead6c78ffeef6cffe20254b3e522be36fe893d0aa03ddad19a47042db9e4199f76bc536106d4b96d43e6f70fb5649a5e7042ba34809f762c45bd43f8fbb6ea2a4d5801d74edd54b518a3484e79b651a85d0b4b68fe15588b93a2272124865476e67631e119f6e6353ca6161ef6c33828803ef59b23d220d4487b4dd864a53e0c299316ba98644faf959d6dbbb4bb2f59ef1a1b46e7226b12ed80b4b135d846d0e7895453c9fffd7e369cbc77a185f85daea000b7f8f28583f139028634d48edf1c35d923e01b5ea5a014da31ee8c616c776794e16a90982c1173a98e62eb8d6c83be337994440198ce87ca2670b041ac538ad9dfeec910def2462be6d2a1e0e7b159d7e548a4ead2d4d20dfcc6cace27d6ee5492d07a18fa13cddecf5b27138bc8d2d5f5ad485df165aa04c3585d469880957d22c14b66fea2d838c8fe8bf27f26afa7b9e978d0ede839fab2b722492b7c726b75421402d96987fa35bcd0056761f20e787a051805f6aeb36a58a6a001e70df61a78484ed7bd5a76f174ff70ad13d72488e54579960dadf16385bdc354e56f8860790bb928c8925a0643dbdb95822deb8aaaff13d98c6784c2529f4aa362343e8283ff8b94caf036befdda9ee099269d4a25cb754cad62b76bc4a29fdbe23c874a8d873949d594eb8ac0998a54649ddd20b843a68b4933b99419805ec131392632f0ea020689e344db3236aef7a420636f8d8019e13407201c916d38a60bb438b1713c6a8d9422927b1ee539f72a7a3788fdbdd1ab4a793588ea34fb33cd0a25b4ede69e1e297dc4de03246a3aa070899f2a434492bf5e44d13a77757ffbc788e95e2814febeb220751dd0f4345a19a803f39c80981daf0fbb7de247080224e947a1e6e5c3193f06f5999c7fbe16ebecd957e90dec907ba8bb36ca9f66d84bc3a83312052527d2408e941deacaa0d5986ea47b3d208d633e029d8bbfb4707254854a255525db89cc984002b33ef9361cc42bb6e54be86edc0bec9145ca047959ff37aa7aa6ded1d4f1fcc811a6b850a8716ed6a174af6b01c8e86e9aad0f64ac26796dcc7f167bf403c9aabe3dc7fe8322a0834df9dde5b7c169569c87b7cc20056e1bfccb261e772e98a4084647c5e75b381624f9254bf0b2a9c9b854752240548efe5e509f563faf255e699e3b45fde06915c8fcae86297a609cf74b10135d5f9df5edbbe3571d488fa86582d1fa39b62c68ef2da1ac0cb1f05c1d76b8842a5638c6ef6da3095ee7d9ec8078f57fbec700701a2730fb2ec80f18ae64fe4f0b710b97d1878cff729daa01e2fd5263096cacce3050e203e77dfd1a6b57e5829105e471c72452b3a07e2ef3bf58a8e45af6f79db733fadf47ca55b160f15bf97166595b89663c77c9786eb738ee289805432947d746eca06bf4ce977017c773b36955c99caea4bfab1334bac7cd7f8228a02c4fd188a07aacafd701996ea22b068eab5a2da37a7edb330d7a3f6aeba1a97f1666c7de56e12287c7da2a33c8e755bff4373b7c7ec8be8be5d810b8f3a25d755aa0b8cea629b4496e06ff7441a17b37ef699ac5e4f1f46c81201f0258ebd5933fb82b67353fbb4848234d54ed523044cdbf88908dfd380bb898c6a4194a0238544c0fcfeee8060ec922b52fe10b2557c2f4214a6ed8a8367cc3413881cf871ebb0cf0e49349a6da5f9b659da4a34505744e99165e14fe04db7d81d991147e91b97cb0b67975a8b05198ef34ae5e7d67f1b0936647ce3355a7bc08b8788f8e609e317cdcd6a13df79c743b8813cf830931c3b25921bce83a0d838b1d03ea613a4fca66e4ff33ebdf94b794737874c2fdb9f4009ea2b2999f1ea9e9034ff9bc42edfd92dfa97210a21f588a57ef1c635602372dc7ccf17e607ccac24748b302306f78e844915b4cbe87f90c94a8cddb118a6aaa540192265a042bfaada8897fa4d12f3c4c8b0bfcf6d31bde1d88586be0ce072f0be223d2e8a2450de04751f4031bf7a2d97d32e8c9f786ba0fdf359206de6bcc7cd5aa3e474879323898abfdf0c01ad88cabf3dfc61c7c377096931aaecb928db302db83add2b0d261ceef1e0992009c79890858d915213ba0234bfb866e725762815b5490045a2ce8ee08cd6ffc44b6f0aa0049a996bc7e2f72edd54cd9703ab7871dbfae2794649c18adb9914d740320e16d8e65dad43b048429d0ab39fe411aceae65f5a631c3c8b09c1f47a4064ac72f98c8077b2b005d6bcf86df171d216dac81634d76af7c96be90853a3743feabf85f1a8c5994c473431c90467f6a99645578fde5c9e1960fb8b44db4c2c3b56f75b64c99fa941e8609661de577d57c0b3f3f6fd703140d0f51d05ddc8cc54540709406f206d6c8aaae5f806062aa9e92d27a9828193ead308786992b7aee719160648cfaf0c22c7f5419c2283d6e3acef4e7dc3d0fa806ecbc6fdea83c23d72fcc095e524c320f4c60ea4793cedec3a325fe4d3eb2ad9a741f126c14643cf26c96ff9e1f80a3e9dbcd318211e631a470e583dc85341ea94063247e8fafcebedafff8d3a9ae68e87f5b10b2b1b6b21de8dff50520f511209cead2910c6cab1aad2be0598aa449bbdb67b56caed974372879b56970decf96d57fabe9727feb7cda5f9fe1810e61dcca2d220772157938e7d273db3ef5be8373ace75a023e1d5c89992aea98aee130f0ab11367ebdb0ab704df4bfb329bf6a7cd9955f382f7621f2bc5238117e31afeacf219b49511adfa3863e4e28515788469a2819f7d3dcf0c3db84bf1305a9f003037d2d8754a7f233f9ff24764e6bea307d7ad6e7ee8bcc1b9c94dd5d38d347891f313b89415c38a4c27c8512e94ca50db4280b5a109a649b46559199cb5882c4d73db01d5e7de0e69b2c478337da35ea1b6803e91e64f6024fa7e030349650db85094c19fd4eb203f2dcb90dd34a2085dc21b3f17e79e5534e9d6eab4c1c7932d36924f6d374a5e2861f71434385bb5361ad36c1c9d7cdc665f36a04038b72e82fb40d70f68a4d404ab23db791c3b3e5d166af3c62fa1b9df37b8b2acdfd31a6baf4bbdcbdaa3863e2e00901f2617c0705a3b40dfc1414155df3550705060d8191250051304c545d28a2900cec54afc2612d061fc05c174060d9e89535e24c8d9920cebde14848da3d7bdf02eedabc62bb1481f99828fcdad1560e3b53e463bb956017c47b012f88d7c3a23edc5b35ec23d3f8b5c15575c16d0f73f3472480347edd42ca5f1f574f40ac255d3b15774bdb8bbc129e3cb043feec9958b41fcb7f2cb17790b626a9865c6a7630b739215b0890efd2ce70ce9cb2ec97998df599f7dd18cffe0d7be59ad79c478e43d76b899928b0ec92193034cddaa356c6f4c8b08a874ea9ae1fde8df1902c758eb385cf57343a88d526b823e3c8565e13483fe801d8a818a733681458db72f354ef1c4dc733a6abd5d2e0f14e5cfeaa5bb6dd7241c7a4710aa370aa997987bb98a84f79ccb366f2986b8603a19e836ad0aff200ee57b3067156248139f38ec05a07ba5abb33ede173e55411f771beb542a0317b5eff831acea79d22c35decde12a7d5fcdc9c0f7e0eebfb2e272ba7f65d63fe9457d6b5182f6e374be4f32dff51366156f2b44e0c455e54627f3e8d3b513a243412759ab387f66b8a4d1f93bdb05a8d0d9d6b56d13d6cc4d147fd396021c197fd924a6c683a793c9455a4afba5d9baf53524b091932903062a84df298b3a6a6b9e1c60e8ea77ebfeb539faa132c992d9c1f0437014bf860b8f8b9fd739b2327e072d4f692867cdecbc982c27d7a32451e61908b51612aad36961fa389a92163e0b64608bc6117d465c85b635b6b740c5f804373ceff412690ae485a5a94f747c69ef691d0ff685ee4e4d74698ab1b8b4ccb8218a79871e3bdcc846e7271d81ad06646b8162bf2d093dc86f2caa9c024b53a6b9f42419fcc70d4b0adc629728494b902270325968831cc6d2dda7c08f3c3ad9ff2dca11250c85de075a6de72ec95a7ded317b9a5f1a88e2bde4099274bb69f8fde31c89e62dc7276a256708ca66c4003a384c6fc42a5acb5e71fb1053191bc84958fabc5c3c28b5293e50160dd81cf68d10c3d6cff28757f8c8ab4e4aa178f3ad6da5d1024d9b5fdac1c66054650efffb80d6f4b4a1fde0f35c77e80d8e0ba6f8f327d231974347246762702da5a2b3663f30d1e2a0a34467b0698845bf5fd8115a9371da715f0792f42a4d42d69afef916057848ca8ed30335d57a10e6116e25d8fe0a1cefbca8e9caf1c1bb8e22e34d5d37178bf8e722cd3ceb02024ee5128449a02cc1088cedbb902b50c387ea23cd4465dc54ad32533321f9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
