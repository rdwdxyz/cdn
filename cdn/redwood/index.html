<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5138e57dc86d18df67b64a5395c385ffa5cfd0c4cf2d9c60ccd2c9e5e3869e5ab29a8c2fef2aa81a576dd6d1ec47f532c85809298723b58324c50ee6ae33e7291b5f4987298936c73f8660e36743b453d9655a0aa53c1ac03441fd07aea11f7fc89a8a3ce985c9b4203410cbd450fd913d9f01b0c61e3c9ff20110316af90ea458f1b396e43b432a3209e1134b829e49bf66e15f28184edd5f7df28518b533b12f4d26b485655cac0ad9c40791a473ffa0fc0330001289ac3358c82f5951c207271904cd548a449377b46223fae75aa9c2bcb2f49d37faf256dfc440272f756788b529c7ac9e75a924f9ad8541333a14a74322edafde9db4d5fc3e614d6c52586a9bc26da895e9de1c5f535fee1b025458ca2598ea3eccddff44c1ef0c5bc91290eb9e6376f389b160219aa7eac804725a5db99ff8d08043a8c2ff6301f837e59f476d72f944de0bcc9473339c5c1a113121c6ac27215a02bfbfd016de59cbed7de8fd3ca3abd7daeaf3988d807f8964b29e333c76d48b9b513fe3baa0853cc51206c715d446f8a7d2dbc444874c7f99bbd2f0e9766d6958ce27b9bef322a552f61273b47f7ee66c5e398d8e5648928489b2ee32a67e43fae65c8f3a0a69e65402fad0433a9d51c9e2a8a64841b7f83d3cddd9dc63899a13c25b83c8b600657e2095152a289adc8514a3c6d1de637ca40e4368d42a419412edc0f46a8666cbbfc89749c71d08ef4e267ea3bbed8561ca321cee0481665a01c673ce9808066852b4cb48928ef850dabbf15d209a1aa9b043ff11d7a530e323343a1c1cc7d341fed5bbed5a80f400212351011cfd9a9a62858c1947ae7925b6af0cbf45a86863cf360e296fa93b1d22d524f7caf5964cbad17229876bff64e41e3491dd4a6b543c7abcfae7ce8329d0992e63a4f26e58bf09188438ccbda77d1ad55c1cb0cf9473ecead37d62182daa06c2f18dcdb2ab38c7a545b5157d898043cc46b36ae946585c5e0d289c494eeefb407b2dd5ded5568735758817dac675547f773c48f38c1dbe460c6b19bc3b4aeacffd536db0c18e656b2c5d7b3c8dd58ad3631d0c0209be9cb6cef46ecf4915271f3b453231ca8a31c9b926603c8327c6f2165ae0fcff02d1ce81b4bdd8766cd1cc4a332216d76f3256197796a504db595f03e1b471f99cfd7afe371d45cb23f7fd4d5b61080caa11c6fee7d4d5c20892692eeaf07d3b21395b6f0bc4b92529cac29ef3949d13cf94f2741e2875774d113577b779294835cd38b540587df821e743f21831fbea86c9560fcc6c3aff6d85654575470615cee0a480ed588e4f1b3af19a816a2b40b1cf444f1e2eb5fc7b9e2c1bb26df740d49f708d9304a3712b6de6202a323a154489f4bf1e4a56f6cd15067131658e6d8b1ddf065d51572274b0f99f8dc02f577b92c11f297f04998b04cd7609c54e325b5615f4d69490455a35b08f9e9285e72265101dbe5cbfa7f82287ff0b75682cfa09c81b53d77aaedaac2eddbad427e783a69e3314ba9d4b03d7c06e28ebf89d6733ad9d85310f5f846045f92abf7ff84a29cfb94eec6ccdcf00e222b1622845febf181d081cd0b87ef83c9b0a9cd8927ee61752d2f611594f42c6221fb7e9d76bac26efb4cae65de96f5dfae09e9f317c3f897ade4b79831d4d83180f697fe79a751074a74bc7992286dc2560b26cbd9ab31744b897c2202cbe7d41dc5b39a2a606ba57347c1f293e401c475d02760d688044a72c40c3354e44194590f4e20ca3b63912b32261e9ecdf63333593f89c897b0d82effac64470f7bb7d18ccbeeaac6b9f720428f19f2c264f4dbc4b5017049cdad484d55cc85e66d794c5c1882823507de4936f6646eeeac31d37e77222a7d160f5de2b58719dfddbc28f9cf78a8f9fb5f6ab0a86161d46bd1a410a7c6fe13ed158df4e8424d142412166b47b031786f1ca720b1f7063c581b662ea4d2c21ec6b354bf820287eb86d3f128d9863b6a0f5cabe2ae587a98b5f683bc7a97443914d883f6886580d1adaf7e1ac4aff58641ea87154b994c76404175894336044bb3f022ae5c27c86fb32313025e04f057d1ca07593561c41f3a74d5f121ec38674abe66824c4420a04898f9034804b4755a8c9e1a82cbedfd2466943564c4f5bd28f6d535966bb2439cb140430d7ac36782955ad72a0a130a1ba42c950adcd257e51e0e6b56878269ee0a5c09d87b37ed3dcb3bab904668529a29cd898279027ea1c07830a64b5d228ca959c0a563f0e6058219e1efdfdb62596c2ff4809046224f8d959557c30fecdbe42005e8cfe56764af10559e89215b3100585045e6680330bda0e657003c3335a5309aee7bb4b739b924bf8dc121f3c7fd2d255ba3dea358bbef41b9af5ddfcb8152a388e18ec5f6a2ae6951668c65ff9f652b863efdfe29c66f9a9b437b0a9ba65a2e70565ad909e52a7597c2ef97b66e5af1a47edf0401380c89f6ebd59fc9e9ba3c730efad09487f6c387ced3b6071d72e09251855e9d296f0c38acae73e6df4d0d0b24d89825f9d69918a78107b1ff8fe4f72d39987db4053d454023db0c2283ecb1c40e105ac203d611f193abbd6fe1267c17110bbdde3a8bbe7d3ed54c5222600b2756ca4a940cf37cc76083d2538f9e6491114201476e61e38574d4a897be9fbb22410fc86c954241ad300a02cf37c07cdabd8492b3217a85667c43d86870816bc96bafc8d22dc24b460b5b7dbde3e188a790d022a39cf31de233878112e918c0557288fe95365b517c5ff9a7b13ef9b5e9a29bf87e46a9904264719cc6d20ee5990fc8fcb17e0fd3f1e58d815ec70578aba54930852efcd055a1f8947a35a243ab098d2c8639ab0ffd249f5bbffa6d06f761edb5acc79249ad4fb4b5643aa26de75ffa7bf707551e91688ff9dba22f98afc43d803c4347df0ed072dd465c38f2ca9ef686c0589d6bbd4ef9c15eb2cfd6de8c5c9f36126ab9237e39959fa34c6ae7137396ecb5eddbf697a0fe7c403cc224f5ead072ae068628c75fecf0aff8ddaa92f44511810ee4ab2ff9c0cb44e963525cbfca95c3977c68338a9e4ed9f3b3b16e0f094b6ac60e35605dfb5654cad0f5396803d9896edf19206556684fa0a20f70abf7f36a78141e55d2369799a2d3a2fb874f05b3e8424e14e7a14a1cc3580687a767b4335edebb5672970b8571a25941ace10ee02fce4c5c87728fc1084797e11c8379d4ce0890d605e282a0a1ee5f288a69e4794e3fae137ec3888edffffceb380f402c4706e82d169f5c6dfc6eb1928d12332a1af4104f2ac21d3e4fb7613da965f59eb25779c195e73b8fa1186d7d9fb97688002de7ee7bcb376792909a12999af83021582c28aa3ca504034437bcee9f85ab41f61957d32c19d8567a87ee5d2a53f2e04cf0bd10f7f2de9a426eb7a9dec1c2a988e90ba61e48fe706c2158f929e34e6f2707070f0ed3bd2f6899c8d89f6ba0a88731d1454a6558f6ced2058638c417e13ba04538094e24d45b5073905dde456c2f24933d818be31777d5614d2f189830b19936a5768eb74ed8cb117112594c461383c0299e64a47d6e6ddccd0b1d7c36dd1e75b0acf828086079a7527b93bdedefaad545767b7f98cb8e41758f0eafa09a0916c47fbd0a168a1708338e791b17c6ea8a3131e9f97e091c1c659e4bb0d06e00e19c215ab584055259724390e2409d0ea8cc2113bfdf122bd9dd4bc98bb20bb7705d0298b6e114b2ab28152ac22ad96dc0fa8c967bd7e23aad6b12f1696b343f903215b17ae4ec0c8202910999c4eb8c5781f79348007260a68bafc0d1a272d5ff801eefc83c020eadb86c503a67c04d3651b8adbb63003147cab4dd1cc79a771880eb106ea8df48dece070e94fa456afa25dd263e0a11b95878e31e278be3ed5141b98becf8a18a8ee88d7362bc4bfceab01accf69b237112c7ebb6436f5e86552180b6f18d3e3845aa90fd89b73c60414abb7efcf7dc3e0ac5e4b6e07f4cc3a93348ebf3fd2337569e89a9deb505bcd8cadbd0dacc2a6501a902cae0dac533155fa96fecd747bb696d478a2bda6f7913b5304f6c9ba998f3a35cd787cd7506fcd7eef2dc1f4bd004b30d2481dbdff3723f574570b89dce4c7bec231adccf62898ef1dde7313c893a28b0225301e6e8096c63d85d65921a39379b485ec540e1ee7c48861c4131015df964f94343e12fd3318c7167439ad189fcaf4602049b66e3f28e6343c2defbe0629721326b1af37fc6286239d2ae3cc82dec536298ca3cbc81c47dfe7f7df85ccf3019112d3ac5f770826944919f131756fec94830c5197250536a4c5492c6a71dde4091365bc4f94009cd763226cda1e2d6e055fa836211a93672d52b5cee4abdf9445c3bb6192b0c7a16c422f6396428a43b0527b8191410f044715e7ed246b67323d2747aa4f235908bac5091ddf521eb5db3cfb498d1e57fa3aaeec595bf69d7a8b1185edb320eff1607272d92598d29a5248036571c45537287a46403073a7af0a86f8a6c40b00d7f5e281a6d005041269b1ffb372055dceeb85b70509807cb63f83546d04172b62c557bd9d6a9e27e83d63ee294c5a707ea554abc507976954f34626e5077d360bf998889fc98c6c7f3902fd9fc63bf56a27eb27bc1671b426270549cce988305f5dcdc1809fc62f10a8b4c0397d6c95b1fdebaeeccee06977d537bdf492d455991ae4fad294aa5d5fa927bd83cc636a5497226e1e3edf8237f5a163284760f23537d5bee34acc0aaefda34013a5a2e655f3a9460e3f7348c1ef206b7f621bf4556aa6f2848772ad7987893fc312f2f83f8adbdf94b24961c4cced95a5751e3f8be59a982e7fa8fe1435f35b1f962fd9b82e7aa70ee5c5b830dcec9e7c551e30b8ad1cf91dd60dd8378cdd15abad0c8492c1a20e373f4f26034e2885f6d15d2f0f3a8b978d662b966cfaf6b52f081ac316264fb658ccc34b171b31132dd94b3a0817aaccb2c633d469956bf437c835ca30de86bec6a88eda159e1784f8fcac6b0b263c66c7413307bf9bbae84ed5356761adf3272f5d5e22144a1f75a7eaff66c91423fb9403203c73a711c3bbef5f10d0ecc46bfce29aa82fc8a8565f69ffb31ce18b8896b72107a37e6d13c803a2c8defc6e632eb0e7f200668814b4df0899b90ecebf9aa54c1dd37e20660edbb6ab05f1c16b1d6ac858694660cadc9ca4ea084db1ed3c7625063b07b5bbeaddd87bfadc0714d930b8eb96c42d4292fd30f81f42a0b485f4fb251b05ceb743bb92f8121d3d2c43fb1dbba93e9d09c81c9d65f5aaaae19b9ff84cd3856fc131955f51ff47f228fafe356c2d48625426e0b0ed7851943c160444f3425f73d1905d3daf176d644a1fe2987c741f69850cca2e13de2691bb4fcf7944f1539c5be261dd33aef20e71f4173ab58ef801d34ba6a444a134573d46280e47cff4e2beca30770d07c0c84721778026f9b558e342c23c1f7dd949d42365b4a895266cb6333f9a1ea555929f1af7e5eacaa56221a27adb22eec626d06a339fc547bdb285a23d8972487f0c7b6501e527f0f7f67fe7dee2e6a66d3175a1b394f9fbc4708e20f90664e9dc9befbb09654995db4444000dee056e4effaa5852a642ea9d23cedbaf086668ca16945c30189c68993d800fb4861ba368f622d195a26579cf87822f5738303749c3f176b8f9a774542b2849593fc9ad4a2cbae17a623dbe1c0029e54cb66f89faf8c7cd93abcaa5c09f0f705737190454d300398e0f808c861ceb9770bfe40a0ddd04d9cc6a6cc2efbd3cf7dfd8b57447537f1ae3827ac4ec4f740845c5f832e5d2d5212162aa4f39156125f7f94693b69ff9c08bd33bcc58c7c96fdbed1bb5b8abd3c05e5bb267ba7f5ab3eb647c8f802c154106d6d0c751c2cbca3b40a870bc7f6d5547ae8080c4d0a09c46bf2e2c7c9dfddfa4a71984cf45ae886b05a283b79355dea1efa20649d171f1f93d37ab2286c5c4d8495a2f456a840956e7f958a785e8c22831e2b69423302fdf608ff18aabc48a009f0d16f5cacbe3ec8547ac570966cac03e8de70ee574ec3cc7a1b49491b71177a84bf06053b3d5fd3877f196be67a48cd9dac58b63bc3928223f0872865e52c854886adbcc725947c9a3be0d4af8e188866182ce4dc7ae1ec3cef6e392aa0053215e1e1e4de0ad85ecd5d67ebe49db242ab16f9f4821fd2af873610e5ba4f6e962b698c26066106e1830c5c9025b8ffcb17acf202f787f246e064bc8b02c8b6ad33174f0d6edf9a25d745582a083f18cc4191b0cc9bbf1fcfcaa32b081e0255513ccd2c023d444f475c171ea416365a5b1541de0107dff10c13ecec7f3ea174d6dd50c27a13fea9b5c83a203954eaa1f7cf1ac43678599f40d1085c2e3a4424b3b27ac29c6ce71e5b7891f33552c732ccbd491f3a7b26e04f2ba9a300e1abfc88e538c37ba3f1b6d02ffbe13e8ed87307d3e83904e9d8d267c6e7e62e54afcb539ca1765de6024565bb2cc7be4f5434732fb627cf7102168119bc4eec531574372f38d69e34ab1c31c59b3b80c2cd11d93db39b85a0ffd4b57016c283a04213e7ea67d3d57ad1650e4cd819610a768264722f1ffc144b4299657f048534d7a50501201a5576c451c21af790baf222f292035d672eded3e0fd932a75022b11bf532c5614f90323358f44cf6363813898a4556099fb0b68faf864bda43046dcbfb39f35cfea05ff1a5c2bc8b86df31020c0a3876fe996f92be16283bbdd4749cf71d7c4aeed523a9fea111075022231d54751e9c971a039e88d3369b5df008c88ca3d24a7078ecada83d55f05bb394850ffafc3b66965762886933aac7cd10600d5620de455cac7fae9ffb2cb797885607ad7a606801a3afad164f75b3cdc6cf713d036521c79e8ea1b2a3a169952ffec19a087a76fba41d146f1527a0b1e67913d19da6c512a6652d6a0a872bcf680ef1f853d7c12166c5bfe2ea935e288211fe7d6dc2950758dfd6bcc384c768c211ca2a74c45cfe527ff8398a8588e6a3356026b94e1a3f97250f73a2d0e442bd1610e13d603fcb1724d42217901eb1bf3cea95af532dccd097f4c4cc7f89dc5235b1775bf18dd3f859af3aa7e56d68a78bcb312b27933b236995849bed01861c75d05397aa4da6aee7abceffd1357eaa553930a6f4b850242cb0005962be6aba58e1183750fa419a9019141d53a1d1a07999457932bd82aa3a8f9c2932739f4e17de2536692b9363d60b8d4509d90349e74ae4dd9b83c7ae715794caf195c4e7321f79939b92f39a464de8f27fae27eec622e1785714a4ee3fac7865b98bf54af8e0abb1567310789c9b57c97404558a69ac4ff760de33f3063c67183791a25c07d458f51dad36a94917f49a42083f3b3baa074474397df39b341aed942a98d70deac5b98f6a18c86a4d21624ede249c3803415a08337b6b591e61236657bb8de0dfbab397a377fe9b29d4a8b9174e770568cbdbd8849e6dedf21ff0d53f31632926ceb6babe90adaf4741401de67add1f37d50f5a69a27a87fb54875befb636b47e8b47f9a81d199c2b6184c7d8806a8269238ff63417bf1933ee59aa7a6d91886f3ce21f0501c26d1e04dfb4a45b95a9dd1af0a35f49e98f0fdef0bb8a319a7c5546e94ee41f07fcfb824292da03d62e8a4fde2dbc015c974851885f46477c6d7cac0cfd2b0b3b63f0d1b86067b85fc9e55f50dcf7d0f16f771e995f626563de6e9792de1413c052a1377b5eaaf01732366bfd98e809e9b6112639c42eb304c4bcac35ea5286e064e5a13624db518571dc977283b51a8cdaebf6b71dcc667b083ce71ba41b87987e5bf9f48e3776e3ecb277d1171c5dc0c3000a57e42d026a21cbe9837be3c61b8fda9749fc61d0686efce6b1379ad0bbaf553fe8067cd1ee1cc4cd1ebe58f7f4c2032ec13b02d8b6bd3a7652bd72fc5e967555b4b7a2c00f487f4a1b91feed444943e2aa61faced3d4d6d1db2c04a67ebb4b3c08de37e6e486f26719c2d85297b34336a427550deaa8c850aebb733902b8f115b2cb910074cf094e6a934ba1826e4309b30f76ff412d39cb734e2ff9d321f6680f55aa5de4abea6e7cf32e91b4e8fd64cab15cb4be1dcc0d0bc945ec2c2fe1cc78967670508fffe6eabb1a35bdeb0cd9fe0ba6871f33129c0984ef1b10fc639c37ccc232725702cdb03ff3d53dbf3bd8783a0857ab0b587da6b8d0c5a85cfacfd9641acaf3a3d53070095886954c229114d50200e96f803f231b247b2ba3ecf3113988658133fa77725e658f1b3d9bf45fa87f91d6ca9131d15d0362cf84ed578f18f40d56803cf14c36d624d05d90d81e00cddc85ecd6d7066d6930c7fb347e57cbe3e5c7d877df496e9d951660f9f57f368d2c1b881d7fd7677b98911a3c5dd4273455d61784404a0acf2bfd0864c52a753520ff6c3f9911e5aae8e7cb52821476c657d902545ca4ddb1f09df4ec896fa7e70d25a9b6d5fb9ced0e6a33c770d262eaa36ff7055ba5c630850fc9739ecd86a23408778f2a74c0cb8fb4628c9522aa227c4e1550c60b249947b51067e9ee0bf2822a13dfc48fd1db89c588e6a7493100780afacac13072e2deecac7e876f62100497e774173d241cccd6efae0308cdcbe83a83a89f090f42b3db29f710d69d95db043e87fb813278bf21905912b74803508a0d1fae408d8a6fcbdfbfb2aada4ae3440d718a6bc65dc23aaff42616fb58c2c4a8bd8936d3bdc0b660deafbc627012140b4922583172074e67199b1194f355137b667ca6faa63c091532e82aa242d42d2a1d5d24cd57c7958b401e9bea5f4f45f22be489273060e826566b003cbf76e08edd4b9cd4d9f63ae0bd562d88da0518d511a7ea33c643bf381a1e1b82334e379cd0733f78f7a4729a25a7bd323f0014ed41774f95e9efc2ef1d26a7f4cf7f56904cefbc3008a056dc663372cdc3b4a8b3714f74df4fab79ee739e9119c37db726339a97fb7276a302d3637933f73880db1f3a38d183a3514c89d2edcbf9aff830944b5a4d38f8cb3494cdb6f25d5a2c0a84a9ffe889c16b6306c66514a833414a7310eae2d68e2e780f64ae1c50c17f52588a4bbcee71e76cc9e6d84b3399512121fd9c2a190385336ea161f3a03c8d6072aa83a2894cd0608a5f16185d2ab1f59bf2ac68609dbceb36e41a927bfac74bb32abfd949302d63788a89b4679b43f6941da7535ae3ade6c7ed32926a7681fee3a14d7ebc6661f8732334619f029635c90ac3efaa1a3be5359b1ba91d2e30d7657b4d3102780e9f4d4d0a7ad5c4f7b3b9f58a811e67142196d03d0bf7b5ffe65063dd773282df1af40c2e9c7d4e3b9bfba62f4149a08754672ceddbdd4a3ceaf71bd36f95d9cfbbbadaafe2ef35249bbb757277d803eaca11e3a7c73dbef6f751d240c97ad8c93bce09e505a9f381c444e4fd2a359c675a1a130beb4d3e4f14a94dbb545366d3a07b5c5037e5bd371d75064b075aa6aa2735decf479884461b3bd908948f53201654e2530f5c333de74e578329c8ee308579568988005ace19c0a0616146760356454db0b6db00b87c6909badedf5b4fd43da2c381f8224ac82690be0282b0c66fbb93473c096fad79f3fa0ef0ea4a9c6d41319cf8075b9549e90df00a5d3e2df923125c0ea6ad3508df9c91de97a92baef504348082368fddf3efefd4a5ccef20504e50ed55d4fac12fe33f3bf49a699164df6e856c8e785ad9272a52255d2e70f87ef35e39bca1a57bfccf158181ee6c13262b213fafaa9c280595a9e32eeb9282289043acd020c94461a7c7de2d044138ece48691eb4669555e83a2cf2bdcd764fba985cf69641a35ec5d91bed4b414dc475ed8d27a4dbcba604fc31b1a5d1b432e4d2f6a2270f3c518d869baf5a335e0345bbdbbd517450273babb79ae83e3355b22c6c06228e575f766def41409593debd438eea36189a58efec876c8b0f4100754208c30fcf99f9e0e14940c81eb4246d2db84def21eb10a601452a0a936ef981b8c354243dbe421bda2740f65839876384edf9f86e188edd15fb5610c3d711167faf84f04c1f11eead8ef1d3042a1fa7d4480b0bcbdaf353fd5175e46fe29e90acd14baa41e308727f6a5dddad1dbcf42982c70052a1ccc3fcb1128eda17107c0930e3244e81e0cafc29b0d410f8fdb421f81271527a20cdc1292be8d151c878dcb1de6a90306e2deda226fe27e988cfb94eca62ee7b1aeb71eceab5c9b851adc9ac36cc441e3d5d907ea070284017e234e53c6ff999eb0f41941d8ed4a634baa44cd3c928144385c844f4fbe2d92684e734afbac5dd3d92df9b7ce91e5b51144f810bb0ef04b62ee5bd3b99ddf90b7da0b8a7f0ff6b93d98e1fb815fab6af9b0fa6d0276372a23","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
