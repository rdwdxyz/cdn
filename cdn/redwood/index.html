<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba096f829b46bfd7db347816d3c841e89fc3f4c586863615151dc9d2d8e12c2997c6a74339f93443aad0b5ea6996a2fefd242147c3e2aad5a9b96b67ab00f31f50e0880d0d0d93c778e29527c415e49c4fe05488f65aecb5752a87dff264018bdedfc9c735959a0610c31134b73fb166fb1021df350d8b6418088c6d6c3eda2f7dc39dfcad3ce7cb3565467c3bb80cac5e2107b2f1378ab27d951fbf8c438eda6e95c1251481c13a7d569f8d03e6c56e68edb5b46f74851d6089a4e1f3e16044cd16ed7a823625a8e73f507059cc2b63447ceec6a454f90bd5a645c949f9706daeb62b1ab780f4325bfa7227400223ab545fccfdde5380824fa88d5aafd7fcdb87dcb5262397bbd260fc8fcb840117e9045d8aa77719021309df35f43fc27170bf4138a820f89a301f122b0372380e01eebed03346388db962c074ae0ebf6ef833d033e64b9019866fc9b955e02ddb1f6d38757cca860786cc5dd69bcb3ef0299dbe5b571748ef98fd7ab010ba962e10a5e27f8c3e04d43ac6c80c525b341fd9dcb415a0e3ee287500239b47b255cea3f6ad54da20dbf779eba7f09e3b3a4959b58efc74a4ea82a73853d0a984c57112cd34971356a930529bfdab1758d6c302ad885bdf432216b0f60f6ba43633b782f5088ea8ab29f39cde2a99d3fefa6e705326613bc695b2d243d515d4737f3876a0b614ab5f297e1c0931024506182253194c04b758dbc3f5e6ef66fac534a134745089cf28b7d158369da3cdb952f2cba869c884f11d878c98966d01da1b2dba950b84ec95580159f19c9501b282fdd1544d0caddcdffb406beb2b2150f69c3a6d663142f8b770e879aa6befdf232ecf8dfa37ce32cae8cc8c4b80cde32aee75246d8bf474bde39a745aeb0cebd5e46132487a5c94a25c3144d9542000e23663d0071df60b9b3dcfec9434bf5e9921c05002fb9647eb8c6a77efa6dcaa13f63c87191c82ce507d49c58a99df7c8c28fc8841ee0e0108e2fe036188aff1326a277b1cf7948abffd929615c97f281053bd11473113c38472248869e245ba03076fc90778b89127db3883b9a853bf9b15c879c8b29c21c4903a2ed0df95fa5a9de723065c94edb9ab9f348ea278a1efdc0a89b3c62bcbdc79d3c68e1c063f55f61cd432fbebba5e0b2018f02948c4eeec20b6084476565de50cafa0ae53cbb3363c52c34473f0ad87564d79d2bd75891b404f822931694f4b33aa58b2cae0c7e319ed87fb60a38002b28db5683b9f2f60ca16948277bdc5437956e262e29c3a9a81ebc525be0ebc46c9e5d8509ea8b907efce937f10bac22e184a057f1eb0159bf7a7ef649eeea379e8540cde9ef18e5ce3b6a876647833c73c90689d4b72803b58ba2334f8d0938617667eff3608d224f2ea746336ce9f8cddc3a09e7a2208aae2c244ec5231b1aa4b905a0d8aaa93911204556658350ef430e2b342daa9e6bcca8cead2ae52f4d633c121b07bf1815b16bcb9041f1230f848f07304366cdf71d266c5af1fe7eb716126cee17a0129755969bedc97e12613cb9afd01d803c2c20ee2c3e60dea0872027b256c85d7851222cd1301374ba9dea7a7e4afaa17c03a01f19b337ad2bc2277c6d63ea63fc0c8b90b9e15109def1f9b958915aa2116963f1d87ba0099c6b0c974628c39e32581d38898afc71ff784a1750c73409e12c23babc3cca3e4769248c970187ea1acac67c7b2f04ba5c5f9000d1fca34a2541c278f53e0862440c2bc47e73e2f747467af43f4153c94f5c377a9518dc94d7c191d596d21b8f69a861853b1e4f7accd4be1752093e19476776d6a5d893e29fd8156b72f68b2f80031019b6a06053d83e891d08e2fdadd626be13b402317a5e262829f4e6e8e7a7db0c11d13331ae3cbd3f81a8655178ae2ce9540f790eadd9547fb45fd4a5bede65fd8fef2638874fe181addd7ffd3b308cb1a6baabf29396a92309bbf22469eac7e724feb3247038d9cf6ae8d1e1b443dbbc7ed1c5a2b0c7ce54f98849f7a114f2852e2f2b1a234b776302753cc7a11685faf6193939a5cca8fc7b55786ade1ded2f221727ee2a255365e56671e0b6e1c2147058713e1c3c1b1b47a6511fae0575a0e58cf79862476f7fdee0ab5c8ff61a260935496414ef72b9779c4dd7ae485e55d33bece0118880a2d3a0402025888292d9e13b2dd7513601cc853a57d94daa1b7380564a502eb080c763ee35ae99048c039ab28e91ae1341df9eb58afb14684fc4536c92c40490a8542cd41f638c03b65635e04ef680bd5de214b77eb39b789f821357a8bd499e5d1e32785d6fcae934f788937b2cf53419ff7565619a389099886e9b380da23a151a17204f97b4a9793e0e9a21925fad51d6da1eb1c91ea61a7e2f3795ee3f7eb0855eeb4bc213985a186546bb740fe72544dfa3bf08c6d68cdb36b15d31e2fcd2e6d531b3acfb50802b30c2fd5ea3271671afedbac20f9f85dd3bf2927200dfd964310e8a1c3d225d80ba3c2a95f6fc9225a894015026adead61307d36d6c17b943ac62d30df4e8b0d22f63fba4a954b156520381c82a8dad7ab5e313d9919b2bc75ef7ec14a0da56769e8be4baa5c23b5052b87d8c81961da29ea968f3e5f7f0f1d6e5d3e41f8e12d166e2ebc0e49a9100ba7873a7a901c49c023d7d57183ce0575d05f0d5b035cf4536a9348e23c52559266e81cfaa9804ebd62451f0a491d7d52f4da1187b56b154b6972be251fa2b90850479eafff6b121faf1521af53f1e85f4b9732dc538cba55aa85d2c9b5fa11202db9a0323bd08c423299bb3d557d9f21571da2b3f7593502ea3d791333b5220baed4df867d008bd243c35b1a9eeb4490f9f0a7095ada352af48d141849de369e2cf6580f1bfc1e2d1ef1ce0cfca940b565c2e1012ef47fe3742a8e2e8a4d343b5928c822484eb914da726e86d678709238086b22e248d3ca9bf064593d5a8818845a2029073729ca396fccef4fbadbe6bbf17bd082071fa90a26346ddc03d5192fcaf85f2faf8716b5c4af7bf923c7dcd3ec81c5f1c3b73612693227ab9445aa449e0745bbe181d0f7d088975fb48bae9ae3c06e5ddb9b9de3b41f7eb5aa78dc305906f20dbb3c0afb74b6f48b38a931a9ae3580a12cc5059715e636e2e6a9ffe5c3370fbba5922844c3a4feaf6f391a21c9e03eb88979911d62c052981f22ff3585462e072ad5a0b9ff060fd3d0310762841c087ce8659f804b2f63e092af88780df94f4e6c7fa4c73b97ac5b04c49fc74e90937a4f9a8a0c6ca042b797ad2a0175473da2d74b8e57d5f943da8669ba9d096d03717871b86d59055adfebb79d8d80dc35c7a18e6e7794e5b3929feb37b68ad5c364a1827efe1b1fc0a5442c9453554aace466c843be42d637f1e08b28e68166ec51c4aa8f8ec11621c4802a9439846dae532f18aa240657929270712f7ba094f7ce1c8f099363161d44376351f56e0b6c38b4645d7a6004df69b846f56a16134478367a3c427716a5d7ecd538ff153bb437a9679cb92fffbb0634c15d101688e678915d12dae7d6cc26c047edc48190df1e03729bbdff8c820511ebe23dc96c8c68e636f0fba2ea5842f34a18a9c71ae85dbbeb1827a6c0a63d420460cba0edef1441852f1490673df5b6b5fca5299c0f3b5511afeb1b5139b2f3daa1e483cbb8cf5fbfb538e1b6025dbbc92e78ececf969934b58b945c9ac23b92b7f546fd1dfcd291f3f55776f8743fd3da91433555a41929cc9df45ebd3cce4341dd3f8b8a86faffe329c1a88d0363cc742ae6f6cff682b397c9abf966c3711fa8f280c03a607e71011af581958cb56428f9f71d8aece8957db84081a91235be7f4d0a6af02150c117d920c178cf299c338216982fb4b85a956f34f600a984d9670a6cee53f5be0e08db2b501345ccf144f8cfba360eb04d4538a69120436976a181c5307e4badec3526e0d7ae14e85f7b00b9bf24cd7a0af5b067f499b2fe015757cf8d39d10df0eded23bd605ed99514f4bcfc4404acb3ef62b900065b259cc90af62c3c9a2cdd53cd78f34aab76abad905c52cd2a2f4d2d07ee451ee6e067fc5df1df139a5cfbd46fca8104ee1df96d40a052eddecc2a3d575f5e13f4eb9105556f13cda4207f86353cfdcd8d26e8c023adc3723fd012ee8b680715da7d13d300c4e1b9cc9b4840815574e3e2aeade681d463286a39842019a589bada544d137d778d25c0e701d9d9565d7dbaac4a0283786799601a98f883eda633aeb432697e7984675d44a5abb87bf74383c4ca20aef4663e393bd995f12290331b0341ed6609a3fcece4ffa3c0a3fde3c9ee354a92bde3c5715cd41253dc3234b8d7426651944303036604367f782f77e8e2e71bf10f9699a2ba26d839ac1e4df7bbc5c0a158da59f394c0dd8d07dad36e0de0604531a6ab02a385c349a286137be01b7db1d31ed87de001c2e5425bd1d3470152d6a55b56aab0be505a07653fb3697c59bc67e46fa308679be6ba339574e0b10673ee24be73c1adb7c456f66c3f11633a8b1db918b781b88059d44351ae22024969621af5cb3892560d4c9f9f4534383a103c72501239ced5e87de3ffe35f42ef2446a734047dfeaf886e48c6c08a729aee10e3e055d649f817f45c232760cbfdb23484283c605f1edb67dc8021bf37a9d13c835b0a686d9711bff38e9843c0256b49fd4ff3f229e3c61df76b3259b607e3a9ff0b8f00701d5173cfc7875bf5997eda6279e2bcc302c2503fce9fdbcf0619b046cf2626c110aed156a2fd8ca1ce171a443f626b8c2292b28cfb3ab0cc547a298825bf495c2b0e85ee04a0704d20709a7221d8f826dc061e0aefdbc20575d31653223c8db3f0ae951e3f74d540b8bb2fa1f79ecff828c17af8ea3d90e590c46d8d1a412c4f88912a4e7722406bc84996388e2a2e6f3079e8764a310bb7a9b002df999338b12a69fea6bcae48fae6d058425c81f94ed3f1123ec5bd1d83c81755c8c99ce016652bb7fab6c3cf66b71a97567115c4e081fe5c2dc7df6ca417c76375fec3cc431f27e1736b54908d070bc677a4de96b82ce4e668bad5a4b2dbabefb9347f54bc4997855f3d636030d4297c5ecf7d3ace8a216c6ddfc6ee7f841880098105acabaf5e7c204bde01cca89f989fd1674c3d15eaf116286c543e6bf48ac2885c551447279bfdf6f629e2491bdf7608764a3a000efc2b272f607952475f97e21edc9c0f6a7698ce69c9d8afa5f809efcc8d01f71131bb4f1ddc5eeb30a6d6f53addc88d36e5eec567f0b44416ba9e121d7c2529e2cdad698e28147eb4d747c945574def0fb50cb2a34e3412d5cd951159bc9d734d897111f3236578dc22d7faf52ed9d3102d11ae20787c68258cb2f0adc352eb3673424d4e12a6ef15986e4f78422e5ab537effccdbc27cf9f0977dbd7ecceb43d826f9ddd65a84ab3b51d43bd6a3f71e342ab741e71753e02d9a1cb30c349c881d87df6739360321616c3e94870358660fe4cc9bd86b63881aa7a108eb708c85eff4a13965817047f1a8dc7fbff6487dcb1f40d1208c328d6a292bfeedfdff2aa9380a64c6cb90d5060ce12436f0f3f0b7ca85b387c58e0e93dea9ef7624092700914826b584f914abc218f7dcd6e878b5bad74697cca9e38f2e16c92c934a6a1e672335e2ef4fe4f99fedc6ab562787ae1a3bb18a21e6199a935073c4b792cc89c3375417c76b49e97f4b7d317c7ab3a7a330b50d7a4ecac2bcb6fea6fb5ac0a3d636cb50bbb82b06ae56d5afebc3dbeb623adbaa8ef0dc1d983766b6e752f9d3c687345b728b741f662d993c7cb81651e888c7eed8f8a4f38b581c9ccd31d7906ff17c948b9a606ccff28485353e9e11efa4f30a99bb124ef2beebd82a866cbf14d56543b8de6bc293fd6cd684c0c02b0cce3e4c444325881102d9196ab4a2d957b07a9f0d866daebb98c8b875c4f2828ee576c19692333ddb4b3be0493685d43d9d2f123d98a9d12cbc54a46c412e08d5f2d327132771893c451f0361f4c3eb9d58a1c1fa25afcf6bae068f2a73a5a4342bb31c7b35396291d5065fa1741fe504edd62594609fefb20087d576cdf8c34936f7b0fe813e987d8da04fc88795ebe350f253c32ee78ebd196ccb44631163ee3be598e1a6c5c44f1fbdb059893716d9605d96687222a0b748fb436218a0c4d65832deee3dbd8fd9de430b8a2892476ecd6419391d324c3d4ddd8b698d47783868e84106461530fee03a01534e9b926e2700716fa4dfe7e657ad540de0644e4a6993d7777b158bc6d2889eb4dc1331fc7c5ff92c693ca2d65d395811f3fa1345cf8f1228fea3a5b0755f5174b3155a94cdce531091757755e07f44af219181da2442dbaa057c4bf86595b51ba0bed0c01bb91a19d3e8788617f093d57f42283da781ecd92f7b4d72b58068ded442388c01bdade32e5614c52f78b3dfc05d715dd54b43779389ba04be938c341b90343a29aeaf9f158002b6e75a8531c358329157fcb34ab4bfe8d5318126d566015cfccea9e1ec97d5f0e5e2f25607a5cf702b8dd20ed33e82588f3b1e03974386685e2b75f4484f3c05535ccc0daf50c23aab74135c59a0ebc3e50a49e2551f5141b6195a863ef2920846b6cc1383e6546f4ab9fcb0f3ed08f65eabbb76a45bd4b45fb71785ccfb0ebb49e1f43de10551bc9e232e164b1d762c8066c5fff5ca3b9d60e6e665956081eeec31082aaa7b351c9de4b0eb496c7a50a10a84f8d69381b1f4e98862a5c95c13b186677479be18ea34ead0cb600ab9160bc4ecee2d363049c3a3e723e546b1846c5ee0d997b79e31647184ccc3ab47f6043d357c89a4d0cbaa92781fce70fd690d04e2c55566f8bb6f30cdf26c24a496e1a927fea1392d17fbae14f3645097718963fdc388ce41a9cbc42f84b145ee8742dcf7310a5fb2d62420ed67555310a7c733c18c5d69e28ba2a95f616b17bb731ad3854e045d2302ce873314bf4fd14c151827832f77f0239e47c2543d2b35d6e195915a1db29db7429d5f87f6443b535c3885ab741a0a4c6961dba14fc2ad3d8006078de6ecf669d09871902a42c1a0b736c8ce323faabc6259e2fdff3f87550829739e05c783b145336233c36d89569e06c442d0251e47b33975aba1769f30fd667267bbee81bfcca5fb19d1faed5871180048d2df88d6924b06def1d53caee75b098794a30ef5a7076a45d86e5211592797747c203c09f5ec96a7f0021c4590dfd41dde26bedec758a67028edf943c45bb30e946b9340a94f9188b24d90345a128c731c7cfafb68d72fb4d963e9c28819b902cccd6f2a7789c37a9f0d8c3bf2ad15004c65b40255a45cf93a95e78e652a0602c122fab7388a29d23e1aecfb6868beef2eaf75488328556147136dc96f9900b1801c92bc1885aed25e98f60567a71e3fdadf437a70deb7b2691148a986c75039a794a05a3bbbc3ccb2ebae168239ab6729e6ea125c9880c1a389470eda07d95729b7bc7ee09679258dd1dc4062778add24229bd82bf6c7f027f5c549a8bc577aac92167562d6025f77020017bfda3489c053d4eeccdd7aeeb30d63f9d385199b128a89f21cc41807157fdc9185166e441e6f504c5f6a812b8cc956669decfa9893e11541cfd581c1d3b8e22e8f7bc57ae3c9455ba18ec245715dcde76aaf1f9391256d88421771a0a1109e039983eb79aa10563ec5cd86a745b6677b3c6ee94cc851425aced859ccfbd3b475ecf788aa5497664749d5a640caca85f1e655f71626a69f36e23651dc5acd8beb97b9eb2330b099d5dbe069e6cc7da944a7509d8c2752647b395a653ce4d20673f51a58afe5879855c3b52d6cd8bee2934c1e7e47dc0bc4e8a73f4c2e0bd496e46a86188006c4ac360f35cb322adfe82142f4c0b3677b66d1d8f2d69c38129ddd70f4c862545415ec1447b34af7d62a2fd0dccded8a5d0794c99d56eb0ff63b97da2f4231c1e0d0f114bbb451092d9238e135d74b6389eb2f8407554830751e5759d695bf59d65987e7f35f316fe0abf35d11d7e947909e37f382ebab14a9a3a22a3bca724aa7549d186f91aa605bdeb25cce41bd736e3a90ec4312b47a784adbac1115cf93cacf1c9c7e4818e11c426face5935caa83eaa5e608e507d4c744d6c180aa0be65c05a7c10b746e0d3ed40a949cdc15c5a6dfbfd676473c9c187346490e4b10802c9d0009a510ede63b9a87b3bf13fed57545dfa09233a3d50ae34bbe274d1292dfdd6ba1ae72d7941c9ecec56d1ed37f661459f4a6717a8072fd1a750f20ca62c6ad8c58a316ae17935c8a2979479f8b440d77ffdf269e9f2be5cf4d505b789a6f645558c6696d3db6f1f258a61de2a54fff97e9dad651ec423f5c0cd2e7ce81fffc555816521266807e6e2886a5915fb508a14b8016c276f878ec90221015777d5a1c615ebad9707a078e294fb9f17df731a38185ebea102d6dd17c6b42730de07a1433de45f6da43ccab75d55ee69d12a044bef3a89b670e416c3a2474685b72a8af92179bd67773cae620dc5c7ecad8ade6f9fe7f3b6bbbc421a808c1ae1613304c128e808e11290e41c0f7ec369b166ef270fa828d443d53b933d0d4e49bd6ddd1b5411ad8968b42ea18b8e076ab3099b032db7b590965514f5d2ba4bde238521f5c9b10e8911501699a0e379e97ff1d7c593e893ff8f378589c2e30cc08df2c7aaebff02e2bfb9329dd8d14ecadbf40393177d01056077b282b07dd5f338561f181f1c4812eddc2d6432596858c3cc493f97a9205068ef9f5d4b11914c5f1bd43da62c3ebf9f1276d5255f705520c6e1ff9a59a28ddd2d0c73492195b19bb75d9b5c7d0b0ae660e163b44c4e10df5429b1d39575c494c439b821bf4fe0620b0c1112c11b58c031c4015f27b63356cf3b1418573e138b5afa4dfbff62b00820e583e4ff466a4cdda32719ccef7c46d7b36e1eb67bcc33d8a415add88b428ab2feda1befbe463568654a5e65e3a40d48bd37f4f4522e400a231c83156a0548b52bfed357a8c1a8c7a69f3119e8f52d47fdb8a9b608039328406a319aeaca2ba33a1bfd14fe948d9170388997e9ae44214369142a7d138c735674e04b14ab57c2200b27c4aa7bdacdbe0d7f35f879472e7f093c62a2000bd577f961332b71f5e8e8ecc7f2f9af87498812ef86dbb08459d7915733912474997eacafccc66c4fe99d8e80913f2cd12507ade68634fbc57d671d5d58dd9a69e787cff218c2ce32e752c9af1861fcd80f9ad0a54a07da4b315c4f3e174e4b5c0bd9efdbc2b21daa276060a3330eeb3a1aa9bb500fd5c40090b8993c151209c9de5a57dc2caea4472cea417de646aa1450d69647ed24056a613545a70624ac34c3729c2e8933204ac869dfaf3ee7cd2b17ab0042601e875857abb2bd5cec4daefccc7016f95b1452799a18f7e4282e227cd7cb1e5a2f61cfc5272abc83b6ac9b7d10a5012e29eec8576fc27716538020ce1dbd60d1a963aa352141b245448e519762465bc5b4cbae2f9afe23c86facec4acbdc7783de8ecb155bec26f639b05fe84612ba1ac234d130dad69bef093f8a2b777fa65f51cbb3516c8132609b6fb6c0c9df8c1b379f694021bbd7972f32d81038ae4b15488245b1d3ab9318c9ed3b419674c48da47dd07a8ff402948f2de9dbc8cced179144ed64aeaf5f6b0c3344a6b027be400ef49a1a5981588c1ecda934e7530d6e95c21b09b9d0d4b22b8c74bc2042dd854e3a3ca02dfd43f03b5e083903d71acb59da50180c085c82c30d13113b2fc21ef298df252f72c612fbd0891031843ba758555c2234cb08ed985b4e726582d80c09c7b1b169337dc0fbbfb800a230e0a6a6a9de1d0b0927d3e7ea7cad7b51ae6dd846f9b9413fca9344bb0a46f954df37a0507625ee244f886c11ec4ee898d81d5c42e490dbf752610c71b0b6583ea7b7098b3f2ddd2c993d3010a6f2ba8a4da0615fb15c679b04ba17d4785747da944b97ccb509647ecb043f304aebf1b31867a01904fd2b4edfa04cf09a63b801660a16c078a1658e3ba26f186aba8103f24c8d985e1a9bed64c2b2bf89b148e0ea39acc4a6ca2984ea962a811c3f932b3f57e7050509b6a87d3a70bf6c85aa272e8e2d339c67c3608f9a2f03eb6f843fa18b1501de3b7b0a87d2f44a649737f113e2810cfd67315f808cfe8655a988d5505e0f5573bd08cda7623565f68e5b6eafa937359a38729cfa8c582e861b3db2c141e53bca2faf013105ad181bc19fc613dab53edb9b5923a773a449044c1c255db511cdaa87bd12e26e87dbc7130bcfdf7ef63e7197380d319b55dd778f0991cd2a615317a49361d5bd872f4101d1fa05c331d37954f162d8615ee2ff3c9fada8fdb01169ada8fb149f81b586291b5c0717e30c5a55ea631c1de9990b7dd148b19bca11e83fccd17ae7ae2bf0c2a2ae4ed2a85f19f6cd560fd04d21de8c16045e3e523f3cd275319611e8f482bc81454f60d614c5af5ef88dd74a257ee97f5b0698ccb485bc2dc998ef4daf4f7f5e3a34fb63bb90e6906553e608c3cdc5e11b7573e00e4a68b5a6f5c83ca0233f96e3576bfcefac7ddb71203624e3deef3f2332cc6be783b0a72f6ca92afacaa13943a00dfd87ae8d7c2a1c3e74603e3a77d9664c02dc0e17c95d2f54f3dbc6f16a436428f7d1c66afb84652d65243dc61f56082a72686b57fa473df7faccf6e6db9bb961359278c5520d90746a809f5bcac3a0a58e6a61395f4fb3ff2615fc3c04319622f91a5a579ebf3de87b4807343ed34a39f9480f61941ddcda0828d166d43841992e13981cbbcb270a191d7cbd3155069f25d494daa739fe42a1a185c3e0dbeb3f03507d62519a7a14e84a4cc5b058b45e5c8893d1eeaa7952f47c5f22d2252819c2c0c9ab3041f5cc42a44f5b44305764b2af21e04fcaf570984de78b5605ffa25e5d45b245893007f75b4af33d8fd57fff5184c3a3ff4035546992f54cc66bd6fa79eca1f0728b59025df188fb0ad8b0f6b6f8ea0e19cd26392f7c7c0a91b7ddada16f531f89ea529d761d1ef62edeae96f86f7821c76ffcf6c8cbcd426b50cc4dba50ef2926c530bf695cb78eb72fb9d770d087bff1cb3c7d4be29e2fbd2a2308551fbbd0337a4dacd42de5f2bab9d5b3ede93dd3839456f69a18298acfe7f3150d445fb74b56f3ef21dc4448581dd0d89586213bd5e4d77e80af3b20e19533b6db2b7bfd7a840e1f0909f82bc1b0fa8f766908631c6e577f6e0f53db21f498e21d916cc1c7353e0f3c34fa1391b41dccdd2c2aec010dd096b0e8d8965bf614f6f11b41b4a90805f83ab60605e46176939634707520fa2be41921e39bff794320b9bb9f5bf89da3e6073192bb79eb48b7c434c23947f2ef77f2f0f771094c2154a794e372a3f3c6efa08f4276564132ee3b03b4ce2e045b5d6fae94f7c6e248dfb82f1f7e57d359f8753749758558e26b149b0fc2352588eb45defe7b298f2d53094fbd02d2a374d918d790e823e0e5091e41f3d4ee170dad8b54557403615c328ff5215513b88db79fb4c8869bbbd3a69d54187448adbdb5cb739299ae9777c905f983148bb86a9f91afce9cfbfdb9d2e0b2c0f40eab2255e636e5ebea07a713e8ed5118df2d7037b3840dee6f882706882ef363722769cf8f044d73c3e46c52e13ac0b9afe8d5e211298e05a7305d98d376d1e8f766608f364018785fbca14c139dde356d696942dbfa843188d5d083a40e36e255886d9b51dbcb2f09123567fdf32c2ffa2520946b0e2bbea826a9831735ad455f41305135464101f8a2766c8b2dc8400067c051dde30d3a08871cbed50a1b266d99bca3a63022e2a598bc32f1221a0f30190af1958acefd479b6f42777bf9152d09fef2f650fa53874028dd6f5b7e91c9d7ca64d0daace0d51b9da1c5f9fcf5570bc146a9cacc57f545246c6128958ceb30030a20376009a6fa5540dca75a0f887d90ade91857c222d9e5514239856d9d243517c00ba07e24f085e77f916b770d981f63731b82b264aadc85596ccfb3a3ce85a5e4912f775ad4903a9d1982218e9af00ed856d9d6345d86f45accb1d1082f06b429b11468e33d690b0d0a354af4cf24e9d5a19fe842eb7478c6085c719bca29bd6b394e3dd2f9c873adae70e44429da829b7a41b8b59d09f71c5ea1fa69affd975185586229061a16af1f12c892035fff355ae4851e6caedc7fae4dc4d57162eb85b47f114a11806531d90e716f64a10c2d4b966e2b344650bb35e06554f2f3ac0336f69068bde3c4e4ecf6132c98b4711b226962f112d5fde9b6f7d134942421c32c2d192107e6905def22e005365b61fb6070f4ca26e0eaf170027f862ad8c1526b60cc70ce45c3170cfdcc93956d36676f5fab2d84b697d4bbbbbe617d694393c78b2fc77bf658c09094adca6d95064964a86ee58e0b29eb95331bcde1bff26684babc957ec292bae6239c1276972fe48db8ab5892788abf1457d8d6cdb8b4a82ace0bac148515b45c7f311385a8cdce3fbdc4dc9a575f2e478fe70151788bfb8c42204b9a5d6605474ba928daa421c31470053c761786ee2487fcd9d90020dfc19471a3a83417691efe1f7cf89d6f26eaa2e53eb90b25e3f78285e702de7f6ca15a59233b525b19a2b17e78d808d20b8ed960c75710e6777db5c0aee00c4d6d10eff61ea71f6a846b92fc677beceddde8e4b9371b5e187014122397f4c44436fc6fb7f93d51267b7a7267685bf9e1b4124bf9407443d659678d110c412b26994245c9dcc35d79b8b8bf3f9bb0903e9312276d6d1e5099d89bd42e826e77862c9e9ad0181b2b5e841081b7fec981a47027b4bf023ed84cf9e3b3586978405d804e598723fc34494de379ceae89d90451583bc2f192cff06972893ebaee90f1c389a8c8a7fd3576af8d784b65c5f5c3e262b3cf037eee2aabbc8bfacda1a4cf46c3212763b8d3fcebd6753156e201aca8caf39f6300be70021e6284ca1cde6ec42b2dc754b2bd43fc0eab32f1508f130a88be9cf76fc3a2ea23e5417736e438e01db14fbe299d66ee0c4207426371bba211c62f72eddc06b81e4adde6825396b48204f82de7b371426a9a49c1aae5a28502ad8926c82a662433dd2fb4a73ee964993855e4ca8fc4c873a687f6eaadca4adc2985706c59394b7d331cc464f7a98c90ed4c04b3fe7033e3782fc65aa2386297f387d046edface4142bf970c49d37e7ba659476fd4f25737275ae28d8d096a50ae6d459e90d28035b54f8ea0723fdcd9c794abd59cbb7bf7bd03b166fa18ca0690eed196286ec6ada1620807fb14b07e141439d60f50cb1b006418a4e2d6c4200f89d358294aeaa9a62925b2290ca89640be8a4d103e4e92c454957d532875762e330bbeaf3dc0233ea2575a370d33e0b5986d9ac5314cbc8e82a9f423f3f339cfadd95cc0d8658b477b32e54a49ea9dfe9ac6e77439c5edaf8e19ddeb344f8c812f10512fc3d5b57043b53f97598f1d2757cd3f4d9836794fe4c45832cd2397f6dc32f5a900e94882e89d610194cca8f9dd17447b5493176f84c80e887602348d14f5f69bde77dedd096951d37b6fb2daee14e8d789980207870d094990888e61dfbff7e6c2f262cf8628f98c3356f0144dc91ef0544e65235b1f34da6bbe3dad2202cc045df672d7292b1ed6ec33abd189f275e0ca609f255ef9bd36fa70531e713caf750f8b3489ad4e7388733f2f74451a2df735602ed907c46145514574a411c23f3c372d50b6af7437360c3391da8a85cca35f5b82e04bb80ae10c36db726760080f3517f4e2ff9fe047eb880f09da5a46c33052a3fd0fc8497b11152b983c5a017b808aa97ae02ebd6ec0bd149d0a1ce1fb6e7df718e15aaf0cae979ade1273cc47f656c4c8b2e490b4fd4f72e0de442ad7c4b3f970e61b3c06745f181f3cf9b6ed38ed34d78e37cddabd706d7581a63453ae1ad9a1b5c093b13f2d992411342428f2b136a1cfd4362fca25ab6516e310a58cea340b028de57c1cd5a2cc84ac5ad60e8aec428a616d14802fa29af75e12a71f4457b96868ff438a33333e5cce51849554ab81b493a566e11616abc501403bc7a2263d639d1c4a6429e7ee9b46e155213ce9e83f0c950dcea6b6ce6d25e59c4f6926ecd28611940eadbd56adb3a70fa1100f84324249e7632e060bfa5877c31e4e03d23da2f3f4e36c66c971792641c02901b0b9babbb641f80f3e1c62def156f28280e952ca2f90730aec8ff6e8b9eea2395841d32476b294189c39e0537666df2532a4c8ef72f86af3a38d39017899674c52c20ebecc51d31ed8eb8570158e477de9785de0e34e0b5e833769fd3210f46083c61e5b82cd2c4416ef1b9f73e725c648b84442f9f84186b8a59e7389d0ab0c80e01937a4cbac48af74539ef42f54a24a209e9ec7033664c721efb388a12d3945ecfb0fa035c53a368e51e8f3f0cb898d985ddeff1c8f5a5eaf16f2b7400b348342625251133459b68c338e544434487858f1bb09e3668502600302ad62ee42a0cc1c1bf4faa85d395c1a34d7f798e0280926562386218c0e2fcdcde299326ac6a31dceb5d315ed35cf322525a473cf1aefce5506f149fd6fe1f775e9ce864ec88af1af74fdd0ae657d137b15e67a8e26172ec28ecc4d651cb749d8b8957eed281b3201e80a072d2fba1f09d19ae52f8c2abf2da165181e9f0a697aa67f560197795d215be5348b46aa737544f0f67035258db46a63a9567c81f4a7730ec4c1bd7585bb00b20b248f63b8a8ca3505ce095b113a074c129ecdaa41eb90d59fbacb234d3ce1a232f08f257c8364c9a0c69c07f4cc3f025680890aecbdfea9c49480529086fa8d676eb01e363f782caebc9ec79485b578b1c596a105cf4cdab5bfa1fc226ab10f426437e8a20243911154f138bb34742d650c7c2c1cd10dd55ee0e9ab959cf62d3b3ba5ff34d91251e6fcfa0fe5e502ecfb62fa4eef7134583f68120306288239f95de6301adaaec969b798018a5070c6f83805a32b10cedf64da198d1e8a8b20528c120ea43a8528c33b915aa96bfe53aa0aa24a859cc2d185d3108ae2016d92dd7d9f81b729dc06fb3d5d553fcbb13371be920b1005a78deea7b9140ec9c86506c1c2e4dbbe1848a0bd59a9d756fe87ef97e39ae51ed96bcac0da5e06f24f2467e4269f223ffdc150501c28b241f1fff5b698da2d4df6d23e227c454d563dd65ff16d55eed3ee5868734125df26792a0fcd1f8786bd267e6920ee1ce66182badacb409fd07a1c18b307365e809df76101113b9128e4c2c2fbc3ada9b07a5bb28b5044d65f7457ae5531d6129d9d89eddd9fd85e343ac5da49a872908a85bca532b029dbc8e99822f4aef1bc1f2c8108f2ac19b3ed10c1ac0698892206b5378024af2ec3c15feaecb5497309b00936711003a99aea52ab9f15fb621f401cdd1d8421a44f1d66964322c081015556c972f0c2fb0b2a84f79f8a4f2c9b03ae13a7d7c41b381662ab080db33df2971b0235ecc6e81d399d29ca86126bfa79c50146033d72ceb37857e7a849e59ca4d124e7ac6730c6afd4417c371d34b47da42b8ca5ec0ee004fac8bfe091708df28d18f21fb7790f6fedb3bded480099744daf912f157fcd928f0c18e42bf1cf960b79467b747e63eb37d208945862a8706607599b606746ccbb3a088a3e2d81897eca0e8de79809699791921e21730926656969c90ff997282bcc2ed71a77fb0cbccc93a5ff668a977dd7943ad058ad7e3a52815f3c2b256da98cf290581c4c2188b2cdaab29a4556497c0da4ca9a310e834de9389a84aca50af77a056352d167af7006cf48ab5cb28ae4f51f2cb3b0016cfebcb6916cf820601683bc1a1251e0e68f9d85a398d911a0668ed2efb4bf15ee27e2d57a01f6ffe14fcc262ddc866edc093f8f1e493b70dfdce25c5578c893138372f54cb906fe1c13c6255e259d50490d853e9df8a4a2e4c4f26e889d85aa210f883502a57a66ed1ae22ec257fb1c1e523171c779fd4d52e915b019bb6bea7f000c1c969ee877f77130bc3803a23ca3b2de5416f4c43e8ca75209b5480fb4c735976155553b686cdbc86184810afa3f44b930fa4abd5da2a3166d1aee66c2fef38365b805fcf0d0901cc59ea739147d507db005f23ff22e31019e4ee376c298ce7d11c6c787e7c13d7fba22fa227938a9c2582a0d49d107d72d6887558e1377a18385d37a0ed30e31720f56633dc8388fafc641bd0c6e2f16d442d7ac3740f3512b8e7f9a70c3245911c71610bcbbad2d0af20b776323a642e37e59f8342623994b59d68c54d51fad7f09814708c5cf09f7d6f85bb1ab43cabdbdce8823c6c4e5cb72cd048c27a1c467b7224cdd4c66a8accf1cdb04e82f4ae584fded68903bca5ad80eec47e1d113308e65bd2c14c0a5d10ce84e19a0d438635f959322a351423c70dae3271c0f8e06e7af3ceba20c2fe26c8337d67703eac1b3886b65591465848b3feecfb44f24f61bbfbc5d70aa18d749c694c1651569feead322eb1ae94da3ce3368da3fd7d5c498ccd3930aef64af8244eda367d835a6360e3d9ba6b7dc766de4a079b34a2154b4729f63194610d42eb899ee32d44f94cd060fbf88779b5e3c94fd553b0e676de215d561af6d5a6d840d7eef18392b58b2a9c7a494bc95af4d831098a738324e314a6a3f9f347505194170411af63dc4c367677206a1b56fe33bdd82b6377263615620730135def2f70359c1f8fcbbfaa3afedfdb4b45bfd4a882811258f99e18ab5571451190427edbbd125e4ef81ac456ad510d753416eb45e55ce2568acd4877bdc16b5854e73413bf5b1ed4abdb07a0320991fcfa7bb93d980a9d4f4168697948f7bbd9e12bf81743770f11415de1c4c9b1a9e69401b68228e96a98f5d59999f484316d46eb90de986ba74f9876ee3efad435e8de41ee321d4f3793649ae5fb99a16305bfd804f51497b97de7411c47706bcb866f7303a3bbbbc9c41fd3119c97ebf68d4653054544927538c71f5ee42e3ffe9a85ae644bf1da6605e21f84a13c79df8ddd81a9ea570fa4e48ed701ebaf8cc5395beaea7a828505ea91a4e0d8156ee3b568809406ab8dafe02baee183e064cb5a5154d82d3a4cb53920d0e50463341aa8fc247b8c766022f2d23231a68cf6d0e1a3f572b54a4b9928fe038e875465b0f79592d565d0b7311bb3e5e8bc1b61b45f33cf231fe94590347a1ea24078b73a2698de78d3f6da0cee51e300acd721a9dfc2f980a990f7e2ad68d4d85eb7e343269d752d534bbb3d9352d250fe27a20428f5ff9fd48dd3ea2da3c89af92275ff9924da5be452ced599d7aef6613f19710fa8099c219230d5a793cf738728a6e29345f3e6277450ca58d12f4ac326fae35314be8e242075268e41d2e93bdfd3a1898cb9feeb4be9a583721700c17b3f1fb4edaee8c36c16f484dc62f34bfbb75820372ee0964c9a167ab386680b2e4966f92748d69fbb1699a54bdaf37b92dbd99eca368173c84b9a80c40dacb6aebf53a52a64276454e80870fbc5cae04c5451ae1ad8efdc7d7060477b18c52dece8c4bbdc8d3e5f70096adc94aa559d61014de6a0c1d04037524d6099c18fbd22c49b2f52f22e3e1857c429a0a3a02b42578e17f73d91ba4409ead0181d565e7b0da70a2edd7209f9dab5db55823c4d17d60d684bac3fdf97feff77ecb450e58d682a0a8d8bd95ce6fe7ef87349776171905e49b2585307f0062677372266edcd297241fdad9af373c98b045824bf06a419edb2e2e7c2eb90bf086536c5ea2fdfcc4a214447b66bed06c1ffc6447b72b565b746617498104f993125927c3aea350bd0dbdbacc06ad83b5a6b44319732202fc692d37a3bf1caab9882fcb2686f7d979421af6fb2d254b9ae57288fb19fbe0c83b8804e4dd18616f05d0c60aa3eef64c449773c045943d3322c72fbf9eb7a9081d11a6efd74c7b191da0db732215e946f9588083eaf33914bdde32764adbdafb0ebddd544f1c418b08ce2b8d8fe5c5939730f37549d657b73145e4566afc49ef10c66a394c549","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
