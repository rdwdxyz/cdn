<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"721f5af19e12ca825eacfb1c39c6fec186ea0f15152f74572449d2af615a0ac153d944e6dc6b3a350d0432989b869ea1edf5b172cf19afa15482160fd0fe8df8a6798a307c71138c6e816fd81d3087c849cdf0caab95765535d944fa67f4c7cb0101020d9c585b66e074c68d8adcfe1500cebae608dc1b8615245356cd7cc177ad5857169c3b17e71c826659be332dd7dffdaa00fba508bd9fa0f7c126148c4bf48c5d4c3befb190254db3f1155a602b8c92564a2048cf46dae2e2760b8070525e10dc8bbcffb8672144f55d925c1fc81873c21d0eb0ddb8c820d934887479fce03719c910818c6e3a2811f97134c84ffbbe084b9244f3808e406ae7bad15b8b62305341b2acd30f517c548227f3e730a11bdf5e83a6b1c24b8751eb7c6ea6445849968954b6816241eb55da8cfee168fffcbb7cac1183ad961147fcc6ee458544ca8e3dda18f221ebeb5b0712abdde0cecc2bf14baea7168ab3d47f5920447c9bdfaa1356c0691789a571061a8d8bc7b31d1fad0e65579e39b98e8e682a66c69a8a7411a706250aa449c1adb25305b11406e47ddd4dcd6bd45a6cce4f8ddf3d74fc7d5e1e05e9f5c70d6b781494d27cd3a6e54e277a29d51218d8f906884cca2c31340c07f874b05da7acda45d6e152d3debbf2bbd36c72111570e1bc8c3b5cb93651a95eb5c4a492b5ae96720760bff304ec74fbe8440bbadf7d3464048cd7fe9fda744883f5929629f9704eed632678b539d1f835b6dac5de510561b3dbde482f7c1849fadeb24b174543c08a054d6721e9c17c68929680d766221ee27c1703edc3af9e6c028e5290e149354b63236392b8f82b0f4b218c2f037d7f84834560ec615d142c92beb4cbb52bb63ac3a8c1eccc7cf54c22d143903c45a107da319b45e7bf65f0ebf2ff6bb33adfb1677e5f2977a03e4a015795959675d87d7260bbfd79e54fe70a97e6965ec773365a06e4239e32a316faabaa6d38adb7a36a49a8422a5552054eab5d70708377756ce39346d8fbaa896efda7d11ff7e1bb7e5b6e83938bcfcf5a08722efd4c4502f6676aa3aa16f5ceee1c1d84d0e73e687df5b86a66cefe3863ee59e880932b939f4ed0a0178f99e8db431b0064fad8ac9e6595b1e8a2e28d830747cc2b438c209b9276e1d257af215348eba97abe11e384b639230b093e7b79dc560b8b6b0a8271bd9ca785cad72ea56498875db040cc8ffccff387f0fa105ddf27a93a3858f124ba6d884682c3995604de6e72a03fb86010b67a8e4f1480e725877098f1f064d778e3e8d576c66e26149657bc342e054e70b6bfbe84c2a0e91a180d6a6c0a00e7dbbde11782409a059af06b12c53e5e761130e56ce19b025c593b6de21a596ae0943500156231032d5934bad841f31799d03d8c233c189fd27af441d3c4ba4dfaa389e7cf2cbf8b88a8b1f7050cd4ee098a83fdbcfc08272746c596aba75f989c56be3d317c6ed0def1c534df488540933db215e7dda33004c830771f9109b3102fee193750de60dd09160ba8f5f2e6a8f2eba9163143f092f95fcea152b47eed1cf135599f328e96cd1798415431b6dc7fc26e561f4b61d7c7c0a50aa4bf90f8601d424165594504c071f9e39b22fd8b7d86e37300e265aa75dee48b88f842fae6b54804e5c6911676de75527473d37f8b16672db750721e3927551b9a1b0b6eb0e4be112ccb079263ea999d04c4de16b90d29684daec32a15c120e0643f115ffd47cadd57145fcf9499654ae0cca303aa187edde2fe9e5c5ed8584b43b113b64b124942d5c38fe23b94c21ec3c711ea5c1951b83688a74bf50c9a98a763a07ede576f58440e13415e9a03d45d2880dc1655049a7b5585d0b9a96440c2583d44dd9be9933f8b50ce29f60a7836f1a7903df8749f7d762603868a095ec26035d3772e7bb29d90ab534e12cd6e3cbdbf18ac3b3a56bcb3ea7c1efeb0a1d5ffb5214f2c05f9c1842f8cd6e4c4eb65581f2434f1686b55084a0f52bf5e73ee850438ec5e606178ff5efbe46c90e609adf48b65a24d1d621854a1ac9f2afcdfee7b0f413c8d28b9395e3a93dece719d1dd661fe113331822f1a7309feef59045201e0d070b574104cac0f1932721146aafbd473c2c6a426186309ec8fb9b2ea79fecf43ee02cd28d85e4c0c673c3c89f9a9c93c54f487e92a5003d689fedf7f1474864a0566a053bc1b0652a29854131e8375e8f216004049a8e48ddbd6992a4928be0649ccc82324623ec46a073f54b5ebc9f05334c07494d32e61b3d87cb6c380dee2901cd800592fe7b6fdf71b4f5d408b1744be26cb030683e4a17289949ba285718cac0ba43caed7fdd1a6ca67b09dc79c53b1eae4f2c4ba0170509b497446be759d604e1e533fc8725a7d48f037f77eb2e7dca339120ccefba9a9844e26de89b525ad7ebf2358642f7741e2a0f5ce4b950dfbcea81259208dfd8d4acde01d375e472520461da47ef9447dac50fe9880e7c45f6d09a5339ca427d52090a5e06075b5f5d22a1d3cdfe4aab207fd5199a44971667fcf9e6898d453d2b5f4c17ff18499a5bbb8e9455af0bd82ae28c8c051ef71ebb146443b0f591da66f8bbf5e8475681d4651dd9467af446a19071afb96db890ff5cbc2439572fe8faca5e42a793aa0cf6be5239b3c4aac5e6c0ace3be7609b0dfb4c774bd95f255c4a864f74ebaec6b1af9040fa436b777498658f31689266373caeee7042192d34b8b235e78772eee385053a7f4c5c6862ebe3258613e616a2ba45b5ee0f474e2c68c952eb1ee3831b40ed424e01a7aaf023684f1cffda959e7a7f777d62f207eccacc749fcd60ae973978adcb28bcd2e983bae9ab7522e20928dd8d84367dedd72abd60fd0685eec220ebb193284ac54dda928ef968b65478d2a038f3f30e34078eac3e1eb151f4a77b0556953259e702e72417ef17d02a91a4bcd63f64c62ff3add115516d259ef1866d6b47d897ae7b77be093cdb91a40e69536f898c1738266e242b7ff5dc8cea0850a1f17578b7dad03d648bc85b0032546dd420808f1a930084c6054c4a43c33d1e42fc815df810f73c36205b046b8a62ab7bd8ab93f38883b2c043940a65c9f8257abef33b205918133faa9bc4a4eb0bceb5c8476565c7c575eeb0ec2576b247e4c6727e9dd19622c2dd87c3c570e69f1e32794e13977bca58a7d9414e57a500ff677ab30f0a184455c2a49535f93afcfa65649b1f2a35d0e377bef416996fbca338f285cad2565975c6a3497cc863c1564bd1a5d63dfad721b7730286056b0ce847c38f0653e756ca9df9e9c56d8fcb390bafe413f6dbeaa9ff7e1e3845bd2a56783ea0c6cf03c0688af1913539cd960c48f63038d63554167c919f4d44665c7b2f28a7757ba6fa2a99136d931f73089efe77ee43d23cda82da7832ef6db456827385b59813771e0e9fb94f1cdcca6f8df24abf2595076bf159ea6250d25cbe67bdb667f9aedbae4fa65853a61d986b4cca0eb20e2c3c78089113fb6d7953eb484a67cee8cf91b27266d59805b9794f7b451755fbe86be5929ad317814b7ccfe8bb6101e5d246fdaec1a8d3e6861aaa891c128a9e95e774ac6d91e355f555504d463a009927276ba96379c688b58400cff1304c17c65a7cc4bf23e890931010b46a292b61b270a38ac97d89f34e42c1fe3340c3460cc2062862af6a9edcaddb1d2090caf179c8244524cd416d00511048de6f32c2418fb852d8e2a22c48525c34051ebbb0f85dbc9785f3aa69be7bc6ca306371a417953ba6ce163267f1bd5b1947bfc2d503f13f41292b0abee2fd7944b35526f9103e89a4d0024592d71cb5860a61f478cc9b42f41d956264c4a37bf0321f0e776222e6e9a07cc851c109c1887872f82c2c82ad8b9dc3138cbcae3d41743fcc8d67f45475522faaaabc2490a97f1207ddd16781cc71a058f9c7d9bbd62397037e4b81ea7952ce4137c77a4ba40ff70cc443379e1297b88b98517f94d163034553caf57fafaf514fbc147e23ef00044d6c54904cf9f9520e7311a2a5ea6f3cfb8cd70a2c43fe6754fce8ad7690ca7d3c41611df8bf5eaf3e707377b24da070bc92b3786ea0ebd46752c17ae66f4bf61e81a6c2b9ca1dbcd168ec3b2996731703ba37eebc90b32b4670f778b4eea7f8a5990df3ddaa89ce3bebd40bcc798ced09a070d2cda7d10d46d1c9c838da0f44362f32f07fd0e00da757b2556f6538b6668f2d8eed5717a484250c29ee405045404973b23f1dbe9287100975f3f71ae2123dc6cbefc7998f83d288e361027f2883401f31d723d832cce8811ad8adb66d014c8313a5b1ef1c25a8ee0449fa7f44c8dc023dc1e77766ec6162ec07a8367d5865a9088ed72e41afdfcc6ace5a79f1f571f0b00da0834119635f2ca01cb95e35e740dc19c6160de75b91e0102c7258edf515b5c26438476e572935e41158e00e449f7603df08352c37855ce7674110be3fe82b1c83b6913f58fee7f33a019a9719e8c20cab16bfa558d0b14605d50e0665bef2cf94e0eedfb4b228927c595b5ba6a78a71ce43adc9901fda0f69734758faa3f14f4bd3f0ff037960de24c6735073f2cd1f291606043e16b1de2bdb170e4884605ec7372e3b3a264d380e94bea61a5c4dd00fd7ce95cb6a67ce865f5207836659bde8d9ec3b9296215d51d9d0a80f750ae87ddb3c3e5dca32b7b6fac819d829e738d34b7aa730eb41dd452ea8a27c494552cac9ee25b8f51589e9a8f9688c9d0f4fbd87e1057029b1c86041005bdc39f3f142e80ae2e7c100f037076084d3f9ac48cd952cf2e4fd0b352d3086ad59a20ed333cc1a22e2e4e0db5dd32b53a803b4a3929ca6691f0a0f3364966e0da416a6c6a9a813eccb20a4e0326730e7aee699e3bd9053bbaf2d1a7fedfa615a25181f783e8d00d17a1b59f51a74d561b63452de0771699e2f8da35ef78e19e60918792771c40b44f9aa1c8966fba33332c5d1af9db01226ef3aa05e0e8bbd976f98443412259c33d9521725074b1758eb1031b59cc86274c82891c8ae598719048faa3c106c374140044ced6e7d11c91a1f91f0a8947686ca9b08e138437b1a513a3cb4f0fd975a6192f4168f8e3ba8892ffff5e22dcf21e0eb400b897168bbdbe29bad83bed8b081ddd100c085a25e37c3b8422f6ee2c2d282377dc86090147cd46c9311510bee58f1a87a691ec374609b6b9ac35b50667e672a2667bd5e446d8bf1f8f3f70eaf71b5ad9d32a4944cef21577063464c2e0c98add99bcd139ef5a6f2f8e3dc23a4567ee143ecf3bed6d0fda2514f134a546664df7f82f62f0442f29e1a348615a012286bd27740d1c1958744d9a1488bf5929a4a6fbe0e4efe7329781cb9625968e663f1c14c02f067047f76c05a5ef65eef46530177c7370c4ed77a21286f53b64ce41e2f304ca328f6f0fceec043a7130ccc8acb5cdfbbc93f4d767ba95808cc7be5356d58b2d67964fbb0e6d4ad056da3955d80e048e219d7353f1969f296e7380c54f087ee7ba470200069d01861acaf5e9e0b55cadee18af3e41003fb6842ab3b96bbb488cff72b553b2089c1578e6134b76e23aa81fa6511669c3f2c7f80849cfd04e557b7ccfb4386027e10de79a99b912aeca50a07f0137ee1b07723e73722060f24b9462d760512b249f42e9e6e125e9f90a17ac4c7d8f9a7936132c69d5f63c3e3ecaf76ef17931b085f052a1b7699afcc4b3b2b7f7524ce9d730d19c8598032d332b02e14be4fd0a3600e629302ff7719223daca310584dc615c400b8dfb1e3b89a5abda5a0d427270b951359872b115f4f5fef165ebf4d55cf6db309ba37f83b0eee7bfd56cddaf8effeda0e5ba542a9e9037258d930137206453d76ee88f661044092bda71e1bd0eb9ab27c9b2d3d4ff215f58ea25344352950730e3b48f36f47b137fe52fa2c9f4a83bb498c533737fdf28c3fe1f755702a4995a14d790640096bbe58a4df9c754fb4f3c0aa8e802153da51a76d8e42de002c0095b7c1b17d024a7c13942bd4bac7a872f34cb950904905e74f7cf9e17f48bb6a068ba32f80e34fd4e6e7a3e0616af91a130c021f96a7a18a84c0b1d341350a2e7b2a7e69098545382d83ae1a8abd25c130acc9375d44e63eae34848986b8d62ba168de37209884fc21f1c7fec044694d109402d26783179ade50468aa415cd92bf30b4d1188c9b37515dd56613abdf56c2d7847ff2d1e6a3d1b3ac5ac465a55c1451244b726fb914d61e16d8344a57ad44805fa43484df9633964aabe92af9bef5cb5709c903fcd8fc4864769a184fac271a52c6fcc6f279269287f685154f216fd83dbdf20c275b75f17a71e7e7b89dcf877ae890fa812bd02b331a9d9113b6277e81ddfdc8908f50e1963ba7b4bed8f66e86e9118c2e5f2608c57a8a64175c17c5d21a24e58aad85f64f6c3ec1b44dabee1d4214094c0ee963e1c56aaa62c5d0bcd36ced0838b61f4c5fb18e5eac0f8291bd57d45d3e10c9a255bc4c3bcc9fceac1e94eafc0337195ba5e904b176dd0c58a30a6bd9562831a92e10c0e3451937a2323fb88523e99e913a05e1c64a7ac6be6a6f9953a871036a92b35398bb78860a7c133a36942cf2a069c3a4d39984e2d584cc675e1110616ad11fd736080e5b0519daa3bac01550cbfe0745d3efa745b9e24258eda5fff4736f4a8ea0f05f662bbef109db88af18f19e8b5e3a7757ccdf00553229378a15b96b3e5059b7c70cfc7a3197d549bc9343724297927e69df8442b8ac2ae32d5570e0443b85053e241e97063b7409879d1533cfa93ce2f8852f9e1c09d330fe2bf1a64968e3a1d61a6be2b17282393855f1f56e9b721cc52723279f14a0d87d89de7f29947506da29e0ddb6be170e371859384da47914313d94af0a5db5a8bd8a65ff2ef95db2c483de3a4b01df1bd01a32af3127e20bf4070637568464ee0c999e3f422436517a3d34304a96e4ec3ef34ddfbfcadc65e5b6dfac05d46c43892ec2eda909f87e1c4ee07aaa0c39c81bcc48d70c95026885c38a0f485829856d4270686fd64ad9bdf639e7addc75c3980dfdb4aab63813f8b1ae165efccc216ba0206be84c9391721201bc6befc23da9f8702ef0c1fe000bcdd14c63662ced4bf68aa4da85d3dfcf072da04522ee811a5a4787c356bd8ac21183bbcf5b2005d1123d75bcb6f6bca450938cc97c54293f07cde120fcaf20519d26bf3f51459ae3c849c8b9ee3f12f33ccf8292ea74754d53b7402fca43292a3601e363ee353dc3e360ea43905dbd7885c31b106c1b8740e2bedc18049147d1633cc33dfa3296c7f7a3f10e830aef91d0644b2fefbf2fa6477faa20bafd39f009fe4c1c2876734a7ba85b3464bdee4c132cdfcb2c710d232ac3459fc232ee89f2ade6c075a429406f77e9b51f542a29ab7734587a15fa2b843e96ae7b1df676129fd46e93fc3d3711bd53f0607975e67c553d73971cce9f5b329ef1b114775591c6743fe6bd1262ce32830658e1d6a8aedc02a4a7ac4f1c613693edd1f59e5e977a3f8f55f07a6493a9f768a3c12555e0843a5830783c545a6559b3293cbf42becf6436c0c1e896baf19ef382a4c5af18b9ea55deff5ae208df05c0173e5605f7469c4ea32c0636dde552e622f2c0ff152fcdda58d491194d717051b6631d4a0911b4eb33ede03c9fc80048bbc1cab333dee93453d3041e1aecb67ee3d4fa2d4be2b90afec9cdd23b3435c717c6e2c795a5ca8a8b90b22ccf8d831e3ef44701ac74b814886d5f50dbf804a0b2fef2843ddfd8997a40908f831e6fd3071b3e65cebb79794e2edd8918ab4ab90571eb06ca2ab59594dd17c693404c6ca0b16558e88c44fe7a096e2ea86741c3fe77f805072c368e499e01de0d106b07af4775a9283c6a01e7ac064466ce4bd29f3f3d89b4af13809e8e7e779369f63dd51db401c8beb91dfb9f02eeb0ca9e7f54042ecb9f6221f08942f96e7689c5823d3c2df8272c4b71b2815cf297d7d44cb216f3f0fe9758f5c8830271f2fd2bdaff1258438cb9c65e221f2885c2861cb6e205071407227c7d72179ea0fd1142b276d08e80e12f3e2c37d492fa49caeb3b70dc493bb21cd16b6fe5cca431359725ab5527da5e8ea2082a2a4a45c46ae5adec3d9e2215eaa22f5accc4bb9e5bfc0189a2b3e0a938ae683de828f92dd70c40cca23f6f861d5685f06900ad2ee575be24a12238fbd122cf9d44b017c36fe0644ef210994d168f60f51294935b89a745fd903fd8ec5831bb5567c752c5ce76018ea73aa8716807345c5bec7bf458d7fe41991b64c1b1d9a8c02f5b302ab0e4f992990504f6e1e2468f4e542d494f2d59baedaa0c0a9d3c02d398e6e8b443998ec1d0901e1bf55888b40358915636a5a59f13a3ceffb5a9276611a0e54720df786cb34dee12171964e4c7778f7bc467be8ada5f49296ae8f43e17ad541c364a0a5bebb4e5da3eed948181535ea50e33459cc41a72879a9dad98e2f0e86fa65a149d65a509b5e7774dcb0d79b543ea321f23b0bc78e3c460ed9220045eba869547a8b5959d9009b30f902d12b778a0c591543662d01a0d27bb8facb448a336e397f7f0c6637aca399d57a71555d7ea649705e2cd12db25dd050365461ce86d3cd85a233f8257aa1393f865e97f4b37061d6c6079318982a19efaaabd20235639bdb0e0e1dd6263cb54fbd58ca4246f80214071d6608478c7c7322da1819f638da50ec9a4ea53088d9a23ecafac037b012fde5a54e3d7e9d3df9631e39cd9e35c82626cf724b04d8c360fa8f74f7d0413fa89bf1679c8c9bce01f3256b73f744c53c6d59671ce044d81b3a76351e0e9e5775b3414e45d1393ef7b7b15ed9184d16a64ebd1169f358594c9fc9c7a4396b9da26a25adebb6360a6febaffca6614b855fe33ce5fed66bca8c28ad38acc98512893a94069758b5ffe8b1bd1e77f78ae93057a86670a65b5b03f891f4d026fd19d27d5cb3f1f58e3b0fe55dbdf0b0103bee94f88a83b4daa768b8dc96099c092640d13a0d04549f1c4c76009868ed56ab22e5108d98d8354ab95d094e5b57d82a1eb043c2f844bb007c0b965fb9d9c18a826cfee9a8355fafc1e47feb6d84eb16108cce9478d42a65195022f0827a1a543b5884064ebda76f9cdcda7ac7e550616a5fe974d479c0f6c191bf1433ee7710d9a2ebb9e21a15debb2574cd452c14226ac877688654d5896509f61f1669b18490869cb6563d46d4972adc1010124360378391c5c39c758ee9f44e35e702f01d6fc90937ad0e7c9a0d7a8a96d1aa4accdd0f37031da46562ad4b069af118e5ccdf0c9e309ade6cb60b9fb1641a6eda0b1f3f3c31517331685d3ce64fa8dbc9090e0c5e8440a1eb47654157713897309f958abd1e01219a96b8d4937e2bf884731e0d1714e081b09842dcf5af67f710a9987466521a953037fef4bc91782a1b4b15608be4b921ae6db4d99c31f4696c4221328d5eb5f12c1672e85255702f0701bc2ba5b611fb0c841da3f7f0344bc7101932f5414cab071436c6e43ab845d1b5ec6f8915355bf863f109de136dd541a1a025ea85a261090ac4f319bc8821ce58bb070e5c107e587742d333fff46590090527277e738a2ba73ded5717fb5e913966d659b5172bd91838621fd32e3080f25b26877b4ac69dd365782318790511d5f3d21014051a42cf044c2a9fe8202b0db35868362a35bab56fe64ea061dd1b8f64f2e2dcd56fa5e39ff81e5d0df73afc3328981cd2495df886472126bd5978527c68b2290fdf58052efe555b7c53012ac76e237c481aca39a9541da4169a66ea4501df93404f4bc53bac6334173382b7bd48bebae4615883f452857db1d7918b35db485ff95e1de160230e914b16bd1cbb1a8d71ca2c81a9fbcdc3f0309122fc0a3113598378aa58b4c56b8c4e188045347400ab5b612e1b5bf5de362df66cb33aef48c2d225812c8edbc2f8979d45bbfb7cb66d973921f0e8d69607deda7a0b7a1e9930e2ca1ae6c740016659cf7671ca247fd7f91227e71a854b33076577404c46ce7091ce0e247a7c947cfc2063f7cbb7489f7ab50180541744c912198f34bee888ae686665a3bf9629f8ebf2757d5b14a6af63c67157d0f6865a9db1d4fdaa2fdc8cfaf75d84e6daf5f5bc79a9b29e2fb98d06aa21496b8704ff271b7ccce80519959d6cdb2294adcb1c6c80800acdc404c4b594dca1559af9f546e3f8e9b6b60d2ddb82ab96285ebf41aaac795ef04eae91ec4cccf67cbedabf60bddb94df7f05ba626d758a9043057a3dcfe2dfedf783ae1d88a27bb98965499fdb12961e153ba2e468c27a4d8c9c8c74295016e8c564e0910fa74de21b1f25fc42db83a69ed9ff32942c8284e3a17ac56ecfc159c64c2f512ecf46dd4047f98f5cf8d9acb75f288c958fd4de1e5dcb978085603521d6e2d1d44cd07b3e1ab60d33089eab7b1a88498c9b33b4a45568df093aaec26a9c187a650e447211d64f581fcc7d4c661504499ef028270e3e4fd5db6d8c65dad74307faaa22758bf93a2569eee4be4f0b6c1f002e5816929dba15c16f3df65fabf272e01db7b0ecbc023ee52cbf8a643645bf35bb5fe4966f83992b5c02c7f9e9c3d0b3c89608813d2eeffccab57363ed5487c1f4d105ad2d240525948ff761b9d43c2f603bfbb917bad077346febc4958e26faa25a18c0fbf113d3827aa11111dfd1d0b8d55d500b2eee9e33a498b66b593c2b96d4fa0707a9380b9b562f9615876a895a76ba542b72e043b980decfd8f9346e26b1fd2a897a7e7f3da4851f4e79d729da50029df7203e61b7091651b8abde9cc57fa4d5b2e4ee10abdc03c6b93ff3c7e117b2e2ead6dd055be7d8685a5379b0f3dc6e141908d8c744971ebaa9a056482d0a21f564be5ad58f2860420edf616f2854e41dfec78a5e032e6db933573bfb55810179ba7520018b3f2d9144260f826fff7bd28d58cd6f496f35fb04493b5dd9f234532858463602abb3a3b647bf5a575bf50b7cdd075d102dfe2ed4fddca2dc68e86f86839e6bc5abdcc9bb7552ee6dc12bc715577e2638d7f599914e345f85fe4dab761df2b6e216d5047e83c5ff81595375eebeb560ba66fffaa2bfb23039fa51f1462b218fe1fd8da87891e2c5b24cdbfc08359af843ef3588d722c7db145396951c1d54202bab1ed8d859e74012317efbce6685aa0fc6a8aab588504f06ca26ec8b4c0a3df697bd03fe7d43d9c3f42382abcbcefe6ef265816c0e46fba0ed86a135d25714bb0419cb22183c4e67f68047c54b2b619cdead9e8709e72dceb1d5b4f1f8e29b13c8aca8d8c948c7a37fdc0e529c12897a22d0bc0b9da8ed362a3e4a65bedd4488bfbf7d7ea9024d614fbe6e0d61cbaecba990088dfdee7c04fe3eff25e86c7b05a11fbf7fed1c26d1b4552c1a76b30369b155da487b805656b4d87833d592c4fafb85f2e13700031cf137f78e650294264e1bf57186f8dfd396ae6bbbbb7a5fdd96bf40a96d1b403384af1bec1ad832eed8093e87b3ba9d6633ccc1f77d4bc75bf1f7c4013c5ebb3a40d9afe89660f67532e80c21dd79d34dfc79f1bf734faabd14461f54bf8611d73c9c06ff221232661a3a5221310c5afb4200e6bbd62520784c77f5ea96f83568097cd6cc27edc09c20bcc47e6f12886dafd553e8c21d19bf033358fcf92e66e4bee91ee7c730d954c27138480a209c2d7f6010b06996004caf4618ea4a3bb87ac2ccf3ec77ff5852e77baefeeb7549cd2b4c073a97d9a3dd6335d833d41897e7f54e1a79ff1b9c803e9dc8a10d19a2c449ddc722ce49c9b4b81e1b9a9f1267df7dc0e935c0dfe30a850fed1eab1b0eac08066f67fb87836e6ae202cf868b0058605cdd83ba92e979a9a281090468ff5771c895dbb68f62172da22b66d46024ecb684b7a89c3ce34cb9fb000e93b7092e7785fcd735f48f6bc2ab1925e24b96da2d866e7a94928892ee55bf1b7d69917e9b66babedce93bfed06971e02fb98f7e2bd210695c1452985f9c97ce002ef7f3df111181d6ac9bf237326ff1028e636b0dd70e53dfb526bf7267dd8cf627c9f4136a7562131628cac7a4fe34c26d3539042ec35c2f7c86ed45928302487d2628318abe4c8e0660943a5aeedc83cbe9b7637613e22fd047211c1a15976e6e33d9874b31cd88823b044c657b58b6c3d6a188fcacd97b72cbebe1b79c42ff4f862159845e3fa6634981fb04c395bc9c0ba1ac963a8ed75fb7e857b36f42eb65d06aa7ac3e7be67b816dd07971d15bb6accd1dc338f7c7cdddf334894c90d337810ec6392dbacf15d05e6e6535524aa7445a7e53231d6f6fc8aa7ed1f8cb39c62e9abf20fc02fef9167db7da7b68a8c562d8bdd70399f2c07567bb6af9cf19d3274eb22d85eaa95467a6669b1b00a1fb205138b5015cf214f93d7437200dda1d519e7df393e2829a6d9d9bef83f6d3ad34aa738f828665715547b88b98cda40c89adfa2d377c2531f4b844cb579cde50d0234705507935df9731d12827e485fa4150eb75a352469f95ef53ec7456f5563c03b34b3f1c12435a2b6493bc57d407c97a1371673a95c9208db6e8657e7337f516957fde92aea0db3b89d5be8995e368ecf5725b33b467a72d27652fd348782780894e7d11172b7b502766ed088dacedfe750d2455aad2c9b1e36cca824e266b0aaabe7d83f9ac7e35fa18d3c429fa76f55c6e7ff13379f0bb6e74042b518b7a38824dedd56518e1ed21991e22171f2e6a5af9ac604a3d7aad5c7798ca08548b58c093e027b15d82f4533407dce782b9be9df884774e2d0bea5ef969301498dbd2f72cdc5df2d80c39a54ea93c21969243eb344b531dc19f1e8c637fa90dfb858f681159ba6d23ef0cd1e048493e1587a68746e49e8b6f40679315d4654ebf7e1b3d3027ae5d67aa3f90b07a5495d4e53900ea45f0a5788044542c93fd56bcd3aca5a554f6b978752e9697f475cf798067a34d1698a7910b28cd94f4d176730ff9d2e8e4211e1763b292067cda75b9044ccf7bde6cb1c7e81aa25c8b961de31f3bc2e29be64461a4d46f3ea4f4919877fc84c4cb70853b557be79b28819d5c7f51c181f8c380bdcc02cf80bcf2d3b46cd101dab39738e4052121317e55289fccf22583482707c900fda0f70def603b660f55a50d6decdccab2b6e9b2e7bda0a3456a69eb7563befd2b2da07702cf6d00d4b54e9d1db9f04be5579a1bc38dcd5bf26b89bb5cc3b8fcbe96b72551f66086e1c7e3ce2a182137e8773d918ec59d6e2e565973c3eeca884c51d51348dd385d6d44bc116e57e7d75c0d69c87417474fcee8e1fe02e3b947175f9600761ca551f09ec3366ec9439dd6e9d0f45d63b297eeebf97dc4420512d0236f0167a98f04574a511f22a57fa0ca06667f00c3bfd77fcd538f5dd6720cc6085e8ecbd16d382a32578f9e6d5097d514c539911b1c128cb5a83baefe6df3a7385d7edd8c4ad6656e529ffd779931def33b5d2617f6bbba798234a345be6e2524fc0dca19995810483003214011bb75326999f9aaac336b6d2bb1201d785131e197740aeba5b8a39d51b4224221e034039e29be6c6670b58920238955bcc5cb1c5c93d69acf315ccf6481899e35c582f6a803c503ec691a8c39e4b8198e1a7fbf88705b4c8409de80a7ac3dc7e83707b49b0f35a2b7ade0bdbe62251005ec87872bd4d180a7d0fad1585e66847a38c49c792078f99be2c5504fb5446c036884b009c91ec7b1d1bc5400d9dc57ad2d710e73cc39bf63d35fe868ba928911c2994cf1e5512b166f52113d33e0696382d7963f48153bdf77c876139eae2b60c074e0472135bb3d3fe9f4da78916670dc833901b195364b9948eefd1d12d391073af56fd063c3fa633baa452c0c954a943b78eeb0eab71ded5b757f7c5e538c5e6870400c8900e2668a7cb8939bd98a151413760df89da565a3dc40113ba58de52cbeb1d97e158c67436375ba56d063aac661c97cb44f72cefbfedacc4504543c1d2f954612e7cd0c0090763f4dfc7c3469cdd1be3a4f7dad0460841c85a7c5dcef84515a2c9f3026049e96cf536cdd9147d9516111ccb6dba6c1fc3b405827cf4c9bc5f1b0972827e63b39042a4d68509da42c4a8343c08e57bd81ed08458862f951952edb1f791df2c31b9e125ddc0b9864575c30d4054a0a2f21bca9b0da62d4facc236d9bbdc0cfd5bdfb702819fc6f8dd3e79ebc88f171d73b03e11060060943249146cb885c379e02c1003e09380007293cb701006628899643d0ed2993a95ccc0d42d4fe610c8f1ee3c6de09d5cbeda3cd1f316e1f79e4f190858f1b8d9e9e8cda6575af26408aa2a4c3fad871d93f26512b0782f7b468ad1c08319220700f3d0a42ca4e443e5b12fe7c6aba71a5439901c69a6e60c25ff0cb5cf51bcbac199e1e11a83bb42554c9cf1fa49b12860b04676058559ff6e772d5b637764a9196b14870c7ad89526d17d5fed20e491039f434120aa19586302f95d4720c672f4cd4fc86c4ec0ce01480811f2a802ad9ea0bff454c9a8b834d6c8b2f69b349e435c6a1c120e20dbae38e20dd5425af96c04ccd8d1a401ab8182b8239a68d1004ba932e36bdf44e350137abcfb132c3ffb72af713114c3a3890cd57a4491e266a26b3491019a0798728a86923f6856661db4eb028732d501a9602cd12111e238a04e1bdece875664eac9ebb8b1ad0ea8328b69e228920ce13acaeacf20b27435b7850dfc7b4127f6cb7e9de2a705f6d4ab25cfc010d21191532f6b0535a18a26a90610f1865b32107a69d9074d7fba65c9bafe7a0ce3710b6c34bef07d25cc33709b159bf0679a5fe3ce27d4b53d48801c8d93e978d00d8278737ef0d228f35455a05f7e3d6aa027fab17981b98291b0a4fe4ed2995c6489ebe2c0d780b207ca4374922c1e9c41bdb479fbc79af22ae6308d3a9d7ab2cfac4c4160a79fd7c6fe85b593df2457538e2a781395fd3dc6c776f9e1a50c180f8880bc1d1036d525b905d70e1fcd40a3bbc764130f644c9bca6f8dd2d2b796d26352cb83d82d8dbcb29289931a3150e9845ab42ca569ee6823310b57ebbb78b99b14f4f288726b5eed42b88085e98b0b0275ec359045a970ac22653204f1f76fa91f1afa447d4703d9ac717801a5083be073d8cef2e4a577c014968763d298e80d76310c65924e3fcc117328cf7286b7fc104981aaaa7d6438c03984aaf6c1390e6d432486f9c5ee58a653ccc3c241658f870c44f726f47e03f390c6242e02619cc883a559024795b632f3f35b04d5c1c02c10d0fffe0d2aa6818f04d9de7e913bfb6ab41fb8af025ce6885c8eab587873158ab23e23515c143474d3df06de2df31450131c65a6f340b83109fc10a8fd249bdd9dd252a04017ca1cf4233846890f8f115f9cb0e183765c339682b0f68342e5f031d1ddbba7e9e4268c21b3d8d5fc48f0f93cc137e32e61aa100e1a12ac4c2abb1de991ae9c383b4fdb0de5ec72895595c5ce1dd912f407672d06954e4f23d3bbc87558050d5d26c56b73654f643c91d3d81df4cddf25c48175539c67487d24063749a7b26c981bc97b30484111ce4ea723ff96047c95a7e77c64fb1b4134a3a66ba91574ac224e67e6f9f2105c4b27a447fbfe2b6a4a0e9ca41048b5a4d669d13d626048d8564476e9541404ec2a07367f8593c1c58efe96631bdef846eda48f5d1b5de4afd14eb2b80fc4a6b33ce19004359260d0e58fba6e20c277d11c73e48ce50b705576d4b3364a530dda1edcbe6fc691cee8c70947f02c2b6b8c49450e7160af047830679448819d517acee0535c82f92656d96a37f2f8ed7b2250f61ae0b108ec2842a4291f1a7f1dfdfd81a41e70a2af3253f4ca7ae5995ed3cd58705d5d0989ce9fdfe17f6c5bbb80364b999d7a3150e1b383d17b3345704dbe4ce616f2aa874ff97c2c9c27e41b95cc3c04be88cfeb331418b9c20e80537bc302e1cbe8902f8927d70d83d9480754e06d26db64bcf3a90a14ff7ab0d4442929c4bc1e220d9dbe49cd36a531ae7a94775f5193de64b2ba4d70cb9c35180b3d5215df8f01805cd4b494bfff316962c055ed6de9914c6c863b253983dc0a64393de39e790cef95050ef789cda5a52041a6bfbc5e717f4fc7537697b14d2b9fe1a19bcdb74a78fc97c89164226b90d26431d8b6db7acce424566a47acc40cd0c02c3bd512d7ae4ac8983a6fab0df64e6552b6ce3d1e81724422ff386a7deee10df0a409f4b616ce74106808fd4b98fac622dab0453cf320849b222125172377ad35694cbe783d4bb4ce0209077eb9cd6f2cfac7a4c763d854802003988b7bfe6bcec05c8d11c8b5add97f7a2a13688c05e8036b8d18940a3453a4be73b7c2a7b4a01c8b9d7020be06552ef75321ea23807c06e632c7c09e08f16db21836f418710be60f57fd97ad16a6b3482a366baffd70646790b7fee0bd5a356794c712268f2125050640beb325f8dc7a944a4766262889ff711503efead2c0014adfa270cf36542bd4ffc56cbd3f798965229a69e4820117536b98d86eea9eca9a5091316478aea9dc454a5823e5c93b34df1df99729b1cde6455551df7dfda7351c62ceb66ecdb68bee230e6bd6caaf38ae1d15006097bc8aefbe4d04e4aaa24d0583e46ef37f71b439b1dc3d64f695108138a4289414086a029eca6c97c25280263cf5ed5856f30d635ee5b93e6f416851787b815b34324f9a0a2e49efaf6ff3383d55b93e5924008211fefb38f6826e58bfb4acf676d8c7fead25e4a13dc159b9ddc48e0f20fb0afd6a3adae9f6c2990efcea688bb4a800a8a6b49480d47d6bc00ee31e5b4105ac63ee5d65c8ffb3c496408e277344af9b11c7570a899dd6b35f510e777ee91c7b5141996a2a33e0ba4938d87302540f208c839983a94e5ec4ea14f00604783e5a53509dd05533958875e9eefe24164fe962de834125f309dd9ed7dd5ab67a5426f09a5626cfa02ab84a106813ea7f18d3a89ba8aacc3907fb37f5cc8c5af34082e5c160472ebe86ef6450a1a26dd66cbd8e2ac55ee9b14a785839206f830bd15c72457a86b37dacd6f879c33331bd863cdc9a33bba7083f26f89b21ca0c76bc5712fac80b4634e5f4e88e143f8c3d804fc193da54f75649dff2022d6003a359aabec34b2c92832f4014d9ab75f4d289f0d2961ff555c14c6f3ed356c80a6e06a2bdf4f34bb9c8238b682048fd66c542b8fa9a53434b9a0a5abcef5e913ad462510f2f2526c8542b669fe50e3fda62087b317ce7a5ecd8fec1e01e1228b717185ba91c1ce69d1b8bc10f18ddeba650396483df8c03af5bcd413aa353918a07e6c2d041f1d1d5602d404d9087b996341577ff8065fd866522b1522f079950ce64c8685127087fc0354f64d75e969b622ef845d509cff6d6f87a83e5a90d84818b7a17a61b2b687db1326d2a5dfac61013e8f80a96799443c6e3f19bf9611fff40ca82ba06601a5611c88ca916c5a476e43e62b46d59c2aa3456f99081ac34f05437e3517d9be87a087096dcab214831f777d950650943e2ef4171ff3d703235b6718a7003e77ecd156a26af0fc181ed27310d606da485bbcc70415b46393443d92dc08481533e208057a4655bc426bb9351479abe93f1837c5b1994b95dbf3c5125f0753b7f3fab47d74ab93574171dde11f27277b032b9c272e5170c3a2e4d03e231ccbf028a63af37d2b360db400f243974320f7bc0e2a1fa30204f6ca92b4d8b2bd961a330cd491632c536f1a2919f320f26bcac9ee1cbd793764bdba5d89659c32f8ca56d97f72855487fa5511ff7e5572c9ec55ec4750812b65d5d5211870563479357137b0f70e7250379036695c2bba79e04ee5f43c6ee3fb9760fe9487b881f017b7f35a3174bd265bb479c3f202c55491abec05519ed78a04a90781036c00291e5ad7a932125bae5baca30b4d98737d9f472f260db966836490dddee1e534b30de5ccafa85d276c6bf206d1fc8a6004f14a661c577e7915956795b9d74494dbb58743e1229df5e546e39a96da14ef37005e6f83ae014767d5a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
