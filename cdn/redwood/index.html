<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"185c07ead340c3c8a63f0aad8b2515cd9d97babb5193f54b8f27c6bb83e0d0b8ceec551f293ce21f72bebb4aa3d7c72a591288b834550292736d143c7265a361bbe12bc24982e93091b0fd5f886026de9558879917cd3668d95af18a433c477734d7c79795cd12eb9b807259d511dbeeebbb4890b1ee9ef2ce686c07da9307cc6e0086308ec668911271da11ea70a001e0f42cb441729fd0d78439bc0864efed6f02e90afdeba63897c04f4d5d574d1b345e610ad4f17d5a262819fec8384ff0245151e78708e0271c66bc6ca6088b3b950a4561cc5948b4fceec16671ecd8f67627dada0d67024cbaacd51cba13f086d82a450af0348b7fad1d832b39be7ad9cc52c40fe835ab17e4f07db8aaaa4d29702ab1cf34686f1a772035819182194ce7be914e711d59d2299303b5b68fde7c6746b756f27b4d0f3780c74671a7effbadcf10bb66d16cbdee2ae5824d699ca24f392b3597db6ea3993a38e419fa40a74734e8fb19b04326d9275ec185991d53d9ce91af1578db1c552a55443de993bb789e1a918f7b48ed523b58c4db3a4eaa56e294c6ebc225252b173d4fe0ac2b05781a8ff9ada0ddf08e1b94905a1ab221c1fec71e0937f03e2d638d169862571db1fffa27a9230e4e798751564a136a511502dde9b66c941ecf8a16bbb1083791c40bb76a165c7ee2853e6c38b827ab9eae1d0aac2821fff0c7dab947c31f88d28885c3800441c6987f00a2ce9efa31646154d3664fefb3b3148a1a4a5293fc5425e882951bcb1abb4f33d9bb84966adad6a1b26187f47b15572fb28e127783f6dd86750580166355a7283ba3de5a2ca751991bd15347ea67945a11e2da9d3c4cde6bce517a4037580f761b7fad2c1bf48ebfdf60fb3258631b8a146f4e216fd4af4eb87faad449dbd14a7f550d05e301949680254a7a55d96a2f97dd667369d2adcea7e8e62237348323159c5e22736e8fe123f4d54612deb6c7928b6781a8bebbb6eb034644a86cd8a9dd448a57233742084bb8dce38f13b77a9d3fc88e7b104f8d1289ef3f64edc374c079847350f51d81144b84bd33d9cf32de52d0b9df56c935c373932a1b6f613ac0f1cab0ec4c1b67b583ad8e9d0de6be15ba7728e7ad1b68e71e1db88dc5259ca89c96ef34234a5c77b027f58cd501e70b85458ebab7a93884166fd506f3fd0bf3f84b55abc8868623aec05b73dc0adece15d86ab2ce0e96d4bf84e89428f7c0333f5722c3d4f29cdeb08b92f2f2ec3ed79dc011057c2eea3a8b5563feec44b171bb704b2c24f7680a3122cb12505587422a8f3bbbdeefac7c555dc2ee46551572dd8993cc6cc77b61b9033d24bc9c72a0cc8a678091be576953172bb5f5fe09ad02426e8f311941a72c9fb90360e09ab03b057ea5d084753bc7b9066a096fb596d80b9aaa10ca2601bdace6fa0d024d832b6d861baf15f9ad66d235157e5bb26f9513df62cf0f1ad1bd6f5f426a7bf5ce551013670f79b25baf080955f4c8a7920cb433a69b61da8c18857ebc2ccb3c8322eb288803b5adbb769d22d1631d96498f4a2e1f363e379424351741ca8d77847498cf0191609a0263e63712b2d9680171eb735ae7027edf04e87c11696547d7abd0e89074f808bb0def97bfa9fd744ceba8371134e7a52ab98cd9997bbbdec073b4f39bc03511336e65141f3417e616624244d488ae91df3cfc46aa86ff0a0cfb6da227760cd01cc86b65beca8d976788778cf2680ab967789342e8fb26c2b211b2444cbdc3e56e0ecffd2cea91133b92a21d23789c1e666b1fa7d8aaaf88d91722046e49429d627f3bb038e47ad6014f9e09bfb228d9041d6ce11ec422b31e71e0b132faafde8320609b2424769553afeb864d379ec1df5dbfbfd6b66c2d88baf5ac3991ed4cf1378e5fcc2b4b5155a9ac4f3eeff04cfd44110099efb8be8bc98dff32bf6bfe8eb50abd18e208bf3337805ef7d0c73401c6d268823f3e1bbc91874dc22411dd041f76ca92581a36204f1f00550cf01ecdd42bfbc679e41fa9a1611f7e449cc257f4cf7cdd3997d131df1343d453fbc7603e03873087bf39080e25aa45c690f080929de1143922a1f1aaea9f14c00e892bf81692de3c53d1702099d9a65ff1b8710084dc274ba4cf4ac0870e3361cc5365e77372fed55665c8598eab3eb62d7b15585676d0acb360ee897bb7cac03da44ac437ddd91bf60ba75c1882d865b1e0f5fa309251d473411946af1e8102077d021cc581a3a87871779e67b20aafd4659797a00d73917e56b8b0587a5c9a5f05f41c7e4ea64e654d226bbdeebeb32e7fb764a4a6d872f539805952fa33f23025c08b361ad9da768b875de4670adf801ebac895d10d01d7f92d650ea685a69058f52e6ee3c1cb0ebcf55e55e8261b776b4447b6fae6120b3221c973e22f970bdd6bf1e3251de6fe9fe60e7f339901d0c1cbc6ee2b128ec09c0b80f0319d3cce10f8ad0177be379e21cd2b5e023e62b117d0ee3c55d46a79c4f92acd81d8d687e9df18ad38dff7950a672e2a1a895578a26ca22277976ea3e40e1ceeb97c2d55848850111a2ec1cc54cfce22455c350dede1b7c55a091dc4f51b2fc38a23d0b07ac38f682d5df9738080d7745a4530d3823d2270e2a0375d93c75bc9f9ee4d7ae268656485613ee1cc4277515afc7277eb1acbcd37799d1bf1dd93fe2510d8fcdb4f5834f8dd03b8733e028b7cb576e0a2250a1820a9aea1269f8b33ddfbdfd950c0b7471264d70674f7e3b8cf04cbabda0c99ffda112dc0bef0c39a79fe062cc92eb2e34cda31e2556dd04b356d48c0f7d58c759083942ec75d4245d29d9eaf5457659018bee67c0102475df4c25bde9a138ba0ffe9d299a5b9a129882c4973fcaa56e5545feae453a0b13bda5568c373d0ca3085442445135987cb3e058869b89966209051d492c7e2a4b12531d8c84f2e5ec45c3224fd37a4af3bfc5376e7067b9bcf3be67abb321457b138faa183d133709669c18d95f8cf5a5083e1fa6b643279d49a5d0df328007719ce7ed2ea17f7689aa5fd6f1affedd37b0ffde8363f625a212b2328c6bec07303338a3efc5f248e258069fff464e3ba49c98008db03c006fc87d149fb881d995839a00b8f1e359baff60209e6dc3d7947d30569f575ee4d264c329bb6a7b892e9170f52aa32eb6635b88881370b59e0e56c951c7c739f82e98522a2216bd2560c68897aadd52d3f5bbb93e1aaa4f0fd798af3bec869fa2d88e6de5cbd7a918eea0ce9fd9dfeee52a9a6399666fafcc51213723e62d015af9ea2f1b45aff7e8e25c2d005330fd5eb4dfc4e96b6479cf6aeac26026b57b6080fe6d0d36141dc3149fd697b563f24cce007051467a46c0734583db6ce3c3f8f0e0aa6b6e221cd8b8de282c260a7f2f0eda4f3cd0df4dd5a38ed625fadacd5fe56ee5abee235b5985072763eb8bb035fa04fee332d7e17b86d6d657dd8326e38019b5f44c70269c0731be50b3b1c4e263a6613ff614bb9e5e04a7974476729e9465b8187260590ad074f41b175db833f0c1e72715f3814566dcfe1039d6d5a3680cb9fa401a12b289894d1fafcf52ca236223252056def8631d033cf72f1b32d3c74e217815dcb3ba61a1720a437a6adc4e2ca9dfd96be4997c820a8b083204058bb029b7a72d915949995b7669d406652ff5e3454abcb40ef545a1f7689183bfd47cb9d06443ddcddd782b8a909f58cc0c9adab0cfb6a05ecd8a4107a98b832f664792e21b04c364bebd6d87ea00831603905aa3bd2ebfcd2eb636226f8f360670c08d9727d8cb3284abd8a835a2b8a751d2997a7650d74a6cb8ff37afbbf2ec0bb1b82090e1c819d6cade5858cd7b7191a62c0a6de23a4b77e0d1a79e36a594dc9b492288089ef63edaa187efc3788fe368b15d0a8cd94f0c0d436fd7baedd9f3505924cee043c1b9f249d15e0d34745b8d3b8229093c9dbb9ee3c600e9faaf81c7d0300e73d9bb67d7dc4776051d2913a5aedff880a72840b8d94747fd984b591ff8ee641b65658f1d140bb51d80dcdcd157de99dcabdba9cedddfef764491e5fca81bc962d380deca828a1735dc1f5ee8213d44a830e8547ecdf55bb0a030744c0aaed706b789a3a31a2d0235ab2ca70ba4477c89e1f436849f5ff3227fb253e20500fc1eb3c9d387635faf5ef66dd6e775865935cca65eefa024d85a4278c59c179270ff0fbd1230ddca23843c0a92901f5fde4d833f39c8d76e381db5ff9629e0827fcd4fd1863ab3307b9e63bc610c103076ad36e25fa66260e70e2d3c51397fc66885c4d8bb6749b682922055bd8630d21c6ba8037c9338d7edaecab45a863c59b323bd6cc2c4c4b28733b1297cde9e9b819848ded1e8ddb13927bcc2d201f1fc5f85b92a3c20076dd2c8503f7f4d44dbe4df867db68e73905ea68417671deb8db0face82733e46d9bb863e256f181dd1d56cf893dc7e40af29590443c79eefc9909e8d5832bc65ce5f94cd5ddeed191ee70b5e7e1278e445ff66fb54550f0d876ebff2e8d8ed2a7e0d8131fe6cac07fbb509ad29b78349d50d46c3ce3ce08fe0d67d7c7b1f64c8444b95925716936efaf2ef800caf5a34a56b67df023ff9041edde787efc0a243df70797dfacd8be52abd74c98d13c61925ae41edd9e321d5c3adb8ee8364a7562db6cef4acc3d0d8c99a1497c67b105dee77bed50d9609d18bb81fe762117af0af380176c00ed54ec24f2390bf3bb10b4a68eacf998ccf001cd4ad409636bef9a24a2d9bf70cd3132d9ae57c21dfc9b1b58281475f84032bd3c17ca15539460ff5bbfb7fa0ff09e18282aa5cdffa3a7c7960970dc9115b221554a2a701025a494325808de13f8603789ab82083378e0c7633d4dcfa5115ed0f66051f9877a9b2281df88c8f2997286b53c16e6e4a2ca8acbc3e272fdad73886d9662a279dc684303dcc901744a9238457f9e9b0bedd579e9a8bc1c9da5d423d3d1859a17ea0d687bdab503738b61f8d2f8f7831a15540f5e348406e85d1954d14073f37d6ccaf642e909ade290429c376f5a7833a260a5e74127a3578da8b89edd704c3d327709224c6b835978da1aabd6c8927aa861c00c233aad31051f1a0132f6da35e1a5774cf1a13d0c8c7115fd9e840c3faf6249abda4362cf68ae7ba7b9c1cd652444c4cc3746c4a74b49eb6c426d2c131504f6e00ef474dd9a67e0823d4d972219f2bca1c77c83ef216cf86e2c8b1ff37809c34bba8d67790bc7831c029b60873609625a7882260165ee8993a957ed3d76b894d22d7b905684587b955fdd8ef3ca1d82bcded43a6ab92b835c304602583b31ac3868f0d8fd0904730f904d3455970855bddd40062f1d8b800711ece7adc4ba8ca8b4ddedfc1b4a430f61a794088a9b4ebe6f339fbd474d9adc88d735c5a20af78137770aa5551e7254ea4a79277ca08a80f834a26de9a15160279d872e03b6881383c42d813688fb54255e76a034b4da52fd67704903deca7042cdfe6796679d0fd845c771576c3830c1e0898e8e8cb35451cfb276d207fa28dee73d6c670e652b02676624640d84c86f5c03544ea38df058758a52f48b8862c7ca0624c91fdc52a7ec230a39ea6ba075e0555668575f443d1949f53e4b5e6895f2d7fc108ef08b730cdb9fb2e2e22abc6099b21b71939c1452af3eb785df123bf851f9b1724d93f172205c2dcfed12607700da15fe9f375d0c7fabe221586b917db084d25f69447f8daa8c5d84be30e5013511b5be5117e580e5edb750abd085290665cfa408f1ce59e4cd206bdcd8b0a554627bdc18b4a5948aae22f6cc431a11456efb0f7434d2719e02b9ee9f1853a58e4332afa25e7b4cfb4f242498d53a05c205625bfee97de881bf5c07c3607cac0d1b37b7cd753ce12cd85011072cd58ff4e32bb8795408ac47797555f4dae04a6752ebc851ee38ab8bf147ce321fc95aef12492776b5e61e280c58e05529759eabb3f1e0bfc652392a22db270870b220d3b5c3e3de7a0e2fd81378b8969c3c372c3f1cd85e37619d62a7d7530620e66cfe1a9fb33f88eb203bd41617e3b973f25422fe63fba3900cc15cbeeab849827259cb658db3b91c9559befdda756f39bc8ce499d2b59ba9fa761abd0afa503c70c4e4402900be2a160c0deb308ee911b15d51f47f3d007b67fd7cd76159f0d068ad74eee9b3711ec5c8a81c6ab33b23b953c07950a67af46d6edcadb6bddf16b369314d40c0d5251d2391ea1aade4d84a737bc9a93ee53e3ae8eb1481cf88315a201143410d767501c82d9f2a1cf4f820a21e8003624814afca23e049982feb2017adf0b9ad3280b537e9bd86b7966aa01798c5803849663a7a9d4df6a721a5b473950b53548a6aef2e926e1ed79826e4797bc834b4eb47fb86b86f066b53a24e470ffa0751deb7861a2c1a3f6fc85bcd17f19cc5c7e12973507084b0a26844ec8b99e7b60358a2e2a13f38f224140bc7748fd8eda5def1b55b9d07513ced5d3c7c732e54b1013bb57a54e48a6173ed9e4fdf53b9d82d82a89a1852a4dcd14f84ce93281ee4b9d37a46d8e3b73c42cba6c81bb8b04e2c60336e9ce728ab0f4ab7e782c537f535d6022278df212ec2da6a35049ade44e12d2517aabb4c4feb4f6edcaa7832654de6e1f4654e9bf5818aaabae1f2b29a878865ef360354c0d8876f8bd5fb6327c4e6e2236cb2d6b50bbfa48e6e60c4ce56e0abd382e741b9a4abbb6be7aa86cc28709eb05acf4a701348e8526d7836d8d033500814f93402bd325f49035bb7d6ad7ef96fc3dc326999c7b1db5b5306fbb57559f4a11842a5b415559c5060fdc31ca22862d86d2a558847e2d60f9d2fc9c44a80a4b50e7016440eb83b75173711f108ed9c532906b6c08e6e0099f786f9fb2dc44d333b9b8efd7f20b48045187be770aae09eaa8af610815bdbdc001c7e6b73b137e6a325ebd4cabd3bfe65bba667e91bc6f1dd7ee6e4097e2ef5d330bef257e91aab1e5be2d5d9e3eb8469f08284b576adc72e2843dbbfd6633f43719bbb6546ba90d09b9abf5a5e727d8c7d860208fc42168fae2add00f933351ac5e8e3249ff056328c7949c90b1264166bea8cbfb31e40bead1fbb156450879bd8ed177be3d382c0be733abf1a4ded4d15b1a93620e7105f218476cd4abbf11355ba72af97198611a33e9046b5a82952d0fc6bd623f3f49339dfe97413fdbfae5fcdde3ba9160db9f2be483fa4dd0384084866e2fbe1a22dc8622b4f567a558c55786d6fbeb4ea43fb85a06e55461acd8b99e2b5495c010c0f8199c867846531e48d94bc78d2a61b78f2482c910817c4c5d78e2e6a925e2b76a90db6b310b1b83bb496ba202e16c528233072045460433f97f0ce22fa00082b2a836c598cf38a3b77ffbc8fa4343eb3d0dd41a34070c02939b463e9bc7ee5f10bd7db451e8e8cde8e425d2883b45a0dbf9f3274b4b37020a4096773f5d1112a32415ee20a72b630301a5b18b7dfd2504add943d9a1e97f2c625ea615d5984d6520a1beac314df62eae4095b436f44fb3555cf07b6724eeee81926e656aea6ac569b5f7c9b7ac647c9289070703ca5f77241cb7a876084163ba424f5b238ddc22ca1bd42b93e432bab3d5c230d39a954dab6ce8a5c44449783e3bf9adf0455592e3c229e7f5e7e766ec81839f9dbd7eca18ee4496d25cdd4a122aa0c09c592692b6ebd8758adc0e385b5c328f08616795ae89c4cd4319fe59542c49614e68818eb777c4e7295a5df37b0631a95db188d2e30b3fa0cb2aab117f952536494be2efc0d503e21970fbf4dc206eeac539536cc94316fa4979c265e06fca7b12c0e86f4dab5edea3f5682ed5df51a00b33785b5733acb6f3ac7eecc2b6eb7e501e61e5fe14596d125477c8af321addf418e04aed080e534ec572e0c70c4c2c5549badbf1955b6fede8da11e229a84c924bafdcdf925fea041e47609053e6f63d188dc30f5a56570c310b89c163c06143ecf3a526f6a22646cb06bf8f068fd06b8b6e87fa06a0bddd35e549a467fd738aa79cad2029084856da1f7eea6fdd218e5a14b2b7088dd028318bd8ed626930edbb5d3f3cb6d44089e07c6fd4cafb2d42037ce6ff9cf4f31392ff78d43fe12ae9d6cdfac5fd91575ffa5fc38c7db1b1abb49d1e64d8476e8a84d9ae71e0d5c59d83674d5b181398b40517e0ee09d70204639686ea277c3e8b3114ae1d52ed2f6a30714b7fb521a57a83c38554406982d2e20f4a6297fb29093aee1caf61a443d3685d12e0cd85e94ec4d76f36665cf43ee945d39b7a939c9317121eb13599256afbde9c02939157ee34dfa61c54e785b575e38ff0bc1aa50d985f267bb6487ad1a40793c6801268b376a85b1170d6159cb188afcb3a00d23d9e1f34ed0749740546eeab710c7a8cc601859d6f8be67311250817decb8db2c37df5ac9a1b0d818abb74b5c5c11a1a156642faaaf61b1657cddb660cf5bfbc1d747e0b0e69c1ad6c8fb2b1b0d705baae57f35c7ab502606cc03a8990d93878a5392f1da6d2343dd022b4b948791af1cb62708adf7d85deecadf1516528fcc034df6b306430f4d2001b0d313c846174725824b7e7f8e974a31c99ad8ba9eb5b52e004e55b70fd48e5cf1c598d21dafc99a54bb06a5822dcaa4c110ecc623915f6e64b6d3ff0cbc4acaa5adaf856814c79bbdaf29405f43ef2664268a20e9f02a95ab3cb8ec1995f0700c5061f8d78d9ac6a5f7d8b45b459e331310ca10d7ac34f8dff1ca4cb0b6048bfce2ff8445b2767de559bc2779f48e0caf35be2fbf3323175b2be41af342c4055812ec3b4550fd10f776174324149401366cb3f4c59a4131195d0b1eaeaaeb0e1f0c53ce8e469ea3d28a057c7589b58ce4345180b3683315d54aa781bee65805d46e7b9bb3b7df9ef95084f963b8cd3cd971429b3ee9483cd22afb37de6f31c6d10481afa8e15d9ddcf034f83cd489c001d4a514f4e1ce509d4a912025279c1f1ea7e086840b42084bb9d1a426d22dcddb8a5f143e91aac2ed51a714fcc24fc002c0765296b2e5a6f98491094c3a1f6afee24160efd53ad7e0b91afee7389959784a71911fee115d9b7d44d5ebf57a9e13ddd47600c325f879e460f45f8f1cc11aa89b441a64c9a3dad8189005cd5e156f62add3e8d551b4af9179eb9997594533424aed93b948734d85d068a51462a79c4c7a7b8813f6641bd19c5796c0347b71d93fa01d24b2ee34ae054fbb9ca05199297adb0ff85ffd442c48714097018112cbd5e1778184624bcbbfc4e1ce714e5d036d0f626fe3bb31856217a3c727e1327fe22c7d62c22412e18cee57403b01f26bd45ff2a41a5edb936545c3febb8143fe53fa415aa961a15402b9b4eeee23041cd10622698e7785025a438a95a2bf84779313d12923192edce8b19c74bdec4f8ef81971993e66d1c27e64b75a6ec4a1b4f2c787c12172bebf0715111e7d573ddd8bf2d2e9a1b3906896db7d51af1e2a726c9c86386dc46d1df92b8b886ab49a54c8aadd31a1ebad85dcd2b938d436aaea1869eeca552209d8e1e89804dc30bac6af1b9ebcecb1a8650df2c85a5ca4fff4fad87ba8feded09ae147261c09752da09669baf543cfa31b9aa970bf4019b4810df1395c65eb866d81f875ef589f7cd598a38a5881762827ce2bd9297a5dc0c1ab1a9056d1cb904bd2cf5fddbe8a8749d496db4658e11d3f7abed66d87e3d87a03d981fbc72122a326630a0349f42cafa479a21d00c64f86dcc36fe0c52f1ba40d7584d4cc720dfa2ddbcffbdea3e0f992a2184fa91c48ee1ac2fa058c741d7404a85172ce85bb3353a1793c980f065cd30ea041cca50f29fcc3c898269d00d43ccb04d58bd467aa85fe4edba34de5fab8ba28ddb492930f8b8372e1f4e556790abcc6d8ddfcc5c71ba4ba1b2c423658451492f61065be9c5799be6d7d7a2e0babb18b3cc31eae2ebe21246d5383b54c79d7f2abff6eb0a244e1a95a0119fb8899ee69b79031bc9495fceed2502ca92cda0f2129e3dc960c96c77246dcc33be048a51a38d185d30023ecae70f115e4f68de959bbcc41f70e6caea86651f12e2532c4d96c1f6a9c8d048a7d5e67d278a647a5136639c9aa6f1abf855ae9d4315a4100595ca90b888e8f00c043793c5fc106797a7226cb0dd8c6d8c3c3604bf157d02766f0686fd49a90b475b84d48f3b88469cdf682a59cdfa4ddac522d8758707b55b00f8654af3c44b7fada8d3c10c80db2164366a6fe0a135d40f7298ae5e669491ab68b98c79482f3b14ce3a988b177f1862686abf8fb07309ca1d71fc83155d91321939b564144ff4a48a205d7c8da2921c1763de36a4ca5321f4a2a70ac789d8188b7c7cb607b92b4a9b6d529adf43fbddf94e338dd8eba274fce84db96f2ee3883b8e878ae481743d77cda74e2bdd319e581d3228b85f2334acd4c75afd7f83a5b84e24ecd6a9fb5f9af08c116ba95e248650d94f2cbace181530780a0e5c398b7148e85eb5269f29a9d349cd127ef1127505bf258b5dea7c0dfc37e5aafc988beda110b18a31f7fe16917d084d86e2b5a4841f40ffbc5d6e045c7b12275d82d49e683849db74eacca94b7288c061dc36b6899f43b6262a7c4853f29b33ac0f5e118f2f04f47ce502f942f3fefd7beb5fe974f2c2a90a8da4c222d1ed59b4811959317669c5e26e0576e7a23bcf44a92fe0110a6278babcef2f69b3cd824214bd7cdd238a86efb445f9c8f4f6850929471c081833da9363f6f48b0695a512172058fa8157482f80a4db375496c8249329d5b7fc725fcec01d036e7b4ab6d70ded769aefae1e4648c73dde48302fe5671f45b34f8b80f6f337118ba0dcade4a1f344a339154f61aacfe040fa2de308a3649af2af0dd91097e0a9eaa21ce82df2ab6fc2e917b0950a3b77392571d19a8e8278de2382462d2782ed7de5981c82cdd364693306cec65208b8b9d000720565c1849e34b50eae573a69c386e31ed06c7f2e2b1dc436c2273be2680a785e8c7395f1191acb2bf4ac73bb2e6ab1332bf16141c4927e9c9e8a94ad2d13e610dd4f4e3fa92783f2b69b25605c91db2875597059bf27a16ffe2c337e4ac39fe0cb9c1b98090ba6da5e5b645aaaa772a4104af5f2fdc563f9a6ce4747c5f16cba4150e6323e8241edcd7c04a324f1a6c3c48563976d6b983c62b3c302fe606a334072e20ed35004cf6b2bd175a8918d32870e56fa8e64d0fe4ae8445bf5e2eaed8bf79c57780ee95a4df24b669a89b86aba5fc692b2206a00376bc52394d7b469fd90478179151e6351e81ced1598d8bef88684613f2537b2c3da9ab9db84fb7f4de2da45a038b4915cb9a43190fd9e82fa5831703974f52409fb65ee915e4bcaf1483720de7a979f9a2d7447e2713c4e57e280980c1c40ffef124fee4437cbde2f84902eaa2655f3892a11fee47fcfb6e6c7ff0440be9493f7eb634d59ff0e21a1dcebe94b151f369d7c27b774003525ba9bca38cc5d089af24a8fde414fb267919b8b5972856a567066502ee3c086d0bec21c18f40a4e4ad5c7c25d7570b382133871e4876191616fb5220417753b20a3342d18ec26ad8613ee1f157aa90c5129bf952394b5406fd3d50b02e3647224b23b41ad545d5a43404c8410af667c931b059c206007f900740c711c7728d985b3d12c3049dd230a2f6a307e60adee4aa9e76b2ad55233ebc43003cbdc8de48d6b9c7dd4e64dc07aa248ef0643ff7b361ed9180220b4f6d519484e4aff1f5cfab4e5471cfceacf8ffc1c7b6bd43a7ea7a3e0817377940b162bd06cb33b17c5ca8cb359c0e929d6cf9509700fca78084fcf652c9eb4bdba3d6451fa25e28dcc55d0ddfdd067aeebd9fc33e4519583f7ad982a7be82cee0d6ae4593541d4c59be9d37ccedb954b8d2594b8b457219e98a1906461045607f4625829420a62d5a6b6e214ab8df8e4084e0e63237f1df9bbff45af29be6825dba3f038b1a2c52b122b8869e0183fd9a5786ed6aba3bcdb9a3e9ca546c63182882c1f57b332b880c642b1015f2c4d7c063319a71d172b58a12a6396e539bfa59ab03f39220ef302ada6616dfad7e8107c69b523586f19e0c9ebf0a6dc5cc98cb32be072b95471b50946f4f0b9ba817e1679b4635b623cfba16125d686bf99bb7f73643774b7e159e19000fe185d97d828f0dd60d1383ac41d94b054ea70435467ef54d0fe59a9a311438407a77be98e229616487f62f1672525ba12a2505248b98888a7bde0bcf57f9922dd0006b4f06d55a87da74473d8eb82a63515f7c7f9d7cf415f9cdcbe3c65aa1f053099b7ac1174cba763d7d34162b0c580a0f17e4423dcf264729e2cf867b361828307d1b1ae492099248fe98211f5b3f2d2218f0048e452a846854867fd2ff3a492765a73e205e2bbf819e9c7d01317effe29b6a27117b464627301b16f45c843a05589542a4e77dd70252b4df7f2c77a03ca9cc8fa6f622b09c3584bca6d1007f3089d08ecc89c5f50d60a46d5c76417911a0ec22b4e3d5a0049854a4bf87559760c70b35ac85a16a7e15964e74a9b1d4737459bcfe02139bd7228ffb438b287c0d06e8b7cb44668edbd3f4a41587292c699d7af2991c753a145432f4a327fdd86ccb069506ccb9aceb4656f76bcdfdeaf5d13d63cfe8cb1099503a6da455b779bb56a95a05b623e6378b676979f60c1e2305aff77413afb59620c4e0a1160fab83e26170329fcdeb1f5b75b14c74d320c224881d87288ffb44aef2e02c439774adcc5daff9e5784fb376dae0d17ba093aa3d5ace43dedb76fea01bdb9579503713326063483573b0f8a02672a9e2d3b923168c2bb9a05e01ae4b022a73dffe7230df844a6fc866f2ebfee336056dfbb0373ef6a3fd22cd089e2e6b22e65b67efae028eab3948fc764c6e6e702fed49be0df6f1b652f1af0a8521e8febac253f5aa25e2e729129f9057c58ef07ccf27a8cce5f95168ea4c8807fde3a637ecd84081a2370322c98e8d8ba2c4260ef17a647c6c55099b5835f38fec8649cc36480c186b38fee3fccc59bb4794d518735ac9553d87f0f283cefc4c169deea3f97586615b672d65a98c2410b3d151106a9537602e8dcc4a6b1726eac17ef711b22480daaa147e65e6601663d93e73edff026e4245a2da467ce5fbca43cbd64d253b98991b9da47c1376d4498caf250304ea73e33f5fb46a7c1b98805193b58a5cbf99c57e0c5d12e59edd12eec3927e38e05ee174e7401e7465a3db0a1233e4c2b296302c4df2ca7af6e4ff32bf603eafad36e7b0457c19b2a604854d38bcf665daf67f813591a0774ea2b88eaac3581b53b05d2ca6c6a94ce77ac797a722ffec74567f60cffc6ac206ad322f9e93a4597482c4297284268dce079e1a49d2aee43898f399c459cd52968847ac709eff717ba4c6e4a3b2e65adb538f89e65a0c3ccd6bbfe14ab2df2bb767176ded35fbef5da3e1610b9ff7242c6cb4558e5c54d9501e2c50edbce12af639efc0006d14c3b25ae27d61c5df5bb1eaf417c68d78a0ef4fc578d491cf37ead2297f281a24bb6e7d37701a0d29138c528513c41db53952c98413fa1820edbdb74e5099d36a9fc5d9b42195416b0688a9c6cc8db2d36e8ea54092305ffc2010b73cdf9c998aec9de8a3842510679bb50a56507dccbbeea8dd53ba12a7a61b2731c363ba4d3177c574e283f41a3f858eb7a5567f27589047bf907bf6749fa92c62ea9c38e810d6cb57021c39f7e722db03569f3323f5f35c5744f6a2764edc94c7dbbbe5703aae5664cea1c2e16c6347c0a6209112b72df49b80e3e4d04c65a3fc269aa6ad4b60440250964d1a751d1305484f0a52a47b87b4efa918ecd80e9b768c162d6ca2e2bca6e747adc3cdbf1d371aeab4439968b84cd785ca3116e8f81331975cfe698976bc58d4dfe3249497c9eb3df6d5599e9802c149d6a5dc9534d8068c0781770313cf1061b1afc7c9dab99775e1a30ff20cc6bed50f3286e4a5a9c5b88488dbbf7df9fb7e3b53e5506fad6ddb47ac2209780c5e36cf74101c4b90651fa6db680d4462ec331a7929b11c1c6abc86156418d8bdd5b13e86d7088a049cf5a962bc889e3dca4542eea051e16b5c658f5d0df6b5c2d3f4cc772a04f418267bf788d308ff7ca62edcaa4ebd855a103beb98d386ad3e0030509f1b28642d18147f42895a9ecc93d38da3443e069435c46d3a5d3b0b5331d29e314d1345ffc5234fa451d517f6bc8b39ebd59dd100ac2c9e538e477c2b5d9d1ae366f1927e3ba44989fa9d1af25f25029f5bb3b155684b377beaf2fcb61cd7af349e924a0922ec8bc62b60efc0493e998d229a97fc2d87f3d479f302e46b798c1d41e96a6e59ff5f44af2055066c5dbadc3d8529474080b27d79ef37311c4f1116a741ccea2e51ac4fe1ce60d17dee9779dd73689ebd7394545c26a746ccc55a32d54e954b24d546d363fc01b7c24438a8e8e969eba9cc7f4c95ae899cebbb7e96f2e27a193f022377eb1e83758a64f4e01fca7f787b2f6ef89276469600a50ff72c2caf79d6ceb2f085c8f545a226a420f63d88c114d00187b43aaf5e828f0d6d84d50a30367c6786e9427f479d15652895bd91bc143dcae849be6b6c591bd62f11ab30d02b57363b3647cfa0d89e5847c4cd187478b34a033fe59f3036d76963de13d88a39bacb930ac07bdd390f762dfc0689e9f24059177561fbdb2674a09f639b6456f914513cd0b8573794daee78919471131cc892817c254b4ba0b798bc661f0ea0121a6cdbe4149c67c3933a812edfd3b5cbc1ff203f95d0e50474d238c74a4ae2aa50e32aa1c0cb31afff42952ca108875fac462d7235dc8124637025ae50173dbc930f8094d88b0298f0f6dfc126c6df5f1a8875b2fe5b0a6377657f7ca87d61ae2ab03c9aa8a79c20913f0054e3ce343211a0fbf7896b2c193dbabc194e666fd33929e174c6035a724004e4c13db260b2fdd69d8badc97416beab7bc42c266d5dee3edef3b7213806a4044081d716be8a38adfb21161fbc5f03bdec673e17951c1517649c4ee05ad51309127e9194915a6c2afb273dcdfc7c7018a6d070218b21a61beb653501041cb8c27024a6a103f3afac126082a1900e46682884825195f9441caba33123e081e0d1970001181ecbbe9ec6aa0f5d52b74fc0776409e1ea4d43bdefb3abd7226e11823e8f1b7aee608232a26a9422570f12c5ae300d49f4bed60682fb98b242a5ae7b261dafec5cbf3a03d6887e6701ad1fa348584d6ff5c8bf48a0dbe84bce26db25f698acce2d35ca284ccfa96b9e8c8a18694dc8e97025ba71ae8b64e418c9ee5805ef03e25c0f0013bbb55c53e2a1fb137949797d072d4ef96586991e077782027d87dec78adf48c3ef1120d9de1bd12eecedd016291ce40ebbc8548d438e165898a09bce09e288a360e80a11f36cee367ce5d113315529de1f39e59ae14eafc75543490717c9ddc4b06847adb4f7ffffbf2f81dd2b42455611a941b7a03ba33bbeadaaa3bd0bd72cbefe63d1033dcfbd893af43cf89ef6decf3b780b96754af964cb36203c7ce4eb75d0415cbbfaecae8bad702325b066505ebb3fb59e4bc5bc8693e4682ac278c6965439a79669c38d5582b4937f9b576bf45c9e3dc9da1ffe9ac54ef42084032a6a885e3341187cff4689d0986b07b19984a566dd182ffd736f1f9859d16686089ba3f367cd81449fbd0fdc5aa1f6a655ad00324670e851fdd82866ed938f18dce1dc860ae1f3687bb92f8047cc5f7e15bbe13c833911aa7b5602b8aab7751115ff1f43866b9bf61589d485159bac3b6cdabe3f0d4ece3570fd4dbf9fbe5f2edb2bf2f8026dde3e3118a0aaf9bc44d2c8163a0f67fc8551b130de4f88e340570961dc56c6ac903b337a6b84a8f77d6748f6a551e340255d05c6bcf47eac7b9b7ccb95bf8bf30bc84b3ea4c9fbcb908e5994a39ba2eb96bafa71114ae91ac710ca18e4462499bafc3c0b95368266f126a32ff16d0de122035423c23d1130e12de289a1e465e0ae3b50cef5e977b2efb70b19424981197a9ab5731438316ae7d2636adc8a3638cb6eb55f69a674ac25d4fe388485b4482aff560ddc2b71c75271908446a67413bd07edd665f3967feb79c2228fd1b99995f0fb735d229e866709e737adff6efcc03914a4e2d1d14f20312551df2184df8dfd366349cdfe0fcd36b80bec748f38a8f0379d630f6e7044bf7eb19fe1f5c516ad9e490e4571af4faf87a1e5b8219902d2b0b86daab93df7e4599c253772da04e8934b5a5dcddae064ddfd5249e08587b8f6b951ad76287d91775796ead3b5cd419a1833ddf315dfc54dac2172e0a4ec9c17bea89056dd5e9ac67e81d7d326c6cfe38dda5c3e9375f367d487f62e94d6213ea4ae393c472993c4059119446274baff7c1fc5123d95e146196c89be0f5bfceb8bb99ddae5b1f6c416e493a809bdef4c1989a0c0e678cdfaf20d54abec99fdd3ce2822b7c7aede6c539536b369d0fd4f805d0b749ed8ff80696e3a71fe379193fce6547316e9b59da6a7cb940cb7683bcc33c18bf66176600d2d169bfdeb3befaaaf91bb7caa15ec724c3f6c815e86384df1e24e108c607b38701d9348d03cc880656e8096008bb229ea734415480c768e3c3abdc4bab8674398b0385f2cc9af40ace3e49ec7da76dbfdd46cefa8fdcd59cac09f82db4e7681d5bfcb65ca4ccf24e7e6c04dc4d857df04b073500eb4e16b3e7e36329f7d74024ebb76af56dc355cde36ed8494144da9407569e0e33357d9ae0ffe3dc482b470af9ae60912c052285cddf6cf2cb27f3feb4634572cff838dbbb22f4ecfef085266f23450f6563f99bf040e6b4ccf329cd2ede8f0f9c93b0cd0d24af36a396a068727ae8541bc691f93ca24c643162201420c7b2d78c2f269a8f0613c9561e8f49b006dc60cbc96c376173b17b9b869a42be3c785999e2cba49c121691b6c5a265e6e3adb28b8e601ccac388cef3e76c6b2a126c6780dac68aaf8296c2c7fe93f831d5b903dd12a9f1e0dc158fc1226e1000df8d46a8a6323de4de4143060404ec064b140b7b9d9ade0ba8da31d63f5d7067723a22d53476e9715babfc86c8ce4adb76ae3b9c0b013d1dcea77dd944dcb6f171a02434ca5be53e7e751993bef30e7de361c1469d525161c9748e7fcd4264e4bc6b5690a4c187f7e791d740d8ede573287400e5eed428b8ac712100f11dd5b70eb6898e5018904356669cf84a9e32d3bcbac8ba7282797c196031ff3a926b2ed61a36e3481afc20e3c1b7283d497a8ce6dfe9ab348f67bfcb66801155acd7c463f938e661f285dc7a668f19b12266b2af65669156b67abc57c78c190b68c6135fb6faa563d8fcf31e2ce5c1d4a15eadc4f30ced551cfd46ae9685b95c85f5f5b587ad4b69f6879953bea107e64c5249d284e9b1aea1e1ddb599e9f120e9602a73d8861fcead6a31ef54beddbc269186ef54df884b33b5de79ebcc695fa5fd2fb1622ca76b9e693c60f78acb7b6baf104a9fbd8706c578064424361d0479ac3cbbedcc53b0c1cd3f7753af3b0546bcc9af8ad975f93a0b1331fa13fbd99f72e478c6137e8497a20a4d26ece49f259fed1b2ce71b9dce4db448bf18bc778027db52abbba728c0be1a849a6db71ce192f8e07736fa79cf5c0d76e7522c71640dd279f661d23c5f0b52e15a17502f00bfce14f5a73ac09217d6ebbf14f6bc38e312a1ff3263490bde12f7ebd26c275fc62ac5eea50e3abcc3abf4a57d5f661c823ce76d2c66f7d518271490416400e9275e59aed003d033096b45b696a091f0ba188725b8c6eb79cae8ab84f0fa2d3e761ef32b09aab5963ea9f7543bf2548c6eb9156dc84b17dd04fb321fdf017c8f09216d8f446424c167b4d5148506342fced42b523f3eb5844237a99e538014779ecd2d6ed498f318e61296d4d91c6b921238b33ce06ae3ddd1189ca3c35d9518d7e91168d3778f4f0480941a0827a13bf99de2f1506096dfa9fc699fc469e364323c265bf5bf07ae74502056c487359e3f053567b4c9a941b03a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
