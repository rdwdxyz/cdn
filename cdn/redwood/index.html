<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"213527faa9debaa78db1264bad33572ae96972ee6de6b2db528bc5727a09f2da3c6e1eec1da6bef6966cb64df783e26ea37dbd8f45f0b651d3c4dbff69edf7e6cb610171c8dc14c37f938f1f15a387a38ee9e16c1f79c86b00c9f2c380a84d4e30532018af7c0897745f4f9e8f91efbc6709ced8b181e830be42dba8025b3e549ef13687fa022d35f95c5386ef88d911ee4f63f5430e40bfc1e21654dd585ca8ce9551c4e6c521527905e103e569e24f30ede8e533c9b3b50c37a487682c5751ae6f2ca9a23384ca4e6ba3f0ae57b0e7040d0abbff5a00e43420e4bf064b1c49a969a5a5e36da7ff5e5ebaf261b400bdac81498e1489507f6b52bcb1f786cea7eee2b0f200932e8925eeaa4248f76b6505dfee789dca3290b7e0271a73fadbb4777cbc6cf1cc6dd5f54b3987eb8514684e2e38d17a7eea558740a5ae99574a6617627b8045d21f86a1ca81e09a3a67cb7502c15ce339e1335c5df9c80b9933cd5c3c1211f9437a99f8db679e328d5b58adf554c768bb153440eacf93aabaa5fc4e359f8d9232e6a860c16017bd7e7555d36eb9b9c3b60f09ad80e4b6f2129469aef3aa1153df8cccfc983f8240aa8cc45f046866dbc9056218c47ed1b89782e0f1da38e1509d56a87eb8eb23c97ffec3af863e13cbf6186241ed412825c406b5893258efeb43e7d2978226cfb88978902f17a3957ccc0885872cb722088c6e026514a49194f328b5855661f720443ca30fe47e70698ec9ddc52fb215e7da970a9df78b5d46935d52f45fd9ddfcb54f019a64f4ca9850dc1062a458cb4f3402aad5acf7448e4879aa420d34732c20509aef8437414b193c973cdddcf414a7d0f5886ef5d7fcaffe0362c798ee861bf7f8a04dff28171b71241a7de2f84f46a8de6e4b6e469f93d8ffb21519d1fa5eb72e0e3fd9bf0b57693ddb4221cad788f71010cff5c7d35e50d0f65f1ce09683189286e73d39f3093046a45439ae0a24aa13f8efbb216fad9b23277bfc82629bc4488c6b4329ad803c58ba715c976626e1271f349e4491fa032c6a8ae99c30412b31ff5dae0d2a97b4d2acae64a217471a115f0ae8b8c65e80a7f73cebfc86cde00f115703bad176fe8dfaa63d6c5e9d8efcf4fe06c90977d0c37981666ba9e6be79ee097568cb57604739488f2dcf9c033bf540373de2ef452ac46bbe626814dfbd96ee778d6c23c6c5c9614afa865c2e8336f180eccc1a544c70757d788ac32768fa3f678d3704762a4a5ee401ca081488f56ff925e4bd4daf050df6c33bb565bf833fd0307611ae9a7ce5dbb727d8f8df7ee45fd7a56d9ea0e9198e6ea6aafa1c0bba63d1d38fb75b8467af10c89be8bf982c361d98f57ea92751f3fa8d0083bca84fdbf8e2dc873f35163f4f9326121de9a1982e2c94370c0b0967d9ba13eead6a2054c3d305086d77d7d155bb7dd5f16dec5453516241a5231c4a83cbc82ae859a53a0415e990d76b9a87dff04e9021a71e8b4347bd3b95918376b1449480b1ab3faecfe42b6244cfbd4954526398b9aae26920f2823de0c081db03d7b9acb95b3c459290e32f2e75dbd9d8626e8166b46a66c9d80f505d7df455eaf27dab35b4783874de7d71c0590c0541e2fb819fd4843d5e7617a5e71ac10ffaf2f4ea641d2d4558dd1c162deb71909b351c6d0f02600314763302f8ebd57a58934053b1927ba18a2a277858a54bc7aa89608e5bdc3692f17574e650a7d09f9f56757245edf95b8c940fa8e1ee2e563abc5a236fe58d9b8923fc3984db2c648a4b32f112d0ed43ae3a4dd21ff21811dca4268e9e909efad8da82efecfa9414a92e9f9b08ad3e6829b698ef64fa32f8003fc70c0026edd79734d70c497e7ef9bfb39d69c382870256fa2dbd6c989d02828a4679704eaa33d5581f1d346ed720d5b6607c8b1379dec9272844481c7a718596a41a87cacb631100e07ee4ef0e85a206fd0654aabebcd4dbcd66a4ef171e1514fa78ef6ed5d693d9dfad0b9281fd60ab5187dff103592b4c342806392af073640f1a276647b7b6de077a9e85838e505bcf98e342d6e55d685e13f6f4932aaabac752ced10bde2329042a94280a3c4a6c4119cd49e7716058eb272be35806af5d45753651e7134b3290dcb7928db7eb4e341b17815f3d79ed4722bd289958c148af57e2dc45bf39054cb6b6c84366419cc0c7fc3db6c09c327fe2d57870bdeaf98b353f49e8f0940f3ed4a265cfb2ae78059a109434a3a87fc9162e2034bf31aa81d07ee723e7e394443d37958f98a73612a797ab72f1c274a4fbfaf929175dabcf3b91cee88f2da4c79bc897a97584e02daed652a0753842dbb3feef5efdefcf039f68c6c8f413ddac7cc110aa68fe38989743bfd29c1433c90c38e5f9be43444ad3105f165f489115eabb047114813bb24536743b215981fd2c2750a727a2e0a772dbd310caa763f686d7db35b31c1e520eda0ed0925d5d9f37b7b14fcd4d1e3666be7cc7dd2d992fb8941f97ab02fdb660e47e76c4c6747154ce0f7454ea6b0b8f9d887f998335c692c892638671fe8f66c790850fad1fdeb9a58456e3a15b85d3729771c08bd4183f97f9980b52c107c6d8f0a57cd6e62ed31d7c7033bb44666a02b87af71d5fff8644e31fda12b92ef43c6735254eb942633d090c1fc2821d37c0eaa959c0a5c41691946c274c3eadc59bcbcfb3f9aec134b8d262051a8932fafb9d132aee80ad1eacfaa6722f51abbcd5298a219f1c4ce53be9cf48498ef2b139c1b5344dc9a139883ec14350200c4b8155d85a336f5009a065ff6dcb57c8ce0d48027912fc3efd9d094329f65c712fe68b95b3d80208f6cf336956d634df075719f5e103f716eb942dd51b55c0fda0f4bbb346a541639ecdbbce238d60f464dc2413d35a330bb51a9f0f3558f3f6b2ef8ba64a03147066c5a46d48ee47f7ffe4d238888e0613ad647869d1b855b1f6dba398714bc83e88faccaca4713a420fa5678ac9cb27f4a54d6e27996e9f15ce1e7467096744ff6e5bc968ae031a49c0cd7b17769b88b887d40ecdb438f155ddb76ce0c0558440fb57a5ba271eff34665302943db6263e00d27366a58b774c57137bd60826c2b881c3ae66ce9142c82f30cd3124a627336793dfd109c74eb0683250bc1dca45854adc10be8c1b920ec6c7caf29eb6a51fc570bebf2b51348b2a0da5c7ebbfb138b900f56cc13ef1ee224875e9c29bb90828e4202f12411c0a6868349895a8b45a8fb3f24f2de27a439ddd75eaa22c8d10f2aff2c615e15ed9909de898cbb8d076fe59c24381955d518d06c9b933fbdc554db17db2bcf9dcdeb3e1513f78d292e6bcdc42bc5013613d4f8330240deb249428cbe0720311d3495a63054e4d6030943b681f8868f2fe1736534c803c0815ed028f97a9062dd459d89935d9afe8357aaa0b5b8d809219fbe8bdfeb3ad434cafff2e2fbf6d680b8e82bd38059008f81a10b27cb5aad9d2a67cfb9762ca9b9731b98ae76ac7223261c278314a3e11ac7caf9cb47333bc5ff7f7666a9eccaf325e59c584890ba2e3930d22312022a80cb36e667e79a3042bfdb689258d6e5dd226e86a0b430b56194252152180ce6b596ede5f25e26919d13595143d7e2d00ab5767228b97bc04bc8dba4992e7a2e84c058e087d33fed47192f56e5f14b69d20805c8706592f03a8f92d0bc17490ae87f21a4788cf26c1dd2a81fde08667fc46ed277e8461553f509d6fa3c2947b6c2e65b266c44e058a83c6660d87e62239d8f19f66a0de90446cb2745ef9a0443f65ac5421d7565f7cc2566a9b9e7502320b5b0819e007491170a28b93f86c2fa553b5e1835d1f0a161c2a01f20f2eb17afef51981ef59e40b5777d0b538f43cff6edadb54b1b475bfd2f6c082527bc3166e2a9eb305e23cf5959bd61d54ea1e70c2d8df3dbbb1a9ea28695320a4551990d6f78042c91eab43c536c7d615257a8b68dd9cc6b9a318802a20294cc3dfee731b1077448f25bef6cc8fffd05d63c85afb567b5d24e46622d9bce94e339302e1b01d74271d76e52f58eadce3d9b339eb583f68762c0043cc02f4dfb8c9043e3f3ed54a8db675a11343e8fd9675eaf6d65369487baa39fc7d4e482971fb0a3f62ffb0e570e26a46e8ef79a45a672c37e494603a6a0a67dc47c0f02aa074a5878e6a64f3f053c09747df305eaaf476d450869a11882691a3ee927758e41c1f14d3a531ccf4b362fa73da158ddae9917f918f413e1b63bde694b626da814715bab680bf25d7fcbea12732a490fd3694e3f18689ba631738c2a8721c33aa2aa5d3467d6a1f3a454d41b68ff6f144195ed9d1bc19ea83cfcd77aa84eba5c7071db93f19c97a9f0e927dd86e78fbec86adad43b46c22f4db712eade46c6614df67d04583dd71c0abc166048d3548c296af2111e3fe211772260220f291261d744ecf0dac0a739b8124b86c409bace702fe4d69a126a12464f4804f8c613f6b1d3ca3cc2f05257f8ef8fda44ba8c062f9530787b882a02a7f177326927082b03329c7267604ea6c4d7932a1463831fe83c910fc4ac4967a5fcdba3f8c21cf2515cb3f8b2ec2aa10fb962bb19b9611d4eb6c3fec01055a4d73927c671df0e20e31af4e712a4bbfd7336653c6de7f3e6d2d14b9d9fe7cf2805b09b3efb9e028b322cf3c730823df7ae9cb8a9c953ac4b675c4953468d4d4fcc00cebe07487e2cfdba31b68cf6e6688e26351f57300a8cfad020e514b795e38056b47d9e31d1230c774cef6f62b98877303fb1cdb8d0dc212dcfdc9c6f9345c69bdf2088383f13f60f8a2c291a6d6b1ba909e9fa2d684f851c57773b02c3ebe1960a0ebdb4bc846e5795ddd191d525a31651ef519eb6bca2600a1134a638821c443e00df0dc626c3c2644e4ae93b7ab17099cddd99ad9a173eecd3f5f37b6a04483b7c8c08a082fe0a266df9cdd3feb28609decc14cb04ec21bc4e0eecd4428f9f3de59b94d46a7075f8cec7b747af1811408978baf4326d2dcb0569859ea51c66f98f9149c3b594d7515b771409df98a4615977f31d1cfbbc2719f17e5399c501df6301763336f5a90bf04c8e52ea6eb03e1eeac36243cfb12696ac48bbf4f86435f5ddade851a8f23f703fc39d7478f8c11685b675f400cf33b071a8736353575eb31696bf316d3d1444b648d707b341f98390f13a0c132ba569abc276deb875de6dd3865bac1fc7e103fdb30df307269cef7081b67d2af6d5a5cd4975b95e6b222a6853c3b4dab9dbc5dd00723c3c0c464a63aabd572b94b24393f4ea7719bfaf1955541df2f781082273d0bade569413374ed07d8b4bf355b4dd0c22d5217a6b489390b7f445d2a68f3ff2d12d521f4109f61b132bc03633845a0e3f649ca94b2cee4a8fa9d59d7d45fc4d0460bd2c82e38ad24014c3b9123803ff766e8c66ae4ed44b170954a2887da273a90c499f6452a37dfa1bd0369aaa75c4fa759d8a70766f69dd08259a35472ebfd3f364de4b97d0232cf9251dd8cc40df2fc74da505db3a26e599ce72f82b4b456de23694b96f218c44c07f686e7a6882e9bf423324672d159c3f973928e1faadde7e3b9d32030ca3d282f335ca1e4216a8ce3f47e549d08058e58690b2ee828d0b3105dcdf59585b247e296094f7685e3408c06a10803d89e1d0d57161ab1454a799413b2027fcfe02c12a4656b6f97cae0d028fc3dd3a2c4decd7b2010297b1b7c9ac2b8b9ddb55f9f67797f864ca0169c9f119a0106271d6612f8987b6c05fdabe5a3656c30335d65aa8de742dfb078595a4d5825251ad0effddc0f6458e40a6e0355e6fc4147de9273b0201d0ea82203752f94f199016d160fdcfc1c1b87907d39a45f669d616a784ebc74f0d5855b09b17fb33158b1cc480f1aae4a6167d8cce536deaf6d2722dd0b17a07ef8feb5254caf57a7d4e37eb84d467c2864c3ddaf7c98e2aeb9f35fcdb63561e95362f6aa6661c89bd1183d84ef8fee0bd4c729d742e5323522015593c6c11b0b16c647d83aace249e555d9f1405d2ef5f8d0ed621d4cde9b76e8b9c40c4a64ded475ff06eebaa3ff7735005a9d1c478fd5e0edea1c2b0d619ba59b0f4712e0dfc74bcc17590597943cff37f621570d993e2dec25d8870813b7a8e79f11e52ebcbf059f8330cbf23313ec1621c8aad1270036521e522fd968f1f720667bc43665780314368830ae0605afa6b5e1875c8a3638277748d17b96334774daee47199bddb843a4cc22b188fe684130d6d0fd95e8010e2aed9739450e4b1e57e1621300e0a4c82fb87eca239b56b092ccdc2f8db8d57e7d82e23fd0bfe0d480b124c251e11dcdf7b7049487448a0a404a36be075b7b433a7480dbbca81018f0ada28448989bc67874d9dd2a9ca79a49caf729a7451dec903f9904aee7cf19d14355211391f4616ea0e0100b7a89735884354c22beb12b4a4a4211880001f40cfdd49c5e71a8bc500e4dfafabff42f57691ad7560598fc3bb9ea1bced45bb65b479086d267b617164b447cb25364682fb12df3d04c3c812138df669ae7c8b91ca4d9f37bb592a84d7286370505e8628511c136826a2ccbba18c2594ab37a48a909ae4e0a93ccf58bb7faba0d40a03b11bb578bc5fec3dbac84248b4e956253a7288270bbb5413a57c4ab65d92afc5755c7ed71a24eb61df386a0225aac3e8dad09ffc83be849ac02d76ffafa76f497908ab1c0ee1fb4b343afbc6e3c477a183d1889be3fbca920bb52bf2baca9cfa63b089683367a256eddb48f81d0ff78915d24063d9995740d2df8dd905ebdd522804a46770ce3e649d38b8d9b5d021b82ca697b502424712a545f7c0c64a7e3330d391f4dd5da2bef0c75fe980e810ae8dd701ce329f0c21ca76dd50f4cce8d13467e25e2fba5779c91ac4928e30a56f1bb3ecac96d866b758493b35230a691df9c0da76eac9d36bd8703a986a482c45f21d416543af572dde9a9b5d4b2c5d8700b26edcb0a49b6492176da76c1c5c6de6453a686057e8707905e8dadd40e7dcdc8479eea95a8ba215ea2c4e67d806dfe1a6ad2f5d15579b16a870e984856ddf02383081b037913ca4d3aeac23e736fb56b482c61344bf5c55160654e117320613aa60168f4f87eef4c57e3466ba0315e0cfa8dee6d3de160062aa7d089fec41d4e03a2604781f3bd9e69f1158ad79ea90683f29164ea83d950db410f321e83fbbaece7d5124e158a4a4c23cc0c9a2e959ad8fdff255961201160a42c88ae5e9c2a48643503ba8b52d5846ddae2a6c069fbaf9dc1159ccbab4af1985cfab7281c54c351b453605d2fbbaf91b8636c76755dcd338bea21331e20bbac15759c58fce56c634455248d2d7de785c5d779b117a29eae43f2debd8f0e7b22910baeb3e8d93e653757da57a826e7998a5f93e90323f8dea2130c8d2ab9ae65b5082d49d5ca1502c309b04dfe6a50acf3ee9564d6efd5fd3dc1c0ac5a4d35fc5c69bfe53ff16f1c6b4f8485d546fc6d7920a7b10f390c048dddb26a8d335e6579483bac9040459790b9f1bc6ed64f1d00c869c51ebd0c6eb7d6afec96a82f74c5985d8d09578b5610f28cf37e838ce8e3dbe354f3c736ec3dfc5c85c6798777c9f8e0896b73dd7e0380024bf9979b89ecd229886641fa45a1990cd89eb6d0909f6816955444fcf3ef3d33553d14ea754e779f71ba2ab3d55fb3c3c0525539560089115de98b3c8f62adbb9477cc630363e593ee79eaaec34ade5e543740c2013eca288a7e07b966378dd1f9edac4aeb4bcbf2c42dffad5f24da0e8cdc42d5e52cbec72dcb8881f89e6f9762100738f6c1e015ed8260ae7081c98865ab9c819296561d925515b8840e6f6159851677a040be28979c2459eb370b60e6072f24eb87d0ebe82bda6df9813b0b260564c67781546afc5d1de036c93883711d7b75f05136f0a8a27fba76c4e7b5ed7a52473a3a4bf1bd61e82b7dadd645ed5fc07b9ca4f127bd10098b371225a75bce5321bb0bc477dd508bfc875aac625005052e3a82f32054df6111d3992d1dc45029f62bb90b40531f71e7f7e3471ca4345159d2bb02a9f2293134af08ee8e027d8dad4e78ba6ad88c12f6985ba1df25195574848de28bdf2dc06a6050f6c9bfe418ecde8f5e4ae3df572b40be28988703461653b18e201ce9c61c6f4c21a41997c3def60e729621fe647ab84be6eb1e82097ec1ab3cc4deb71f57fd111103d06b10c27047d5bfeb31386e302f7d3a21abc0453916641b7c458e9be898b19327e962029de793e37df51708c7f6e763fb28825785f483bab90d16e72f2739ca8887b18c4d77c14e78307894f2a28b381a982e0948f27a9cd63636e1b74b7364af3b0f8dd341f616409f667aa39a2fbc7715a284ba1fb26018ec7a537533c7fc222b5113c42bb15f722f5aeedb894a20960c50e4230b4058453c5ec91ad520cb53e906ebaf85953d8a7299fdb4d9d5d1632cc5afb4d8f3f40f643a6b7cf74f85ba7e00ba8483dc4dc5e1d2bb1e1ea2410272a8ee051866bd335f300fc2501213b658c668c5e314e1961b8b938d7cc470681c54dc8d4addb2b2dda367d5a09197b9b22b8f286f86ce17c2ad71a320d00873c6473658ae5f0c140943da1dc8b0d885fb6c6062edda17ca8c12fdf50e157d367e3e878318b8561e087dd6d980a948af7c6fb423a32c958ac287be03f569784b655208dc47840e4ed289f64824881d1a902a04598761fefbff231cfa85ebbaa7319c4eeaba2c501c88df38a1309ba6544bfdddda6b04717cc1e99c222aca2829e26f2b69054b96a0ca9c87772da64fc8a4445bd7175a0d0d4c421031b8b1020a5b6fb053eda8af5a84391680d4145f9179d99d8259e246d978d243b123dd1066a39b26efcd60a7fbe209c82eb861f43e043e55e7e2ff6b862032429cd6a9ab9e7bf7eb50767c0d44d381d7c7fa8db9465d6dcba9dfd749d13487555135f29c157d16e91083a73d2b108b16193a28da9232f95573c14d0b90cab21456e6a610f9c510b9a0c8493eb6c5b441229401a1489844c9e8d84a9a9a574fda66f78e935d319ddf171f394334be351fc6f13c560c7a20947eb3cced6dce0de06401be4cc7cb8c60fb3d53dc40166ed1ae30c3a74daa2457ad1a7563edf85480eccd97babb61db969027339b678c2d9c5b45c7b42a8d1704198b23f76fe85d39a05d4cf1fa1278e9d6d3ee2294a8ae5a1380208a22b9d773b6fbcb5cf8f66968a1498d81f09de5a8eeaa2a74aea3d099b743292710b1dfef10dc1673dbb39b382b8145c5117dcbcd96d1f7a4698ec5e550533d21022617b05bdb50ba679db0f1b9f0515581f91c4b76d49b12fb0218f717579b01ab3e74c19e62e01a547a5dea88d897b360441b0b23e078788d6728ec8460aad5a4371bafec3f464f4bc1f58feb61ad1238684c6ec49abe80008db34a9334eadd416eaa4ccdf3a84e46b8dd49edc2986231415de4d830ce5595c3d51885184fb9a9ab4881b1b147af0559b970185ff9a3ca077b28a8dc49f6282fdef30fdda526b9356f099db243675d491edce9c947ee054ee4733076fceca9ea9234db442fea9cce1562fd35aa0a610e7a47a96fd95c849a15b735f52874b519a2a2137a6cbbcb0d728ca061fec5be7690d0b7bce613cc4d54d8af11fa48a32c547a513d0034ad7a9b7b8bf07607bc1fdb82a852b5ddb3cf9fd8b9e617513a487a103fd7170c15eaf155431e925d55999e21cf2f455414942dc9d3e6aed57427a796eac512c59b2babb8846423139486bcd4eb0b23e12d3bc462462261efc5c002dbe8abdf95deefc1fb954c6bd533f73ccb28ecffc92ce5982657a794bb653724b3ae5ce4f6a6b8c970e54263465b93de98eb9d3573480a6f08fb7eb13b3493fdccb01cec3a8e33168a123bb42f09f1db13901c8b449774d71a28f7d81378888b9d827e08cbbf1cab0069bba37a3bddd9d410b1042f941cb90bda2fba3ba1a4db5b6cc1dc6a0dffb4788ed1f262e3e6a82f8dab0a48898fd01565daa0c16bb0ffb613d3af991cc19d7195cb3323e2bfcc1119ba446dd787a623120b72f15b440a1e8b28b4bc8d81e15523199aed35afa65d2e30231010808fa75115eba4ec07625a69e756984f94a9db41c5280a642d23afa4c5b5378557a6d3192a5b7bcb41ed0a7dce0cc8b2fce3f0d03f4cc99ab68f6fe96406d2222c8a53a2408ac1992b79e92b4121ce8c60ceee8c8647031c48552f68ebb47a716733b316f58e021425f0f23e63cdd4c2087e03bf9cae6c2368aecd4a5a02e1c44957034231309ae37d82aac2fcddfc08eeb7f7c1a957f6198f32b98f8f527dba86f69321a3968cb40a2087749a108ab6aa49704940051aacde56906d75f710e4ef56c69d56d5a0c46bf74e8e628816c084b676a60c35bd603825be554eeb0bc953ef745cdb77a17a0d5ac27364578da0e29f2911f6aeaf14719966ed89859ba684bee78d3f00621e5e2288a3aca9a5acb29e8aca9f4c77a8966555c5270d37f29c9ffaf644e46dda8939e56816d4ebe9d188158caf12a3a62c6d72d66516e95375ae50804eafa66ef98aabaaabdf57ff7bbd1508c3c882d3058a247e04fc14252a473e46c788a2914fcbb9ec874f0c217891d6d97d23551ec216fc2d8ef613cba283c2a806e41eea1a3f68e6d0b00c03d14df8c0784fc2172e15f6d8e7b7f457ca469d1be0f303ac3c0da2d9618e1c58db21e09555277ebdc6d41f6f73f4119f85567a4217bef0046810ae01a88c74be30dd8e96d5f6586284e1b270b04682772b2255a890047c027a7439e993457b11089244723f2259960332a8d20c83cc9232048856d51261e03caa7e69bdc1226f9dfec80ec3da9481ac9273e9f803d112c3ab8f9f9cf5c0d3be07eb83eeb15f42cca8107da010149d694fafeda45da8acf005393ebd5bec940f69871226fd639ee7e4d4576282535b3a24343cf2f951d975d596fa45fbec48c0c8d9b03d1660b2309f7a1893af6094ba9ac6e35ec17f13dafb976fc891bbce4ff81196b73a9225fc0b2e370c99bd3062026790c96b4a72d01cfc4936cffaf17e399b3cc3bd7367591179a0b8f60607856a86dbb1a5dbb34da09354cbb2abb6b7b0acc81d75f301a1306e56302ee7db759374ea4d58fad84c1cbab6c4d0136ed38bbe62dbef312f9660c37e55f7333754ad9067a2c7dad7080924e1445c476c2b9af509d1aa0994e4c648cfc26061cd0cf3cb027a6bb3c5880f48bb938c24fec30907e1006255fdaca6b3a459ec6f7d0e2aa8c881dd72e9a5471c90a4fed6a9811391cdcb76796cf59548656e9bb5cc68f6d57789978d17679093babc88663fabb0118019b8e8b40810264a764d831241843681b93b5e2acbedac92ea02a25881805b18940274c9053a154ff3101025196a72e74fe65497d8d12e22322fb270a8341230354bcca02d82ab991c0faf05137e27233061fc20f99cabaa3c7d420061a316d99069331ec8ba54129ec770fc2526ebe15c00e453cb7385e3e4d05f7cfbf61872a12b7d9c4a1b707f551ea4dea612151da4c5d784165c020738a3fa62ac9b12f0995411b8d8a48ad4682c53017c0778d3813cb47156836c8e062ea6ea8736093f753ab9c3af8f305783e9d4478a5e3dafe264741a157f1c8b614f91f380ae07e42f0d8b3fda66c2f44b0721145f91d64419f3231e4bf9d5ad8f13e25a6078e04f2912363ae07b2fec17f8fefc253253b1b064f8019ee04015462df1f133b6b6e9921e72968241be776df4540e31ebb34f606b6217d5a58c484044ca1b4c4d0ab370963fa21d34e12bb8d35da3a68f55e244236455703e33e9745f88db8f8eb689048589ce9d85f441895f68e6660301d60897e28380aaef44f7e0be78ed3c3005b6520753f8a1b9f3eed070c5983b7fac3ade069a1d98548a7218ed1de5d484ed2ae7908c24157e89d594051ba5f72049d2ecff4d856d46f65ba3aeb9dddcc6c3b62fed0fc1b4ffcbc25ca79347246c9308fbc26584272c80b5af43ad2e6cfd88c54bd1f9b067d8b7543b959e02023a897ffca792ebeb6ba36e2367aee762477b90ac32a4050e4b7215a075e8cf02b892aeec033ecb002b8b2fbd6b3c2a14d461c14cc9b0ee66ce73b07172871edc2b9e0b0ff008a912cf5994fd0cf13925bb9efb4ae6a0ca6361c219a55099ccfb85841531b3012732406ae6012fbb52e290e68c6c2ec2f28fe2d4fc65c2ee72a0e02088d983fbb0fe021db79caa76dc8224d95c15987c389a52281122bcfa09992a2c9ed3fe19ac1a49193b3f51bb2bcb031e4dff0d720388ec639f554622bf690441a888eb190b40d4cb0f3495ce0da258c5ecd9c6a9fd4c74a862d89f28cc21385afeeddc6e0ccb225f1230500c72ee9f333ee7f1cbb16713690dcbbb9f749a83e9cf0ad7ab93fadae242b5a18caa6d779b953eb6c6b7b122aed3aed71803b41eb9d34ea02b8658cdf3676fb06d49afe89be7de4f6f3897f8362154f3ac9c0742006ed5ec651e7cda9279c53c0a9f061db216b89fd337a9248acfc6e8e01f54527c0e4a328839786d3c1b3c04cda641f230f21714f02ebd437d971376830a85bf3e9b4d8985490aadc7a3fa5b6566d997994571b863aa6c2bba945e063ea6379f11ad3c052000e5236a87461e50734bd5d0a78c8f13b50b4623fe71d78c463a8a2eacba5732b42aa4ac335935f59025d5b93d171679153610805170f0d856a720fc59a202d2e5dbf326978513c70d3a3625701dacef5fd778beb34bbfd1a354cc2b052568c7a412ec5ba3f4bb8ccc6b541017b1b481a03373df43175979f886036be329eb9352955896b97866f32476be59af65a1e93465c0edc0559daf50516084549ebcd4f03a2bf59877dfc1a4aa1eb6ada8e56ab5fafb641df089af1590436309a56b071733e54ddba08adb71c20b3964fd323e7575b10d0296da212e58412e506ed108e7299b49ec40425fcccd6fedcc32e3f528faad0deb134900af10b4aa1f1d288cbd26fe3e72a611336934a5117601276a3e664ff68d28ffb0405381609d0c154e0143e290527b84d48259bbf0a7fb5f6c4a3f4a5b7e5b2f4e99e17ea940a3f615a04ca1e09e868e04cc343e7448f760221307081f50762ac23fa3558334d8ffac8014ee7d2d054584ad6dae034e073ae88ab05b6a5f6a5a48e17b52e0318b417b3e203d3fa14316eadf6e3a23fa322bbd6bfad9fe5285c3f5734b6aecc6b88292290d105d8bdfa415bc29236a091cb791e86269da0933678c7fd9e87630581532ce8b90e6269d277017427f171ce8280e65f9ce4056816bd26938d851f393a3c000c90341f7f87be9eabf2e346d6e25762a54d1c7f73fa560c420be2d0bf0b870da1d056ea7ea225eba8b91f859d6b097b2ffd30144e79fd8019978e3385fcffe701e1e2a1c76b6e548de06addcf7e44052afb43321d238fcf304fe20af746f641ed2940d82c715be7c14b89515e46d9bd6e5164befc259b932deef9c16d448de98b4b1e9bc4ae282a2be3924ca27ac2fe0711ed659038a535d7106772ff4073f3d942ff29c5a09fe91c794152c62379627065e10655575df7feb377ed2d146ad79290985067e8277bf74f3b63403b34b375f8226b9f77b7758205017f45593def11faaab97e50e6db8f27b9551eb0dd022bbdff1fde982901ed2f58385288096f308dd70cbd5b280c192f1665c9193d164aa2e5299bfa241c51c18c9158307425868ea184ef99204bc24c3bf2ae8ae775445892050092959a9f8d45b5c77d8a8868435995203efb773112d2a7de8db3eb6397086d29de8be6cbd207ba2dfc3fad59751e24351b1af9ab917c88b9dd95aa15ec4e34f528cb564dbaac2541c5d5cbd4d6f7d0199453a862cd55600e00db8c23486ee8fe085ca8bc105b5ed4c49118fae74de6adf6446ef509fa83f551e3ab70c9e45de356368ccabe0e330c6525579d0e87934e28961bbe1bebfced421cae865a731cebfcf1253f6129f1a861cafa537722f5dfbcae82b4acdbb7b6a12202a5d033c83c0b1f4e0462bdedad80e2edf9f9db4a47af6396673e3b8faef371ef17925bac49444318887a2d0c52c9abaddcb3454d582d84ccf958200a39280e8a4e95c1c266fca735e1f1158d9d67703e37121bd788f990ccaf08cd0744b1cca1cd42fcdce3ba33036c33de41a02c78b0ed8e4a7e5b042d7c095a2d4c5517c882c2525ab9791b2e25cdd54ebb5a3ad34da15065a2e28f464e583be1d94a814d3d1fe94ab4b5bd9b155aef9cea221f2531dcee6d96b9da9f56d32400cc65f20c4161d699f66bc92e1e882a82df78b70409c53a73f9f8343f48de8f558df709d05531d82cebe499792ae62c2939ca18afbd253a4feb248bba728665b623303734f1d4472ec2377bf31490aea377ccaa9632a53c1177ecf4c7545febeb2274b2052df2cefad6ab4616b8930845989bfc15ddb29489bd558f8d8a26bd404516ae4ca0ed60d54073b867022f8987964611403c55fb5c5a4600791f917e4dbf9f899aa9b54f20225164cc124a62725751a46adce501f4b8377d4244e6172a60a729b7ea7600a13cef1a20042b6011673c82a18646f160fd8ae5b09ee595a0e7d95ae9c01ff4043a03ce84e12920aa15647fe6a2b33914dd6ef36ea4bece7186f1b17d6b314616c8db6db9315c9aba5116a60521b392cfd2677f28e049bfd681ac2d874becf1933846ab60d9260c2e68c8b1d6d9c267291b8a191e09040cc93d98981de7292595a2ad4e46482b0a0fb58ac025b4ca2fe03eb54768f60e2af78c9801e8ea612e67aa63191908d33733b66abf4c958dd5bffa2535a4a12395ae352fb5e6b4ffcac189bf82a8a6bf151fe799a4853c27db60e34eb26bb74f69aef3decf90feb5ba935bd38863e5877850b0dd7f544e317864a1c2bbee7136ac7eac144eebe9f217567888446678a9e5bbd6470b3d47a9b505b02bee434395b962979cffa760d664f82648c284b2ff51250c651b5622d219e5538f33ccbf393707c25aecaafa053b6b710fc837397b3bb62f401eb8e586215c3c272e795cb434bc42f817b81cce03c1f0e91d450f65395d397ebab9a96b917d841fd11fb27063bf99b2cc964aae122d1037c5c65a16a1b939174370838f27e50d2dad353643b539180d929bcf5678416d0f8ed1594dad2a29ee85dc784c9271dbca8cd1507aa2222a22872e7e7c4d14b3fb6b93adcb7c9a4fe624a754475b19e8aaf8450f27c3c99f88c0d261e8bdea80cdc5eb6b0d5e8ecdcbf1543166b2004329ae5facccc78099b5d9a7836af8a6e86e165571336a34fec56d973757fe599e468c1681163c56cd19e0379d9fc009184ce4b0fee0316dffbbbd4e1658724348e4ae61e5601ae20d6e5a876163df5bdeb79bbf8e22843dadd169fe238130f1c8caf13f03c8040f7c6c05a8dc5740eb592de3b284e4cff7fa6ec54b96a433f1448f38814875c830e8fc95722da0192bbe311b544d88e7872b1691e559913bd686923d8e71ffda021f0e4d8a3a5b1d388fd5ca8ba64ebf3d120ae6ba9c8c7f8b3e85616e8ccf4bd199861d2dc71132b79bb5644cac94f5fd0a01f2cbbd0e34537a8c40c9c2e920d1060ce5a123e5d808735b901990dbff3e732efd218a45dd70f0f55686523bfe6902c061e2fae113207c2c5c2aab6321d14c03213605c2518d47a3a74b03b356867d958820565e160580a2d8dfc8a41ac27e3da569f9fbd680b6399ca6e4e95487d104f99faf6f0cccf2674d38fdc98650319d62dd45e2aafbe4bbd4488d4a36d5965c0762b1f1e9a9bd2f362586658c1a289c90d719301b4c4231387c2b41b0f5cd47d7e6250003baa358f9de729a3b01b387695fdf297ff60ab42cfb02ac40763516d8a0ad971364f6b7f5b0e8e430f6a012c7f0f99e3923b416d5b778bc999911383ca994454f3eb5f28710fb6c9e4516723c38f30db69f10cfabed229ff9219a8a9bcb3e1946b43f647899447b328660caac4c972ddb0a8aa25a68f56ac482c9d1fa18b2980780986c536324af696fc86118b83bf01bbb89d608452991a56aa951322d89e8901d9e3baecadf28aabe9714311db9f77108228c64e29ed9d1eb140cdee00b3a50438927fea3ec119a4bdcce5f656bd352ebf4643e24b2152f65d263a1257304c3526eee3cb8a7b8f0185790479d4b860cb578f9be9fa781f699a55c20ca7b1dd6ed08fa04900ba1d02f3d620ad6ca709cea5024ff631d0bbc7f0e77bf60da776508f20310a4dd99ad928dea8e810579534d161a51cd2b32ea1be630dac966566cd204dd26fd6b26d76f060a4df7b9d4cc8cc1b3a730d921b5068edd9f43f53be040e964c1b058d8cb3845f481d25cc07eb86f0074cd1dfd44c5090d909b27a2c576de93ed8550cdd3f34bf1f4b02592f386b3d589f4a8a2283f1d0d5cc08b22a0ce66f286db86785cea377f3efb912a0607ac87e1f52a71aa32f0a667a82786509c3299c53c4b6afde62ce4dadef2b58a6de5e0f57ac0ac1d76c0b28aec6d43a5597df7f63e59cfcd9d9479241420f2c28d357e7adc49657f47973d44f7bda316d8222e4ad604e2fa9a989d5f806f4c9a3956695f7c7115fdf035097409fe7ee651e1cff03272fb18f7164d78bf4f421a2e15372b8e14e4521dc38087976e6050abbf459ce4a761c406fce36dd91bb23ac61aac964c66fb681f745066aa69e26fc97f345e599f1fef1239da44eeca0e78e8fc4f0886a4adbdbdaaa5f16b6b87d0db69baa1cc1f9aa2827dfbccd1bbc2f9c9d39e97b96b0627e81fd1120692c29e32e5f07d9ef0b728410144182a65d40f57e4e537e46c161477144f3bcd5736a1fdec8f996e4ee46e973dcb2266beb4fb9ff5c1b6d594c1dc73aa66f34723b3be3006ddd8266b51e71bbe9582aab5078a38bda8cb079a2c03e6341aaae105de67680540eb20f2c2bf344903652871700427031a30236e1e66cf004ca72bd74d411e9b92b1b4c6789d72ad9c8f6df8138a4b39fba5887b6eece37f52a0ffd7f4481d6d0f61dd062af105d609e498039adeba791620f43c78ad84727c731886b7dbc7fdde24cfa9ccf0916beb60ecdce46d66a12eaca6c62eaf0b5c09dbc8082e6ca70b54a68e7221ce24849911b12c31f4f091fbd279c41f351d6494774e056e24c83adec4c5bee0d1301fcfb38e0ed3c23fff663bd555dd8358f608ac466b7707a75305fce60522a273511d581b02c09ce28287fd78b69c12f83e0c0de2426d82ee5234141589bed50862835e86300efc7528821c9c18070133d231d16e33642685c85e8f01a2832edac00dfc8a2e313bc38edc367ded276c75ca0f59643752bb0eca3ba679687a16f409552b43a6537f13ff7c69d033ee61b85fd3df7ab0775b3587f4e59ca5c257765189ad8391e5650d5babcdc8521b7b8a7359b70208fe202218e7afa711c4d8ab75cb722e0aecb8070ab675fe86f8aa2d80adae9832b09511664a826c5464f324c5c13041382ae43a0d5499cdcd9f2cbcf85d3234c1e6285d3860d86a178ab6e0dc3a014d2e3dfdfd91774f88bf938571683da0004c0fe12613d8e49e9ca1f4f9413fd82af76e21acea23634dd88842de028bfb2c95b6f0fc5870f33bf7e7a47f5a09c28e4c418b951464da772ddc0cd67627fe4a472561809652b56ded44c276053dd606a6b3cacbee289b6e47f48102fc1bfb7919c0bd3d9533545fc47529646411cda9cce1c0cfb7b13415e1d6bdfc3b162bb610ae12809851d1acb7ce0e423c93c322ffd3e2f65df57e12c4cfba511cd2a1f806e4b39d29f1f24c4cdc687dc8f4aba0617e04b1d570c2cacc8a8da5147496e02837fae26991ccfe541cd6ff85b3aad911f3d2ab2b9c735fdda74aee86f61c2c400feadf37e651148f27fe2130bdb5ee08e91e6cbafddd8df6d0a1dc99754867d14d03f94761694371ae57141cfc7d39adb28a8fa31e35272c47cf505c181ff20b4700f57cf652bcd44d978cd96db5bafeec9e5f27dfdb15b7cba6ef6c145004c653939b0f3f48231778264c14131643b4a4f9c98dcaad932ef54be","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
