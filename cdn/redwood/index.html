<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b77146e410e89ec247e7786c8c7dec4682910f2af6253964e535770b34d399cae42bd1d894c9604be2176cb5f83130620e8d8ce0d4a3bb932769ae75db22e5f89ec8a2768b7e5be08062e6b7d3e3b5494a3def727afc1d2d5af83602c04038cbb4d39dda72ce4ab157514fa5d96ca7e5594837db2d4583be8f365baa5d06aa33064ce3bdf30d78f3b5969f0057d41702973c3e811c2a2c519849f76e309df822e2180b6ba29c2229895a6666e2cb696767f3882bb637c0dc17cc8a72c64e0f48de506eb8e17b187584101a7b9f65314790d1765ab81c3dfe9561038de684e80d0b86483a2f71572a5613cd1f95c123e92d0f6d35495a90def4c5099ea642b4cc5d2b1410c476df7f14f6fb74ee83cb89f47d7ba14804c802d35817a9cf83e34e30fcb1eb730af84ed29439a3aa62d776d8249ac7dc5be99805a6fb192ec10bd4547948aa26666062118029d4be3e52df40360a7c1973d3603c5aa6c3122cec633e384e141472c4800b26575b0cfd36239a38df974f483cc4040941a9455e77b5510b98360acb1cbd3dad86a0f392042bbc1f91062080f905d002dc5152b9d5c0ee745ee380ba6394078186098dfbfec89ce6f1eae9f574fdcd0a5517fa84d6fd6f97f128ae9db16e1609abe37597a270ba9c5429a56386436a7a83775423eecdd1ed7fe2c85716ab55418c790e451a382de59e331bc99029a7ec7c87aff28cf628ad98d3e8c0aee630d12be442d603d00299aeca45b6d77a176f3f162fd6a696f9961dcfcf86fb0687000ad735fe85a264bcf00f02faaff607778a14fd3c59109bf287dc3af38919cd07ed8d5d2e0393a4251be2b59821be116e43bd991c025389d234217d5a08eded9063390d153cd6dc91784fd5c33ec7bb5421c2e0c5f89bdcde29fb933aee70da8e478b4aa34aae27b0e3b48836dc795ec5bda534493b3d1a026d68ebff22c92ee4fcc6ecfc110bf9441f5f2861a5a90806b64e65c9d643af52b73104c829bc0435eca5e3d8c7480c71d25c02dcbfed66017b297fa997dfcf9cbc60446829c469957047a7f88e09e999c43854bd71c4794626cd81c0fa304088a8a0c5432dc0780396aedc37a3cfd9ffbcc79057e5cfd1c1062d190b80abef4db928367ea47638f1b2c338eeb4279d51c490ef7de65a15d5a7aa8f924a556bc3743bb9f8fdd630d5a84d7505b453770f7146b2fd4fa0aca9f1ad9ae1167b843f142c0e0c2be45597be6d6c4813766c432d4ff8dd0415d94debed77d781d1238a3c227d0afe2f56cad66a8c63cbab53576ad98a7f6af4890e88733af5a4ec41d6c78907c202e28225fe40d5a48c703d2a06ce47d68f328928fb66ec9dbaa0d0ce65d8bb44a7df1ac484618ed6a545fe5f8402c960a580cc2e874f9ee787a3a02fd21a7ddb6ecc5cec003be3d583b8d3c6009f7dae94e7a177b900f07f1472372f2ce813e98fd50f307ec513b2724eda8ee6f7285e7f33cdff68d98e727eb32ce2fd89a3190648a651fa7dae170a6bf60a339a6e7f78cefb7b72d2a55add7b415b4c66c941b7728f81468cf0e1c2f829a06a1289c241ec4b16c106808cc727a93b5779210cbee8985feb70bf98bf561501fece7d5c3793e9da5cf23885542755d247893e14629b5073f052511a0920fdc619cffcd51f14a1e57833f2103a5d8a11870fc9cfad4ea6ffb12fd92a7e240532943a47b3eb2e9b396e841ef7b6b048c8917222c27a7ad116abdd9c676e4a697f71620dad01baf7b25e62978f5d72894fe697abe2d429567fca1fb8e03f56358c9d5f5172828c5b4c13db62e8cb164307ed761f9c334f06bbf2a738366755ad496b533a98a52f4e74ef579785a8d088ab9bf02563aca0e558cf041254a50b75f73168d11fe7e03c9fcdea6ca6ef3f8589df01736c115886ca5bea5b64f59dff0087fec8e8227ea237681b9a0fcc3cbcefe012a5921545655bcfa4c6265ae44997ac86cd923eab682fdb74c039fa27c939cbb062a885f31548b2b465fde4d92aaa2c2f733555b55a8b5667d0ad50cc6a780bddc6e6969dadd35390e6309feffa7db7b12c051207880c861a3701f3689b29bac400658f8dea8dd05d2f36ed21be28f8d22b67f0e6c03d40ae5dc7ab9f27365f197c3ddac668c7afe62015c2dd8dfa5864da6ca8c6429916aad1dce37209556c27ac23145cdd1b0117eae30189acaf8d3130fa96652e0521a2631d75f3cf01e5afcd0259ba1f87aaacfb306bc6492257906061fa084c172d9f9e12f572537b9a438a57e331ce26d78e2fd4aef75c237130e3cc743916117db18e451f5ab9480c28f881141387776f81cd367daa6c6bdd6cd06000643d84bb70d036de767424ccc414fa56f4e91909348dfe26aabb361245b4bc76aef7fccaf968c820de82a069dc51453de97db95ea3b60237d17d160fa13ad15091f3c4a5efcc31bcb283c3aa46e1ca110e1caa8d13940483c5344a8918aaa85cb9b1de4bf4bdcaae4f088d5f4d243d0fd94be0c6577f0561d4ec22e0100016eb84b25bfb7407cdfa125c48bfaefadcb5e7ba4445d36aea4c9dc075831e7d3a933dbe7223f4b75197f107b30b1d72f3c14adf2fbe6760a0ad0a4c36aa6f748565df7a8a5bf39e68c49c55d1ba17a574c5f541bca0b2964c23bb53d8a54b99ec5ae70480f5f35a4f010c457f8caece35be415e767828fe08856018e38dafd8a3b41b6271bd33fb36d68ec3277014ca984d03ced270851ffc453d0a3276fb27f29a70fa5fff8cf2026793ecc3997fc8471b14a9124a57da2508791b78c02e35f8f0a6fd066383a48eec731f66891a3223cd4c4d82f063e348b93b6154c081fbbb181014954c2c233ae65cd22a5391aaabfb873c40ae2793a3493528b4d7a025ddd93b75433ef8bcaf8bb146bc0b5566e2b2ef7ef350580a5f55512ee1baa6c1cc6590daa4806131b5e4c565835872959a61cd16d006f2adc36599b9386b037e5e98c75fa2056a40d712a11a0ffb8c94a061a3fd4719d09fb29d77280c37560e6df4df1f745f39976bae0557601509658d7f32e696c6ec0daaa39677ca719950b75b50ec715d313917a78dc867d5a9d394f2b1919105502c576b753ac7ef136027903c62b3f338a07c1cc8d5a4b0d9450fdb54d1b00c43ec3eb50d15bed08d390019722dc3cc244ccbe01b9dff9ec28f350d882f6b729f0ee4a02dfb3634467c2c77ffde4f8056f420583681bf1b145a187004e2ab931d74ae01aa11fdf5a262966e25cbc4ee2ab58df83936698d6e01442f9fe7a178d9fe2acecd1380483c24a7d2f801ad94efbfa238069939bb4a39b9249da2521331a2e9bf0cec18210ce3c34139636e733a0cd41964f880a11b19dc5e65ced920cf9f8c0fba5e3d958ae5bcad5aac0556dbd69444853091f260a408ff0427c2dc94c0d24f4954315a253d5fc18021f72474b2843aa72cf54d99fb262d105cc81dda0803b32d75de2eb6a93c2ae499e8d16de5e68a687761ff36016b93439e5a0cad90bb36ae296ed87e7cd9f03555aad79f1d87e8711c2516f1c986df9ed4ad22c51d649949500eaf557465ff060562f61ad904774521f18790ca16502860373dde467d1d3c7704590ceba4c3e5b8a0c9683c0162ddc844d76bab3b1c117daf9a9a60d08983f27c2db5b3b517805f13c9ba1d9ee13efabaecbe23ea949983b59ec823955597adb10e5d56fed3d65a46bd9f5d7bb7931dbcbb538fc35534aff01c4487e8b030156d9160d88ea287135a3d53862301360f42cbdf6b55698d6b32ef1123e8602b10d1f484fe032e14848a1855d106956b7fe9dae0faf4bd7c2392a221dfea2a294fb47f26e957f97202375114699f25da5b08bcb761cf2c0e18d48cdd625304a668a05c83e17c9ab43732b6d2e771db43a12842b2f0979f5cbd0d09246cdedae18334ce0130f3bac351bf8248e70a5c50ed45821792918341226485574009dd536b2e0df63028f18acb345f0d20b52f1071fe3ba6ccc81eec697751f5db5cf99d1755de74b1fd62110a33d520abcfab78abcc494ca5765549432a2e5d430285bbde596b87e38f2554f4121aae0c59d35c2f90f4678fc583ee75898797e24660c8ccf22bd9d080a558e1ffb031c674c1fa34532e66dbb7ddeb9179d59d7db13cd1a1b7a7bf15cba911f62f663e54c638efd5ff9de31149a3d576040986bfe95950e8ec681038bff3a0f9c9de98b36bf2901140cb31612a3e885db91e11a9acbf9af76233ab628413176cdb7f68f86537c6856aad927cf1bb276e6f61980a8085232fda8b011bf74e8632f2e3e0333ba314d4cac141685cabfe688057c1e123c87e000f345df7dc46156b76bffd66f8ea2b53a700970502b281c15f2497161ffbd359c58492064a21035d1c35bfcc8cddce59702260e07b7fd72e90cc1f62a1fd0eb3c368ae18595bb918d4367b719d2e42934da666d195f66362e739cf4b873d7adb81b5a45b51e8c23030d8068cf6f9c31e01098a5a8d7ea5cce53c7991c407135efdfdb54a96097286fe3c1a084ddd7c7563690126d86f913fbb70f880fa51fb141fc293345a6294bf506c2cf6a601846ba5a01219d13afee72181df6ddf6efa40ace9c765316efeaa506e04dd5f4553ec6f3e1d3b32ad6e84ab344a041c906ca964d2d9b317c57a49423823e1c58b11dfdde2eca741c2d5eb4313b9dcf5573be0007a9bad472df03de9f968ec53a4486d12c71f5147cbc0a76bba4b392477ae7d8e67b841beecbd098fe57b4186176572fe44e6ff980bb9c613388cd09ed24fc164ef1bb30c1f54aae7fb43cf0a174f95818dfff9cbb07c606b727752ce1a3ae43700d77848435e4868dd9476087b5f65fd2466a86c6dd73f7f4652cb4e3ed794e2caa65594696f01e45d0b8a00343bb095695ec4805b800f069c053d25406eae8a751dee6fada73e5666826424675cb9a4f6fcd3f75b4a877bf52f689e78248ee16f2b8f0de30563317030050fca245fca13e3ec4ac148a4afa1e2c3de089d34e6783debf3543fd9c15db491dd42b0f9ec48f4e9299b452924a6786519efa91e2043fe5104ab428b682ae1bc64b082bc8a112fcd4bb2824f10b945c1f99a258c2d09d3cc7a38a3cbe849aaa99435830f15ca52fe719145e1fac545dee2c7b8f5ab107a15d84ee47722a243082dbcd4b734379346ecade46dd4526c4f0af04167473407a51c0bf5dd7385895df97370fbb17120b88276852d8c619d3bcfdab75d92ed1f2cbe5531eb85c20147cde3dbabde023a527d635ce458626919a6ce2d562e51f5aa4ecf4c8d59355bc9c45a888a9d805a88389fc2b9f7a58adc8ae71c7f3e1bf1c975d5fcba0dabc678e872babadf195deb9fa1bd61328f49a4d767855d12f085bb86d47436988dcc8502780549620467737d273ac4d978f85b13fd6bf746c2bab7e4d92cf879b30c9d9bc70ce91c73a53626545d12d5fed95910216f75931bc04d13f71628c11d0e00fbaa223aa4ac01f6e57a89eafa7f7f8fa8c331af12c6041fafa9528f523a237522a51f0fe8965295fe6370476aa69da2485100d645635309bb65408393d1141bcd3a0918adcdf3109a7107525f954c69cac1f78a59aa531ccbdfa89bdc689a57f399979cf789d6996308f17a179f2e941e1b604abd072677a62c70346a2654e003d7afb37c57bcb0919b7c3f6a82bddf681e183b237613bd9a4e50502f99d8cf547b9a510de27e36cc955d6e143839c7545228ebcd98bda79eb8f9dd8365ee1b88d3fa7bab7f4a23fd6cfc763c5dc02168771c14650b403c2f58974a7866106e5c29b10a5e72368e52743d20960a1e96c63a0491fe78c0511cf6f933ada0a0a1c174f91ba30e498f3a8689b93b02c424aaf19dff168c0770250afe3ad9842bb4202e8b8e08302d7eb62fd12f9b0825a1615806758dfa19a0904418f08cdb3429bf627217b9ddd9001a0d07f9d13a16cf39bfd65659cd589c07907860be9f79d43b00f6e95703d30084f39d9d4cd9a8db32e2982cac28b84991f6ceadf54f173882749209dd6643ffb06dc9837a55d3a87556118d0295de417a9ca5293765bb66da409ddfd81e3caf31266a6ca5fc5c6d65ebfc94fcc0482a4df91799580507a2f56f0e50c761531fca76e51b6f8426a0f1a340e8578eb31c49018aae677052a11c95f9bfb0fbd13d81a3e989b0e6f4da3b9f7c7bb2e738bcab9c688c8b99eec2b8d211c887352629b269f365f86ba9fd4cb85033e2838c4f21b88d53afea84f8d7d62d34e43b404789397e7104daeea4b3ea32c1b87da104f37566e61b3ba73c5a9f217d6b8f7c0aee59dacd1a02ccd979e963b205ac46a9026bdd9c1204953dcfffb2d0ed463340382ebc0059d274b251d37397c017bd7cb59a95f005a8c1f4ce4c0df413c78c8607a0499b1e9f6ad864f425032ee3dbf783feec03411884728cfbcca0b1bc936ba325d3d589a43e827a3e114cb8cc1f682cf8ec94b91d1aef5f93efb42126e1f001693f0d416cfce3a06e6c549915ebe4355317f3bbee518b67d608cdaad1ec69ef034b1d5c6e9222097ab8ed7d04de03bca89ccf809e9d11ceb9e2207840c6753042c6a4954b45a858fd3b58950b6f92926cdebcd5ffe2749d5814a813d12af3c49793b1312e3a4cbb2ed139f0acfe5a37f3a2cdf2ed34ebe518bc44ecf5fb69a8fe2ea3d6e8cf8c101c48a10f03941adf309c949fc6d88b6464487302ebf76231784bad06244e4a47215b96dec66984ef66b9a304015d16b424420f058851fd7ac5a5123168e11b1d4d466a2b53b4a723603ad1b2ff8f7672d35122781e42a28c01bef4f2409e7a991c4b1d83511ecfa0661952da24fa1f9fafb5335778d213a46712a0226834c12d564b6e48e01b0e47d98a22caf37f1e82c38ac708e71897dc0737809af86d689bcf6b18e32c443859cd684a9254164742f6d4bfd040c137c62859f53e71226ac08ae9c307191c4dd6eaf42d904c0a536c0528dd913b27247e7c93ad9e06f4007b10f3b7900c519a3befa490e4d903bbbfd9e4c8edff03f31f2d269a79f7accac028c7c1d7c4e19815bfeb10a4462f70f7ac0f47f0860ec2a1967f4129548dc93031175d33ecaa84b9bd2a6fcd655a6da8bc22299eb25ce8020d743c4a44f2bbb27379e778301ad63595b944c39575d85eaff06456aca1049daad288d8d2b6a2877ebaeead91dd219433bce28a188682456872cef46bd04059f40a5818a220a946277e5716b30f9d49fafbf2ea6a645ec7177da5249c755b09aa02eef66b7b7b439cc0aa1f52396efbf9648c2234306f3b2e055a49474a1a80df4b6cf82843affb0c299d7994a0b52bb37a4973be2462e383ab9f72f638f2be5b03bd9ccb359e2e96f8519ee8435745874aa255b5bcec18337749a753de96aaf287685070f0b37edf37516f2cbb9a0124d7e61637cf9d9324ad36ad7462bd0016612225577fca44fad8b9668a3413ccfd81a91203e0a1e357b1bc1f582d8d9dded947c5acbf423280b311437d5a81524a3eda0a2d2dea0e3c9f478720bbda98156a082880b1e59401290b909fa232becbb82405a365709e59ccc4e11fe20cd5e3012ca0fdee5f390e48fa79343f08e4e2152d15864a619423c174e3bb52fa93fd22584331e7ee425abc7e917f5359ccb71a870f0c055e983d6b6db0070fa95710633c86203275d5b0f0a80da9b19b591b3a689d6720c28897464b79e6dea8fe644430440b1ffb9d614f86c5ddb2d28ccea7f38bf7d525b379509dca4d5da1a32b111d6c58960b07868851fdbeb1732d7ab034472ed9b865e038710152ca324da7fa80238a1e0d8e3723b3cb355739ac52f97e17db772aa2b0ca837ba2485f28d31e5515c88b70932c53495463f7a714d17d3f4b1b6226961779a43e8695da790a21c34e0ff076d1cc965680492dab0ca822b01d842bf0290011bb9f9e2978f2718c7c7e538b49233e154bcca00582882a45def5a17ad544d2d1c000271a6bc5881e530165a815ff380e2ccb124c0c0f6cd059ce65fba439afba7bb5443f9c1d628425f176f51d8d26f844f63e66131d2383e75bb546ea36f07c6537a9c3299aabedc2b85f13794556275fd80238c8e3954ba1b0073c29ce3b32750fa8e0642c94085141d72aedd2a5ee282c7bf349089cc51377fdfbd13ef6f9e0c68273ac0ef78e51880d94bfdfd4e42f96c0478958ff7cb368337a17fd1cb9d5fa0576a0b262fd7cd9b94a78080cd4cc8171dd443a7dfc421c94da6a2bdfc9be1f99df8da504dc695492bea0243a4ab46f2f6fa81254a07c3aef88f93a269e7da616e02626e015734cdbd5d9c6e2d25b46ce0aea69b9d9d9cd8ce06b4783481291ce7861f9f6b82964461fbf17f75e80a2731fbf5d308f4cab7ea7352c93407326446c6809edaadad1e1f668d3b56a856b3825c4988707c6cde4c1c9424fc8a4c49a268ef1c8a7d85cfede5a4685aa5f02d9104f5556dd032db9bdcfca8c335f448d52917609c81deec20f987c830091889ce726ad91da6d068562aebd4b352967610e3aa1b22fc6279f67be9715fae2386df5213e6d71c821e5072023e2f012f0f73a89814e32d919b294d34eaadbe82e884c4b9471eb0f457ce60001eac66e2bc35143bc383389fbe6ab31f155c364ecc37e8aea58be07c41e8d5d9a1669c838c04fe2ab59f5cd06edc59db396284a9f1b6efe0ce92fa8ab9f471d87996ee7454a3d09dee611f256c38a47e23c2820d09606c152a3c86bc39cff51101191c75bca4aded445db31d7146d82c7ca3d44d2273c91a40f618dc3b25334b0235cf052fa49b3372d8d4b186d01d63aff91ddba6c73320d52e9226b6201501f4a054b0bf7ffe600ac2e2b67857308c5485df182baf5df0b91b6fa33bfa8d5c3cfc385dbf3578a54886d3817f49df427d62b507e112df61c1463a45366bf60e2dd148a1bfc0569877014387d6198269b161225a79b84c64ad000d3ee27100c27007124262a4fd793b0d77d0c897ee0cc7c361009afc6eb27df24a816efcc8bb6457b12bdbd9ab22419b29549b77cec56bdad76a56d4dcef22a412dc095d8edea714925b0a45381f5236863b730ed5d8376484513b7aad58ad3554607e8650f20a34aae535b9df6045025c76e2e7f7e275c426320a86d1b4fdff6130e113652b6202a7a512d34a7a9eb8e9317111b68b581df8c3a3fa5325beb48e615984403664ce65bd264cec2515467d746649fd0aadfd3741dd5bd4cfc26d6b3e73ca9f54202d699f8d479e49ae7dfc346c481654d471e46c2db3c166306b6e69fd28dd9f8b1371d3da86ad390d522f0f30f414f77afabb9ff1d780da6a179709f2ce187a75b3022539283d97b7914f9b1d96f65d30f83f5cfb4400a47d630d6e21836ba1238d0eb1c22f529180635459f8d85bd9cfe541b852ac2b0370841b7d93288e9c5f12d0dc3cd005bfd4b048bc540da718f1720b253620e6d3e1d1393858444bf163189137ccb1a533f142a52f14de465fe4cbc73ca22cf6c374d02891a0619d0f6a93219f05d4cdd4814c1380b1aaa39683aff7417908df835bdb6e26c32a0da8db97276b911b7eee6248b47bf0a3134f9c77f36efe323f95769c697c2dd6809da4fe287b9bd33ad5dc1acaadd2faea2dea935f4c48446ef4e8dc538ed1ed63b7351c30cfe8864b0262a20ddaeb7acd4e05564f0879c80cd294dced6203bf0d9a36023cee112e26f9ec1a94d75bc78837d7435c68d02dfa826d666fa40ac5dd5ba4159574cd40cd39e9c81bd135b0844f9e7a1cc33bb9cd669ad5a68180fa9448bfb1a9044addced16dbb401ab0bc60ad75a6ce294d345174e817f5656974756d62a7712cca12c34b245095898e4e20b5516b0a6309ca68a3d9fcb81e733098e6d73c44d4e933c4b02b2b6fdee0f3896f2966bda013028c6b7e945c3ea5d1e6213567b5d33cd7536670feb403c5e65c6435f19abb2b02a43f192d5b33de168b35b50e8c63f43b3f248f742f6844ef832cfd3c4a1b6a33dacae7fe4922c988884dd28d18619feb15c5da6bd53e3f70a6b26a8bfd824ec414ff3b0b85cc0d76f5ad35cdeb324e1f1aa3e5a752d64ed548dca57a589f3b1546c2dfbb6cc89c184f25e89e7a15702c5df8077b0b04a1f60cb541e2e8fa662eff432b91902bda9adb25037d10cbe9bbb2a49b765ddc345f0672e067df3efbbf6653d28270defe56b77bb31fac9037214e7a6bab932c8aab99297fac7fa07b4f03c623b284d151afed298eaab545dff39f596a0b7cc58eb5791a54b0b33f7b5dab48bba071b82d85620a238d04cea8d3e9e441e996b7ac34a40a72c72282d123016f261faa825ebfe3810a08445bafdcc366a86f1ec6174725940dfb4b1f6380dc6b7001c3de982758425141de1b5821ebca4e598200d5ab6e21eb3b146b72b2e250f9085546dc68530d374dc5043bccfd6c2b77f4d1ebdc418e7fd33367404e1215ce9eda7399333ca5ec3c7dc6aaeb35355db6425a31fdf5b45fd2fadad6a2de5f6ec002ef40a1fe1c310efa77885c1d1899cbc01d50d30d8483ed7a4b7955d2a98e8eef47a969a2aa85021102d0c9d76e25042368bcfcbc964314eb5de58389b1d25e293f30bd5b6836719b1b0684e9ca30a9cc0cb1829c31730c0f12e48c90d0ac6149d9237f229ffc45616bc8e41804b0bfcc288ba5d6eb4b9eb24e6dbc206e56f9634d0cb64fa31347104e544438417ffcc0ced594fb66124408129f4ce2ff3f85766cbba99e6f74a9640f4b8b75399f8a7c32c0f589d6c51ce90ed8be991371144c0851e764b885da530a0377413d8dfe6fe40f4ee0db3a3d721cba199f05b067dcf8b4ef1af50afb8501a8dc2587d0a82686aff89a3e87f11087a59826600e1358894b61052a60cf4403ea25c189dc2a0639b9c3f59c9d6c98656258743d4377c4a2ed9138bee466490cb9d7016a8d8ef7a7ffd716ec2ac2a5d3739d029e5147aa6dac42a13f115dad8b183bc4226725156c7d9c6b551d9dada643f3ceaa492b5d3b2b31e7ae8c50d4637d406761de2f996e06178adcc67ca0be6801932cc105b040fbe1afad09ea9e243718fb3861d2e1b30ae1a906ee4df4382291ad92a851a190df472ff581ded3b690fcf0b623e6d00f09bf2c92e1e7bc948bb9ea48fe1d3d8300a62c0abcb1973392a082a0e1e5010747dffbfb4b928977cd5c0e9a0aff39d5ed2c9395d0fe0f454327087952f093a1d6b3e8ffa04b76daf6970ea899f628aa0f3b6b5adcdce51fee85f4bd4314bd7c1b136d72b2202efd9f712ca759a8bef822bb5a5055e95ef525ea23c088bb6d730ac66fa2b0f6e4c190ef2b1b2aded211f7d7be3733583733a55ee55813138348ac97575228f33f7f8314cda637a6e219c4465c2a24794a0fb44c210a9a1d8e54b596d35796d37a3b05de5fffc97a2d97d58d921b1b8b7de6d4f9009d7ef76a9a4c6346c01d0f21861615cc665475edc93bb637496ffff2843507a2b3053a002f0237bc01c4f3f120a3ddf21e7a358471074a0c811f114155c8bc8673bc4a5311af8950ebd44635d7ec67edb3abf2b0d1d802b3cab750c4fc2d1b40ffa7024fb54a92e83a4f5a7aca117eb6654c0a8cc21a467fadceaf9402df14c92bfec1a6fe90c2e3d0bfed05629c6bbf831da694751dbf9989f8ea20971e4e109a9a95a912b630a32203ee4dc1511fd35e8b61deea58c96ecb3751e5760305db29d26ec3e2a8957db829059b414c527d07f71356a365bf27c7930e5f8819953a7601a745e22113d5755be00fe3e17af41ff5b27fed654c0229f72bd30bf76f8b9ea4b3020c31b2b8fb7f0741dd8b7402ff3c4043fbfe84547ea65dd055a10d27cc47b7b28578681a5457f4e78981b9ff481cea2d4f495c855055cce34c670409647ed4d96ab210a47d62f15cfe7b0b2cba16c964465c33b27ea7fd11a6479e90ac80a5db8cb451301b1cca19f7e3f5699eed68df7f1c1855650487445985817c711303e07894558cda0b768d4cdcdcc1e66a650ba621a2d6afde8d72cc1e69782e7a6ca6a6aaa6e4f273f0ba15009ecb7dde450ca22876abdfd0c044f8775b1b0da738c2329d1dc722db3ca0c9d835b7ff01b77fec406ca73e6eb3da6904e1ecbd9b527cfb8c44d664fc2a5508171c1950880937aed428c6c4f40390ab14f47003c746e91ca1b84c29de687910085f53f8e5690704f85d53d2f867fdbfdae47fa2f873408d228d2ab8500e13639f736b4ea6def1b30ef4836363a7cb482507853b56a079f18bef77f3ccc161b9c6ad6066d5ce8719b02b214677c6620b8e44fc6370f9b5531dcc6b4d6a54a07a4a44ca710f5a8f8614cb9a105dc26fb39aa3b07cba7d4afb4c266d4e92f2fc1fde859bd70268755e2d9799710a0948d7bc1ac45522befda0ef98f61b572abe750f1143b42debea4dc740cc0dd66f5c1d785b54f38ed85de1de274758d3a4b7b3e48974fd3b89f80d9daa4da719de8dcca4e5b4506e6727cb7257d3aeff8ee03010baab92f2637edc20787179bac456fba2f181776404dd02f96af1710a65b6ace1ca3c8cd2fdc9c043f929ac5167edd59ea6890f01bf2fd059e821b39b5c279b5fcb4d33d8bb1d33012bb89a51ce7f973c5aad2667607d35b82fba332fbbfff4246dfceb564725bcc14645b300abcdeb4f70fd2a0eb6633b29d61f613a58535da5796e85447b276358148878ac91054dd6e0f2ccda97c73d40f79aa70587506526c60b46ad7cf4a39bf822a489d7f4e7be9f609f158283b6f4caf43cdfdbb93af164c827e30653df5381e0a1517c60e1ba6f2c57f121aa02ea1419877058a517fd271a4d848a8265cd6508c14739906af8286464c78c141af09539ebe93d4a6732d35c8af5ef8f658573d559847ef35aa3ea836ff976993c05bfa0f53f19c72469c94dbce1155531b220d4a6b6cfb46891e68b17e1d5001c1ab7e3980db345cddaab42a11b65ba032f37ce67f4185f99f42f421bc74ae9ce7cecaee338215baaf3c252c210937c96dae756806abfd2cb10ed69aa86ae10a8210314da24b0cf49a3e25eb6b38ca8f7f268b22b264825c470c03ca022dabd9ff72caa5d2e74127d98afa285a6cfc03ac915ad156a3d8acca3010b4d0696a62a7168f47ec3d674d20f6f9112862bdaeb1b67c513a86c9c81f3de686ae70c4e07aebeefe96df173abbc5ff1365eae546e8f6f002afdec3acf368ccbb38157134b9208df619c6fae7e42b307ebd26d136f51247898bcabc2340db0757e3549c9f26ab58ad740d98500eed4ee2da46918b1b1f35b477c5f07e22ecaacdf496489079295dbec0aec31177d6e7eb4661591a812228b064556490c7741ba7ee187498d09c84d4cfca8a2b9d8dfa206ceffe30e45ba6adc583fafd8f3460dcb961c37078eb1404d6bd6bd831f13808b529395b6b0f831afdfff998cd7f1490877956456db6592b80e0c7307f7b455425c32988aa74dfad6581b2be7e74537392d28edf38e6699a129bf5f53f7cd1e9d49a6125eace074ebf22d46b50d01d96f72a8b11fd868ad122446a0189de9bf8c119f2cff6ae5f411747796e70b1ed87f813c41cf48a40c98a29814d43e6ca45a4f0c73407b18dd2e3e59e17d8fd1b6b8fca9f381ebb3135d5396c72a039e63316783fadc4f587e09a9b4054c32a7f3c424e537ae166c45231fc10dcda7b15b0762c366f94779d0952df29ab88e9b5e10b17de53f1fa00afde3db76935ca970830b2733f2f0a39bb1395113335d92edda5f8a7085a6c3754c955c2a8a67a03441529e869aebcb08735bf73a2aded0675455cb02ce25528f9a42860f0fd6264aa1ee91578786d5546b76717b27a8a1cf3e5c30ceffd60c47103696a4a8414d6f207304f30f5aa7b46f809e96cb787b079e422246edf71e8435aa181841d94e5398a93e5452bd663c97dd96ba0d7c9e4b663dca3a224f6c9573e17399e59de78ac9c0aea5b6817e932c396656bcc9cd15854004a6a4e1809f3fb7d4b163320d064acdc22303b2dbe52c0c7ce6a599e7a5e4860e9fa6e134685518d408b8944f5af20c047b5a8c0ac59f7261dd1aeb31d18e2b9483a3bda17a2431a7f83b3ad0d7b40713fe291fe9cbd7e06604e4798240415fed3c10a09daf9bb3b6cc9772c67c29f4d42ad44d3e242b8f412312e7d83efdf5777ffe0e38c9f45fb282e4f36b3b6db5e5ab5935d2421001d991eb408153e383c6dde13ffbe39e4792fd170b42daf1514a7897bcd9f1b8e59bdc51094189482e1c39d77753a5b87d6bb6f6a95c5cd63fc59aa7cfc7b209190c543db02ec82e0e898ee53ae6317a78f698744f13a4bf06388c0709cfabde0581c6d1653cd71fc955acb52d7e12639b195f0244c84d6a2ee4d2edde5c430d916d6348cc177a9c17baa6c47d1dbb5cef176fe67157725203a1cc41db8969c05b15859659f5bbbd34f9bbb9b3935d525e2ae863cc1a0895c1b0af5a487837b91d6bedd5bd3600f4d97be40c1d70d9670d78d9b624195b767e3b3ff3ec8738091c2c401d2cefd64de911c812226e9c80dcdea3a52182f0f30ef74c6df78dfadd41c93dc4da16aa0df0fe8abdd94ebdd81b25dd30d149a4d9fcb7867fc6846ccd5939ba8f3ee86cd0646f8c1f691e62d00891b220e98623ada34165d0a6b73c6c34394766954beb3080d0de4c4e224c6ec83b960053b498e744407772ede00a3f0eaeab8c2850c107587ce997de3ba16a49ccd2c39be7b53c6ab622c4af1a03ccfc0a5a475bb32d3022a1ee02b9b2d8ae7607a4a8fe89467183b9f2b4baab3ed1870971e2f0c5fffd78334fcb1cd2a227a3924cbaf7febf22ce9a7a57a542eecc4233fc401ca4bd0ad0b22002750802c20b672e468150284a99cfa398657efe2d237078f37bd449c0347a683896e537baf135b73a76961f8fc42fdf906e9e5da13609795f33f3b5bf74090020274bba80cc7d2fa27524ced09defc40c43bfd572f704f30d229da87fd43e961cea190907d3eaf1e28dabee6747ae56ec3ca5a157bd2786af12279dd8539ebafa09490a6142bbd2e421df23106c0d9d20df3ba5844a6af9ce7b3982955c053e3b74dcd78180af3ef92cd1bcf76993b2be9696da72c9ef87224100c196740bd6eb77194cd59f922357c83699e4eaa5b33a72570af794ceb03078610c363b4cbb348e0a886c7cafe23ad545350cef515fe7a35ec07f9d55e9ffd7d4d4c4eeccb2a53fd40d68e58ab7d86c13af48b8a260167ccbc724a622ff1c6b9de23720b5174ecb97e6166dc694e024983a0d7a421390692e36d32031fe0e190851f1f4bc28a2126818e104d38e7a5942c26087ab8e9fed61ea9da6f9fb043fc925f6912f19d31e32dbbfc2fc82d8c680bed507428d590f6add818fe7f7473114853a0319ea7f5d27831fc7ad8facd1ea8e3d8444397e284f4566236ff5206810cb08a5ac1989a4beef489480fb55de54ee9f918a8b9601401f248c7af4d19648fecf079f6724d36119cf1a3272a9c6106dac85bc7e5f8ba1188805a8b82fbebb317fbacfe272c0c73a93b18261608d62b9747fa32c3a88544ee4b5ce520764b1b69e95e2fe611aba8d729829d0c342720c76fda345fac97fbfc832741f588b668769b4207b75a5c0ec77bb1f083361ebb6a2ed39884a040de29523cba2ab9dc12241dda169e31581403f3ebd1f57f90e14365993d30d072c4e534064cd6d04ac1a895534653ef62269171ff98938ead8b298ded53bfbe019f2e164bf3f862f60ecabb7f06f789798925a95d7b10d7042d806ef2e23779e0ff9fc26db008dd7f77fcba1977cfc1f74c57ca6d8576deccf99f2b6495c08407ddf0073708693f2303595efa8684df416a3f7a40f8f711115c739cc3de63aac7127209888ae4dc3aa9e46faf8f3b81c7821e10ffe88d4376a76e6a661ef0610a9f6540c88726b33605c07636a57d3961a60516f1f355092520713bdaf8bff5f72dd6a9b3f38f8b9bf0092356f82ffc12ec38482833fc2f76ec1458d050645de09546c83ff6bfb2c53d67c95274975812835490412e749b952db051566a43134311373fe2538c3828ef1bec9fcff1b9f0fd36a6507d6891fdfb7e76503aed54a5f7509556f3f53555a522fe8a262487b6fe57def3a4f1a88010becc9504fc0f4d7312c63ad2adeef882ca75216bc85a12e191a144cf334651901a7a242029ec80bdcd6fbd22b87b7a7648a78fa2754583016836dd386d6dd2cd48966a8505b75af5ae2f2419936a84a50652368199dce0f72d287bbb096162568438b02c20d1892d9f796ad559dde11ccaa926fef6dc7dfcf9ee1345c0a392fb43677afe729f181c0bed3086c690dbca340adb402cd50aa339fb977dbcaccc01e3280efc7993fc3d7fa01f0a6aae6ce3b45027b960fc51b0df3170b022f9a41c31658591339f43a581cc94715c8a6a059bd48a75a196d56b250f34e033a37c0a4ca75ce4e0701498a602601325dab9ff6510ada3c5043b7ea3ab4bf2aff6ede89e8ce5e05b38d79ee7dbd1dce0f9df19239f3083137822b375ad6d274ad2e7c688d6e8c6ff1a4175022ecc7ab75887691e528ade994634f1eaf1269fa6706ed46b9837a8a5f47fc86999331ecf6f64b88e7ea52cae673ee4f591b4359c572d966d48841561e07cf12856e8217ee6667e004014fac39e1db88e68068f80a849cb99391267c44750d25c30a99372b73d0a7edb781ec0022cc9703fa361d125b99956c982b5e98bc32e84ebc7602ad01a780043e16eb0d87db2353ee282011476f6f342c0ee7bb8fda2c41bad2c60a59ac411ef5d3b02448dc233679fc9d7a5f33f0a56ab24c0e17f942be5b9f53c9bc3f846bc072a798b6e976abb0d0da6bb66c6e2103478f056f0bcc78389a82d65ff0c2c347806618b585b2cd47d97d356ece624068be7bdc95ed6fdb683edf0ec052920f355e1bbc3381818ea22d563531260dc8669a60247d696bbb47d10072b68525a85b70013f7dd7d8f01cf7a9b55b3ab692c5229e577d897a6751d2b9376075c33155cd6e9455d314a44f3e071fb4ee1ee5b77b6c135b72715fb99a0b896616066541a3ba5d1491a9cb514df3c1654442b3aaad80a42059ab5f56773b972fd7e13dfc22385e735936a43bcb27f1189d3a06ea612f867c46063d233b3077a554a1d20c0b7b697c69619b7fe504f4193dc2c141babf92c8d676db15d1a7cc8381e0ad3ce983adc4d75be10f29b746257b25d97f631cce03d37841afbc63214f216b5eca8aabf8adee584bb49bb507b83deca41ed797cc008fa6ec26ab89a931d62f2eea09869c0808e525514baf06917753494faaab216affb5e8b4f00d0d4f2e09e9dfcb3cb72ed062ac1cf496ec2820ffc73450bfbccc733565a14ffaaad5636dcbeae8774afe7d2226da7e21531d2a9ef92251dfbd0e0839749e1fcf124c232224c785a2acd6ede046b7d163cb820ddced0a148daa391dac9ff289558b5f1194c64a3376380c643f42e9720adc0cac346d749d756837134e74b3632999b75aedace41370df2ca39209364f4f6c28e5295cf94787aa564da57fa6563b2c61ce1089a7206d08dbca869e881f6a71a75a74888540aed4cda675bb72296478e5a330f64233bb10a5a30a7541c481893dc3cc1e8f9fefe1f8f5f4e3ff9e3a7bf9cd80cf785d1b653150e7c428b86a24eda7e7dcb29fea8b08659bd3f87f7f37924f56b1469216694411567ec40c903bbf857049f2a91049d36809bf19605597ae2b45c9beac6c1284c77e5309ef38cfee3440e8673bb45bd41545028d240e7d41f24fb433e0afe903150e42e741f6eb31f2a9e3bbaae34e96df2831e5a5cdcfaeda53b83b6a945b2722ab2553d45efdecdaeafe4cf377db7c3715415c071d5d2f48a7118b3991f4b450372ec9ef7931e5eef989cb3851f4dd16b571c4aaeb2155fad11b8971bfea11d8f138a4ec9403b78bcb2077dc51a33e73b5faad5da47b8acf447e99fc4188fea268b0c8ebb7dad505da4568e6571d0abe5f3706c69a6bace693955631d4e79ecf147a3dcffe166e899dc3fe6f13c7cb6f47d87462d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
