<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d3b26919f338ff97bd35ee1d7ec7eeeb1101e3ce905228215dd7d2d5793567b9fdde534af7dd48c784cd39911ab37e3993ab22dd7e30498b21340b00e6326cbc62f6d88a5989f473394509a3790bcf72a60c4a8cc5795d1732735b667400e14bfbbc5fa774b855e64c47900dfc66c32fc288d9fb1e38a32af7cca73a59af4258f6cae314de12a5a65fdba5180f275d2a68813bd93ee4b2f15e2fb68db510ec2b7a0ffb39b4fc8c8813d48fc6fe2fd1b79bcbf025f34e5dd436426a973badaf1d0eade17f4fa407a0132921bac17eb7c0dc7acf930b46e9c5ab911d8c2f515189c0e9cdcc73b7155c3eca3cf92f55388a7fa826ae0f0a086968a0c850bf5dedaafe4a5fe0cdc93c6d4cd4a9c8bb074df0ce469a918d7c669decf6898e9a11f124dadc7f7648bf555cdd5b2f7c097881e59de093c1c963d57bdbc6d3faafc533b3d0659600d4bfb15915442f6b0c176b87d40e807c04a9068790b4c9b188e79f0959f42a320f676371a15b5c467e43aaebef29b95d3f66e3c700d219eec86c818b8d0d576373ccf9531c6c098e8749796813e6eaf54f6e524db2a0d13c3344e25970272a63ebb894e097b7921c0edfa5aab7f55302e492cb9a94b8fc187f52f053d274064ffe290885fb9221c7e0e8c2ea2bddac197c891a8a3c1acb93f718260bb4bf5761a6d5294e71ecd47aa565f30a9158db80e3fea412753caefa996693b46585040f87a91f81afcb51af1fdd440c0fd5c64a4131ac5be17d6b0847cabcf2aed1cd8f55a53b90189cc79971b021059f00227da9c1a0d7780286b361e4d910c6a0b642faf4f7b2fac1b895fbe93e5bbf94cc8309516fe54c62cec21ebecc459689625ee726e3654212182450ceea688de7cb8d39257f750e2083109458cd87a62563c0f911df99ecbe636dcf889ff37a0205a68cc62e80cc320d9887a67d8c2e1c9a83c7fccc512bda6c1a952c5f984185bac61b7cae06f497d7f2c15a5adb50b517d1294be62eb3fb035a61b4975ab549f4a65b01550595eabbdecdc78da8ad30fda9969caf255041f14319f42848b1da682ad97d69ebb47a0a36b84b3fa21425322c09c54c880d2362a51322d4b86dbf4f6082b474e1dfee092554e5f59f29bfb0858a75ea82fd76a1fcd716d751dc349c7f2dea6d52346b475750ffbf64dd02f0eb4115a1a25448c5225c3ae5ffbda69a59e8e58b84bdb30d5c69cbff559ccb6526954da9af16e19413ad07f0615eacbe0f15a21278672fd54275d78808ca60d57b3025ea98b814c3097608e0644550019be12889d7d45454ed6bc1de35d5e217d69e95397e6f80ea10ac17fe161bd72c3ec4912381b1ff706f904825b4e8075939a2170ec5b6f6d9b8a0659db328614ede75ac260ac9bc2ce3ff8b5b1c38a6f77c72525caecc46d93d5e08fe95b4b65035951d29fa22c99bc49d6e2dc32d5627a5f0bed3ef0d62068b99c74a7288a3b8dd25fe55ef8a602185015e34f807a411009c385c504366d2e6c70722f68a686f97e8da3d369ebbcea9c0d01c09760bc08a79e61a8908a416403b07442e779e2b89133dab969529f8067a27a629a6ff41761a339c5d26bb08264179cee842f0abaf6ad8bae02fb23f7070b0c274d94faf2d97be469421f3d671a2fc6a2b016b5e1cba485c59387cc8bb092cddbfa1f2583a96f15c29fe0c16096675ce255807d3deaa93d2f3d12587760b8e3aa02f4936bf5bf5a74740477c55f2b002247f57617f1966695495c74f588c40dbde4c71ab940f36c973ef8571c5a6400191b4da04a2fcb2e019ab1de7fbc71417e54d4b832c98234dc7df1f097312c99b538b044f3db68287288e70efed0108e51fb17f52364ca14cc808e244998d3c2d507f948f6515fefb9eb5497db54a47e4af40a78eae142cef3da9a931a0dce30176b450b9aaaffcaf24dd4d9fa456c49acf44a338725ea7f8890e5842c1a22aca456538607cf618b5f8638292f5da55e38175259679294cd804def149629384ef23e696914d8a80c7750ba08801057ceda3f79ddc1ecf02273cfd323937a1090bd5fb76ff31a0f4d802a651e12fbc80029cb4088db6a957c666fad99f1493d0939a4f7a4916e2fddf2c55fcab936423df28e8021dcd898346fce875fb5fd7399eacf2bc26cb91745b889d66fb44e576bdf4a1e05031559eca2723257d20169476bfcefe5de2e3bf357fd8ff81b40dc5a38145bf5177e70b7cbab4d1d7961a6cca1d0a4c8dd157c65299b27864bcfa3e3dd1dc398d784d04fffbe6cacd2fbce4f602b28bd65270fc0c75fa4ba27736ef86defc62bdd4a3bea552e1a18e529e5fea0707f1bb14e724ca7ce6014af5335af277cb496cd4b376d8930bb97f0abbaedea44622edead899fa12b446a0bd9cd4219bb1e2857e42d976adb45e858795977379056769dedb597c740f98aaa58fc88816fd07f709dfe88bc3c0f67b57743aaab5f8fe8c21f4b5c07b1d0a7ddf91d36da5f1b98af4a347ee313f5aab0bd7d6a84f268b27d71e15c59fd32cd9ffc2daa82456cba1104ee205e340922b49a9d8ad53802607d03a1ccc52fc97f8ba337e878a1067fc1d759b8f063d8928dfb13040248c85b9d773db7d60d3097868dbbf50bdfcff82724bada05d719ff064ef4d269ee81a7bd3e5f2439a057968b71232cc8c4c9bec5d0793494d3d482e0c8d649b242ffd31d072ee76462f49308ceef4cc9bd3b5507442e8cc14f886f4d06bbd3f7916e14b018a57a4e828c05bdadabfae3faed99fa3dd2b8f98c90e930229d7b99a51992e7ecfbfee86a5657fe49df21f83361d1ef75b655d708cad112ab0e45a82c6528a2f9aad7218748ee9078f72366da3cb40c1821626cf7c6e18850adc3bee192c06f590841b8975bcbb7f6227f7f2f1c4d5a3c6066778043bffec3c0da69710139dcde97d9dbfe6d532e85f1730ddc1d84898176d9d2f6668c65909ee79a31047bf0cca079d7f648ffe9197a30df6eb90307b0bd898608b31434cd9fbc126dbe1d79ef093596757ce4cc0923bf82eab524446651a36a90a98290677647ef380fa56726f2916b1ecde36d885c99ce8f49f97a7b81d6ee23b6d6e062b4ae8ff490150e39cf6bb1e520f4e9ad3767f28985285290495b8fb5d6d108da44c5795d84fd1bcbb8e539dc802c8f9ff750474c8ebfa1ebaa3bf02e431c46a7d93d3d78ff8a8154d1267c11a52e7864dc8cbb690921cf757cd6bcb43b931d20fe300ca32842fcb5be3290f7da0b2f4332be8bc0bad78fb74f8927bfe6bf3ad2e3ad28dd7c80c8e6091717467fb0fdefdf8e568cf345f8a8325ae9f5c933266330a97d55bca7071359730f7c7847cab2b2a9a58231291c713f3a28e99e8d5f47ed44c9b9c5bd22c87d8577f0a554d5a7c887b1adc35d56a99c20acb4053c1638368fa05fb56968bff68b4f528bb136bcde25e8780ed1fab4abd9cc9798ec56eb240095b83ca55a8da6c195a9779e155f5740db2de7d908b664d5a5dd54f6b198c5a32970a6c10b9fa05163100cc16c0d87c5c9077b88f2a7f7a402b3e3f850859948a0b64f70addffdcc2b5066d63a9aa1123b6b73c30b9c8a72c45a7ac77ec2217a48d003fc72e3af019760eb37f2c40d7101a2b27903f330f0640813a26bb9d0b462cb837385e575cc84ed1e4cdf3089688371b39c92b56ffe44c9f6e7b21bd434596d8b02da6ac7d2a0cd6edf2253e0a26c305beed902c498757127abac1b2559863bace0ceda3d42dbb250ccff178caae8575979dbd743db58184a4a33f868253eca1d4828774b629fe6ceef8f4a3ba5055ef3d029ad113fc6ee8fa6f868218b429644062b367308ffee28435df83c8aec580c7acb3b6663dc4c07fb6dec50277cbc785445e6eb753c238c029488e7f50714a60bb51cce10af019d75d17148a66aecd9d32bdcaed2a5e1e610829dfbadf724b9d848e00dccaa037ec76b8ff4b27a2fc3fc154236b712decab9f7292d1065e9ec8eb5505d60f9adfdd45a3703f05a836e5cd1a3d60498570189f84223187f21180f553e108173d8742868c6638cdb9c1c3327c809c76a8fdb2b5c60863e7b99c216ec5ecffb4a1ae77d57be2a5a6aea35718b2e9eeff71ea3aadc5fac10f6fdfc8a2a599dda8545a4e261b384f6e682d0e15331486895dd053799ccb677904e95482b8b550356e3c09e2c0c27963f5446a88cde0cf34e947bc3246271284f1d4f1ff48a61deb271425036b88cfd42405f4fdd0454185f6848c321a1b19690a7cba983fc17699083aa05b5f1a23876fbc08180e2fa5a172679dd243db87ce4e0a9e36c3171cd4d743b6c1b9ff6cdc64dbfbe110315ea414aaeb960b071f0d9d8d1f61eb3b7a9c715a46e845db87e14f205d94b619f033588fd5838b104f984efc59cea60d8a703c350b0f26944a5fe735df2caf15ec08ed9a5c65d495971c845605a3694d3222ee30c1a408039a82e756bec6702789f28e81ba02ee3a7747dca69d6ea51da14c27996b157bafced4f63db03e56c3321c9d163d7dc5d55d431f5af471a388f200f17bb99b10ec19e6aaf018a63f6d007e23231cb1629cb83167729f745b95df9a9f6f8abbda3b4a06986dd76a61b15f88be1822a1dd1a8661bfc0628ebdb05abf3f19ff9abf299d9092f72d51ef21c5897a669bd5198ff222d9ee69f16151aa475efcde23f5750109f6d130d3382b28141e28575a0f5a121fe8547fc9be696c265ca2bc286dd22e46b1bf09c8fd8e1af8fa6b466ad28125fc51e3c99bebd875abaabd755dffb0c24c31ab3008a68953d4c8e6b66db3bc523f00749da985806e9168cf76e8fd1a028d7165e5031fb995e3333950374c4efa088d271b9d53c0c84d3746bdcf5297865c0e214584a388aff5e47d08f5c026c7a52fed738d3cf650356f3dc10ac71ea2933a387ce769f499e59e966a51685547f3299611b103e2c0d013d30c856bff642c4105da8fda0c93f1a7ee93c251622153498f9f190191eaff38993b2e8b88cf70f5cb3b4b2a58d428a0ff323dccf43ac718ddcfdb1a48c2b796ac0a11f08ce211bca7130c0217012c851556a69d6adeb23bf22b6174120c9b1ccacbec0031ea384a69b0cd64e1a665fcaf1975adacfced16085417b6f3d43f39c378310a53ddd52aed2c731369bdff0465188d461cabd7a52d1a1533d4ed0ad7b50496da6228f40be0b6c4307671518eb44280c35b2841995aeef9587d2f954c094feeee0bb0cbb434e7df11596e6b0216ef5bd40f825c2b9c8c09823446fa8c52efaa0a375f1d51d2c4864c9b867ba46f4872d65da02f1b6a2a28c77bd60c5d325afb037dc1a04f3194c173f780e0e4469bb2432d613af3ef9b707313f7a48580a9fb06f822d51803c25b4fecd469bc9f86a13f201f015d811be32b8534430c37c2234b0d6a64818881ed6181e2d9e0dcf7f7d4d4912aa65e6029d2a2b72b7545e5874ea1bad940aef0f850f7a45dd82518bbbf15746065ba81011a9438e10f0274d0e24928e477803d896c2351bf52b15455095def8d74253a9f3732ce1bf17f07e4eff6dbcd3e80920fd9dac6f92580939e09c5e60358527da9607f8b11da5bea7deb3c4b55e744171ba1996adddf72291cdf8d9fcb72858758da7b317f1a04679061845aefc5e04c5abbd854816ca0b3b294a6c11121c80150c348958ee5ed702e790eed5b9adb15b3382d7b9e5b5d2d4e5caf4be8fb71ef269093538e91c0bdb0ad3366b33eff656d8f0012b8b4fefaa8957f1bd8d4624482312bb2889aff8aaa9a62f5642bf016819737558fe718c96a3c67e4c37d303c86ad7f539fd3c9ffaceff4bff290e7e89819bc00007d70d4a6929e0372626dbd8b4c5aba93a416047ff798261f1d3c7a5b6c5cc68984019decfc3291acd827ef00e10adeff1fdd1940cb4cc5374bcaa720f5bb1b008e05aa7097368c0559a0d6c188de81077658868273c1266d2f5d0d0292024d3286f08f145f7b8c1b1d3885cfbb1454aff0f0b197ee38fb15e0190393bde10f8e36485a0aa7a7fc52987d6664823399e2dbb5035167968fcdf1c03a6fe5b29cf56bdd7ca2d0980ffbb22d30c120cf87f44a7619849d48fb72b2a28e756d7902799e33f2ba4ff0fcfc11d5ae2b4ce7c15db561f79bbe49cc50a6f2161958b806d33a6c907a5e5358404d9193c643ac5d7c5b1a370ea2bed372e25eb0b6e44290fe751d3541d9520984128c6b70d3df7539b848cbedcd3ac5a80f396dbe29b91b9f83cc1b4908a4432531950c9cf1b5e21ee969485ecb2d6ef5be70dfc1f9eacca5c030afebe86ec7c078766969b7d23a172e854df6d9fc14d098d8b480e025fc371da38bd4ae120fdd92788f4267e7511fcabb5999bbeb4f4cfd0068629f76cf3cd13886f632a6a838e49b43e36da5be64c487d0bc1700b5a350a4012ff8e008e0e4d4ec87884c455e33fd393aab9cedeb41a3f0f51aead3a03d7f0e243dc87df3ab93f2aef77cfcaad80ba63c74ad0862c2caddbd07e25603a373f7947e747a3c6e8c508b490750d662c097cece9330208449d71b5d29390d56ced27d7958cf15f4a64550df5155a488357bcede66f56a16a63e270be2a7318eb0347d04a9dfeb510ac4e20920f6f914afbfba5457577319b9dcc251f88fadf913354d598144c58db6d7f07d2b7f9e8758958663e185505fac6e9bb6cf7f92dc1797a3ed684618b348fb66a4bf1e827035b57f8c16644056e89f7124666c418afd9a2b9b9b28883606c2f32f768b0b26c0260a7eb152f6ccf21bbbda2e489ac0e7628b3890512e394060d2d73485d91567ab7ef4d446e0d1d73e7759ff8ef408ad144744031873b2895132324deaf7f0f0d85c3419e5f39cf6bc28596b4590b5b31a7bada13f2d361544a4794744cb061c6af7eff4b5521f09acf735182add3da6f97fd23f6ee4e84457e12f6fe7d0501391750bcdaca91e03f398f7f7c9047e9b349dfc1f3f5217c9250010dfb9e692c70483f81c2c6d502aa7c32784b4f9972ae0ad8200adc1fcbd7f616a4bc51f524090d506d82e315baa2ce2dbd787655523bfc7e54b0d93b9a7389490167103e79dbadb657f20b2bc930a026e2dee12dc436dfa7cf55dac24410dcb76b88ab02226524a6b81f8491852a05686caed1d82c7b64d62b17d1b7c9807a2a8e0d182a0d8264c9a7eafbce76488e8fd68e89252ef9eff48b3c246334f386f69eb2f99d85bb371979595f2764ac96bb3a4b322f4625fae40a2a5c1dc7f82c52519784ea3bdff16f432236d165c248716f0bf590985969c2c545b092f2e0c4912c07c8fb1dd493e1a50ad29baade4aceb0448df35edd2da76d336d2562c7167a363e50b73e1f6d78bdadb3c39615ca042ecf8f05bcf437239f4b31c26785b0e1759eaaf5510c89a6ca891fb9c209f52d0d00e1e60d2e0bba90df8d5c35b2aceba6d72ef703a98a4b2cb20ac7f762b5271a4e7243790192c595d2bfc9d8fd5a7a859223379d9a8f1f26392b114b18359b28a5ad72b13d6c0b20639b8562cd0d45c9c5c2667bd818f58d638cfc033e3b875c74111d7d47679ff0bf9cf66185eb600839c1e3a73e792c450ff09704442ba36a901f0573fe5c010d925f89cbcb821b3174f0342209f78e1a28580fa292467919e3234e7c9280720adf738f73ff1567f95d3f6db79a05dfa12a62946d6e5a02757ee6aa15b0bca8b92d677ac68eefd8666525e7134f8ca626b4bbbb55365672f8b72d40d059aa73c5f12f98b800bfaac5a4d4e4b391a9b290c6572e38b3258d82f54c5fd10226857b6d71847f2120430e4dbbd956b722a48e46419ce30ce9de162d4b87a43435e37882622a4197231f1cbb1b4ae2d360e48b8359fbe878c829376b7c11f9561a9678ae06cfac12bef8aa8362a56a463b8b44ef94a225893427de1424368fd736cca848e213db2bdbd464759b3c13bc1dc1e737d82e21e61a8c38f670a4241aafdb36a92551104e4b1ab58bb7b7ba036132777dd6db5a63361b0517c4cbe2c2ed1d6736587b6c870ac441a2a77db3831d6dd4d0e3eb9d7e5b401db120287215ba3e43bae51d24a336e96c70ec78dc1dd098d9e4530663b6314a5dee75fae71343400da95b171fcbb0e15cf3014e8406596e507dcdb5eb074cc452e7530c37dbf834c62cd21668ee04c09ddcb7deed80fa513d880b243d44f8fb2a0544f08af90f1a39b6db04b1dcd60c60d4cb5594b62f560e83ff9f6f065aa57e62db9a74d262588a570597695e5ea5bed4f68f4bccc9bc5ce0a0cf6d5518c7db2486079cff8fd532f982400c143d0dbaaaac6fa46f17b1127afeab76617cc19c330eacac341a9894fdb8696762ff84ec24061c662cce6f68f781369e7fe343ae2d3f74d873c681aeb9ce11790adf5668ee0be093ea896befb41134fb95a3be43a1a9e4de513fa6b2afe2f140d2f0d7e8b5d72db5b25929075d78176e4eace1b96558aaceace959f14731756b25fd030a5b9a0147e06cf5073d5a45ff272cb0cc4a0fff0fa48e0917d0c8bf2bc8f2a21854f988c536ece217e4036f6aa8206bebc2c5637661d74bab0245171e8998797742405437a22652bb43554868513560c517feaf77703a4c67c8a49d4438a360e3ae60fce57aa029fa988c8758d1112f7d113ec72aac5de64524c67e1825984221be28b5fc0d70ed13589176a2a69c0e55d7cf9c9d502dc5e0cb75c721a6f1383801788acfdcc824fd3971b6025d9bc44a6cd82634ded35ee7bc81f340b07de949124817518fbb755abb1670cf945279b35ed667071d00facb08fbc67a9288c097459c7188bd1016f7f736dc445fe0bd29cac15cc3ff74d86a22340dc84eb0fd178bab631bc90758510c25acf5593d2028fbbf19e818d4dc8229e2dc5e6ed8203aad9716f5ad5f4f06956753cecd9ab4d3b81cb9b7a6159e78c97503991266afc52a64b1afa7b64c60e2dbb499ddee5ac4e228d4aea2c9a212689fe6f6e14cb13458f11c28ca943cb083e70bd320d74e6bcac9dfc2f2f2730adcde2a22497209600bbda54109d3a1fa0462f88a85e968a9bdeb9117d7557e4331a5e63ff2f1bacacafa74a8cd990e9640f91ccdb2a2dea0034307fe384d0a0b789362ccf352485b1a7af79df2872b7b24762f5010b821d6e470fb88bbcc69dd772599195a4c2678be68e5bf70ed72325fc7a4cf70e05f9da493d9cd10483c210e1a1fcc1dcca293dcaefdf8fb6b9fcd2ed105673a34a45408b993c90964fb243751ad94be2a62bc538e751be5a8547a80d472720a9a8871cf0e8907b74ba65ea6a1b6225666f4780b44ab6b94faaaafa2443f9b8cdaea3d39e85c00c979a45b113d8a63368c015b5011c355560cde1046ace91afb3540093354b773304312a9d0edc7cddacc089608be5dfbdde28db2b82e016fda83ae1dfb11ea6c8335e3c69ad1a5173d6c7301d7253741ca41c86a3f1fba8970a14f7a710ddcb92d9aa50f56ccd365d2cd9cae0e0406d56cfcf325d1d5f5902fe469ac76ae1d50f162fbeef6f3cf6e372ff4cf94e6bd96814cb0cd132138112017eb1be53adab0739ecdfa54bfe9cbba5c125d2ebf86d44c3efc46cd1d00eb4f63dc04c40f91b4882e7ee7ad7c372e1cccee6010b712156ed746855c3698a762844f6472df7de71efff4e64d5399f36bc28a20e4b4aca0c1b17b2f86df739a33fc20f9efc9a4a64353e42f3fa335b72750758a1a21feb9b83f6f27138eaecabbdf0381b793ef13d4f84aedf50f5907afddc720f72c0f1e33c6dc6c3abcfc323aeedb0d07284f73d1342460c7e1a4a99156e776efdca25deb46662d88af08c763f9756794f8ce30129403e20d40edc8b603ca483b52ef5a1821953aec0b959271ee9951e96771c2bb10cdd3c5bde10d62ecf1c95287ba89d89864f6083ee9ae42db85076509093a41c80bb9087eab47604842347eb5d00d231945c20a24fb64087781ca38cd457cb955eaaab57832a74f2aeb49b275985911fb95df4b5bfdfb290c2baf8dfe45eb50b03ad634bd99ede7d6604048d5ddbb116bf432bd0fb1b33493fe27109f269f6331cc921870715e31074cdc9947047911792ad0bba75163687fd2af9de94ca0123a0bf9ce3c538fe6abce54229996da62e7b1c8b863a4a2e6c417fb25518ac600074f128a32985d62ec51b292f018c90c70ea8b4a816cff6af71f71ec3999a832562945e58dce5fe2cdc83483380d03e0c956897767e51cdd1090673a2e6d116c254904818131adda81efcd812e5e27ba25d896bb2ff92466a89f60c20e43a9c17b04aae7801cf8c5df3f62d6eea119a2327b9d162116dd1cd5044590b116eb49db451512f085ab7d1faee72d5eed031ceaa45b2823ce1b2bfbb99907f42437ba3ed658285cdb154e70ec835ecdb2611f3ddd0c29f4b17dbfdc223c6fbe0ec3429b8f86d50330e62790061cc2cd9a2073c6e7fad4732a27c0556e11516c3ebaabc794065d1c59e91a018a5417bf0de3c3e9998b324f12e1119bd582e281f214c66b82f5fdf6d8914f2c3d2293e6a9c892bd93494101be39cd837835452db14b059462bd271bf91a5d38d9de7a80aa086867e841847d2901732a601ff787b96e1738c20cdff3c5ffc98a30cf6c21c1fd0353c3dd8807f57ceb5f496357f750881d40816a8a103bc32315924f78c110ea2167d2b9ec5397e0deef94f9ae4f038f3f34a8ff5b6db207f37fc6c0b76d30ef2eca2f75ea9294161a2a847f620228f1f6a1fc10b07da5dcd75b41f6b22fbe452eb7aa0634914dbef6981ab5451d16b67b91becd5f369e7781a9e082e38fcf899f43384e39710fc73f35755de463aee1d402af8b82b45c3861632269ae0adf0f82b29dbe163bfb536558ba4691273e148957fd9cb062b8a2b26bc605f9aeabe4e10427504489b572d3cb62efc1f5d609ab4ea2a024e8ba3633cfab186634a70f5284085672cb1ec2f87ee40a23a614b7bee6d1d4379427ef698838e0deebfc99cbc883c2b07ab6350edc32feda73a683ff2971d4d87f90c8423dea286a3e07a28642691a31834d57cf784d362279e5109da9401f42daf0ee202c2c00a8d9b095b96eb331d956b85058f2e3082fee4ec90ec09b6b2838458f8a8c8ebc93edf4d50752cc26fc6ad4a5500c6d28a8b3343a79434ea809164f5a7cce3f80ff18e0eb78ac4c77f1973bfdf892e7aceeddcfb8c80ab7b6aa36b9ced169be63890f7478cca54e1f9b742ef679d67fe999429e6c86a70d2524ad3c67a47348ba1fd68cd721bbdca45771609dd605cc92ab09a4459540072158772ae91a2c7a8367c3a75bb3b2d294977fbc5f0bfbe85e99cb38ee7ffd4f2d8375db296a20224a1b65c58182220a7561b502d28d6692025bc24cf84c73aa3a756b4d2f3eaea2add58e1736e8b70fc6827c00e778201e4dda38926ebc309f3e691de1f94fb879cca4d4f86f3d1ff5e32378ac59998a631e6ff6a32e04bf43e66e46f801c39aabc8f54112dd764e33df7c2506fd216c435c44d88e0f49993e589379efa493b07d29ab4c5a7c0a0e1713c9bab43310f82990d98ba9eed61658f5dd8a2d11c946082d82bb067b3679de1ed112987610c2987edb620aa1476b1bf690a24ffbaf9058e8f0b15ae4d1e6f4511fd50ad24b199659d6c7ca18f353c14fce2b996302f729acc388bfafe28f9528a17610f609764850fe3038131be8d00a9b3c2268e29a5e9278cb2bfad505588dca0318c8a22f5e6264b7e47f1d609cb38cda2e461fd494462ba9249b6c094f78f2e1ff4fa7d7c986c221bf11aea8c283b1a1385e1e5e9d1ab9b4476ccf8c2316677991c7192a39a582d4e808d4a1750e1c45449876f2047dcd3b830a74fa80eff20a169f5507a57e6dbe511cba7144231442142e37097953ed1e07d328210e06d511403d4f085efaa27bc543d8aafadaa3b9cebe361b063f676538c3a8afe8805d2185b694c95d834adcdf560f032ffc0dc0ce45de5a10cd8ff951b5114727313dcb414c99ade5712eb3253c9f74275511bdd244fdbfbe67ca627fbb4a5bb08f17bd3b2c77acf61689f3c5ec52f0b891730e96c28131fee9cb2d9deff936ea00d1c6c38a9c955a8b6785fa544ec939ac067247631e749916d8734684341319ff5de6801cc3aa12fe0b900c5651f9237381be5201455b79229db3b87afa7f58a3076862506ba983cd1ea4a0259f00377f9fb5863c18001d759017d21efba53ba222a62d50934201179d0485e22eb1c2efdc664a743dd5aa7bf6e70fc934b1b0ccf03be232df5705ed9406debbb54cb0361db1b2af1b8a6c9d001b181b1d8567c9a7a73004d9660499883eb4c41b1f40e49ffc05a799f54f4f6f0e142a561404e9a0b0bc1b8caac11a05677d4b4ed786a889f3ec3164bfd034c5feffc0af34dd87eec3bc0be9baabe6b8910a708758e49e4c17497ce8f26c44cee4eccce4185ba31bb1476e2d9fa377dcb11cf7a040c7e6d8a4875c7dbdf9d9716aa3fdb889d155f32054d36c88460de86d45951af7fabef67df6e877d938dfee360367390c608c12ab9c3c940b9c53b10cc47e5a6863fac67be8f019f8a830b7451cd7f32dd4c33fa72801dc7f90a81f29df894c3d2d886a0a676d030b2391f27a47f4475f4f26559f679f0e0ce898821ca7aba548246e5e2297a029d05427ac1c4197a7d787d21208ba09bd0ac6d2fc4667d28be8cf96d15e5278aa7cb89438398913cb3f59be11378a68f323f494726b1f3244136a1c37b8f165d812fccf0810fe5b6ec7d6a7edb61fdefb9c67795b9b39c125c0f56ea5218ea95ea6d02c71b6e6699610bd1c62b26b3c3e2ffc4159aa60eaca6ed5cd8a014864f52195bed26503094138a75e055d5e997c6b795eca49ca55f62837fa68f346cacfd772a0963b22bdb09fa9cc00090ffee37ab78fea56b136acd44a6525d32e1b1341d0ef7504931e776eb2f6d6f11fecf6da3f92e62ba5c6a99d0157479e39832543f3f7934e0f971fe7e3ea84efeffd1a5f31f32d70846bea7d7b560936fa5e02fbd06cc2ca30737808f35b5ea4dab36aa202a30235bbc0100f093c79b2b3eef66c2ee2ebee37e5dbad0d698e20b40d5343d33be6258a03f13c1b73c1a980e8f7440c92b4dc5e0ffea60df4b36bde14bfdedea14ac1cd5c2c5e234586889afd6324895de50eac4336ae088c8a558f8f8a75d76901142972c01f241108ce6e041ec00bf96a4d3b1e8b546b9626f1c9ae624f4a8b6d1bb22e18e8485abe23b985e7073aa13cc8ff2b6fcf0376365d374b929c4197fdf00e489dbf430033c868e99b59e474ea9e79b8539afb95893fa93eb043d21814ba5ecaf3b1d7f01403e473172d8f5950d10fa6673c4ff84dd2aac299b13afc9f18337393aa15dc0ac8640a349224eefc75c21d9becd3adc3864115507c062ede8f8e5c672c849075891ba14943edae1c9c8119a27a9c097328d321cb301e135eb40d1812e39f3bf16279012de84ce0e399c28847cfa1aa7719a16f596d1b62f8a8586f865d76e6e49ce6f708fec225570081b3ac46da549fdf9165f9270dd30f150de9df2d3474c6be13b283a9a50fe3f323d4549c8582e9896a9ac37ffc3081b45a63b47fa6ecc343b1a827e887bb90b77c3baa9cd44c139c1f75b915f57b28dcc8b178bb9d85c2ab3806e914631ac096b35d21a36928381e5d237993f728b293e7942df505a045e982ae5890959d12b33f578816e58991cfd1f8a305df9aa8012bc7d5911b9a601e31bc2f8213a6c3148b4fb3b4f56549538a18dbb99c2932863086abb8dbbb0df5badcb36ddba1c7333ef4f3a6ecfee1916e3dd1b540f70077dedb9c0e48fde1e9a3493d60ce404c97788a472e2a4c8b1dd8fb0655a7d2695ad05d37734dba2d5204f08e6d5fbd7a58dca83b2b642ee08e3cf57dfee3a0d70476a346d2066f69ea81403b8684983d4d2a699b36a00a83c8b9293bc8a24023b6bb5dc3c1eeb5748ee06e72deeb6da58294df3f26dee811de7e2387c1b08c77dbe79f5ed1bb47f37926ad127da050bfef33f82c1b3c91797669a737906109723c6423661663dfbaddcd43e1f2d95506a69d9adf09563a7092d14d80b9bec738185af99161c019264829c4e4f609844c37ca4c2f60a6947c606439e273b5428e1783d4a90a2601ccc50c46c4cd344dd867cc581c847c0f28ae18cbef626866cbd4aaf950788ac5f02718310874ab453b93dde0afef8f1f9cb4889f538cdb044af22beaba466684160329a766378d8063873998cd67c9a430f803b66e16db49c1ad14832d6954c41fc22a46630553ea1c0a6cdbbf8a9ccf9c475f038641bd8f889c09840be99f9bb6e6bc2b0d5552214af4e7629ebd4c863c65d50bb766644d4cbf92ce4f69ee51eb8a4d24cbe90ee52d833899e12d84d366e678e006f09a421c6699b52eaad40a8e8b838615eecf84ad04670a6bb38b782aac81efe520de7d0f72a80a98d4ef4a759b7fec820dc4d08f7a313d82cbd41975cf6334ce2c4a31a39c6106382d8f61db11f7ccb690689846f0fb6279b7780d6af5dd15827120f8db958d1a33d48ee4b27c4ce193b7ff4926eeedc0e06c490bb640eb2435b6a7210865056805742bcf90c36de3c2715a780e479323d81d5cfc527647f93912a4589314fd6631cf48efa9b7968ca207a4bd15b1973ae79644753f34545ae23a748dc260c7604d58c2ebf582bf96a3b2f7e2a17d0e2601cc3f38911f9ebc494439a3328c9ac6e54ae71cff44ae8a0bb9735a8579bc3a49f72fba2dd0e8b817bd77c76e52bd2dc55d3365db7ea1ed6ba9d443a749ee3a0bf0824c9ce85d0245b2f5429c9e6cd890ff7d5573c7672913450a7ead24ec6a62385a5be8aa790f2571a058e629199e98a0cbe24f54b4a443eef049dcb8ff10ed775c9514669c5d481c18ad4341bb96b31606a49cb5a7c7f4c645c9f332c7e5702e6a4505d29aa7308466b41eb586f5b3950d186edbadb55fa6df05fb91fad19dc5b387ba201f1dea3506bf21c7446fbfc889aca549afd5676704af2867dc26add113cc37a8755a33971ba087296c18803fbac54a36840d40dfef9ccdb6ed3838a310168bafa3022057ae2493be4546f0970c90cd8b4c4f6f21d39dd007430bacd0645b2b2d8d55fa04d7cfcd805fb5b056fb11de4e881806e310cafa94640e9f263191d5a3ce7aace62fa52a8f107f00b7c5d8d9f14efd41f7922338da19c7ff3e2406bb7ad03153a34585a94e41e6a5056337485b584da7f0d2b29939a3fcdefdd7bd1f72662d13a2eae496efc63cd8666317c87bc944deb4005ada2ac23cf41b945e7c0e76f4ffe0a0a9e6e5731283e685f814f8315db1d92dc1e027e00c1d9d7f2c051c00f17f56cec8e0947ecd3e4101c627ebd91d89a9f314fe209636d0b41430b059de4f536df732c86ceb5a063baf9d4b8461b29f06f215bf103b7b44a5a109fa504c03232aab7d973657ef44fbba8a77d4166252de212815d82b00e39d04f5f9b578bc2ed340c39c19f1c640eab538701b5cb530a57c4680572ac237e7a4ffcddc86f4c6a66b97968e828d5de2071616601d11fdc6e5d5229d7f43948a47c8bbcf0b2579981973bb0729e19d29a1e85347f163e0674e8cf90d6c5c882d1e4553252bcdaabd066fdbd2c264bbc28aae8550af6d348128a1ea2649a9ea1e0e797972e5cadb84e13a9414565c0df059ec3e2d599a81d873d46ae0c0f3aabbe9f2cc4f849907f333163bdd5e0a2e24e8f2a6272fa36d61971b778291610e274bb2142ab763b0bd6c71d1a2d838abeb1766a1ac09afa571e4c372e919aa226219a06520575b9e67716ce7632597fdc6f792b0627a8029b996a33673115bd75490efd95b6c7d4562fb9e31d263e2269fd58f17ba88e2f31b468b1de4b168321917b24e88be843cfedb2d2348cae056b59caced68d6f3ea4c85cc94767ba052c8dde39c1f8ceb51e6ca7cb6c1652f71080ed36a2d54c4472f21929328bfe187dfa210d8b7628656cf1f28ca892d6fafcd9a77c4eadfae32bae3922dcaf8abb0d8a6908a06a8cd12caa75bae6bd2c776f735001807879f72949ce3050ecbc11d735bbc85919b7f4886decb760ac6c257491f79df363bbe95e1549b55e257101b101732a1a5ac4a784a3a9fcd512927aabca5c064f3c3f7f2f94bbc424ddf2c70d517dca011c94435d4817a3ed1f2aafec045f75ab7a02b591c1fcf6855ecea436f4887094a39ba80ed6023566c7b446193a10a65c98813a5b6ce54be3da7748f6ffeff8a125f7eee5862d6a5b9de5386bf9212f4f980f971eceddecffe5de7d209b9e8760c785f9e1e9c3dce88a51deb15e11576ae6bd97f7ce885b60e24c0bdc2c1f335dac003e5e9269efe88d2ee53f049b26b376213ba0ba2358b13ff2172e58c151d7564f27b66aa552edb4a3e5f1f2783c355bc4804dce00def58f242b1cb42fb420cbb7293c4e532c6874bca195e12b66fbb96ecd01808e317bfca228245edd3a02ecb6be2bdaacbcee12e0a35d991f8109fe118ac72053b6f86b15807155d34ba201bccdcb1d2799aedfa2f786bc6920ac7b369ede13c681047a6c5eeb2fee71f312940219e667b34cf11ac50171ce5715800c396f31134f7b1bd1fc29cc053e90b62af389d5b5ac08f7f87eb2e6973a6726eb988cadeea7e49971c7b7f3e3f8e9a55fda91ca9101b59822780525e12bca48eb22598b6c27dacbadea26fed8d2b1f6ac3634fae8dda09c3fa9c135f1d2c6b2a3e4e1d103380ac05fa5ce73a0e7c92371929ea21e51c57490a471463439188abf92a4d5ee572acd0d6cfc527e45aaac3c83b4807b18f2067ab29f6cea0addc54277b873c811ebe227573c1c38336ecb535d6e1ff5afff1ac45183c3d9f7850b6e8d9fc410b727f234924af4120d816615f47b13e7665f7f28054968ef0199e7e1da99d4123ac06b03875a53c85992d7ab4ce8feda24ff1c877c88bbbabe9e940cc838588599e42dae8a9376b44f2ad814ec2dcecc8808e8cb333884fd5413e0fb05bdcba83ca1b1775e7308a92a5e0078a1b215bfcf5ecc32ca0d5e3aaeb6e32cf54a41135b8e09b6c13144e04aecb29b96ce1c4d3f3c3b62f2b9bb1ea68c48f10a15ad9e4d05a7ceb3d8fd49c3bdedb32a0ffaabe4c23a35b6084e681749dc4467f7ae6c06795d88a2af029947e9f7e3b5c4d1a36bd472e5bb3a59f4be37bd735c9cdf2bfe9e926ab656abd267d9b00d2833ba5882f7b0e1c7ee635c7862b03bde9b06a445f1f8bb8adcd2f942168851d6ab90453cd31c8126eff2fd79b47760c439c2fb1c69d88eb7a4f8cfe141f1e422d44c492b460361fbac845d26e145641a464b1153c2186f3ab21130ea72410eb86c8e404e308862f49302286d4e15f3a832eb693271e170e75447aedbb908af1676d7fc2a41b39befe641cc5654445875594a2849efbf03353f82990d977aed5affe81bd3b744df6ffccbaad8f0676e52e907ad39a425896a6935244c4b8681b5cd036a19d8de0e2558228550c7eec60e3329d6909b5fcd45c7c7bd5aa66da78051ebbe16e6d930142f6a24d304f2febe11617a3c4885cb6ddfbe3a8929629c98b761feff639a467545adbe262cfe9b6c31d71ebd1adce7207ce346bb710ce87aef0c6ff35016663956b02b23786c0e3cb49b6212bced141c126b0150b84ed6b89434e2063f52ef0430fe318caaca6cfb9243d833112f746108dffbeae9b30d181941132c923bfab155a5425b80e74d8ed584b55d28af52c7979a384f3b1035e860f39df81bc292ec57778490b97eafebf475b2f0978f809838cb37ca05c07d67080996a6d006c4545b00ddea80dd83490dac455c114460c263f1891e4d6474c50747ced4653ee83799395760e5fa7c9e4ae02ce8717b30b840acf5f01e744014f594ef8c45d469c7fe52ac506f4d50acfdb02cd2333e35d5759c665bcf24fe97a4298f367aa53f1cea11c8c757526cba3144c4427e6b9a5bbbc0bd03654cc09b10be1198dd22ac3f06ba89ae03581f4d2596bbdb75e3c734f134392fcdfa258fdd5370542b64d9fa3e38fd64d4244ff958acff0522243","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
