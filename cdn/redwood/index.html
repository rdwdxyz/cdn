<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"403baebdb051bfe452f6bb3752483d5a07cd0e34b90bd2c3adfe6434fa58866f2485900225d6542a6c0c5003f67165e9ce19f66c501fe33e4b572d17d1ea2e2f05a837339279c5b762dff9828d917dd0daabdecf8f45b2dc927d6a1288c2a192806339bce7bb120107f9103d6853dd99d95cfa1304eef96c2a2e280d9b418e58ca8b9f8f21173c50b47ea4bfa6904ca086c068b502d5cea2a0da27785f715287ed6ea2f2195916a9fe01dd58bb1a8bf76351398c7b67f9a444856c1a9060369a81252ed411a9fd33832d7276ca73e4f684c42271b53c4aabb90d8c24827b56cee23f74b09002805fe9cd87fd5aae7a642f27f17249913bd6181689194902b1a6a2b495fc75a1d9a946145c892ca2daee2d76d2b0ccc458da5d8c70d108b813fedf5664fec06b6a8ff649c0672179c475d57c8b7cad40f6f3e252c39d76654e1512b0771471fa40320124680e88e848ccde4f8f8628a5f5c322b15dbce8e8fa99e915c79970d583efbfa15dc46d90ff0f2435ed1988c89a57acb4bc452b30ac23f17e92d3877930886963151c258bd28997bb79679a0923c3ac40a4c71c5053596d071e1442af72a1c8bbbf51bc1ec86442c5f0b114fb11887ce6e02bfe35ba0ebdcc3b6368a61f3ec15e160b506d30d78c27b345790d132020a49c83b4dc7bd6b47226f7ba81f209864fef309962b49797518b63ccae5e0c81ac089e93ece1ba655aa03b75220725a514e220fbb23f5167e0378caa8e410b568d03e565bccb82c18a41c933739dfd517a8dad9a212a4fd228b5d41fae0c46bd4b4def1d4d41292bd03478bd11a4b3d088401ab2796dcfefab20333f06f4082b1d920e6fbcecbf6f8bb0187cfc87f03955391b5444451e4e4c282251ca6154d46d89869b47255e0237fd191088fb97272f65db96a59a6041b0f82bb8013da1fd6330d389ba3ec86d8de62ba81364aadc6007d79f9665865813577bf51b087ee5c67c3ce53b1e2eeeb21d23e9ac058022f9bb90e60fb6da7507f7f829a63963fc58a0c1943852f2aa9714c560bee4e2806e6f41a5adcb1b04f1b098b3edaf409679ba5b377144789c8988ac964644cd4d6866167972736dbab73b6156b28c577507ef45a12da3aae3e57592d42ea7802d5ef35281197d7218f45bbb5b57411a8274c4f7cf9b037a4c27e1f3b64fae7a1045d1cd925d9b644ad726aa4b50bef4261e65eabf45286c9d444c374246ef1b828e08f8ec72a8bb7abab008906403003d3d6d1675f708ff764ea2cb143cb0c77646ce3f3f14563f3d0cbd954a93de0afcc2d1f14e92ea3365a1f608fb1ce514f88ceb9055b731d2b59f118acc1e6844defd352987533b05ba40982c0470e4cd322b0edf2ba3e5706c575523a91ad72c438b7d529d04d573e1caf22437e002c4cff2548db315135aca2319db57bd9783a23ecf62501a4355b52a616cf5ec001fbd690dc8f5903cbbabbbe2bfe976910767a04d5a740400e914ba836382efe71c3ac35bc1770fed373f17cd5c28e6b6ea8683e366eefc747d28fa7343e97c94d9ce10d36fce1d92f2903565795ec8ce396bf796fe9476d1bf994c5cedb2b20bf83c0bbb069a3d426770dcff1895bd5ff46836dadfd49cd00a9138e04b8e4cf9bcfe94bdf6777e43f7150791a03b2362d84faf1503c632af6c13cf5701e72821159e56609533b2f792ef194eb33a357b5baaa679e817cdb05166ebb937303aff822c7122cc5be73cedd725faefde65630a2179658c81e12b0566d83405ea7c52c73f6df95b6d1269b40fad0b7170aa12119894109b1e04d73d8c1394686618593e6b6d5c71670cb8d2d1a275b421f226391f0b222463910b9346e54479548dbd4114f93429d707790a86eb611bed7f037ea0f7e9d5898da79e02b77d0193565f156657abbc669bdfcaf091e6e3807c89326d082b84550e1750267123c56a40ec22d5144595f7a44efb61134ba6bd0a52addf36686b191c8636e8e1d60883b36f6b3bddc1aa61a6952e2a362b688ecee180715e5892ab55e09188d15dd3982e32287a87e73749ffc0511fc7cffa13bf61c6cd3015d8f6f116a1b73ef63bda7303448d4c2c5aa1be6682fa9708341cd786558a77d2279c5ca9824041c912567c9662d18b5aa092d62ded759621ad3378d92d601205d63556a8aa434fa32032c2f8ef0c2486463c10989fd7e6b987b54e33b8d99626b5d8f212d9187424299a66587eb68d266373a39e7501266dd507c3dd6fc851cd140db4508123a141be4564e8a1d992286b9086e7c56ce96a24ad6b014142961e279144407809f6c083aa5f4581deac74dcf677a619a0a1a1ece64e438d34637db734aff91f4b0b5c651d821c5ecc0069c6f9be1f64860aeafe99d88ef0fec171d00f7d10ae215baeb44bdabd4d08130bf698861b1e5cf8951b23ec3daa5817f042f3341094d4d563a20ca337b3825a1eee58f407975bb8fc75e83ba6580fb37c9c8616346028b2577222ee74519143e5205d6d09354a70b0d2d89d60186ad2de2186b51cc8de53bd67c4b9f788d5eb9c55880073ed6910e61f7c84309cf436ee11f052bb68a1e39745b1ac0ca98c80bf487d3e7a23c348d389aacb5649292efcf4e180faee4f5fbc44c093237fb0faa7805f2c62ee6f9886ca2134bbae4fcef7de7033c946fe1480be790fc0aeb175aef61e1078382d84bd2cf7479ff3373c40bb3806b25e518a3577a23a573d6ea04544705bc6655359ac09c74e8046cbc78e03c6ee791fea21e5c5792c9f8612849d6ff24f227787f97e422b7a3eada84c9804415d205cf99df5adac235c08767dceef724bd74620331d85d3b66d3c3198103d747a0905756f78dbc1b0386f1d10ac3d8dcd680bc6034c55e36e1aabb41d6e2172b029f1a0d8b77590f156ade9824006329b1c1601cc36056e0f8769473cdc09eba1e70c8bb68948b40fff1f202f9e3e31b4b447f59e1eeb367570c216214d901f4252fff2707ec57f095af89b001bfbe4473a9047f82348172e85eb225989ab3470136dbe71dca28735dbc9b2be6cd624aafcb8c3af67e7f5e34288f3005ba4217064c7afe68ffaa85b96524edb6f900e21aed84b598372f05bfb0318056c161e1e2a72877d588f8f5aeb67b8eaac92f466fa777df40c66796b3ea9b2ae6d8237023400aef14df35e6e6feb45bb9424835ecbf56710ed6f2fc6b571ecd66d823e934e85f270b83994066f7c77c6bb7a27e63401359d842cdb631ee17f03d7f8dbd69823270967bf864075b7350c7dec463d6552657bcbe392e0d862e1e4aed2349f4150959fde485a2a323b1bb0ae462c62ffa9bbe993dad990a87750331c881b01e389ba534bca7d84f5119ea77e84a31eac05aec7b05355e9e948afe210bc501469b70d877856db24dce02ab97629a89c51fce45b743e0f6f6992cdf21f6705a85726d625bb3dcf1922702415557c4bbbae5593aa41f5a25e63c4def47178fedfd133f3ad46d4f272bbcc2240ee3bf4dab35a2aeb513575566ecd0b5c67afa760c1e08cba030dbdfd22b0e8c99d0ea5c36c22ce388d1f4b56e807108eeaa6acf6e4c480b07febd6a4216cca0f8fd3873bfb08d2b2ce6640096c4234e1db308492299292c41411a03978665aeb8bad387fa7f93faba3d402c1ae9fb86dbec4940b8e456a44f8d07119f4e09ec841555e70dbf2878916dbbd28401d0db2c57e33b2ddf24d4a3f671adae83db6e44f570ac1917701a604a4ee594f945c6a8f8e67dc0b34e63374c459ae038d91fa127c6f0eea63a19bb1a9d0970d2d6c816eedb9fd6f93540270dcd2c7afcfb9559322051db388b86a47137fc0bf745f114d45a3d0885c9ed26f27f409966a6f1dd05770f7b9aa045b8be698450fa9e92b8096229e12139f726de1f83cf451873be152bbf347563ee521167f573fc91fe3ad1239c68d24f58f7a012d026645f425e811e7d630c9fffeaecf5865e881235b0c48d49ce2bebb99c7a1830170dd75bc37bcf777b0f0bfa14fb01eb05629087779952fcb12398b1d978088ef9a1ebc952c877c5bf365d2918b94bd2f00c5825eac1b50136d6892033e580b6e312b33b8949f0cd6f0bb056e4fcbd6482b4f558d60efb295d4fe9c87a0eb911b46829d9ef90f8a3f8a96dbae7b14a1d3bbedc7b36a8adfe186bad7905e7bc0b422d6d6e4d3a387fbee3d4650c146aeea96c3df765e4c058b76a0d7436a5dcf1e761fa8cfcfa0b142986ece5114db0b1d2486b808dfc0f3619854dd6c40e89aa0555d083cb4578d5003742547d42b50f12d9037b008f394021b4b0c45531a0257fae7cfe7dd20453ef2fcbe2bd93909649d17e9666fef1815858b1cdfb9ededce311fbdae9495cc051aba2d48f89776464ddaa54de689644fb7019201f26ed5d4bb46f741ba20561ab2628eee86e99fe9a7bfe320b66da493a6ae1489f09cdd6cdbcb827f7f217e8b3e98672708401d9a8c54a91dd799e12912cfa1bdb2de8607e2ea561e38b1c9fb923895e2e372b670d6225e5497ed14c4e5fb90bf01d13afbc9b225bb2963adb5d9ac3dc69e7e2983b70a69d92273c1a9cdb34f622fb5b979158a4ae797c5f1aa532c6294df6cb08bf1f3855d745283a3d5639840d6548b1004b5b9c6dbd652676861bc97e5b4e8f4937a5866acfb2c2f9f55ac89a33f380eba57230f4f3da6159809b6b532583d6213b0c0bdbc675fb3fc29e8824be36cf696d9643d4a9904aab825f45a6952bf862d46e788eaf8b99ae6b5e4d545af2d8e7757faa51c77b98ff2ab4a7146a26ff404473eaa9f9394415eed9482fef4fcc99d1c1fc3f21dc7367f6ff76df5d95557f0424da39afcbda69749dcd2e76d523280af843d8c32cd7a1abd5978b3e4dc6d9c18e5560c7b3e36fbb154ba738ec4a23d298b46ba5de465795e2f952eb807891ad04837781eba1c8ea0036a57f02dbc42ac44758d121ddafd03f45fac6cb15b6fa8f243969804f09551871ac4909e2b81173482b524702bd1043ad5a4b1c6ae7530afa20c621eb29570a1277bcfa7ed35b7d2e5ec7a3f1dcd0371ed15a1caf98f35e2b6268d45dc66792e91f9cc38e3fb2359ff0b0ecc4c98fa9c1f4020d98f42729ea786c4c7a73761428c583c524b6099285b73420cf6b39fd570118f61284f98d42604e9c38cd9bff81dc707677cd6c40d705bc1fd956138a4708d72bb594652e6ba5e6568251a0c63d2d74c9b89ef8c73c0dcd4c606dc2a2f7e60a745dca62caee9e3ba96bc5c18fcba388ef846aeb5842c2c274cd5320e77781a5af6d89cce985f2f530e3850c3c112c04e28d377756575601da22c37a2236d592fd3345b45d36ca119aa5e232b4ce4f3456654ee2f3b2778a954d714b6f8f4e8f85dca7795dad035df63d9ad192838568f8477578a174858aa69b5e889c2cb19bd218b66fc9a185e2b7cf41e3c538b974c8b29188dbbc57045fe27cb784932caeed39ba4312c957b0e7248f4fe48285ff70df1d1d754ae55df3a4c52e101ef8e5a06305b2cfa557dc8159b601a2bf998f5b775a4b72bb2eebe2b250809e10db7a102d62c53b9c43193f78e85caa936aef5f5d3d6958fa0f417f6b90c0680bfdc6c39d8f388189a8cffdc358422a8ff0c62fadd06cf19e45b4f429fdcd86eb9e570e405667538c79f17a7ae7bf5f199bdf8606929bc072aa33e2462dbc10e26a7bab217ef76824bc2c8bf001a95c7aae75ba637b3fa21f77bdcbb772c207e8130d870245981d439c7f456577e3963c29e637e639a353aa9b4111def653e89cdbb4b64d07d9bc627378154a53ed7e14b850a5d985e044eec198cd81b94ea3586e0c4277f9c0adbaeb7102eba4ecd880e67111f74886e4207d2d1ed4b1d310dfc962a9ba7827e32aeccda509a778e3089a5f1d6a06829df934d049222ea788be3fd087e0da2faa62e621e058c300d61494aaed3ba953cc1013db800c8b841b7113a51292ef84b4f350b36ff58b61f22c1328c43ae49a329954e27321bde2c655056ca0d0d6c55ca1137830d2d93e0b27602b3908f76aa596c7fdeb576fc1c59a70a3fb815b102f1c7e4a5f99173e7d75579f09f864417b69a360cbb1b3073d1a9621b093f3e1198295149a7fdc48dd2356c65e4ed88b6bd98de3b713cdbc6641a4b1744099a89ee2d33e5349bd2c26bf58c4e1d77249b6ee6636c71a6495a925648de95f602b929aee1c253c2bce5cea7db84e4f9157a63de814453309b434b9205b2280dabe6c2a77b90454384b19a77be9e9829e9c8020a9f34773f9acd1e1b5601684b7a9123ead43260b079ccb5488402d51d8ba19d12e3d0dad425d88c07ea1266a3352a3be288145053011f3498511eeade3f60ba9ff8c927f25bd0b19f90a183166e63f503292269268a06e9ec273bf2032ea606193cba7f80a9e7cec987f5a4e0093e19c226bea37f512965c00a2cc62574b305a62ac8a1a51ae12c19981aa4c21c1936f0406921821365d9ea6fde96feca1da7bb6becea009e80f0141dbdd9718864ee335d518ecedca5126b052cf7ef9e8c706c80eb310c2bc5778d6d4f4b6d922e56353aa98b51b5262cab8d387d273abf0dd0bf31fb4ef736e2d52fb8cac207b9bf30e8a3a745d6658de07c6382c82bdef61798030dd590a2db363d5e20e7a7b446dba3ede73a062274a6b21d849abc80eb4c33ffc8af76bcb4792aa1fefaac67078e296a3ab324aef49f53390afe63511eb6687e00616bb9c92f5bf4df446c6b45c440f37ca2639dbb612655438913f9521744e22d36abe96a776a52969926c152da5f11891978c719b2a7c4eb758283ba8b27aae66c2fbcaf120b1e126af35f7d6eff0a38bdefbd8e9f4f0a94c296aaf53bbc42d87ababfab7fb59627619f7a24507b3be9b7311e8f94d50cef9d4cab9454980aecfaf1ebd47092f3699b718d42859247b35a942c5e11a55554d37bb0b27b92aac2b8241c0c3d1e927854247a0541248ad6a53587260eeec1156906de35a34301c1b7f2cbb9a49505d9359c7abff0237871a7e27d47a5c8a42c97f10cb36d4a0512938017239073071b298568eedb8c5edbb54a607750ebe02bf769116f55209dfc4fbd102bc2ca59cf628ca072960f704097dc04f0c172a3971e7c06e15f27f2b6808aab73af9ff664d4d895ed9ff23111164dd5916adbd9cddabdc584457a3bbeb92baf0aef9d2daabc3d640e1b3447f37da494134250e5f65476625a4935da538a9ab0284c88a815abeda44bbd8bf942e3c1dd1756e86531c3d20f5bcdf1348ad68bf67b82dfe6b044f4b8a024a7dccd5f42e5008a45a30ae2bc921820e94cb5b5f072fa989a674c9636fea1d41b33fe9c18abb9d9016a506ffb37615ac7bd7abe75b1e9ef436e6eb5b63e210b5f2bb49bd9d494c994b197a84a16ea1c03986308bf98e8f466ef8249fed45a6afa9020a9a90be9a29621c622a26b529ce0856f0c8a49c8e0732c78b2543a7ab8e32647290e8c7cba5239db8d474e0a6d850852323dbef90533af2b81ad0618d683ec6eb17f80e4e0c2f735cb0a7ed2aca487f7cdef94b8cc3d9ed0e8e89b0fb8b1f562cffef1fb0e6627065c87b00fbee66dad00a12e82d66eacd3112834c5cff8bf887ee2480d1821550dc0afdc9804a9a58c96f4d679387e6351511c7615c227521fe114a3cd6eb4f3ba3cf248ee9090771ec2e191d32aa85f4501cf9c031333d2320b29098c51311099ff74b4f427b16bb76585c121accae9be95d7cc2b57799dbdb652a4c7182dad8407c9bc85f0456bc040405134f2237c33e22168d8c25e0945760e4d011559f3da0f1da876ff84158fa6c1885260e23a238771b873a534a731835a089e94b6f9a4dd176dde715673d55eb5fbc2eeafb7b189cf26c84c3d38dcb3b6919429d1f9ad2b0af589d67bdd4038a5070f75570e86da21734ece4f10df90b8610173f5ace20aaf1eb6759201d36d70f60430aa924057c2455f2a4fa3f552278416cf3b222c1f93921ad23d8304b8b0ee8ce75e3d3badd29d3c82e8dc19a1b482948c207fb135f72a38dc3a63ce6ef2b417ea7772a266173d5022f058f0bfa22bd86a282edc5656a49daafeae59cecffc61b28ae1fd61f764104de1b8aa1c4cdb7c290a6b8642b6e32e771d0ae0a33259f0214fa79369f1aadb0d9e924fa40634345e0e2700a35686c9194c345cc479440f309e638768df9ee8ac9ba25cf97aec9a4266c611b63e1d3495c87f73795c7b9576822d4ff7ca39409b44887ba33d9d22c45b171e2501993cd486d230e53e23a8f0cab01d732c89dc4d561c9b8e1a9bc6aa1fdac1ea06bbe2f215c90b85d939d32f2536d888444d6931738f19176d6f25e519b693beade19f7f739ae1c3c56ac3b8c665395ff92e0373530848107ed015b1f6768417445f96a8bdaafbeb166adaecb64cf088ae29ac85b6bc1ab6d50344dfba6a7191f106a18954934df1f5602ea731d73c38afdb56d3acf6c209d0efbcd4c0690e56066227c802695e8f05e32dd2607cd4147926dc6db9db8b58883e36765f4aef0c3cd5b5bf5586cb98355d7d383f6b6620a908924834695b519a3bc70f07ff6336d767391aa60543e06a52f80981c70ee1233fdfc2fc48ca96461c4992b8feb0f9167e039bc121f2a8f06b11a5ba57c85af6cba2f04f9bfbea1dab8f470dcace13c971cc19f4dd15b34e3fc8403052220965e0aa9e08cedfe0774f6847099ef002f0d3908e6d635e5f3810e8e7b621387f00b449986eba0396978b58d8536acb5414cfdfab89062c2aef4e2b0c040f2a0c53152463e14a5260f5cd0612d18df0a659141ed087764db09e55123bd372f88491030f6c2c679c90792f0867f0ff73e6efdcb52c1e8fff465f7057b0dccbfcd9fca681675af6445a5027af1d8bafeb309d465d404d264b5728c6682ad2d1faf5d1d523a98f0955e61caf4c80e06fd23fd78361db00984554ef629654e7ef41fa0fdd485bb4ca0a45b8938c31e5d053bed41a3007c0756a6f69354dea9f0c4d4cb0a92df1bc4ebf938470725561760f27dd7a496869daaa1733b5789b35fce82af4676db7c29635118f86a2f74e7edcd015e2dbc06c254831cfb6da696222f0157d0e6a67d49bdc3c2777b41794d0733f9d7d0d5b29c939ed5541e0ae2b60afd15c916861e84a193ba92393e2f8d1deba250f166df7751309f5f5ecc04a6430c41623d68cf6c63e5716be9a643320cd6c793c3c2203185f485269bfe44fe8f765cea925f7c8bb31941545188592727b92f7f844e95e9c3b4bdd1886a0fb5b2e77bc4f0da4a44cb75a8158bc32f433c0157665e4e12f02a22e9856d6296b1b9f8fa31376abe0e5f55de03a028af97c80c35c45c449c11c69ccd4f8e97fde11402f2c37afe0e626491c4b8a4ab3dbc6df16f09c5cff3212fbda8e3dad852253e6df611943bc955dc5d1d5c50b9275296b7042bfade89f6f9494fda8eea239a92f36dccc26d409386c5972eb02be8d0c7ce0e16fcc83e8783bfba27eeb6a762cb3d58c6123f07366f6ff17ebef1d6ce6e72b0753c67c8bed5d724ff33fe70de2ac6cb64c9120e5adcad8aa8a7d9dfdffda23ec08c4b69b47784884a89beb2e118c3a0085528cc693b0ee99bdfa43923e359f4d054bba8c3961b8ccd227f071e10c82237fe6c92024a2f75ef1469000dfd9c8c05c06c10f2b53c79e34faf38d97a0fca338c74290616a0d5affef01b51fb0f154966cceb158e1a52b7c84ced405955a818362b5d357ef430658ec539f9e81c0889274a15b51af90fcf7d405edfaaa51c74e641ab858798f58314e8ef361554d69a5146d2af73611ca25a3f4c7892ab56533b324cf40b9de755bb6f79be0037e1acbc98a0a6c1efe4ae5ef34a4ce94e81b19c225b317f07b4b1fd723b95ac09a052285083649a4c48e00b422fbd209ecc99988025035ed22336ca8dba5bfff03df61147543edcaf443402eab218e7e8fee83cc3f2809d71846145f64a7b4b46e08782b3fe17ff7173fa17ceec0cf812e7d471d3dfd41185b3e91e7264a6276ede15646b1697c37f8e224da62da5a97a05e6f610f48aaad3840ae56a01c2eab5085af9e8e434b7e547ab58b8a18e5ccc44d5fc07c6adf2dfdf7c192f052025b8a2c3f002600c5e739b1a12b9b1eb9a389df0be3938bf2f47397d762d4e0d91883ffd4a300e00ed5bdcfe5e5d77a1402120d04285d0dc67dad0a0cc69f8c49e89ebc876ad0831c508a8c23ca86e142eef79f6391e0f233e381f6db998bbc7a28509324040be9ddb27645e7c09ba965db87102fa7258939cd7546fb27f81ef7c6239e46a67d5069688eecaf591dceeaebaed21d8a03a4b967d941ea7bac50cf82ad274b29e07d314e32aa9a265511573f30a29bb4917a3c15e9b88c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
