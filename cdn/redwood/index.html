<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8cb945715286b030c8387b46acacceedabdd78202a792aa9d4217aebd61d3032647c26d98116dea4b1fa63ce36d3cfa10b6d53de0d1511cb1f2fb664a92539ac5859f8d52ae896f1058f3c58409977af23f7bf630daeda482bf4662e63bb7dd1453e4d5c0d34e00dfd6bccbb3f7bd2771893f0b2410b218cd836b8344e21d2918bfb08bea79d519acf2931b060ce48ecc744b55c2073e004ec81108bce0df02e2226f9e6e6a474becb0223c0bb6d49248b4edc8b916f46117e897a4f0da9f14bc798194496708ed46e65d8866ff6d836c0043092bb71dd61bb0898da5af9559d24036f92bd691f73ec9b084667e1d5fb1c03ff165b004bc7cc046b4a51720d1ae22b3ab5afcc9582db33e383cdcc6fb3345d0fe1d285cdbe73ccf5b32f916dbcbd7a68114c1acb456b8e8d2f653193747b82ad7683f440d6099175648007a2e9dea1c5292b3e009c6f858cca773a738f450015d0ccb96313f47f3d1b48ad1c08cc42ffaaa2a161393d29d1dfca7bc219bf4fb9cbc1df75f1894a91b096d8a365e7d5bb848e4379dd07c9ba1bd16c93e2471be82efaa87b0ec08f6579ce0bd5e5e8ac88210f8974ee13d6ed236dddf39ad573b321ac401731c4d8ddf3d059c20bcb89f6891b7045e2a79951e819c51bb8a697fadee9c36df69a35e786b6b0d3d095750876088f743dc174ab86accd0502e497a0ce953826a7d29a6e8763e4c5c0e54ba3c0ad3734b7d11418c455196fc44368f8e34ad7a424920964f788b6f03c2bac5deba5382c73f9beeb5981e2d37ab2d041d616f275b50d9403ef57e2afecd13acd63ec1e86bf178bff1ebeb1c32e133bbf7981ee48a5314508443e062c5416e13976d95855f773b1342efb5b28d7191eca3a685e29312edd8bbc346574f018c7d9d360738567e934418714e0b66016e5477764335bb9fbff86a8962e34edab7c2fc97592073049c4da5f1d8604c2dc3cd0c854a175d37740e11a4b05c7ca592b670198f745437ecb00376892629d7b8915fe3bfbf94f2ae1f16e1ef8fe74b56969cdb1f8473a34fa97b40e3d3a9606439ed5a816234a05d4a98a86ce9080831130c4bd94660e10d278a9e8d9b4cc818d63d49696c3a00e9ed10540d4713491b4ef2e86be7e228b493c3968018ba5c12aac36ae08f5a3f4ad3dedb325456f6f6ede94a2f6a47ea2a672dff984820dfb8231b743181c84c78bfeb8e3af08a0ce54bdd36f877c38c2fc9eee55607edb6337c150becdd23eae0b93b04dc5621fb635cce8ca7b4865f865841cf3cb27911d1095ec48c3ffd4814fd39ddfa354c671a3030e05e86c52ab2144b153a805ba7ff0e5c16867bd6f7551c6e5c1a94087276ec381a6e94efe1d76ca4d050635259fdf0c312fe4d2502d08542f5ff4f67f8ddd43109ce471e2fd785df0aa031dc34ef57ee9022a85c8e7af432259aa3dc06bebec578705d901f051db8912e38536f6dd0612030ff65307b9af6b2ed23bb067988874f491fbcfb23a0da0731e6da15a635c31b36fdf71f4898d21988178b7d370e364f98401350f96e7b08202cb45f12b164a5fc17e6b39142c5526bc2a1c70f1ca7a2eb570e7d1bdc3d1d88f61c47835c530b82be5326c91297f2615a16fc9c5bfda4008f0dd61d6ac6101dc5cccb059137870f5db6f99bca968a4190e8b21e416d7d13c20b1af9182989089d4248feb24899dba596c77070c06784b7b48e049d98c03455ecb057d911ef08d1a200f2b14d41117dddc16a12d9bf3396c3c547c8d843537d775c6b07ccd818561b66382c758afaa193913b689a6b387f119ed35b3fb70a529eda424252a26932913b548810ab201211a3b8af83403c5d8394d1f89660ec3ea5fb235721c4260fe3cc7a1f24952ca1c56b1eabf152ea48a657a1796bc9d549e6384f9c37e194a1bc36ce831a18abcff257fc2e261635eaced141d6e3a385f1c933a4bb6516742d1b84bf7ee476fe3d33d15f6cac7c0f5a2290ea3a050d7b131c08dab65d7b4c8a33ca3ab69437189b9cd5ae449cde71d265f808b45d13ae73a4771c5d1830dde6184c3abe03f53191ab84c84d84e84f161ee60dce69f44861fa96b68c4afaac8cec05b786db17a08a08eab19fa60872e249c951576e2f54a7d19571437c00dfd38fa8c38b6aa89adb82e231d7fe3ae818a4da7592bac3ea0e7243c0a0a1703c5d1ae513d0778e65c1c666cafe79d6f51b6d73de97288528a65c5949d2960b6a8ec7478fa3101f310dd71e4cdc558eef4197cd2d779e7179dccdfcda47ba20daf92842b18d46ce3bca1bd4ceca43048e1a1d94da2a23420e4470e10479ecba933e35e9e8644710fb5885cd5cb425d24e72c5836afc25ae33a07ebd617da7b7b6371a3fa50af9dd88415b1c38fc44b3f0008cf89ab9f20a19454efedc3d125bf0fc1944dbcd725f7ad0aab8404d1aef90e8dee23cb9ab1c236b0a3c70e7fd11e6fb4f1cf87c25e2959c392af3e91313f9b406832893ee107d292d132bc2d11608b55da4f758e4ef899a8903e4cd70ff823567203c6b9cf706afe2ee33e3691bffbe2fda2a3d18ef27d9929ddd24b23783b16eb329024e2b92ff75b0796e7d0b9c97e7ff346ca43452af6d66ba3ea49d331452aa2cfc79a9b7d99360a771ec5f8fdca9675a817db18db06baffb0320243c8f8f762fcb3409e7ae4fda43e67c4844433c52c7df0151eb2c4ff0b2d2fb5f903415698c552659dbf67287675ff126b25995e3dcd08eb48aa783b503bcc20bc70f781aa34f7ec6de2016ece8dffbd99c3dc13f80e75aef31b73d110440427d2b8e01bb320bb3dab4e2853f645d0533a00199e49aef1fd79a198897331531fb825308a898ceefd69c819a202377f602654627211d2dd86ebfa809de5cfcc89040acc12c93a1e86d2ebc00e0e957f50cb8c1b03311f21264f4ad9664498dc2a7b257cb56c6e4f477c31b4202018d985625f7c0aeb47064acfd696041655e31e834fb5e405b0251583310a0dbe034846c90e515e97aa1513cba9287efd14d4a377a4ca7da091ed32c37313a39735c4e43da7e56c06475f39653c914c7c11a274d9661f73cc526cc90f50c226429b63d1461e299dcca2880cffdcf94bcd26f81fb943ef3937fd6e99e7161c8a0d48e25759996c98f10d4373b1c411acab153d1568ad9f5218f4a34e0478ca7cb375923305fabce980463dfa4693f409195af1a913e2ed4270e9f1401167a3b9dd3f08e0c484a1125728bc1ea1bd9f280323ec660631bdbd6d8992d082d5117b1f6db9e6374fcfd017e81d3cb29568b099acae8d76c9f755d345f50329dfc52a4ace7a352b5337d6ff7c44aadf54f9ea9fdebd8bb4df8584aee60574caf65a267cbb55ce0804a9591a2c4069feb47b6d6029a0033cef665e45aea40f717ab2819cf39990c3987ea55eb138ecb6fd411b415a3409324dd08b10c9308c8b2b6454b793293252fc74ae767b771b911d959f3608796f3e8cd72813b0a76772ef3ca98f74714c03572addcf47923797981818579e6cdf4be03b258d3c13afbe3cbc2a89d12ab06ed7f1b52359abce2afbefb7c884b442669a9a83b403ee7420bfdf9da7b9b5a02f22b5128de8a000802754ba9332bc9beae448360c3f17aaab1fc75e729cefe0a71a30d984d0e9ebc6049f35832d27e67d70ebae16181e455bca45ea910930bbe0f57549b887cefd790c5ff6623fdf99e6c0372531cc987d1c22b7bac47e439460b54cc7222f72a2e5ca5927dcfee22884863cdfdc29c789c516de3942cd3db12dddaa7bac9f53ba298246676560dac1f57498ebdb9c3428ade8fc9fd1b64717fcc7f3ff5422feb0962f9ab4a84f1d749cd7a46c5194c81b43f518cba743baf0c78f8ec64e1c1b095591d52e3269dff9d4c88f39c081a45814ffd11afc37d8979515dd8b51b47cdf1377ec067bd64fde698417e39d47a27089eb86b5e09c836370075d373902937992d8ab1daadc5c38457388af4df30c504f21c463ecdbfa09375c94cecccb1c9a466af1ac9bc5dcf4bac1c392b0dce080a061dc190657d4787a67f47190af886674ee4210ad2ca472caf273d90768d85606f3c976725a98e61bbb7b5d44d2dea13ba947efcb0f9d96006ef96198989155868683058efaa9867f1cb84382f9d4f2f46b1e860752104d9f334c03cd5cc52a08b6f342e7d2cfe053184bee7c751ab2d888658c396108f72b94157f2d0bd0e198ca8d07f9c6cf214672f0ae22b24f8247c686610230d456d586d639c2d7472d1d40fbccbcd0c15c449ec2eb9e2c3e256797c1a69937e90df8bac05766344ee338e5727d7c32414d66a81a6a6a5842af7f803d839f6131272d873b11f12be82ab4383051b1993580605476120d020e679b25c669f7c1d60980951bdd3ef0f84bd686f4ead7b36c2b3405e077c459eaad3123331730d870188bd49191d3fe67580dc1bdaf7ff9702f723485ab7c36e5230e8f007dd6b553319bf0df17da3f8ed2613227080b8ab6fc8cc839135b1a33c3b56183a879440b84b8e9759b49c6afa3d78a092811bb590bf7a72b32100bd579de6b84761fbfdd726cf32d0ca383a0cd8169eda76fb937b8dd8fc6d049c9173d8c1bf8d080150be08b346fcf5e2ac727986f963b490eb80f9f64e0fee9a84930086fabd6818c46b53135292db606d30ce9caa682c95b7c6eec2d14d74c0a650f034d280d0dfd3680bf220ed29cc4609b3a4073c3db2f4a3b91f7d5a3c67c420dcec966eab301cd2d07ae6d11e57bf0201c58ff619047138bccc470680933ca15ea7b7da9545340ed496953059d4b13140de235d1ddee06ec8273cc297a68fabaa0a8e1261018567934d0c16f5595164f5243f63a846cfd603c53d23a28db610091c9c198dbff5149a36f87d40636aa3611667b9d1b8f93c15bdab9ce886078ffbf52f6ad0f16c1bb97fb96d96841acf812fdfc0f1ea5eff5b943d82a4c00fb772f7d14eeee883204e7ec3f6b8b47bfa2568ff2bde0652d3801fd64842bcaf422b8212f92a2730d648a461b154464f0bafda7e91545f5cd905e35465a670285716b22ebe35b2c9da34e177da564f828a096fa2cfea5ef75ecd60033fb2491c6ab32a957e635f93d8f4ed750c1c95d891a5fa2e66a32ca9ead6bc01d54d62bec11806698a0ab30f7fc692cc7066afbd77c3e0da47f44a8561593a2616b53578a571cb44ac5c0d42eb2fbd9a864631f8cf4de7920272d02fc3fbea5f2e63e368fa9c36a979ef69e2c73649bb5a79bf4dde85f9c166e1fe0d39eb8131fe6da61c5a7aecc652e8a459c2efc2b4c56e11ed89955a35293955f843c427e732a374c40b6309c1b179c0c746bff46ec81ca91d9724e96c0ea1ed4d3b3e70496e5849cebfb53870b0913a97b14588a93c084d2c98a8bbceb14c5f94667de925f96143c284b00ca64e54a34c65395e5db02bf84361ceb38538d5b2ce5bfaa12b1f7a2de3a279f31a12de212d91d783829a7687666c1f0f52dd88a7b89f2aec751c87f95a13c959631d38ca9f368976ca466fd5e1c40564978f464757ad4755a85c40fd24522ca1667cdf75489f798a419649060d0489c1f784ef138073b459c0ee59208c16702e546bd8312243f596bc1a2238fdd308dbebfb481ee882965275434ed7476f39b805665e20f4ddccdfb28848417b88195992bef5bf94cd4ab560f7a38ac15afa610444ac53f3da974c767a24efdaf76b63c89d5a810164096e8bcc40e5cf39a129db397bf924cb8969f6685d0007c405f69517ad2b700c6089a03d44b9a819d8e6c9593c76925f16c9661a67bcfc64f199db86e404d198963ae15ff0f4d6cc21ff16ad70d13fc585380b2f1f390434644baa7e7b3c6a3e2e6317856c39c2056f2add97f096811eca2fb41b961d9d342ad1a50a0ac7b1eb65247cef30b2f64e99f2df62122bcda3d1d23e83c4be2ec73cceb7518fea08e42c09607861200d5a3a0372c859d3b362930b3fe4e7e39a6755abaee5069ea3693b3ffc0887f34a7049ad72a7dafffc7ed76f824146680dc778cf64bd05e846c82781642afe7910d04eb5c608174086e996e4ad678b096cc41ec954cfd142da4ba6ebe9bdde976fe3b071c420f52a379c1343201e2647d03759d7af8fd14625d984a2ec9d3d6f578c2e969a110029f2cce8176d63aa6e249bfe5b4bf1d41715fcad43bce26c5b1ac4115ca632b1d95c6e6a04f081c5df266431c1319aacbdbca435dd6035988e700f3a0eff538b73145ffc54e88ba413d210961a0247151e22a6541a6eee2c585d300d415303050cf8131c0a6755dc3fb87c71e6849f3ee47c8ceeac7f20cad406ccb49b2a7f246992362ab6925d181167bb88e9bf5196c156a51f0135f211bd0e7b84bd4b81c081ea7769b4c97a2397cfdd391f1585a73e6504fb54509ee745fc5f506e0e4f315c28c0e57619e02552e41c4fe12df87442e23253a6c2fddde6b23b74c6c16292ba8b3aa708e26079940139e3a8042e696562e94878752b4c040db98246fd2e7b8fb95972660baad135684b0f33b786257867a7967ab0f918fde012427bfa3ba5e1f675cebc1b1ccc3a35db3cd926f603320033cd5d3b8d66b377416613953f4e2d8c961b8af3432f31249e8b00ed014a4e1aaddf3cb1e56d954eb9f6797c0b597aac51e559411da0a10fd6771300d6e4cbcffdf8ecef879e9c7516958ac86c9d2b4a6d147396101414820995832365b901f731ddcdc9dd84fe262c08dad1bd62d999689f153445832592743d04f4735cf11cfc56c0d3ac6298c7c024eb0cb59d1f877a67e96490007af556fb8099ff4fb84045dba0aab2eafd3307dc0ef82404d1771d835c5f2059d9dc7e2601608da1226ce2a0ac0a7340a02c79be90b6a701d9eb51de010c51634d71f9ef6e01cac519a0063a7327fa6e187d60ac64c66234232a699dd5be86b3e3c6c7c89ea3a87a9451780c14b5ba93e3412087db533923a0ce3710b149bcb91e7821f1515c3180437221de784d997b71680294134ef708a709cb725161dd1d9f456c378173798e82b12b529c8f64eb5e282d481f5f1b6ce32d7aca942fef71714e1b495a03b20dde58ecaf2e5f21268b99b2c8193271ff53245d95e1381492536438cbf9e1888be194f6490a81e9c09c1d8b5833317dd1a7bc758452f8f8c4d911e22f85b6638289902821452743c175724e31462352a56ebf365542040878921172446b128792eac4e211f55bd25bc5834b0cca518d4286129442e3c16d46c91848dafe0754618aa26dbd439bc66faf0cf77badf50ebd3dbd4dccd7efc310e3d183b813e4eba455f04ac22778cc36b8313d7316ee8b57be2fdcb8d0f5739031a667ffb1d38d9c0edacdc6c5f980e7d8d255589fcc6a1c26c9801ae1bcbbcee102afb782699a8b9df5611044b7728e52135ec530cb36683ec943baa5107ea36044115086b7d1401feb60fd7d52b5f233f1c18c12b8706c6f3e20c3991bf1bc845e822019bb031d910068d5da33704fb5b83fb392989a35b86c2f8721d18fbae9be3e9eb79314a7e3431474947af5cdf9ddb1a584436e975513a8b7be8ae676e0eeb8eec02b886cdf5b006f54b3ddbbeb32f3d63682d8becb9b4b40883ca4f8bc5545c1ef58a202e842ca76a3796f7708684925b4dd834763547e8f670e6ada326e0bb95c1f7656c127b32734a6c6b3d0270e7122b22fdee377af3771859f73c88bcca7df4e4190f29ff7b61c5fc9eda845f5d15405bc008dd006b8b0c8dbf52dce2a3ecfa3a8027740535de1f9170bbe455d04398e163c9063b4540207d0f6c4d91fe5fbcaeb7b01977e2a0769c61ae11978bba7693f84bd8e95c2d0e30b43e488cee20bb328afc2aed4931d61e23173c001ef4ec8b4e7f44335c3467c10c6f4b4484b1cd78b4ac2ba24b41aa43e64da22595616d89268fc043c3413fd98b7d65c97ff789820cf041de34a77726bd046bfefbde75bb65ef61953535959d9117449a51d4a0672b1e7133d21287942a2c276f2e00c6f4a3c65713769c4ad0a932bcad0c1678f1e3608b3afac81779867424260a0f063c3876017ea39223df5c9835546c9b00128c45275c15c3c7991220a124a26e9acd87cf99f94d941aa8202bc091811879733c5b947c8fc6d1e43f974720f12192db2ec012126cbbdc48dccccfea0fc0d920fbe1c41435a1dab618437a04f07b0070cc66fde0bbd21267f9e17ea77dda0dfc8d3841c06144fef06c1e45964c2962c6b3977822179421156d071739ed3257807a748a1c690e26d941cc23e0124da05b4ca047037cf49721a0c66871c7c8544f02a1eb5aadf3d55bfb573c6b47a60d8fa4139a3b77859c7157b481eb35941f1e5f6b640f86e5355760f3541d4df3528c034ca59bccb29a1103a4c9d5ebac7a45970deb1f14e8ed18ab78556e6fd3594f60e5e0e9164a61604d3e0324473231f261c1caff537488cf5ca1f2cbf408f013cf5bfabc17741aea76415a8a0a7e4f92f13dd6abdf8b3f01d57605236a631d0f3551c28bda7a8e919c7410f2a027c114177f8f0506a7d3e0c0c9dcef90137f2068d1988cbaa3c047717284f57ac0e35e4fe37459fb03e67bf84c5bd1449ac63e803aa9495b13e2feb1cdc927db2a4ab25793c668023db2f2156fd4c53b2f3143aa78a9e61ff67a5fe1a62d7870b209afd21bc12ff106558bd5b4163082420db28057525eee1b6146fe59d35fdca9bfacbcadc5e95526422396fd8e878cd8267ddda763d5088ba47087163a0d369bf0582bd4d4ad8f25e245d7af3f6c1aada5e918e1e297910a999445f7154e87f27d494dba58e707bf855d2872f2402d763772056c95ff2f20193480e238b15a789249f46e7dac49d357c55e22a0e8cc51209ef6d93346e7db7d151e5a36caa1290848f79003dc9c3911cbd73b5f494ef6cfdc3fac03ce0a38243adfefdb447456f42af123bf23b010180e03efddda9135508aa2f4c06ac8bfdedd0402cd61b3d575fdf522e84d3bf1f3f3eb804e798f9debd084f09c447e81f1faa831dc98541d99c7a8c57cd8227bb23f89e6438460e9c18684c39dd75770a90521f0f9eadec3578b1487f6a8a066914cc8c0c6deaf48411b9cb0f6a83883c92bb053eecdd7a1aa99eee092e165f7068a7bcd10cebde10e1d1fd9e51254fe7fda41e902cc389bf24c99a788e86c8c82586e6dd424ecd681eaf2e85bf65eb3db789f753f0c83f0c5214aa12ce9ba3acbad9e0d30a436e44715008ef6f15dc12d9c856fa55d116b602a269dfe3d16b2ff4928fcbc7bca2dfb9523a14177afd9b184d1ecd734ba9f8fbea3b2a51bc6819b68c21a662b281349e7202ef8685e2be43b2b50904ef5acb0f6ba41072244b2fde4a93dd6c25692fef12c6ee6d0db78abc7366b44fbb709bc29289a3362603c565d4803e9a4eed6dd64941c0a1d9395ffe675678b7350e7d79abb98f606faaf869b2493d09d01284af63bda894041179dd1ebea3f934e4ad90f6c8b70bb845b6aa5158f309ca6ce631d64d3b3e55871b11fc6b1270c0ba60e653fef38d50d2a005c39aa50d9231538824f36205c099637858b48e877c196ab5152aedf5afbbaf547f0e03084cb0ba572e6921aa19aaab3bc5c6a9505046bb321deccd0f3e9fed3648bce4937c8f4b07790a2f4d9dd30d60acfc1f504af603a0e549cf10e53b93eaf2de518dc284de84d94add7da390ca6d16bffec6aebe3ae4d29b6a4a4f938f95804fe50ce6000badd43e4703ed8b7868b1aec0025df5f2f4d77d83e9f0d178629becf57d426eaf77337b58e2fdb97d6423e97002b0721aff1a599c1d64ca946527efe7032cf471682d8c6610d06105bd1a73ff0b1f0ee528c90e4a24d2c7b57c66fbd5d66f1f27f8eb519016fc9f8df226e57c3bd1aef69585bd0ade26a875bb2ad24e18999cee94204ed4b788d2458d548319ff4933451871341f2ed833aa4cf0647446c4e167bba5d246f92cae601eb7697c766b6776e128257cae5cbb4bccacbbf6e2bcf5f9c8bbbc7446deab30a024ee70971494fa427c2626ee8416ebb0b45855707d5d11120bbf3c7c5692e57e8b7b5a9e5f3f9a83d4191e46193c4e9acd0e6dc55485c7001d50a233171df65eaad6b5bcddb355bf91f30f47dec955fd27842cee551710f194872acb72fd07d1874c54547a8f8e96c8d9026b11a618caa9bbb76de9d138d62c4de23a4234420ef9a23cafc43d4e36fe31ef319205ea841618238cb8b5a93e052c4544f7dde25a2865673acb69db69bcb7615afdbfbc1359a71133c6acd33922c39847bb9aed39c0a29514e7a03b8b43d041b2c73ccc04148ae693d57591a5721e506570905c377ca388b38fb65a949cbf8d061085f12476ea52c0afe3ce671ef80f20b24b4c9b72908ab07ee728145859605d0f7459b5d4cdc27b7fbb57839362a97eb3ba6f12ad975ce56478ea22142c04f6ce02e67ad17e8fef01891d4289ff3d1c47ada9e18557528645b016f3e7e17458b5d18d5333975485ae19c78cc82ca96e3043ac251a01eb94db78a64c403b815b3c2749829f5d8210491089fef0f230ea78153ee334ee5f86a5f4f479556e525835fdb3b38d77ce96c898219923b28261a446eab19ef0c1b9a4d45c3a6cd3e82e821a3e8725cab00002fa842e019e030504b266498b6ce74e8f9557f2ff6ef7780c740b8ab9d377544936b0cf7178ccf420f81eea3bcbd44153b037164369799fa414def879f39cd561124511e32b0d507c4fc14af007d8d81d044eebfe1bfc48d92f1319ffdbc80d9a4e3a26c293c88d85741d583621f6948bd6764c4653f1c812fb110ac1e5504ba923851f3a33761a73ab16347725488012dfc454d5f0e57e3210cc42c58a9dbbe4a09c6073f1348eb0d5bf57f9ca3c932070a42d310f243635af3d8233f6d7fbe737aa14226c5b4697b3f98ff059d6ada09e36ec0fd2d640aaf2ab526bdaa5dd8354a1f45b4981a2dd8ea48957e05a7e1670d41e8a136b8b3db5d9f17729d05228078b6034296ff6fe87ac65ba2d6c7ccd326f67eae460e20aedb44fe24f2e03c33e473cab2d82719d5f04d86543bee5541339879c129ce244133d8e929b0a6969699158a377a0136a3720478a94dd594b444a87f9ec2cec5beddb0eddbd2e4f323d51a3b53b3db4424fc16afe89776101a9a26156853e425edc2cf05e92805f7f86280aa7856e2413b62876bc9d3f445ecfc4358e74d9b8544ccb11b0aeed2d0ae14fb3715035b75be62d4903b6dcc206a900ac6de62d3db3c7f178657cfba3703e961e8b31908d171ccf6082eaf6d1434a1ff3f4cccc45ed7e8672f07f86c52ba70145bc474c05dcfd06704c6cee1dcce0933d93acc06d0461895dc2988eccf55002188d0365efe81fdf42a40b4e3d948fd066978f7cdc879dddb9393a3b205be96b1cf1056f4b9a2b2c66a15eb1d58e9e05b2fbed61b35bca5b192b4804f80382570c96e2394e3c3a61bf60cbe223fca1f3c20346a991ead416e64145e7485d390838dc8aa4856325227825ecf9fddb77fb7d60cc6154d88d3a859ea7853ace5ee410feb32808d20e4eccf00559a53413f88bcaac15f656e6445127a54d2c383b0fe3737480d879d8458e95c0d451adbe8f47f546a4a5ee003a62ae11293bc4b40018c4ecf747b59f52808abaffac2b9f9dc68d4ad0af8ed841fa8510b9a59794193e4effd4aee9c1a85ee29540a3f53bc968842bd34f6c9ac777622f4c6c8f0aef73990cd55e13fbf46faf4f8143844dc04110e4227c6e0c8f11d9d4241c4977884a0bbb672ae022085b11752aa024f2a4698255662562a62e3b6b9a18f4a846109d7af31768886360bfb0ba4abcc476dee1dd4cecc8bd21ab33ba39e89d5c5f802405a3b7a388f75a93ca391b6c8d6322dc1674f8dc8f3a653f91e35cf3465432e28a202b569eef57466fcaf89a423d843572addf711ddb44f75825b4281bfaa66350e2d37ba6cec89162f053937532c42a76f12ebb6bad4afe1726032233bd292911def739cfc8da4fb118aa9da875cbcdca9406e3dd9d93f200d95e276eda21f532299448af617b014247e724174cb204c90a46ab5e9923aa2bef802f01fec4d2df4f82e39c2a1c9b7323d81234193b2c1893b3dfc6222b519cbcccfe7a3326cbdde2e810826ecd4400b27fce61d08c309b53ca6151250abc74d665131da4674a23b9f3310d0670c94666fd48b062e918ba8a8912b54d42a87255be0707788131efe0fef15c7fb42a8b46924374b8f8061e8ea900534d0fa0171657433e933afbdc6b9767ede67560ed216bd4492354d521fec8f7f60d68c9699ab95d62d2c915d7d12151a394421cdc553f7772859e934a8a6dd601bccb2e1655aa1a886b33bda150f41ad13599d10ba167980fef19a1a92f79549feaf1208e0078cb1aa2e0d6a0148920df52bcd2a937d1556ade8c7b2998c755303dea8163c9f69a96d4ebdd77e7707db94b23edfa62a7a8cafded4e6759f95d3d2aa8c8b43ba2f9b1d6683056b60bcefb4bf0efd66ba8e76c2036d631cb2800a6e15b9d4377aec0354673c6c8d5066930f68f1f2047f7ff2cded758e492caed11ae6db25aba01aa29dd86612790384a24aa8b2c94c3e589cce483e7e9f0d9295bee418bd0eae229fcdf6d5314ebd4b5f57073dd4ee2057e2f32af190cedc7f66fc5debc49418002a392f044fefa127d36eeb4faec8d2f185eb43c71acdaf5c9fc628f2019bf7ad6459df6fc4890e6c0a8d739e23803abfc052169f72b37e5c2e31baafd70e0e82826f0b1c4132e618537afc07463b2c2e72ac3c270e5143e539b5d0091054e8f0941ac9c1d207fd086e33925329ae9e5e99b5eb00fcc6c0afb282fb6c8b89f203c416e03280e0249406b92fd15da186b260b5b8cb2a4d5f34bf2558acee0591cde3955e730043f7190fc822665c1cadccd08262904c9503693f8e4b4e7225026ee75351bdba4010a0d6ac9f0da7db3cb47493a821f4ab1b3089f787ae74e93d130a0392f77acad67f8371fb45bf7ba7758132391b8dff83bfb0ca3c9eccd31e3f2236fff316b07a063955f4e5414e0b0e32bbf63a919a6e49fa3f064596a1e082a3a7c05d5b11a9fe06af4ea48a14c668adcb091e08c55dc6a62a1a38506fedf695ec83d03c3347ca89b8afa52d4306caa7c40ca79a1b9ede65b3bd9c712fcdef4089c0798d59f7a59c0d62945fdada80ab74287836760b19dd8c6bc1b5914c87ab1d5263407921c416dbea38b35070faee7f2401164df196159d9abe925811fa5f1731b0ac669d46eb37e52a396a53c09f9651bb9232f97e2a75ec4587369f588d7708a75cea47bedddccfde7334731592ba402614f1ebba7019c26e9cead6aca8c9520d6605804dafa73ce1632a7e58dc5d7b4ab8e6ba8f9d92fc51943ac41fd21c627a4dac166121bb1309797e32e794183e704e43958672b9901afb25f62d2d36ea31831d26829c2661e8fa14b7c6fd24a2d28d81fa0624994181b7de3be30a9eff670a3e3f48fc4beb14bedc9926ad591415f8cfc458a0d4bf025a1466fccb8a6c1398cdf6661c9e1660b97a65fa48ecbc7e493321cd8cb78f095b45ce236481949de123c8ec29f9b9e2550040cf113168d762a736590da077db996cefe9453d4c589d63b07157a85509404ddfc4f3cae5eb5f982b01f28371f849c6deaf21972cb8cb73d5d4ba72e9725c59a02fdab8900682014bb970b341e170308fdaf4c6e09d1e2879595140b45763708a4da7dac1fe593db28d663130590b3ed6a3a049061383b32aa7aec8d266cff99169e4bc3ec3fbddccea6278aa44154ba37a4687deb74e34a9aea4738e1fcc6fee390b78680fb161ca79f472dfd544291e742b5be53c823728915ed9045f57971ad1cfa7632ab0435b8da2b38af974171bf479ea1725a164e69f06bce6c2993c69651ae2e352ef3c97c26fd19eed765582115c9d2dac5fd6718aeb4e42ae2c3f9da6cf4099b89e0031a0bebaf4c6e1b0c39733870e632a0da11de18e6e3a38f5b54db32963ac9ae417fd559c6d606a4fa33c942be827e8c6001bde9fe165a87719334079b352cd377742ac61fe334cbe32d0f39604da719996c67a3bb320628fae459158785e8a84585719d2c32371c8a49c0074f550edfdf30319f8525dedb6b7f611d884f9b47409cdaabfafaf20b79c34d4aa807e457ddb047bac90c45839888f0afa94f7bbd7f1c88610c65f39567d5fd4aed6fa90dac9396545dd5e5ff2c3a071930e06bd792778788350df9008232e536674097ccaad0532f358a7ac8a5a8d54d3fd0e995d01eb02596856325e91452afa7b338d78c59813c25ecc1936a4b114095cd49a0faa8f008030041c5a2536e412a53597dd290edd26e610a7b85a2ae2de8493d9a6459ac9dc586c9e45eafa231a28ff9f7c769a9cd3a0d64da80ef8b73d92a051add635e807d7a626f517556e39fb877dd32c6049400b45186b1cbd6b9ff15726bd2171c4176be5623df4bc7af9a6842ab14b57ea5d7d86c714a9ad325f5b31f01a66058d0f49b52d5073de86edb7acca98bc4d23db0919e6190466ec5590d605b4ea55be2e6243819bc16f4a818b71d05ddd667c83f4a46005229a2bf25210ce1d3c9911d491e8bdeab2b649e3ca922c9f628c906b930e9bccfd405f69fa62ca591bac0b506008057be82ab0bbbf7f512f4155fd7db2d51dee4ebbab509cff2addee704257f403ab52600471ce44a49aa8b196a8018dd3b238117a38bd5f0590a840ce9b0d0754e29fd1fc4ad0b5f8da4337d1d07ea8c4518c2301313ed2057a4e0da0d8361192b6aa07ae0b2374f48b5bb27eb8d9b457523d18182a6a09992282ed86ecf022b1b957761b27ee43b3a6904266dec4825a622c7cf4087b03655b36c74d216cc091e4c28525bd1948bfe509c218a6a10d47fd80e34eb60a1659c32b2c78ed2ea2cd1ab81eee1f10d3fade95b436aec562f2ce68f5d460cd467e397b2e9e6aa4f5853bafcd774368d46f91edbd4f85e234e0c01b1a3f21d9a2e1ac4385fc1a4a0106d056871ff01ae899416c0f7fac17c0351c5e88727525f950947f13e27c33be8fb2bb7482b6e67eb56c9dc5412b021bfe9da870b7cf3ba5c19ba252dab47c07942062a14e1d533f4244bd47aa82564a6b4bcae446bddfbd954fbebe42425ba679507bcab1bd72e7570ebc20b8f0cbf8827fad281696c18001bb216f80fb88e69e9d25ae85ab8a71fa6f4c1f37d36dcd564dd318295f12bf7ecfa3fd93bf798dfa03f3b40f9c544f081f3c02aff790c0da18931fc5b23761217e8f73d8b397dfd4d5537343951aee389e1a0f5794a509298b1ec65e63148b72d33ac0e4b950f2a91db7eb12368c9a02820fbf64a3d9487b749d63aabf6e8bf2b9ff17ac4a709cc418b48dcd0d05f1f137ca86794ee28a128e8adcb2fd18df448b9e9b6d8ce96f6a2a3061275884c8ad11f74aab8c0bc919af93e36bb540a9bc6c1ed44eb80f0f7b952a49dee1a5cb7e85f4621936dd1690aff4c3896e449351fd6c13af7c62660e103345308521ce8e5709469b22a90448b2531ebfbf6421c1a7bee8587fa5e0eb2bdb31d75588cb37cad6a79f9cc7f1a3c6bfa8205ee3faf4e35d317a6f0689468f01806c7b4cf6215833b4871421f70c7203c80236c07c4c9181525fd5a09cf2af44272d4fc775c638560496219c34934277e87d81f9e139d0c9e9d300efbc508dd2eab3adae6dc399a7891069655b028cfcd1e97796574c9da302ad07488c529fa00c8832871cb10bf3f4f6c8f59020f61e5952a79a91405ef120c9ca715b9a528c9ebf59ed5869fa12c4688f7390b002ed67e4530c6ba9d4804a1ce295891174fd875cc75b29ab7284fd19b4ae491bb4ff42ebc022e3afae224eae445856d9743fc5fba28d417d3d2ddb70e263d9b82abc10b2bbe09a279c5e82a653d6f588460675d552d1212725b6907bf295452dad1ed8630c9b7073f347606b1b7fa52f20ec159a842b62aff587676cf300cae2065e6c2a23de6943692acad85b8dcc508c4e57f9f30963938ec6d9054dea6b5f6f1421778f2d83c63114a92bb242d872abe78d6a48de5ee6101702f197473cd03d20a6b83ce0f0fa8f62a890eed425777600c581b5bdbb83bda434feca93b6d15ed8a4b902a98ca0ddf7f67f13a8734d34e613cd05b66504b1ce62e8e6025534629d1adaa29f3b3eee05e2cfe1e446e19397545d63adfb0705871ac362482c437b8527ab75e83418875d3a41d74b816fe7798f279b7edef699351de95e1fe43b7a4c0d397c0c7b1dccbcc950a098947438aba6118a1744f11bb1fabb9def72de82a1c7d5af1e6ad7eed4004ee70713f87b15b77988bd6c85c97897b96e75776ffb4bc72a4f27b9f35232452cc465b814702360c5a8f7c33027154b0391d6d794af8ace2df7aad0e5174c5716828cb44a5fb51c6cfbccfb170c0edfae26a3fb5bc309dc332b80ae1564b49093ebe61c1bfad00022ef4864dee36175d1dcc2598d6039e9108e149713ffcfe7ee58ee92eaef56efb9df17302c90caba4c39eabc7ee779935a24b87fcd648c15f27ea04de96b83f4310b570d467bc394e390ed3bb99afb32e1049f301a6c37db75980406736f4bd4389ab6760b2e1094b89eb7ea6176386a6625abb566ad5cfbc0892bdca080fa46e612feefc9f15db360e0700860dd87dc72043bc62a9b15e1fe9ab69a509b80b8b7e6fe282983007a631b2a536efdac96cc777857822102e77d707baa08e89eef56ab9a8db44198dcd2f9dcf86f4ff090c05403c79ad2f4890d9dedcd1b7beb8b9af501f3e91cadf1d6849b087ea7e6f291d14178b8072ee9915f348a4ad63fc4cfe6db290b9d7c4a5065d56c67731e2d3b71604d1d267d84eb481b02a090d224ba7c6a830e646881dc9378e33ced4b2ae0cc181536f1e3aabc4f5faafcafc44b25e79b09eb67b78b4d4105ba77be4e519d923a45cb47049d11c94f999b2872d7bfa026ec6d82ffce2b8800ac93d55b66818a652e7d45a17c8f9afc0e1803b3f4c96b1585faea50beadad600ff962eed957de3f6f4a1d28f0f910863414ced75db230fa35ddfbc4a693231b3b9eff7cba1e27072bcbfe215623cee2f126716f0a5545c10e091d5f460a9020cabe0495dfef82dd81e565d6dca6dec79f5e889e68db0592be5ee0741334064a67e95867c0f12eebc483ff92969a349d6ba0bebd5bb03f2523424417e3ed573a5248bc538e51f8aa6037daae0c3108242a40781b2e7873c0fe821c4ae07109fc26d0e4d0de58052583c3f52353d5674b0614558f1c8f7f30a584be6ce21f61d17818358214358bab28fead6acae8e602d317742f90ee5ae6bd6d4d277be349c884d276dd0a9d1922997213e35d234a736c863a7df03e6746268c2bab1a8242f58488cfef25ee5c096c6e1be0f10230b3183fd0a505b0643e68a1093d35c1174d54b6b1535cc3aad03061d55efcc914d7392ae6a010cd73dbbfb6b93e36b123ad2e8bae3ed7d412e273a0f007e27f1664674962c92545ece02b6cfbb65d1afc4c011b7f2eebfe3206759a98a589cb5a4948c19ba50a2a8fa318b59a23635217be5e9e05c9a6b5814869250c41997b0374858f54eb96a71503b308f44e0b3bb23447a2754a0928a314b5e8726453d99e2fde8d865786dc55302147e812f34c11732796bcc22e8f88128ca6793a05644b0a5c4bdf94992d4f7df69e5e74e14f0bc1e5bb0888cb18b044562b3f270e8668a5bda2aa66043609b7a29e528909617f6323741133692f3609e7592d0a888421901d587722aebd66e3283a0d19b4f0a8218913ddee563b3d115ef6b1d8628be4095121cdcb06b648cab3aadc142a9b220cbe85efd1c59a18f077369be0f1ec2ef9fb2fbf7c0c02f23d1de35e383bea70d7d8c7404d549b35693875ab532ee0b5e4f49ad14e11f4288f1f74beec09c5ac95f9ccf08de96b05b48effea90e8985338a004b212f90a27b96e826b0f7461fcad1c83df9270d64f836be4ba65d27b905d263d93260fecbb755699e48667a67e8d4bf276e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
