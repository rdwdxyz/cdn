<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0b656bce0fb3483e6cbd25b3d1d43ae57d6ae136c89d6f88dcc3c6998fb412f05472d217c8cf8e20c05a0abc9ee317c5bc31e59a03eee9e3f976c059dc22f3b5910f26f5ad247896e567cee9e307a9890a875cdb91e7be4ea5131c8d3f5533f4a848d461275f69b7dbeebf7803e59eb32f9b72cee0dda61f68e12acab74f97d643702e770e06afe54f6a14439e3357c4a3fdb7a1c0a2e581931cb64ba72d87e1677d6bafbf803ea26ad885bb8fca9a1c26ee39815ef9e4ec612e044b5e835265062acaa9ee1010e5b1c85bf52c6fc0c90df0aaddbd5a453784233dd38c0e3caddba0d6db3d8b0df99ce8cc157cd58c4788d102cbe732836f6f7d2219781a518a213940ff558a1e264d8a4e085cdfd94879a45604d33f2e18a91953d9d406a3e2449982066aa77cad5e08ca31979949c756a023a87267c11dae1d4c53d651b0e724b9bd04614029c9dcf25416bb5d8649cba57117b9ff535a68d9088febbd831970b5b8f95f3a6c3241f9dfbfaa68bb5fa18ab5cf762e13cb5908a71b38863dd597c7d9b144a0647a6a0d5289fd6526b73d1a7bd2a2a15d08f4a614b379b6ec2d36cc9c7d5193520ee9ffb39740f69b39adae251956bbeda60a2f4984131fb247e250d9344ac4d4c6cc0a42d3ca1051589fab5745b35f9e92d2f6e265fa86c021ba7b3a4c740ef54ca80292cd05c2fb0b45ebb60546df55ed67970114e1e59b4a413198d34cbecd48a62d745805703065b1e63fee6ea511d079b26df9dd027587863883987504c77dee5746c6ab1a476c423cbd868586970f5197983f716fce3eaef65f35c4aa2ea317c5b948408ab257168de0f8f55cde32e4ed87764878a72a5d5cb79d06bca395cee7c573aa77952f043658c640d1e3b2a4603b204cef74567c3821719316dcd56e05531dec32b033c3317cf7a4ff8444a0fa4046f266c518bbf301015acc7511c9b46da0dcf937467160522d6557d92e5ba4ae636477f051aec4d9012c5752a7e19a050d4ec192a3815a005e6cad3b750dccc41d9f6c7601c39250be0ae8d52c94cc22c0e585dd300e34f71552e8975caf08bd9a33d4c04d659a8dc765d070e50d42142f8d8021bc306122fae6ad5284a961600493bedb28c1d4aaf6a12026399f0833f395b397046285096b2f5f66efce32b5e180537a8d6b9d37abaf3015819118235919cf6591c6e8763643b33ddab23b0dee324ac57b4d31197b5ab1998202f9062a4c3b2faa6100106078944e296d013a15566d4e340fc2b405879854f64fbf74d7eca67ffd0a88bd215ce54290e6440c4131b76c2b317d4f1b30f8405ee36d070b6919dbd2eb1349f56f44dc79cd1363808086be629fa035e149c758192024c2c9e76bbd7f9edcfda37f7c8c7cce2d92bd827b136b49d7e19183a9bfe3ba799141295c5b78252df487d3ced5c4dd631dd8a57172e22f9253f47bbd3cfb06bf047a67d6588e65499cc565b3b87e83e64f6fe3dc7015c17c30093fcad91b5c9639729462bab4d9aed71d22d42432c53e3c5c9d726a3769d2b0632f0bd82358589de2fc75ee380fefef9444fb733cfd3035e26362bd6ae33a8e18dfb6908c2c10244ab0101e5eb8e02329b220b644bc01fcd2ced00d491d6f12475a815fea49abd6a1d6131ff3d7b4b473eb493fe0ddcdc47ec1ca4bb94e3d017ae84243346f24712e075415a9bb4e25c6aff2bb7b3b277dfce3efa97eaa21dce0916c05a1a6b7509bed268a39677eabe718d804116ca2eec0441f489548fc3f59882a14774f3be56beda5510e17ef9b98cce2934079ca228fb2dd4dab8beb7ed13910b146e2844e02248564ec0740d92decab898e7cae6c3e336c5dda9fd872c70891b4efe0d87f88fab091087c546383a3100ec5e724fea88240dcdfc4d7e78bea650df74f1f1798bf93dd2c3bba41587e8dfd3a6e76734f89841d035a8cb675b9900811acdf60a4c3264558f372534ed22bed7c5ddbdc70dbbc276fa20015e2b3dd862d79d6b315bb54b5e39a6e7b4bcfdfba4a7fb4fe224849da6a03e5925bb8cd3ed96995dedf6d77c5106d917950c1627ddd544b400b01a1ff2150fd215d12bc2a0e610f82fe218943f5c6798a3a41ad977fc370ffca336ef13b7771da8151b2b50bd395a297d86ada4ee35e0adb25e6c6efb6fe1f0ef4751c3e0e980461561dfcf07f3282feb08005f20f9a7c203c735fef1220a2e467296cf6ed667e4111453d45f39c0ac889196f1b382e46725787dd9448dcc32040752a3c466bebafcc1733f05d0f00fbcf64155b4c13d535366ed6d454390113012419a7b0b964d9ad005ab2948fff4e433ddf458380dd41fc63733d52cdbbbee2202b99e6d67e10b237a6f1ac89bfc929ac2f0852de955abd7ddae50ab774a71db303c4310e7969ba72bcd1a808634b905bb912b820a700e46d93f00816757bea907c96dceaab4465c2c1c9900d2b401141c0ce74c55114f148a29297203934ddbd5b543ea2efd8ccd1a92ce490378fbcea01151d996f51074e0ce0cf1eb70f8b542e9467d521b7848c6d6bf37b2ddcaad9448f87e031581c303be94a7b48a89b3ab1a5bedf8794eec0820b81871aa4f1c11003f97c13228422e25781b83596bdc0c7adfe6ef36af7c4c48c3e23b03fef18271e767b007984c327782e1a941176b176ff3c940db81d494fc06462ffb0bbcd69d8677f92a7c301441471c00214882866be4d02365fc0cb4def7c311af2a924a00a25a0f708e302d193560a0022b6ec486ed63f9e8b9e994ba1567aa69770d56ae637c62ce031de71e2afa6da75a89c2aad15ce5b634364157cac1a882e629826cdf9c44bd96bae142ff24eeeef180948f1964683c4498ac1ec33be97f0feea064c9ad0d8e89e0feeb6ec07ece5f25681f42f6aeb5b1ccb4352154056d1aeb2e8b806cd055286587898f400b952b18672825bdcf181c0702f1e7d2be8cff76de666ea20c000cbc1c0a5c5526b3f0e071642aef123474a1e0df25e4f682d104afe8dfe2f5d30a066e726cbbd75e1b10aba78dd7018f332fbc0e0474b3b5249b3f5f53623259637fb1ebe293ab194ada39bdcba80ba540b7b16c98f35c6be449799b5e8c2c8c9f48d750bf027294bc7eaaad119d96d88e522e70d2b9d6ec5dd8ae2d2a9077c12aac7872849bdf38b0efec5d0c4fb8580574e0c8310576be35c4c7b80e33720527be4254585144d4151ef3095b25a6f25cd4c27fdab98e63edebf8c7c51ce525839ebf493172faf102fe80506cd51a559d7a09ad4d15313b58f27e68a93fad8f3c2486791039e4b76b9ffdeae9d7c08785ecc154e9eb6053a168b498ddf43a40b3f2ebbd8b762ebcd097392bb4b59df608695b0229aa213fbb66753558b138f5414d6047f21ef19328f1b2f24babdfa7a6e942013234d4d04bc0a1ab77d8a2d251fbc87f0d50632d90a01ac1a8988321e940d426925215612db3b73cad6e70bff92078d23930c3733cf231b34a076580dbb76ab7f69f6f04372577fc63e18097e42d2e69e7568ceb3be73cb23fecc7f8e75d15947e130163eabcb6d31113af743e4f532139b2bcc9485114280d316869b02008a1bf562d48e91d57a26139c32f31595f5eca6c78f6446d5fbbae0064e5e2e477fa52ad9a10e0e058a61fcc0c9983959f0c89b49f86e959be4b654b7b4f82813d60332bd62f8bd809f36ea38a5677e19349ced1ff1378e4d2336739fe7770bbdaa246ced38f7abdc9dd546e741fc8aec746b8a42a0232c6deb059b50b615a12516f32bf22cb596453eb6c2a6a81310c3a95db3ad5242e13060cde0dd7a9e2ca3cb5e0d474ef1bdac9655825193e0132277ab9134b9503bd51e10926fc39222e521e3d08a77b8aba7d740963e9bd9434df1e4e84693c3952f00970da71962e8ff2c07e83ce397bdc444b34a1aca705e1d08589a1b929e0b3c90812053d199374cf525bd205176db93bb3b0c2e35d54de500f12352cdec9d28d0eb6796278abc13af508c139b7c6a62ed9e482ae8636233974c300feb69e9b355b9527220d883ac08c907f6dbc0d129b1023ab5f7e2679128c437da069b4a2f4163ca8f3b879952c5e62f4e3710bbb253382dd67ff59a5e79f25f92f08e38e0ff2b4c376e2d0aa34f837acfb39f0f3d2a19bc711382e8efb8f5554fd579836ca24f22cfc274c45908e3430d8ba138b720cf8a77665c75a8a6bc648c3de269232c62262de3167b538ae6050a7a671c6870b80a1fbd9bcac6686daca21bb12f1c33607da73abfb745209f57a7184d0fe37cece86bee34791488fbf70a147dbf8ca8b49bef3da82da8ec4c8384e87ca2e1227be3141434b671bc4a0a424eb07ff19cc5982f8fe20bccf5dff02eb4cf0f7f092f051f148f91201358569b66393d373a743839e9e62eb06d033d4f4654aad4741f2cd3ec2395e17a71e48de71a00bf1f6b17dd43113bb9e6a691e43069db0a1ee568d80bb0e759b960c15f084ece41897aafd85b483b8e6f3cf6fef750f6e57d9ada3f20f3ca11096b1f0aaede71cc74bca1903163f1656eed689d4112d43d1988a41ec2471c6626371804e1d1301f344456c389500d0ea3a0c20dffbc4876fd236070f3e2b8ac2fbeb1cb6f7ab8449e980b9b643fa01671ef8392871e2f80ebda85f61b9b69cb0bba6ebca330f04882de9de1226c05d9cd8dff1d2f7e0b7f1a5d544b1bc4a5856feff57c0239e0d5ff61cdb276c88243693b6ac11725c082d1a30961e38a31ae3b60817392501ae0b4c2f9497c1c79b45049a2a789042572acce61f64d674dfd34d9f6853863575818b62c812387bfb51a5eb1fa65878ad5aaeb71efdd4c5dec46f597efa87603ec66cd04215f6cf35825499919c7a0be71bfd8ab126945a2ffc5a881e1ea1184f165c918c7f52478d4955eb72e66ac6e13518fdfdbf2db3b81acc2e38182a520eb380063c8ada1658fac2b6ce3cdebc5caa5fe6b53bb1d29d193914520871827179d81439b0b22cc109560768cbdbcaf204fe7a6f47da52e300003b2bcd531515a081b20c467aa7ff860f9c78589d52db1fec6c61d14218d32cc1ba8566c867d1a1d8bdcb42bdefb64487c76bb4d3bdcdbef7c3e09e8446b90882e01604f387fa17e71d44fcceb531f72dd9201891d895ca7fecf9cacc43e7d8a0e94ded384834bc8c762cbb7d6aff7a58115a8c3b6237aedc7637b1e51be8302dc95710c95c6aca9d417e6b88c7e889423623ca48b00846921e1a90ec64912e22e0a37e13cce621f122b2b65136075d50f5175cae64388be8cbff0baec5ee8779f689f721d7147c1e160b64c8f7f81df88ca897f8ae8bf1672430a90d1a216950e42bd7417048d8b82f8e1d499d49b24949c1a52360beca997156fada03a6cd65a0952d2a0a835133833b4376afbefa706511420e7af6db1e802ec20bc115145cfb903870f904148a6d5910a5b4e59e2823bf69af8c3f584e57b89ca1f908240d08b48a5b7b49b3414fb1c63fec2fd0fe3d86399961b3a3fef3b13e459f71ed0b9bc5eb6294d2646218ee30a743fb6e478080ac2962334b48bfc03215f4c66f605cf5614057d057886ca4f71058f9e8b1e8b115880f6ab7f0636f85cc27bc579f3f43937507d5171839dbb42d546e569fe43a1952c9d1e4990a172d98224aed5994e30df31127a8ef1b3cb1055d2b55920ced42179139f1a15e9b7e4aed11c846d7ffdd9615b1774d95c36dff874d8fb8b1833463771d23d35ae3f02398ff407004277444d6517ca544bb1ffcba5ec53a90fde109671321d0d10cc0b8454efb890c847d56e1cfbc386724479449ae525c251dca0d55087e9b52d7b05fddfcf2f00c21ffb922f412f8456da38953135182e12900bb501d7994cec655d20b05fcd850a99040e4bc99253bea597747b6dfcb553fbad69267e3fdbc4c06b1ce9a6ad384dae7fbe2d5646e02a7c80a70b98c48253ef2e89eb160d6daf61646131a33ed08db3906321a676fdcaf241391f20b3ce8f5ebdb0790ba0158831f84a6eaeea1261da696209226a9738c19c81a9cc8f6371c28da2082cdd2a7426882097bc78060feb7609340cedf4c4d88d8d25fef73b17b271750ce0b9486df01fce73fecab5ef6c80c832da30a2947b9d2f601697e7fc03f2b78afbd30bb637393af8d45a2b572f736da7d8b811a9497be9874eba841b92f915385ed09acddaf0419a029e2d3658c200d17b375eebea2aaa6c7ce0437fb7d13b14cc993b6a4da30176ba2ea9076c125428f3df33b6178e6bf18999265abbefad894a96d56bc8005e27c61fafb4f55fe5cdb72317af0f9932950a0bc620db877c17f05bc973262c6eba36ede63b96795fb8af6643f616ac927b4aa170b0cbed76ecc38d74b787796ea52fa6960753e991c96963e7e2f74d72993cb5e3ac40044a94397d50f12f418913dd893c4eb4bf4188b2b44f72a83ab342a00ecfbfa97e9e4666e89d0eaff5bad2ce3cb458ccd84b523fe44141a1ccbd6fa82f14a7105867d657b9e85820bcd02956634f80b9819d559974394ce6ef76d35deaa847354e5b19bd5a92250d9062cd4aaddfc6741194fcfdb886924fefc0d75f8c7f5e3d5efc2d56361aaa7ed3643584d7a3dda06ac5e02415c3d4cbae7f69b2eeea58ebd637faf2c6d94e6b6d403e3d247aff68cdc9e05334aa9311608d38476963250b520224c111698e56130212b8cc975663a058ef9c1f4c173826e551d65db15178e1bf78736e971575d851b0618e5be7b8ac6e24a34df7d0ed24523503f064fd0ec98243376b72df4678a570827fd739c902127c37b5988e210253da9e809348fc90dcb8bf956111b8c45393e5450d9c309f00fcf289cfb7664e934c3e24a8caec8ba4d927d49efb2c78ef9398aa29661c9ad9bb13b3b362a4436454fd23a5a9a2d2017868ee896b8daf6834e3823499e9242b828f09d0ba572017133ac4e70cb6e5bf71dbe56319008746919c74be408369396e35c74c3d79036d1503bbda16947cc7ce644e6c603316f7bf68ff2859531fb434bca6e01400b1600c0791a096efb05173b1011b68efb54dfacad922b1d8dbe909318326da6bd749309b02f27928c72d8a6650654ca73a2fb9e781c62ac43f1a797a0c82ae6b0fa078bbaa8c1dee897ab4eb2f4522c938b36d9a282e37da1202027e458f9430c0fe40b1fd98e71ac06ad54323be6e9aa1725c8cdba1fbd8fcfa304fe29c068b811a7521373687baaa877d0d96c282ca7e1f59a2ac5f81cbd027445fb65146b88606205dbb485f133854cd62fa80103c879081fd61cf3ffbca08f9db3b57ace3cdb0b45c04537e55ff5067dbb4a40f4e42e9a8715577fd1443a19dd1f64e2196720a6eb14fe5d48d86a548b6151a8e67fabb858d362c8d116052100f3ad4dfaebf0f8fe826a0e276607fec3292a9e8dcecf38d0083416e51e86311cd1d96910d705a5f23c8737957e829eea1f7f9ed33456f313c919ff63cd7342309439a78dc35412b7e8ee58a07ced63a6964a9a5586d141bb4e2474b5e3c5619129b12d7d5a66f8178d698115afe8c26a204909b953847386210d77d7aae020302f6ed04156377b258b0d23c790d31af9f4d943db84436f92f96419e5b883e359b31d336a62b809459ee5b01a3b7b6c7074f0a1f8dd95143a93da0b7a365ed40827c8e7fe0411621aeb1f2c59337647fa2b1a25250b8b653f9d713417e9c3f15eea2d6af02317c234d1776d30b99a24b9baaa6cf1b046358150ad771e77589f2f2ed89fcad617c5119d306be5c31e38e094966c79c837a07bf691f14c43c45cd516d77a0ae080ddff3c6ff230c091631a5123ee1e2dd61edb41aea5697c739b88bad63e4f94ba5f1c5b537b8a62470829a742ff20e514bd667fe43c1d1e93f4b85ed5a1adeaed81ba11fa3cf9001a8a9c1aad42751c76acf06aae07c9ea52590e6f62a1043dd50bcc3d745fb81c2d1af9928849a2896802ae8424b80b453a90d6352cff9cf26c273bcf83efe30c029753ad625f8a588f85dad353c59fe6baaead471caea4e150a3bca16e41d135276a0b4983933dcc07241aee8072319165191bcd4e0d0ddd03c9c99d8d5becd7b8e3ad9a9429442c10b31b37afa076cabaf64e0e49788651f1601f7c9ec688d829dd48f4d383fbfa73624e811140a23ddf264afaa312186825953459f7d6adec873aa5ef6b4b55a1bca8c0458e7d34ef46538310d62da9ef0fbdd123a59a0fd5db7c01d0c5e1eaaa542a6bb237d11bc8a59861f4085808e3174f912324b52ec2006fc90df26fd36f84416200a7bce5f75061502e2eb6016e49fb9d6993cdd01a636571b1d51aa3c8169ca52f1e36e2d346c8b3cd1343fbbf617099ec025a6b3658b579a559cb07f40bae2dec10051a811d30f14f973731e5ea104b15d8a6223e5b75be929b5b300524b5e342ea66208cd9e6dd2b22a9cba036c1065eba865bf6b9f13a020c81a55b213bbdf0e914e9cb2947a066d051960a44fdd1397a0b4e7e8e4aa3da57e5a115e64dc5ea0e9615f517e946fc2f2bd58e5723780e2739ef29b3c0ec8200529640bfba7cfa80b571161d9181893904e46380d88d92b653ef41c4ea01caec36812e470d0acf4dc2c92839588594abb02efdf232e7cff54069d62c2a0428e7fc25fd16d71758efd4b8cd38023be399301fcb2863294db9ce016ca42085cc7174baeda8436e534ec81e134d16e18eba21205e62ae202beaad77c67c6ca35de0937afbfebce7d3ddd8952947df604b4ce868ae9016d2279e1cb8dea860a678168c71d48b121ee3599e72b71072849dfbde4cf75558ee5748b0745d37c04b87d5c48ae39de09b5ddaaaa7cf4384ff5507075da9051eb084b1b282e484d62cb942c9f3901b6a5baf6a515e556d450081989262c7b677d107d97caaa513305bb40de10bf01749b3bcf61d374acb52e8c7ddfb323e43c5a60024de1549b738cbb8779de6625bfed83f345ab1f7ea597f4da3ac001fdf35c4f55ec63ba0caa300f67e86f82ada390f0ecb624afdcca628a21a0c314d476a01d6db470c2ce55e193a2532955e3043d1561be271efdc990efe4bca65a13354bb95af00c61b5288dad8b8ad12b8d3f5b0a43c8aedc7d26480f2ab017b7459458a29950c9001708531d23f9c33c8296d06642f20c508e4a61ff2c70ca0ee02fd1ee4b06aaf4e70f0d97421931e895410b57108f692206e6ae566be1e6b5c56def2c49e24277168a49d5c314be9b48c0714d8b0d09a28e160484040bf69acc4f481b3ef0d185808803ae8d89b7b4dd850eb8008b331f2b7b2ed88eb8d7ed76abcd69c732bb25bbafa0435cc1492d8e203b72aa676436c56498b90450d2f605fbf78f1366923b71506a933a69b9822b2185d1f8e2092b36eb36465573bc362b1707085b39da6bd2d2f556251f7b7e3549cec3aed6c9bc04b8ee83cf7aee0a4efeb18ad28c1b1bdfdc5f255287253041950da1a292ffdd90606ee142469314244e4aa9284c4192b912d8ab99ceca2d9dca7bde820645f5055cfcd852bed23503dc4ed200275924d406581ef10e788363ca9e0b339bce79244eeed2c7a4c38755a50a30bf95a7c4d4b79d91ac68c0d7f15d70d0ea8183bde90fd60e8efad82d1f2b1abce6fa589655591b4b1ba9e2d35557bd07071710bcef4f931ab26e3e91897786c422fff0eef927386f7f9db541169f07fe2a8a77d89ac0944da13e3189170132a0ce1c5e6539c8d0714f8c3049730a07cd7abe33f3c485885208d31d97a6d0258252190e0b981a82988397e00ae0ae9cecf0b1cd783fcf0a92c3a5c408086a3f070f56f45ed1ab9d70421c4037f09db5048c9c6c165cf7f80d6a2be23d4c2797b4c06e38bebd431f207a53d66cdc4ed0c6e8cb9fdaadef594b170757c784859a884e0ee187cfebf61d6dac01c63d3717f402b0eb4a8ac6a23768a32db5a828cf0e444807cec877251c8215b8b914bec132350ff14deb89a11f997de4613d03890f34d6ecd1c595a18a43724690045770cae5ea6c59f657b86feb6eb266b0f6c07094e978a85264f8d22c99284fb60cfb2ba4a44399bb2f0df61a7e61d8fca2698dbc25f3740218c09501adf7a1ddacaad93e263550e3308327b8c0562c51d77554414c7e6f0f9b3eac6893ab21238858ff5fb87338c931c38b0714dae78c9aed504bf4d40c8047c3fcdefe67e0c01964ca8c79e1cc046c8c7505960d7b6dff95abbaf1eb0bef283d8f03c5e8cd6f99865d563aa777c916f8fa7c87ae856d95a0e0a77b4349f40fe1993547baf9e1338263962a362db3160eae3dbbc260ac4fca46d8c292608299b0a1741a1c2868322f972c9ad1a09162215d4a9f6375e9e6fd3672fa59fd7336fb990b58a72b800773aacaabe51e715a781bcc176310231327ec843f0a96c52706c4d3f3c1792cc76a0c8137f83a27ab6d2b88f4b1f5a8a3515e198ff02e16a156f85bd3f87110f0ca9125de869ce6685ce8cbf21d040b1b0eee1c012881d5cd78cd0d50b9444f4487ac337417d44360cb73e3b482b7253a7db07e28e2d2b52aea0a873d3cc8d31ee02057df5778edf7bd55a85b31bbb10c01b89e1476a021a2a344e60c525cc15ab6469c5f8089e5dc143af7edd13bb60615b311986355d3d4853bb939fc5e9e66e8fc12e9e088a705fd716d4d17f514073240bf9cee282319135d64ebabc12eb278bd8d54c0f6a44e2198d15b33a5fedd23294ec34ff6785793a07d6b290bf741fb3e4be30b367ed9b3e59d77cebcde6f8e6cc8af897ea03b97484f3ae7eda11e39a354fdcbf41006bdbfeca48f811385f46b6096e432952673aea1818799b44c2c64f775c239ffda979f62b9ec208270fdf91e45c2496428b66616a844f2d0973eecdb2f8f0865667587c0e48fb9784f42c160e4e31c3da19dd2925ab7538406163e4ca7095c844b902661cf9a541387a82b99764a7864706a3e8ce883d4306d19129fcf3d17b1d6a767876d6bdf561df78e7aa5f9707e74044f3b075757d42445070c9f0393b7a240325f8474c23d0aeec73f028d38bddbee7a3fc8f47748d89c26e0acc4ee4372d55179f7c804b0f06ff917b395ea5cf0c7c98a87f24f3f30bb006785343c6f594d173e211ada63983912eb4c1001cda061c9bea333d1de973e934ca8fb846c46288a562bfbeabe212cdef4b41e659fdd743c0f7617fa33eb6307afaedce8feac2d5b4aa42cd28a49c66f6c50d7cecf293910e1112704a3be123b87dd4474b35b243bb45062b8410db14be9bb61859aaf662ff7573d04f5f0aaa9f126c81cd909ecf51d019dba4de97a8425d4e6fac44428846875a7792b52148f0833c05213654f393873fe2f603605566de3953dc390ce9e0bf4079008cef543f845dd69be3d3883cfa8b81dc3cd01e1f5603f4113efc5204d875ff8bb8482a028959160b7405d5b6b15acaff50fa1bfa570ec92c9ed2190c04354415c8afea35bb83b5e616ca4056deee1dbd1e0726f4f2faf145d9a92ba67d2b993b0134c9d9100560d050cc13a03bf1b7d7e8dd18345b7ae8907b18ccc205f50aa7fc0f161660240a81cad1426ad76b51e77d94f838354814275e9be712b53a4a6efbaee10b34f3f2ffa786c63c8717972bb12f49a10f94597bbf9ba5d55bc9e85d09ea3f41a8ef6d0beb44922742be841e82ab512fffca25b67d5be048a2d378b86db40eabf493ff9d3fc0d7d3eefd45de99f784106cbe9974cc1ff92a8429cce2b7b865595872b13c5c788ee4daafce7a976fbe80db215cc1029917af711b626c79a4a3b9e47130d0001566e8dd98407b99ac3071d053bfe0d804e24ef45b0a9ee48c88b8baeeb7e81579c138bd07357fae6416abcb6ec6ed1648b9b201169208a72a667f0b2cabf8d22fbf888c72d18ed40693c01195bc52f282d2dbf585dd90ab596dd24c7dd3e8d01a0e7df8755cfc27aa91825eb3531799a07687d4bb0f565660b73c2841ba589fe09ef7a4304197f757170146fec7156e585d84017d99f9358eaebd1947d039b79be6daceb68e1fb52e06c2a72628160ab65fe7219e0fd5bd29e608a571f295448c9352ae629b810793b5897281367c47eb963b3554859669dcb7e02d890e95cd8717849a84bc476919bbff3f9857a56b9e70ec020b68e6e2d44962509b25485c2c2d6b815c151e65ffb63f7ab3585cabc55cc0ec93377a92b9286a29f27870f3040e38a68b23b86f3d4fd6ed7e43c7a0e10ae9eec7dd56f3e828707ca3b7332fb2e4fce58bb944d68f83863ebd7815774d5737d58a974e0eef1d875bd8aa951e97a67127412e8f4b87ba7eb394d6a58207e6ed103dfea7a534dd7218605d2467e948a3c963814949cd655ba3441a73c6a5f356da334f8b747aef3fa63eae80aa6ffce6f5b9501d0915bc680ccf50d3ebed045def7ca63a2f2115aa4b734a28deb9a7999c6947442e60565766936c75e165a12c9ee8d0d4eb3a53b66d535be28f497189ca96d0ffbc53ad6b636350279ce66166de465c77af98de81991c8b3ed8de65c62548b5c0641d3564d1316794ca1cdba7bcc58ed7fc849c49b2b4daa5db36792d970594787bbe93ebe8540e7616e36c62fa9191b637ae0749178269de198e7d50332e80123313a88abcc72613e91c31a1aa85a41ff5e3a67b11dff63764656b242b822c788d0fd0fc847bbafe4b6dee5e7dd178f798e912de9fc78f916d74155189eb5ef7bf196c048ae83b1841a51c03a149a873a6e1ad5652da34c8018c4a37e35ef94d2d6d5f7b9060a1390c89bda02ef04e20773eb010eac619a8b55edbcde7f4d6490c79718e519f6a67ae7ab25baebcb3f4720cf1b9c17905af3b3209c74a1ed02864cc93c808a157d54d30602d9f35ee4c632adcc661d07a52157fc2ffe901b460899d5c54487c353bbd4efa899ca142c6a8cad2930a4df4a80c501b9ed64c0e763880b582be32e41bcf06ff39182adce8c4d141571cca0ccbeec0b2945ac49a8181159f28c5a00c5f172eed723464838d494148cfbaf818876c02e73e447d41f04c24fcf5d9b88203424e3c8572d5130885020a95fb87ffc4229206b3d0117117179431c40ef205cbf0d2c577df943a607e9f5e503ae0898b622a05bfd5a0cc695037e9ce920635d8ce019abc7697e4e026edce72b86ec2e5df51d9f27eceb63c7ea3e25db4b89ef274263ad758849253ca0bd41283ca5588a517a1ade451fa6980f2d7ddfbf31a3b6216879f4e4f561565e7fb9c37daaae95084477748a8c0df8de8ab2670b7667fc56b79c5454f63caffda5104699d440a413bc1ea1a4a2bc60b8d9b59050319943461e6387189be6bf121a7c75fff54336f9d3ad5fc715d3a06ced7faaaaa5d2f64c0c16b082313e8755abb9b61afba1cb53d6841387acaa034783b75c26eabeaa01c99928258b62ec5a419aab0da4c2011d5ffdf7b1863df0f6c1a5ed1b06fd1ce45d2bdd16730bed4298668938387adfcc8f269b4a1013c3216ec590441edd25e8d3570d94b15b085b00ed7912a5af0c1d6e66c523ca6a9bf9c6486b80d9ea3243f3a68bc6235b16ce346cd4f52964bcab6adbb65e9d6228bce8eb802df4180961e04f2c4ab54f09e666b47e959ce1975a7f9a1b1ef8131607da393c8d8f1da24e620ef36cdf18cc5a0d6756ee3e516fbdf116ea86e672de25be44eeedf9458fb1365df86ec1e335d30a2a692fc0f954752dd440c9b791a6d088baf58949e339a74392b93a93a7505eb88e82f199ee4569b8f16809d015f7df2b229e0aa3ad9520d597b7eaf47f29225b22ac5b9ae77e40e057bfaeaf9026096132da81e31e1de4c74918a4d4325ca7412ad14df6f6d73e1af7d0585022eefa54fa326abcf03bd8b8716af6e9435d9207a0ef51c54b7422f15556cc9c12c1cc290b009219b5bf5438530497112e8229d73c5bca82247110e9c0cdb972997dc68c258587dd5755ce8cdfb47f19d73f9ecfb819d7786a187cd233c71c66e9c7278136f1f08a3a6d1fb8d51f64459698039a08b429c543dae448be679b7be302b080956efaf6bb2999e952ff3926ea4d082a616e809f531060e8149e0b9c64ab875416aedaed83a8b0db218db25183df3931d22645215108d2d48d6959eccfae635d44499f9a02c7a315e15ed7138da9a375d511356f9963a2f49fb403a6ef66a66b72105701059f26d4ce2a0fa1f33f616fb1a8c85bc1a6f2eca1248c74e08f386442e2a3a35abd49f1d97c4de553d0ffd08bcdaa4f3529d892dedbab6fecda68a29b7687ae567aad1d9b0d315d81e78d3eea41dca06cc523ba8fd57f913918527f9fbc1a2614ef2c44ccc6c0e62c9e462a713ca5cb882e2de95b9a1fac6286dcdfacc64a7a4a978a199e2b59751f2521601177342d84ae42bdde225c48290fcaf60ad23b7e64597e740cf6e89cf03cae8e8135d6d031fe8d9a62d9ad232bfa33c487cec5bd484c34ee4cff8897631842b7462e54e44d7bd80328529ab503f58f5e054eddbe5317c87fad360023840b271272ac86cd612f4d57083c1cf3d0fddbb26155b36ff27b5fb9a6129ac5d5b0e63e2b1d5c5a63f6add25ed934de1831803f7c9a6a1d253b21ac0f6397212e9da4c0b2a361cc520001f76a2de7d2a1ed80caa3f0d5482460f701421c1c581e48c634933de8333280f3c73acd5d8353bf9c6cff177b2f53beec3880d8afd353219349fa04ed02d1be74632b54d0888790636f68e7b6f85c515c2b81acd1b3a9b1ab3e1c421d7c17e5b83510b46ab2b80bc054c1a73ce672bae87479da1f3c86415b827fabfed6ccda89a3fbcc2435cbfdef9a6d4b4f44828402b303c66b40cf8a54212bdb35836a203a92fb5202869f97e6569eff1309aef661fc8c01496e3c6c155ca09cfc10ea6019f7b456f6d762cc593fad23c4cc123d78bf86a4525a942618ae133c90db0a901ee288362e43ed78971ebdf7495efff855496f9b5618b32f7ae0e5fb438cbeb035d66614cb1688f902b39607180f98e654b9a689eeef3f0ff1daa3dec8072e6e56b96ef863fe7d1fb1fb221a933c0ffabbb9a52e984bc63f16115df4e26da6b486ab9631a0c1153d8d4baee3c538c9b7a3b53417e907445da988b9f1bc9f52315a6b980e4a357fbe056c9afc8580d6930fa36086476967f7ab722a40b3cd484c5f2030eaef19f90f72964043429103ab9b9c502f1c7ca8b1c411ea9e28f172da511b987e7028633f649f4c60c619902eb49ccf16a83a88d91f0aa51dd85a000da4af727da2c1609e30374db85798707e8534b7dfdb6ebdd1fa22993caa20235622c8a97ee9e273b09d804134240c417e93a1ec43bb86edc7937657efd425ad8b5c82b72d9c69fc6d5587970afde8ff13dc5a5be373e79f06c6a5994c6df7cfb90a9bb7ed9e2e04337ee99b3ce3b8638c7d4e6f82296cbe3a13852d7054fe88fd46e1774ee304b2ea82f068b31e24180c560f39b76221cc413e9475cf674237b0dd14618e1cd6c8993932a6071d5dda43acff4a38047da20e1d2911f41e763f0898780087b8501ee273260b8e93fee1d23f5d943961bb41256a0ea2197251fb4818e807d5acf126aba5b6f036d157c5050d4ee935d48d629d9b0f55e25c3a56a2f664e8d702c63d0f26c2ba31fda1b3e1a81dc4a407c4374d5ce22aac82fe317391247a868f07eb2e0d1fa5a69a141c2c8b4c0674ef5a8ddc254bbe807e825fdf1773b2dea3e154a840fb837b436c244aa0607d41cf97b941eb3116b688ae0860c3c77b657fb5063d0e4eaa624ab1e4e2f4ae72842eb19be022b931f3184b55b382c4bd5da8f19f62e91ec9e195f14366c81758782f4692b95ce676dd4afaa1eec6743e204605510614ffd18638066be0ed4aedf51e71c6f602ee928ae75142ed031f56ed3fd1fec2ab5cec367b33efa807e2a97788a05a3a870d6d383a9bbbc26c5c6449980d950adee17c56a275cbe6324184a2f8cc8a6bf49c3c793e2ff856c7490be6c54478b47fbc0c2e4b54cc05fce8d17fc240a6c56869e97b42a3a2373196e728bb25718a6040bb05299914cf482697e70d7ce96f2b2b686b51bba34cd498f443aebb72be30cf020ed61ae86ef63164f591980ee869ec2ec02b226d5768dbfeb81972afb180910e63c3fa682798c393b38bc91ff817751cc63d809c1813e910f8d54a443adec2a13454fd2daedfcb2cb97ca34d54db02b835b980cb0dbedea8122d3363cd27755cb5a08a269f90cd5b1f37b333bb0998a94f09b9f5faa56c15c8c9704f776673f8df1ce21d2abaed364fde6680a327995f3908f35ba2f4c47cacd99de1f7c1b933ab1ecf799ac24aa517c61f9d11e8cc6d682cc2510abdb3389082e6d4d7b1f5e95a1bdd168d275acc0736477e2beef3adb57324c76404b985a20cade964817c877b6591814d3cd86b801daedcc51778cbe6256e1a6b353d09148547c2ecf3e9f90910580c29621db0669b72ddfa4b417df26697ddceb5a7f889735306e775a544e13ea8225cf1fb75c548a7fed2ad85fdb95347a5b192e93891c214e247f0f46048b1e254b08509ba9e98be137c09685d775eed6b9f718efa3e34986281a83d0760153c01c748dfcb945c9cb83c73ac613e5a7cc6e1cd769e38541e9a0d974846c6a191e54ed33d44ff4e23d16998860f73150c3185abee4daf3d7fa8cf3b07c974c3eb743e20956e2cb2ad05902245c9cc09ae6a075dae911a4272aebc2639bb833188d1296e3ea8efa51c24b09151cfd3c395f259bb006849d56893b1aa41572c58432b9741eaf5f1767448b3fb788fc2759eb569878c4e67d3e76ce983de69dc3eb4a6787f86910b73f5b2467a7005011fcc4b0b8048b65fea2e6414dfdecab990d1e25fd81c10e2a6a4193816e2366ead2b8dedae255bf976fb2b89372264c5ba1ab9b49cf12fd4b47a8827179e2e32a372bd0ae224bef723692c49d8856f978d948a1232e923a895a93f7d82bfcef74197e5677c811c02f8dc84eb25abc75fbc75a744a9d4e9abf1c9e1325fdda7e98179afb00916092a045fe735adc64e2ea92bf9e8fe9ebc6b4a4395f7061742f9b30a6332b78adfae01e8a1932b87194fb83495860234a3fd0b4d6f27da272794c4ecf34d3d3b1e247cf164aae6792b37307150aa91ebdb0ce41e48f974754a474608daf3040be10478a9f9c8784fd0412bf23e6b6593943746b8a98f70519107a0afa73808d0e313c578d0172d6b69fd97a41ed6af0e64ca569e80d0ac51737ee8fccdf68a31bfd74899f245b0118a4c4b7cc5f7df8cb59fe80b6a1343d93caf91b039050a6449ed56d387eb82ae7cacf3b71cef7570505159213e45da99621c328b0d316015d4b9a758a9a70f1a1aae7b578ff8c84119580aa3788b1dc9c1d1f7edbf2d84d609cf0c375a5c839efdf9a130a93191b4158018e7726db90ae46240904d4358f34fec337656de10cc89d56517b24b1c507f613e1c174d60fc1cfafbd29b1586e1c27908454aa0256ea2cdbcdb061c215178cf9bfcdd5cdac9bd2d7444d32298745a951682eb2ccdfaf244977091c8bfadbb08d68905fc4deb3f8189d179125c2abbf048783ee6a843787750cafba4f801e07faa1db35b1905e955a88ad0b9d35c38c97b14e670f6e0fa40c827518524de446bb44287013df24da94b83d00bc755c6acd947b780f06d165f0e834f6240f1e7ad9facf85e8084b28349ba9e10c3f3497ac3bbdb5a92301b063a78a180a835acf10b9d8e9aca8b518fbd9f78d04481caa44ed583e31925c8708407777d7a95c022edfc4c92f46bb45f79de395aa2671cb3a49096fde798d6de7c9e7b580bb8bfc7251acba2fea6a5847c6dfeaf29f8583e3ad11c605d67fe29f9eea0086786cdbcaececb278d0f19298f92f7b948412d1fb1105d21cf822b712632847ff5cb549ba024054e498bbfb999be9a5a4f14a013ca7e992480408a2bcb218d6c6ebc97e98febd99a259f9343a86f3d63e2947fedb9afafd5ac690ec7a68e4163c835ba280df0be57bf2b009638a76ccee201b1a188574d2d37ba3b006788f7466664e401a918c2b77aa31277858f9462f533acbeb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
