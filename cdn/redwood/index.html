<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7dc69645b6bf8428a39f39730e82450c6bbc320f9ff819fa0c738e070feb6d0147502485656e38b4fe336d1badfff3dcef43931e184c2bf7c22e606aa8949d5231bef380e03955c7c7692bbbdf8a996200db234a1c88caa7b0606ac7853313b04d9ba2a4bb28172dd6cb26095e7c1e829d27b6886ccf16dc9a528d70b2d15baca124b015fe5f8d76ef434726a5a508b7670768378339da5693f9e020b1b0f59dd6cf3b570cf14c13c3a3c4c7b532a1686cdae15bde9a093d2bfab9ed55953234e6a4609ce6b226abd4f2784a10b51c13ab1b91e7d9dad3c02c5caafb25d46ef84016e7bbaf5a0a47a784c1e4df88832030d308269bc00c3f3ee1a64b7be126433af1099af24f3016e10aa49f9db400e1535250064e7de1707927c95dbcbffc9ef6529e493bb2a5315f085323ff676673c4bf0e64194faa276b669f376d805df15dd21bc680a7312d5964eeafdc90cea1f2917a0e205d8f401f93819087663c6264ce58e918c0ebd44e2eb3503195df078890f5388d2a65cbe96ec8ffb304cf09c9a023b483f532d3d94d43bd4fcf7b6364996289c683bcc38748084b3210a707e608b46f9c113368d753c36ee09d748acc3a764adbc3b4ff586b22df761e1c0a6225d8c2dafd8a2d9c95d41df05903d3cb8ea00b552ae3f2da6a5f9c85964e9f21c2f4f4d0f9ed59b7e56f3fd9d6229a98df688d9fb25e87275cb83d675b193c5456cbcebdb096b854c29cc390953311ad64433960b751e830ba6b185654218e40f125242f61524b2a596f0232492330a5fad4e1f719cbddfd14f420e997792ee180cf624e0776d3b7109caee1beee16ad5b8cde915757b7c476c9b83abc6a419bb4c9e732b55ee2235bf2038da2385d2c681080c692e5e19561dcf675f8cdedf913ecb3d38886f888edd017f6daf215f16e7ecedcca601dc98af63e3981d7cf4e6fa49a9c8117e61ff1b3475e95cf858badbad065ac03589c71db4a288db3927976f38cd8cf8ff61003f7918ad3efe761118130cb2658c65519dd0f1aa52a48c1cea92c3064e148185b829f7a4f81626f2ee23dc9221b82f2ae16a3b78adb8e065fd9bd38b60c29650c2bbef479515a5fb1821d3907a79fce1aaa5149bf090682e14fb2facbd6bad02dd10cf8c898edd3f1d6a7a423bf25a3ead56da9a80da0c248d20f48f37bb1fdc20bf86d51b49c6d1373348d375f438c16d62512bca08a1f9d7499774746f878ecb137be87492633a5d82bb9d8a163d5a3bf11abaf8fa1b161ef57044ba7706abd3e36aacf14c9205dcb426e21d75d667ac9d92d10f9427d00bfcf801c0ef8499bc23c71506b3e4cef1fee4a5ea3e71c62e072234e8cccd114c1fb99ecd5005ce82e4f9d98f86cf587c9288bd919deb5720b3ac167e6271062e0655a0c0199a8b057900a02f99a3e3c4619db2672e9b530f05a5171ebe257d74a0a3ec8f8703d5844144ab2c3849f1f59077e75a236a4c5b0f1118fcc5da5b4dbbf0ded52b9b1fba4663f594ea43ec00e6706bdea74a8de922af57b4b5c8411da4236bb8d6213c946d1604d2f40dc50f68a58e4673472ab5984ac37ce92afbaf55a719ad4c69a62d1e6f6e2aec40c7d5208102cc04e2cf5e0c9c53c09716a7b5170c74d5504564b01c8e3c7d537ae320b36eb6be8cf62d867c86ba8255f40e6470aeec7d794e87c56fae3bad4a089af09ef6fd8a66c79bf3faf37dea5d2e48e6ceb49039a272390228108defdf32fa51249981bb39de7d5aae8f1fccda2695b07fa1375c0e31bd8e5b6b286daffd99f1607133114fab6cc1e50a07032f1cd48149fc2e48b5bf38843152f5d721745fe7715086633df591dcde1c88941d937e86f82becade0e77f10f36bcea469db44269433d09fae57233e6e452d777d0eece0d5ba3c01eee5452f059079db250e91485bca44821c4cba73fa49f0e10a260645f53a34d28f4bfe624e08ef093b90251ef0c0ba0e5a13baa20f54236e58ce51581e08504806f0956591955f1eb263296fef2fb544baff0756f66dc9a92535bc721a533fa44660fbe2a3688e2568b0a8d09d20007ed071e7e1dd65f707c6436b823e76b081b2ea55a187d5ea44ca042a378fb1bf21fe34925e1dfc629cecf2ad7f7854d315976040170c60494dced5fa7444ac35cf8516c9e9c352fbec5a2681d3e28c151ddf198550f592d340f37d4809a8ca091685b629bc7e89073c50eae957940b816cdc5e3f90697b5d282fe7902d3fac45746525b9d0722b9207b6fd72f36ec2796cb7a7b47b08fd2f25d5a4ad27b5249d29eae81fb1b272f1d561902227d08ca0ce9f52775fd00d3f472c8977f47207831849b3003e639c72485bd8b4986d31f1815aa586cf9adb52637d8ae35b02e6ca3c3a7ca578cdf856bb1b06d7ce2c2e535d7065ddce5f951312d137594b9b4f8c966acc5caccfaf57622811f64b16b647d839d4fa150d881032794b3f72017b11811b25debf51542b134199cacef0c7d50f0077d51edec538d4500768ae7266fccc674fe1ea5b67f5e078368f36199d027c9b86e1ff7e343ea9bb7d20016e366cf7f276ce98a601dd1edc7fcfb09a58f4e5df97410a2ef28677cb98ec9f3f815d1255e52674a1c1f5fd6a004329f7a7e66e1538243749a7f7c2ad5eadae828663cc1351abd8fa900d446f003e52ffdce4789ebeb0e9280d727da481a8858061e158e1d6d5886afe3e7ea9eaf42955d55ae604fec599279b9a502a77772b6e09df36d424a84bf52bff8fe9e8deb6496289eb3fa4c3a1649a7be1121c68f8bfff22a98c1a4664ad0c353248c9ec2500100a531eabb29fff24de4790665c710ee7f46b80ceaa85d84612035ae878aed61624edd2f4d15859cc4504f87012624f9ada11f9827df37c734c3c2f66faf030b5ba14eb1bffab3300cde43cccf7bc5c8e720a6b9f89877e1d4b01278d87803f5b17d280f5bf998a7167eb359781eeefcad090cda03a952a404f1c15f535b18724e2f9479d8ddb46d5ed597b08ad6b79d2a1fed1f83468d4b0b929b27ff95541aaca8ff72d67e48dc368fcb916117c17e13c2a6d958d492c5ac5341c7d33893220d8a4f5608cf84145322917c5698ed136f2f4a3252ee959fab03262621c3a7a975433186aad284a6a43129aa6d6479e02220205f13d08b54e4c3f7985746d506e9d75f1f114aa638ff2719530cab4c2a705f238ac573e11437176ab1d2fff89b93266d8fc9e3b6f7e2c9f840cb0ed0e5e5ab6da3d243f1e6f9cd751151ee8336da8beeaab728d8c25b1e2b6e349c9b198685ec2933505c50924e261cf5604bd7ce253a7ac1825a7bf2353e733e9c2799c482cbff9530fb1b77a5c996d5f2e0af4dc9bc74ee4afc11f8c5e5d8514ec548a2d3209064579568cb05c300aad121b03134d6e9a3f514ced470625bb4a6d091a5777b6147193fb3db53befd995fc61e250ba5db8977bf4fb18ff2ae52a81fff10f4aacb8895c37bf64d7721a0921ce1cd819e0716e4158b2a74eaaf431fc7805222404ed72106cfb46d3fe60316a803d8651079cc9b402776e6f3661271df140e9a5e872421b90c0bbcd9acdafc0fd6cf999735ad2ca083931d5fc570de7afcc1b11db9333ce0bbbe4c87ad5597146c09e2bd1418735186ecc9e9628b46579b9466b388a1d361a0ada124ee4f99465498ece4190e98abbe3d97fbbb74fbbca680610616431b58d6d0d6c4f5f8feaeea2f9842f9ce5ac70ec925d40a091436868f848e3db4bcc8e23a145d6c251cc362e275dd3f8cbe047f7de8940c6c5b3c5c9af64e09a6833dacbb1c511340a817d2a92e62eb4c2d5b264bd9b2f01fe18cc401bce3e1db012f299201cc70855891b79dc43d928afe384fc2e50afec68acfa680559797dd9f644a938c58e7c91f22c13322cbf9d5ad86b4564c72c628d0d32ed27368d74969d6623e1d42eda08a544e2d2166e8510019077518c4373469d3757cd79fa91ed60756eee9c510a39ead6cbbe58303a5faf7ea409a8d5cc06fbf94f69c488dcc7027d60569187e98df7267ea043c075e0ac55d3b147540c148a37cd6ce42f71a6d6b89b6d3be22659dbfd6c4f4f1d13261573f3ccfd8d72e86af7834451fb5812f6b7c5f76c4248d15c5a8dbf95aa46d8ffb7bb40ecbfb52847ead01f38c3d16381dccc9b27129511a29f525bef40df163351e8720f5976868ceedbf46650c8106ea52c26ab81fa12d5c33870ccddf0eee6e2bcbf9628d5e5ed74a8ab45846d5990b85094d1d9ae744617f9c92a4418e97a5337a405402877a92a758c9d8d2e4147c86e3d545b872c59054b159f2c83a62eac14bf20d74366163f3d08023a54d3e34245de1b6a324b7d218af4e3d3503c183db4a532797ce8bfed34bb6655b5d97e7e2ae1922071b334330a6577b9b7a609120e6a66a6b206f6fbcc989374337abce0c18cc2329f9423492193de7a0b4debc6b573c0bb39f7e21f5f03f3539c31ea19c85d9185df4f9874030e403cd2e991ee025a7d7ed589293fe5ed06822ba55221bf2718a814e7eb3cbda4811e70060f7a112edba6feab3108746a23089870ac69e31da819a129e01f66596fea1c97d533cb4a4572545ea65451ec040b9a5a59f7397d347b6d4ed5295c82f68951c21c47d3cd2b23172e87f8ff2072b354d52f3117143c4d8798ef5fdae31a206d8bfb8735ddd56f0192d7b915dd6b3f2c66851da923528555c654a212ad1a8c62a84e56571d9c43bf71693f16a4e88dc2a0b98accbede47e93a28a940e3e8d5e909f5ac630c6d32a08e74344c7d4357f5907a3bcb74dbce5cc1004cf3806bb03d4396b4b87a41d2e8fde54ad5785c074ebce2448e2716cd94e527eac2d7dddd64ec546e9e2ae4cebb8a8303d71ff6a9155494a7985b6d61bd9b7f34976cf284dcc5832a27b993e5dc44b5cd36a4e8794f2d2a5d26ba7b28e45b6b03cb405e4693333b24cc79dde7e44dc7092e9f58a5d459acffe8f1bf7a1397b4259b62d4264f993f8990f94960a75cc76d8b6c8b1dfe33c1d5d40c2645d50d63695c0db92bf170c2e3674d9253ba3281abecee793ccb8b135632937cce7b5b0167905a36de15ab66886b9a0a5f0f8bcf890dffa3fc9b6e14089acb0c769cf88b3da3cc796c7d95f16afa9b5b75bccdbed90b9ae4ba1f46e1e5e4a92b1628d1b4efb29942829d36395491fe0cd10669969066e2298a1d8be10b172064b647c0014a97ab623667304a869624d2d8dcb90276b9d816fe9293aafaa3053183f3f309f2d8919efe847b147444f76c33fc357cc288a57364ded74d7eb506bba1161b49a9e99fe3b075646d4cc46a2235723b0b76fde45e9bf64ed41537f4ee5341e6b6437a7403ff80eec8a14fe0c84cbd9f9b60e4030c3f0425a020ef536d7241de698d75538e5929cddc12d34926a00e639e1b2a721a1b2a93b7a286684f840401ba2c3f979ae24dbaa9e30e48865869a3df059edd8232fff4ba359e0a7ebfc138bb13397cf2bc2b543bfd1a6f1d33b390fe4847b0a3d001dadb86df71c55166838dbac3a5d25d3985708bd4ac157c6659c81b07f45bc4569e7c085903a1667766ab5872c2659570c10531bd4546a31d3243acee28660867f06bb17bdea7e896854e8ec35620e9e86d64013308030309405984988a4297ee89d7ce169dc82dacc7eef9c35e9c313beb6ef7ff20947e1b2389a0db3b87cdb2e59b02da22313915745b4f9e60c6835c211a47d3cf69a859c22d5412eeb23de44784b4ef640ca425a71a5661cf73fd0a0055861569945312fdc68fe67342721b011d91068240b922dbfaa22fe3a434cf0be8a23d50f93e2504d40bea6f443ccc078680c010cf01de02b2fed9e7e3b9c158c6df399340a26c9a902166346df38042c979721b57b4ac0153aed605476ca43cfeacc1853c936e22e7e07109ad7816658510048ebb5bc56dc89a1d6f291f710970b6c13ddb2c5e3fd6b7c176d8861185a3e0351ee0d0a1105f49c2795b201e9a4112d072e43ccacafc09aef426d88c275cbf644f0971e051f06992a9de5727cbeb0c8560db4451bc1c7bc98975072798d1481ae2a0ef59bc16defbd53853665c313dc76120a79bd94d6b27504cb50be39a96ae7fbbde01c82f77260cc71a061f0350b07de187326fe526cec9c8e049ae0a0cdaa4187d088eaf730286b8669dc08fbe37907076766546d1a684818c6b6ba3ce1d9cd896426445c86f015e1e2364b401a3ea162c3b307cdbbc80a51f738e9bec1e3f84954e345e7f32d57ea2b972bf1e8a790925d4139aa5354084c4811d734288b238cf00ffc1eb138a5bb6bb976535d5509a765a14a57cc0b4026bf785bbcf4f557102389abcf0aab8937c7de1e4a651a87a6fd08ec59e57339ff9c00e13dd13583afc97bab4ec5fce10823a53d68b1934876965e845b4afced4c3b515af35c61762142cfdf6af5bfe91281234e89189add7ae9447f9d93d77c88a4bc429fe4c73c468d608deb8959df7d21c5b8874e21ff9270957a4ceb9a29e24778e9c24879d23690199013f3032296914fad5fb52b2f8ac20c8b9956f1c63f4a771b239fddbda138402b09cdf911fa41eaf1704f51dc9a20c411ba1a51d9a7a94c41001934c1935c56e4309c0d56514b1065b75f3ff602bd8c6cfbbf3e90c018cb751f80266ad722f6f5c0127d6677e072dc5b9246194112e2e13456f545ea17914549dac660acbbf9637b1b30aa9451fd42fede9d48a11137ebebe3de1eb608c4b0d974489cf5b51c78bad69f94c314a2929354a1c115b4da42670826d3bc33a1e4c5a01e82514982f9e92c448eec82130555f8671b3e7f1282d6bb4a94db3435e80a9d7325680273b4febd5ae7003dbc335c02917afc8cc4d103de4034ba54c076935e9d2801d021d79b97f107c83e1c93d973b5a184da6022ca555d17cc1d56f8d933e407e87b70e24cefc751d73873f01c2a3c571d3ed7383a26e8fdd9df82b1f04d0a65704f0fb5c351f8100fc1e2d92a58672017049a1dc27b46edcd2b7804237616545059ce2ce9759c38f3bd29c0f734df5c59c72e8059fb8e80096d259b0309adfb6c23a4d011eb228db6d17ebe5ed744b875d476e77049d52076ec5040fa3e0d26900813400fdbad9f280573c169e67ed3d2d1c84643a5712645782849e1ba84740067e6e4c5b6da6369dfd84c90283b805f38fb513b29661c68fa35ed84bf8c39458572093b34b861c3f255a1deb4026f40b914315f21e47bb7a9d511223af5b79933f323d9e334f5edf9f81b5e234902ef0a7d1232c560d1e5efcc8b288979032bcb8609e6e16e3afd2c1f18962be16ec5246138a9abf5d9c6ffe50ba5e68164316b904e5ade8c2303a8dad824978ac6b95da04997c16eb0f253449cbd112ffe474473a91c038360fc73ffdc17e23e5bfd36e339111ddc2089605e848c21508de38be41ad7cbb217f3cad658f692fd85f2182004a5eb3f1494cd685447145619859aed4744f4736bf633a5652a279b9a74b3226c9304653fd7934374d5b075b9d80d3dc1793946c4adb36f5704bd7b4182846bcc15a073071faf0670d7ba701072044d0b9b227421c9952d4ce2fc9ca08d7939b2390b6a3728a2baeb3b5570a5bb1ac5c8223e062911e0e2f058c8a830559e6db67297c4411bd4cf99196d080c792e7fd4b05d2db1215a2611b771ea836c50ae08cba124a6f9cfc6bc0114a59baf2e6c7fdf64e90fd5fe0589259432fc9de429b3354b62daad1302faad82ee48be8248b371b6e21f24ac6e33d681223d37f6ff631925b483966eca8ea75b983c3424c689dd2008233acda586ad0bd476df93d95da942f5f804f238c191af487c8714210ee457f47b18705a23cf0343e0a85acd92e1b678346eea6134e36c00f2cb18a90c79af3f3013867cb2a02992d974fad248122b6d802cf544bcf6b01f3f6f001398bc808311f03f213683ac64b55227f3758f656431f90df690e755bd2c466fd6ccfa6bbdfb8c89a153c481c3f7ac5506d6224579fb4d3c59d89af1dbf874ee2c290654362194a253a9a8350c7484abb477c0087e56cbafc201c231d5e13a560c442e85c4eef6248fcd0614e47a4aa85bed6bad047cd141ab0ba02e378a572dd33c202e7eb465d3240f435a036f44f0f6ff3d94e415da0fb96f7834a60eead581c3474dc7ea058ddc6d738cf6e8e630adb8e37dbf89d1c843bb9762789b4f8b2a48e4a8f31b12ca1dcd01d42cf559f9d49cd669a6fd7cff0ff34d3a788393923dccff358678bef7a10b622f6a5749d1c04e8f24b4f67b82678098326d572d5a5c981ce1ed7bb6447c7abddfd00c4aa52735ca69f02e23af95acfd31db0568c1ce2735c84c8f538cf396d5f32b46274693a23d2a5e3798cf77a069c70587e1e10b7af01dd71230bfd4e5f3e4e24fc13389cd881b125cc8f55734327677017eb882ce29861d3bb5795f5a1499e10b152ac10b869bdb147165426611cae4727615cd7d9957f57aa16578a98cc65b70d2907179fe7b39c0f0de5722a3751cf84d0b2e693cc39a698b4265cc4379bf0998c1fdc40da698016ccddc1b81f2b4fc572ba40ca29708adad5eaaf2cee9849ef1e4fb390e33d34650246a396b30dda17ec8cead0a22d44c786ec6bf9793d3832a7bcaa67a0a9050c544fcda97523f33eaf0fa594bf12232b8757c17f0819f57f67b4cc01d31720b739ca9251edb0fabc704d0558c4e0a3680599c4c7432175f6872f65c810d60eef80dc4073c9fb83ad96096f8fe60d7d98efa2738e263074cbe81a5954c7a2b482af07fb8abedda6eb5b57ddeabcf7d4bda5d23bb4f7803f50885f6314b95d0c15483a3b8cac22ca9ad84f1eb4a84f04f2386e76c75236d75345383efd5109139f3bb679a32b86ef85323de322aa5e2b452646a534d3947b3a62fa8efb2490ed6ac73c90ed5b56bb79896b29c173730ec0b0581f0b84acb2d2ebaaf6be4f13c1d4a981f74c4f74b64a601c15958903f6473106d706a58d59a5eae1f6d14e0abe45edeb03e3b1f14bab85e3df6a40d3e3fee6874a6aeef851485f6671ec8f49372ce74bc42641c4c55edd0a1556de163e3fa8beef162125e3ea0867983db7eda41fa63f1e069aa46e5ba3c6015be424afbf6e3ff1bda23d0a8613e04869e17fbbe530a86264094eb37d5c8535474a6ca096392dfd5028c8df20e1a21019fb21d362dc4dd22112a0fa29fbf32e942e72feb81f0b3ff492984fb74c4fb4c8083af03cbfa80b9220a088abc98226584ec1de15cf0d517e5196528946c457547c4ca4f2f6bab7a4efe58544f1498f02413998174c892250c2847d7d86fd1009ed96a977d2758b770668c6c5a3af9fea5ca7ddc4475cafc10ce8dc5f9d371a871337477a47ec9216e787faad8720cff7febdfaadfb1be13183be8f49df154380434135623953989875e707943af311b218441893edbe6d0ca3fdeffba0a17235a566e40d904970c0ca2ad672df100cd5f9b271194cbaa9e77662dd32b68d02d0064205fc0877d08705d7416d455866afc809caee751a9a9e7a366ff50dc3889d65079579584ddfa9fbf1278613087fb2dd864585af14a48938fbad8ee1d22864638a0d96a1237e1ef0bcf4fdcfb33d716280c71831c67e0214e2d83840f28540f76b731edb25847216f9d001490896709b9498a0dcf4736e2c0978d490272ce8a5f1f511cb94815116abf1a15e4e76cd5513ed626ed5c6747ca59718e10fb967dfac552e46409b946d58228849ab71c2754e17ea656e806a5cba324ad66a886e37aa4fb9474cd098a60318ac26bd7b9d78e6c6faa9ec9483afa61957ae26a2858475559099b8e08faa4cf40e49e23875993eaf4451eea1b95373cb26a78b3e7e7b599d8740ff184badceca912b0388dfa540dd33a34ed90f98147496ba4b70bff7b9576b72ab2349ac41e7d99950235af23e5d4320b838a639ffc5e359d0e7588285481810bac1929774885298e7d7dd9356e8c2f7d624790ad95c6af22f8e78fc908e0f890e59fadfb11ee68e686f14cebed1df01e9bc3a2170a2f3c30d2e40057b1b95ec7cf393bd446d3e6d397784da6644683672ea1b3c9b5fffb54b6de620391ae2044dea78dcfe236422fc1e6b440a57d711f766e2856c1ed3ad13298b920bc65c22294a01440ef8e6aa8ed5219d2d1aa3616b90ce9716fb390e24898a18ec30092055156849c6b4a8ce04b3e7b442d8504e477d026a89065e49846e09b7a157f57937dbdf4a90326bd8f16aa61df805adb363dd42c9f216ab95db24593787b2566291a618e9cb6cc7cf72b800ab06586ed23898be26fcc7ea9b8e1377be79bf6018ac43e09c33ed55c499fc7a0e13c24ce279ab0a0c4827f770ea0ac1707fcd92ea415e28f8cdaa54b82bd295a3a7f26a3049ec42fdf89e494cd5d6ae0cb0ba937427a5212ef1f3a49b3980af1b20a7a69ef66834dd99ea096ca88aaaed571b8f7f14aee64ad0df9db797f20d2b9f1bc460971ca11b1d8e220f695a77c62b5b4fae496ae2880d36b3991b5a8c4e01b93342420241fa3416791a3de442f5c5b36ee7f8d7687e73701cd5cf8771dab1642d9d02242e226a434bc040789cdbd1403cc4d456ba55df12c7cfb7b8d62cb3eb276a4af7c203c1fbc74dc2415a3e0c1628dffa679b0ff9f9867556e1873eaf5558dc414b9b522cabdc55449622cf4e7e637782b64c682b69244745e77dd7b50ae51599ccf025796ca21e9454240f258cc6b0a68cc0f2cd82e33fa37666f0e7a105fe136493597faa7362f9128cbf81a559f1400650ca19cf7ee1dfbdcbb10a5d4570e494878483ad83f5fe479318b9968f178abc698c87c85bb064a222b7923bf74b824d588f9bfdc53d836b6bb3ee8ea21fef46abc3824b5a7a03eff80d760a7d5b286d46e2f3d943e0880e16d39f94388a5829fec2459c7f893e5e90a05aaabd9fa351376810acb2d18b995d6d545effea8c49c6f27b4f699f4f7a5c5cdd0d643c4a0d5eaf1de4576f12978389f9453d07244b06aca6ed2cb96a8660dff727e0412554c17fc4ff781a4baf4b66c9c2ada3af84e313712dae7a19104a5eab372ebee49bf792e97451ec503dc8a4d69261f98ac2b1be60c22e2fd3c26a8d6c2f7cdd301c7cdb5335273752e986d508595d92765500cba785c9e1c5c99c87efee67ccce29bdc03bc9d19d45f8877acf923950058d0de527ee60bcc4ad5317385664dba6873287a803afe44e2efb45cc5c60d7187fc683bac352c27fe9d3dd19104663ed3f2687369545dd16c53d608ab4c0a2458e3b3b44731ba1d32f1dd76c4fc19553db91d923af09147302604bf3c9842e3b1fd8f9a6d50050c08addaa978018020a8fe8710754289bb6a03281876875ec972d4f41341f915cf2c7f3f38fe9bd4bb9203beb8488d36a880e3862fcd709b2a31ce18fd6026a21746f1878f30b11ee02cc5d508353a1255264161b13ec61ae49c833768d22d88d468acb78bbd220173ef8eb6361db9d993e1f133b43f31f1283aaa7166e48653411c07b04b70c1eed10a8e2516f339ab7cdef9cc15ad38e5f2238adfc15803b93a25c15bb90adb558c3b8a8eb737384a39a23670783e7e9311742660d1c30ca2f224f5b63e8c24994daf23ee1e224918df71a3493dc4dfa16addb24dd70f7c808b08961aebd0fd5d80e5eaa2dacd499ed65c1cd1067c040d45e099ff832e22e48af2e067526baa59638cff143ea968f69e89541c3d0855e5f34de11500be5b4a4491a8f136cdd369a4e3cac6da9be1020ec1d807efe7fa92d08bae9c0dbe7b0957ddd53946b4a2d4b36ad2e2590dcc5850d518a593f3943376a7f550a3d64ffb7f7b10ac20bf265eb36a2494a1d137981db372778de295843555371e18d6c52c124b6834340270206b19534cf43b7e3b321b8ea195b1c631c15591cc82e770f519ba8f6e2c25a20dbe826fd03e69b4d2732021f9f487b1d9caa3d46ea87bc89c7d5499a56288f6b2269b96a0222a2e6f0abee16e688251c94a7067172be4ab6b4245ccce438a5753066b21731fc7a21a2e134123bc087c522911f9ead24a894a51f21354a078c3be736a624b9eb4775a13de5f373ccd4b5539a74fc0615e296ae12eb0b5d202e08ac8b1ec69c16911b400a491a12a4e152b4ba253226c24eea5b640bd6981a7e92a0933e67904c9332724550b6ef279aef45f8b8ab591c7b7761018a0a92aa77cd38201744911b64faeb1ff27b65de4cdc46bac0aacccb2c7cb1ba50e0a2a11d81837a6bf243d45151411a175c58d2924c445d378850c8acdf84f12ade35655b71763f16ab9cd0d7dbf6e748073b21c828de81835168584913e84780ddb61101b82e1264490683ec7359e2fde37b4a57799a614622ea4b07dcc71dda14d737f7613c6c9c7fca304e325ac553a9ec2fb2ae0737310c698521f8394072e790df886d68f1758bd9e99a752cfc6780756390fb4363eee7d18d93c0c500440d4d9b4bcee34c1e0267cec2e252ebc66970918a05c325fd43bc37294b987b5ac8f8357eaa6fb88d6718395ecc988e8eddd7f5d9f6ff7247a949d1fbca1a7646789e56922246e8d7fbfbe2c0854ab769efb1a7424672dd7711a24ff9cfca62ac0a6eb54ba2b704a7e73c2dfc37bb95545af25913b50c698de53d5fac703ba02983f866c9c455d2913b947f8dbe2110617b33e5647a6337d6289152c6ce23d1c06d8c199ff5978161df6805eb6f187527765234520cfa4570173774eada1c435459f44c2a4a55c540d36bdc4e04bf254ec1f1a9da70452fe9f5f73d6080193c7422ab6cc0234f7c07a8ab0af2a41f8024a840d49bcb5beecbebb141db5b3945a605ab650058b0ea89ffbafa40926ab2ad6fe73eb0f586ab85cd64c5f3d9e4a5ef0037de3a231a403f4c41acfa85e6e851cd2ee575140d2bbf8d131b20dc7bb1105d7e7d9699062e6d75546bccc3eebeb0b1a2dbf168e489a97bcda052f1f00e782d47538ea8fa2079c5ee064201661bb430d120e0e1314e3306b1ff8f9d84aa66d5704c0830a0a3a832f7d43fb7f74c8954ea4a4ed2365cb864b575bef29ff7a7f11dc522f9b6e7fbdbe78937645f5cad0cb5d3e040bc1f7fc0df0f7e12e1d22737ecad7e0856e3fb99f7d8cb6e44fb3504a2512db2da801707b119d1ca9ed2219176d5d876f5547760b323f09158af56f2ca770783a8fd42e6af4cb0b420e1a93d841a7eed05eedf6b0cf8bb478d0a96fc44ef4a04908f9c762cbec0ffcb4592def5de7505b59914bf9c9e75ef28412ba815b019c499823be9fc22209a5b10587392ed99b1b5b77ff8b496681c0f2c9e0c6491ada95339c3d52c2d5867a5481e402f5ce1982fd7255906393f2725671ce586451fde0fe7700ba1a90f7b37097bb312db6efe685b98c1caad645764e872072702a53b9dc5c8d24efde97b2849be805b6941f7e6e9c2a8a08dd2a8dcb5f7dd679d853c232dcded6e1f6476d4c2e873f09aa6f659a8ffe984cacab6a1f602956ebf63620c7170acabdcc3c5395f4183825d213f30d7497e1da8706c8ce939985f10ac02764aa1719aac64931c65df15f0b52e1ec91ea4a4acbebe796551bc41cb191b48733e9d13510cd2a0cc564ab442d074f2fe7c27a452c2089af4d35d75b7d973d3c703655063175fad54bd55aa8e90246869d6fc196d2e8c3456ac90c8a4adcfd7dc44a0e06b18513e950d89853cd3406b0ff42de36fcf0e649660537870fcd5913c8ae245aaa021875c0bb8dfdc0f2204bca7e1baa8920920e021e473784158b221aad3e135206b1992cae64eac7352fde7f1a1850d11db8a6bc16f8cdd2fe8545520bcce6a67bf6d360c25b57b8d403bf4ded9063c546cb3d6ced78a641b3c8322ad7ed43de5cc719dbce6e67bbdbad2099e3f25128aad48b629b72311dd3eda378e08aec3740c51ab9946261e97e566244c5c466032d70f373655cdc397b0019cecd9b37995e99c4a11cafb5ecb78164f137083dd5f6a6b751964e4ae3a1622898c0f5cad5df664ac4716e17aba4f4b31c86f8c66bd18b2ce1ae8125c760a1bcf335a26c4a223fb5606086de73e7d0f309e01ca46e52af2c91c49fbf1cfe9b5a2ef4904f4747920f99cf2e8295a4acc64e7720dde9d7e47d3dd63176ed163523d2035f145ae2d839dd8c3156c56144e846835d1e73e72643098cd3d702dfad7a6e421e904720c6c033d285b5374a5981cc979030ee496e2b38d87809c16f1a8f03daad9fbaa0a4ec9262de94cdbd8ab35d8cea4cacc6865b2ce107754debe1d50d2ee9f31bd2df3c5af2698197f775d40d6b973b8e66ee3d0dfa4f3cda5853160b4fb4a000a1a788a09f0ac86852d7fabf00f320f455c3deaeea972c9b403c9f1de7128a6d694a102a67665dbb6f9ad2a88af7cfb3991e45b957690d719771806a0d13f3917d657aa119964fbcaeef40a2f0e89192a578a0f5d8d0f992bb910334fe2b558237c23d5fa74822097b2c6aa550378d6d7e09b3224ec696b3a469a377163c5cb74e86c8c9e3301284aa975153d8ae41ebf1c3c76b3eee431e8abcda43c4126f2463c68548094711d8ea91f3f7cf77d58fa9015a336d6a4c57feddd8f1832cbcbabad19903a7d3bf1df5a5ff6bf15fcee756bf6e0f8398dd24ab9da2db91813fc2a25a4e803e85e436fe68aeb6adbdc5cbf591db9720e9187b8fe549b03e1715544a8ac45ff270635a1cc6f09787d9fdca1b42061debacfe4ce5a51c2ced2bee26b9ab2562b55521810a88912d601bff156058979c9a178ba806d3d524a20cd819e4cd464645dfb4b81fcff30be8db085aa6b45db266c8faa23c8af23f15b37afbff9824beea630d76192f7aabb4389aa2a35b97e081337d29423d3fa82f8deaebbb9ed1bbc80dcad772bed62cb18e34c5ba1995a558082137bd8974e0d93057f54a0c5f76c529c04c1659736ba8cf33bb65317e9da9f0fc0c12bea46f150ec1e75513c9ed757c4a44ffd3ea71bf74c8b2ff9748b5ce0bd74ced2615822e8895e892d55ed90475a2097389f988aaafbfc483e15fc5b7b200c03d3a4723b4302a30ce023d4d5d1b8f81f7ab2e00a8b80b1ef7e98a6c2d2f00d07cedc260969c4e82adf154f58061f310e6ee872d05db5e1b59c22335c691caf471ba62114d0409e18daac83ed245869c2e7a3255f57db166d35dbf46abee21862bea73573544f5cef245ff3826edb312692b130f2e5fac81668f8c4ce826e88108f408c63a517ccf5756f6445f0d79913846fb76be66bc73e51fb500da8fef2395b06ad6d5232557719cc6aa7f7c24d657ccad1d0ca9e6bb0e41bb30d150976544a03e0d56a8f934b4d5080a8bffb7ae7fa862d6c7388557877f5287eefd96f04ea5e0c99c087d4aaf2705bf565a7693ac3b7b5bfdfd0055590de357284fd7207954b35cab9c124db3c6e9027bb563745ddb62f9f6158d53b302433875ea07a7166c68cdf2b038dc1bbbce742aa91fdd2b8d0e2386a050de75d930cf2edbb6480fc0171d053257c8694a572645a175b09c958656476213edb718d6960f333be256b39d5afcdcc6e54976265fc927af17272a65c00a5e156c2b985a5381a97318526a501ed72f01a9c76b957bf9ceeb5a1b5268b2a891e6d2146801957fe6ebd3f4166457b1a6d558910b31a5d8274f3ba73396fee54713be650438de04fac727fe4e21bc20215e8d1ad45de62e932a3f6eaba31969074b84b56e89e3cc4b22a7b6f24b3db706d6dc1ba9cef7dbd10a1f672abfca42e4040b78b2884a2727ccdc16eca094c63e971db4d5be5e7c8a44e0287cbca56dd598c8644243743e641e9096923c9ae4ae9526b71808b7fb993df9e1ee7b9a2a2af711ba0b98b0f0282b756ed493cea1de3c78e3ae144ef9fbbde5e6f988beef0b9d1c64945d299db259c5a41e7017c9c1924be26aef8655f33b341d62c901611d2de1bdc5bad4f6ff7be584ff63156174c65a4e45b45ff4271739f78815ea965ec9ae1282073ea29db5672212d131c1a01103b547c354bf3078742e8ee1d9b1fcc1c82eaa980dddc70af8c77cb0d008e0690b0e11dcf6a215d3f01e2d4a270014c2d78e5f86254259c9c956f2572f95cc79a1ff75a7b7297ce72f0c2493caf9b598f61cbf1cabffaffba0a381b036211ed46d930dbfad24079f8346352821d235f2c72bc4f38b77f76714daf03b69f0229a07ed676179ebe81d4c69a073f44adaeee171a17f6119bd745df37dfb3f0a26407556a4ac367fe5e93c6ba072bb23e73de75521e95756ba9a88fdefc26d649c42ae5f8b4183ff0b5f30bc5fd8371c6bd31fde2e9402670d66690579ef6599dd652fae600fed26f6a12c0416fac1ae7fdd6364e86b727dd58148b4f97adda2e4690ec4cd1041c08f0e24d8843712d2f2701da35d47adbd2d299ba203ef16c2982484b72a33822bbaa5a588aa037ba2bd86e87f8452bfcbd69c858a337946c0b24897473d8ae07962e589d8879015c693305388cea4a1cc12aa63d3e8e3f9c39500ff7cb91d77bc48888d8e8252deb1bf859d504ae2df6b174174bbf1c27957d107d861e73317e146a1342c3f8ec0cf9c961df3bab4609d3df4778dce4434d9d8677ef20cff00b909bb89a53caf23cda334f81cfe0f8c1a65a24a99a71fcf0d6af7af719d94618b426af11b257a836203228f035b76bc3191f56ac35fcba179ea85582a8336c99b83706ba1349e58561899a1be5a4148401c3a82bd874eca9744b9970bcfd21dd4d5aba9d406adbf5c2490eed1e683254933a82f461bb4d529d5657c22eb2c66ed8be1237d5ac21d017ff83d199daf848cc8d808119d29909907789e0119db0de1a3c123fc6e37dbea417c3dd7c3e7a3d95a13f53cef352e79a8a6c0e50d69bb23689726bbd7621591dbc4d160e2142de155927e3cbf0a0bf24a8de0877a8d4df6c2f83f5b396e72b1069fb012395a856052b8e5cc21e28d91afe8fc95af10ad06a5a03a516a1431c5b63df7dda6b0a4747108e9daeedb95b2edd21ed038e67dd6bdd741dcb6c921839998879ededdd4968bdab8f10f1654d34b0eaf2d3a152ce1646d01ea16e608a209a9d92625f3f8bb5105841e5e5246628c17f907c216c192d5d34f60c0dfb0660f6357f42f00f556dcec59d29f697b3287b4f5478d81cf5242a02b1136f9c9030554c36632a32376d6f78ee03d6c26519383b86df8f030e4c17fa82bebdcf1fff905ffec08ddd9b4df8ee80fb4882492ef4a5d1efee7dbfeef42aa1609d88ea52a88b4cb2de288819c6ec90db2f1212387b47a23734aa4fefe86783015e225725d2139e6fad172eda93056d99129020ed88a2cb2325b032a0704bfb7dc38642946bd1758343fc50959f884c83476e445b65ffa7023fb715e1b51a5b636386a94d03718d4edc8405110455b65bd79171e7bef228970d03787f4b67e69930d44309d908f847136091604e8ddd9fe5f52694e23a5d22845253f0db29fbd41aec8b11b23da57a33b386057caf5f4432718af198539a795d6cd4e2ba4ed97ac962c94e99443d3ddb9261dbf2873bedff3ff8f8b26d8f01154eb6b6ff7fe9cc33d1c6e795ab2b1ec5faf7e1fc9e95174a6289bf4c14dc4b68bc56829fb5993950ddf96c80ab374a37ef315bb4492b3ecce1db0d2061d46facd36e717d9998a4f573eef941d48fcd7e8c5e6563b975125ae216aafde14f96a8d551c0bf4c1c4e69e253570ef1e5e96f70ab8f2d87ca6df7eba3805c3e0c77a395178dc15c5f922606ee3ceccfed139e027417f90e7560f105691a2e8896aae220d999fe14a8b2e1eeb43eca25482be480c4f4113af13a98dc5d5b621a6c8bd10f0f6c0397dff838b067d2e6e7928d88801428a95de862fd38ebf2a13e73702cf037256a8f55e3a8e9e683198ef2db77932308306e2d5ad353a1fca4f7ffeec8eedc7f60a2ac75a632529a540225511b88208452103c9c682184a61f39f30bab40f0614e40f8130bd2f0f0cc2b82902185c0915ee8dcff728b6d7f7fcf936477a60057a11fe00e1f50daa69ece8202720e858ac4f38c15eed3acb55faf69e122066","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
