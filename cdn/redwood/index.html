<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"165debfe713e73eeca0b757de2552d63b9fd918067f15d69aa3b3a4518d16a4ffe9e9e6bbb6c03720a1b33e06c096f723cdc64db1f682c2af3676f5cdbbe415fc4d0d9c59df77b51d4c4a8155f7946056842eb3ca5400e87a721478c386a7b81cdc098df93263eea66588bf9812a8e171a50c467b67e18243b9b0f400b7a133c6a16968e57b5ab24e69401b922497213a1a3996d18deeb41a83426966b5bce2185af9af5cba298be18270eeba5ee06d0143a401865ae3e788b3756fa3871031664a2e1425705f73571dc3c05e8aad1f4bd87c754cef1fb4dd466068f042a87faea23c2fbc45ee2df64ba725960efb705dd5354a45e1ac6851e8f354583f9b7483302e23555708e00904a2c3b62c01b53cb220db2ec705b3e80e9aeae3844af5f12d13d049c0d0a398344569acd4a2bfef9d2bd44f7753a5f1697fbd537928cada359563a939fb0eebde5124aeb20c6a2cdab64073efd48111dbaae0a82c7a77b6b6e1239856105c9e8e392f806f4b199dac0b2b14e3a182db79c3ddcb482da55990c734d42950a57e834265298659e65c372993d8970162249332342a03fc766711f3fa586850b77bb87fdd867ce2c463364a1bd2139ea4d66e7bd520529173653bbc941852f1c2e40f7cdbcf9fe5a5ea616f2c7f22e901eca7802509492ce383a8376e5429450717187ec759789aa8a4fc9f8948accf4af72bed1f22dcf6fbd318347e6972525f4d262f00b91fb46fc9a8db0378698614c52cd79861b8f516ebd163545097595de5b207c86ce17316c29c9ca5689d5da91e9cb7aa089c085120cfddb35fb74cd57224f732d8e6ed84459d610cd844c72c8a0b4af1abcad740d5f2a43778d119d2dc76927ae54433edb0b4ad39c4363d01c44485038fe908de3ee9827cd7cfa0a97096be564781e5ae9a387cdbc886396c7a51bbec12a93968c8a765939b105ddce9b9bfa608cb992b242f5ef379f4d2a92daea02ce236db3a431253e643e9d70bdc8ef29c9fa2d535a47d6aa2e00695f430dae279a0fd3012ac46640b7bf7d7f78fde397ef1cd6d98487b2ac5c5625e30d666c923bc7096d89f4972c1dfc34060ad933fd03f719355b45d83f9ea263549ce597c219903f2c60e6659377d8441cd246505a7f1584ea6bf9a1c13986ac2ef4a5c336986d65dbe78f54d24db24607cc7d2c6606532820c6e2981a6beb9af17a342a05437e5dcd8882a777cc195f3d1cbb7533d0948052acd3b990f6f7b96b8491dc767a19758b342622a968bfc2fe69a526f9f55677c679e8a383d2f8ba2ee28d4f3367e575e348bb56606726c2de6b574f6c635edaa6780aa4ca39c28c639389574fa9567c85a692f13ea3f30e7370befaf3025028886d139ee40215c4202e3fd1e61db148cbd99fed045d7cd96fdb138f8d0fe14727c2c91a088f4624f47c503caff81a2b5986f8a343d367d31c30661f828e53832853e9e1e1dd00d3fad78836db7847731a4f1c7dfaf729d1ca491c8a255f407ba6945ef5be3c5f7e03fd0edb58d6189116f2fa15616c87bfedb13d633cebd9626199a00d86b5afe4123f04337b1ee8fb1bb5f022e1be375646cffb78ce184d0efc2185c99c944750a0b06369f46c1300e73197a8081779cdf43e163a8f131fa4731f06f99b5981c381c2cb788a081ccfde6dd5bb3a6836412d582609a5916801095e4320059535215d6cbeb4539e01d7a97d55157d28df753edc6f5dee6a9c18cad3dae9f1d6944e5ce1b34e408f21bbb4255fb2ab145bc5de2696541e742adb8348fa32963bbfff38b842a2fb7f2063518c895b56fa0fbd9c648980a53c90e00435e381edea085b8469a1e35636e9d8c7d03e260b82fc5f2d0390bbc342002ff3d9c1df0b9b59b516e44b15a02d54eed18c4768c37ccfc62982048fe3b54fa1a9457b7ea9da3967e288e8fe34ca6d43fe2e6a383cafba23a699e5d16048099f5e3b22bf370d06ff8652b80857e340390f9c4f2de9df96b46ad24874d5140454be82c11f76754fe49b8b4c2433bf9be18d4fc2ca5a1f07f09cad595ba386d39713f9b519a158874f63968355c8c737bd1542d53fce809da37f33a5fc04d3d5eba0723631877cedcf64f507cebf01a0e371c53f39cbf39899e9cfa4f9b0603fbf6678270a30f327187641eb83fd3fdc2a2d7757853cb04ed4db0754a3198c50ecb1afc1d171450fbd409608db0c6facc5d83633ebfecd4cb6d2408d858957c42cb9e7fca96a271ed75e66cc0e1eb2d2afa0d9ec0bc95d3c0a1194b7a0e9726bcfdaa20653f615267d08426a22e007a8b476f8235c510e049757dadae323da3d8a192961e6ff49ef121cf111d9a6c59ff85f06c526ed15d1c423b9915f83b97598dc9d43001711d0a8cb2630262b3bf1545f6ae189ed9347e03ef2b12fca4392edf1a9c211da6dabffebfefd21cf9a9d4431b48fa850d438442d40dd36c1da5341a77ca4ea0493387cc23b5628c14a061b2f8fae6edef18a9717dd0228c6b57fd8eb6c3de1291496c71353511a66ba6e1091f8395924b438832bc9cbb9e85eaf899d6b36da6494d40f05d876bfd8d38c9feaf4395493873d744def403483c961fbbddda6c72fd260377c35554fa8ba689893d2a5b89698628ba91f4697cb096169d459d7c45ee8e2b041839d1771185032ee937a92f32aec692e65967e4e54afbd04ffbe61f0324be00b95a1981d22e511f5cfd6f5143b8c8875d110af7fb14cf5afb12771ef6f7f143b2d7c6327705b1acc8a603ff9bae4a66afff58d546af74e268e1b40b7eabba171c169714e5124321ad2e81fbdf3b14409c031a186c9664c4d68980cbf678c7a16bf4cce5d9c12ebef51034d240413ce67cc474db3a1bc32ccf7d7f9461f848fc966c41167e249526f48c1be3c46dc00318b8e2150eed53c3f411e8fe571ebdf0315c0cb7d074e9146d4ccf761540d637720f5e1dc5457085de1548b539a1f4d4888a7a01bd629cced96f45465ce72afa5ebd9605cef5b9a7c93a0cc6045917114fa1756623495a256e092cb8777e905d2ac98350bac60cefd089797c78f0585d67f9b78febe3a24d653fb7089e09db1c8da7500eb1bd5374b7986893f2af4adfcaca3226c676f83ad0f38aa92c2cc57cb087fca1433964bf318d839eaa683b7c8018a42fd0d984c04ec3ee70f3b8866288449b71d50093b2d614bac6cebf190d0c50603045e4897963397dba7822dd140fb0a495cf88cea2245de41e21bf74c119cb59471f8286d6f319049856f0923f9bf901f66bcf53fdfdbc86e7afc6a4586d290d7396dfa1af2de8cadf909589bae71573e1d673837ffc0010e66f879a9efcd8600d888899de87c8dda422f7d1950e85285a1cdda7d732ca0d71d4a89fb2f69baa7e5437233162f7799fc2681c1d54a5f221e411a1016d4fb1abb9a45add8fe814dd2b8eac7cb390857237919e3f184edd7144d34cf1957693807580f95915832b80e4b1f829b972386081fbb605140234eef2d1c60189b0d5eb4199089c6a31fd9b873c1dddfdaf123bad4898baf4ade79272d5ca2a997f167d85b62917f9e9f20e5d74b89fd9103e4d7b9031e93dcd9bf1edccb8ddab58ec3db93bc738002f12c55909ceaa14d53e169aee86bd592280990c0e7073967630ef342fb9723fc8ad548c064d01256249d6a143016591dd01bba388d8d70030f1ea6d0dcc03de84117eab892c58ea231de6a13105b3c01cfe8c8bf15239a0fe1aa88ad490f28f34c325e8c95df87cb319dfb6b6572c56cfd801733e60feb95d7dbb0d3d261227bff5ef4920e9306f28dbe676cd699f2a8e614d57e9f3f484f1ef7b5c643b52374eebba2565628dd47a1e35c5ceb947eaa3384da02ba5f7f0dbc1cfa1d7b18d9729d04827ef85de14ae4ca242cda143f3955030d2c33a4be11bd7a6f803acbf0502774b579e396a30c78611e465b69cd0bb26c956024e8a0424ac65bfb5b1012f4b52bf395431c40e54efa2a37eb22aeecd189b95a99431fcb32eda810cc5f45b48b19e9fd30d373033f9ef61761318742ebf0b098373f63b105f85369768f1f4700cee8c66224500d76e5cc2e26d9285c21f3cf3265a4f1253fd09e4febbc4c234c7077d3f9f03246567bfa52c3d7994ba4a256846e5df3538da71e14bd2955ba7f41d89f69ea4f260c2bd33604d3c390077f5916ade12ae890dbe8404993e304574938122b62b62fd86dee60b910a85303c31a40ddf6bc3c5a11ac4ae3ac815a739cfb86b11eb2b6874536250c47345d53a72482ae4d33ff5b9cc13a4fc8bb7a5ace91a9daf863541abea20e3b3976ff49555ffbb7effa5c6f1d66be976cdfe4fe8050101c7ede3bf220b7b72f05a1fddd1586ef5f207b832fdce134fd58fc9efdbc649f4b59db23d267f551e42b863d779e7ff4cec0c0855d5d0ae47ab9f432ea5ce73f9c95a8547a2a6ba38c8aa7a9e1d30ba7271c00d5d75026974958ca6987be18d1b185bd921e24a9e026f0f1dde3e787e99e16790969f1a9011649135a00f8ba59fe5a6b00fbad49aa7c1e2eecf9f482a5ee6e71a1d55451038e78bb04206e495eb6caa7253359a51bf219814f420a6f68304f02239f3077ce0c9af6053889a56e9b3a311a0ef63b0c320ca35588528577ba5e9def9d3a5ce6f2233b466d947019af8b1be4816905319a06b150d26c9899bab8044c1f68b88831aa9bb829e4fb6bf6f2834e57a3ebe421226a840f3486d4d487451ef37443894f0bc517843563bc8e643f4bff8164f3ca5b975b6b20b781622289bc90096f099d0bbef440a44b4b80d892e1a67b2301f6b4949e17066da2bbf1259038f922f3ee7a4794e9fbfd12cc55d10e51ca5999e4e050cba64429d2cac269520c183e97dc4e7b7a38288e9f8af13602773092be65f7d996593e1ffca224eeb581c027a2c543f53b64cf1b19b5732791bb0130a299b68fa0abbeda7ba4f647ef00b8338fee517185c3bbd788bed625d8131c3ebfc7d8bcf49cc6a144d2a7f6792384426d5f6ca5aff33f60b3fced40ff7c26dd432e5c6a085ceaec1d46ac0bab8b4907eedf0f51d12f514aeb4cf7755c2f2202b294afa25472a37680fa4ccbe6f1db6548fb39140ddf74d8ffc516d19bbc7124aced424acec39ea04a701e5b3669f7b0bfc89ff4a394aafb6fa1016840070163aa7bed09d354ae4e1a3f1466cf1ac75b99b65becec7a736e4768c21665e2b75d9fd280e1043618928070502d80d95208b28c91f2ea2ee2041d102a8d6e323aa461da3be79b40873f3a6886e712d87c8144828abb93894bd39ecfae2948d633a43a263351ae2d61883dd0499753be6a4dd632a910b33fcbb31aa8621c97ab822f46107f382dc2847f3b8d835c2b696590b2a4610572f774b499d3907936d34773c4abc9561cbe5ac49f1e8944e6e2590de6ac4dfaaf47b9863acd846d53a712554c2579f813be71f7a341dabb2196ae844b1edd38cbb3ea8696db58cfc947829f668c16c1c2a0ab2938ffab4fa034e53166d23c8aa54121ad5c0be4901ad7f2f487c9f3751738f300690fcb108ae9e9e6d92f5b0d8ea176a559b4cc79cfc6bbe2396b29417e4ac0938630129124a2ecc917ad2e82bc2229124c298e3c354c1e855a7010897d535cec60ab1caaf02cf4c70fac9effc8c14a41d6d57c4d7c6bf97fea7ff46b3a1d3e9e68b0021babff590ba0fccd055b69697c79f1e441e340a1c88c130214bde1ba225dec0c6eed5aa7c728d03170624bd2a4c130f476b9351e663a18e23b5c4f7050c3dafac281a1da5a7027f9cfa52c52d53212177deaf15f76e27cbf72e4cce4f00b86b74a227c4abe9d16199515a2eced3f109434dddd8269283ad1fad48087243ea44f1b83b4469ecd591adcabd49c383bdc9e6d1b324e18063960c06df0cf65b4a2416c674e500ce07ec06506f6560bb0cc336e333a300c6b3282c3063597d3a993d5c97023c129530575aa44434936d303e6755e1cfaf4441257230a6511ff6296ec6b38e293a25978ba0d2ee474043aa299427a49ba0c1b36a4fee8f14e6d7695b3fff1f4b7a17bc059d28506fe36cbca8e397640b7e3b2e57c353fb1d89d977f30794b797c577fafefccdc4e1aba0fa66741262f5da0a80983dde7dd4f06ec9a1d8df12265b77853b7d17099371a6cbad5031f12c8a5ded530cef5225689f4a09f689662a3b259ef8ad3b74f646b81761bfde4712733aca3031646909c04e63487e920ef9ca2a7d5fe58ea7b782bfdebf0dde2d1bb7eb20273e437819d2683a2b464f5eddff249ad07581cb5d0d80b4c35500cce50f5e25918c5f12a3c8845f6c9405e03d177e69d22b58d14c5f6f1fbcf599aba29d447e1022cf924fd1328b9fd71f64cfbf234b13705503928933768aeed7d5b3b2f140834d245992657823ab51f94924c2c5bdda413c32712bd3fa183dc407945fb14f412f7254697d29e18f4e26290184c3b073203ec6ac33cda8ec2a1cc17fb735dad658629a0a8b8645893719a1469c73df54870e55981ccc2d7db249a9cdcccc2be2b781d9bdd596c089e42a953e6e7d21b15e6b8ddb45eb5295735834ab1e8aee7304fd56c9b8c6b09d80b552e778a226439457bc3d72bfa556a21184929c3c25f80c5d511b59fe2f7b46a9a5cd93a73703d830979dcef95dc82b2c83b8fc8f633138769fbc249fe030d7cf44eaf03c6658282e2649c828efd0cf381d9f6c73ab41bea2203dfd9aeadeee702133c3bb927d822ee7e8253907715e465686b29dd2cf21603e256db886de1af3d3578bb0beb894b029f62cf263e996463c83143eddbe3a402c42f63e9fdaced5f1e78c55b95a9dc1f772e5794c57af0bf73bcf138255011b893a24c82acb48a65a9f65b2aaeff49de942cef7124deb3e3f21871d1a690e9db3e75b3f2e12057e2722fecaa192284447379be48cb469c5143307c1a883bc7cd072721d1c5b7545acb0a455f77c7f7b929acb4ae177babfd6560a9b163c3eb00d5dbb9ac0a088158abc06182e55e8dcabadd887362edcf6c83835c755b9767dd85de40d8b6841670d54e97d94d0ad560813019e7f582f2e2a2b4720fecf4444b03f6e38c1eddc89aae925883438b15ecc171f9426b4234b27d75c499f7ec4b35b10e99f88488b0d87a17faaad69fd5f936a50902255ac87d22eae7a1c0ed28fedf1dad402a2f8aab68af95e7b9abe0d85626032101afeb94fcc2236e247a0e10f09fe9d2e02379371d150efe43d8257aa1cea811e4c20f8d4189d2d2061bab1f1529b9efd5a509dbc0bf3fa2c59514bc856a3ad534b445b25bb53c0759f60e84a25631790a5ea0bf21043b6f499d894568983ea32e556cba5a5d6fe892ef923e4e2c54058de8962fde206ad6577cf5785387c628cc9e1afc9ea57626a81a0dd6167c4b3d3622fb1bb965d7ea80533a40c3608d0620504c01f92277493e59132f28e791dc15207b0abc415ce993f2c6d384ed4141c15d32a73312f98c529474a4f14f53c0647815594100376daa392fb5a70e662820cb173ea3d7940d8b93590d326e9dea7369dccefd71647b8dad78cb8b0da03e12f7090a0c7e4ef3269ea981580c70b64a24cd53abae85b37966077d4605fe3913cbe7770cc77dd595f8d3b3e4b72e784ac5eeecd12ee9711505bd4b0988050c69f06566f919f0b1a67a5679046b28eccdf2494fdd6fe50c0406552f98e266439e8104acc98c4210cbc77837b55224bdbea7fbee63bde0fe3e87ab27acb440af90287c1bbe043d2081ea11222032ed7d546bbb65e011330acd76266a2d9cd5ebc40fc577c097af49e1a9c74951198648b4412122402ba49a535adb391bb446dfac165f0209ea3a03e50e4ff1dac00f4d1b58e3aeddf03714aaef01b256e776cb66b4cd9bb994742562dbb159bae7f16bdc1bf5e9d566923d0c2424f0120a998ab9ed57a43a7d2fde2c4b15b5a2ba20249796f8df8a831afbd28a1c112fb3a7b8dc145282e5c6d30d1dedb82ad8de9a1ad96e22ff85d2315fa11f547255cd9657fe0f6665e54e6ebc73fe664199b16271211aaa49936d90a1bc6f72c61277769c247ee5bf797a8b660e4b6597b822fb16233d4b7e675291b0ea25f73ead7229e0e3213722715e67d75800dd16c0717c6e01e7a7a6b4d0a75216c36b682e9cde5340dc4e6d13422e898232296f72b6a22b430f7105969bed47db26d1ed48420491ade0d7c4efa384aabaca11d7e8739285afd3be9624874c0e826212e0f98a8d94c684c0ab592ee4c5f63ff8371419704cbfc1c0340dea0ded06d5ae11bb4b3c5d63a48a6bbf5af2e5e4d77f528a1a9386a2bbbd2277a6ca943b300e90587cf31d482a9994d8379b88078210e0bd9f327a56818b6c332990b3b3a0ca63bb8f2c2326ff666705c340615c38d1543d5221e41b9156ad475596b9afad8878a11fddec8bfab14bfbbbf7c97fb55b93d46e563e21411d92749e15b6ea5021d8dda7532420ec5f81b02f882c345e9e6b816e52b9387b594bf15da0a7476a446ec6409e5b59bdcc87988a879c7afc08df9e20b57dbb7e5f86d40debc28e5b3a415020ad953901d0e37f92e55e659c89505e12bf1837c1349da247b7ea781b6e6a74d362b54d87b356f5cff53852122c2dce86b4291e9a0ba09bbfbc5ab223fa5573beb3e2c62d8024092289cbd4cbda42852cbe9a9e2cac34be9c1011f6b358b0858ddcc4afa173f1e94a7c7ca7924a5ca442dcd74efa4075a452bf570f3cbd4bcc18589d36e892d1aaeb94ea3511faa1d3ed9fa8fb4b5b617a51a6db1aba4ecf5b407ab33c722e0ba2d1f726e63bcd66e92a746328126cf9fd0667998838292dcae99cc526777716a1d0b025c3024e7123a41be670cc0c1f1dc3f5f7034bbc5c28ae9e8f6d1e57df29632bf350003651e246425c6785fc66297389ea66f8827e5fc5a98678e1f0e65ea0af0a48176e6f4ee344a43db998b81bb98e379832a502b0693bb2e0cd082ace0a7279d012f6bea70005ebcb9c939103104d87e49b24f4e7c82f9075a86816df9ab4e1d9b8819b1b5b0ecf63fad91e302ddd50799279bdaac26a2593fb041a29d9bf21e84b0c11c20c4349418851186c4132172285ecf7086e6069d17f31770387ace7e6e9fe64395816b72823ac2ccbb43483c66da830b8489098be28864ffd79b924f6cfc783bfd02986c108e1c578179855f0666e088bf20196c75f69b59a56438a555a8bb0448efb1b67b53842f94a8a5b0d5c595d68c55341f7c48738d1b98620aa28ae3603ed343db698e06115c836995fc77cc1f3055f6996548fdc832327d54c07af1d5787c867302574ae72b56fbdf82792fb9a0a1249d81deef6b577fb115528b399da597935f9823e7f33bcc182e879fea8abd1152e1bdb9f8a88248ce71436285200ab0b793a2911c01676be21b80379a3f615ee757cd38738811db1720c789058c2cbaa5f1e6cb9182af69b48a0a13e81d5d3d7d3ebb4b9208c556145992d78591b6e2bbbd505a59f9c3b0341e1a1147cfcf4bbaa79a84f6dbec74e5bbde4cb1782a22c7fbba12ef7683178bfdec8104da19f59cb00dad068af450e45fc6f36393c52335efcca18d03724e001491ca72400a2db7cc4c8b074a4a9ee89056e53c6addbd2d0b8a32c04e1b8f1b15b7e0e077fd0489f8087d3f1d3bcec949330d8220d0ada79330e8364cc7b7e9c731bc05f45b9773617a2f8d0bfa528c8226fd6e684f70760292e4076bf6f51862ffd1202302622162dd1a02662a37cc4fc1292f2cb0b3b19874fd46811da8bc5828ea760f27e727d78db8f2a90e98dbb3f2134b1d02d6b5f801c16cf9601fb9b0ce2bdd5df1923414a53e76a34527f2a925d3690f1b8fcbf8eb5b150474df74555a5986a073529610230849496857ab7ad94e9df1d5c5081f5f4a2aabc4dc755aae426fa8b8a87a80061c646a986c57d121c9ed002c187f80b91f2ece0d9c1f536bb7bc706176d91a76aa22fd738a1bfc21eefef69eaf8f24ed1dcb14407a31ef08e28a078986cdf6e48264fd1ea1717be53945712c70073c4ec63f77c36012e70164bcb26f1dc50898fd5969775424b545cee9414bfe3b7dbd866a9caebf57504fd472340391a273bbbeaa63f60e4a6259437d31f98503fb14e92995f506fbe13b897b973e0a87abc0a287760001c427a542fb3c5311c1434d67c2e1125fc4c78e3208c1545e8cf0ec61c0a90b2ed4b6050e3b03c9e35555c5c29f27a232bc58df2f2cdfc71ce22426b68e89932ca89a70e5d5b6f66f82eec3220ce680dbd818be5a4a7f79d4f1ab7c0a7cccc1ce5af4cbca9b9f6793b4b948a2043b29653b58a9e6ced9d4ef61c1d084fbba9f4e7214875a1d85101ad01a5f517aba6cfd17f8a83fe96caf1451200a867e4d53ceb81553bdbbdad6dfa11a2baba6e63ed317849d2a62614245b81af8600e3e4346d12e5fc9700705f6355cadf49be562c487d7e932b77179c29408b8e28995e48b49e51a809517b48ec281d7fe2d9603bf727bbdb7c4403f9eb6626b42e55e63137ffe2d11af140c3fffe61e1fa05b39db5473c325952f6334150dd2d13fdf1cba932a39d67b2f210de645404ced30cde79662c777cde43877c009c68f21df1d975762e5412a873677a4424fe804484369e8cf1c69951d58ee02f239b98c0f6b11419d466cb046d335208c5c482224d0c3a2f2a17d0d50fcb38d6d87d6ac9e955a19d8ab7e64ac80c2d52bc2161e7e669c00fcac7613bddf004894e9f4d7528f9865cb60911c6194fbc98a35e724bae46bd996ae0876b5625bee459f52153d90a1b4d8966415608a61f4999c990574d2b9e5971d66e306241cd2714dd2ff582e59d0dffc1fc835b35f031587d93dc26d924146c993a8dfd0ca377dc63ffdeb216d59563fb8a74fb28e28af50d4533ad68fa1a266d18c88670f7b02a48ccf43c6c57e64f097723416c00f7f3ee6dc6fc49bd7fd05453da131e017aa67b067889abea8c1b2d76154959abb610f825935f9c167f7da5fe26605fe6f442877793c71e79381044b62df52493d5d6fed735d4d0bf158ac84adf36bf7d867d16319babe385cbfd2fb7c5d9c63416fddec97c34fb2f89af066a68ac0e7df88143a0ad2b554a7b6e090e5ac138e28f33d584f984df79aa1f267458fd1d8d7cfbce794bd9dc2c57359de1221096568f334218a434f8e6f473213f9b89d40d9c4440128ae4d58b79be584547fffcebbb2445ac0c58835fb1f7998a11f913cb79080681e23338e57787b67f9b391a83cda0fff7ea957577d8240103d3fb56da7ae6e6286a454d594e7a654a80120ca173024597984870aaa5a6a5b2935187a95b923fb51a04adf1682c3bc6c100027f972f67b1f58a3722b399c7e72d51674791168f8430eb9c9040bfbac2024c18449ef584755e8af087fa19992c48465124479d640b2db7fffb5b8da70fa9eafc548796aa9a6d2ce0535b8a1cbcd7cd7e2498f5b29f5d3644bb4eae17244ca62ffb8a087f125949c6b75f23e2ebb458ffeac5d6079a46f6809facdf444e3c01da885b97dbc3795442e972d5b5af29be33b2b7d2a0fff2148ac7d6fe2e0bf635ac469d6f2862875c2a408d28094c645787fd956e469cc409e201dd03ddafc3e0c77b0c67183726ff97ec0e440d57033014bc1f9805f74aefc6ece1a89bc8c4c4bfa3450cb23aafcc149ba5163514e9d53b2fb1e3d5de78a51174d7946c236612b464e2f94818332f1697fb1a755d8f07f946072b839889f38c8abf33f3cd74ffc9d376ff0bb86e96837fcc9780658ed948f2267d09f299b199cc79d81e89866b90b82774b9dfb1a0cf68301e1f0df7dc1ecb136281870cabe1a7eb201215599dc5abdf5dc9fbc8d7d48604fbd4797b2001ea84206b49b58a253898fac6791c9be23b90571f3e14c66f18335744962649b96b10fa924f9fbff23da6dd9133be3a33e35f4ffaf157642b17d92ca4cc62b87d7ff69d717283e8d377d638f3d24e28a39ce045599413dc6554a1d08d736a05d0551884d6ebe763f4f8dc6f90241336d8f5118e359c24f8cd5e87c5943384d07c2c655552f7537208284bdf23021b7415c6b7ed9ae459af17e0719c4441b41ea7a549cdc3d21089989993c6f13eac09535a5c29affb80fc07c7713346009f817d5b2a4ab8012611ab0efa0fe03f5d19725e67d97d96b1f038f21ee1b62389ed94c79f0931ea8c56a50c6fcdc300df580e77720526fa628a542442bf11566027801d982fdc5f1f98e68e7bf0959ae4d6f020d501a9d78eb112cad3162b4fccb5176150532ed39d75798c8e83062a561ffa3cbda787f771bb8ab6e792791495812c4d1bb2cf3b4a6096cb6e5a6190476c89c7b32603f5e3f7f04b7ce42df566220240155c4191fa446e769f6d0da8547261d266abc8f50213b0721192ad422e84bcc90871ba0b4139b87077e083ab802b66c01e61b4b1a77383fc049988bbfe4d2aff474bbb29a927893b63ff0268229432a52ad0dd7fe3e3c6eb92354cd808edb5e4ed0a39e97ee9e3f5245f0ad4f16eb119f426a0d16404803cd2040303bb300317ff868a4fdfd983e84187985004cbd26e111d6f2fd91fe750c7f74e8592d276588f3ce6de33fcba8650923b4912ef6799c1281eff279188963943f00e6bda984f3f486aafb555d4c17a264130f674ce0bc5b4b255ec084cb1c051a8a4edf193d498d9b88fbda40ce2f0f443674e76a10eea298b6b75c64f646af401e3cd518857247e80829990a45864c90867be43484ca38dab922be93e45c1b7adfc203b6788a02490bd6c5fe20dd092d2098c3a2b3910a9338fb12773f02cdee4f57d86180bb2eb24e07cdda9d8ab35f4ab0401cfb2f6031370e65ba06c1de7025497b06ca31a6a343052864c8e8623209291bf776b68c4ff5a3c4963a7dd70390485b4160a36b7a4a500ffd37bafcca011cbbc7a3d94fa3429ab990321020fd8a33366cf58c752275be9299a3d8cb5d2054fc64737c06f4087b03a17eee0e341ead6da7dd959d18d437a82331ee18026fd9e0469ef752a7023d04b17c48ee6785a453c8d738fb0a0d4192d6d7699c6b20710ad3e0d99baea044496d69b75760b803841081647ea6439be0a5914ebc8b6494d6b364fe9a53476932f9800e30dca72c93cc8a333a74c968b79e6effacf1663a23a1907caa2fc1bcfc531f5a33a4bccd7bd0c68b47bba766de2aa9c43da56861693b2ad42b45e0bec87de7bf3cb5901f92af979d60970c6005e976da6b004bdf84748ff031a613c45b76f9d3169866eda3fb1ac3548621611268b991ad955912b68cfd68ec6b6cc80b51d29dbf4bf5ce5643dfdbc72a45685148bdca464a49ca394c9588ebd8c3159d927a1a89d50c367214521a482098b6cf2d919c4fd5e113c5647b123ece5d11ab4138b792651e7801b38295511dd29f0412121730ef6695cde9411aea77b160e719e4a30a3cbfc6f0afcf7e39a7ccaaa3a29f9d379d0ffc7225dfe26f6bdc8029ea1f3ad9833c3a726603b1b7d0c5bb10b03b697f7eed21974464f938799a35b60b97856f3fd4b50ea0717b11bce782fe4f2c5eaa23412ffad4c14d2fe64329f5fe01075cc9015b9fa579b276fdb62d5e5d2379901dc7a732ab1b018fcf603835619075842c9a80e51d5bc2d29128faba1ddb66c968cafd1463604ee086e810b6d5067de6fc7856fa9420e90e99e111bc9cda04d875d932425d800bc78129a5d323140924d928a27c955cf227eaec69f3c5c9ed64f8ac6c751ae97e492cf46ac8cf3da766b07ef09c5bd40a2cc65038551af36c5b2f0bebb67afc9986d53aacca4823659f057d5986aed2a5da788c423bb328c8a7b54eb5524cf03dc117441bc6c57a511b6596f0a004981dbe5e0d100f78269b2822e6b85ef566bb62963b1aedc9a2f50c674a4eea1477479724f307ad84896e4d091349de84ec430864bb6aa02f269c56516b930db8976edc4e1b3be198b0cb672db1c1439a133e1f3543dffe4dbe2005ce59d4094344226a9c151943b3a94c5a2563854ec2a953eaa1436593c283c1f45eabf11dda4135ba9e4304dd33ef2cae06b0ab0131a3f0c332a72cc3a30128ec08c4c917c68baa6cd03f481f0ae974194f8f5d022b54cfdd78764bcb8d344cb96a8da9445c42e6779ef85e9c99af9ae0cfc82e0f2e4577331a2a582eca2a61b63d4bfc9d6abc3b1fc44c0b0b92b0ee999583562f62e5078cd725d6ac2b398bff8a491ce65346e9aec944e3d020fc96819c977eac701ae70377c724b44bb9b4e9eae6e0af17f1fcb178cbb42650c8ad7b8b6ce3dca0869ff6c084b73f63f41359892274203288fc488c9fe1c061f9fc7fdf3613abd5be879787c6cbbfb0184a196e8a743d12903ee22e4ad37346ff57d3f28ab5b3b3ba5b53e285ee657a294a011ee73d1ecf39c0538ab50a1d04f1f289be8fac23455fa23c9ca11fb5f9f3333eccc716d4c154bf9d8ca8108ecbf51ae8132eed8a752542a76677c7dc8a0204fcafcb05aed053cf5f560302a2dfdd91fbe522834830dfe662b6f4e53f4db9afb32ed54c5db574fc3fb508343236376c2d6eb3197c43c2d7fb555c0b32b59d940ba24a10c50c0e6f05dc80329ace95fed7859a00a79363209e5153b1394fecfae60a19e4be49b8fc46041294719647ae2ad59c49a61d135f2f1f03b9ebb2c4610a86e69034d97aedd23e37c3d6840ef44ec14d72a054f3ecf39fdbe1351f341a3e1f64221a094385a77090f232826668b7285aa920e20ecde8c5eca5d0fb37671bc43e4c6c7bc71084550f7562802a493a2e3a374ecc635b79c4a3cfefe7cfbb82bba88fda0ba3d082497617b960e468ee9dec8c717cece81c560cfe0e8b321bb03c63ec2a134ab38b6b57fd88f7a357aedc4e8a1b260effe1177a195705fc98bda9411a17532bffae0ee27d979dd195dec28147d416ddb2b89aa4730ff25f08da572ac25a3acd2ce1252ca5202fd26d4316a918d2f5c7b9125e4323f17b1fd479482ae27d7ab81b3965d39299972ddb222fc9b0866431dcfabcade8c5c341f6cf1367ed8b9e44f8581779bacbde4e54a6e2ac487bd4be6e7e6dc4f2866f5a3e28c2a8c0714702ddb52a2f96bc23546af7afd4e28ec336b17495f61f8f23b360aa2b7179844e2583fab1e0bbd23652d99b6124816c5fa8929431e22734dc868cb98494151861fb97f96ae063b666ae6810c5d64c8ba3040bc933d8a96dd95bc9bddca48d82cef5e445919a80e839e83feea56856b2ee0a7579569644b4992ffd51eeaae4e0b7131425526279c870d0cc5b5dd2954c807c951dd2196a8ff689b874cfdfdde5bf97cb28ce39debef5b23caf3a83acd2c84f87048ce778e6dd442dec0892fb9c64838e84a26bb0064931a0ed995cdf9f9bba2a77e5ce26893c1755afbb59db95232d8b2e10816d81d3e6a67324a8e9b238b012db0149107a9a0df201dca650cc6028a8de830b1bf3bc662880ab73777c27f45a91e62450d0a8edfff9eee2479b7464b1540f452d550b7273962f40b1860e1ac81fade7125ca76a7bae83b8fe0462a51f8d3d88f259929ec3b79243dcc3507836e3bc6260a5d5ec31965bfa59662d834a5ca8ab81d9c4da4bbb2a917ae36e901b94a0f908b1f1b9d31b7f9b69ddde8e16dbc4f916687f271dc36029d761ffdffccdfb90a0ad5f47bab960b67944852f008c5b2eb2f988364de7c76cadd7f39a5908e0b894efd9880bdcc98f9ed2c0037b19bd5efb291b1b03d6025168e0940d46956389b05002ffecee7b4cb4db60248b78753ecd588bddd7de57724d839a4268c36336d1ad5a9753369d3923106558878f67722ae727a934f9bcdcc7344a3dee81eaf7295540875aee0935802ce60855b9839fa55c298a35d50fc90ae3b069ebfbc33492e02d99be2fe7b01f301f1889044609e4d0336eb6bec8929f57626f8ed7287b3a1ad64e53e90a0fd345d50663da3eb5cbd792c5fb7bf21c98ab2e51c861ec6ff1c2a81bcd76769501f722c5c072f3e018d9c5f9d98268df7870cc3f3ed9177b1856f6d276a81f06b287d0626d7630ae80eda76e556e833072ad7ea693222898b194d0d8006619ba890e54c283dcbb21f4dd7b53a24b4ac513695cf3767d469e7fd3b03009b3fdd781e80cad4920fdbb3003240976f082d6f4b68a04cebbe8fa12409c6b60bb010d3b4999e3f3dee4e1320f701631317037ff6a26c679d4f32060863cd419c6c8aee088c8896f01b06a60a58a13a0aaa163c66945d335f044974abfa04a58ffaea995eca99a910f882e1e1ff63aa5f8aff94fa5a5e59f08234ad045bb7f2aa25a0572910e6f2ad0c8c2578ee281ccd7da16f9a104673ed167e2475551574f15f331140dba8daac1e7b80b61316595c17c3bcc9db06edca3fed1bd4f40506070b9c2c0189788c92f2867fccd72864ace7af7b3d00435716142cb453fed914a02148a53181bff079efe2cc7ed164197d0aa613040decd300682f8043c4f55f790ccffd566153f4d8078f8984b45d3c5aaaec6477b3b4349b1e08b787cd1465fd7add4124404a4245318fff8b1fcc66cde7460748ada314b9cb9c5bc26a469bcfeb1ea14694d381717c59c3b1a08fa819711e73652c077445674ec4b9710f5b94f896e712fd6e7c0817e5a26f16e47cf6fc0291a866a1d84684969efbfa06d7bd09fefaaa87a5d3e742518e26571adea0236a7ec4abbf92e595052ca8eaae7ed3d6ef7e1f51c298e722805ded446118515e4554fc9436ffa0b2a150f2fb0a4ca18bed6be057cca9654c1f4522f41bd8c9d44e360bb3e30f845bb98625cc6d569982734388480a01546ca1177425b3e791cc14162e3f165169490447c5d0701a53234549b2aebdca59c6adab00d18194ae5ab459a85a18cbc08b8b38db9e24e68f63a4e9f5fe152e56dca533d8b57198442b7c272363381dad4136a9b955da926c2a414737f1c36d8f5fb17f25ef3cc88d1f622d11e9e662c0ba7cb237ad719a7958d8641a404738dcee790e8f1a99ec06a08a71342eb637d04123beec5dfb1138c98a6b7e504ac79d45a712573ee15b3755f9ad53c4bad7fe018e643ad3a719d5069792e159feff833a74360989560fb4e17d56d238ecb40115016d4177e1e534ed2270e6d1a631c2a834bb948d2eb233c5eac003860a326cd9766b84850bea9849c4bab1988923e787d888ab730b241ead416c142a46d4b0f9507af7b1e6480400ab354512c9749c14dd47ea637f80d754ebd84f8e10ac221d633539f44b2d17f92a0144a5275016d2d7d548796e6a2cc56a7a6bbe0294fd59220eb7389de684d7bef9d9f04d33033c18362468a2ad44cf5ad47ad7a4734f4244b13efec92dcd36bbb8ef4f9b1242c0fd05c86272d5944259a4ca5c4e738fd01abf8081f5f7902f846b943142023237d25b3e58e260ed9bd678d78d5b1304f8eaba7b9e9aa2e5ffabdea5d7e9962859ded0d1444496a99392bd0faa57be8ebcd49621c38f465fabf9118364655bd4f78e02b3709a3c70d3179212fcd79ba6f83526340f879af9b580d61b2d902ab07dc304d85dcc1718ee06bb976bb0d0d9c078be5beef2f749831f3f1afc3518e4e38b71a3c62a9599d0f4885f96fb0a53045f295f5b1a180c32efe21d0ce9cc603ea154dd4754551dd190641bef9af95fccdd56958b02459dc56f1f39a66b42f3a7db191adea9edc789d74d3c91aceefaaf9f7a7cb03cfbf0ff12049586f21cae12231ddb1ba829192714e13eda0602ead5523dda7980ada7a157f890c2170f35aa9b97cacd9a0bdbe03baee02519dc6ef07049f01bf98368104dc334287c47556b769e454401bdfb1894e6f138ca43f156ca873d76cc023a94eb1d8184d005f2128ac34a4ceb2f306f0d3f669d8d48fdea943869b93bd47342648ba349d935b3fc1725f2c059d4eb357dbb59899be19b24e395911e40d221b949ab966e755215b74bcd213defd2dc571c126f47256b63abbd91419a3603319168fd6a6d4b7135edfdca43fd7d67a3c60e622f69fa4ef56086b23b7038583e0f41b08aeff4bc67274a07a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
