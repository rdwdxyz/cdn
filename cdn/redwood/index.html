<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"106e6ea200b62d29164149000045a8f68ac6ca1556fc09bd967f868678d4296b14cf1a14e4f6cbb2f91a474672ea14606bd3ebd60363d2ebe5dae3e403014bfa932ef3e56a1c39828f35b1b87cc1830f63e224375ac2f9cbbcb17c6a3d2876181793c0549386a162abc9f92471895ae70cad5ed28c699fc1970d35a049d6c607a25162e266cc9ac9daf879575989eedc4ed04eecc677f05cc8b15b793d95122fea9e0839c45869335838f6fe62d8447f4ad55154e289ee30dd7720eb4c0da3e2fc479baa26c4b422c182684a42db841120455350f310c15cb3313246a38f676ec59238119048daeacdba5743a900ddbd37ba2a6a88314b5d10584d2583224dd78cc6920aa48e2ac260dd451598994e1a9c8f326e45f67c9361d16a13ef1a764a03873e4b9126309c37162df1faffa2b4095d2f7469f7d51ae076726c1c018de1e4dd696aed24dc73796c32906c5eca82c1f59cb847966f2487395ab4ac3c26f47e5890dbd1fb82a41ed9631331f43edc6fb03bc593f6429dfb8e2f9fde32e3b657ac194128b537844fb0538a7851fc0ade7b500f265063ad214cb89f0850a554d83d4c6dfc6f4e654a128405af697bd17968ffd85010454a0f649ef010deaa0d930b6fe85ef1fcedda56a5f8e5ce27e56b85fe073d079e3d1094587032c59fe64f94098de38ad662081d959ea7cdfe71fb258ba12f6d6a07aeee6c543482de8206b7a4c729677bed3cdc1d31276ea1c003aad7b1ace2813235a3cd5d2f19ba37bf37930599d713fd94d266c28a92be284d20f5aad6e57493684c8a1abdcffab461d9f974c3838db1392638b2837e766dbe77b188f86c72acd5f792a91a10bc23cd60b462f3372a981f9c0daf51e95b50ec7d092f80be4c0d0208932de8205712e951cf9ab492876d82cffa43dc59d15cd4b0e0d092ba8fe4514f00bda10799d33b4498f4dc885847acdd83cc75f0f0ee4248f652eee90085b66117e20daeebc0d8097689235f474bd2aea4105c4e191de588fa444cc7ddb28e94aee4f7727fd27094b4bc78dc74e3e832b03c1cbed3b0f980d2b0a08875c7804cf121c929ac42cf3e44c7b0a475bb426805edff7eff318f11189422d302ead1d2cde6890c962144c9b3097d0c0e7c0e6c6efda12d176d16f8ecaefe68bf7fd87522b2921955f44bebb118a99ee5d4cd96241a9b242fec6f946e127f8faf92ceaac4b6df2612c1e1814cd18eff053a3986aaebfa59230ff84e3790419219bc4d32af04a051172efe73957da138dba0887849ee05b5418845d6d5c2f8ce2ac5a240606d503408a38a77301d9896823401ada8fbd17464a085f3f8c0e0d2ed6c69c25bbf5db4c12ada3ef7a39e77f6a9cb58477893516e923d6fc2095853342d632e6ee2661c6ff6de412b49257d3ad13bde93fd874b19c7eb88003425e0a949e3493b24652cea159e1193adba9cfcc4cbd67eb60e3dffe3a03e6744a9e805dc59bf8dc55a7e2b32e475f66d0f2f09972ac2ba5f28111a2fedf5667bd9cc11355b795abcc16c4c2542364d096e38d043710ee62c798272ecdd95ecead2ef446c7b16eb5d5960a9c3ac50f8f832fec2a0742387ab6db23fdf5996e387d0bd101e47eac56f1c683caaf812e2ffc816721416f11da49c6fff54182c2f420ed34896178c729261734157a3e9a28cf5d439fb27fef41ecd4abd67a505d56002d7d77729a53dc5a2e564c15a11b3ccf515939a8184988e9086e9a5ede77c5c153de0175a058093afbbbc1e8c257e58e545ef3c922602db76364b89f298ab96bf6b1248498d483b388bc055fc4a0d10fdd0b712952585068481437540d55db9fd0a951461ac59950f07737cd7e2b7c21c4611658f8aec74a7ae997a3bcbc6ec50dd2a981a7a1e0aed338792d3a67b801cb5dc34e50571cc1bce0a86bcb8dc8e0239d3092a0e49fe20191d5203543886cf838adeba4e4475b80cc5903e055096c78569e6d3cc65eba0ff53f5b6b935e568b5e8a8e37d40bae67cb0b27590477e21693c846c19964d0b7fe18b0089c19d80d6b944d13c8e08827b69763d4179db4e92906a596ec1abded48f01a17ed616c086adfdf22f9c3ffbcf8daaf10794dd6d2532add52fdbf566f30b634e9c5e9fb4933e083b142ea8f17e8298c71934357499322dc90613b23eef63ffa0bcd62055ded03c6f6cc93b9e30e3db9efb78d46f2722cd53873b45f36438e291042e34b3d2d5fdf2e2fb1d12a4a89690dec0a6770ad55bee04a61e42ff46b8b2e3c289c36a52c08349b147989c07ec74445ad88bea1a5c493e16533b130ee15bd9ee1ddcf71915f7219b8b8bb9fb6aeb3f9bc73fc1c8eddd94c270eeea41d4d9f58b68077af5b0b42ed4e003c968e5f2f75ea0326ee9d3cc1f724a6866ab55edafacb6b63a87695290d32f875ea0f3d4335283fe089fd82f48b81dedafc4e33782e56870c0f201e90be66658a22d61a0c5d6d006853e1e333f365b3ce6bd7ce790aa2475abf92783d879dedccba19c85ac7977512f8e8c6b2555d780715a0825a8e97fd7687c116cd4d6ee87a921acb0582ac041a114d45335b5871490419d07cf284380383c26e30872a6631b4f556d51fef4e125c5c27016e8f2c7212d4946eb5d0cf8d7c53e408b0d7ae3cd561d760f9278932b8f99f44c6d401e5280e12fd769f25a7576a4fc1db99f4a95b8428f8bcc0a634451832087cc24c2ee2630a506b92b62469d5e31f8af0449abe675e637ef6451fa8003a25528f5c299ffbdb4b6277afb2b55a237b727e88ca6e875fc9f611ea697b8ff0aa1c6730d5006d3991a98ead8ac5e7d1d23e981f41d5ef892becdd3761a652a5516474c0244195851f8f1629e77ec8d6f4726450523fc92914b0eee12311ac573438b8db2cd9c6e5d56ac08981a1ff27f7b1d66ab48a8634c03fd000b705d839396630ab7adfb9b5fa417b3b290ff0e0ac7317196ffe21111f8af94fdf852f5a08c878bd1daf125d346ce21cb2bc7653a2d63bd8dd43a9a043debef6e6c43704d5cc7d25254abf0ce309ededdb2c81ce42d3aa3642fe2076cc0bc11f3784c3d4a46c6b755cb261aa419bc144718a88e4b60cf9c2b54aaa356f68078c184134ba8ff756739c32de8e518db3de68c39b80725298cff1bc0a7f3293da79c26e6a4d7fd721a1f8152e1028db2a5e117ae8f0a315744a53ee7c594b74880f397011937454a68c3ff2af8bb12a7f18a86ecdc714d9cb6a8030d0845b6050541b0bc315f5d7cd875ce0104fcced41b8516a61f4db370858629316d087800cba4a447f526dd88872c6d8b3a63c987a37cba9e411c6787eef95ebb3efd53d8aa2f7d732867ed5e5ffd4af77ce21e2dd984ddf60b2edff1f824da084d332ccab218131e7aa08d46feec8c3aef6cabbc33ec26f2b8ebd52e204ac685a40f534aee0019a85bcac8d0ba70130aa8359d6fbb04b7a569c16a6bfd7c5056d188adb5ff59973b9b2ae93901782a047d2ffcb9e68fedcf8cd61084927dc1bff58185c164facfa1f7c30c542e76422e52f5a57683efb36c79cad27560e1d669914a649ccb82b7d48942af3af6e8a3339b159ed04c220a6168b7c4147a8a4f7cb7330e07c57e0d7de9abd2b950d07d1ebc6dc58326af7b171650c2ae9927114a0fc1fd34f61122c6892bd25fe79809b50b1f9593ba0412b00d6dc3c32d2f8bf27e08b5901e2b3f56678fcec84cfe6296161c44a64d5c43f278772b0238b76c39cd05c415ffc94d81c0a51aa87795724f379f468da2ca41639115cc463271fc8d817fc9dc58a7f6f2b161adb87feb8275883f60446971af358d387cdcaa71a60df8155fc79b7552fb1e479b3bbc750fde23111912ef8ba71fe3d17dd7f1477fae8742af35c25eddadd7ebaa4eb76be6317d3916a950a4f28e6b633303339970137b3af9f84f50dfd16a08d0c80f38a898f6633f9b043d92cc0b5f6a678885a3d5e87f89ae35046f3fa8bc8eedd7338feda1a8e2efc7f87178921ea2b10b682a4e11639012e3e7108e82f9ddb0d8831cfa7cffeabe0065c2eed2e85c11ea4c1970f762612fe6d0ba0654c2719b8eea415bc867f48bac38612ef1d6ef55dc34ab645c442a31ea90eb541332ef0905b8dc9d5610fbc8de729d57c1bfd86753f1478c5ed57465e0f93ce638311efc5bcfcc9f5416521e6883c4c88710612091d5f193a66ce820da2afd9af7c1f343486c52f82e67225333b018a39c9e30fe58812005b9da8d25d325411998b1a2da004d72991fe4c3eb04b90c0ce0db2e1d4acccad7dbebfdee8a0bb9c52e155a2d80a5481cca9f607fc80e31e4310537e9d868969c61fa3645b46496c17a187c1409e1840c7e29bcb4db0be304f600b150044ebc01894db5ea801f693bf49e140e5fc523eb66eea4db32a01de5f23878fb2fc64e6db286433ae900cd08292d997240ba4d9f881f4418c825202e216c036f0a0dfd87e72179676d67e4270915b5e0a7bfd2a6a6aac56d8266142b0fd1232b9a69aa2bb8b519165ebb09ef6d586704c46cad25563d3e63cf9e14be2b66892bdaca8a69e158f445d57a203fa5644bf5739d5d86e91b0985620683145df4c87f67c48f22435152c264c967244d24aadf54dab6c4dcdd93f021cfa807b48bd8f661fa5883918a50d7020d0ae657e9f4c34948a178daa9877b008153639f88e2470d8fbc899fed777788c3007bedbb35b9dbefd8cc1913e055a35913da2ece66ee3736906ae7124fd76fb5b0c993cf0326b07d0cc9542bee4f19a885a007d8ff321b9fc7f934b991dbcd520a9f40223cbcd8dba96daf085826ad9aecdbaaea1e900dc28d374c5e351c123e9fce53c91972acb9f993fbd787afd192b85ed9d79efdd46596913108e95cb314bb5bc8baf16f76e4f4a8dacf6953c56f9e20c5379f854f5836da937ab6740bf88fbec05a271580f6bf73521e0cbcf94235b5fa9a4f7cc43f00a7bde70244d39a779050d8d68cfd1f926334a3877128bccd055e6090c153c50d318b85cc6beca094245dc08113be4f9efacacd20abe2dc9399e33173b452d4141ca85fb3ba4cdc3e0fbd8a860cb9af89da44c43e60561ef9683e9a0cbde4e91a583964e76281cfc7922d3e019c149f05be5a0c37ab65f393aa91b99d74a0918be94a8dce2f5569057d7be4c4768f0e6c17b0f008da6c43f63dcfebbc4cdbf25be483e059c1e71647a7b5e307fa1eef19bfcad279679ee1d232aabff1bf465ad5198c2cd985612b7ed2bd86a9de53a1a4b17c734e9989e527fcf84ce07992fe39d465f559234fc33d9f1e64385407ecdd85a2f5facff175eba3006bc71b1533beb8a87eac7549c9e0ab9f95caa866bfea4af424d2778602f252ed623419392c723fa5debe55199c135eda6750389985d4e185bc9c0ddb91e25b6b661362a413da5a06022be3b777df3dcc11025c1632132c60522057dd43136413ae16c6a7bcb9253c3ff560dcd739b3c7ebb9c2b52e5f90dba9149da47d5958c895c9c9df75c9e47a838c5b71331393ec60c097fd554501616ff744bb99995f93dc3041b6a75bf4cf8227bd0b417e95c899d3a55a1a32c10b21e9f22a25f2d7d238cb873213a1109ca09b34204996115d1c95df0131fabf697bc43ef476467e0d474be6fb76020812005c93959ea8f74c0d892da767c2b77a5682ec0d61beab759421602c5fab2b697eba1ef6111057dd503ab2b0a297832aa6856b439d8a594c51f37899909ba757f0b36b9753f52f71010dd0284f55aa398f277f6a1f0bf497c3913328b02698ddfcf304e7cedc14d8fe29fdbb5f9cbf8a08519ae39fb042132c0c714badcc81874c9a2f8feb4e83fdbfeabf65786ffe410098bd41504dc62241ea10c274f737905604fa3ba2955fef97e41053570c7573f419ee0b1ccdfa66f873bf4afda11033329ce16706de06dd2a428ec5df1cfc74808ced8c5cdda195326081f95e47845f6b51be2baebb5777513ee7914f6cc565b75be03fdab738592e36d9ef17081f367c7d5e9d154feded617dc3ad7698d4bb9f0fdcaacd088f453a6f7a54673b1bf4efe932012d6429ca778ad40fed1e29001f67b5e3bd73ebc6fd1754e5a52461864f3c249c518eae25c10acac0aaec503b0b43571fef378424e6ff9cc45d4b6c43fc2f2a0c8df1603ce9779a3657623458f0f24de8521e2c8735f7d3bc10b105f82eec5d20f6dac187e3ada0ec903ab283ddfe785ef1a8d25e3eed0871d0ee04b7abe339c879e9d067e56682e9cc2c47c52890168173a5152d0b85a2ac938c28a6197665863dd20c737e51ebe551d795ffe15a50eef664f1d24c470591acd9c7ad5178212d4cc1aac11458a2e09a21778e618cc9397d9781a62ea38862e91a5cffe0edc7c93695d3088c8f3d1f222084f9f5e11e000e42e8dc290c5c285ea88a6a687d5176e9efcdf8af32ef2714875cb8c608b1ba8a5ec85ee645dbf864fcf4842f35a21c4d5a195d46957e7690d1033aec64e9f8e89e6dc9b1e53702867f531b6f1fc1b90cf38a215e5486b881b9b2ad2299af09f89e1b69d6db60c459860fdbf7d009511f36e93074bed818273953217d1c7403834e67f93aec69f499072705b74190e4e1c9347bf400b7dd27ee36b7a192c1768bbdb5b75eab6f20126f952e06c8342debd64260966e93cf5de71ef70a5e06f4eaff489aa29a9e42aa54acf05fd8e9e7f522eab491bc7ca1db50e30e3c2ef5a6f62dac48b11ed7cd229a7dc58b8078ff873bf4c9a3be02e64672f52948be110e8da031923214fb337f71e00d22238c9b85b64d6e3b947439ad8b6a0c40a89cf6417a9be7b49fc2f22f2b892e9cc01346d214422f4cc05fba0ba78e722b823db640466a0e8881f014c0af726261d8fccb3f985d54265dd0017df871e3a2435b9d4f6063314f4a652019369ca14813515fbddb1564f528da3c16a68208b4434528f71e0e4b8e493d38f663a786aa47afcf0c26a97915f5b0efd9240941526ade77557cc91595195e23d8e681ac4fd190dc48f451ed4b93c4e8c00c10d17fa3710e3896cdaa8a164cf754742557312a7ee1db0c0c0eaf490384df3235722e28f852c02cac2c900a0f270a7084ea3642976f22ff18a79fea18380aa2280ce3d986b2a1a83cb6c2c417a4cd64ee36a3715d0e54e6310a4b38b063e018ff6333eb5fdc73c634774c30861bddb0ae17b84f5a3d83ae3c02587fec97855f8ab56c11dab40897d86b29edaaed8550bf4c6ef520258d673062b71a50e67b035644a3727a3eed77e788b04886ead87d3384a46aa4176947e97a2e2257c1dd9836dbac65ccede01ac63a5cac096a4b6b483af45ea6a6ebbf88356846c44b1782d48b9f44c10c633f2d46994a54a5e651eb65723642fc9a7082f28d9af78cfc344335c2edcd7f9330a09d21f6acaef59bfde7333531a8aa22db8ebc9da8b86efcf1e82d1cff03ded8259fd494b9e0cb7287b3c2b86c969ad2c031fa8a47264b787e16a4ff0f1937b01480eb5c710d8fa35b8865b756b33f4f2b93544c1d59d11105685bf3762cdc54274315f704f0eccd700f76035fa756ce01fa25e05584072292d2ce95afc49bb211c71724abbda298b399f661e161f1f67cc3c7a39a4ebea49466923566131ae8414bd83317fbfc4c773cf0c626eaacb9abb30cfcecce961e85559e27e2f6405c3b1d96b8af2e421a9b79bfc0ae7449383db9ac6849d8e7291aa389dcb190b5fb1710c5e9cee7aa61365802e9fcd7a8a10116912747c7c2800baa84942946ad378b2ffe32b8f389df3a01c230ef612ed289d45641a803fe3296141fae294d5106b3e617a37aaf1b9dd1809e09ec28bdebff98633c3b9faeb25c297072218031753f7391a1876fa1ce04ebc16be2f72e6d5f38f50143f958915c163d9d77fcd4ebcd887d0debbe70ab9112a65616a187682679cdb553700accedd692794c25015354fa43e8098c7fa4b93d2c1e165ead4413d944d3e72ba830b0a097bcbf94082a27aba50679434f62cd861e838d8bec6611e9dee2db1e8d8cf2a840cb68344d471688f8beae0805860ee3dcffcbbc227c2b34a41d2cf9f0174ea82c184bf6d924aed02c4561636c51b85af14a9d256dcda7df56e3daa34f9c5accc72bd79851cf7ba60fa4f32990b1e3f9a789a449fd1c32979583a053152f66d39bc50a88e560bb6dc154a40e132726cc9f3e9d5813d4841e2d327c6d9a7bdb9950b33679fcfd0c520680be3ddb8f89a77b95cf66a82887e25e0366e9156fc5f77bb6ca538005945f1f56fa7f0eba5ddeb2113dc259d22a116b4f8cddecb9263c620bd2dd91bd602aec94147b7e74da669031bc86da2ffbf4b0d5f02c9b2fb3edc8c7cacc6c67f1d5e2b24daa87766e2ec6355b6660c2ba6cf5e33b03e31802af6041742c935bc0117467514dd897d865e0b0e05e8f788a00c6d9f758b0300b033bd06ae0070fde7c09a9fce0ef2d289a36a84128a281eba0fb0abd90e14eccf6d808ffa782b0e2c13917eebf233deedb24cc0ed2162d1c332bc05e13eeb20dfe85714336bf055901668803826a8d4e8910e4da53ba97c914f47edd249ebc0353aaf1c7fc9c40692f4348818583d7d9da820f3bc71297ae9ad9a0b655d921b5744462e926ec682a80038221b61acf10148bb4afbbcde83d1063ad144a053832d5179ba45e7937324bde17ba43bc0f3484e4eb2767e85ffd23a03d6f525a654bbf7bbf4ac17f19349e8dbfdad3a9a3172a75add068b8897c55112aa3c9fac306a374d7eaf42a8e398674c4c95e684be05f588738b4edf1cb01001b9f4b0f14090f857930fc900d766af4eda514b628f8241aa51e95ea1084435e6aac71cbcf74a2aec83619b3054adf5d52a919e3a34e8859ec2947d8f7877c9f06156e35895a48c9c4dee53e5856a3a41c08d7332a7e1d2efe09ca33b10ed426d9fde46e68031bd5508fb8e84edcb036b37288cd7ac5ce3ac8c9eed599631e341b96156520233a352425017a1bbef589d34655a03e3813466325fb8483dfdb5931e35618eb80817d11fb4598fc2833a83a1d9fa5687574fbd9f1fc5ed42351d7a5e6b03f0cf000da10d6c367a19f11e3391ed8f9184ef02644983f65457463e98b67e74535915404a454b3e64a970c31aecd98850ff9335959fbfd380525739251a41a03df8815423a71dc57c8db8ea738efba1521f3a93ab14c74708bd49f33d3856b23062c0878dedfe1b9bb442ed5d4a44163319086f11f3ebbbfa91ae656fcf627f2c4b4a45cd2c1d8303515159f963826633934cfa2dd3705379e3e47653c8e6b5e21cec1772ac4c10e3da3b363b2989b2cc500a29884052de59c7dec6ffb684d430451eb94bba95d8c25edc5272786a62f5e9c4355911a53dbf913762ccd3d0cedcf7e5072b990866d94eb2b8ccd26b402e9d3d0579487bd2cf9a875a567ca626298a7979d433020c6c7fa45e4152fd9af7a077904647dba37b66d37b316bd8f165a3ff5bea23402fd83620251b1eb0e4eef58d93b83d267c145a3ca474e1a7d6aed333ec340639745eaed92ffb1048b08686d7b204e55652c21711d5e67e6902460c13b2a1749c07cb04880212c26ff11cd88b55df6bf0279cf1873db36c1317179cbb93588c11d0b359938b10a3d7294cbbe415d194fe7f41f225bceb306db37d97bfc6a7c9fffaa925cee3f5aa80a3062eef12b8c39abd6c329196c8990e7c4b6c9dcdb56226889d5e3b4510b3c0b59918cb6ad92fc37274e37944e5de14f556d8db95c778ff3f36b11f574192cc00fe5ab5f3ec9551dad72493a5eec046cb144c4cb036b0e5e572a5332e62a2688d7f696ff5efc38565bf550e7e26227d0675202ee7a0a9ea85d53d0c5658a5bf7a2ab635e69d6e49d022ba7a0d8dcf9c0251cdc732285ee313335d5ff09efb3d8a0c6b55ac8085b6240f805d30a07390fc94103cc20168a46056b5b8e93833dd0176c3c8416c7ccd40720ee50712f15923c3b90d28a80cc1a648fdba7b12e91b728c2012b88a8580863315e17af6d1e157eb37f3684048ab59277b82733c6c6898c3e3951038251d1d96dbf57494a170ade4bc84c7fd41b3b6c6ed35819b5fe590ae69530ae6ecbb3e2eead37c19f3f0453ce80e64a10c31a2b4771f885a5ec17fd17d76fe1dd66a5b5e98f8033ad684281fffa29232ec0571426146a1ea82f4b41f921ac4e428a1100c2a6fea5e63dd6212de31cbe5a36936323a84e979e0a32fa5ffaf3bd9d5b03f7d8fb667d5fd83b9f101a2d0c90c460b4c4f6bb855b656e9b4cf19da1f1da099622a688abb8bdf6626975fcdfa56507fdcf4b7ab627d8abe76198064dca0ff0ef17180352292c5cbaaabe383db98876f7cd6ce3d5c1e2adc19a15025c4ab73325b0efbb70d793e80ea0d80309d3295c8fed7a3f212fc7d771155b1eb69da55763da5573a3d36a165f62a4d4a97805752f950dc83f92c1b39ea278b06745dcd44ad3759ffe63b07ba89ef391faeb069f1c1ff5534e86b9e9b1c8ca953c929e14548ec65af55a61af61dcc5e124bf90fc068c6377102134154f9f43f7b7cbbb07d1d9d6dccf1c9ffbba40cd833f0babe306c16d16ac154cb8bde0edbfba31f1848bd39f6a5a9139f5e8e7242bce8f5562a48c92da2555b9e61be04ad4e9ec4255fbda90cba26f4faa9e1b70e487fdb6878624ca5225b5b91e97595699740419cf31d0fafa06c027a6152f1a7113e098a302e41404b3c99ab33989dad094c4730b4d0251e763ddb0e8bf36c74b152692e7648ef8ecca83fed8d8c26fac675353ed6f0369044de4c4dfdc062c03491ae76cfa52736ed3913ebffdaff63089d39c33e0b8945518a4d156b8b78ee4fe498e9864acbafdb26694390dbff3f5947a637a1e03f4c8b39ff88b047b4b541d6d241944ce7ce50cbee5f0f1a0534a6b970e7d281ef0844221008325cc9e95d4f485ef199f286a02cc621099887700400b4dadc47e977cfc72f219ce515f2903e9dc4560966ddf0b17e4aea90eaf088c436f559d8d2bbc00f91c46f8773f4eddcbdd54daea78cb450584e187b59ebb48f26a9b35ffd793d48748ba882fb62458ad4bf959d8b9c668db38aaf90e208e8dd41ea7d689d0e7ec712d4f1fd894fcaf4349d6f6f806c4342095cfbffbff78453712344ae75e66ee4e4e535e8025f45b20ddf36e5d8f9cd3162cdb9b65f842895acf1c7c6ce19aacf70483d92d28c9fd1f47de0a037fa5ff750935d13ab3ffbcef424f3aadfed1868600386d5975a046268da98d4b59c79542c8e930a9719d22761b66239e1a1f97d0f2c6993113ab30e96f00edafb20201d3920e9352b04316df5161397684f094ffe64d405d5cfc2ca0b6cfd9a6d00e6bb537b72c02877616f707f58d07fa165a28bc99e1c7084c614b053f26e47f07a4d4ef6ffaebf9835881360ca4d779014ca6c43c769a1a174b37d1b60219e4e1eaf33f9ed4936dcbb48848880b63bf3b2a398e469af2fe04871a371d99d408cf975a50673809daea412a7520927ef0851e1f18284ef328a7a0ee1c5848cb997e422365c4a15f8c8e208bf8321fbd93e804b1325dacc9206411230276a8ba42abfb0b1e755cb3742aaedede6576d3dcfe0b89b3956f61c6e2d75820b7fe7afb174c840830e2ed7d45a8aad8218861d09e4f75f374c12e8acc64c009d120aa18f07402b1d7a41873588b69da9faf37b660c41fa32e37dc360ed978015d5f805caae9a5ccc0938d888f995de0700bcf1e8018c862ab8c726197c4633fe59a2d3bb6daaadd61ea34f36c0c995dd43d161555e737ef5cba034d5d47a357370e5954f4b1fd899a19c01354e6564c99f7f1d6c8498d2e3071984185c367f2d299bb25a5f35fad7fc566b101c7358b2e168413e2f52082c16bff979421c6279b00856d277c30af89659dc9c7df127e13abe0fb5d1c808cc384917e4fe4992e29ae8e90e157ae697f7d306acccb294829e39496471171521d2e279c2d60587d56c8fd2b8065dae6273daf737fc291f7284b874c333ef03393a57a376e937265f749c8e995e8f21147091a2d970065ab6e03114366c2d64681c0b02e9acbf74a534c01fea6ecacfc7af71d1866e552cf232136f222d31f68f12f84ebff3f5d32f805d285fce906dcf8db31d89f3976258d530618a1582aeaba4ba5ee041bf05c88271afebb02c51a7dfdc9cb1aec10d22361334f348e4e93ef57253e3d346869606041491a6a96832c5757316b72e751a942c61ec6bce2b1d1584ec4d278904d6c3955d0c2930cd9fd63ca2485183ecca68a16e0b7f7ebd57f8759d31855cd28f161e4259f68a20034abde2722d2a1f2db7710aa0f27252ba74cf56177c23cf4993beb59e60c9637b7dedc4b72274ff0786db7aa1c160f959d18c864e3be74035091aaa5d1a0d0f9d42d98042ff9c1980946478ddc4def3563c8ec86dc3ca245de5f50393cffb49a64cbe8b10d425a6ee88db6a3e9aa7cdff5e989ca70de96c8eaaf66cdc67e0287e5ed4985c79bb0b382580edc57cc4ba64063a660baf4c61d52f22b1e5c9e3760ec662aaa58b322903e3655022963a33fdd1c1b491e2a5120a41758711897ff62ac2472260d27f03e75d0764618cccd50427a4c8c6e4fb8ca0c1e360a64b6d4f48c9dc15dd2002d1b50ece2fe37adb16dee45f6e9919a572d564c0accb4e32d1bd453da12f2149311348b017396d12159f4e5879728105ee84bb816fd23808b98e0a398d977438b8931e794b83b65063430b05f81b77805a8543a0790160902158a3d1bb45b9995db603afe950bb411046a49ebf612a6814b88666e2c532590afe7a7a90f877665fe9f649dd937f88a7a8f23cc991d9783587f422e3558c1d6bd69967e5fc638da0513bab0659fd8eaa2bb989812b6b3af876b37786bf0429e01129ea4c42fcb0af094e000ee5fb9b4c2bbef565717f29fdaf52e5b5b0332c0355e994350d2f3466843c0c1382032900f49bb24a3359bbf3cac0cc1c64e22ce947af4c2cafe4942378cbffdb9b231243499e9a5e9f106687b36de1bf9fcc57d087b3f9c429db0163386456a56d245b8d1e45f0eba85de8a70828877234f7af4e4a35f6748a835d993e232aa68694ec08950f81c56cf7d937f18a405f47bc8dd3ac26e846a1a42fadf5bdc124378e2ae4f0078eb0763e8f5c0bdafbb172e5d06aa323d4aa5bbd24e3873c3a404f9ce83828604d2cff581f639bdd8ad422f5dc32bd9e1964b6999f97ef98516554f49f96111166d0c0cfff0655d7cdaf933ea8796e7e54dc4f77669b397a4ce65f75eb1d5ac7e0236806b1789803c350b47304aa5011e12e71ac796cfebd416e5468c4677a07e9d757bc5efd39e1c91236e48af5d1f4750f657cf176bd590e467b1ce7c53004ffdda376056e71034a73c8c6871710d31f4f15648bbe70a7e22c413ef7804af61ba3cc372795c6e5a6065fd41120a012beefd8e1693ba014f6bc0458f0a2b505f2abd5541b793ab6a74c48eb71c73f96f1d7b243ed188a6d630f3e395d3b14dbc1c26ff2afd1e2028e07cf8b85a744f72ff7a269846daf1e24b2602cfc7cfd8e3c582ae817fe02f1c5a14d3c19cf6d12a7cb66cebcb2f24ab86feb13602d5d407a6b5211c3e1a35908c3002ceeba43e2a26a7696b4093b5c35ac79ac3fb1d907f254efb7face0302f59d014679a7f752c270ae4fa8f7a0b974b032c36030955220b0231c21e237133fe1d72ea53de95177bdd1f94a609f8acb4591115d18e15963f2272c7187766f6f6a63eca7f82a12ca3441ea7aa235be026d087e5d8c2694b7a2c4f54055cf6a9ef7523fa4762f7afd3be60110b579276dfdc2852076cfbd37c2e05f3000f929903eb4fbb492dc8b4b65a4111c6442184eb4d4b9231fd6f901dbc67b8942002d4b4ceb9fac00e99851833ccfcb42b65f40611e542aa25fd818f3127076473beafc8b2d0cc91f9266c70410817dd71b8c922388975e72c7d8a41661cbedfeec6b6f240a0e04f4ccea6d451deac61c0a05aebfe6af22b23f3e23c3a02438a4131d54749b18b62ab6f7b76722cc6bde537f10e5be2618729db5f4d850edb21156f7924163242d8513cbd128a38c899fc84e52d2764e66467bc4aa449f805c58db8090fc8de27cd83ad9cd87ceb7663e020970f8822f288bcc8abbad51ddda0435eda15784b5776630541ed6104f888133b9f2781d6f86fdc630817b49dee66a90ee8067e9534e0d8fdf3544762298e39c648f7025c7760ec4c38e401b98b3e52bd5775ba6336d3e34e64f142d1453950c72be35c477d333f94b9ec23db4cb982cdf11b533b57d339f7f604341a914c8977b3c391af6d3a75fe4efffd76dcfe9828d1b702e682295b76d44bdb591b0234e093cfba64eac7d7e0be57b8be942048db19e23ec7207377aa8077d07b32de2bbdc4f8beeb29a5cd2bc286f272a0e360158ad21b3eced52ed37023f7374b056fc2b06adb18e12bdfc690a0e19dffdd22a9cdfa0261c45aeb898de5e06725ec15ad3b845afae71eef8d4243f316a25007c1355e07e44672f9de5bff89629a798306446d1ade318c6a7b318cdbc33114cfc28d011a4f694b34f4e8cba169233a0493c993f74745f90d04dc9c77bcd0e3f9887b8b6999814d48c42b03e93a229613433e3aff2ccc2f0920dae036a88141d5e209e5036a31588d86b331d01fb5fe5631cc912cd645af442b9cdbc0d923a115736c8adfae693656b22bb2088b1fbb230f474889e5f3125331027306426e61983db6e4760e32ab0c1ea6cb6fd236c016c44112f2f4e06010d7a147ab46b1f196f161a028c78a401a412c7a5ec27571857a2795272eebfb268c4ed8828d12490347e432f8dbf7848cc5e5a684bc023d727cd08ac61c38c9ab36c7fd63e8edf301c6af6ade05f331c2310c97e7a6aa2b3dd8bc5b18d725221932b350d7c912b6b766b919be3084b2ec58c07f854aef810b43f6105e547571730e4e34987a0b8bc3b2bdc7fb669714a148e6d732d62e8074ae3cde45655a4d5e4fc2d61caf0e212f32f8722a06a8534e8083228a030ef5ddee4908be90e50c27cb508d637c0d7364ac0b0296fa51bb53776ec2a29c50154d5e905a984da20337c054d6a1e6178d57c4a87df674728e466326c9cfa05a63be439df2e3753d033077c82cf4b3cf89999afc5636fe57a7d5f151230298b502d66987920c8137d64cdb7adb6fae814dd29f9621a2ea818169367f9d975f5da97db2b9753882a61334329335266f3d9590290076e800a6230bea26765094e5cf4fd552cf85f0e126deb0a80ac2c1f424484e9db0c91df00d505395f240fae0382b890ec2c21ff538ba2d4cbcfe249ba2a82f29843e9f64afac4185db6d8679fba91821fd11dab33301ed7bd54660d578b6217996994124b72bfc609ad9cce9283f81ad8b381b2e23641d2d9cc12b71e118c25872a3b94e19a51a2c4e3b9c842045067ea9b25ae7e3b7e652f621d8575f28c5f9add9c51614ce9ec8163468dfe4dd9c7e785cf829cac1451dce3756a63b74aff64e44a360714c2935a697627a0eab4bbceccf48d0e38f6df5eda29ae746d313c0f6967fc859263d997346894a5bb9ff015963d5c79b8a1f6a30d8a8cfc0794037b83e8e4c9adad07debc8f62da9b5edeb1a2a02a3ecbc075f845c38d711c6c5cc3f063c038aa253d07395ebad15bdb8ef137ed9737581eaaadc10159425a8f44c0f391b37ebe06c1bf4b17146ed10b691c13e34e70b75c86394b7c0353505daa9dfd07c6f797b6a2ad3e65ddf0806917684620ce68738e60687ae96125542b51e01215f54e11b28bb259491d7ebf0b6d30906ae7516d5ae792e7d0d51c363a2c4775b15f733af792c306c5289c1ae19b3f021ca15a8a1aaea944b3ea1510117358191892e25b68e930030fe9a21788ce5d39bdde3d67225e41a94b70d20dda7d95eb1aafa9e5213037fdf75851e3f2c4a6b0324f2101dc306bd899315fa27153e4f03c4ab24c44a73e1e60745fa657e983cc1df1124e5d442dfe4c04c777ad11aeb8ca10a93812485bb6ed7460fe82d094efe5e47ca393aad22d11d1e15f4bf6be048b8a79219ba815666a56664b81d6214bbaf758d2d7dcf2f5b1c048d12392d25ff07640d40fa12b4d4aadc1b300d16741c9234ce1a88660e932f401b340224a824d582cda47273bf7e05e91940ea1ec483ea446a0d49cbd80522352496966c9a7bfae43cdb7c99fa9c8b95a30bcfbd0791d01c7c1e2f5e381a76ac7d6e4982baf70c55845d257d7194053e5f24c25c44fdc3804528acff272af73501c51f981c039ae6b289fef6b5a4fa5f1859a0c49835725d3a540bb2d46e124168b1ff43d68fed0efa2d1a88e3f57496c72e67cdac8f1d80036012972ac0a434e2a1e9d6b5fd9afeb15d4749a2a01146138d36a3b093392eaa34e48b60d997826c5ff5efbe7d0625edf884910f5535de31cee19e8fac6e4cd044e4465e5d2825cbbad75dcdf2e2d9e96e02caa0783023cf81d4af0842357e78972f3d2416befda0a0f58b29e6bfc0e5a1d174d15cc8940cbf9dd671fc4a5103cac227686cfcf5928d4e8430e7fe72a160ae94af7dbc06c03cc0cd614dfd86b44c5fbf34d1d6007421b1b1d8f745c28cc43cf4192608eef0d8433fc56fe3431471f9b46bfbb89bf790091bfce3abb39e52c50d47b67456c3a37e61b0d444ec7ddf5c357f720ea5921adbe352e948ecd3a3ae776da3c07bcc248c98b4c7a06e8847ea3b243c850f0ea2de0c4e1de2d5b3e3517dea808f07fd7ab2fb7d8d02777d0ed6061f0511877ab259ed298861ecadf46ed9538c40e39cd75acdd96c6085171885740bb461c7ae525f0ca40630b5f8aed37474323f0d06948cd17bab05edd2193e15901d7d2c59a93621c55328eb3ade864ff0c1eba7e30c55b35f5bf125f501dd966d605fdb35e269f3d5dd5bc019bee46653da6637e52330cf9fc65ebcc752df90c49cbbcc953c7e8de75bdcb1c51f8442b2360f2f48e8b4fbd862e92055eadc40e55a0073a54413b53c12ae43278b72956629c612d4236888388a1c7adf69dbab898dc7d54e11562cb10bcec894eca329a6a8ee5a51d446ef2c20fc591407882f643e87a2735a8c77af040c53a14a198e69e82ac59270cd069ffda0692ba7d7979724312ef4d04b52f1c2ce931952d2ed4df5d5c0e317a7a72f16db607cdd0ec1c3c3a672a2ddadcb4bde1f24132a84531eda5795a3f943fef51b036c81a0be2244c805267506f4dbf2183760526d7f30345172d03889fb088684c13169fca57d87b8cc55af6c5da229f913fae40ad4c4f18dc6dd785371058770b71858b9ebe0f610c2d8282d380ee41744b3ee34fe08915a253ac6697d30e9642488e9211605a3082f43869777264710bb668832a39d3aada4f408b115744239a84124d73996b34ac171781ead504fb1542cfa6d6d50d5ee5740f924d1340194c8e247c07cee5293518857d9970e465ef578d7ca3428cfa1223aaa078db93579971e740967a8e5cb333105fc90cab19eddea8dbe3cf84bdb1317b1978d8f435df2b01ff0538077ef229ffe1147995f5b332d2df4e82ca7ff0d40767c97c7e45d6aceb4489bcf52caa6d7e6bc2936704e7124ff25e115fbc0fbe4717abd76f7f03ce0f93c8515e52f711733b803b92553e8d8c0d5790fba9a112c032d48aeb235a02a27145127c50854fb55398a3c308b1a899cdbdfc6ba2833d2724dfea86979c8f977651872593f0411f3457ce66abb7702038c619c6b50dfc3837d439319699e1040a895e474c17dd88c2b3dae3a247c29b24d83a67a9f250fd47b7769aee9345c6978b4915a113e0abc825cd02c11e2aa825d684b379df03d6f3b6039d8c9a3dcf441eeb18b2990edf91ea40779288c4efc1e43cf1202a602e2ce83d533ad7930dc2b997051f420439e44a45adc48d321ab3aa726a99b083b9d9d615e11fae6574373d398d6719a7db3e6bbb248ba61c675319d40193247920ed68d019ab78969a46fcb05b085bc30174e0b194ffc0822c40a7edf7d6fa13f0cab6d7f0e938fba2ec922173c44f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
