<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"51e831b784b49b23d4aa74c083451a5961463bc129ad799a4d175437255b05d44bd30512db9675527dbae2c3c64fb763f0dba1efcd4da9bc088bd734a3ea95ab11acb42737ac2fca80ebdd868be4347fc60c8fe818e862fe7503f98771e713d0ab8c022c4fab775f9e8c2d59e5fdaf6cac75b91baba1a4a798baaf970cbbc6f24123a70c8b8cff4ce1f8065fe6aee24c8d1cd5256392d356c9dc7e9b07bfc63c29d5360cd92f44a7d610caf0d55289b7d62de1be1f42de3c269080c190e93d305fabeff7f1312793e186b7491da805917493ab438e4c66ba66d50837db66c0c353f44591405806406f98a2d9a34fe21a59e3242065956235703712bbb3fa5b95f217b39418cdf6c0b1d9bc5c56f2c01279e4446639b75b82d9c567f896bdc355fbcd6657f8993db3dfcb00a978f8e2a0a82ddef61fec69af90f28102f48f06e6b5f3f40cf6227867c4146913d5adade6bb71e53593692635ac3e16b465629f4ada26566e21470a1deeba6f10315003a98b90bbb9d72c74d7bc3171505b30e681d0234c34cad945afa782612a1e840adb222b293cba3d2f3c71a6a965494a4561261f5bf0563ccc3a9f9cd1c754a4f00926a2557ad4813b2725ad27891a8269b3936e32d5a813498d3ed6e7dcdf1229ed17e272e96ada979c0ef2a81889052628f4f45ce1ef6343b15983fbfc3d6b0f1cbadd8b2c96e3af348efd2b6793f04e756bce0f7c663e500d261088eff66d45280b7f349c31543d4087b9621e917181ddec8637804f05688b967bbc22fb2841e0eaa684c1130d6439b0554af1b202c23173562777ea5fa8b26c40f19a0429073dd265b282fcc98d898843ad02513f9cd8f8eb911b9f9e0c78a596b106673360dc4df9608a258febd1afeeba234fab0b3f14a40f5d85055f94a36f2d9ea55c64bc400a98e2bfebf81ae49cde4f6569c48aeb3987deec3eb3dc413d32b02f8945f37603ea626e6abd48944daebce8cce7da72e1db5848f32fbf2950ad23410773258101a9a41aa4bb5848e7c0e56011df4dd9608605d532ce9868f30c44f5afdec4d32020a587c095dbba28e50f950b9c8617437d9fd1267947c0be5bef284ef891a385662100e20dc54364a39cee3efb7aae5b51d4d40fb59c2cd15e01f5cd5b29d334fef47a954e43a78f1cbde9aed5c09a47e93bb41b01ad837d4d68d70a3f3c652ff0f302b333b7868499737983d1322c7323c97aad4e4fa5e0a8ef7ada9e78dea14158b60693037ef274228ad07ba178411965dce90fe81cdcb702965ef54ba7d91d52da1d93daa5f31cfc3970733ccdeb555aaffbc1fe1e380615a5747ec3a845ae14a388191a7913b9bd79618879e36b5b03fb2a852241c844695e75483ccc808793ca742d99dff39b28ac4fe12a73718a7e4cb5dcd3c8939d472227549fc02f785ca776e16a5eba579b8040fd4ab8bba858a4d68e2f188ae3df53d4b88849edacf8ab3855094f55021f8c28c8b6c811504e3981b0803af24fb97e156a7a16fbdafb039805dfa499de42afa23b58fa59f528063e825fb2c18fef8a1e469ecd172fc62cf40102ff11f926c1eaaa29aeeedfe9be9d7f6d7f506b5222511955903db39a4e33489269db91eeff46462d145db15b5bd13051ead3bb6b18b5f966c31e65c2da7d620e4242704f16c2ba79e8b1798bb99154dc4b1b337d4305010cf87881bb83e23b0ae9b1d9c20bb8363decab3da90b9a228fb548261eb06e0fb4be71e23c8366245abd6ba266b7d6bb2a489743fd10b243acea7f80b9731191a41f10664cf8d311e80eec28eb2905f8a89ac17afc359b3775982428abc691847f268a5ba192a8090020c0813e85a412d96792437534f717dfdb748facf484ef022d916917442b88cf834aeea49867acb1b8693b13bc5792cc5d62439e10c2112fef1a6080ffe427f7b4014b38e43ace78adaa361ed169738aed1e49b3a192291dcba386c7b071189db880e8fb96f9df5b736efe47651cb499fb3ba40d5870f4fd13d9adcc379252475e852a0d37cdfde74de49d64975fba7c5736aabedc20597309908b665f584c1d806d2889542dbbced0e1bf0132c4c217da3efbf31d43c85185d7506eee9311772d9d7000771ddbea3a0cc9339f3e70943a4504373298ae48717b41f8b25e36d6333e95054c3104acce6fbd51e7e77dc4449b9a145694aedba2eeb9f6dcfde785332b1f4ab044cb48541f9a35185302ef79b09dbcec4e45f4c853b27077e6b2dda05b964636532284ea42ed692aa2560fe002a7a34594f44f63c46e08f7baf18f62a5d6d64cd72edb61b72f206f1da1a26deb6c56966f000b0dd5272db87753de5768b94726bee825f1be826dc70e52a93f062d02116f9fc423992573bbddbceb0874476eeeccaf847f1d88b7813d926a3972a33c397cf6e266221138541a547d98dee41a72cc841646a6df57dfcf7607916d5af189c7cf95e24f28ea1f6e67f6221d88b1a4e298dbb1bb3ce17dff108219e3d70ea727893fcfcb1fcc957db52c8df78cb5aaac0c50db398cf9081443ff618e206817c9d98e1dfd3f769db53bc9977ecf9ee9416608bf14d25179ee848e755cab652c34cb04dde6d472a2fda43c3d26441a112940c43d3b1cafe73f2c306a697335165477f37811d7c6f55d42ca9383a7506837cfb130db9be789b8ef047010c33de8596267383c0c880651399c7295a3789f6ca677ea2faa276aba063377ba275b7cc1cd2786eec9c6fb5c5a7bb916cef44a8d5f7b1ff97e8714231e0a0f53d22c14edca690808b8a5a128eb012531612babb83ec0db65bbbe298dc545886ded173b3abdb7c79b1dcf3da0eabe2570758cbcdd8fcb4001b9498a3bff89a305c599de9cf44555f4118f984a8faa0e06977c8d6b2105dc36ed87d6b9b9ad49f07aa4e84a87423eb7e5bf7d4050263b0910c19eb5afaa9d6aaf391623b5450053336670fbd0a4d98cd9e8fb4ad99413806def7f0f48e1efc6cef51bdcac5c86e951fa4e77e18fe711a283f617f93df17ec1ec07a822e1981a0ff8497a8842c1e75a3c2bcdc088d70ea26e91b78fc91321c5cee8ecd83229acf8722999fcb3af8fa524f410c980c3621296949e0a2be4b894e875be5fe42fd9566aaa93151b6c3199ee02ed27cdb241c996ebaba287e2b4af1c54f5bf5a26c35ed4701afe494cf912b63b81e6e0d2199b8f9d5dbeb863335382560824b57a43c17add57ddac2810d9f7328ac8421f5540fb590c3f20e1bdf80f71dc97fe9edc3b8ee20ec569cb9672ae986eeda88dc96bae98191c348bfa8340e47556ea907b046237f6dbd4a6eac8303e43e203da43b45c9ed38827cdecb248bae23e3906065d410c898ad72204a06938f3231f563a7b3aa961e6c2a94da20bc174d83e10be062b693d9a83baddbf26456e5a33dfb79fabd46515602d07ef3a37cd26b9e91be2dea32b8596e587464f072e5b48cb6a2b8bf8f7bb544e9d248f61ddfbcbb242c6ad5133676946b99439cff07ea03640fea71eea03f762d6dc082a8929a8b3c69377f0a4d8863625a37497ab0edeb73ec60becf8e5cfc33a87e5854776559ba3d06e53e7bf0380bfa7df3f19cb39dca7582c69291e76ae5d4b08ce2c1e26398de72e23c3d52070a9cbf16cfe9244637a0a4c5fefbdec8b3d458e9468933a18744a2a3edf45cd8142fa68d1c8351416a7459fb3b4f29e030a0caeaac44d4c5e21bfe8f9fe91d35a6917b6e898b78ea9f1098a4eb2533a9d325d3ef1422d986e9400b1aa8b10196f181387c27d79bf0c17379ab11664ed95214463dcea62598acb6bda30bd41419d7c4732818f450cef5f1b536c161482c94156080a5faef2ac5e3e726a22afb18b88663e73291f5b78ae6558ccf18ad0dcf3f0fc445a4a72f8fdfb5eb8b0f6de91d9c15bf15b42c992c4555a9d8b3f0817576499c0c89f3b19a6f81973a32d2ed57881c5f32f4d01f27d6068428690012148b5d7dbc188ba330270a78e1d350ad4fe94c40d474b09ec538034e9b1b6ab3f7ffa68d722dd009aa63268cbab0e56db3e69bea06155a2aacba62ba9ba54ba202f56f30c5157825bdb969c7e7c51fec8d38c9b85c6fcd7839429c547fb12586eb8db50705569450f4fdc6351ea15cf3eafae6698d65634a0d03702335790324a134e5df35d295fef0a057c0446da026c83d29d832c12fdf5ab8af788c8f8ba3e70bf261a0b3023e42b798ddac23cead658d94c9caba71dbc90c3915282962fead8038533c40e789d426b3093fcab2201cc9442d0254271835f2b579176f6f782b665f6f9d67fb7f7c4c753355e999588ede87e6e0152d59705ae4c867c0d18635c72a8b86343411027465ea2670e65d62b0d59366bb74cddb0f6df8101d47eccac0634ec04364784ac28e6f286f46289aa02763735221dda688702393b930040cab3862a67a6ca4db7fdf547034ca6c2881956ad219df60c4dc6aa07e7f0bf6b921321cca81ef613f786c7bff2cf060386a1531c5fbfa00d0114a0fcf49d63c233f634afe234fb530a39a8d1d1d466d91add982e794571caeb715654798d2eb921429e5a247d0a6deca57dc070ecd4c211594d07706566e8bda220e5d08111b955bbef5c00387c1f439b48e7d2c47035dafe646a56dc71956670d5eb64629494fe3d99f77603ad498244b56f93dba6744c98a6f822182afe1de74085aed44a805b773ac2f0ca3adb03e18f386071f7874f5d5ffd7edc6082bcbee5acabb11c0de4bf4946fcf226dc368141b629de9d2cd4dd3380f314cc319abc261ff6c5514d3b9b61d419004c394e6caeb742029803abb3a39e619ca0a5022fafef0c936e79fbd83f931ccf22c1d8204df24ddcd671a2be6a3c8449c5f4ccb9a204d31f6bf5aca231a1f21ea6e245408f436fc74480cb782ad961161cd13dd459b7da50160b7b2a1c876f3467b162b8b52286125c26c06aa6e4b88a9ca36f96a933b1d28b679ce0a4a7d4122af0c6382bde76c261f878f343b94379825cc23a0ce566cc31feab5476ae2992292871c05dc2cd4412bf3fd509a5cb9f1ea50b856b56b190a263e4dbfe7be04b345af8dbf0842e5bf13c8b848b39a17a9affebbed2b60c09b3234cc6d53b876da095a01592b47fd4d05a4499a790ed7d0b5a7b370b57f1d1a69293285567d2de0918f8ea03130e8c4f53762212b0ba2c8f3a4ebbb8ad910e860d16e1e53b39c4bf9b4b65a938dc7fbd1a1bfda345b17f0b4dbb6b47cb7c17caac0dcd4b9f270dcf1325520b0640d8ac876e3f1feee6f1bc4a14612c5db7b07f3b992c7f2ad58a7fa64ad9a0f1d14111c5d1536146add70f0ec9fc88d3d5042a298df5a72df782fd2004517c5ce6348ba361a2e1261d5638588e3953e1fdf379e164fca5ba8fc79a0dee3f6b7cb471bb24ce8dc0c0ad040b0faa24f38d3fee9b0cc36e01f7c7bef0c3b857f4855431ebf1c5baa486d4bcfad323c7f6c39f5a77bdf1970ba7e40db910bba77e57e961aab18bfd2e8fef58454f80b326d9f5434600f2b1ca6b19f82d1e39fb8bc864da539ca4272649fd0eacb70ed779f9d8a80c5d0cc0a6a9a11c9a3c3c72215fc484c9345fd10dfe5ef16fe9f5b63cef89e038fa1ed3827f338bbd8a6a6c5a049fef0e2f20b986f3cada628f76bac9707986c617ad2a6fae2973555bf07e4960a94d8d8905a5a81bff7f8a94a6f390fe6de13b05c40f13473a052c7225624023fb2ebe4699dc5c068d9032070f567a0221e654f139a42f36ca05cd060db68bce738160cf5b3c291e84b1a8719757aea018e7a7264d223b73a251af51d2031c9fa57004029e29ed895b3ac27827dce5d48751c13d3e9e4c7b09b57f9c94d9998c830aa7d3310520c448d0111ab5d8c4f0d007b0fb4aa314c0abacbee3fa67bbc18afbea7a834911e8a6e10a5b5bd8301e2568a223c7086d0db4d4060a3f56d8a8a8bfe4888711e8aab250b710da31508b41541c97b1bb244225e62c26afc3ba144712505119abc7c7c4988a4826b4f43e01e62e7f5e899bda3788441db5f6e2dcc7b921a98d18c047598b9af81fc3b1490c29560a264a36fa8d1176d50b595c4b900cce8f27d10a1c42b1a1e0dff75ba4f08e679fe904305425ae06888173f928a6a4bc8c42582f97248bafe4a32e066e1d11c43fce88a1c453e26152560a23222f3437516120d670c44910a7f449f0e9d429c6e80b45630a91ed26274de241feb02dbaa9317a3e83ae706d8dd104996c8c899eb8dfefd88cdb3be5e8ded736374fa2cbd32a48d2220a1f95eef0fe59ca3e0253c87b7fa9354b3ec58297f26ffdf4bcf5001c864b4abae24793497c2e9450da076015d0574691d97f2d339d0c52ff24eaedca2547af1ead177a7bc975f5f0ae863871898adc3ff165561241b2f50de14ab7da5e99e60810a07d6ecfabeb33d82a435bc658d000bd7df4d695868bd7f463319b028c922c0c6460676f7b342feff391630448bd19dff2537d971ba8f2716fad15a000e0257f6a705dcfed53b4a2d0608789b11ce217708bccc2414abd150baa3a107046f382f4900cea97196637a527fee71ab674e8614a5ffae9b9559b2d7ac4c67ce2f851dd1a99fa03ba01d8e1ded1f7c2b0d3d906bab2fa2bec165fd004cc54cc27512bc5f371f82b5530d62ba308e4fa885ac0302246cb149bfad0184ad46653a7b188a2a10cf4f40992b0fa273fde9c6f747fcbfe6a0e7daa4cea150d920676b4969a42ecb503fd8489719c6d3638906d963934c366b7ff17d3ff104ff43263ba90173a72f712223dd07f626f13a34a46001719b3398fe70e2cbb4f27eb2c32af67ca1fb79e7557164443ab047fd3db09ae9d6c7d938b9d39489427bd4a2a4c2caf87b10d963df3ad0d455e8db7fa7f7827522020d6f2821b5101ba251431ac27b4e4b2bdd251e0b484a12d0ce0187328804b4c69e8235e2493d07a6995043fb1f0d43ab438a2fbdd5fffba82e8121936cc6cb55c0cd3a895bdf970c7512ef5388210a198026872ce08c488433c649a7bdfb37ca33184196a53f17d8c21ce7dea6ae548a127356a215de538b1380c3f8e983da5054901d3e5dfa7deabec3a823f432bf3f73e37768806cde8a015a965f9f5dce93ae136cb2956d0e8fd36db7300f0e74e136e4bf76537b3555193acf90016132e3d896b069b721bfbf14afd8823d8e47b3cb90eca816baf5aaaced553ad567e8315699a349a6a80f935304b0be58a246e8fd559d62d86c88d701069045be40ad0c6d78a80d10b1b4da3aaa2da3d2e467a7bf64d8364e7995269b76de79ab314562b996b586f23d5dea201a7c9f28dbc7a19aad13d820f79475f95c8c3b89695961be99524dcec3e0d52a9d735b096e76c5339aaee6705795df16957f8a77e0e38492c988c0bfe6540ffe80ae6704d3a0db74cc0241c4289fde368a5e6fb3dbaca15c1aabf201b70f0af0029dca723f46170cd6f68df67f6bd291e65ead6233a500099c568fa3996192d4f150db1c52216915e3eb07451cc92b1db5e1f83eb92796beb65a4f563eb79bc9e4a6e55c24765c6ce36d952097e38827df5d0aedde807ef53dffca68b9b5b448f9790a62ef61dced149cc7f88aaafdc7a4392ada600054035de62029d90e1a9b6caddc5cf85bb5ef7ab6346027ecf36a127f67e2e2172c2b5005255043d92e1e7aa4f2fb6118b6ad10ba80c5a8d8ce5a7f755f9a02b79066059b8c239f91f09526f6127c44df37ad4388b3e2d1474684e47d61392ba1589066a2024f28be02a51981328cc51c01c7a37dbe03d0bef89cf6ec722d8e8277a16a78eed93b7d619456a15f7a13287f9ba509ea190431687c2dd5fbd99766e417a752aa28aa923b6f3219445a5b629ab931a51e5641b57eb42a3c31136317a31ed8141270e8e14e8ae2eb5efbd4aa1a8d429a030a54dd93ec1eee4d5611f50d21677fb059ca96dec12ce4a13a4412b44775a8d08dfedf68a003eee35d97e8876f521c75d3dd1b1c98656728e80a98614ba5212ce2adaaf8c281a8c9746323fd8ebe7027d6e8957232b53858bb2d8246bcf2f6842a315f71991a02798c97b2595af5621a588ade72f39ea1dc93dba305d1d96adb8fab81bc178bda81352e704f0dffd30f6846b5d50e120112a75ef8e2d4b676ef4fe87bfbfc4e8dfa165a1b70e8f32efe06f291ee6f71d3072750f0fd648d062b218ebaaaf727cb266c98173c8f6f2c8e83ddcbc95aec1de491ab2b7145b71c0745838518c3380e69676b6d22941220ba0fa247f1c184d8b704fc667a7a27408be43faab9cc61dded207ce624356db2dd8a254b616f6cd5c3b127b9573ae6053bdaeba3c3e19f976c523d95e267c268a0a6728be8b13ef2a10d394c99de10a3badf9a3b7d25c462980784984b4a03a4ce07ea6d2804e83f710ef6656655798e43b886a5b331ea21b81b7e4935a0bcc3eb4bc8262d2eb4a90ccd3ba26f46f865a151f90d0d35d8e54680347385d74086965398302027361d1b748307da220aad2d8b01c86748c7e10a049d7517852781f25e9b7e945627e4e4f39fe08eadac1e4a8acfb2e7b41710d3aabb8e127bf5ecc28f870559b2fafb896c02809acddfbc81252dffbb2ebb9be4a7d7b950b42b2832c16643a463977a35b77f11b0448a070e52ae0c0146261a9a82cfeef9f0f33796dacd16f372df2113febef03d3b54ffcca06d85673f056c0408762b704742f775385b857b4ad1b5fc3b78b238f91790791bc44eb2af5c080796efd9be31de4b90a47317d609c39245d69759df58fea73a475f2605c5688d7b292d0638c540132b199f614e5621075bc81c22dcc79c99fa9a9cf3d93a98a21ad7cba8b1b4712520c44dfbd395a5e6d9e33aa62953513eb18f9a03c5390a664b33c6c58acec3147c9a19f6943001524da66346ebdf5257b595b62feb3a5e27f32aab7cb1a1d49f1af56ade05c05de92e5197d3576ab51016cb8037cb79328e098125d31c977306a58b006e9d14dd85d705404c3d1595033b5629f74860dba91390e23d04d730d7a4f9496dc392c1f9d4b50a7dada825928beee424f58429fe40530292ef8559875371fe4c3f86702b44775e05f2b355cf2828f1507d0155e656af65702f5def563bb38022986f4e6f516a8fa106c120c214197c19447d07241fe3ff707a104904c005eb659789b6f3ebf51c12d0b69aae259631f762a8d42cc96dd67aaebd2f7eb71aa2c628a0e2e135cfa9091521184ac8c17d31b81aac6a9600d66bf0367303c58f09da355dedeb3a6dc3c9c957e293ac497ecd6507077b79f2cb7df02d5425b80c96914d90063b624a4ff621f41c8d8eebe61fecbe91ec02570ddc3f3edcc82b0922bcc0bd002ad0617da8f1431abcb712710ffb3caa6fb65608dd631c0228f3d8b86881fb6ab785d8a2c6e8c97839168aacb9788e1260e045c88d3a443a89873a474f35ca9b653c9a5ca84ed3758852952ce79a3f49f9b5569851649182c3eebbe1d2c482ba9fa61599128d33c6a7c16f3f136d56fd376e6571156a689672a402d94ae5e4c0982e675f1e94e55fd6b0f2318df6424d37a87270e1a87f34e020dce5aef07fbcd8b4e64dc1d543039eb8c4ae6520fbf3da1c3c2aeca27f095647c2eff40d801852d1823a629b206d9f62dd3aaa07468589673f1550250421892dbd7b90fd898af1305594acf016b1ad245f9e5a99e9aaf433fe5b6fb4e79a5f544689bec31527ceec019896839977974b71b1f1a9b1ae077337c0dc821e96c649322a89dd03eb7229bb3a15452e248590ddef810328ab41c084a66dece2a479f8244a01e71f7a2f910d03c3f4ffa6873902119c88fddac30a3462665e5b921e1dd4d9f867f0fd21cea67e229b6fd6f7503ad67621c3957df3e25c1b3ebb3836a6d7b1ce135b71fee38228e0a1990d7c2e4156fdeaaf6471009e15410b6b0b6cab37e5e507bd514f8f548fd859ba3d8fc14d8d8e94dc4e682cef37bde33f6d665ac9b654313815de50c219afcbde46b051c916aa17f362750e1d8280f2be78c5b16650daf149c506e791738b6a4f6bd2c31c015e32240120b98d5774e63f1c87c92a85be865c3a8906adbbe2959268dc0667a49ca5937124f36889a714cb873c0eb060d5c8cee9829100f2a12375de9517a3ea37b973ea0a96544c6eb5c7e2d1860671950ab112d8795f4b031601d778bdc79483c85c3484ee1e7bc1dc8842ccab942a1beaa5dfe16e733570b9140d3225b60243e33282107d0286bc8b5355ad7d0a102395147dc309cca2ce71ffb2a2096875f78a7715a797c3d7b2b39a9c855db6632e6eb4606fd40adca8cbcbd1c332edba27d3fceb06292434eb8a784c5a078ffa41e57a5a0cb011781639632694228fcc1a181bd6a80c7ce0cef30e9836a9589fcee4efdb371e97c70c60f6d9eaabb59a8379fea5fdd3aea9343d98cb6ea74d1a4f964442e8c6b5e81667e7b9df289440c35e5c339cbccd4b3311eaa701e9265d88e95ae20180170416774d23f13c1ddf15842df86751bf9477e42ee705159deb9dae6233317d810446929f0c509968f0da6d7ff995761da381e28f1769a0af0c2c19b98b0486bbe6aef96a96547e6eb7ed05e64aadb5035b6deeee01b9de1bdc1fcb8fdb2ff27b9263fe7e57bd4c878874888234ea869c764074a0cc6240e6908d8b3bdec28a65d1b36703db1ce93cbb79026ff06da586683e0fffb8bf326112cae4f9527d60cfd973db1d332fffd6fb058b89dd6ad802afa45793e49d3a27d2cc65769b37f3bbc25cd6514a3c2efc8feebeea2bc939555d0930f80e97fb960b38b2d9d54335e507fb9f7db5d0582a7370c106c29f134370f3259f77f941bf90f161579e1b3fa2b3f3107fd69ca0e5b05b7567fbdc00ef1c022dc901c2c5e85b11786a6649cb694d2389d9dfd032facd379788a20e9a8448c84b7ab933838eb5ccbeb38727c614244a9d1c98cd646bd30ffec92e429df2f1d637e2a6710c71aa9ab50d427f69294b313b0d7218adc9e8800273c8f3b6c4f6f2dffc3f5e2d0bd139f76d398f286597775b6f0fc9ef27d84dcd68d563c0e763dd88e89f52a272becb95e69efa12f4f89af136a9a3ff5bdc69fcd0f7c63016fbd4b9886360fe6de8a775db544cd79d4ea7f419b3792e10fad726d3bdbe6b89b00f74d026d92f6d30ea8ea7df59ea887feca6ebc6a44163351ec7b555ca06c5d1efd0d6956df439ad6d491628f59e0e801f64060226f5504942336daba27b3190903c9da2491a67467fbf5caba526eee81e0d7ae15723a5284dd553c97feedba6d22a413077602e7740ad078032d23cd8b2dfdc9ef0b1b2db7c50496566d895318f003317a05b67bf4e9a1578860f939b39f8b4e62a3896300c63b3f07904b5f8e9ddda132e1998e8ee339b5d58252de24786bb053f05708b9e20b242e926b1e88fb4dc4ad987ebfc5a097491a44855b8317251585afe208aa16ac6108fa385de4e7d6206724ea21c9132fe15dde8c84da7a974069e5fcc8de9be75b752af59c9bd7d0bc2fa4093b6060bab0e13d3f7743b9e5bdf322c7bfa8a4a8636df8c6f04a53d1111d329c1938f15c15e4a911905454f0536fbcd2873defc00d808799a015a9d56d7590d974f4f67da23c560830f72b9bcdfa50058a4461b0bfb1bfa5bad7a00b3b545168547898ec80e26482136693c5f9474a2031d2214b0bafb0e0d127dc729b4d5a1687129554caf3137082ba718a98bfc34beef697bffdfe64ee15d05d5b506dac1e174fc21059c2af874107c1d16796c0ca18415176cb8e9aedd26f2ecf6606f07ce5baeb2d0aac0d4c7ddb0f1deb93578aa2985f8dc7b2f62959e972bdad6599252db09d8c948b53c9926f03a5a19c6484d4e74f37d6d2298b9abd1025c4ecddcb41514810b25748fb387a7eab1d0057a210cfaf18ee09b5b481f34bd49a4ecc3f202c3b0711b21813a9f814231a0e799ba494f9c142e8d72c1e6c2f3078a8be69f2e0939f753f535ebef864fa221a08324cb6fd283b30a03fab6a0e653e46a9cc3b530f0cb0343c305f25c6617fbdce3e935fce77d997a2f2bfd895037b39e883d9d779645f4b2cf7e5811339fb8b98bda226622cc7ce416098c8a5dd09f286b4c9d1dc42ff39b2cd13f3b37149e6693e286ca8f9868040108ae69f2c93f67722c51cedc0ab76509f7bd73a50c6835d307c0a0d4b81c8c4fe71626e4ea0b65cc9f9432ea537a7df6b601e03b668bffe760a39949dc0d5b0bb43bbb7e8c6a9f264ba74fb80d7fdd5d70321b739a89b870f813028f9388925f888589a84812603a315d8bb8ede68fc8b7fc63aad1418c10903b5b339e9d35c68cce61cba3203f8a9b361e03c4119641f1ddb74aa39ef42ad99a4647351464106af97d127c22892a2e05036338847ca325def061f381adf072d5ea5720cd909cd5a898ad68964472ee5d88f95ac71440068f27f09b59acc05e582a5d3c23312d68eeeecf29f86c87f04fd5c7b0969e85aa4ef750a31c25a0867cc2da71a468c617b176589911d96b69f2d3361b9902dfbc89374034e68e3ed6712069ea24a464c2f7209a96d38fe6a9e45385fe6be1eb2396c8f3798d8b7b1944986e8b6062edd3ee3d496f7de8a3ef7dc58aa9e332f317c602eff352d0a8a31949f750f1d5da68464a2846456bf03929e1482ab47932b91553f81f05e0d955af18789698f85b117d413d0cc8ddecd771fe62fd10e33bb7b96138ee6c57ae45ea6d128f9aab93eb9aa5e832b31bb9075e407d9ad39b5f63b2b79384843c9867ddc35f6b2ef297e42cf101f5289ba82ff709d05fd3043bc775a324c147bf9b3e21e9d0ee341577722a0afd4c0810748ba0e258af384802dac3857164be3e78a9277937d2e4e773da2c5dcf7683158a266bd2ae8c2aa6fab95622fee79f4571e3bef127aa3652656f64c802e40516cd044adcb830c90fe183e2aa52fe21644fb36657450b4fe8ab3dbc3d7a65f23741ac4319b8afc38839fda70e2c35d6323c52726b41c669a600e4da6fed0574b1a6fd215fb83b0a896f988c30b63741f9600a441379fbda07873b5a33db48fa31b115105b1654fac4c8a6c3a1c1162a738c801dccb7a2113df759e95ea72fb8a765147d45583261091daeab256345c469e1d5f1ac0e079927bc88d1df85e12193a8088f1a3212c64e637991a99777ae48af58cf29b46e79be4e47c83045d85e5fd7aea7d55360d87d941f7dccb2d89ac932b5cd8c6f5de42e1bd457ec4bda569520f51f0d723d1b6959b7154b18a0f47d8a2739edd1b57b7664386980ef635bd5d50c87241faca662ebb361dc5b98b3e00bc6d9daafab5081604dbc9fa4e5e0a03c3422c5694bfd6cc933481ae655c267c6ccd91725e9b19f8402c19011a9d2a24b7165c78a8a8a3e468f873f96f8e9a2066b3ab96efe23bcbb73c298dd66aafaa12891b1d56fd019b4990906280c6c54b2de35395b0e0dc550082ce326ca5d0a5614b6fea4db672144d2c4f326ce20721151b0d363fc09f86e33bb19de41cdea29143472b5ab1614e2e3010cdcaa8dc4f770dad82de34507d0b70ed0803f0cb0668d5e1e5cb57634552226069f511bb294607eb11ed544b216f70b716825d0ccda5dfd84cc11a8bc5881be5c4923355df2d6f4346470e8d4192bbd9dcd25bb3d3feca146b3adb7172a59a65943fb0135b1e1816d38428769429f6311b281fdc3a9236c933163b8b2ba50640ca53817960e2e1b40b447299b7780cc1e08318a10aaf5f6a76152243a76b135194dbd916fff432f58d5c8bb7a2fb71bd13e5578e3613ed60d738d62fdf2d63214efd6ddb5f8c19af19454d8ef5c58086ea54003e293a8ead7027d8038f023094b1553578f3c9fc97d855e438d81b950b37f36e3e722461e8a12bb6227ad7ad16ab4bb30262ea114c53127adf337de558636a22234f3a454cb99ed7ab702b95c3ad93d6696c0dcaaceba10468d4a34336c9c10f74e965cad1aff21f5615d4ac72a791cf6e0097f985b98af9e76e2fc091868a686580f16e81f9e1f5e116208d77478a2cbf247d0ad0f39f48ae567bedb54a34215ac27983402e6952b460672fba508f368080c6be1be13865c6f9482087e916217d26ca478fa6ec43c97bd5a2fa12bcd4cfe687449efc2092eb10b1bbe638a6931264a0a3838909975d33beb7ae40335a9789df72d758eb8ed16984900016166bb589f35eb06eb74247d828dd2bd0e837d0397e17e00c71fb366cff396c0509930a4d3fdbc13e149a0e67a447248d40b6299a8c9a07fda55f1d9473e440d7aa16c9fb67e8bc51207074b3e5548172bc880ec396fbb0408d67776b94cc1c035a80dd5cf593cfd1e19778722a18cef48aaae400d1a29e7d70c0aa1e1d97c2c7a57117671514f82311c3bd78bc1a804563369439916ca50df8c02327d3f1e36507d99441e5a6328a85e419159eeeffeec6b6c47a8d7b39d4398f95b75ab44f06b940374ebf6988aaf1fc22af1a20af8cf0894cb7fc337aa9aba20880f6050b22f5900c344b44fbee831fc7cbb37b3bd7c7e4fbcd3c5e0e9b197fd549afd8c387d9422698a210407066e84293db464c89ae651ee5d35ed5d7ea52a044b0584cdb6cdbe17725d8715730caaceb9bcda001c07c38cf46b10fe64de04d7572e7dadfc89771106cad3fc4a3721806a368387b58f6ce0b2d4b36229dab3d1ef5e41fad2ee0509510417070cc7a95dc37ba4df87f20180e0300e9c756dc70c9c4cfed71ea9744e52ec57218a04bda11e76230d7e1f078512f4eeea88ff2deac88e96835b94f63527e966392a088e19860f3cdb258c415be4553ea6eb2a69962634d279e31b8bc04c87dc499c0b8267e4992496b34e430442c98d2906fcbdba65217bd8b857716c159bf7055aeaf0580fef6f8ef72a9d62e6b3c0201b5e4e13804d672124cc99ea89681a392864141981272a231c2f5a1f9e5ed4c142bdcbb38ae8ea9a923aa685e7f0a2746443305e9d3e4d1c71dbd66f1c3e5bdf22b5ff78493535167515761fb74589e3664fa0f011661477d0a9b035e5a86a0b64e3aee66817925237710ce9a09cb8dea58eb2c32256355a6a078ebb264e25e646566c99a39efff072c20a4c9838bd0b12e7e66e583a1a0d146064f6c21805c7dd7cfc9ef87a9e0aa2e24a5588db3956fe48909cee7c9ded54b1db398bc76e0a97017a19ac1815816a68a04a7e4ef2bc04f9809fa2843767e880c2152031204a7b5f390cdac4a7511f156289b4e7daf725c00be3b53d344eb61911601429eb9ce5e6e656bf084b0281bdcc480c1e7cf39b90912f1ab026f0296cc75bfc9ec890cb235cbfab1486e1b27feb9d467bf6dc91bbeb4325ae15127af1393c77f76125fb3921a77d35d0876a87dcec8add0fdbc9d4d31664bc283ded0dcb69e935d1cad6283fa237f8db11b6663bdbac77e9016c47f718ed98466b7de0aaa167d80668ac15a5ae8340674c3126273216c0bb814a8977f9e368b229966fa6d1a12544f10b3421a8ed0255e876a75926c3f37cb2d186cf29a79fde5720f4429450ae73c6d03d786e90d7a1494726ff1cd97887f0041789f9b63c97d5f3e306c51c9306ebcf59857ac9736804696358165fbdd7a299793e8ef308596196c83734025101771e0a48e9d54f0d769422a5a37cc43ef046f8d7a77da9d1f65ebe08423751d9089512a6d86c4f478ddc3247dfc0e5bfd60d79610167ca823a97ec2949df79825e3db90226242b1e5f37f12ce6d186b1067aa598d9ad5a0babd717aea21e74f072d08ca89a8623717d19095eae384f8ff5bc3535542966b296aca6d59c82dc8ceb8ee38fe9caa5454f29fac8dac65767d5a3de15ce4ee9ed28052641514c1b92f57b565b1ca7f2f2e1664bc0c7370773f8102875b3bf780bf9d044fdc29f326011246aa8ec5f2004ce5518444258b9d813933857405fcb9193cb78f2bdb93a59a971749c568e716581f7d869476f70547df00d77fd24b937f204cfd61d94709180ec87366c1191de41b8cf9d0b9edec592dc816ad5f207535747fe98b089c231cad5aba7466010a8dcbba6ba6a98d317b71df83d4ccad9888d92a2df16968665ced9770232211018613b90762cc1fa98fd087f47c7d90dd026ba0ea3cff39fa46c98bdb36153a7ecfdd996da0788d2a73aa9330ae259d1464f988d4adcc008c4a349adc1fd7419d77ba3d22de6c37078f81083f9a68581efb5fc498e1326c4992b14f9ee403bec0992acc878ec14f1bb5d71bcf3dd99b1374cac7a6270231246f4763a17aa65e040a87c2ec88a96935372ac7bc6245274c0d9ee57ed2347067350cfad71212fff078f5e7e9ab60729cf926c4220854a6b993f0e8aa62df27f340acd753e1c2aaa1704b1764ef9364b3bbe3f99ff036d3bde363e54f26cfecfb54baec33aa81996cc264c8490491e8c483688735cff96bcf18600e9778c70cb1e96ec7e4073762948654788b4ad9e5ecf8cd79204dacad52d511e3b97a485df483ad950bf03812008209d5f2a8834e2e0e87b0ce140cd7cb29370fe23727cca5463986ffe372ed4c054760606beaaeb7e5c5db9a2b9f228b7c5e0cb2e2306b225f8c136aace9d73dbdc55c283754d9dd271571b4cef04e9720ed2d6c8df45240d3265b759b53d0d15eeeeda7cd446e5aff31ff5ce77df686ba86daebfeaa7985dff4d91b60db30e615bc48c6d55872ecc9d1bd49acd09669d17e6455fbec1cc5ede82209e71b9088447b04ddd0dfcf002ef688dc9ab3f0eed484322dcf64972488403d97c02c0a292043f7bd86a0cdc2763c401f73d8161f8d9196bb7f1a3fea6221ec83397ed2be01505e21fabfac6cbf068b358814c80151597d42832a5dc68a425144d95d08d63c3d1656c586855ce312abe0e1bc9842c772c2e0ce631854e31c3c040f996359e4b15bc53fecaf0447a7d704a3952786bd7e031ca42d0b2b8944cc717157198b17c29c535d643eb8d3ad154b7a55ea8c46daa7eb2c99862c32e9dab824101a11b1924bca70ca5e16105713b8a7f20fe7afb7d56d511145c75a9fed0548b705cb6f61a042214a967f78cb75b681bfb916e52b9bdb79cca9d469af561a3f820c62a6d384bd5422a598fe08e81255cc0473563b329959450fbd3e76b55b0770d9c63969e8a1d2b6cfbc4ae2ae046a2c267563b43c8a594f62495f1f25866f587bd89f33aa87db3e0752da0d255423b8f642b76f2a3c6b69204b87c723faa01d9f9617f82ed3497ed106ae77fe82f09de33a602d689fe4084b2069be1edff05c45c932727990a363e22da7a47ef548e803d94b89cb68dc1a9717cc0466c03a19808cdfe4f95d9101234377ec771a0f3ecbb0cae3ebe1b645f82a877a9e695da204cab4a80ffe0b9c0ae8dc78b732fd387143fe7c5e0de53560a09d41af6d6bc34364d7f5ef5ce8974a451d3815d25d796d1ef8af2aea36674f2b9be9ab7bd640fa471c44e9b4ea9797c6028750fa1741eb6a8acbd9ca63ff778b2f7578a67cd713cb3740e8aeca84f853e8867138340db64b20a0ab4817dc78061f9ce4aa1c0e8403d4a6b6d7e9dc00e2b4bedab56f41c660b98d8ce42eb9d100b8c5ebae31d6098f071d10b4a9362047d0ea4d800e7780dfae97b2869ef99549a4e314dc1c4cd35c362a965d51a71c0a47013edfb4788ba0b7178ac42d88469fa34992633a049c7fbccf5570dfcd59a8f4fb55905d26676968903e20b4d60b45c7787c7f1d2c6ca45690774ea2e76cbc591b7bee3068030f867d1e6a6909bd75b58ddf84c9acd876253e39e445634fd6be50b595753d14c96bfad6d4fd075b4eae6515494a38cbb0bd917fe79e6c50aaa10cc4c06c1eb0a2327dd5edc38119bf0f32c8ec2826624fd5642b3db34434638612cfdad1c9c5a4e90190f744e5e748556091aa5531cab4fa7933cb590ddff790ec5e1deb0a7a08547d36e73674fdd1a0bc3498969d3c533c9aee3442a1f5abe39bc388cfb189b2223b80e5df4ab66ceafa907e401fdb714a6c5bec5dbc91b705065ea4ee39959761a660032f693c371a30615b38d572a6968f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
