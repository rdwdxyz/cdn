<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e7b3637b0b7238c48a74cf08f7f49ed4bdc7e9f378fbd1d4cb1922e288f7952b8f5e13931ff964ba3e40ec7d8bc4e4091aa4bc051af386d8d70f964582c1e733a8800c39495e4aa0b0772c9ac3cbfb2c3764b6c377959630d87b5cd9d14ebde07f509be1c62cf08e508ce4dff276f9f94777f770a7039d6e41684ddd475420b2945207a0e5d95788d683cd275bf539cb54c5506a6ea6793881a4471013e0865d081f72847dacdd44b7de7c3afde17359218f9c862e2473a0634d500683534efe77fce7327b545f25c6af6b3085d480520982f17342f0b372ed9a044c8d7126e28e706dffea60955886436151474bce36d3f1a86ed689e958745af6c05ef239d663e8785c5fdc19f6a58a9dc33ddeae1a1b95aa066537a4412366059c0da0279c8509adf92c0f75cffdb4d9910e13e6f765806b2ca6caf3d50d2e00509426abe1c0d097ae9c0af8d6ab40f4e05875e04e1539aae2602c1abb8cd87fe7a1e6eeaa808431b7eda43f10256815b4264095c567a1e082b309382add4c6ca0586d9f30c413feab061d428a89a4bfcc71ad3fa50c81e6f14e4f8206c6eb64d083ea092f9d6b2bb8c661152f3dcf52d5bca76b83b8b4b537fd6ad15958c726d350aadb8cd6f7c2465b4502a685793e0e70a70e2a610bf411973f98a837d0be0b361e80c8d74b576a5cd217749978c68a52c18de863321c253708c05688c9bc9be314c7ce631e4f8ade3f06c47b734488dcb1b4b5cbed4b01b1e1d14665f49d9bad1b866a777ea433954ad2e58603b199ce84b5f30add0563b16d63bf6df12317c7aac7ea0c415a26f407fbf9f917dd0006b174c0d682bdab11d003f7716ff927b1b7e233182d70c4eafee45c17ed714ea366943a26feeb08dbab2b9fa48ef3add83394e7b34252f47a3262a24a9829043cd4152453250c128a5233464942fb1142f5eeebbddca1a729dffe29c70a531beee3591b17032f3e11b30d3931c171b90c894d33126212baf66076abf4e3d2a562ab1e62087eb220feb348544a14b471ee3d569844e6f3786ba7303d2ec8e22f23fff477400476624cf61c7674df55428e8ecd8317e88a24a1c85a1ad5795330d9a4419a719f9119be46ffc30f1a7a8b11ad1d5e66d93f50512950b92958de8e0e0dc8121c5b1726c6505c818f7928cefc12095133b191c12694a3fc28861c798603c360c4b26f5fb009618a36c2e625f39e279127869e561d0942f2d6832ea4cd5fa1c9b4ae42513350c3f5c08973198ccf1fc5bfa3d7816bddcf0262aef5a2583e6b8c0f978be2073910e56aa77136175222385b956d824834789ca6043ba87d42eaf17b5a1ad0df2e4cb8914f8ba0aef47cf763f4151ce2baa15afc6ceb86117eaa218708c16d5d5dd12898d6d9826afb7f8d7977ee8f9f9f56263b8b4b1db1cd57ae18fa1894eb93ef9f25c37534655c6c3c50632d359fe77a394a3eb9cce442175eec71d21e10a64ab793e6f254ba5c165fae83c37f9c1c12e43770dbd61b5281d344c91b89f43ac2ba5f96dd9f302a6fbb87b20470c2e9f5f2df0d24f0269863aee1debb5f7128b09c78ad768ddcfa6b63522e9ad5051e5de51e4547ccf4e0643139a0633dd06664afb01562ac3ba5fa348b629312b041845f36832acf5c1a1863fea2821909f85c4b549391e105e690ac7fc420f8c2981115ae17556068d3dd9d81978a182a4ba5121bbd1f68fb6d72430908d3a5c96668ff236306d348a5fcd2cce285970dfa8b95b5daa5cf318ceecb690781e0ea70b07ce42c6bb4c95953ce66f1229ee809197386832dc35141cb6667bb10569afe9156889d4bc1d5e39672308678de2cb2df54cb6c50728bb2ff7c50f517cf536de950a63b3071d80ef487563de6ead61499caabffee75eb9497184fad779010955b6c629e5ddb24ea02bc254ee5f9ca3ebe1418cf12ce6f360b32eb2aad9c6905d910feb7055f81f634f40e83c2b3a9b758745bfe72a5422d7786e4c425c28f0dba6d0e833fa06e22f6a209ca9be6a3739dfb3c5aeca010d1d06d656a6e6547d6311de14338ac805c7d8f8f3a14660fdc0c9c6b83cf248259a7adf62c18353550f5a5451c30c94d8f129e813f3952b4bd2152e9c44016a1cdafea8ba6df956c8822b8eb36e172c7f8d5142e01768b4293ab7080bfa586f6c7e5dd3a32ce365d55168d5f33e7d582ff7954a333d86a1b33f5617289ec04434c76ff8465d0f27421cf84d38a2513fd3fd8eb1cf6481fc8fc77a627a4a01bbd690ad0cc31b757a902cde8023bef640b9550d55f40b597d46fa8bc624f81af7b39b12afc9f4bc99d19e2f9d96b6a7c3fdbbc7d75469e11362ebc3a39867cf53823f0749724ab9836e2e212791593a9e85b61eed71b6cd4dd55ba777d7b185503b76ce3e1ff57939b45c07d7015e41f23dfa31a78a69572f4667765f66b45d9a7978afa273ecca77fb3a02d54c5c8c6bf54ec3dfcc5e36c13a06c83e3968f822c118c4e14d41771aa8f370ca656a19faebfa5834c68f67314058d48424501baef30947ff4fc88b0a5ea84d22d3dfef330e33e48366af125b16e28e5096e31d9f56d0843deee712f8907dc7e0c6388af245122bf0c704ef75dfde1a09a67470dd1e2edbdc22504391b685046f1cc3df994348fbd3810aa3152dd45cd2000bc59550ada04344d09e47953832f8acd21b6592c2ead169ac90a74087a3afffa4cc1a7781381fa290002411db8f5cadd3a79912634d48f447ba18dfa7bd6feb605f22ca50ffe8781fac35480c693fec0041c84ad1b891c7b16b63a5f851049d9732a088f804eb1c1276728ce16efb3f0cc27830c83b82719b14571d0c6062e3728aa6908cd58bc71611783a50b8732c21a1dad83ab8e33ff884f64f8d27aae3021732e5355f3cd6958c55f28d9e5af45c6a5e8eedecd70dfeec65a311baa07a06df5ca7683f69a408ee4af08f89ac798e4368f78142c7819021d7ebc5ee7dd2127d9d40ecff78ecf43156e4e0027bb315bde5cdde9ccdd41479bba8503dca096693e62b6009d07c6365573ad411eb6afb09c21af952bb429e3ec24fa32f5acad4388408b0327c8cd31eaeee72505fcdfe444acec0795840430454787e523d5f9fc19c1631cd1541676fbb66492c928d361b3c49da52ff197ee13ed63f61dbb13f1815958a319123060d3b16a3c5db5c10793147fc68ad530e8266edb317582041bd43013ad51224c1f07701ece8c7fe99389328248fd5e678f21f131b09545bd1825bda3004092af99332b977aa907e28783fccda23809dd72da3c659add5e4175b875a2f418bf7f4d09f7b81044115843fbbf51d6801b81fd6d0793565283329db753a50a35bcab6a834b5e6f22227c32308e5001a4c9e2084810a670da58372e90e47c93d66fbbeb01c3af0c407f3c954ca34fa0b35c118f895241cc94c01f1c3f3ba905b429227978109bd253d87cf62c328c1a18e19d52c541d53282de306de45ea366ca42ad9029b488c4949ecda6f21eaa0e2c4a32aec0b1bcd7c203a32922ee34813700b55dce7ee3aea1bb2e2e6c7ce8b122ebc6aa0d10a2c6f3516abc020acf0fdcfc7c679bc78ed0ca77db6bc1343e2f7ce2a2bc3679b38e56bf85d83d060686e09c03f3f13e56482403a94622bef0394eecf4ba67a632a0649419b21d9614cdc459b459a5e949ad071ee0d681c5752ab8ffdbd4f2f1fd14a1b8b176f8309d741134136bf05404989c485122360ce11dc20aae20fd23ff7994b986ae1d3a599fbf5018b4917264cccd9e5413b1e691e491612c43293590991e1674caa9fe25ae00b7d6464eda17e1b98ecf42a892a764819044aa6b1d6e79ca95affac4ced460615ad7491d95eab3bc5c5df2e79f1e906fd5fbf3168bb45cfe1fc3e692d13275bb9026da0ccde0b5e4bca3d0de815ecbf82b7a46d499b4e47c5c88cf443489630afb0848e3344fa4aba5283785cd575529a363421fe3510e6148f41bd9f1a949638c7c6fe94c408a7e20388996cdf41f5f541fc1ccbb961622403667939cf9a47e9e6049bd6f8727c572a92db76879c6b735aba05dcd86d5b76ecbdd5095af8d876a58ce58beb87089f463ed6dff1798834e103ac9a93e49254e125a505c82aef0ede7d8d39bbefa4ea544ba97527d3981eb6f37f6e8c565f7cefc0f2a099f3d6a769e955c1be28b6d1f41c2fb7c89f06f6a4c73b264de9c4d7a73d040327ded2ee6299d2ee34283b6abf2d0c1202f7096631d71a924acc9bf5f591e1ef11bfb5593c1450f693c4304785608380426be6f8dc09e81b14043766094899a91df229adbacd8ab75dbb9a3913166facde07320065be3366da011a1734955f6ddfccdb856c265e3a44b44e8f0214bcf67168e18b4bffe63aaffb283bbe07bfdac7d44f1b1189df23afdfe0aa92fa229bd605461b66aa3e3e7532a5ec4ae4a32d881993e7e5b7abe6c33c86e90e3b7adaf66ac646c80f8d7906b3b6755563f6548e32b824cee26e23209624194fa3f58763d830820515b50402533ee7e32d8aff66fe1074ff43b9df76559546550744ad7283af9e861e950d1c7b651c548d1872f603bd85b45dc0c9904a2e7a4d60ad6e2cabe95f8cab35c6e91a30320505b4d6d74ab402a525900e89f0a0cc58994060d9eaa9911a0a3a2aad9b2a89f6a0cfb1c5f52b6da9175dc91b33b1c04484a82373533d711ef2ff2fa73dde02bced63d28b6358982f56d5bb5bf0d6312ab957e95b69b88daf0fceff26e3441dd2aec218ff0b0b4eb13a078e54e92a2079d302710ae19592730eb6aefff675febf235c461a37975e0b1a05b0915f791da8d863ebec58feb10cf5553eded672647de48e762a49624281b2e03733c5aaea99dd3bb1d21088f175ef122e05a1085e3058089bfd4fe2bd02253b250f6ef26b4e7101175872dd92499b7e3c2630c0ef88b346fe02c11c2576bdd6b1ad5308300ae2fcae78af06e7f0bdac21673400eb60b49e8293a21b8320004dffc0f59547a9a6db41a86e80a93b3d68dd468b0821ed657f5e23b2f5c0545229d8fed41c60e20b345d4f12da866963cb510fdb1df36a5da5c9be5ab7897e1532c3feca0d467748b233dd4ebd216eb5125ab54173aa7e8d2872092efd5edc8c8ed8f5646f2e5b9e7c3237a82edbdb2cb6e135a1c87694f8f050bede4f7b4ecbdfefe2544fff9ce976059923aa03c4a1cb75e4d01d40eb8ed992c0df5f482ae2849abd6018adb50d518fee764426378771ad098fd66863bb9da30e868c3c1c953a1046e79b7cdd2e7783e9817855e3ddcdd3b805eb1b977603d03f3c954f603e419f690013dac6a77a051bbfcf908b8122f9b37cbd8d51c45b254d5e0c310f033c69e300759b02fb38108dcfc4d4bb68cd4571c164fa605beaf2dadac67bdc4f98a4a522a7b3a3aca0d691b6c9de71e250b6a4cb430ffd1fe1fd2a66b1ed1ed9abed20bb00dae18ed6c14c3fd5fddb3d7c5a6dd7b8f77dc21d8ad7e469780f82525bfca60813c0b9bf0a34267f366b92cf608bb6fcd2c9ceff1ed3f1be6e07c8e1c74893783b718c6955ee2aa24a8d63017354d28b89d121438408369b2fc58f51a117d8aac6148ea4c5743118edf313aa1bd0f5cb6d72d9a1025d28e4689d4d40dfe413f4e8d17bb349c57b42b7ebf36e8f33294b60637cbefe264f28060a5ff6e3c3c03719a5551576f3630d9f5f13020ec4fba7e0efee56e73e285d24f92ee24c8d68ce9cabb667a711b229edfb3039326eef46a382306a7d7a4160dee209b246435580893178fb1e5e5d2ab466e9638001397ee7e2a1e744bbcc918a8fbe8005ccc850868d3ebe0d25cd74444b599d9b28c6cb48732ec5f775af59633b5b820cf9a1c814193cb9f70ba83d5c6dc72ae0594ed816661c5b2f69cd9f8c7ffb539c4f172c76064375c27ecb2aa53837d4fb7e6f73fd176b75072582a65bc22eda8dc5bc2b0e57927bdb942a9c0d4554b68b044dbccefbf3613d2873b6c3e90d2fb6e169cc3884594147c36cbf46a344458b2bcaf584acd6108524a6d70953968fe00533987dc5bcab66301b272213d67cc4a2d196d5e3fcfcfc57d0450aca6953b7409f93ccd5dd7405b9c1f88e017fb935895236192cba2adc974a0e5831626b0cfab2a156760a176e50daaf29838adab078500b0be4c44e6ee2f69bf600bfa554b974f5423abc4d03125610fd011a1e905519d03b498f4aed81428f0e779d54cadba18e8afe1c48d1e9ce0aed2c01ea28c68bbba395f5fdd7329888626af8285fbabf510fca9c31486580e9c574ef3fab09791555403f25d224dc586595f73fde8ce9f8c293edc2ce21ba3e0c81fcc3c6dc5c62fea9bd393f9fed0a49c1ee19b8fd7948cb386793e276830c3d31c939e6317a123806b9c4683b72b114ea5c662c35d8160ba593d1d1f8660e7dd8f8eae40e15a507191cb6cdf1ff8a6afe583aa3f91a2ad2cbba7d52fd0314410763b996df0dbaf46969acdae5a83d7076c5d3908943f925751081e4fa44cf1f1339ad30448e5382cded90ebfe1a6ff1555e2af8616db493e4ef61a558b1a5d36329aea219ffe3236755eb93493f1ca6c57e5eead7f1d54e1770d119e85c0493c0310e7732344761c2485513f28adf1fcdb85a33bf9e34ea0171756660549e5d82e7523a4f62ed35f7483575b363a3b2c7538cfe0f56d7fdbabd2405227758be28ee8dce8a0cd8648192b42c77e180190734e3a3b799ad9c1d614971ba67164c82f37e867489a9c47a4271d6f82e85d7c7aaf4f2680255ee09190c9c787801e7d74369f84313ac274e62cdef8d511ba5f8a7e4f38c0dfbe63439022a809733fddcd54153b4eb9b0723cdbad3c810854c3f682d4265c6d17ffcfb10a47a0b13a2c846b920f26886494cffb5c3352e0ac271348b38c6e1f91008be730427272ec773e9a17572f846022dd367add80f7107de1178e627b4ecbcf02c5d2bf2988db079530525399019c12c9e12e388661b240fafeb9660692128ba1d6641ad630cbdfd526840a36c430385eefc92e8cc906f09428f91fd20cf06acc8fa3f027adc424e9c0aa01c83c8a1cb1c6f1a47093e475d003d365cf617ed0e549f3ebbe998690f1127963efb858c2a5235a653074055a6b50aedc25a1dbb83cdba017d71e4ad91b34ecbb0159cbad0b00775a99f1b2a679a13cb590888df376403d229ca7874583c7feab9dbaddd89b50d989e5aea440fe8ecd14dc777774ef29de8c942a986e0cda45369c35eff8fd51acc8d2b8982dccdfb55f87d447512bada8672d60ff206648f39073861be60198838a08131a54f26fae94036d296e99cd30648f43ad12d7b531145ff4ba8640e62916f8bc339e17f9a3fda6984667f8de6d79816a9f846b8b80de42fe5ae6a61fcee7f636102526f67a6e050ab6d233358a50ab086d9eb4c48ccdb2af6c076c8027c449ecba596a82b60831c8aaaf7725749c85a00d914d3c05bcaaf100f90bd73947f7df0e1df5db66b5be49353aa9e0fbb93d16f1c2aa02e50e983f4870dfd2c98af1e519a82c2a46bc3af1c8b3d0230738cc9805433f76bac02101e7b9ced55dcef9d9f18b9128041b831ad3d38320e04f07626d1d9eeb93255659b3a521c27553aff41b5ea79520fb2b06515cd404b5eaaf48910abec37d3eaac792f568ed2981f5a71acf6f75be93d9c6cb96802218b72c519746675dde5151926f9c141f31ef13ac9cbde88ca5ce9c7a3d21296f2b1891f87fcfc8371aa63da8573efe5f1d0c4e3cb685e60abcf530da0a39a0f24106ff6595ff1cb60837492929a2ae15f6dcd8e85009db5e1d783d1d1911e8ebc495967aac9223476e6928fb1b7977647b1fcf7ccf0b37aba085f53bc4d70a13fea6e082b8aaad6995a69ec1920de0bd7e9616fe109380b67bb349776993455b45eaaae66cf2d6fde1f577ac6bfd74e1fc1b42586d7c1a48073593edc763a8a1f9ab28dd45bb52a5faa1d80f4e4b4fe21eff352e741a4da489279a00d0444374d8cdd46e0db3bbf0f1b8032571e4db6a2501384c03acfb764f97dac7af2353d98fd0f2fc8b71cb9a9df7a106bfdb7f9e7616a9601bc1157ab04d72db7b0bed51ade63419b760d4a6b6d295b35706fd8fa8d5dbca3ea801fce8b3de6b9df3a182686a004621420a7116b5919daa86f52249b298ed0f75774f590a02e874aa1e792e6e8de9229e8465ef7e0f4b038a291e9be381e28fb019fec8e0fd93370aaf4dbbec09a0eb5c2b4ac220944bd0334db4e8836886945281b4a1ba337e9af16753914a29abe542c479e8f1b6922d8b4e5d6be73af6e25d195ccf52c6d16e32ba440a959dadc59aa9b54755e7060ace3992512c71d52bf83f5cd8c0cdf503547a5f5fad939aaedc01ff17f838539d1ce76eec7a307d716a83a0802ecd2438dc617d2f89eb51ec0846b9e9decdce4a30aea6d16b837b579e12c9600338762e3cd979fad8e5f91f1bb83a73bf1e685e89cae465082687b70c487a6bc10dab73f04cdc6134c4a877399e38664a2564a334fb3c8f599e8d333e9d2e4dfec2ba13771b9292dabee495c939a88e22c140622a169c2097977e694a19c395ab42a9b864a0472fb9ba740728558de7377cd2217ab1354b6dea79580723b03392ca8d9c070ff0319e20a74de87e91a8be3f2f118ee70348a110d115a8d9438c4e86233a98640bc817a3e9bc18612cc12dae5d181d3f3830b71207324b51651050ae59d1e725e8a849e20443e72f2996c72c5a5340abefd94a3a2ac8c6930718349bb97a1d61df8f5dd735f7eb3accfa2d5d704276eeaeaacdbf51b4ef786738aac37902adfb335fe0f255d0818b4ef4ab878033f111615a2d5fe404e7399fa7ef30fb04c8fd0068f7fabaddef6eec39e4b5143daa5293363b9518e8bf1b151331a88dfec57be8cf6069e877208e0f9b1b93be322d2b8ea212c8fcea7dbe5b25855b55a20ae3d4874427c5720b4c23baecaed77ecc1a65993c14cbb60d549f28be83a1d1ea6c9aa2125b1a9754fadc9930938e607798fa00c707ed78ce63e4d0dd90dcd274d5c3a05c270b98c404e491e58b3bedafa8d23611ad4b602bf517f68c426647004a623d4dc5555e359402ff95b9cd37f78c6c8e1dcfcaff8cf8d997281e90fdfa682c5c63b5cd5cc9adb09904c8e1752ab302498548a209699dae582c5d1caa42acb8b50ba7fc649cea2d159215777f23d6b5a05cbef7f8637a86d3b44fb8e6f747f4ea680f77ee94cac3f8beff1d5a204a032fb9d1bca580defa3688088d0483360f5911939eb7e5708e621d01d368af1a2785667f9e84e819b1016efb3cc96325411316262cc5f953f372e29b147041ab64d05852e7dbf20bce4071777cdedef90650ab53a7d05885e0ea7c0ff9c85ee13ac678192495c64dacf2f27aa311dcd0fad8cb998f7afe968dc340835af3afefeba421965054d6ca3fdf366ebaeb1817e95e3e92c46e1a7cd87682c991b1bfdb3377cad90028efe032a874296bfd3f6056d742b096c168e771251df95b866ad3a68a870db9140692639cb0ed50c1fd7ebd7de42609a182ddd78ebac8e367debdc0561dee00616749daca31a240c56359c80450530873afbd8d93b64e4484e4ce4e90c2a66aadd06dc3b866eca1c9f0d14310229c9562facbaeb059d255bf6fa81ac77278a29c4eaa059b5c2fc5bf00c2ddeb131c010f12853dd4b966659a088956bb591303a9d74006c9e76c9929758ab0b83fd595d1922f4fc6e4564ff5ea06e5d1612fa98e7cf748400e14cfb881b4acb36fd560845e978755aafffc006cb83b0b985ea7015c9f0438af03f4681640a49b248c2e81cc07b56816c2dfb64b9e684aa654c33d816580894bc0383c3a9e0a7131e381cbb59a5f69e6356cc50b36fc21edfff802e8c22c7104034d9f9742105f256c986cdc9b7fd5ae9a7e035b37db25cb9deca53d3ff552cb9e1ba2abfe84fbc5e9b447eff659b801c50f2c2c0f2d5957c713c4d58730366ba411edc8c93d5fb224c6248be26f4e909020dd59691e8a958c88d27d26a3b8eee52b8213959f0b6413aac1cefc190fb169b6cf991814ace94055d64f90f94dce157f59712442bb8380518308dd6e8b90364ae8dad5d444de263aba6f1873aa9aa2d014a578a095f164dd0de0936c31e7bc059bb23ddc6578429aabefb6a59a25c627471174d50c2b107e169edd54b10c7dd3e4e346cbfa37fab36f27188cd00ce3f39118329fd51b73b9ac43d36fe37828eb2e9b3f007cd531e9ecde34d788185e41c249a86de092127b0ca8475fa51dffe1becbe5c489d83af195ee4df996623e12d7de5d46e8c9f5e6e3d8ed60b4470e4b9b0c349312ef994f7b9aea795eeaa3b043d4c198af874da4760abc6a25a3f04340f1b690b9271ab068d5887e02f72169538aed6e578698699dd548003a34159f1dc8e28773367236234fe170e45631fb13b698ce280065131a5aa7b450f7ad9e3c194dd117de7a36a779450710966f4ad5c6ba368475d37147dc73fa428538471fe92b5be3c11b3b58106cddddf74d60eab83fe534e75add4519af148eb49eb6445c143f678c3bd04719f1b7c8cbd2fe0945a7c9f9c7e6d7b3f064cc3219bb5e15787fe91e7bb6640eb91609375171e84bf8673d8c3d1bf70ffb585bc8f15c0ee9c10fe7ef9bd775492d26bbe20d9a970a2945e96bbe0ccf0a18694707069c25a1f58500daa75fbf3935bc31ce77d5a294dfaf7a0c4da2d3a5c42f403caf64fbb063e7b488fdab4325d26a6cd20383968535b7f4adfa73b214bf1435adb255ceb10202f2f671488817d27b3fa33e179b0160a50c691a39e6b29161e1bf0dfb159e30669308d629b76f3fc1010b7ea6b26d15cff5f82a0f777b467ad1fb7fd57ad35becd4b696ccd2b5316d1b9c2bc11593f0e683f12f6ddc38bfbce1e642d030b66a35c15a2dc211147ae6f57e0134b992164798db9d58e99518fcdd9a926828a46b98f62cfbd962703a82596332a8f3f38fdb243d570cf313b38225b91e1d186c401f7a3cdac8a168955124ef1e5c34cca824b9403c6e1b5c2c3e48f2cddda5b0d5793598afec8a9cdbb6c32fb0c58d83ad23234fff9daee147f7c95bbeec8ddeeb7989d424b2ce0fade2f7f2c329a1808fa267e0ae1a241382384fbc4ffa0d23bbb336fecb6fc66f198277db0db38285187da2ce0a4e61f2defda05a0863198694c673e025672f40a1f4f64ba1c0f797d35b615593e264bb02661fdf169bd8c6b72326dc5717cf2bea4ec3b456936a413c0017bfeb5c10e21efe9fe65b03864bba331f25b9fd23b2ccf6613088cb233567cfb97c03b8cefe54a3a02e5f11ddb848abc32b666f9820c7319fb3e93c4282af2d19b4aa7024900b3285a1f0435e9993c44c5890f91e67e67a984df6aca863ae3e5db7821fc54d1d9cbde88aa0d2b82521f576d65ec03eecbe7352a777e40c9001a3b4b1ecb94c4c142a5b7931df5acc985ee4ec2ec838551a194069a20a97028d78712b1d3a49bf4304f884975f4aa7fad6c2b314c30ef24d12817d11641a9f230610c4278f9fa6f01952983be8fa7a946e3e30875148c03e81ae47e0e201c81c2266145d56c04f88d97358bd96f023cd19a82a317b42ea57adeddd379a555098784741b651fe9dfb0304c294360b25532db066679f4509fcd52c4d747defccf45c59b0dae75e25d36529a4f371e80c93b2f85536e5cf40a75e7bb503e3b0671aca38dbb18bd266248a371042bba7fa7d3cbe8f90dd2bb0c3127dd68d367cc395763bd2807668ffb8211707cd273f405581fdbf7298a8a4a25de05a2ab4ca7e2709546faec5a3a4b9ed52f369448ccf3ee83df17d9553b7aa0e7f90a05e2bf41f627e27d11045f60ba0321d3df36d2214f2010389b2b98a0ad90a7f799daa7a642853c0aefb3353a62b766833072f4bb0c72d9ca5124d3e0c1b12264fa67b486f9f3e626911759a7017c881f62bc1b3bea27e7d6a6dac688f96cc2372f00f5b9008ccc8240fff1d998f25a2752b3e4bf018c68f056e4b13a9155439463eb1a66e9fa7cbdf89b5e4413d85a96f73a2121117f44d0e9d1ad9c0bc80c36af905923e32235f5e6b491e97e83c79d5821386dbfa62bb9432a07c98e3a5ac8e3ded4d519fb7cc5552924369c05dbf9982998f253997f466f53910e079ac6779a68f41702a8e35332a1c7ac1d48e9bdb227971f4f416637d36fee34a5ec39c2d00d4d0d0bd3f7b5e8b10896833f55c0fc634f4822f0e9f7d13ba74dd1b978bf945042b5ffa4b5764fbb9fcf65d56e8c24a7f3c595cfd9339501fe646613849e342a75be006c9ac86de1a69888bc12ea09f06900da6ab463aa14f85a824d15b754a9f39f8a1f7fe2437996abdcddd912fd17f695fa95ab2b233f23a466704c748cd9f4365edda1a369c7400ca6f17fab35bc4567286ab57209c8fb5fe73c282858c8181ba60178de5aa0e84b2822b83600f4f7c957ab2f32a35fb8929e591d38f6f7597a4446c203a211bbaa647a124ed6b7a4a47546476fe90fe2e71b16359f26b6dfbe55dbd487b59d5564dcc88c1554fe0cd3097e7a661c5b02f4fafe7f379306eaf8bb8a28bedfbc5c643a57eb49bad610837e602bb2cf2ef9a6c460b27ea0c3ea8797357574ce03f327e23ec03b1369efdf03797bbbcaa863a9e9aee0061af3220a05db8bf81e424d6c24b753e28ccb91f392053deb85b84bd116db90f90c1b9d6f6256e56575007c5650c54bf1d635a45b4fce51350ba633e847a3bd528b2596e822242a215012701dc701229f177f6cd7e8d2f7208b7f889bb5e953ee4d6e7e45b1997f4ba64ec39bff04588fa76acc59555c7610baa46929d496a255e22f1310ca378aa518530c2bf369526e97d18d46cb32a031c3e450820c13b4f80d60d3d7f789df494cafd196e01fe574087e0527acde0f4b9f9da5077d72231dcb068aeca3e680bc7d564d85b6bc741914f33c14976955d008c1296a164c881f68200df6d9617687eb58b588c903f9af5da87f0c8ba67980af200cbe7f78823f290e88d9d5cea0dd6a7163e53f71e00b35784e056badfaf492269b4c26d67b638d007f53dc425c5457f594895a830ec390fd8961c962cdc12be7cc2462a2846a9d0861f9735e6353d89016771ce8c11be80fcaa8cd77a591fd28c6d46f3d421295785ce9abcd1d09f69d08e6522996bbbb57adb6827a5566c2db7db0eadcd950482e7381988ba260c30d39ef32aed90a29758c6b10da0ee4fc7c2c32d4ebd02a59caa52890c2392eb4459c6834718886863d3ce786ee921de8a05c436ee5b18102235a90375d16071317a769465cc358ac4ad765e66f6762641d88271b2f87520a61102bed25199d9104b0162e5fdf6aa611404840d07ab435120911fc7bf37a10105c8785ab541ad4804441af8982ac279489257876752968a454eb0c5c4625f73980b5014effc18984288fc023cb040e58c7b5907a50369173ddb8f6120e7152b872e768013bde21bcb904b7e0f83a76733a0115e3997a38083cc8637d0055c3867a1b706e5a861dbad83405ef028e58cd24fb3e99cf45ee0393d5cc3df7122faaa531b1dd1043318f3c1e89f1d9960f6fc2bafbab192db8c0baf15e4dd7cdce4324950ed82d05e8c49381e384b77f1ba8910d1cd157b7f466b46226ebd298e71d4a14d50c23ab14e56f2b7b0ad01e29ec622000e9912f2b484ec4f48a61c30cd399760e9c02ed1c69d8b33f7a8965920696346ea8500d2cf255aa56093ee562c98595af8b8ae13169e241c6f532b0dc0e8fcb4cb76d86fb1da7f75afb4298bc161f6fceb59c704528b4c2135facda6f5848bf0f8a97830382f514360d21ff806971c887b6bc47f7eab572be19882eeade9683964fc3c8ce336670c5b76a799d4a4d83aca8aea99f062e304ec28009fa3d7b8259be3657ca9bbb354993d0ed1dffad51c549d5417eb0238e11f25fdfd16e55223a8bf8968003d1c7aece59299ef33a484a9ccc6c1dd1551f4c3976511c691ba4075f613f3b708001515c79da814633ac90b0f7619765bd546e1fd8f46a0ec8fb024f9e334aaf6ee0d1f5692888ce551f0d294f9ecabbb8f2fdb7096df344746e2a1e437a5692019cfc3e99c1aad4cd21d81f19ed479cc15b675d971d33aa7aee50d1390ee1c415afabee8b8cd35efba3f6008851bdae3499d29eaf5fbbdc89127da033017915c3ff95a90e8f0527fdf5a6676a0f7f5e02692eb0274a76b5ffe2f04c7380d0659a68b201b3b46228e765ac68448ff22bd1239bb8de967753c6f146c1cad23d78948e606e767a2dfb58c93253c3629a28fd29e82f4aba9fd3387fcdd20d293f59ec99f801effa656c0a39db744a16e0256a837426e185c708a8ebb3606daa6cd6100f9fc40cb3570779ab20dfe228cc94b4ccdba9222830b3613a89a21b21902c45851544ee3c6ae7ee9d13d23dae318cc85003150bbb0bd29bd5e354bf944dac5b264503f1d3bb6b459b02faaaa72df3647948dbd5ca9bcd5bddf11f9f96bc87bbe0aac441f86d8f0c60c13edece0f2e556091ade71358197c0747aa0c5d5f8f1fe95f92712c45c01049b2f229c163864aa7c70f92a323b6b0fd0083211e664fddd24568c9520b664657cf5731d380a350d21358c1b46c39186764cfd47c8650839b2b55fb405018ceb98dda6084472bbb94c871fbd048cc6c6aaa55b85e1532b3028b198014bd17c30fe6a3c95bdfecd5fe6b6059d5afa25774f163a69ea8bdad537c9b544fb8bf645d339a7fb823e39886cbf6144da9364ddba521a5aec59db4d249cec499ca865ba45ad383d854cf0c34a3ea4b4b4a890ca8f1d0ca331c0c9aea7dbcea57bc794190337f58427ef3fee01c17388053e269a45cd046e63072c63083f18d333b20b4aae8b6aee48fec23919203600163842ec7cd7b3ddb9f20d0dea09f42f97b5eb0d070d69be980f92d47e1469ed324f485bf679a35edce9ec39a8c271592d064cc2aa25e5b22e07d6bc5142c5455cc4bf509c2c897aa043cc1347f8b1f8f149364e41d6fd0f94e84df84aca623a9d713dcf9236cbcb7e63c1eea7e5f78580be7975596a60cf5266ddad16f080ca103da5d0183210093b40274444c75e9b3e2d64745e5c9db81231c761084241fa319a9310fd9cd2e804545627349f36a5f2836ee729a670535957a589771e6203db6004ed667984107994c6beca2e00d5db7e4c07deeac47727967c47e1918fb8713e97a722ea64b6e6c5c55c62f903549922c764f831edc57134d36c4de304edee0e808b257989d7deee8532dbfa84a3ac3c35ba019e2a9b965d49d23be41d9a2b57a4c08360bcbda9dc83b87a8c834f4c24780423ff140c778281f47f3788c492b3a9e2d21055e7bc8d5348838f30e4a1b6d882470d6cb7ae128a440e7ac23674a8de22f940eaf11280509aeb16b66c9bf03206c0d885965491a5caa1a0aec188edba6182a76d49263678b100e406821dedb64776a5ce5fd3cc95de1f889308a92f37121e0837a6f8e5042bec0f15895a4f278168d167db97eac459f2d4c85d19c4b49903576ce27351148c555115350fb587b1354d33dbf4bb1b278b5000c381f7484c736870a3b0a636f27e00850ffb18eff10822b0486e16a9112929494fb453a387a503f7415eb03521351f8579c3e0f69d9a22913ce7466a48a630eada63302523b2fcda5899d9306da27182bd54f6144f816dd1276981bb4669547eb19174d1dffd87c5e5bf4df51c18c92ac8e26aed8feee4e702d5b036c577c4d77d35b73a762efbe1e435b91fc265cd080789cdb7f1e8b7e91a567b55212276841a3a6918ee9cbe95e97c6bd453b00659eeba78bbef76db5bc9326a8941b93e58fb7d542d9606eabd95ff04b90c009e5a7628d8bdc65f2a8c01bace554e9963a6ee551d96b5a39f1484f3596e1243233ecfacb4a09f73624602193b63974bcc19abf05969a28b4ba0f9ea6d0340da0319bd40e945457a73d7ea9f54db60e892c1cd431b5713eaaa002d710333f32852f064700fcbf682ee0102daf8dd4c3ae62a764fc1edbe6c8f90da67f1e53c8d84bc8f406a244ea4650182da3f6695cdca47fef2199b815ae6de3742940cf548ec35c932443159219a78aef08ad576edb47dbb9998d98641b9768e52a975777b621f9b621d29ab21f28f9bfeaaa0fef5ae2178f0959c89b81e06b61b81670b69623e9c1bf6e4ee65777a0e5dfad39c9874e4d23a6004132c7992bf813709826893f2e599e67ba0b888bf9c8791e1c61ad3d5e48ab66c54b28b501137b6e85d1d7cf61836210d1275e060f343dbfd5fad4fa5a9ea785ec58b3170debe761749338b830eac724083328f54d50d260d55ce479c78a4b7dd134a3e2b52c0f0f7ce94675422852ad0317ecaf70d25acf2a7615e7bf2ec9aae5586c5e44c500cab334acdc8e066c07a581ef974219f8e32cf65ee1ad401ed159b479a16a049ffb6b931a3482681a60fe27e8824482c7bc73e81b955b72e35e96db3d6bf6a29ac04bbe8cd12c829249379383f195385dad89584ab4ad775149c1cc30a1fd7570454260e7cec5d824b269a10ec7fa6e5020c2cb07b076c83d9d9546ed52696a4e5a719003e690ba52c054032d8b898e506a3890a03dfc12aaad2c479af37e94b837cf2127d0a9754c1fc3b6502af3fb00d2b9e91313f0669e674350b104e1fc3c25ded50c486080265b3a49a7a9c82922d7c860e20c6a6eab9a897bab8f6406e4ade5fd08ee2b95dcc389c4e458666b18123990d84ba7798ce1c2f448313b8db6f67b9f33097525780797056b5daa1fd0be05f0520413215f1ab552b86af8d619138143fd16ca677865044140d347dcde5b417d296d739d3b632c53f0e74bbb9a22afd6fdccf6ba506d2ca03093737d95227fa79d67238dd8c1c8bb37d0374e6079fd04b0b7b7c43caf294a0425a6a254797cb6f0a25a69176402942e1f00ad321c841f06f18fc7855ff2d515cdbb104b7588d0def4b181c7ba3e2269a9e51b4d23c7ee787401dd7f59427e7a5fa293cdda1b9278928daa1829187d5e2b471271f8ab859e346045874d533f374f046cab91ee7083fbef4f39be7fcba76f3bd2df569a3621adb4b872504385fc46050c19add3aa820164f6e25c32e78196615bae1427a1f813a0d35c8eea55b9d3d775714d2fcb679dd5682c680707bc600816f28a9ae6637e780587c3f8c7e073ea44edb3fac94af29d891bdf157499e0d5d990feb6c1514b4f5b9fab5d215be4d26dd05ddf4925b43d7f62e5da39d98d6c9937d16fc98e75fc671cd92f9362f83b38876180fa09adfc0c1256b7427a48c3930906a9de3deb7155a7c31046a732d7e7c516591ad88b03df0a724e42f2d9dc63c77069c4e1186fc1ab348aae241d5307edfa7c143b62e6ebebb5e7238702710b9c0b35c12c38b3c9bdb11c837882f1561c9339580125b4738e09ea879f86c1c02317a5daa5928056f93dab9766194398c868a6016898d595caa7b9c723f68ccc154e5355287cf1c9770e7000729f13681719ccc7b6a49f8135d542f669afc1d4ad9146a125c89a1e825f0df05d054c88096db88b9e402bbdacf447cae540d2c7c8532e43f17c540076f8ced9c66dc3a8145ffece61ced9c47ccc8ece08b7704a7728228619861f7452ecafad978d5e452ddb575c28e0b120253e71ff8a23586be90d9f4c08ea195fc38e8cce75f3f61d289e866d8ea0258a7a2c351dee395de0519d8d4ce737ba4b319270e1f706d25dc317e245a674c6b2b845088d31541dab2806f5340aeaef878aa0d796afee72960e481713fa071324e8ba760bf000151de3b259fbf9bb41c6e26e3bcb1648260bddd234a3391fc15217d66ebdc62d1e1ea10ed1d00b2ae384bec47bd2b74048fe85b0fa516da551f1d2cecb6fccc5229f1c6c153e4976d8424292ba4a23b7e8686819e40e4ec57b5204c7bbfbaf7f02f348d66237814cd842d536f75d362685ba3cadf7abfe6f02d83e10687d01ed85604f5a66e7550766bde08a4efd99ccd476960621a0a7f6cb3476af9817d797c08b4951","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
