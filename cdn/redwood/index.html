<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"027fec8e7f3c7584426c5ed6b94149b88dde00a7d17fcc9d05381dbd421330a564684a4cbd3279f3caa1f237fe35b0e8848d395d7f4d6e0bc6a01ffe592c48f686abccf7f732cc37f44d80ebe3415362c18e6281f216061bddef5c1b90ef390aa94c063f97bb538b8f91dbf8613a3f5acd0cf4e67f263c01f689d8a946a4a39dbe9b0ed22196519c38a662d858d5a733000c2084e038f58e273a8860255ce8df7f5d8057cc9efe9d1b0317ae9e33611afa332c03889eb82a6c4cf177e1e221024c4a264986cadddd1a2e23fcac839aeade2f44d589184085b4096e66920c2c5238919f5db3092cfa5a4570730ccb59ec67f1bdaf151ca95f3d757da6fea5ceeb51b7257c0ae8c71b3ba05f4fb33f5ccf94f48d64478f107309406c50f896e7a0fce9dea585e6d175dd862a36c37582daf6220007da4aef7673f8cd25c62781955f6f28d2d7819da9a984f7a5a4a1935c4771dfc72e212cb15702f292a4ff46d36ca25604b63cb4d7b99ca2386efd9698c8e46ea5d699517cec105705d6347ea60a01325ae9378b957dc20055c9860129d8fb3cb9fcc089f36984c4565102816ca46005fe10e5a62ed7d8034809f01116dfb31131ea49209c1e3098c28826686aaf79cd79eba5050f58e058536ecc944ee3f8f6a664b0c5998d0aeda8fe40d9d8ef670d71ca437f96307d0576979f4a41d6113d28733814abf45241931e1487383419a69827e3c63ad9c0c15e85a4f344b46d145c102017fad522fef73264ed5a7bcd3a318e1406dc46d714e01568ec0b5d3c5721f84ee97f88295323bc310e2cd8f8c2e08c72532645173468881c983dea6c21e6e5951e64b5aa5b2518f7242fbae71f0d45fbaddcf0763aaf951999921869d4f2db03b184bc1916d98a4cb26c4cfd79f5bd88bdb60561c930790ee1a6e40e33642c5f71f72047792f83cb425cf6d310dfd516d4b44832a35f0669208eb82c654db632c9ee8bf0fb2d1db704eeb08248001b5f7229a498adce8872caa61ef654a8cf769e51fa6371dd214c03691e34718f47f8a6cff56efe16a72db75a243564efee3124a204e8e11d6d33ff2248560549e4562d112bb31645e7969f00bcd069319c732c336db4f55faa046f8add069b00ad5cd25d05caf5375e13296ab8a1bbb75512c918e5bf10ebefd7ba192a2f42482f76e24d660aa18363183e0c15ed5e0f3033e8dc0c662cc5793e0cc33e5e8f9dae261f435633c9d00d630ff34030d6ca17f579a0980df00585a7db1f62ac2e5cce899a0d585a51d33462ac78c724025461ced868c4f4bf3d700f5b45e66ef7009f94b081c901b91b9f2825b3155cd6649a607a911413ee92e556ecf7300dbb08e04700af43baf82e92317fb185173c1a4ac2da6465ca74561a0748af66960f70975cf51a1af9f4b4c1d16cecd198294913047cc1b869808e2dca950a7ad1736356931e7fc9577f7d7904cc0ade4913bec4b1849713ad138689c985b3103487a20427c0b3063cbffd736fad2cb1729f1e4c06d505277ac273e300a5b893bf9f522451a025c99fe3f035c616e479878c54dcd6ef378ce289cdf708d38425bc6fd32c7bd8c1c6cc091fd7771cc186cbd983a31dad9ec0016dedf8825bcfc703c8ba31fd065dd675216e894690019b1dd657ee3da0a7956e8f48868af430bac353b1e5eda70ab9945b3cedcc0910a2cc3e48931fcfd233a8cb7028218a0a5739c6abbcb701e28cfb0f3148a6642734905b0b1cc0da4879d942001f95869198addbea76f237697539365c5e750fe27b652e313c1e0ab1112c3ea5fd3d886c3e8564bb60b9159cec9256c11dd3384182e7d150e24e85a801c1ee0ef532ffaa955f014d12244a32a47aaa9a09d4b019c0f947133833ed69af18c70beb263ba924fe25b2e221251ab3d4b723bbf2c09ab2be39ca6b2fbadd296af46f3a0a2a3cc8363254446ee1212acd3a34534c0c26f366c125fd5e76a176eda45eef28b41b1667461905d19b0e56bbf87f27081d2c9c9aafa9f0980be4e8c8c5e49d80b191341e8cff518233b5c6fd320307e0e1fcb7bb33f4bff9e9884bc9119a3fbbb677b171b375ab4db644902458b4f0ae9e2ccb2df2a447ec664d47b8ddf4f61e439ba67cc169f6d88be36ac34ad07624d1c8ccb09a33c8db8473f466ad2555ee0de803412feed7a3c79c56b385937db29676d43eb027eaa3594a15c182ebbb364e4352362baa3ffc11da7d12b053c0db43b47b86395e16e55cb92227c67c0d8e61051cc53e5ca4a0ef2790acc4db1da9e396e993ae53a5a539628bdb5a13e4279bd2e0c162fd40c09ba433fa51caac136e91a07c2152b9b598cc50f98d2180beb593da708c210746bab44e1ebb8e51f080bedbb2cd085f92d0432fe712f801e837ac297454397436ff2593c8089945e1cf454491a3c97db47abd0892aad18314b3837632c6e05f6fbe8a391792391a43e122cdcc9842311c897aeacf941d2a1718032e9e52f7ce176eb6c74314be147502ed370206134a5a94d7a9a1bca4a3f8a1f3c7d6e5b39db9a9f803e6a90c69aa41d29b6d2e59bc71611c2d18d3eb7dacf9e1ebaaeda298a1f70e2c6f1bf23aa28bb1e6b9c51af0d296734044a49700cf9c914b52a153937c81f5a387b7cb7853d64c5c0e91d371657d1e536b5675a832025f128d4dacedb761769775fc83b0249dcbbf97fc13f140a2eafb3a9e81ca3ae4b40b069d0c84a5a5aedd30ffb110f2d7674c72b9e805134e98220329505e9f15ce04cc4d396d17e0b3a2c6a8980343504ee1d0671f82dc1574ef269034f57ac95a32832badb3e01ff8ffab1026801a3b1522032efa526c1d97eaf91341201b12e33fe2c31c1e07776512626f47dc5b0e2f37490ca8474ac597fe35c4a9ccf44d62e2493777b90014e1f1db09684a6c3f04a9310afbff094fedad8dd9253832a281da21a3c76064241b2c6968ab50883eb890eea7548381291ac0d466911a28f286d77326bc1fc80d41ab83268810c31adbbd3af1b29a1562aae315744bd977114f73930d9882fd141ba43cc4b029effe507a765592c392ceb7c6719a1c1d2ee2afdbfaa308cfc638e021091a57798fe59bb6463038b962496461a9abf731c93e12b9d9d63d2bb1fba06e5d9b96c9034d6436491c9fd0361b2966baefc68a12f6603eb1d10799689ddd4e84932bc317bd9e0e0e84d7b615a8b26b7f741208ce6cc36a94f08e66fac93ca6dd8d30e0e3acb54c021eedafc66f02f22443e44a02bf5684bdb44d0620d14e054532f79b358e9cf2c1352c9bdd52bc3e65629b2aeac309ffd1fb00a015211ce442a6fab705c014dd740a43f092825cd4972148ca4cf1999bbf075e9a2f0efa33cd6aaf53ae0f135d341ac8f8acbf49cc520ef454ba44ce564a4f1d862c3519ce289b2479f0dea5b5c0118380dec80d757ddffb1bcce1212639d159ac21d03ef958d88d9d85a943caa953692509dceb98cf9041ffa2ba51de8f9219241b6d822e129048c6480537e5dd150709856d0fffe7f4196c7e6e8a1b473318dca62c9071c9f267abfae53e12469297e3a213ae9a1b3f90559ca9222be49d961627b20311a583a98ba64ed94b8bbd96eb52fcc6c0f8d67d8180dead362a250ea8f680d707a9f60f347c835ff99d6303c89c66c18e54d3675145fcf47fac99668c4eee5b6b7d605f067892020f0617af4667291e126d73b2fa28cc353eb9c517ccdbd13b8a383c4b748cc2e127659696dd24bda874c523193d1d1f09d6ced0fe7ce31d37e956ebadc78087619103918235001dc2de340ec49ca2a27763d422e6ee18f78f14e21e8c24b9ee65a0f266d549087e4d7d239505394e395cd4faf0d7c65d24936e6531491b9bf6d828b8e4184f8aced899e0ccd991bf43376a9eebfdcb22014483ac00169f1ecc0a6791817553c4b9524f3e3411485fb915b3d464f30ee7823aeb689182db2f23ebf25bdf6234ee1b12458ba5427a4442d0a8cce05ac98fcbd7c325dcc566654732ee3b6da81d5579b08fd3825921b7f6fe90db8718a35cf3c5bcd81c6f13f8f157a59131c9c98453080f5966a19d9ef4cbe11600b7c0df948048711e6d4f09ab223c18c334991abf7aba9a5db8bcc04f23e8b7f74430cfa96463e9099303c183bf8915a5f9220d064acc24b2d96c6bf9a9736aa82257d2bb393bebdb00c6c498e3a55350111f65ceef95cec1d1315175744d98d95ca2c23aaf1a9de9ccd0ed4d99e3879c96048cdd20bf2fb43222adad0e1bb69780ce2652840a5be30f52280a88c7fcf704f7c1e0389a3acb21b00ce3f0fc8b0a3684fc6582711eac60d19943016620c1524c7bbc9ba845fd682367f541e5b380982267d57d2cfdef07a92b8f659a5e93eb925c28efc73df1a92c164085b3ad2766003a12a47da35d011a016b5289ab3d2671db2f88f561ae8f3d7344f4394743b14970ad27a3c0165360ea6c6ce9d83e87ff73d249521cec50fb86378191975b6e5d96ffc382ecaa42581a4b53a443e4c0d2e755ea8162c14c343314414e228700397773886d74a46a820a16673195e1ec6a127ba51246aa2f96c7571e26d6baafbbc6ab7f4d4106654544883e780f094a7837e2d017a50c5917f1cfa4d7ede84c0c62973ffc29f8d4eaee9bdee467f23460eef2374dab22be6900086f6a11b9048d776db12df40436a5b62eaf687b5cf6c1f3ea33b32cb5da70224c1992c82cd8beecbefb3d1029552324114bb0388c6ffdae3e79f3129e217ab143129b319dcbf3a6468e0c236a7d79d07b6631329959a64e2156db1af76f13790ae1a0327681b64ccc72fe7121d922127f96ab88c9abbfd573e9b75dce8771e3f80edb581da0541de6dd5b5e269cab8ba20bb3a07aa6d4f973f0416c85e2ad9bc9e29d9a98ddd4356ad7ad57fccf8447e38ed8400b73fce41ea48bf53008180bdb20e4de0f7356fdd8ec9d408b24aa75eee7204e3bef98eaa1b1c1aeaa857624019a2c3fb6dfed305499f43a7c689227397fa0b8b0e8c143e2ce35168317980b847f43bdb94fbe4fc6395f5fc6929509a57a411662b9f6a9c339fdd6b6b8a08de38289bf4b0a7d11d9a7e79972c24087efd9993e34e0b76aba6c39f84a5ca002d06b0662cfafdfe9e9183cd586f169f51f41ac53f0b51d0543decb8685691be7e62e4877b2d0a5dc09a4e8ce954d74dad62f59821130f601d0c2b6218024e7ed6443dd7339d7213abe2a02fc6d40fac1b5f0e0e7fc0698a48d65c083cb831ff2471178f59f0ea1069a74afe071ad7c843b73d40f534a6e376d567da6f10f210c0d69659cbf5762c5c3b0d42b8cf0a063801177074faf8a2622ea2905fc6373bace50feeebaa0a2ac566e52904c63f9f0200d2de3b732087478958a81404e97dda82ef574a628161740ac42005df3e7d13dcc4dc3aec8c2e9aafcb92275cb773c6fd5c09232b3094f173c4906977b4dafdf8f9a827391b6dff82c0589fbee8cfaa77906accdc307091cce360ee57dbf2ae7c3198e53522e229ddf21313d4ebc0c035a7a59b62e71a1f2d8ae7fd50c1dde60d2dd8e41333e5115f726a2f6dab1419a6b4223dbb18bce71b182bc1e55c27a1696a20eee2c721841144b73e8af9967e0b2e39f2facc5ee865bbe165c6a56f9ef07bebb200087a188095e3ae6f8756452adcad201de0d271eb150e9580b9315aa4a7e9509725955b86afad4c6d27ea42f1424572ce5a19d5bc473182167169359b1aae8bc09dcc1989bc0894934ecb68490f09f66478c8c4ed1f8e26824e3222937ad1998cdca5f73395e583c5b513f144e1a8997492d2886e22233418b5aac214b7cccab885a7d1f7375b4db4da0c4a97f66fe668d762d49c6d8c6f15582d077134fe0401fe41b6039887aff84ac8dae84642b21fe5547b4ea828874ebe3eae0ac0b326ddd1b04f7852973d146103da46e00a2bb98426c84719d8561e8067448938e8789d508fe1325039e7f654f2094765de5a202b378a1dbfe16ab10ed8587c4d166b04a4d931949cc85ef44da308e8f4025cfa28412dd9a60ee9ab216dc86df512391369f7f4b97f52d129f208040d28cd06c7903c06e17d4efcfedefebd045e0df27c4a06b0d5877c0358334e772a09698993b61d0812de27304a1074248f7d9f407ce8cbab53d41c61c1ae9f06a4c522ea835915815cab3b56f7b5984a6987d1038cc9fb15449a07cdd54b3447336d8036939ec4e1ae2f20431a22273eb28d620b5124c3c7da923db43fc810839ada38cbbc389f5bdcfcad1c70e568931e24fc82480e3ec4a70f8783e4b29eb3d4aed2691cb8bb031ea1380ed880b956046a3d1897a3eff652795d2b8a6cf442222c3774f7307bbfadfbc5d664f175afda3751367b2469ec1a930037d05e2726854f430b2c815f3359bc64fad97fd377eb1fd3ef9d780f30f347b4d1852835bbcef76c3fe9089ac123d6d654b52b719d264c8950476cea35c019bd181e3f3e0cafd8fa51f4a8c67b58af95e9fa9b2062295b8405260828dd93d520d7940a19c011ad3980dfa7709ebea994418640a3831292d2690f084de6aea8bb0d7ccd1080cab04d13979a24d1fbfc1d98354236b0e1764f89cbcb90b6089664865e3cca99b7d7d91cabba9fbdb9af7c97143caca787921cb8dfa7b53bb52dae83ab06ba09d811b854536a168edc176639f1d506019386639fbacffed3836aacda6775a994e3876616cf03619c55179a530bb6a72b3ac5f3c61338761a62b189c919d9f56cd87c139c741c528e463bba615db4760c304f98125ccf745680820a0f28907b39332e975def23f267a428fb941e8414c5ef90943d87385e6cfe9ef081ac01f2f23dd24250e58feb8f0a1136e73a56e1136d401bbe0a6fd2e06f9fd49d2b5b2575c226faac472952dc9754abfb9d4a5e6570e437c93153c686cce21e4e3ad6ea1d07b034f6e162cbad9d8000b281c7a93ea0c7fc8ee25b00a0c613129dc82c3d27ecfb38e2973ce6ee3202aecc89fe6eea97c945e4295081a4ee934c7d067bcd5719702806529e3d0013f60dd4e8f88108989347e65249c4f0323a3e6142f32273f935f09f50a9c92f44169f51428216bb28573af64946f7b94564f632f563b551841da2277911494a7fca5c874bcf1d52ab948b636e8ece5eeafaa404b04c4a965160b8372e270da4a97ff0b527d3d6705ef40a9343b99968f2bff57013a08139883a4a57f3801410bd98ace633ebc36013a845fe425c46d70a23ca6c07933a6a07562133916e5715302e1b2c7b3ae36e8b87fe8ce49aa30ac307dfdafaabc8d0574a2f87ba1c09190e1b29997995f7f6653fd7fac84e58b84cc7afe414e06a720c01dba36a7d24c12520c3bdd0a649c1ae9cfdec6e20ecd0d97b6d3ff2396519ed11649387306d99c1dfde50f9c76399c02cb6a75e8085c34968e08024bcee68ff6e6143fbde9dd56e13ef556c495e7dc0a076fc8ae39fbdba9dca0fbf386e53fef95dae87462afb730642387576b1e9f866a1b21c810899ba62450a2e098dbb56e63d10a8bb66c5ed60a83c85e207de442fe381b7323f7d132079bc0dc2efe889f8f633b32629fa8859aa5f512a45b24844e39d544ac7edddfaba662398f8fc3089eb84f19fee7df523818e3f3700ecc4dd36c9a3bf274701cc7f0766549299c096996f3e1011c567fc01bee6f953b45ca0d678c2848aa1dfebdc66ec62ff69d859affe36981b72e9ef33f912779a1fc80f52dfc42790178b6be224d560542c1d7c93f5d6cd0c74544ae03ecb77286782211a5c7c4c7951aa08efe279d24deae18f4264a904ce2f4b3bef179bbac29ae3fc3f37da6491d50f5a4fd4d336056725da732ec776e5f8ca24e7e97ad94067b6dbe8ff518d50ea93fef5cb9d64dce55b3a5918a404693ef8bba5642ed57f0b1f948864307b614d69592ae2283745acb845eee6922c1d3768b4782035c9861169f9114f29efead0e22a7c918185e453aab7db41138565ec085ca70b6edd7bb704471138918a97a6ee86506fa8daff68402bd147d6865dff983c3081191f839533ac0c938c9ad079d59dab73f3c8667a8ac1ee2002e58f43605b52d92f940216cdbd64755e0bcd09d75a17e01913b929fc3639acbbc5cd55191e3dcf81611f5567e71c7ebc619763876decfae92ff1765820f90839617e39d37efde8110b904a085bc6cea3ace77c48138010c097be1c866932b71ff02727110596d61c0ceab35cfbd7d33f7f8db61ad8ba93f8b34e66dd615b74a762c60055166e4c3c2650ea3699ed98fd622e51e9c291a0b2bb633a77375ddb6d084ef2b7866e07734e3710789cc8b4c5f40fb3c4bff31b8ce8807d86777f70d090b8667ea2385be36032e2bc971a7b42c6fefbcf70cb949e784a01768028150ed595155351a568d7cef89f9496b46efd811095967e56b0b37382488c0a2b7c36508945935345322876b189e6d698f6ce9e0c16a425c85617513485a25e3a04fafe8e7a2530be7791cf5aa28e7d16373f44b2226eefc31194befe806c5f11768fd92395d2d4c0f0d93c65461afcecaa3ee838b0854c02edcb3e46de7fde836aa99f75574fb2094d10fd0fbf2331f9f75b760f74a3b3deaa3d928112847dc1b7b924078450a1304fce0e5484e4c76e358ee2effcd543b22ed965e32ee00a6c470b6dba511fa1aa0748d6b8e16cf135a0131520b50791258edb87f8b7fd18365672f159aa8e2d8945a64d3dac3641c0c0168d101f09e252c82b07a66ea06ea49d7deab7f0da1a5860c016a081a4b59282dcfe4c7d57444b05d04375803909774bb3759652eb6d3abc785285d2f1ee0753b1b5e6079242ca22791791359852051d8b7232e5e1bb2010d788ad1eb5c84cba0007cb2a4a374a3070f235ec0e41eaf0a21b651e1e3f9bc24ecd2accaf48d645bd5af5b8bb700cdd7d302236cc02ead9af865177776406610f0fe883e64047cd99d8ca09188755f24726a8aaabb57de7f30f07a757157fd2762e30583f498b8b042e3bd49df847efd6c8d17bee231a7826efa9e34dc440482f05dea0e522dc6131a5e6db16b4538ba3c6bc1b61f5062604bbfc9c9b6c7a463b9a6885307eaa925fdece43680bf9868c792f356431bd4470aae4a4f9b4877178f86fec6b89a3fa21b424c60650f00dc6d7176983c4b8417ebae2c5f89ce8fb55df6918c0042351bda8a555c0819ab40938104a421d12b5d377ea4f923e0c8edeb2bdad6b104e376a982274051c1b58f1f97639cd22f024c5d64ee689cb58b8d50723a8afc45eaa8d8f0c7fbde2f8a02264ebd658d0e607f0758da62397e4afcdc8b13e0f9829522d29ac64f78b83fe2f42df7727cc006c2bbe2745c27178e4395caecda4d103be3ad8308b64cdac3744433086d9e698395696915ffb406a289799adceef7a14a3638b55485f18bcc8f8a29e3b2e0067241627438f182379b64451a48a6ac91ad01abd27d2af34af2d3f31a6e98cce4cf524c126485fa3a5379ce907c317b60d2c226244342c03647e8f76b69d65fc094da656ec170cab0d0e27fcd04f87414ed31fdaeb6299ed9723fb89c663c83c06854ebb24151d90abc97a29642e354ecbb9c79dc14fb6c6112874cd5342cde4544e7b125de85f9e0a3999bc191a303df318789389a6333bbaf6cf028d8abcd2482af2dd04de9a88a9e6f00c3d40531462b78d36313e2e78075f56fb43a45f78b718fdf5a52ae8d8ee70df8e09a3e289c848973919bf21a1c98328c2b75c74738e15e1e05e6b4595219d4c0755c7106cbe769d0b3481f5eb220fb52f43ec9646733eda8ce3a22e0fd969abf71d90521c120be9b0cef24671ed92a0fa8f96b845e6cd4ff0f5fedb7d29e606db46e6bc84e39f4858a66630a46374677a86dfb324f32da30cba869e0d6dea7cfc75a6d2719367d61f1bb667153bae82414fc1c2529f2b4875ff9742ec0137f9152a5781acbedff9df8cb89cc035a075ec24117550bab45df6ea7be734736832d41b24533d83b1c6fb1cde29e2e1fa3763e68c5060f836c9593cb8e6df31f232a5e945adf226a2e337cb44a0f55c2d32184d167693a4404dd898c9095548339d237741e9dcbc8782901300e9c2e56e7d630d8418fc43466514c5e5b55ab7b4c7401b1b6c2c854480e5faa042a85a6dcc452e98832f5e9661276e485c84bda2cefffbb9f3309e0a6a72c9fc472179d0248669fad620b72d1f27175de0413c64f5389f9954ed6705844220b09fd353c731a0e8f5bbbd925b5393fdfec291984c1fffa6b1e07d47b3be474acb060efc56050656d8544cc212de7d9c1a07207aa92bbce8b1c61514c34e65b6fac9eca7f27b291b77ca05e8a7cedc7f630c1438ae5e359f9a4d4c19be2c26b5f18746e30267a96261163f4cb49d0239c051582413bc156d35c5037fe01dbfe01ec8e77885229390c571fffebbfe4203268da20097a54d1cf3fa1aa397b35aef26283a62dd93b2f48abc69bcdafac2f23a0f6791205cd22ff9a79097ace67d0d84b4ef5f4d62f0f224f5e90002dbf599aa25f73f5130dbff8b3b6ced82c796c330c91ececa1f131749cdc918a6ed480c0bd473f614ae62ffc0a7edc421f2c708813bd600c57488c4cbbd12f96489a5c413e41601e9b1b6aaf4e5433b63ced3a4814b73ea7c6b2b481b375946bb5a51d65f7b445b89443a34111965c4ff0a643a843a53e23d24b808258afe0c7d500babf0132a78157c0ade46f53fb448daeacfd467d9aecf73fd5e5ce0b544ae487a1ee0b4ba64e50f59ecef5af91bd837d384637eb19c413f24c4942149b9e17a940a526fcce92c2e1c4a96564b32e2ea77fc5af705901a54c5f9a36fc807346f2be583a7237f5b5659d57d3a99270c4d0228ddb497755d2e3babf326b3335e84e031ed6fa190caa46dea179c8a595c67fa603e97119abbc7fd1aec9e8ba0ce2efadab6c60e64323c7ab9fca6d18e15593a3c7df67df7bb0034e69c3d8851c7cd284df25efcd3da98c2901dfc1715db6e0091a8eca48e5daff3d1fd04b880db537e4d2edc09771001133528a8062bf25b75b9a58b7610fd47d8b6a9479dc21475d6f43927202b45f90355e10c8789aaeb6fc374fc9fb66d19dc99dd3777292152d557bc6ddf0fd974ce0a31978d57ef50b8e703c6e72c4f256c66f5c124ae6d6c8225b42587a3fd5327576f0f88b75124246146199379fad777ca80b0b8413f51800dfeda8f4bcff164d8c337f0a88d3d2bd6a2ea2d7cb908a6e172694cec8ca32249ffba0040225a37ab959b9e59b11322f964470b495d53d5a25124e828a1b7f21be0262a5ebe1d2d8eef1413234aab4df74d1ddb3539c7c8bceb1494a08fcdd5affd86fc8f35dc5e9f19b6940eecdfd28e30770580a54a22c04aa9b373d4982dbefefb99ae02e198916c89e9630a1fcfb26ca4bda65699df7f47fdc02cbff1eebaeb1f7d9de03d157dd3507f8e07e1836d3346e35cbebc375c35258af569e8abdc57021cf3ee89666223b3c6651780f1997bc84ff007ccd40b9cf9bb6bfc8a5f4ee585215d5ac9e38a2766a018b5dc71f3008fe73d9a268125d7c93ccb808641a71d015f0e428e6b6e8e4507e92e3db0172520c88d659a945eae974d6832c8a58c16d45b3bbb0d4fcdd7b8e4ceb860299852c6f0deb3bd84a98f967b4f565c698bd1dd852c45dc072f429462f8b919fc4cab0c4f4cec699c2ee220fcb44a60110d5d311a9a99ca98275826798f6a011368edf7c243b5c2bb7861a8d3f1f164ed0afff4ba6a3d2b24c807ea47b9e8a168071fdbf55c6f15bd21b196df8376be69d5b170aa4a9088fe0ce3c99ed98e7ad48f8ad98c70d544f782d6f8b8ef8f7b968194f9cff9781c47afd27b787b8f7cdca4fe718670ecd5034c0a40f7401c11bee1ddaeddaae27c0f1dbeb2c561006d3e352f069f6ee2b7a1e6a6757645efab92df4046e5fe3472d8c3b9920609b2f635cd392787767096a22adb9d6055ce547162fd0bcf5b85b7c9f897022f5bace9e86d174771c21ae095743acad09c13b1cd10480267e4d81134eedfdffb9db1a5e857475cd8de2089cb77c517d3aa63240db075fb48fe4627fa3568b88cd126fdd4c042ff37aa4ea1912c88bbce1562052156b597365e81e2a23b2dd9964553c4093193bbc9f51ceefa904cfc730992ece6d547caa77ba6236b445da00f7cb3cd78c376dfce5747a0c23e8084f998a536e70004044858e56f8a03afe76bd008b8b8d349bbdc21bb36083011ec17c57fe1984133abf67fd13d16ef5389e322ca3df4418bd4a23fb4cc3d34fa9ab0c8c5377c536a3e04b7f08822237b3db757552b1cda787a1ffa0e78d4d519cead820a406250a25df6ed4c3bbed71cf1c2c3b98bb72f29c4c9823c4ce5c6d9a200052481df97c79345e06876c877491c2b0cc0a5ac635aae8e191fd6d70d767df0f106fc818ec07ec92cabde2aa247c37a5db7fa39fd1b3a228488b27bfb455b7bbba6d27b52e00785ee5c7cad2631154befc8649b5092f66c10977a6d03398aebd95a35429d587846a8e3cadc66b0192b18b74015e4011731b3e3c8edc96b60fad223ca2f1e51e9e6b919f3b95f357aa1a282c797013255414b8f875eb416ed0e52d71a5b017a1c5559da7794e3bda6bd7ce61ff83e897da59872383819d3d392dce9e061eaf765d529c7695029984d735403d91db0df97bf692079d9dc96b73ab8ffaacd2bf929cfafe6686e4aba9d29ee36fc75a78df77f802458076e6a764aab1d4a596211f99a6c10a0ded51cccb065f1754ed72755b04626e7357f264ae9ac4008314f87ff96c84f2c4aff046e426f4700b55dfb4f40e732561a2bcc9bd25dd4c31605b7f5ed6e2a58176fec90e5deac412adfc447a782cd959ddc96769c7b0d3f9032221edcb8cf3bf90d0b8002cf2c47393b3951cbb4afe5779309033e2db5b8623e5be4916c7ac8248ffa815bf8e365cc50671b9ad492affd12ae414e76e40802467a9d38f6da3339fdb9a988dc3da07f68abb7b0effec39db880c7ce513b7cf0d94a20ea1fe02c89fac5db7e9682bd17245d03f994dae7e0bc3e8d2534a633681a1c6d7e346f26dd6d662ef648ad366bd1c2eadaee1a5d6a53e72018912a908993e0a50e0e033a158d75c857deb1ce7e4457374218eda8e52d786ec279ac33e41508b104e327ecdba3ee84ab7dd8b6e8b3952853d18ebe262676564efdd0d29b8139e4c9ef5bff79687daae6fca45ef5976d3439d39a4473c5e32f703f5e0d1bf60c8b2ddc48c025575ce7b9f2cb4ab280dc2498ff469d657ad478a8d10e44e15336e984e86fd2e7e9636ad4194f1100778ed5ad50736f9e660a0ddb9e1b4be8653537c9cd25359d08e84997c8acf883fcb5684434608f2eb196eac42865ef956e2a9501e666fff8df2517c731f8996cbdb051769dd855e4d6a4a197cb4464699989225965ba7af3969d77a882736fb6579764b23e6e00087348f1a2121d40271c6a70a2e662b03204bb3a2a7a8f39cc0465c9f7c7adeb62fef6c2ec15a965377986cd8ae618778665b55621e4523cbc638913b73e2ec9097c467952c5a26089185cb55317750ac562b671a2080f4b37d0aac2b9cc687e6b5b71cd46de9b3f74c09b6f29bc1cb70fc70e51978c0fee09192784bfa15d27c6dae7769ff40a309f09e4e33bdc1f479bcb07f6d2bd0d7206867aa8a4c856382bc52d7dd1bed8d9a866b26bb8958ee1a5a50874828ad4d6714574af6da7346f779074ea0f9fd1b5de2dd2cfa74bc5fabb4b85d3ea829c7931adc1def74da5e124b220c8d1e0d57a5faa77001dfff962a077c9452cc08f4cf14f76dc6a8de14869655f3774a38c2c27e15c34572839cea75c0064ab38fa3b653c00389b0cfcb871a3c55732915d6da021bef26357d748e7bfd294095ac29f7d5f1831745c91f4d30f29dc1b04c5d926b2092c46a239213b6a03474dff792731d79d271398e609e3bd456c7a951ed2da706618dcb5511787ec97f389aa31101778eb430c9373d9b3a8b0fd03d833fb56d31364f56f2c0444e1318e9fcfa0af61772c8f5e77d808838731f6760198cc96dd7588afa182ebb08a8046535164dd3a4b68c2f2333d9dce2d88fd057b9a986c172922002c14a21c5dc2d0e7dd2c6b15a54abf88f02d8f9c0b47c2ccfe87d8aa667a2a7309e5675349d893e1377729d3a12c834aa9b03fd6cf32665a8162fbd75ab33f36a3a70b2ed962c73fc3ce387ba7bf248315339bcf510ac03407212ee4f7d3932e158fa382232e4b482979b5fc56667766d1ac42d339145c0d819ef5618ab9f55351d8e0792cd51beb212ead157fcada90b230a904b9af791148945488c00af9c563b49ca792ffe378364d8b17a4ef50b25f40649d2f5e284dc9e4a111aac45139b92dc3537dcc4af94f76856ca8582fd352a0dbb411c14acdf6cfda6f735019a43e7fbb36786a675784b8ccc90639bf28adb23c8a3f36153c60428b0d4e4795e9c572b4af70543e69309913f0283c29018f098ecb44c77f96c177d3cfb7af96d03a554380a48b40e6c1d8326629fb328c1bd9a4280c3a24d4138ed7c90e89799b09e5f30dab7325fa7f0a14032508b5355d8eca8b165ea59562c75928f59c6b3ea303b5169edcafa1e44ca4a67547bd27231b74a7dbd77ab51f2c83e3a8e7ec6710286d4bf6978903f1c2d1a209ec98bb8fa5f774159661dc5c809d7c725474bb08cbe144e6d5313e42deca1d9ab347fe9c01b57700b16e0f98f0863cf459446ba9f1dd3fe3d90c036fc4f1846fc55fe14014cd82e17763d2d2f180e2e172a7f8fc329daad452b0d6ce870a92c5e3f097491223fdce8f209ba00b3d68d1f66c67e87b8fd453710b2700bcd6e3d69a8ee49b9863824577b22621b303689354779f953fd734892aa91b0930b2c20dba43ffba3c45bd325b9976f88f485679971fa46e7541ed6244012ad9399252a9a1795ad39f93372ae674a74dfcfc7c203dfd873bf5f1f18a4825a5871a50f38e944a74fb2a762e35df2f84e86438ca39ff65e03105c46f4437bbec1f0be651b8c8f25c4297d345a9dca352f74a1548c409837359daa75d27d24924755014b5b53b21a275e5eafb02c9e2807878875449c63855ff06e4590c95b7cb72d57af0d307f9da1e56444b3e4f4500d95e8778598ac9f81c616625e70438276e8db7216bfcd5180de1f54dbe9b2654edaa5125a4c7abe5b801d7e5b8325850478fa456171f101b9939a9935188d72a4c63841edeeeed9a0f73b8f7770b794d5f951f37da50ce9232901231f258efe6cff40e28639b11e7a774d8fea6e7b16d4d633883a9ecfde7b0458aacccbae3699059043ef48a29477e0f18ff5aa431c0a667fbd1597c6092afb20192462d419bd679e60651abe2b6d4b351a1cb9fcf37507e1db43f4184fb543055ecd57f7713c1b3695a99ebaee6d7632c534a5964d3bf58fa19393917fabd4283a7c84f8362b5cae7b66ab07ad5a0fc0c7e144e9504439d89bc6db0128c16c222d1c5d26ba2f779fec0256374466a7ed4a517f51d07e7bec1f570e19d8a17c3ee835ec7214c41134c7afb49e92ad11fe18149c39e72a247a5981dcf1ad0ed3137cad1e9b50f41c85ac9aef80c516da1a3c48a216ea526d3836218bb5233cd8ffe4ff4a76f5f62dc1d1fe5c245ef4d7a354498115d7cb921d943c1a271900e67f06f3ebafea8a3c20d21b9b0dd294c13946675e761e6fce731afd7dc3180bc3023f6734427f7e6faa18cb9e428f30afe7c362a4da53296f7b0fa329a11789a5c7de7a576d0ff2191084b911f1499d89c85261c5fa4b524fa02f5e971bd01279a98d539d3840c60b81369b1e7b7eb1eab1fd82a56a60bba7b5f8a251a4cb76b4b41cf97a24457d8eba61c5af09a9bc4cdc407af5e54f078ef9358478d4da7377ed88701668c340bb1fc23c07bd7aa06635847db92b569f5c277631d2cdc9d1808572a807a26fe66b0595ac1b2a953707494194bac3287194b143e7f9610ae78138828536113f910359ccf9577cc892b3dcdaf4ba754cccf3013c9246684fb9bed0f11d34c08949d78cbcfad757690bee419fa30edfe1f1622008e4d6f12118774de7b0a104159089b43c1a6b1f0ac9e87eea1fea42235b8f7986e8599c7558b095b2643a524dcf1c670281496d5f8858688c6556e9f0a70c25242c594948563de1d718c5500c35baee9e2cbf5b0206c8b2cb43a7778583d6278fafb0f02162c3b74b4c029699327a46ac5bfd9b844b10a20684d9fbe70de6d8339458dac2a890f0d6c249ecf6cae3a83a587e218f9cb961bd2fabcf023cad020631fd762fe4fd9d06dfc5342def0cb3c6b378150b65605e96e867fb5951202cf951d71d384510a54455db687be8cf7bf1239965a865d51616f28fee12081bd4b430995fa03e9b567815879781d3e84b1d71f9799adc418602a90f4b51df041018a8a102b420dd3b77e58b2ecd807a5b8a36be7eeb3438f4d96d2d44be4d6f7e5817b3c4c7b37018428594f591243be366285d8ace22b8059bbbae77b3f9844a024ece0a53c8899da14696c8c18c9d43c07a7b68f602a8625a79feea935774f85461dbe54847ce2275f2f19aa29b3905c30e71bd740b1e33f19daac286ee73af0499c57f213ad79f62a61a894f5ed43c3be8066191dfc376f8c788d697171a7210b4b84ba71ffbb4fb1cdffae560f20217b0ae0d0fa6548a4fb54fb10ce34832f9897f2daa2e607a8a6e8d396bae6d4c822b580f294c6fc9b800fac3f34f0a64fa0e10e1f968e400c41f9fd88d06b481aac9ccd09989526be965780494e992681cc10ef09fcabe331881316d8fe58caa2ae60f5659278f28fc5782a2a6bdbe820827145f82764198306218615640d36f4e2402f9da565cf6a83ae4a956862ba124acaab1e9b7d3b1e229ad4dd7c4e4e36b5a61e874128f81deb40cafc1cbf400176e5db3911c26b254e3772be1058d2d81a2d4ebf80c034de926bca40300e0ac894baa84ee02624fb15d59123607e91e626a0f1e77384f38f8181922abbbb68929056973e502a1a3acf9df7b880fc5930f81cdf920480d6912ff2d20628be274ecc3e16a3b443a20102eccf096aca9cf60d3f4cde0bb4b1246e0eb88b430f4d5cecd5cc8d49daaa4a294df6d4bc164643265c78d3ff6b67e58db94b3a1f57a4ff9700884651b41f56505d64554ba869571ce57349d50ef649b272d0c25a020524a816999dfe863a058c33ede48ee4dab90c6a2d4cf6b677a7f94898b45864423d400e3ad20887c9dc1754dfbdb41a40d052cbe3b774e3575ca2eb876ad69269436221d81e7787b0a1d3db75e4f1df65929a94cfd094dcb9abe42784891f68f521617f6b45af460c60ba12423261b7297affaecc8ddb6d02e5c2fa962b1dde7dc31355cb6f17a4fb2a4c49adfbf4f4dcd420a2d18b35d534edab684c2ecd8b1e1fe0b2da7b3aaccddd0746175a2f19c4801df72e6634a762cc3b91585e1a9c72d0f38e143d2fde21c435249094c3215ef6e4214feda737f239d60781c9f435c32468cb394916948d6954ba7b0e64321f7de6f88b839acdcbdbd703aa3ae8047784dd9d67afda6131525165b88e51d84b1b221f6456a20763a2ceda1544ff065ecbee69504a498cda178b0a10e8beb72552850ad46687781d5e0ae98e6490e26806c0f14d7bf1778b768d23a5219358bea7d5e71475956f21e2b611f86bc903558f8f664a31126a29b2b4b9206c5572f8916f42ce45362f0795e84051670da7e747f53d7cb84414d8ad78bbd642045d5902cf10f37c1d87660c9a5f7c245687d341defcacfe305c00bab59b767fe70b875f750a246eac4a1cccf69e418ffd3d8c35662c27b3fe6d0c0283809c415cd3881c770df94fc6394b6839183111e3d7b59e503f22901e64920cfda5fdd78c14514d2558d72f4f7be9202dcd6b01cea554b469572ad538d8b97185623a7a6d87a44119712b221dc0380aba7781b1cd0410ce2ce2e2b3c73b94fd2e9cd190a5152169dbcc44c4293064774a7e034a22c28ae79437618ea33c4c72ea65f7540","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
