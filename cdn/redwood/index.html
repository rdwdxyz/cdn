<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d40d5b94e9e1affdb16b7599ca874cb00b1392e0f07d993912ba97ebf23bec121a6ddc09b7b5d2cdd83db299436dcf9e03fe8acbe7617f2c019f85be3343034584eb6e762934bdfa8ea1072793b8b8d55034afec4023aaf2da810b5b9c2c8bfc5d16688b407de6245d39b0865e10129b5fd5943542c8d730a91a7bf3f3b7f1bb54cfbb7fecc73538bada2beb5cfc8a685e389257c38554f025a847f40e3667e77cd1996e599e7bccaf8ce0872620085b7c086e0f2e23d9033d3aff10bba725246910aaf524e810c904e71d2dde5e9989d3fef406f92689063837aecebed78d0232c260b352ab126ffd1f56d443fe033c1231e9ab311900efa1572f52d602678bbf343f721e01f0f6d6fdd64a15370f0194bad319cfb0ba383716a9666097ccb3a0891a8ed244be74ab53e62ebb6e9e6d13500d21527e674cf06b9776de18ffd9c087673c169bae8a9f1e9eb335f6bfca38c76424488fa6ac2e0a2eeee76d8e22490ad8607eb1f8a2c44d5de92d8cf97c32e3a92da4ad6e34b9d2b8d574778c5e89383a22e7d970f2e1381a84cd301fdd51b0a37db7f950e02b6f10f99f97115623afd31be389212b41beb174cf4ec082882493a6e00b63b4b346a99c88d270bb38298fcac5864d2a3f22c1bc167da4c4c0075733ece9e70cfd6cd7609c50233f7a9cab0e73a7e039bcefbfda45df438132cc9250b23c7ec13b0d11be26f49700d6724ef5bdc8898f8104f32225ba3b02f0911034710dfcbf004a4d7ceea247c2471b6c05cca1f827ad5361593ab397f25d8318839e7cfb0e187c7cd57626ecd659b3524bc6905858c328c8857cdbf919b98cff6ebd4f05c37188e3b022422fc965b9e9e8ab19b768c4a1345e3effa326bfb34a5bdd3762554b7d416ff35f1fc241a871a88e0825d672af05b35f78a8949863c4bb672e3d4106c555c60f3bb20a9a8ffffdaf4e027024847ffa269415d2414edbd04c838b3809152ecf05265e1cefab45e5470c109a5c2bf0502d6032a5130451b34e25a5677c4e34871e10d03b2c7d7836f6694f3b167f8ec428c297389d339d264319c72eb5546106f3b5f10347ef9e4d7db8c7ebb104aad74f82c1f17ed2d3dcb452fb235eb3be9e6fbb43ca77201ea526c701219c5ea9df6a81a1735ddca81f99fd5321419f55b5d0c63e1ab489cfb0d0dbd2a954438a407f492ecdd67f95d5c5e05bd5d087f346e2459244ca3dfaca9c8a736421a19bde8da04a86920e4897734248771ea7fec971b959e7e4c91e4b193747892e416ae52930032f30ffb67784fdadf14d1529e3356ae2846856bb28ad5e7a1ffdfd5b73e40d8cba8861d5e299edff7716a22ee3e175a5b51cf630af12811a5db04bb60f501578b8f4010d91ddfdc4797dbb80b1c72db2a57891e51d62dba5917d7852b3ca1935e03f900dd4cd1fbbd82cb89b4bb9f4c128f14e34825618ae58d8198f9098d9d14f38590204d2547a287cbf6dfd76c76517288dad54335dfd3d6d8f94d483e1ba5188ebab9909688642e930b6ee5c716cce5dc9554ca64ca1555b0af777355979b248fdc3b738086a670163204aab1e12b33110b8bafbaf8fb246036ad0feacf0f0df42978772dfc81d676faf431c5d268934de6e6db8155ba93f729d60851689db949af8c95bd3109b4de1a4cf0705d661bcfc6348b178e3022e059f96cc56bb5072b9a67056cd496f7534c51064ee092b90cfa7e9bb2f2caf2454d02406a65c7151c256d702f726c6ff0041e80dcd9c38053c4fbf80b4d4fe61610676c1c67e8091e9612fb93ccea8aeecdeebe0a872871c4248509327767fbd1979206c732a3df27948bfcf16ef79dbeb6147195c211d0e6c921f10629a4b623c0fe59b25f967c38db58fc2a9e20bb3e9bc9584e452f8c209807213f8a12c4ce6198546a24d052685b243f584ba92aea270dc4adc39e6d6f887e99d029f97c64271d962dfd39fb4f23f238dad7d60bb31683d09319217ba654063f2829c4dfda7c2c4ee1e41c321803499a995a42f990bfc97369a9d335434a47eecd2c996351d196feb46380952b89693a54bfe1bdc22d3a062c4e4a92fcb8757ab85401508c0f604bde05fad2fc73efca452e28f5b13eadba1e31a258551d271c5532223451bf72dcec2f1f259012382a0d942a6fb501ecf24e98ca9b4167eb4af2d80b1ecd19eb34825ee328f1421eb545318e139628c59e2052eabb08cb732b6959b7b33c8a8af36626deedfde9c617245b29090326f81ae6f75101d77b75a351b776158534afb81437ebce1083de39467468556ce3817f7d20d4cf88e6eb3cf29ec5ec6f3bee6b78f962007812f89f1d16b1805d08d93f55856d8d2abeaf4e8caa8bfb6d36ad147e82455e3bcb3e405ed2d6d8ec755dc3c000b38a6401afd7877e4826409ca7d67d0088d475fd33bfe601b6a01b1839a6cbf5296bdf5610d52bb82fd8aaf1ecaff35b5735435d1c4f1960244d1cac9721a70b6dafda0cafd63ab29c27cb571ef0b7a8559b1f61c0579bee39e4d1db2a2f97a4b4c329f5a8346df3f420110d929280418828a13cef6cf9bc1414c163b06f599367ea0e6c4ecd151e008ae0139e48fab4d7908a528c2611b40909032aee011fb60e61b9083478e665c767e24c0c2f627105e632614dab65bfe98dc1cf96f4bb3b6622e9d713cca0419d05fd2a8e1699ec083c145616001972abdd7204f4b419c37d264e63ea03c5e65bb59fb0b6fc2ed02aa2bc61307833a02b56795a689277f45d60c4ca40654d644f14431310b1b123aba07b91d405ad84f41022df2e8c9f27af90e0805eff71ba315bfc89711e9e7c7f6a2b70dbbbd0b29a8a27b298c76b0c03fb5075bf713a2cf0b10c8c3ccf590d2c4ca26532377e63701a35d97626932c09a89bc9301ade89e5dd475d90afac7440e12c0a70a32da2be4388c92ee93a651a1cb811e997aa9e6c19ff0d9bf315e270ba7de81f97f0490c401ae2f8506017128cb374beaba8666f4755e9b9b141c968d7376bf05828f63eaec7a66e1f3530b9932d7fd6e572db85892448bed493a0e4a81af6b9cc349cacc5902e01e2f69503734a9be85edb0d2a06f1849af21338e1baf2543baa9eec08247d899c6aa6f96ee80b0ca5c8f5e7eb99aa35d4c18fd32a67e85a45c9653f0c9bd7410bb3fc92b8f237540d66ca96e6959bb12d17b5b1f670b9552008f5b1c355ee2fc607f16805e8bea690b3da52901f8a8033109c9ddbc596b9f351bd8bc8829027c890db6696eee7bb1312edd7ddfa86e6f63b7a12a4810eb2f7410dec4295a51a9f9902073cee766101e19d12f0809deeebdaeeeec4fd67e8558a3dafd47817daf0253844aaa1bc7097b8c1d3228dcbbc817b4a97987ea78cbfab09e92fb187055daff55d892ab9f7b6d716776f7617dcbea2c5e615a8c02efb50feee76fdba5f317eafdf9598702226a29a656b5481d62a7263ed49d61100028bbea99d7602e817668accb0cf5799e3deaf8b36d68957a310ac8e0752cc7df66f50fe0a83957a786c687c0b61081c530189269b0d531b9288af3257e4a32f7b3ded71f0e60713d6f8a8a60fee216cda483471b0448a82f6d7030041a50823fabfd0159406212c62ee85c6e1a114c8d0183a6889ceb9339d68bfa1044b9185980628f21d89a4a9d37920ac60dfc8bfad6c0fe0d59c5f0c2b7ffce7ae37539c6ab898fd80de65445c8f99728118a8d896cb2e7b54220480a27b9b6c40b9b7b7768900c4a43a790ebd70fa2d327529502a3a6d3074f8dd5ee31ff010b454e7cef41acb91d340ebbe24f428efbbc4c0cc668b3940e753ab3c9a48b7cb5a052b7c77b3d15b0deace05f62e6e618ef19b30e7e53f461bbf9069f6e8d1254475badf87f47c8fd4b9c6f6c03832c8dce2dfe145d6d9da9ea4d2f44060108e8d743e72ce0cf79538e85c840f5968197b7ea2ccefb7e32938c99e4cbb8cb9619a87951a635ccceb5b06885455c37a5f5a4fe162dbfbde1a7d07805147e48b9865683330a75a47304688b0e8892e8caf4a9857f7d8961918fe51851a25ab6503cca36cd5781f436494ee9b0ec6ccd179301449e7dce740432c38ee51aae2cf8ef285419abf6957360885662eb2c74a2fe8d54ddea72005d0544f7e963e0331fd3f06f2e439d09a45d94345727f77fb7b3991d1ac471ebf827e453155fcbc0b518064be0b21edd339266ec48fe3fcd4ff0a5c591b1ddb8e549dc1d77ef62e9f69e495b48e9a946a1d723622c9f0bdec77fad0a87fb4d93fcbb183c0320b5ea90e9eb6c13961b0661059076deb29e5f2db728ca2c5534990a3b3cadec08bc29f5c65fd4976722b409bf3bcd39f55bc6022d4e9bae8bdaa4328cede18968ddbcae88d5eee41c3c9b68e5dce5b78bf6fad482570dd886c70a171850934849c444be5a7f8c84421cf1297e039ede8512db0254d3e4e5b8f9b27f6429113fd79af0220f0a07348fdf5b32e7e8ca8f5b5cfb351bbbe0138ad46d6ca6a279b4dcafd3df0afcf380df3b675ba4b77fa2714a918aa6f8c3ff1e553f05f33851a4323bea9e90b6211e69c834ba92a99e32bfc3b7ebb1b3c6aab6273249b032ff6d60e6bc5dfcbff4b0a73eb11c9cf6020dc50a801497aa13edfee7f9a5e800b96075b00ae59e297eb5b8c7c0269f9fedda945d265842b797c3a267ae0d58b508769db4391d6a51be5567e97bb99741ddaf5e94fd3c9f46835d4bf1951b9ffa6980e3587a4db84653772d84949f648a9b8f3e1e48d428e2b0d33eb30bc1aaaa350c5b0b54eae09849d7537c409fa615db844732f5aea2ee3fa8cf7d75687764a6d2f9156ea610259af16108ca8df2f1837394610df89e1205f3ee1a4fe080c1c7e1a160fe240d0b5eda1f58238e9524524d70112505e2a4aae2ce79dabedaf04c6929ae21c72fb6fbb6e0dce9fe8eefd1c9a9a66ece1f20207b51a5aaa27f1fe18d329601e1f88d5a32f9660e362a7b984a2509f775cd79f1a914b2de4a252d7a5302233d437932bd8b1d4db8b387c8d7e7a99e8ad14a7beb5bdcba55cf66713d2b40c9288b74b8beea10d56361a00ea85c801fcbded6d95c48a622b5e38c4a839f57561cef1a34cf574d48c2b80c4f712d829f482a037a8a33487af6a914342d80d98241600fd78b3eef42edafc48c0bada7d87ba979135132a737f6baef4a87657e772a67409d8fe33c86e4b07e2ea5bbe52c692121901dbe2c128bf37098a20d71d38bc3a19c7a9918ca73334f162c1394fca303e3a27944a96ae449d9ad1717db5b345304bb52040fd15ecc63c7c4b29d889d6931503a07a65d25e26009089c0fde708e43db4c6c14c32deb2daccf6a459549261d487187767aa083d0bdf129a0b19c280b1864b32803a8630874258331b4bf95e2c265f2ef33570f43182813361efd615f6ae041e7f040071149dccb8cd414140dc1146fbec34be8987f6d915b5f2a3a8eb0e99ee1fb55e37d6a975de48fa69378286b0d9909d39e15448d7da7c7161f4d7a988ac9126b936e3f0933f691839d7acfa94769f534555127c6f13dc3746c45c9031a98e25f2416bb2e67699b3c95750cc4b7af67d47aec9ab551f31d74edfe20d277a3afc31d57f6ba29fa7d2d5aa716a50a3aca7578e19efbdbc9d442d5f33bd91126647227dbfeaf932b4b1344bc7558e33964a892bea4ddb815ba98cbff3a16a6d8266479780001591a9e1f0c7388dc4faa54955ad2e1cb9fe392c656045739c4b465f8d49a8ce70f4241876a59491d46dde8623acd599bac55213195bd4605ab3eeeb303fb4166b59a25638bcab2176f82cf48c62556129c819f478be424169d83e5049298e4137a6147263517a68e1ed33c13ff5815d464cb57f6dfbec444dff81fb0e108f6d9e1419eb44acf5ef17efeb494ccbac1b1c0a4547fd4a861dbed770cc4787daaf81a4a2cdfd27fe2b63c0a8df932d604076a926cbd46bff9f28313fbf5d9f25eca02916b816e6a310b3903566b39a22ea51d8297b34ca050b0c291004642d490d0a7a66c3fb9c3016df600eb2b6716f6d23f6eaee73d3455bd5c244aeb9cab6b84c242ec4a5db640dd4a054339775a0e12eca7d2dc91cf6b81b7190bc24e0b4d23de8e743f31a986a164f3db06cdb4fff52e58b64146b74ccd9cf59729de6e04f05447df70faff632bc2327c838f7d4bf69ec2a878f05a7f2b21941825fa28372c00c64157168e08a05832ca25cd0e7529769518f540fa79f3a9ae328253dfc4b5d49c680ce51d42b4c3485ca86ed75ee7bf6c3e2aa252c8b6b6e32c71e2dd2b1fcbc43c391c469a2fd2bd7a186dcf1425253188ed2fc3d6f497fa51967e0619a52935a326838a657c27094190750dc0e325358cf179260b2badc8ac912d771e95a4c627a919a575bf246f261cc7f31b16d1a566b645a962941a50c3ce23a8a6a0a186c93260f2cef8a58d703cbb448f8fa30956accfb3a264ac8b4028c712c517542236dcbebbd3c1e62e79be7e0231e1d2b25e0ada1ba3eb031dd76d97d8b3d82d42216d9b9d7b8fcc8b1b7c386df2f1d367ca704455df985ce64585262a18257182380d06b23c5fa3eb5e3180ee9cc4685931005642a38d5f4bdeafa7f89bc472cad7343cf6e4344c41c0bf6460dd8969ab425c27dc588a54be3a3482233c674689e5bc9e904207a2050fb9f81d74d40057ce321547850a1a91d823a6915bcbda87bd0341119dbca5f3778d9dca89496ce735a64db4ae1ff0c131d3516d836b4934e90ff1b7adc488e18463742086712717ade4391d88292edf9cc95c77b5992356c241116e8fdf344c3fcb25a1c117b678baae3fc5944f30e0e9290d7f2852de633090afad08f324740e5419ccfc8df49a13c66190752a65ec4a3a84bbd94b08b19463d4101f205c1d90800c1231f0a93382aa81848af8ab9decc888ba5431032e63569905d65a6b84efccc949d7d71dd3f42dfb2e19e8658f4c2b0c78393b7a9ab287b27fcff4b1ead39e42830d4a47a8738dfef13ae55955704f979b18fbaf326a1ec4c2e4ebf9b4853fc38cb608739c5102561c17cedbc827f08553ba311166aff2eb6d2c55ee365f276531d4a134c3d3f3a175c56a2704bc04dcce544e513259eee80f6e8608a9ac59442b8438009cb21742d703d100bc2ee8c85bb386a2f62f6f371928314c7b689442ba014c4f7173ff4240b5ed1131b5fecf8851f3d26303f3c90f55a21d822f9a02ce4964ddd38a75318ef09ed4a68670d0e8f3fe46904703a5af2215a1de32f1ab44c7ba1198421223b425405897967e361df0862f377a88cbd1a9d865e355db19b581f7da44684f82b9e0314aaeab52d73cc08732f6ee50711c9dc9f9455fa4da2305ab0ee852c2d319a77358264e1f5cec8d311fb9c2572ad662cc392d7ba2020d5c542ef6c12e2909a0d96c77972189243550cf8c30840247d98df6b92037a81465674e63eea97d1ac5e346af4958d49acf12675b2aecf74f934de64f5519eb91203cfcc9823a88c8d5254786b7b9a3bbd3b526c0a8be0ff0f1f5b1def74c8f29aef27a03c874f9dffa05d88fc136b10b9e37c55c0a9b5f1d6755b95734ff58b8557bb9acc1f9c7ea74305ac74785b16fe828f89c080cdb7fd208f748cc8b4a63bbe5ed1cf6374a8127bd7f9a17bb99988be16af7f651c9edc6dc934ba472059774ecbd5f0c71a783f9656c0f0346891bb4f08a22166b163f7ca796dfade6210bdf24c8d18c180a6e4e240af9c8cb8e0e5c1444a7fd2ba6c4bc5044475a8fa5a58cd5147d1fe3eb94068d4d330f1c7883d5d9762f9c08e5e1bca0c8fb844dca22b51a49cb7302a04ea50ce99b88ad3e29790d115ae74ee54ba9eecc105f45d71d594e8854791391281001f7b529f49c47f538db69befcc976b5f961df3ccbabbece3650d3809d038e4a072c043f591af691a7e0e01dc7b312ddd893a09525f2e07c7e2ea1fce1fedfc52ef26ef131d8f87a93538e2eed42b384c4148b69e79f3b9064d52084effc0d11a0cecf599d2e3ee499720c955a2033c67ccacd7e407bf2bb13dd8d138e28f1484e87b307fc5b94c1bac83d6df34d1233a79ba59d925a63e7d94b4a7f4f9ab7b037dc6d00cafe398fb4703e03c07eac071f2f7516bfc36489dd8f5cba580c3b61850f51c3344827ea6a263c4ec1bf35150c753f20764899b9ac88aa2d8a6af2a68b5a077ec5a2ca696a002b4f209ded179e042bd30268d619b3faa8b04f45e6deba6da679ad0c87cf07b49e49361f63912058e63f47da82b3fca43039bb796bb769a5e568a4d02a019a5cea595e2433ef033eae13635d4d18aef09f61bca12606d479ab8ad90c37e2934c37d9c3f009ffa61a70a01b87430f3e3a24466e9c70a11e3fd8138b1440c6a0bcb87b5f50ac88e0c2e58f57a097a280e6d8729f26fb23d75e1a3d8ff56eea57496f9c62d1caf96d6818ae67596f901817f4b4b1ca76cb661c4b007c4a942ed46b3c008edd22d6e3d19a711077302a6f8e3a418864e75f56ccc887220a7a4ccdbb206ab56e97156b8ac929523a7f477b003523dd947d46551af942afce6cd5d89550e65c1bd5f05e90b3ece57e317f45753350a220c00f2299c48e8d1c9bb1963d7b1e65e0652b87e974782ca0194480a1d485c58b45f9251f2c7cc0810e33e1312f1d557f3b77f41e8feff786855064669ae8e6027b923a3385eb84c900bc0f73738e640b937ce5b44bd665a9181a7fe8556e21dc184c94bea936454b7d530c0e26ef5acf08ef430d45546f6c8a0e44cded690b040295e87553eedd09f6d9e0816a953faf9a378bcd985f79f662d05195cac9feb46c3e46cb8e6ab877d901f173adca695e46c2f8b91b64685aea98ff7f75c8f38b64adba851350f06e4324714ebd7c3fe66961d86219a22d2e95d8220dd0fc0e6921c2d09d03301a5a9c68508eddaad0faf490c7a82fd61371f21ca0cba3cd5962e2b4353406847e7ecf4656689d358ca2e1d120ddbb38bbda7558330ad6d06db9388719c71e0278c2ecb3f56c56c710c8905b3cd6ec455cf85e7611af83b7e65181667fbaed3f50e3c571f7c5ba715e34e472fd4c7d4f25838b1f2e6f08b43b4c0b73ff1d40e0e73bcebe0f176d055ebfb24e1d7bb669dc562fad96a7e9f1c478419e6f1a4711a67f33d52ead145a131a0e27326c7b8da533623f8f1ba6c2ca9297dac90cfb24a4f1f9ff4d243d087189088cba952be34e733057efc7529ce81be93ede47e50be60d121608920a4df1ce7142ce8fca24cfa02fbad8436e69b5bd82b012b7b159deb2eea8a0a5fd019648de915b0cc8d6a2ae0752459d80f25aef6de1aa5b5190eeb4ac5d0ee7071ce472be5ef66b16bc2dbdb9f527a4bc2a41c28518d10029b603ef2ff31e4c421102e56870dbe820f13962fe4b67e17482c927e0f4350a72123ac0f6842393c566b353fe43d539658e9fd6f15d62b39a6ac04c593e2123fe1a9b846a3d07074fa2da4becf9b3179027ebb55a592f64ab62f4c5a8ed68435c1ee4bd200ae439d221356515d38b800cef4b0019141fae3a6036518c00e7b7f972dad4038d3ee1902a608cbcfdeca95e72b5b04db88d9d7fb95a26d5656f1552fbaa7ddadcc8e8623e4df96d61d47c0ed9a35828ae87589fa2e8d545f322a52efd9a6a6359eabeca3e7435d28522c6dbf17ade5f3f43b70df0729aa6ac80b4412188bbfc9243b757e1cac0ab504cd7156cbbd6826909f15dc3d8fc0830ea42880b4d777afed74a806564b2520c3ec06b630e6884444e1a7e5912df6e782dd586e71b792bea17a6ae60fddb6bcd06262380929d1cf865e20f6b7b16d653823aa601755d84a918ba889add921dc475f43ec6f0b5f7bc9fca10e0cf4d3dc867c3660e61a27f13393bacda5bc0c0956a3c958a5079a25756608b05087a5f8c8282c79896bf754f3af640de9d4156fd82b326db42e4f501c71fa36237df5e626a5b1828a7872fa28b074db7a01d1fa5f1191116072320fe0fd45c3de21e6651d3981b7d6f97e4114fd9896e54c6c5eab9f86171f064e9d9eac05b2791307d443a71ddd994106d29505aa69fc12239503e2fa6f382b5a4e7c7f1895d29b2cb6fa70799dfd22c7a1239ef7bab8ce151e6591cc5f2609b9229ec19d5134e6976848120a7bb5caa29d0b6510b024dccf5a278433826e872bdbc38eeb3ec832e5acea9f3b604e19353d77096e63ae44a1af5facccb88d9c2bed14e77a617870b09766984039583926da3367d03785929460705aa55792c94a8bb6a7e1060bc809f718ccb8cc83ae517be093b7bc7ab9a29b6001de5e74a5f12db9bc812b72ef203777c664d11f44af2d062aaad68f7e375bbab76198e4751f5eef7a58d2a52df2eb8faccf8ddcd4574ca817eba5735e4287796f68606ed744ab4b701d117451ccc684373ead3cd192edcc6e690c6320e984be7778e0acd1107eba971b9d5a43edb440d533220e92a6199ae4bba381a1268a210a9f3200d56ed52120876ef6e8ffeae15fcc0ccabaaa2f59c72ec3fd518318cba0cd72cdf8dfed79877ff7626ca2c88ca7dbba3edf89c97a55a6ce0b421c114bf190bd2716458ce819beab4252062b557edfd7da24371dfc748d7ce742d106c606ff3555e943a95b28a2cc5cd739bee9ddb1a695cccc120707f80ef3e021e960a9b056d44b78328aa5b113deb32675ec0ed9660457c25deb3d6245b8b4583fed95de8626d4040b717d213aca4059022c0169486f1c2da67927a064b05e35fe10e18faf2e16e12c7954eb4b0f5cccb23ecedd0bdf3728fbbcb89c3b0c6640307928ff634479420193301cb76bec15ae4d95fc09b476ad1ea85b94f3e3c2c1dab6325c70811ae68438d96bf372db5db1d32f63ae9f21e5ed4457bb929ca5a7cbab4ea07b962b1bb48082a86a3d416ff11b55dbbada6b9e3cc3387997fd5d72363d8221f22671f41f19148da32310b267a1ef67021e11c393cbaee4ca828ae2fb8873b25189ee0e961c20c975d76d988270a1c3f55252592542041b6802cb86a769c26eb4ce442530a98f45de6cc4ee033a30e700b24fb3a8066603531de5bb49fda29a4a2274069627051b842ed9aba3e4ed5dfa58ee9398d2b9720650fb5d21a1ac61bb02464417f8c74a90e8766af3774dd79cf64667643307c6479055907e2b68ae3e16fc74e8ad74baedf8aa6cc46031937a500872dad1462c5835ce35850fc0c68e51898d7aaf3d99442de6b64ef1361707a9b1fef5b365a46ae1d69fbe2d9ec07e498b7c778c65b53b8b328c58d98d462b09d96e43bce9b091aeac33d77233a42433c8fd3407e3b9bd24784c29f1997377ea5048d48f6846805a18df6bb71f2b0013dba0362a1ca5ff1212eb1589ae4fcd81fd9663d3278622270df4a7e5396adbc56c478e2e09283e9bcf32bb709fa1137dafae7671979cce773361f756c81c3866d4635ad1153e7e6fbb766c0b64eaeea108f9f92787de32665602e7d986d1928cbfe869b7b4fa6205581e3e24ba3e437bb6c9609609dee0c41cc8b12ba560dae73de97759a340c9a2d2550cb0947fbce4aaef04c98b49a8810f192a62d5cc2fa713128e60b7b48bc8e7125d265a0dbceb99a384feb7f49c5a83454c8b49fab5e07f79f7eb6ebe7f7ca725609c0c88c7a936ca64ea36800338f3aa91f1e8ad885892542a82d18c693a489b0917347282a9709f6208226efb014ef97191a01ae44e867ce62c599ee23df2ddcab7a2dc9441aa203453575e3cb96fd45619b64f74e1175d1df74fcbe59463375a6f78eed6b5a8db991e235bed9a0c0644c28a42cc981790f69775dbc3c22a906581b1f5fefad7d2962d6470abf224fd246659f3e3962073b9470b1d769acae05aaae561826fe089579d26b3a2c584345614a8db266b4b06989c7239f9631d3f5c7d5e451fbdcbdc4bbc968d317860f3bda0449a9dbaaa0d31b746a6fcf13041849222ce7b6b5f80ed9952524351cc9d24a58ff4cb7d06199783065df641e25122d9bc959f053ff727bc805a8de5143c276025df931a8c08b718ab5e4941188feaee2568fdf203ada5a47df6f84414ed162295d74d1884098e2ab8a01f2711a9c283547b230948fad4af938c5186cca02321e3844c75661263adf59ae2b8f0a50b6c06435bf8fc81258dabac6d5f04f871aac5582946691ecb56a76b656a88695ef81a5f9c20f20f2ee45504dec3143165c02e4f31f61b8a8d3f2761b81d6c1d150d068b3f62f963b2b74281a5a540d134fa6cf1e9bf482902732485abe43dec4af8c89c2cb495a0693f2a5f7b53955d6894e3c4da36da2b85f5889552616be532d780c280eb6ce7b60f1b9530d72b4de4e0f248e41fa38e35c5e4eaeb109cf60ffa0403bd252d8e1bdd709ceacf567174c20d7bbe722f9714440697139bd63cc7f7dd423106392d28aff494999c7e4e86f64c6abf473318a8c5d23f655e0faeab594c7c5cb9163486bbb382869974123cac62948a54680ed8bb2c64740f46da6d1ec8e3fcc21144c41496680349dd0f44b78fd02c3be79cbb3833aa717bc0093f299be8cd388adadd3b5f82e85013ef82868041314307c09b492dade325878aac93d7121bf185647690063c962b5adc20719c213254e60866af6a9d2a4a93d9e429eeb93d6331768bf4dd62d44e9aa8b32636469292586b92bc1c06153c92fa7059f93c60a98c54e89e7c126150b62aaa4784619f3f43da14f4fa3097e57f1040df643fed438c8f41a561c7a1c432549164dffad15e8715493487ce5275dddcd7ddaf4c40498d0341c0654bf186fee6b11ab5efa829ba020c55e8e42cb5b8fef8f9490be3c8afd054f9c8fd98e81e66ee927c05fb68ce20819153bb74e14e8ae81f551842a0e094e6b82ea88842f66555c75d52b42cf3bec34ca5517c3a640ca0bdf602442ba2d5fb01828c8d47cf00fb56284d04d88a45573d81bc6b92fa6e92b4c64d60b9cd8cb8f2e58484ff77436d8a4efecba8fcaa6560ac803fde30e09f98bc75be90d968e3ba4c37bfbdaee1e961e3965e0fb0ef37232ae996fb04a864b6c147b34851e64caa4da739ff7598394aeeae34be9201344dae8479935ded37bc77fff210d7b8d430318c09bbcef103913884236d7d0b462aa6c0727cc690c44914a7e6c88c32b9b7932f8cf875f270cc8716a9b4e0ce4f1c5efa9ab5c080e5a87cd883b2dfcba7ba037725aeb35b442a68a80a1b754707710f98ede36b29a5ef63bdb380d5086490bb0d14ea3f14b8dfdf097aeb767304c89a415e3f4b9bd0e541f422f7db2b624885e42eb9fda3f3429fa55631c58fee6f7510743f1b8d1f8afa22166d57febc9e67d18b1824e1e968671e762040778056149990161368ea23f6c97a242ee91c215e7fb12539565d0e26b6974eb8c1ee88eb60abf656393bd3b065862b332d5d0dda4bd611317b582f818b89f190957a1186e0a23b6c997bef36e1df6913732d85555d0c47becaea554b22c3cd970d88f4f28f720943769a320fba03d276c6e409ea75daee3452b9f878f68dbf50d7374deae0fc93580774181840f7b2f16957b7ef09dd09ddd0cd484aecd980a35d777a6c01acabada9290ccd1a2705805f08f54b94192cc557dfc936cca4dd9181d8aa0b5bb9f71ceae7d1ae890ac734e4a40d11637a835b4309f72cd3b220e29851dce17e4c5cc4dbced6ba8fd13bace2023feae74eee07d8a3aa4017c2e576fc55614e330dd55c0b3a87e3ab5f1eb608762848dcd6b663cf8c95dea445270c649debfe8ee3c8ed3a1f97e6f8e103cefa13c4fabed89ddd2b0ffb0bd8e6f921b330570a707d739c53ac8df7a635a7f72c1d3de7124ac966f69338e79a2a3cdfcb078a4a785761d0be252be9380015eb29598828d6ee5b1fc7f2f0d9907bee9da6dc50831591dd771348d9bf44086d55b45be41b5513d7d9698254514840df937be88500473781b3d55fe553fa44fbca14cfb4e9b76d3148754a088812a154c2be498942baf6a7a725d315855fffd498e2016a59a937f673f27ae26a82f00865d566926ff4f9fdba701127d89731a606cc518298e9c5c8db0b61501838f240f0c4ecc3fc4ae3e159b45085d8c86b04d22f309350ad094d5beb7a10113559224fa43599de3f857fb2ddf7857c998de8f0e0d75b9ed6328d8356091cae72376e0a73d8a546b7f3265c75de62ce01f2eb4a636ca336d711cd3ba44fbfb00ff34a78160ded7036912fbc37b919045ba2716fba83e3205416bab92675a27339ad63ec16e2c082b5103447704d126d649500e437ef721751a822b0af5aafb544c8e865690736428b7dbaa994820179ffa5f72f8d290b9ce1703be43a83d8f1df21e74ccdb05a8e5a79c755161d67a6f434e0a4155f1ad33e980d0c2388b15837e942a0879e3a6002f17bd0f76420653b2bc67b1da161dabfe48bef55d48ae0e62f2bbbf74864d7288a4ce86bd2f8a54504845330be0e353e2dde1001a4c161ec8282ec29ee44904d63c59c14e953352dd2fb2ec39fa34c699c84fd3fb2d5faf4d3a105ea2af7a1ad1f2d4c4c8ff436ee0333745dd8b4ec85837fd5260385fd451c44650b81531601f5547bcef0ec208e59854fd9bbb4b22a9db8c9732d3da1d62ac50245b92f0bde70c63b1ac5e09bd59e140effbbce92930e1ba5b55e81cafca5f0f0913cc36c608120d51f7eaeb1ba33874468e4ec091162c683b7ab65d6da18b0479859057c164c089fdeef515181e1e58c9b51db6af9e3d0bfdb6169f4cc867ba9c1b59bf9ae9e78fd9b04789638cdac9ecabb3a2b79155b680aa6da6ac6736f4ffeeb451003e7917166f9a521103f474c6d00a8f744a8eb420a1a0f4f5da36d0223603b0d7febffedf83379c082b72918399fbb43ee4edcb52bcb4ddc896d5a535a59080711162bb7d57e7f8918ff04fc512a44c46ed47ee78ea2d82a33eccbf78eddc98ad0a41e17c68ee81132266dad2ea7c288d5cf939d051e63cc0625c3143c41564359957c9f914b9a1bfa3b318768f3b431ef6015422877770b8e5e550c9d932c103ab41fac80a8cedc74348c292c3e23ac4fc792650b4142eaac54f8ec679f9c526018cfef5f819102a5a1d5f9bfbcdb0e097147be77e7f4c66d2a0fac672bfb1c2eb47e2b5666c93a1824794744da36c7dd265ccdd48b0ab8e58c264e14e90d083e6fd016a727c5d76c97214b7d4f49b7fde68fbcf723f9d50c679d7a1cb11ae22c4373da90e675870eee7f4d44d8d2a926ea43b2ed61fe13b7a539dfd407d9f1923e10e6153c285610c05819c0440b59bdf94cfef05ea526a3eafb3fd5a23fbccff2b18ecbd0dd107e12d761cbd2e9e835f490312fd7bbb4632c36072e4a117682aa35c456d7c2e4fbbb1cf0f380f58e666760bcc0112845665f90b4f8974ab218c76f382cec3e53588589f8fe8b45faeb0080d3e493eb919bfb18ef6b5b023592ef54ed4820badfbebe7916148ba3f5cfdb659c5cccb96277896c159c3b205ca5cf60201ffc7741023e9137e4df2bb9a3eccd919bd9cc02d59e5ac13ad9d93616b46e5da5ab61e9bfee27e1fc4509edccc00262c92d9ea52d62a7580074529cfb3e46fb5758199e87c4b1bb6ff86dc1d9c4e40074fdb57b2be47f64c7ae1f8bd8234cf6c535a7879b2bcda214eae9c89971ffd77f28067d5834aa763fcf74446e1eba9b2b83adbb286b77237870819c1f55a61e429b4106d77c699e1d6291f13d24702a4751fcf1d9ecda2a8332795b26f685e9a25cd446ccab8f035faf0eeb564458d1f5334f1906b0acedf65073eb288ab8981944450c1e3c2ef20b8ae32116da30dca3b379a73ae59dcc8c494ee6096cfb20203946ad22c3f802b8a1eeedcb0173a1516408f9129f5caab309e65e1a6491db90afce1229ded91b8b6af6f4d46c6d84ce96982451a708526891f88ae831e08a1abf4fce68b030cd1c2a031ea002aaeebfad614820c79b192ce6097aa53c92e7706fc68378f4c27530f9d9c0024a7ecaaaa87f1dfbf2dc6f9b7cc2ccd79fcc84cdaee0af6c0b2b3b2f1dcb8f73e9879d8f1bdb290a3b7ab6828cfd9927f9e3c5583ce16f0ff2c71455e4314c46b2b6466d9a9bb913498177aba58b9751bd2be246f36e44689ec0e01462959f87665922fa991a065bad123466ad5f5c8d0f39601380a5f7ea459d9819ec77d4120622a7f7766904be907f15eb9a8ca191fa3b9eb6d81c7338dff16628bdbdac3b7dbc30d6e810d06c5c3f30a8535685a15b66d737925365a31ad99fa82baac0b2ca44cb153671f2bede2f6a467ca8c8583922cbec23651ca09f436e23111a49c1cd7e83e9543b5377eff9febcb324c133406da610c8d5f3c7c77d97847e9b06730914303bcb510b1ec794f15376f5a4450ba9e8610a70d02b456f92c153d6b65d532eabc4bf860ae761b6f9518f0aa1e5f2263c000ec22bfff2f4b6d42209601dd6ebe014fe1ba3c7c2b4796759f2f31cce053a4d949ee6a42545e55677f545738b9fd6fd47288dec627f4e11f69fd5ee0bdbee1498a6cbc163f8b1b686f33d8412e527b362ab04ec989d278aab4d7f5152145bf5e1b5056b96dbae07773632a27b3c4cd9cbef1d086a55e794a8870c566f5fbe648793b36f2738ca1ae8d3233b996cc4fa4929e74f17823a455028264cab1645188105b7a595759bc2e468fa6eab0059aa022a98df7f6a17b868b3c4b1506b45b1cbc0e1d21b5ce33a77f5281fa1f09c4af9fadcdb2696119e7dd15e703d4524f8b7eeb8c223e850ca422a0d90df87321080e1375e66e2018821e6ae5ee083e73eda10522faccadd83abc5a36e1d9c5d10e09a90c2e0b7f9e953a2a43bc5b3155ac2bb2f6d3638c1f41bd7d1aca0b2dcb666f8d82e3e0faf6a988cba4056d8105debaf93fbab1c485cb0375d307f35a04fb75e83170f1a08686c5da514d4a89e64a145e966e76de7b8df9be15ebee124acda196e41bfc28e7df3d40887590194f0660b2c61ecbebb07e488288b8a9ef1ab9318c67456ca4eac0336a4831974d0b3b166eee64801628749644dc57f1e0835c8a70cd604bd6cf9a253bfdf013bcd7d35a242e475d57dbd83432f5a56dc224c61a487a5ce8eda12cd19c932e47a8ce749f21ac64c63e069681b2d38a7ad65d625d8312bc768bba40e03fe27f13e6cc47f4d0f9b9e8b3cd1c8414957b3fc01135f1c69fa28cc6a78ba75486b1227cf0dd92bb79fd31d8414460734764ec027dd468911486e4d7fb4b7b31cf4bf0b5ff3831a05050a81b914297ab81dbc27ccdf157c528e20996afd627e119870925b503798e6b9631bbdac442857efb0c7f3518a30e2ab0cd8a72761853ca176e9e44ffdf5aadf76c14130a04f554a0774b75eb1c91db3172d166327a9d69d5a5a46eab6091d76d5557ab2cc4b12ad9cb097c95593f98ca451406f5233a924cc47b485a3d25e9e632ec5735c660e140b3e60df8b95224a6238833bfd7e7aed670fc41bf9787a3f2cdcaaa5a37ab44796c5b5d0348d000c498179fa7a292bcd34cdf00f0758fadd191ef1c4ad5b51466c9d8377b2a127ef49de9c4d25b742f138841a1f15db8f225211681d65de29e6516680e17b9d564590c2300858de25029c31fc8d1b6af26f83dd16dfd621c140595262c537c7fadc1d0a07a68fe453652a097504f712cea1a4bc430e8503d1c693eadeacde86353a2ef50d0febef1a39906cf17fef87af810b0af8db81e1b8eb843cb99ab59b55a629d4fb6ae69e0546b2abfbbdb85d3ddf6dddec063a074dd35412f1a0a1b4daead75e9417969e7b5644a17a9c1e0e7ba1db036defd66dd97734114ddd82566f648c98c72bea1f81ce7ffcd21624c93e66f0e05c5871d3df2fc0c877f355d854447a334ba8c2dcef4e8910c4e25b4f6b990d62a132e7ef9a1cd2170fc2acf41dd3563131d735bcf18d524e008791c8eb1ac2799d7bdf7228af0452f39a73d38a3e7d9057ae44dc7f91a4ff013cffbabeb8ed41cc771a18541b4c30458fb18938d6165a04a256aed15e455273494edda21e1211b38cccffae049b32d54b2c8e5ba1254d06352c4b22a10544b530210","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
