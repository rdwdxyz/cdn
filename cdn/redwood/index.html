<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a3ddb44c563ef543f4fc222651dc6e535f7b9c642f174df5bca7f82703ec5568e1ebdcb9817634999e3e267b5f7cfbb80e515af9c7f27ea3d23fa0f88c64f9ab43d014b37040c5cfa9dfdb6e92355831f0175fba6440d769ea17c2fd187630e86cb595aea5e73b2c8453723d1482d73f85249661131c48fe9c5e1790e02f320bb86fbb3c3317a8188bba22e3d9c9679b8956c0e16f2548e5d5da51405ba433ddbbc87503f7edf2139c1ca6b0c31afac857c933c27733df079c4461467e40a8ab7bdb565bea14c6ed51c35698aaa524d1d0c5b2704add06e787cdd43a672be6ac98b5be807929078b338d57f319b783324c9ad259c4f87c9f4f81e09cf1d5f2e156a4a32964d365fd179f43d6a6bb2e160709da3439b0863297579617c8c1528d41538f85d4ad87a77bbb79536f646827e53d6fd05fb01d694fff667905cf9d495fd19430ccb32138b04ffe715116c4a67d785df0a0a068e170921548ba296f7cbea6d76e1c78bb26cccbef1a38f27a009b6c52d9aade9b7ef1233a557af27ef01f92cc7031d07ec8ed1e4e34e71b87a946c7958568d23dcea26ee3d3ee50f46f3bca305128299d4b4f11f16fdce8cd77a8ef522273fb1824fab142c2c48e2d225997ad288a80b639a25ed25bf3efa101742502256e7632f4b5e6171b203c90368214d0771e912c5c18f1ade24db501798fa006d52685272b87530ee50961ec21e4a500a9c174cdf5dcbd6f4646d5e71732c70e6fdb8a5daf204562047d5cd0347004eaf61b9a1ffbb4327e2f2d9cda6f6b34aabd27cde09970cd73a9a7de067f38bc5360c537ef7b4d3afdb7441dceb69b6557c21a8f32e4c1574eac44871a68d827aaea1d1e6ab5ebbb12ee7442e951c5a2953eebbcd1bde5420ea5c0aafe00712c4b12e9e77c513a3a56a92b60d9cd613d7184a72381fbe488158d33113538e2ba3ef9b44166500193947525d1d61635762f546fb98677cf23676c33c6233f9e6546eb9d8bbcf94d36732bc1db617ffba7c244fd8234551dc2505df8722830ed9b133c5b9bd79e497f3c703d01ae8a66069f5fbd72d10a4fe0494123631bdacc0dd1752be8787007349af754fcfae4915a34b375cc0d84ce3457e135ea5a5222a1bf41e5dca01e25e7d03ff6d1d01845386efafaad743fa08946d7ea85a666ff7fd71a8174fa6f6890be1292620f568da8cd967f7c5c801226af6eb8bde9eca334d1cf3f8a83c09c45de89f8b71ad8583523c1a1c7f6816ca379664c1c6baa8461077c6852d56a20272ad87a88825f12dc549f9b7313805655280af9400d6ffd7e0645418e45db70829467de2ee4c33b54360799a1ff1f9de0be6994aa474c86c5d84df84b1be63d66c5fc0be196c01eead4f71fec40b89e1b0a894ca91dbb6b2e8d95d2275626b3768fe03cdd3a6bfc9100db540def6b2c47a9de3beac2ba806c16bec43c1d6590eb439ef6bac769d36c7571c4a4c54938ac5313e1e7d08ed8b464f9a478e2fdba22620d4e38dac0ebecb0c4a12adc26d6745284e6dfeb0664ef9cf7675b4b2a4a202fff956eecd74891657bccc15b94d9acc385969ff965c517a20f178bf3c1764793ba36d8e0aa26cbc5a79bf711a35087f3f540aa3e600dcee15de5104eda44d4dd355e70e7402eaf4ccf1c2f6e20063f2b8fdb74c319b540e4283f5309cf635ff1cc1061ce79d80215515da84071841fc07eb99e4232a4799f3c1002152389fb47e37c9f0df936aa05644fa0ac6b23095150aca727ff1c2c4e6af50a12a9a28dab15fd4898bbdc2686874569465d36589278089a29fbfc61e592167a5ae146cc597b9cd6f7d2ed43e745d8f7d2aeb82e8c1123d1e43ace00d88457bc8888abbd2f6689e7fb7c7554e57e9e4cfbf978b20872752d01667aa947de91344b49f6518fd40f8abe8980cbe52c13acf9e4b76621abb643046b90b24668eb35ef59ccbc27ca52d971fe2cd375c7a6e96ab7a1fea8fbab45a31039d2ebd9e5f2cb015539212831b0384e9e5377d497821bff998de7c687ce439af11837e3c19d9132ec2b2baf1fbf77a2695b4e91c5ae95dce5924810cc6ba4739d232d9d23476372b8a1694e889c36b1fe10012865aeac54a0e0473df01b9f955467a7ec85097f614f653a194c1532ccafa17994d0601e798faecbedec5d383bb7bc62ffd86599eef0f97656bbc4ccbfe6219c1f089897272b677900d650e5a8dbb1fb6cb350d25ec772972add2b48c96e808d7718420f0b1c91cd251d8c57471367d90c1a4c81caee27345362307ac07b0d21616a751da9580ec922f76fe9d9e56b0f279de667e04e07ddf4b39e204f385cdf6545e45f1fabc86e2d39df7da705311a4677ba6fa5be97a34243d98a10060daa8a1ffb7bc3bd385330ba21a6f93c67fc85d94fce29683175553eaf578e7dcd4aeb9f49cfd548a132240adaca67aa1928abdfd26707c3f59e5666c35219083cfaecee437171051deca9d9b27f0f912c97447fb026edbebb17d3de28898b94dd700eb06bcc3a1da9a499e706e69072ca3484d8d8148ea0b86ae46e5930e0fc9f2c3e33252e166ab8b62b5270c155f55cc5260cbcb3c80791ceb687ae3392ab78159e17cee56f5a34b5af19fdb7faed86b41049b933158849486b25c19d40f08291f32986a9a017babccb8f43866bb1f328663cb9b5c0c3a2d5709189d15fe3e05f4a085bd1c6155572a23ca39d7e404036ee65bdf59711b26b1805915764e0d9e25dd3566b63ead65dc05671198fddda56b099d63983fb880e5701c3ef0c958ed2e85e641c6ab9987b3eb815914731618bd3820ae0bd1f6eab0a897827eaddc1603b40482a09f6fec723119275811a5a629777e119a7b2b35f8b32b2a8f996a750966d0b6ab6fa04a39231e4e49d3e6382e485886f65c663043f1c280e6bee6de4c89bb3d4647a0e68d25d10784f83eb0ed5f74d777826d086fc3de29e057d4c749d4057166fe0c0026b16ea9ce3d2c65e47761e7112aae541950f312b62919dea5f39bb0dbb41597696fefeec2a099986125a3c16f728354c8bfc0f6123c91a1ce6303acb5a2351dff0be5901a931bd3371f57298591257a1afeaa19fe1cd775f55932905e6fec1f18d21d1ca1e9b10e7222e4e69f0fc19a7a4c42bdf37f217f801e2d3348af52a04a5ecdcd0f23988642b654117cbdb450d37c8ba716638d3a3cb35f09ec02029ba107485ccca7c6f6f1e5d986c52552e92e10c714f2fdd9e3aec2d11215efb57ce02dbe21af3c7b0c5ec3f297060ac6c21d99ac92b892ca432b604978ca9686c8bd0054c6cf562f705fc98feb5d56e0bd7e29eedde74299c87b211a0d8059d0051c932f906e647e945927e0d278106c9a08f10a1f5c1cda8f4c6cbd459e342dd9854833aa8b04628d5386580c7bb100f1cfdd33e88904de5203d967bfe2584b35133ec947864110124d8db2d0eaaa61b678eb4355e9662a8ee852993be9fa817d33b2a3bf476b3f02ddf4e29da76d3ff324cbd0bd6ccf63742576443e2b84a7d2f9bea769fae6d4dd499fa9fe291828b8b636f86519cf11b3ed7c5a38a351c8c685fa5e5ee0711cbed2810bb61627cbb131435a11f68a12663a1a6ff032f79366bb2e67e87ae6c74315c45dd0f8acd53c276438d633e1a8f59f1c191ff2fb24c09eb8357ecc89e0284e2b436c6cd297265f031e2f73a63ee370641bc3b4bb64f0d153aa6aae9b8808e9bdb209f33b8737db380a2585b42a7a57c073ecd8b1a989e7bb87371bcc926071c742cdd95e08f1c1c9f8fa41968e769fc826123975cd9f23f5b11082125876f374e4509d19dc0c59dde20024b62474d48118ac5f45f742d48a99d31f6897d44f68f7eb47976072a2af31a4087cb19f3535172a2f204fe02d7392adae5ec6d805db590fb1b527e77f7edd44c4b3a5ce6acf716e64a5e8fc822d86374391912a3d1768c654b69ff7295fa36849de825253da4aff77c45b480bc7855fa9f8acb80e459a7dfa68829d5e5a33c040513ba7d00d1745ac0afdca33c198083856b91b27200c3780c4484d3c1a3209d60c6ca092e35a088681f394e4e1da7fa4f500939426d204534af6f44bf3f71c0101e4eb968e37a8c8902b27ad5dd847366aac43efd019c72be550a0c07f7793d8430e646ea7005a743f81ce82ab6316198e2e29fb75a63439688540ca36365902b0054eb712d311fe58a88ef2298776d5633a0a076523386392ff668209087d1bae316a51beb39de8f8b30b257e48680eb0a073fa22c77d616195763a96afadc3773894bfe93da3e5fa87cf59cb7ae606aed9b62426f32cc80dc145230c98ac70239ffc8eaa95fb48f9d1ce6b0308d976e2320181df579de3b685db336feed52f577a7bf1fb00a24cffb7b07c564c4cb93d8ae6c0bc9e72d5c4df271251a4295b8573305320fad7562f3be78d30d36b61cee872635d636f9445597d8efb69237b37401dac6e838c7e54d22a5ccd1d6dbeaaf0ff0cac8a5526699db98969c8e65ec7597fbd5f9a09547fc4a1f79b1b2b527701b1d89ae5485833cd2373f1ccfb72181d8401ee06930c41d54390f7ee8272fbf59b14153403939380e83339ef9fb5aeeaf16e01a55091eb6bf0a411f86de9e09c80565c697a3ed35e586f92f6bc6d379ff9ea83e01d27f506c532113a0701b2da2fd23fb037a413c9d90d60349a9cb487d124d6477e622a55d60699c7e4aacd4b3126f78d45cc33b3a07cb75dd7d7b5d864ca608a5dc848ca9c260f3fac27a76e73556f576edb886a37885bc9da1469e1933d6b091edeef02f901ebce61944cca35774db62623ecd2482a2a3a271cfd3dcf89998ca35284623ec3a651d6c4fe08469316376007ef8e250f6c01d852b4991ad69edecea2afb14518443324891185d1486ff3cc6b12d4cc743c3376398cf9f7627dc9d1a61a6f5e90250c330ad474d5f973f47d74313361a84b4437d3c01ff53d7f863282c10e16184bccffa366936063347af2ea66bc623bf0e90d34d29ef730060a27dba4702c9a60d5710b3fd2e7d996fcddfefd6501120b88c86c80d2cacb6cdecaf5e748e5f838f92c7f0ee4f073b0ee615426a21fd2ba96ab1a2770794bfd7fe36e382e802465c681e799e26b958e7f2394d5e6c1c543fb94ac03226504963c6541bb33599a4a297460c274d268c6f956b648ccd8e2f92327b68e197f7ff7113853c7aa728cf5a96bcfa59e158d521774c0a57906768a6228833ca7cb724a559a87b3c225a02e9c432a69e16849ab94892e26ba349e8cb97ed8471cd50164b669f68a92f3949d34fd1f67153934bd586f4ec880b556bd558ed590a3cb9f66f71cdd8e9a731841bbe90f3ca1d24d0e465ae2b3613272c83bc1c7c46f0617bf4a56e65b0b321ed60b2edb5c417a5912489718f637329f02c94f7bd1ca360985a5819ddd06339f4a9933d0fb1ef5b8ce44836d19d6a3f413c0b5978226458f17d0f074a5945f197835da78e4adf438185dffe2c796eb41c5e921a27cab3c9d04d635fc6c908b5cb5eafd7fd2a3fc8243aa29099e46335fe6c3cd04b8db28dc0101ba0b4711dc7fedce5ae53795fcaf0b6585dd043de91e0e48bbc7ec851b37d093fbc949c3531f24d465ea00fe9823bf82d4a0895c9e0e2b514b9bf2aaf0166c3838e2c329740af2f82cd21f76740a684d95eb8fd805db4e4ded31ce9bd060230bb6d896f3479cbc1fd3a6fffefc9965c00b5691c01b8759853f4e3f95bafb0d33f9be30b158bdf47f14b21869b871346330a361a656cf502e614150c88ec58acb71ca5755a97c4dc6e8415e2fd0bd4f5b42fad1e1e6aa0e5d6d424cfaf4efc5e75d5a25b822f3211702bcb0efb0495d3cf303b4a880833aa5b0614f191b19d02f5f66478ed6cfbc99c8fa7db4ba4a6e00e606a9aad114a5e6631bd484dd952469047c7a31a7da5dbbf1c617051ff1ca8aa7446c5645fd34beccc810d563dc6dbc7f497e66e81dc76153ab5a70b2d432acd49aded8f2f17bcd5aeb4a71b989b2efbe3d99d3c07645f9247eb1ad2ff0910670d4c84d2577f19db6526e39b73df07759be113f9ad0d5ef7dce53926c331c662e4372b558216c2b0610ce1e0c93c9363edba0275d8e54ed705e254d35a06c7f565906fd778b6b4c951c0d349ad243ae3ace4050a3454c1a56912443a1c6192088a5cb3b09c20ef1cdd4671811ad7d98c9d5395373b8e857bf673c8acd9fdac55d9037afbd6073ef65846d2ccbbe054f2e4671a079d7c9f0c906ae78d466543b8e204f35f1ee553d5d2bf712750929b8df779935f0f253237b79d5b5290ce20bcb90f6b2e8aca90cdfcd0e525059734e2e87738633318db947aa3e168616f673208b70a71530273ceedfbeb94b5c5e0c26298e8193cfdc3580e0174f7cbc5e70350403d4229f7ab1f88e6d9868c3aaaebddba358e94d3dfbb6ef221530ffb0594588c8452a66e9ccafa70d1e32f5147d84de1f5bd19229d3584283d9989d95316729a1028697903191bf9e820896eb83e3f0defcc22d69d15663f26d8b2a4571be04cec87ddc6203462cc69bfc46c900daa5685d502b1eae101282371d2058e5ddd526b84efff3f19fbd0c8f8667684a1b7b2ea8def5e57b6cd6be735c1ea66ec1a6ded0d6aecafe574cd7c8a0097e0a16d0300546326c6498372e384de1e300fd9604e26a2b73c84db537ea8130f0215210f6402f6f42574567686b6aad6214acc3de64ba06b4bf2c0b79fb890ce0a91f2159ca78cc6ec422a342d73e57b69902ad903fc0866022ed51f8ed88aa5e3ca6ded32253ef78af9ad8133ac0a27d83698418ad1645d73c2f84467078c9c0636fb7bc81b790286035a5d08b23ac7b8b5edf71592b2b3d978150806ef93e820f257d2401349580063f6321e36d6e03bf5c417d0470852a2b0e78c9cd1ffe36fd7312754001c7cde838e7e2982302af38fee7aa1c64b9098df903559cae12947947a3af088271d1cb6161a30dcf1f0eabddc9be0c34896f4074542748f8873877186ca76764ee52e08b0121ab2a31a3fdade3c8f7911ad0c027de767573959743d7628f3d90397a4a687d5ed554037c3076c0834a9e106eb5661f7bdd479269ffd1f8db14c5e1172cdf693ab9f5063ca2dfcbfe26a1d693382b0fcb3646b8561416812ac0efc41b7fc34d27a7eed532e5ddcd3f850f64de97fe93c34e665090d9116306d006796721c8b1f68ab56118777c72c773ac42d4ff3eea28da145936303853c12e3ccfeef44b568fe7a64cfa5bd4232012561a78e61d53d340c10978931488e8d1b045d5e65266c1f3e0f80637d20da2066f4e1d53c2b24a3533ca2fd33298662acb17014fb3e5637d479b335a61d2a87f06181f6e196d9943e880da406ab59d29918b08c545a91f6bf0f6404f72f61fd14d486533ca795a3f1451ca52230376f5cd99efe9a18bbbcc0822d647083c13ca9992a87d05c6fc12598a72b969a998a2a4f1b838d403d1fa25e09ab9b4a8911545925c6bcd80e9b1f61f5cedf279ed9cbe814967f0b84c37e9e0f0c00defada778dc61643c68b4f079493055090e33ad2b05feb5871fa6c3cf040d138d68065809d7dea8b6f3c0381c670eda5755c9f1cafe96c5387cda412b3fb0a754af3f91e23ce18aaefa4c4cc161e28c8cea2b110c70dbe724f186a8563e036b3b52273940db4715c1720ccc42134d24ad67fb5c4a500f22293da9cdb7c535e8eacf71a533fd7680220f5ea7f0a6d022d0315c31c1939a9f7a4c7d3237d9b133a2cf8c20845cd1f060c7789f2e56a61e53ed180a1f68fa2830e64aaddd6243328864a02dd80a25e6f0a86acc052a2c4bf72704ba04fdc9c0d86d63beb4e1ac613449a13f3e4b9be967caa0d8b65bb7435c3ac24624d09d31861a7979e787da95605683c734e5fd242d0abef1f2c57cc5c48826bd68e6c4ed5c4b2ef70e7efc2557ccc6bd88e16d90714064cb1af2e5afc340c367e0b5a5c12895ce8030647db2b0328226ebf925b4b17276191d3f2b5ecba77e0c58c51f51a8d94053e70f89b7f0d8aa68621d49ce81122be13bbea2bb7bb83720f0d4f91f7e1484499db198e7f22b09d082adaf987331b6a575c7f322af58f9e4cf5b1ae54ddf84491e44a3b8194e8f5ce78b6c9080b2421c7c3d03e1926a9514e191505250f3671121139f38dce226c4d5d74011c8d0242510ba93443c842eb5b3d4b128bb7ffd385a8ec30f82df72c0e0b3e9c7ab8e359554c7fd4f3379809b7fc78cfefd8ed357cf666beddf3926e1f65947e8b82e3c95e43e37aa821f84b1a2cfd2019168684a928eddbf81f13f15c895ccc6dd6a653c5801d72abda40560f9dba73e9c298ec72833c7f203ab5f8d28644f8afa07ed571c3bc775dfb4e6af87790d34d671677ed257cad2efb04bf2826b8878cf770c726ec8864026ffbeaf01b08f361d512bb0cd890988a900311c451246101f1731d460e359f421047b2f0a694899facd566ff2637d2af44344e09da5647c1180891c95b491d2d55a4109a0d008bc0da8902e5100b2468e405d1904cdce22edf50d65b245d0a488e076b9126857642b551d6b0b59692463fec0c68a49efe14221d0ed9873d8fb7283eb881fdc162adf73a452843cfd2e789592863958c7d9048357088546ca94fd0b481f74716408303d73aca6fe8e8d430db525bf012e91a93c3047f594612c0308582b5602b8f3855516a037bec5cd5b90ec16342d2c4343b17fdf8d79e593e2bfee48a56abc5e97088c1b7543df4e6ad2bd05b617b61bd18eda061a17b650533fef596bd687b83d3521b6f30e52e8016d9749b2b3017412a0f13cd5e85d5eeaa6490bf1062cb069284e233a95253036ca5050d6dd6f8e80cf21bc9760aca2e7b916409709ca73b19d9c3e54a998c001f1e1998f45c3fff586e7091d713cab70331e3ab70f1f35d34d8478379d6631ac04ccc90d5915a5cfd251e3a07e50f2d6d4deb71d2bb89c356904ac6e40c780bc265fd90be959213a3fc2925ebdd596d5a871552ff9bb7a6f02fd13d0df39eab55df0179748b6ace7b2a3e7fd558ff2bb43ca6e3109c04e17d893ca46a3c090103423c78d5cf360de0898454c08a81186e58c44741eaae368e3e612186fe5e2c72bde59ff37e1ae08a3f03dff88f33cb4855ed74807be8f30b4c76d1c60f6b91bf6bd12404dfdbcae5ef892efca888738d8496bb11633c4b8c9754789852a378232ac45cb543fda62b50fea80e4da57daa62f670cddeee65334f220a366f01f18a7aa496fea1bf6b61444e753536129115e6bda2450734ce4e8fdf4dc480c428e41dabd1ffa3cc60fcbd01a5bc4c0df899a0bd776c8038ce99e6823ef903a70b84518ff15187cf68be079aae0a4841cec260aeb2a4598f7f1760d27f7dd7d93b03547c59b4daac25b1539a3a0eb89da0b71806b2364e0776b10c12bcc54feb27046f8554309c718f9b4cacd2e54b2ac5ecdae0509cd98b8684b7e05bda949dbbd1744222a0388cce4ca72703e45b9204ef4e6253042227d3dc2b19a86cd8076f03864c3cf09988083b2196d3d202640d9a7ef066dad40c63331c1e4f6cc17236c051eea73c3e0d4da3a034a84a8f0cfdbc407ba02304cc994091247f6157f3f31901d5ae0575da479e647332a99358e61445c26ad2a4ed709bf88aea08e1af38533c67c85a8d851b8e85b1b24f2b1f9d0591894c793267adce1de3ba79d9e29f3c60abab42a90ee21ef66fda8ef0593b174e4c6ec4b229809bbd381e52a2d23c08e5c9d8df785eedd676c40a19c77e912632a18f6322ed1dc0f8051f90ed5cc26d4214e241ae240efdebd881964fb06546a3160af3e97564a30e10841f678c182a6de2a939aaa84458324ab860fa6d11e2f8f81a44c3f69b69f2c26cc3468c013bd2371a0366444fb0739ee6bfcc180971ea4c783b67a96c5786063ca079a415983ad79c48f78b740b4c43a10737969e3da23eb1d733f77df14e059ecc3ee7f352f37ed0185cbe46cc0333ffad076896285f5091affc855dd490476d6e8fe928c3ebe7e6218b35f15074827df16a82fbd352e824fa0800b955e1a7a65dcdca1d3f984a9b53a4336ffd35b263b248f207c5378d3ea8a95d79e4f4f0773954ba7187253684f7a80a158d49d5d751f1f2d08d5e3b10cddba488b39b819afb5610cf6f1997e5daf67956ddd7ab6331e3562617cb0e9f0b65475129e67e0257cdc07f45d9e47277c77387c9880fd543b51908f82aad1ec392758766421208b1e4b5c41fb27a8a7d84b9571a0a7d1fedd16d1ad07b0a7e503d4c5a9cc2ad91f8050c8825819f43f885a604954493653a45ccd38ffcd7b51b781457933e92d7e823bce1bd044f5fddf96cf987c9372d005bcc9317fd2b7dbec47eaf6268e8df2f9e9369ceb988f20ca54ff498b16653186087c0987df24cd3a7a108c0bb0b8ee320499242996fb1c5df9a6222df3811ba315fdf1dcee452327d0becd33529674c6e93efe72d5e435630f6b19f4c6478c1cd0fcabf927e4ca8c93959f4ddd475eb05fbb614e0536175e95f755583c45a7d679c2d891a050813faa4dc5dace50cc27cd437e6173be5ffa206c84a835f067dcbfccfa2dfc2dff2d42a84bd1a3c8e1eb3080774735253efc0d568b62e7141a03b37b4dc03237eca0263db8bcf69aa79dd309b14d5acd814b844bd59ae889b94ddf5a2e46d41f9b755722267a8f6d15055ef235277c28e96eddc47c9afaae25ab3b2d559c510740f6b48f181f8a0bd2f4351d5d2eaef58f51dbceca62040264784453b733b471efdbad3d94580f89f7ebb0f6f3b953a12ba4548401ca362c127c59089761cc1ed63d5a947b2c497663e0d43dc23cbe32a91ebac77e6b3caeb4b3220d968dd531692f14669f762ad1bbb1355676e8bcefe6bfe3b27b4729c58435d95e062f364ffbc4626683408cd04effb966c967fdf65ff15677be8129258c28468b5dc75b3e961d9b4f3580311a3194125aecc6b4bc2a3f1b86d5381f304474817c62e9b2e17da696c9e6b23c612382d410384854df830875ddeb49381e0c5f41512505bd1891c42371720b30ec4a438434538e86c5b3c348c6f9039527ac0e2c7bd358b6a69fe708fd4059beb31b9503a69cfb0890f60a353eccb9fc2499a7fbe4e604d573d3e22da20096fa0bd1f091012fa27b24555f43f3d8cbbb64c4397eb48e5b37dbd1d9cb664cbdb682ce33c87283b8c8758b9a28a036e6a8429bd62a6c583295f6464f5d924fe2f899e924bf485c908a9c2087ea4a2ada7b265247b47ca410e556af6a01a55200b54abd4b45edc08636255797054b923d67b0f93d160f825ab1cb52c5eb0fdfb634b3a0f34ede92a2e9570a1ac053867f2d6a52cedf492527143b6516e2825d7f5d5683c43d0a02d52241f5bc527019efbabab2425f215011b6dfb00ef541679fc9cf647388cbcbfc2d0965a4e6d4efb1a10ac29b78c986fd65efdea726fd43b7459b032f3987a19d5279cb771155a69d153e0336ca5605e77aa0e685bbd519a2b856464185ec2025226dbad6a3a0137554b3db970a4195317e79f2f0e4cba24959bc5499bb5f7e8e7c0dffd46a697a82f797587aed0d971c203c4aa8c6403a9ed6ad47b0ed1f20bb9b32a3eaf001d70d7eda3de339c4986ed1f634147b6312025a6a829144ae34e9a5b2c777589d92a74fd5dc93ed0397dc8c81abd90ffa506220f66c53d25d2f3da104d505f3c230c47962ebe5ff8ad11d4ca1e3c9537e6ee8e15699b226cb1aa067c5a175b9e29b154785dd086be06dfd428da84d9b63ddcc8f1913dbd3fa25f53fc45d8d38b442ecc9b4fb214bba932a7753dfc2d78fe9ecdc6b8651510fe526817ed7e4e1ddc6b22d9f1ef06968e2bc4949e321d26340344ce00acf5d833a444a97b5880848342f3227dacdea958be3b9bce0b586d455604136099aac4c99fa83040669ff20356ab57af11390cdf736260788dee36b263e22df77fd53d939b04381e4cbf31505cff655b03afb6e8aa97e028278e159902a68d77ca144bc993cc8213a32d532a08f3c64ecd9dd42ee73740869c1aa12fdf513c50c8ef31b5a732688c8b7bd1a0bfb81d6c52f6cf9ca047317df82249906f72e422fc410cd683471bd7b884bd80389f1724c2da7a33424525cd29979e53b64a5693a4ca9ba2065a4222a76afd833b6277c0357624b6c180f64edb125b6b7183baeb48b19c8717e0cfa68824ce7754a62a39fbc1bc23afa7da70d2dbf41132ec4e3b307a4813810d56c7c1a28c7b08a44de5c0ffad263180fafc7b8b368278eacfaebc0539544680bde8a9808d186015fc11b14c4a1831c2f299daee04d45ba97e005e5a6d492ef939928bb2ab25a6401a52ab7d98319efe0bcb651cccb2b43f99e19ea835533c43cbffbce338f703419655272cecf840ad043518e9d213036ffa891ec450a6faa2ffbab4f7c892750600142e5c99c31df4727d718a783db3b82294868a1074bb69a56dd3c52c302898bd349f638a6eebe7d822b7071cea5786bb9d3e89bd27428e8fed89209013df34416eb6d5046b1519257df0050d735939c191b4312ef5ee1894ae663864c6c52de65f7bc8f0f41a519aab935e12bbb1d283456705fd5a85f83ad548a641e8287bf10e654cecbd0a3daf14cccb6b3f385196ae0bf860f4dc4eb6a025bf8d47ab06cf654d0deeaead9cd9b5aa4497b6ea0ffa8615d7a07f9ea54f23988f16f5115984f3ccb0dede51206e55e9642db8ce58fd2c6175c4b12a3598f8f29f44044b49cb0d6cade1ec0e54e7b50baed9f19b8bcc35c0733ad7bfcf4a0482a619376bd514aadd32f7751ec8a2d5081cccd60501f16f114173aac317a14a227df0ea74e79a0ba78e0f84a5cdf3d45be2105fe92e59fc93e2e5ca36e471d2a1e4ed82f7ed688a7e91901477a08e5779e934369438e52ba515f9c4722e04e69066763d1bee384f8f7d848d1da77c85e987e69615950de3ecf94cce1641bdd792ca0cc94a5996a70b4ab83f760d9d91998bb850340a8bf4083bb29cb794cccfd09ecca5b9c51131e491cc45a855074afe83fdd5f75d06d9dc679ce6af93fe426fb692c0ddefc7f424430648ac22ce59c0f9bad57f05f1ad55a5c82aaf96742113602d05d2ae1beb0ebe58b93b71e07aabffb95295d05ff1d5614710071a5b5054706fe49aa798755a4eece69ce25b6a11888d2712df9bf381e9df926eb3d0e38c991ec6ffff85a8929090f91626882f674487b545695756ff048ff226ee922c57e1794c44c541704e65d33ecd759cfa86ad6b9680eadfd2885bd248ebc87af9ccb58dab7d552e5c5db09cd79fe20e85b56cd0c3e8277797b3ff2d5fa4a026f07ccc35cd75d38b03cdf8b0c7b2ecfddbca00b53f95c3d3cbc5b7a5632d9c1b9a7210858ffd368177a9463eeebbf2dd83cf09e61ebba250759226652d7b622fcb77a69ee7442521fc2501516d5d9e730bbad51c669e33900fbd44fece3ae4e2563fc989be6341eebc0f4bb17530f4c61f86b9f354a75076feb51cf7bac91939d4ecd683ed06d5a4c3d80c0a0c61017903d1eb20c6e3d0215c9f66563e416b6e9e345a1e9a46cbbb4e892c2d87a634c395709a81716e04812501949620e5d08b897d7958458327f67c2f9e1dcce44deabb9393a0464158bb1934a0888cde3707c9abc082e666ba4715ae5b07d1b8424a6ebad2c73c103cb2af878ecddad95e9d0fbaad29acc45a574683d3d8901b1a22612b02eaf7bafccbdcbcb4cf59162380992fc772ba8ad43f9db647e464b1df6de9d1b58d21ed6f5168ec1374a6083dd0011b8a1ff4927d748b1d9043c35696c7a09b04101558afd35fdf7afd2057a006b6753adffa4a720ca66ac65a2dd177f78eafe9e71760f470a6fd1b215e3b033812855b6742a8a65662c250e4ca9cc82c4bc6ce9da92fbba1c7335361b757935a43c75f9d14c432af63d425288509be3ee91e3140eb243a6e2df457a676b38da482095a04963827470d26f5c3dedf6405370934f400decb0e7743963dd6b88ab43bc9721fefe1169b009854d4ba320e8521d9aaa9408106040fc1902744acc4ad8095d8a6cfc27d6c75fff2bfde5af271db69356cf7e55e2d37aaaa7a557d2da6a0cf5f935741ad7a37555417b7cec5272e381e7ca938200669b86b5d164347b9eae2b63964790fb6b24bd333e3de0b9ea5708c92bc1ae6f95c0e90561bc13009ae4611060da5794a2f34bf9947d487af56f47b600a047177ba63374378e8525a7f358805cc371f2052424842698542b48d2a32c780a33bff8d797d6f274b135b03b65fb979a0d3fe77dcfb3c3314987b9d4f7351a29913462ab3f1d6cc634556487e86b071816e8c2fbda8f92701084ca5c94381e1aedf8ffc1c7ea0fe87ad3d9174a7a37b9819ec0bc3a0fb0a20eab6b961ed6a2f94633c2f383adecdeb521f3782639f61c10c4a9c4bd073e2420cc43958baf50e5c4560a0964e6ce1ec065e2f1163c414eb7f373b820aa812a9f028e3b5a6f953f916733ad5303619db9293d93450d70b091a93046966282cba31408861f2364e0ba1508ced4cda10a4db5ccbd4602b738414aeccd0fd577a6b0952900cf17b81d75909ec3baba7c818a218317ae2da37f110e629eaa2ea262bb3e461c41f4f0fff915c1051c53f6d53d402c298978d6320e5b3f6432bd286b440d66e2acad82ca8f19ab3cdcaa35de86f448a375b1356fc3d6aec4d8bf918d8ea94462850172c6ce231f452a9ac1d8b205f549195c1361a19c8571590b1e1e5cdead5fccf870fe100b1712061640febe67907a1fe6306c52d9b92651c473758cdcaa96f43bf623b817aa1d205ca76479374a41b77eb314434ab6e59c5e21420cbcaf96353c1eac37a0572346275806cafd6029f2e4e9846c119365ffd3b91cf7bd36638d388569fbc8838c3296665fda3639939821f63f33ad1d5ed162499be3cffb96a12faf1c52bb48f753cf3f14f97ab94a1787f2f711a17b342903a440136049ee6b294fab41db8999437f0aea34ec43a772f0fdc55495369c623980354723a7baa0debe2f6c4018207a366d61d84429ea40733504bac226e96fcbe297f961ff27642d32965abaf2b9658e6f580a2c16d550bddf18511afb604a3c4e73b8418a3a1766397824fd46cf738251aec6500cac6a5ad5e5006ee16cb4da5b282ebf67ed69f89599f31c7052b160db388300c780191c0d65f459d8f1cf67e7fa7a31d24df4fbe0be6251f595e6a08824074c39241e1ca262e336c7ee7b78dcac289b4b08b96b92cdd4d0b787cf68b36123bea0fd0d023c724e3db6a308b72992f326007ae9a0cec3f032973b1cdcdd11d693d09d89d5a7cd04073f0fb47266cc0187b45f5d4d5ca8a8754c379f021be0b5efae35532ed30942a70824607d583b95337d8568d7ca91647ec3fe414de3233621685b711569e406faa64922ec4892d1fbeeb3ca703d3466c72fd73ba5545800d98c4e5c4242d99cdb173ad51f1148287a7fab6873614f4af71b8f18604e07810110626f7fa0f665154b09fc6efcfc83f112400fc05cdc9d323bfc39737109c7946c1122f72717b7866d494337604c9f8b965cc190854e370fbed85dddcc0a7f5a091242dfc7ebe2043478d688754460c64bc466eacf311defe6a0fa8cf503b5b7f0e35e97486cecdacc045a656bf15bda3e2c58ecb4f88f0aa61e7b25b622d064bbe91bd6359c9114f95f76b29f2a47d438a2c365954291cc122240250699081d13b837ebea6bd334a0883ccb1468c5433a793ba8c9f57b7b417c032e67d4ce6ffa09f72612e7c0c75b740437f84ea32d6cd050294bc023245ced2ea00b60e044aa998491e716afa6a746281d00369784dfd0dd96ad9057b63ff8a90647717d1fec4697fb54fcee03a1408992ec1370550fb7a708f2d1b102fe5089b2e27fa6680e79420dd2be98235d0dc696a303ab172a74cd3f8ab66c99fa11ddf9d89801c4faf645747bb0bb6d9e6861312f19bd29a6df7f2cc5d6ea12112c26f159fde85c07e633320206561cdafb71d1614156756c59f704837ee23727ddb2b5f6b1ce10b499b4c40488a710b0aa2c094a3cdeb5e5fbcb3a3abf5f3a48cf8b00d9e2fc111aa1d66c9c5056efa3be9951bf6f60af2b9ba3a494aeb0503d0dae39820268450abf5dacd40bfdca815dcc37b9bd0ec93df5bf578ca693468ca3990229809999e648b66eb423d46b6d5424c89b46c934b4fa3efeab01a647a051c6a5d7701ad0afb044a2bc91e83e80b1dafea2efc8bee1d9cd626ef61b845f7b6feeed1ab3dfca21f74662ec47d30031c4caaf390d1cd1c83608f786df59744609a6fa46ada239521c5a7a8ebbe0b71e1970bdf909d9e7ced4ea5c01cdcee4b522ac336fddbc2e438c0f4ee15d7cc1daa619a8813b67ecd72b788b5584b43012c84db2a17de684c92277f56fed00655b4afeabe1b174c87edba8fd4fc62a3b31ec75252abe9705e90088ce3cb4b4ab48f403782c95627c91bf90d16ab078a616508ac7abb5f017135e8d2d5aea01b8dfed3a62dc029fcd4b4370ffd5703e70781ead59db299431a767bd99a99b1f35e6303fd5e5512618a4bfdd232043cc818200ae0a4ed3b015c75c7771fc777161741605b9bac6bee236e73815e4cedcd2ef5f0b527b6894ede96d9dfbec2e1b4e16fdc3b99765faf71466e668742f04ba4c2b81a70a281b3a07ded476e53ed173b29e0f05d40303fa48efaac7a2ee45a08165911faf156cb9e6f0c3a21f2f6acc01b555620a85d7f228b7827423a6c4169ce13be1a52f87206ae9657d1f07ba3435ede0de42d74fffb1206018b0c64b031944f532948f13915405b60094b9cef15f4126609cce47c790768e038a6bfce8c5d87a628eb5ee2d7c1ef9f2d5092604d6df705cf809497a47f087a40fae56d2d7e0e9c14e47e0a5d71ac9173194a7bd70f1ae59513031da63f8195b4a4091586f876697b8d5355c71319eedc62b8736f8ffb113368261e6e27f3d8e1558509b5f85dd8095666ff6abe0d6f138f216fe8248771d6056743f9f64692c8350c023e41d310a021296f36ddeffbd43de07fcf71885146b48584e9c0b5bbff5bde245ebff544ebae4214a4a471887b933654eca6df074dff18a73ada2c247a50329d10254714fec346f145d8d14c2a9a2dc8a53b7acd84f96af7469dbca79c4a7d3939f740923230ad2212029d92c86548893073de72530631473ed19e8cccd8a0ee54ad05cd7a2baadf06b0c8a49963d623eec3e2e3add0dcdc3e9b8f58eac36b70167c8a0c22cdf527e6e1006d29c1594ec58f818d1d0c7fe00c6c066b369639e5452308c60f55c4bc034447f465100838bf22dfce50ecbca1ad29c7df5ee4660c0c603933ff5f8fe49ef81e39190d37b45103732d5e87ca253aa2fae774d2eade15f6d354d09ad3d93ca56acc5740fe36c8dd48195f48982ed445dc142b5aff0e8d4379a3ef567ec3aace45c089a087df30bcc4c8211cc67916819872b58ba7aab769e5e5c5f3d9338043f9b6a7effa4472b663238244cf62cd84d7f52136e1aecd8e8276fc47bd38e8c34555ae0ce9a5eb644230506ca9a3025a3ec603a5fc7e039fb97ac4117df80e3e68153c8e02a6664c9ca835753dcf4d7d561e19566ec61e2b30e7708e09a5f8ca5ceeff84e8848fc82fc76626b84cf61ce51962d47da7f50b03998617a075ccab91f4265dce16eb3d0ea3321effaf78e9bde8553146463edc926acff18722b0e03063229bd0428007e9abf26895fa444efc148963c4844ad7f5f856ff7c75826d568d1c5c98521aee3d643511f5d5fb9f86358db0fd01eff8ad32ae91bea9031d6560be62e1e2e6237c83d966ac198802ef6a50d8673a7edc6e4ee9e469bf8e168183468b13eaf17c8a73ce1484002c87e7eb5b4d636b8c8e51740bf0c4285ad5c656bd73778d6091c8bc1be659edffc82d3b8ec23c87d41fac88e6bba900105f82eaa1ba6e37532f0fbbbffa153a51243f37183366605e2ceb5607e1bc4906c9bb2a3f10864d8844210e25bece5f07d0b4bcf2b72f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
