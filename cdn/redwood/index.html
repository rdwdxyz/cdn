<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0af480dac7111a4483e2c5dd9db36604bcff982d1e042dfc66e168f2ffef8fc6071c5e9a41587b97726caf786130b7d0778c2a8e848e28900ee79492a5fe23e90a306d7c21fa1090212fe360818f7f73314fcc02109a1cd92f447eb37db8196996b8353a0efbd643135927198b7a9a0c198a38d95fc2d1bca038b999452346e2c19a7b32f90d5c474c9bde6ff0652f54747873119fc9af96976755983d468e65ba4a619e54957668efa724703cddb42bceeb7173a48cbf13dc7d4715777f287e1a509adcebb314f874c32460ed180b3e1ac93ef29c4e316433e15c8374b64c9b97add94d3f7d6b548701b959964b413f589bfd1cabcb94079b153002becacb7b1f58daf99c5dceee15538e265a6331b5921ecf1831cd2774108e478aff4f4d7d0eb988ce2de57b1546862a4938565e62cd9670a2948b20e6d6378c74f90c55494c698c1c4a07706f43b024e8fcee0fd2d6736527b08ac13ca258e2da92ff85822964d07c85015b0cbe739ece81a404ee9bc52cb71c7605bd75cd74ae4a962322ed1072d3d6687ebe241a212411b66dde7eac4f687fd54fbb322d21e53becdebbeb0fe2cdce1b4371039b1dd9d8fb33a9e33ec40a9e854db9f2862fefa42fb295e5969a10dd0ffc2a11e17b454086977913f5c32040fe34a229062d9a52782dc510a2df946b60b579e1d7bdd6a36759718d07b295873d1fd8bf7fea168f6520e0454db6fdd27e2ffe3b9c308dcad57948f603dbfc4e9f65ffd82b7b82b51f97ac5fb8b0227cdcb511940010a7afa466d38ba42083a8147752f17263369ed6b51dd379ef693c6954ccb6b13ed3611e2e10eeded5e3a9beb171b35cd5f9d2c0341fc3e6ec1b2fd8e29fa3b6280395690c1f1f38594eee68655ae944594251a98b1a172ed29b0f61fab95ab4a1e67b021340376ec9158fc9f1c64f41ab81e44e5c9303ff6f87c104895b6e98e391a35274b5cde1279375c93c99b662f85343e8f9954657e2a11c560f73b68ae1c46d207e429c4447c2fdef27f583cfffbebbc615e4f1a245a3ad646158ac7d34524503331c5774199f52d7f8e3e5b2d7bcf614408cddf08287ef018491b200c10d5f4921acb8da8e382ffe52394d5eb0b8c0964fb0b3054912dd4a9bf8a3f25af7a5819e621ef7a79475a30e21bf31f638d17f6334db6016ec58c13221e192f159474630239c74478b5d4cbbce38fde4d4c236096639b44a0ecfba9dba83249c574ad3e9db4c2e01ab5462c7a8321658145403ccb7e1e03b4e9e4306ff1487a04011396e47097140033959d4d2e71538c036a25ae923631d8c5f8b01c6b37e2c6c0af1da2e9d2b71ca95f6d4b928389a2a73d77aaabd74960d405186b7befff67373346ed8f9ff6e08199868b712716bfeb5c924486737ff6bad750ae790e56ae7cc894a6cce14e61d7a1a36a4e473423d50aa938facbcc4b1b86bbcbf951e1e681e774040a37afeb1bde7b5eb38bee0b8edd1c3576600853edb57ec54a04b9e3459671d7ece1a0e958787ad69837092a493156967ab85111ba7c31bad69c01d7492e6f06412984918a4968b9e8ee699d8f5ec55cae0d6dd1c49a3ebf0b6a65057eac9bda4bdf8ccd3c6ae022a620fea12f64d58327d61eab9623e84506cb79857aa99c53718d29a2c3a0bf60dfba964f3f1b00602dd9ec5dcb4f228f08057503267a9b71544451e1ea80ecc2daa8bb1382e9cf9efc939d6410c7a5f38ce27ffdfe8ec8e6c20347faa59d2c69243ce26e0133d29bafd80df50fd2436f2c1b747306cab750d67b822f3a3ecf24db1381117c75eedd467c5134fc9e331fea406030fd0dc44167449a75b380199b4b454f3592e59e441dc492550aafb7eb68c1c5e4eb6133bbc82e0e3e16ec0b39841249535275e6f62447be352d3e62297933ce272823c4c858d8146bc5ef7233c576f8c98ad95dcfa67d9b2f28c2295b68e766196404a99d498aa7c524a704e4bdb438a1929759adad08c5ef9f9ccf9cf3fb00c33fda23514b15a09bee93795b8bbbd4a99e8752579dcf144eb711dcc7236024476bbce3fd2795e99123df367e3dde3cc0b5aba67984c0ba9730560714787d586ccddefd85797fcd1e60df45e9b95064b00e48941757cf3c47a7552a30650ed4237f99621a3e420894986af311fef1318417f4962f99b2ac4e4ec5dac2faa326d6452eaff813129c5111dbfb6b97968a55fcedac96042077ff1c2e2c4c12b3557f4f14998c6ea553450b3dcff900b055b226b62558610c43077908081d919990be6426374305de4613fe27e7aa1549e47a61dee66ecf1e2ab2d6a66ca5d275fe30314a3367e86cdde402484da79796d13faacc9950f6f61431e9aaa68377d324dc0ea6166283f8d24953ed9a6a8003f23d099bb39251f50eed113878c50898f1d752f2a898b06256fe23940043fb4b59f547bd4cf2caea53f6090aada9ddead526ea6475e5ccebf81052977100371e4307fb4bf7412ca74b00dca17c509abb779a3eccc98499e60146c634bdb116935e5698303a9a7c431179dfc3817c8f3c57709a46de38e604d2dbaa7a266dec530ebec1b3df278c23e17e2f89cf224fd956414f0dd00e477cb9ccc4ca311ec298cbf652577b3b92bf73b0d39893a3fc3f7d2340dc949b6c8f7106fdd71c81ef7cd16365d655fd067691b29fd8f2b00fe4aec9f74c3805ce674279d925f569a08da43338e35584f8c726e82cffa964092e5a4aadd299feed8d3656e2b495cd354f83135a4d4e852c2e7fd02fadcfcd5b04a22458b073ba6171457f3f239bcafa9ea63d9565509beecd0eb92f6f2e6df9ecc560a6e63f7837efaee72363bbc6dae739893cc580445f72fbceebc1430cbf2b638616aba6ef4032be445ca665aa49d0d22ae0fc55f5278557013032fc7ad25715c6ca4c19cb5fe335866a35ce05e5d190c2671cc8555e8da5fb85c624a002946fc4733b838818fedb49d741a8871b885dd60dc541463ff89149c1b2b7b82386156905a94cf04059bc71d9d09dfc36b19799f729782cf6504e670eecdae3f7122aa0b3aa82df398c38c8544845ae21d3b0dd6cad09f057b7106f53645dbc9f28e4ea7c6ae722d6d00a4e71584afc88f6e08ed5481dc1c679d4bcae8c0eb8184e7c639beb1444077de61e844f1eab8f8b4001b8ff9e2b138ac0fc298d73298e7607db0b2b511b637766abeb821994cf9dd48a63ea7126ad61c40a9428915a92984147fbf50f2876866fa19853ff81aae1b32f16005c6e7f382114c1def49a287ae9a1f2f601271b4958e18ab1b50b0ebbeaffbf52f18d4de4e50a8049ccb3e019e5907e93aff990e144a67eb4d0cf08604bd83bd022ec04782b00a7d3e0f7c90e1c95508ad1916f4c5e43543df027f53a5409bdf7e8cbfa82de0b4328e5eeb127f3321605d48a3bcb1330388cd3496952271c3841a8067741bc96d5451c4c3aa8d3e5b781811b17231295c3a7d27a896c5126bd993eba66b560f7a2d4b5a9f3538a3fc73ce1716a506ae3c4be0eea0b60b7231a08b4d13f3ae02381349fbcc3615f178c4bdb3bbf2916ceca955f23343482fbc0254e6b3f3fa1b383f0921e6662763d5663a66a79521622c15664d373b33f06d97b2255b0c8dc0f8bd6f4d42f6eac7e2e8b30159f292ba39d9b2b6c5f6e27bfb654a5351cdabdf4fd36f8fbaa5e13ea90c11390da4d5f5e583e5416f43bee1d498536a30bd4357518a6cb71c52f18015c505e3c98dd47b0a24ebadc6a9f08a549b6dc1e8f9bd64ce401360ef7c294eb58e488af7bc412f043b285eed02969f81d930ac85685d91dbabe0057637d87139cb63ab0031a2cdb16cc1c7d3c6d4153e1205807ac9b2e24556b02a0f26da974252a592a6f50392b63ae6a86fb0e8837b724747a3b4c2335895c3349f0985ed8053e0b74bec94714e21de42ac8c29939329d1486ec3f6d57421a20b8d2051a1c8e3a4edc9018945b8c87ef7f775d69fa2406a699c011ae5fc5fb9c9d0cbb85cf5a95f1fcc63bebf0629fcc1e5716eccfb59fa5fc4f769a083bbfb7d5e0e4be6dc10f3125825e3b60eea35d6f776cc51595744984e1688f3c4a7d99fc82843f75ddee6b044c5279c15f499a24d86a878fb444ec98ef4e7b4f35acd10d3a2bbc5b21f774c8a70e690e8bc9b462b9555e358ddcfd5ce43a086c9763ef3c7bbcea19f3ee04d367f25a2d1c10f55b70bf58bb6c72cfc3d54d15d6b6ce46709a28c9a3114bac814f2579dc08dff2eec1fea8158b0de27dcd1f422847ee6ee206e06aa000a99b5d14326406053a008966ad85400e8cf617fdcb8402acc6a82993f0492dd3eba3c9d623f885fcd36bdf620607b06709d2c3a1cc9f2b055a62f9375410ff19f7d2a738a7cc66b370c3e5d39d00f5ed1347080cff0ec551443f9728db56761db0d806c9ebc91270c55e9f52d9bb549619d35f906c77d9ac5bc2c028d90bf2b2790da08cd029c1bcc7042fd76ef48537515c5c315114d63ee0e17026513c2fb9943fa64451a4318a4076c2973372abeda016a2f0a196019eab9e0977dfc0cee51c04afc161bea4980724e48f3a6b2a54b43664b0a0c15afb1e15971d46ddf31a4253e900e505f045203cfc34c8c6c53d62705d263cdecd34f44f1b022e6981ad5e0ac37d0a0476bb005eadd7f468c56b878065ff8bb7d5594217cd6590a76aad0495778105ffdaf22a1e045db6a95076d1a707f4f2741df6f53b233c568eaf214262dcf8a9c47633bd303217a3062b0d252976bb838642ee8796a3969e1dfe30fe8c0fecfbb66495b96ff9d1c26a70db896ee6a0beba21611933cffedce4b8639294915a0a8fa60a5b5cfc76f16107bca09d4d48d0427bd967e114101ef36f513a3f4441692a9112ea1533d9bd0a1078f4e0cc75196babb622044bac4c15ba041eae7065846b9ca5860ca66de4c44a9aba9794c4c23e09fa15ab2a6728e3a66af04364d48aa05199024144fddfd96656d43a6cdb1d0cfba766f6dd0289eafea099fe518a1960ccf6a296462b03c6a74d1cc8b667ff1d400f27d31663bc69a7210af065a88490be53951ceca982ec9f4ee29a9e79c90e8cd3980fbd59b66ae9ec22d92b4c633cc506d9f36db0391c4077f9541ec78fd9ce906d9b0048d7fd25fa2ed6d40cd2f3eedb5fb86523ac1a4705ba9611f8100bd103fcecb61fd254c45cff1bee6fbc127c342eb8a0265f7c7b9c6220e8cec01c78fe1ae52197b61a108810492e9efdfb5d14d6bb0431e2fb3dc29c8cdbba9e2339dfaaeaa9a17f2fcc51dd01247da3b58b25896b1538e7e61204ffc75f1ca2764e35d6669f764cca9ce27702595603166910a9e322be03b200d2511763ee8a61cc12e0df937f8c0ce5f33a3dc992cae40e9b2e7b2610b600d5cf80552437139e0ba4660c26d8bc0228112f1ac259971cbe283542409656ea7570c2ce18be7b5f8e2893ea4b7b4c2a33fb6ceb8d79a4d85f7ba4e2f48f4eb0349d9f1195842336cf55bb65683b892ebd95f9d00724b09bb47bda768f1be6f8d31f732df3aad2aacf789f7b9a3e871918858a7cc6bc225808c21808aa952d91d2cb03c8f4d2b58d01d034bc9f3251f67aeff48631b1cffec419ab61016cfd8a64a783ea271099f2b09cc7337d45c62fdb3ee28434443cea9b169806cd97a7228938b202454be0a986ca3c1de22d2f843b26002803ec2d0932bd90250d49ba8b612f22fbaa45bd56804f5e1bc3aa6959bcd359967ed59e5d12515600cb51e1f8625531f0406918f5b4052911513a360a9579ac4c573e9215659fe23ab3340c217d2dfc3ba39559c65e51b08b7f42c47b941f55a2bd18eceddc5d1266ab588c016adbf11addf0fda32c888d2bbe561330f0f06619911d6e320f4965ee5db436874c439085d069774acf614f16f98d575c8bdc01f1e0f3a08e8fc8ea97e433a7b8a0219c271a35394e8748bc2b8fa8eb4a5d183d9d63816e46ee99f042e0f1bd274ccb409957bb2f98af7f83265b10ad0b31032900cba39acfc3c55e96d16330ef8f0f1dacc0fb426c9c1950bf7d458dfe04d28bdda177d4615908172581fd47a3b4095e732eb361d083df0b7d6d0b6cf280829144efbb25562e1005a76eb02f1674fa642ec2922098e47116712e3e1514fdfc73bfab4d302b10542cec94d5716cced47795b7d055c86df79239329b8e8da6ada4e1457587b95536f8e2bc771f4900fd5fede5f8cf00681e82fc2a85747d7dcbc5ba8ecaf88ffa54e1128e05ed86a4e1c7ca54c3e26e071077002764461348d0856eec6b7f480bb3ae3325d3a2e9086b95a34a025320660b909dbdd7adb52c8a9ba55a61836c15ae5563d33d0400155eb2db6e1f7980a7647ceb30d5335fce00dfe812cb0271a7d8cc58eb24da250d964bd96f6f8a8d5ccb8fcf7738126f8e88cfbd464de680aeca177186d356188815311d44c21ec36cfe26698e08eef74547d172006414f9a26f07a21a6cdeb23a9c53a692428f152b8fa13a8f3fbab12eb08a7380a4df0d344b243431eced8187d6f18275e48e685dc7f0f85c82ac35e7939586f6f50d5300ed20009f53eb74b5c56691a1ce144df33c2df0ab09af16096409ff1632234ab3521930f45fd429d5eebb13b420a8f4ce99bc1e5d1b7b308396a61114d45bbe7322039c4766d2f1ed6fffa64496683c34a002a588589dae5735b7bb8d9e102f4f69d09afa19cc347726af36dbb3115faa34458f9899248e78dbda10fc11de5e396861004f6e21ff77b31638f7e2e3ffefa7c361809734676a988baf02a1a2db552e8c2693ec5b3ecad6a200a0bcfb7dc9fdbc21f4bdccf5dc47fed976ae1c76ec4726656a25d3fe2e836e852a8871c0b75fc39a25c87d4e1faffca205c500e9ea89683b3c76219e3f9a1aefa4582194649646a563f58107775aea9bb7dfbd894337277102232c74bd18ebd132bb91c966941b66b333add0db21b5d5dbcc539927980591a3857cb7f00d22776a660c0e4d9a8a4fe5aa81f48869d481771011e1204929ac835062eed806ba53b49d14685583b93f4d568cbddedd4233e17e3a403944f45bd7d6b367423fa79709fe2c88195e538e51f55e5a4fd927c29901ed365e758c27fe9e0d15ad8ef6a45ef98e4fa1971005006d6d5296c8fe115512ab68f5c9683d35b83b112b92b4b8fca6e262b8f53df5752fdb0fd50f613d3c42f2ffcc90869024d5301632c0f9bcab70589b9d0cefad96c0f2743460320fa846f72b6ea1ea17cb49f4815b6b2cdaf3ce3f7070f4bfee47d311278ee04d709ad8d670cee440dc0553749d9430e2c5b620aeca4d56ba4c7aaafaa395c2efabe3119ada6a649cb5c86211f013ac6e47d54ec3af90e4ddaa2c8b5e1ef71e20861d734ef9321e269e43ba1119f226d46543c75afb1102ad99ff6319a933a9eef0fe75a4d0047ec6508e333f5b656be5289677988746e4747571949b982193695ea7b8791e087b65aa88d2e68777bfebc4e496f17ac3e706b748dd7895f554cb9d2315ab21afa7522a4d87537f696865f0a156d4129f197305a315412906dd53640266787d16324c632b80922db78b8b9c6a073515d4d7db0b2fc29d66f36c8b72704ce21ac15525ab082d1aa33f71d18905916cc4c30ef46b4af0247502420425bd4cf8694e560e9f5b5ba041ddc31f4ab2b8b497969e9bdf6068531370ddc7692c4e348007ecb3c9c21819aaae24d9a1899fbc57bd5e21b1039af06c76aadd507250592f62471582c418f052384e2a5d512c1b57d53521add8db766039414825bfb7d66c58bda8b429c433a7437fba2e80f0ce7972ccdbdc29481305916ecd48d4b9c93f7bb2af665a572618202bbc743badb3f8fe1541b7cdc0e79712f3eed8d211a2f2ab91d449cfa5bc9ad52c0050256086ec401b358e76ce1ee18c1c381df67153a024176b3803f8e7c809a401f39265de25a826389799062cc1ddad20a42a6d6adf6e77b8a179deb5ceb87b0a6bdbdc01bd4d6f3dc3975f0d2678ba318c01eb3aad377084a4f21de168cdcb8d72f201355d6d3e4b1fecd2742e84b84d1d57b503138d6ed71853f8414ae2d8d0f7bf11be54a51db51957934f82177159a28439bf6b1e8986cc655e37f2e0fc28f022437294c195163bcb4dd310066be1161aebd03d5db7590e92629ceb07f59d9096c32a83e9ebdc9e75f716fca40472235dc0dba03c2e9875c16e8f5c75e3b7e81399af3c8e78dd2935a22a5266e4429a76968b0e0a68e344773e210532f10f9ce526cdfa04a07936acc40df3b310c670c1504d4a800fc5a84242c4f90e7428dd5cffc78071aa7ad7191fad93410922a2e2221eab1cd10fc6dd2978c871a7c48e520805779620c4e8933aedf512bbc064e50d72fecb10750876b167f6aeb8f09d900cf33b38edd567401d2d6d220ba52fe3215b42085ffc22727e2528d1f4bfcb6cbe625af835616d9cd1b9f05bfc4abc53a8ea74166a149c85c4a435e0b97506c611da6b07ef697b3c64537a893afe7297ad0780941b690017aa73e54be082e8030c7d51c1dfd3b9870d61cf3f88674e5deb1e6b869c97d2f1e89aa121e3078749c08939e0244dceb205db969f2d4ae924d9c1a95440661daf15b20eb545e3960f506af8120c56b3da9ad4ae84b3260fd8c23912d690aa48d4d9e57865f7f336241396822895f3ca469827cd08e71d9b5510ea0e980562f816d216f4bec4aa4783555c3ecff1b73e9615cce98ae8ab805349876373fa4fef1d5f30eb2cc1c9cd55660d7c04478dc0ca3b06b99d5afaf5d6fd08110b194cef4f7ce6e53f4a101aafc7af1c643043dfcda351361026a4778f9f57f1bce57d339add8b558f4f9ff3f68fe720dcb32861ffcab7a265422e8f8da07aadd034ede6c8fff3a0f4bdc6f7a070906f3c6d75ef1f0ffec93ed3dae3e026d405f94460b745321cb952fa9685ff10b2a0ab9fc8fd79878e35bc7cded05f998bc66fdf8da9ced1d29f10d14802e41db54310a5c462db32ba7c25e30f52c52e69736f6aae697ec21aa254c9975b75b9e6f1ac839fd7cabbfbde27386b2a10b37922c4f8b4c9bbe23ab1344898872539830fc2e76ba27c49331df06e974000ff1205725a0e9b729687e5c6bee2d2257bfcedd3938076a2294cb2cde079fbec4507600d87e6ecd1f9bec522684873269729ef433f6204c88308b89878f4760ae85498acb607af9136f59f47fb796e005c52110e9932a201cfe2a73963da416e57f5f08124cd0403dccae5ee039858dc6c616a287ac01327db7e588ab7ed859934660975a3c3e07f0e237fa4a863987b4f10522e311451044dbe22cc9e232507ab6a746ca110ba34bdcc7d24cf27ed22e0c7030638c8b762f9e7b547128b2211b5ba9ce56dab54cccc8b5d5667b2247c7c4c85a86d1acdde8eb63ad2a4c21a9f068b664884c29fe403db283f601079a75a1525b28b1d5ed4afc3923f64e2594d031a9c73b844b670bedb36b9da8b928fe465bf3844422926210e158bb29db18d31c06d9b7e915255cbf16c5f6fd7621d44d6220c3e996393d9e1d4a2e71e9eef27767ed3022df44793828bd864017afc8a0f0e380480589e16fc96ddc0f0ac38acce126e628e06d122dd4584e3b69ca05f8e22a564dd613e72632f6b9cd623621912c6ff83bd1ed08978500cfcb1f5e99bbf8d5373b686cc98e6e4fde554a5f52609db9efe6a52b88f2d798d49ee32ed79fc095d1bc4af43aaeb03c48239b570ebbe1d04c2921b7dfcc6601d310e345ece3bc43f347f45c971525bfcd81919e3fae42f9e590067e721f519632436ab252c36352529339109b0feb37145c36f26b8de58f4978367b384b0ef47a9d97fb13f40a772ef4a7886208c8d944e217ccb50a0cf45aea28d4fcdc44f9680d50f2ab9f118717f3045c5920415db5ad6367a47d22130427d0e733732a9f97497297a9934fe32d44ad438915cec86eb41961f1ed5284f42e04ada7cbb61f260a908584cc9353e9bd54cb908de52a7c20ecfcfec12f940b298f11ca66678b6ee7c189f87c57b31ed6876ef4a2df8d00509d5529d4ac5138285a7310a926edfba52cb41083a7a7242b0e7194dac8d825669d94278925d4064bb4a0ead1d275e6b6f1b8128280e59a54e35dc1c704d6be146cc328f2cb4cccf1612e63308962bc9a69661ed24895dfe1a6fd1f7baf3c15b8d534688609907d0b240d8c2e3f010ffa7e2d59f94870d7f465502aff1b97ab1dc7f3b395b9f913dee399e1803d563c8041c071533fe38f50515b3f4e7b36961932292ae991751bd4f13473a2272b7a478379c702a56062d2240f2af99932e9c1a977cd55de43deceebbc16387195109e9a506b2dbd3675e7c6dc88e0272da76ca6bb8b1b148710b7a42f2f4f2a6907735e25313d18935f11c02b0de4d134e82714321020a578c2643109f0042f3f11ad9bc4590fe2501c9e1de8a42c007a6adadbcec21d5ae3cc4b6c0d3466bbb04fc8eb82fc089edf2bacdde57ac44f293664db31e4dde09aeb76c956500884f9b80ee8831428ba1b4bc9c035d06a106ada9a1fa5a322abc8d78eb4ceac58b708e7b8b54f980ed5deadda82ced64d1b442758b33fe635732c23039dfe4df349a27bf8a530f1c0eee5458a067463b893476873ec84dac6ef55f8eef4d7bffe56c2adaa88b04edab0e37d4e6449726d22af65f8bbafe2cac0b45eb15bf7cd54a95e7db428eb0ab18da7f9b4835aac14253caa5f19d5a0f8f7f595799fa8a4cd06c8c27aed4d6184891d1b25726d73acdbfea56c0bbce6b4c1ce209dd6aa744ac8513819a58a5983b79ac57944b9595b9483a41d39971c49ea56781750180a2af3801904e7aa15960a9989a56f9a3d149b026c3d52afb6fa09ee9445a2c141bcc8708288f20cdcbd7881236a08299e857d0017f89a7d72db6c95139d87ef7719e44470023a52b69c8f0814cd5480bb089cfd6db59bdb5f86f45942014a6e241a58d19a77925d0949a19cbf431912556e13b11d60ed8dd7ee91bcae3536208dfa90e1e532e10fbe055b118610257952b6c2494f41f7474306152610e38a3645b2840c1f94b0aca2902337e54570f66a4e206a4547f035b7f171f70b990708ed94cead30abb37e5fce7eccded56d08a1f55c5f1f4034453cf7c7ba5b298c0b4118fa14122d1901981dcfded837e3ad4a819d5db068b7a07aa4404abb1ce47d9c13a705e6e10f933fb742399ead45d1fa392f721dd8a7fdf4a912d5a5c2336cf152fad81272ca5f9ebbc37fa3253a21a14ba023210ffc35a33fee8a86fc2a28120c4f4a0e9b4e92ed520fa9bc11dfe6a40888833961bcaca1bd50bcbcb7ad6dd48797993077e6f087ece0860f8268178a71c500c3b175a49617493a82358ff02774d142e18a5098a5769ae1b6ce31e73fe2ebc6747f3ee1bc5e8979316bc2da2f5e96898a0b92a63db1e6dd63749a81e27ba7b5e4db0dcee169e90882444c28359042b50f8b74b1e1a77cfff6c3e132e1513331e23e9717fe7a0f01c64b8e5521676a5f69f82a1e169bd67cb66cbf52add85442b5153376c5e42d71a923a02cb3588b2bd930172d00441e14d1c733be4eaaa9b13f2f1143683e038312f36954982eb8dfc03900a82cfb202a86bf2953fe3619e257d04587464df98e25cf419e97b886852f76404e4a6ba98d6300a453683e8bc2bb90138fc21df1ace36101c09d3e72432114e528fe4d787bf1d9a2a01ef8a15ccabfe13b79253fa4dba9ee0c4320c7455725b726a5af108592cf67d5a752cf09bd4c626562fc05e84b891086fd7e0db394fb690d538a728cf4d62d70927001d06d192535b905646795150f54b541fcecdd043dc4f12c09bca47ad633516a2b10bde7532ec26637f2511f7a5b31400dc67afdb97c4d6feda3e14e9ec437790d7a2bfa26fce32860425d1983437220613d458612a23b7e4ddb9830e32eaf7dd97af146ac79464a79ddf7b2612239abfd02845d00af4a90042b9065cb39c8f78c1812e48e266d7dbf774d2c02beb83f3ea06e8cc4474ab67ef5bac02708d5b58b627eed2e278f5205ccbb819727f56ad664d9bdbd676f53051b751dd5cf1ab2f048a13672a6622821095eba8c84c8cd7679cf66c34017fba6dc11a00ff76ba621edf751fc4e3629089f6b7fc30142cadd5c4fa85af2619843c9399f7c735b56a5e56e5c4eefa56721893bc297b40f3e4900595f897c9ecfbe2b7a6c8e3c6708fb5fe107c151a6dd51dc7d6243b04ae110112364d92228e2cc8a3014fe79bb571270d0c729e485dde56fe92910c1408b17e40978debdae54dfd8b4738356921248c3afdb23783fb01ace3b00b5a81df5e406f09bc5b81a1040ad4b36b8e34be69ca7888818ee3cdb2e9942d5d42e0ad559c8505d45cf7021554af465ee6c473eb1a019240382cbc8fdaf4d6d083c92aa826e643919ea8b09174ef3021d95d87b44cf1fbf009d2ae8f024b6f54fb0ae508e6b80e488bc9681039b04eb5972b8e8f100c1b110fd5985197b94604f01e73e8febb90cab14cbec0e4b8f35d478b2705d3d21e8a52672c25cdf86bc7ebf69fd87b43b56c38188c8eb18a6a6af9e1624620e13fe77e274b5ece35619a448cb2960e84e03f82c2b4d00bcb5749cea7c14c2a6e03c6c717fcfe7edf3661b5eb1acbf367d3401e37c2191ec978320daa83ee827e00c11d65e37f32704d0b6deaa25dfa7551590a6d99d2bf453a57d337657f0ba1f53ce3f9fbbabfe3fa72151a9fa4c9f1b20892ced296149b2a3b5efbc7576e062f5991476741c0e0d4ab7a567ca1c20f0bb6ad596de77717e860108791b122cec97e9e627ec681b07cd18d840860980ad00da80db7cfae6e4c8c7fbd8349979c2253c64e195be05ebc9afbb3a15c1f6d5d79014a8709fd4579a00e0711b0cd9bc0aef97feca87702d8bf7837b8eec28927236298bc0c2af17cf945380a757fa4a7114c4e3020b6586bcba9e2f70c7809156d2baf2a1a8ddc67972d9a52cae47b6b14e559bd2562dbbea22330032d668c921156721377c31f394f3f656de19ccee99f6ef8ee242d98e7aefe3fb67ea1d45255e3525833112f660da7766c1db1ec1aa24c54e5d63306081c773ff11926fb724c9bdb7939ac65600ee4dd910b6aef17222147425fd4517beda8e8f83dfcec97f1a39e40ac34e80a0d039aef567bd8ad1883c19935273eb1aa6d1ab4b13605225ba10b7b5e88e2865616ab03e5133c97eeeb6417822ca06845531b278b1d74aad6ca94334ff13447be62705b4818324a25b3845c81e369c41a63b3935006f1023ba04d0f041e8f5e8246b29d4abc308c949d1d6da75e57b53b0e888258e965cf4673f6a573bd0193ee72e09afca0bb178cab4e2c21baf78b6f8d80a61d35243c09888e2face894e232a0be8043ad7bb68717a88f890544b5e4ddab0279dbafdd74e72c5217f1428aa20e1274d1a1e1ac58289a6b93a7f0d9e57de7399ed21d35126ea432d45a0197bf3970cc215aff0bd51146bdef68e940e8cea59fa5de7b0f9b2613831aa85e84b7ede860ca68cb33506fbc10554761ccef38feb9be905323f0a6a058323838ee6e979f4e61664391597f5727e379bcfa8b29aa44048997947886a0a9ad24fdb0212e89e25cc2518109a4f2886a1d06257a456ad4917c13a0649cf9e0e3fde701678e14d50b0d1cb286ac27c16972373254d248bdaa46bb04a2ed254c3d221c4e6d7899075680c5c2184ae94cfd4f28db3b9ec8ab009f140aa5a2022665bfd2cd208ca8c62cbf5fe0bd3aeb38b0a9a9dd753637953b14820a1c83083ceef7ddbd2c8c052c6aa26c6e39947a2535289201c29905421f639d4544ac07463c89ffd656e034887d512112b753724d49fb9673930ffa8735f08f985518906107a561bd2a3d52422d3779636247f93640b6b6cc043cb8b60f1aabdc18ae6ed3c9443274367021ded79a29da1c6e3b4f737fc057057d03e428bf3c13132a59498b167999f0a052a366d93d9cf5a5a6ae035d00e4aef15649ebad5d8ea8d98093cbeeaad8940a081ec383fea94614fa9620a620656a5c2781d13c42941878896e892fe4221791e6330c6effc5d9619878b542d359d77fac81e818c92602978f196013ebe5c02663b0895efd613c1c2dcf40bf001c96c375bd4b6e46afd434c3dabef36ea6d4fc0da41c281d04a51da51b409ccf0faf4ec364ae48e939f606eba76d7a2e83268c75c4b75dfa12da07fd8bc5b0a021d256ae37332c290d4e91dc0e5db8b6d512b9d8ef643bc28221027b6960475203adff77754172f84c76dcf4ac5922ba7f45d43766507c3a1014e0e12fc3b3955567c1a2c1dffb4dd396e76e9d790b5290b8d688251dda70876b6fdc43dea5a4009707327fcb2a391828597752205f5106f01601b4f1107fa0f674c5ea39f095b68ed6e7af6e791e9398a2614b30492708d13220549af0b01ef23b63faab44a6321ef1e06a89555cb0c439ed78bd914c169ce52c1589380b74e66808bf22bfef183ca7ebf2c4cb6d4e65c595155d04c4488cb37660976bf4046fd1fb2f81cf918817aa32d858a0e3b570bd29d579ce8e414cf8aca58ae4e9e95c1ecbd6086912d0f169d83eb68d19eeaf6d86d4a76cb1c9096978ffc82243437ec82291f63e317553b92eca04871d66fac944c7079e1e4a87f09abc2c3a914caf7e7ab5f2afe57c7efeb63ade4688d72a38fd2f4a29f48f21a789455e9b54328b3182934e7c839a2b5b41e7c7a2db236e052bdb0b87d55b59803c629fba4136dffc62df7e3adff0c14d548b2a6d6c0222810b01c4848e3dbf09486cffdecb1e394756b2fe2cef3aeef5defcc1856621880898a0282f53067680e9c5b0c7be5465f0f1f5a10844130c050c1190b79180c8df9e5eb8e8323a0a89e7d74954ac21bcf87bccb2b574da12992105a73c9ad2d95111640075f9106d4e6b11572bbd009216ad36f32bce924ee6f60d1db011eac99cdffdd9609ccad814bf27e5783beb25ae1831175d86a5ccebaf204b693c090237398b84fb8a302a923a885df9e5e4b52e22682e428fc6f1f4bb8d4a8d5cc7442b24ead68de450f7be821870671947e3d97908e08e5f0d8a99d4fbfadb0b3664bba76faa021590ff753139a96e3aa228d4982afaafc5412c1a83489443553515972c28b3fb61e2227f2aed83ace1173d3afdc288db9c189354cab8e22218c242bbfbb9c37e6fcfd740ee9261b45cafe9e2f1f7ee0291ea8eeea75eb7a390fb67438b73ad936db826e98efffab80ad8d771b57bcbbb0eec3b6279477016beca9e1a7157e1694d67c51b08da80fbe355d65f9fec1f0a83c796851f240294fefff352fb609ea40f047acba694ef380e6bb2ea17dd34f0326b2870229896807086133da7ad38c5e8ee1374c32e6a2f1a33fa313cda2469c1d6b9ac599e36fb6dc179807d06c8d4bfd6f66feab4420e4bd7e71ea909066bc82d5cec03e86bbb66f5401e70b65bce5283d1c51c20d5f2507095a240d8556284dd40bbeb28f1c408a9464ff1fa8a60f69cc0e401fee67d52c83c2433aff1f9b41516197d91f740b68b15e98487c411df1f45c8745432b7b88044f8886a2fc3dc886832b6002621ab72980f64419ca1113b510a3f9f3d96680d9a447bf27092e728c18d68ae44fa79f2eb259ca85c63278242b3a9393258c889fa409338d9d2c64c4a60d22ad366822e2fdc8b4f38b31e9d673131b10f86f89b4abecb54f6445cb4fa36f02650ceb1377051d8be939dc7aeccb389aa978ac683047dcfe68bf08b9cfcb86319be0ae1aab93abb8ba0c96f8445a15069071c89e46f1dd510f001805cc2cd47a61874d9b181ada87989a803877257d731ac367c23f2e6bafca181895448abd7f9722911adfc9c40eeb63900ea66c55e86b53cc80e0acd5c909886aee91a38833ca7432de71314566ba27fdfa32d2bf6127a0baad9e91035bd59b312701ecb64e46175d490c5f9dbf10adcd2f0d1464feff84bd139d6d2f27e46dbd19e0dc3d8b05db4ab0c6f42e7e8cf7c7c5f21d52a6dd4045c23e88f89c36319a9455097234b8e70618130161793be877b6f9b8a454a951da02f9f60787e1ad161b0fa673943eaae979d45f6f835de0e14650668e119b6769b69ce5e418c61b0e76487e371b4300afc13ed9358ee1790f60914857092647b0bc311c58661625778dc3c07c7fc0f3a5d105f4e5a2621b261ee0c7534ef59b817b3a9e4f342ae5fb8fd728e71bfc5ab4a928a5c96ff4eb03681b388fc21ca0fb1ed079800cd7bf5b0025da70524d9860673b85cb73443df8e5bb5dae9de318df8a9b8de1d371c4f5c8839cb8d21fe0cffa91553a57257cc01b22eaa020c8d559b53faaa95549082d11702a314c1cf6f6d91c76627695d331de168990c286f432ae40bf901ff0763025b9afd506cc1b1819210b3473a9caa5618a0b0f2d3fdc0d554ee1320cf4cb3a8b7b51bbf990e77a894edc853fab857d0105693b0c0f25a0f20993b5b892f06b7af2bc21618a3aa47e2b9a9625bbdb0a28d84858dcdb457412c38bf6f194cdf4f439ed3b8d8abea62eb86cdecb5d2d395eb41ea88821f70dd0b0234abfe069166f8588278f4913b4b0e88b648f4421a42fe6f4314304f0c77ddc6ec7e6262b1e14140bb5eb233c7b4c5cf502c810960f3b2bb7b7db713893724088f234ab6e164649aad16a756f0c4a7ac6b46df11fd787daa4a520d7291ab5512f2806122c7290c837f4dc7c914f670c4dbdebb273cfde910c7069f7a5abafc7f8706cedce18a96a9b8134d5cc0601203abfc8a62da4cd72e9504c5c25ebf767e861f65682a3cf0917bd5937894be5bdab12d7179b9bdc7cc28a63c00a5910cbc389bed60786b7c11a3f77c7e7f38f1b08914b7b6da23b98e2adb74092d02fb382eb7e6c0ee8b6587a0313483349a8e0fb7d82a19810d5f25b8f62391babe0b8fd3916b5c4d1d4343c44978fac04395fad26125c24517baf59ca5f2766827e0353d1e3cca6216e7a0fcbccdec9949523bf87e4ac800c6070fbe8b8497febdb5d99250d0acef1f2e770942120cd370c1c7529423463ea6e165932776ac006fb587810066a3bcd52e110cc17452cf0a55d907f35a720ea7a269a170af842940592d133168842c5eb4887e23f27910927c68b799a53efc66807fdfd7e9824b6f207826e367217c72ca749b853153fa43f3c9692ebb75d3eb6b63586351fa449213d5c8409e41d3a0f267b80e03f0170be6bc9a0358071074f50493a81ca733126337df33f125ebe42dcc209bc2c8c86fbc6d1a656ce2834527ba910581f0d346096824d9e166c2a41a0be18262b423d3cb34737b3ab0dcef07218da20146d0e33052344cf5839fa576ecb90c335e2e541ac9e3715fc58b5ab3ea4b56627c503f7137244b1d0648322694bcef320ddfa823f48e5d32a65bc9aba35b5ff8d4d8f625dc8dcd9753ae50877aa9e4924a20394f2f94a3f88b356e03f6d993a9064638376b2e1504b0bdd6b835a36f125afc3f86a8c15d693ef2c5cd528c8b0b6fdcac1d2e58387a058afd98fed3cb85e3a2042910d9f755d6533759d9c11aebf4192e0035a999a8d43c9f39220170ca410b02b231e16bb78ef92e4b17a5df9d254836ffe9746822c53ae5dd3f0d7d2d1ba18ab1fde21e72b8b91f06149882190a313d78def77f191c79cfbfac6ccd87b949cf2c5922f44253e200c465f7bb2f87683197334f225188fbf67c00a05e2316e572944c5874c5722c316dd43f7c8cb096a6c3e6618614f46dc36d0e7f3b29fef3a6fc5a7ccfccab964f28993358330c3dfa045960a5f47992c15976f276f31e0354783a1d9951affab6a41afcea895ec4dc173ebd8b19689ee0f22a44ce44efe2250984006174e8513d20f442c0ec5e4f8e8c8575a320613cf9a8c6b3b84c2a1068cba9e5881f931580b166a78450205b73fc624fbbbecf68f89016fe90b44b41591875003cce555c4e08b35e05cfce455af99c10a3c5e8e3fdf486889a009de6c58090846c5d190c6c147fd4e2db669b6a15960fa3286b1f523bf3a54a299a071ac77a2013","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
