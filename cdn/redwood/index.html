<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aab4d5aee378b92d351a5542d46528c77c2b7c7f234966ca5778cf1873c65f61153a4e336b9f6f7d08a5b2dd5b5f1de3b7a27aa84de9313bd95aac381ebd085d75e1b26a7c5b650447870e21b43b71cbf55374d2e7f61ec1422332c7a9d5faa4680ed87053406ea0639d8eff76e8ea2f52f931a24c227e8bbc52776fbcab09de589b46bdcb82366e7fcc682b18230723b9619d2e8922fbcd27b70b47bc9dd45423f085cc61c95941d1a8a7b1b5314c349dac950274efa63092ebe825478750889ec4f16fb646a4f7877acb17fee2f914a1dae402e92e18fcd74d54fe8e1ea9e6c95f3d20bb1ced37950659b5c379c6c2427aaa8f38e81a09649e5d2b1f8efe5762a3a10ed21a91fb13fec9287e90731123bc13192400abb05534c5cde0b4d6f1d793bcdf8b8e20cff728d41ea12e681753a5b1b2c309d7002552b1f82b37e8c192d5b40fae15ae87e855106f56aaebbcada7ccc1a6a4c4301f44a15e7caa5134793bac88ea1fa6c52a09540d1ca2a77c3973995d6c79f9be78a8b5c74a07c5813d1a35d21347d2c6965c371181e3d28f3436e24c4bc31c6492cd0ae96d8c31549db9defee793846702d917f5f90a0f83911ca1ca52bcd9048180c6c6b4d65997ac15ce24a8cd04c427e53d3ded848a62c816366a78d4cc1671426c1458617f3871d3759b8d1935ebf0663da581645aed55a32cc949eca338fb41c08ac805d3e54af7d0579b463390b6484ea701ed31e1d0edbfcbc6eed8e2b420ff8eac62fc291646e1655de8931911b86b8a0cee66409ca28c10761742aec15a156bde308c4cacaf2007eb7f51d923adc53af516ca792673fce760d65594e2c7dcf1781498038f02bafe03f288fa1181829ba05a53b66e103ea01599a25369d1de7b7015ef56ae0aabf29d8d32e43e9451761427c37cca6ba5aa67d469316ea92c22acbc21bccd1a91e7ee7f25abde806c656a966540928d5422744126df0d5f1223378d83f3e8cf7b77d0add76fa99b3cd002118639aad679f7e42089a303aa3572eb35554996d9234f3481deb98b1094f26e124a68651223110e7afcf50c14599f6d0be6889e099c991aa6a77200ee44c8fdb291b63430418386ec83c104678b21bc99a8b6665a5e713de1835aec74347e8523d748e5f8bce125a88d2a969326ad76c1a471b2a3bd704ead83820b0b9d61b6b068ccb0de24af5069bf05f52e9e3ace9967587bf53ea8016d14de6bf27b148518a877b0954902a00b54fa3adc94b07407684acfa024acf1dec80f676f9b0197dbb7bbac2a1d63bebb0dca162dfe062f65ba89c705d527a16142102419558b4203104911ea1e814f99ea9218da9d2c3d0dc03c5bde02c5428e79889098faa46804c2a38af99d98f8a0aa4651a8ea9ea9c6485bb5f739962ee1b73cca8aa66c9a14a504a2b4974f4a8d45d3e713e9668fc91ca35be93ec6f8b22d2103918f7681b9d11287d2e594207bce3c9987692d85de4dec3366d03ffd16ac3396751928475c68390f6c7e9df4c7cde5d7969878debd9d8d9f7e70c29393d72bf18481ba6bf05b8f6b19e51697c38202ca5c0d9853483c3a0149c900b56486ba4f40d93203c488c731219ec948d365cedfc13d24c6fab15970a3ab4226b53499b9dfba4daf029bb04a2e3f72194b3a2715579f7a651726c82cd10d011e3d9b3b42f9efa28c8cd5198edcb19a5dc85ee0bf887f3bc6c2b1dbd7403ae6bcf32b55a36be640bfee402b3fec0067f32723b78fcaa0984ed4080a96a391de3a48201f34021b967db9cbbaadc2a2f9b04c74d77d23b3b8d88949b14037d5d390fe9c65dac9b032697a2b8fedf2da1576ef403867ff3833c3a65e4d712cff01020a227dd9320df8334b468463f19965c5e19e6b7f6f8ee63ba2d339f695df23a3c1d30569148e4920df50c3a801cd4176d2acf1e004e5c7e2053f6a1d380a0d9515fe496f96696b3100c97416eba0c135eefea6e5760af1493230cec3c43a12dcf1f76602dc48642a8f91c59bd260542778707fd0f31436c0f122505825f1b09d2eacf8ac201665aeafd552f679506bca7edfa095f48801f7262f472bd480a6c5f6a1b84d9a0114bfa4b385a0fff6c0cd5173a75f004e41509ba5e370318151499cb746fb2b28d5fce01874ee364027fde78e5651351b0d87ca4dae26fb41063cf42bb30bd106795f99bb999bb3f334989d102b5a6fd56496fb9355859baf0402f86c26523711f7e774f52b40cb99e1116cd71ec6612a40099a0c57653f0a58e743ed748c7c08bb5b0eb9c56486dbcf8341878c1dd53f7fc127b90d000fcbb7b6e37e6b24bfa431fa024e3b34363407303778f18cc5cc84da9c55bf6ae36a4aedfaa9459311c199553e82c979352142633d758e7046fd0cdccc01f4b9e4604362c6961e41499bd8f574307957de5f6893eefa931195968e3a7aeb36da0f27ed6b11378817a5afb41bfc0f70965ce5ae4ca49d198b5e51392c1e08b23f15509c20aacece288acddd6ae02f9d7df1fe9d30a1385c3a2091f3f6d35ba3e0331994ddb1fdb485139305b399c2aba43a0dab09bbb844917c1823d240fbb7293ffac73fa8766c8838f10a0e3877b6a20ebe894de93d4aa0a7fefd62e0f21bb7897ce667bc979034a79abbc8a7a017dbc6c3780ba8089dc570c0744844efed07f1a910ac9486a66077ca06bca710adfa2be2b51f96a458422b560eaadbe999d3429ad5aaef0382756f5da470d7bfcaea6ff14896e10993f0d7d3434ab0c0d639a31d5c813605a71f8ae0390816f191c1ad2640a88d55e41e8a5e74ca4e37b7244021c52bfb913fadcb06f876f776a3337ee092c7a95230013ad2d1488a8d468af432c7d19a656c61707b421f17c078f0c712d32be01ff33a9e3388d972d7908324ae11af64d6dd8a1a52cd3301aa550c9875196fcebf34e1cc448069b40121f21b8897014a52d0ca795bed6723171a0fdb5684137ebf7744872a407b942a22a916d080bbe725c508b8b4fe78f3eeea42b77f8221da2acb71aede7bb4f11223995a316c4801cde34ec909130f0ed2942f1b82765cd61f803e35950b5b5399808465c96cf9c1c8fad70b56700373621a9ba2858b49121cb06aa2074ff21bf38b5b38cc97217ddb07463355b550e4ed286b5b83c6a9e6e535c13aa869afab9ae79639809d1d5498c2988826290e864a0240f275b942eb90d1bdcb43edab95c7a62fa33819714ac39767a78bdc510c16bdf8644d59707c07bc3fc94b5a3499f25da3d95f7bc565a8868d6a3d7952b04eddbc339f07b6adf1dd8ec936cfd654848202c7c2ccc9956ea455fd7091ccb06277a4edc104509542f5985ac14f1c17ce224f50483785f77f97e3b42318a8df6156e7926181b7db0149ca859dcd79ca5b0f5d3a53c22fb89135c1e2bd78e14c456071b3005fd8f0bb6dbd47be76d39c73798b396c8a8af4745a2e660d345c2ae20f58d28aedb4fe6742f089d7c42927dd24d74dcc6f0b62b664677f864abda48126f8afde139b5f086dbbaf058af24ae4e9de2a202ba209587c8a52a11f115110dc2424e33f7549f378a8f6db150cfa8d18834916ee281ce3f1f2770d9730795f884121d2f4f27130c3f43b885f6cfc959a64c71dde3f00d8a1fea18027276891f8547002281a4d0be555f9d6ac6e5c6b29697dabc7ad15442f1b07fae7b844ec3f102e7c342eb6b251f8c074bdd759782029cee58b1b0f465570a8a98065a75c06bbc40fa6b29c2eb220285f8c793fb1a28518791985f7335a2fb2a5a1c56a5859e875a3cedd21da6bb4399961a3375a2d832760448da012971b9c52f8763c98834ffb14767e32116e1fcc29aa2202837c0988b42ad23684df66d3f840885d4e67adb91679a36521cdc1aec4b9f81568f2e6cb339e07307846adc224bc0d37c706b52c556f1cc0b7538cc97a1c41ecb1a4efccf37cf9a3f6a19195d22211935008d2d2587300123ed4bbe68ee31e351cdae65cc8868a935cd2d49f88ab7d618bf7102fb549bc93b8a5b15e045e66c8a33f5ad5c88d9a25d00d3dd38f83c5a241a0637b0ffd8081fc0484449df6947f59799c166d7c370cbf3cafad27b70018eb1f12a698a8cd05c71341eb71950015b6deed187a0fddf0bf084b673a0428e78348de0f92cdf0e2d6341bf641fe4eb0ea1b2bd40bc1c6e68e1d87c453391f45668dfb6cc78027dadc8aa5697ef5de6ecce2d6d4b3665bc5138c06f03fa20bfab210d915e82b957687ed9bf2e1a0314ecc2fb6471383f0ca81b919981dba605427e4b9236f323b49e1c19cbec5a103d1594c41fc866eb06fc9fd16bd2fe516c7c1b287c179cf7313a35b28ed75207c574c7c32f252b29f2674691bee13cb8770e6e9b0b20b81cca0d7e39434658cc17f83e6e7c5477e20860c2629e1509c93c8a890e5379457d2f9f677e6773a0c3582ff3f93e758b25d612c7fee03626fda26d5cb07b38afb76952ab1afd00203e9075d8861a4ceb3ce61c7d28eb6d2ce7dc96cac053e3b945395c0f367bf73fe3179943fe4a7c3a951be289dd581734cae66156cb6948ba59520935b05ce06ddce490672ae0cf16bfb4a875b0ff8c72942bba04f025f10215859113317bdab5b95bc64059610e2000a06d6182ca55b6e51ef317e6de2ef70412ff6c830b4493e0a031f0a3576ed2ab6838a1f870f8fc681483273258be95692f816dcb8f33cb54dbcbe19a63cffc58380efcf6a86bb081b042f6a26dd0c6b8c57e08e758b45c7f2d21dbc62a0f3e8c0e633810c6bd087830ed77063a314b9245ce589ca390dc80bb97423fd06dd8809f21b1ba9d741d562b70ae3c61b93fb5dc46eb781b590df809d15dbdf020f7fc14354645d79befbfb1114741754f78b22eb52bfdc58f5186cfd878ec0dea1d1ca381af2be797ae50a27419154e9ded8552851df0d65cf63b707aa4d3a4a8b4ed881d1e951a0e25ddbc6136ce01e8f9a24aad8c602dd3de8ab057cb0eb2049dd4798fa1447702a9874af22d8b8ef01410c759c39b8a508da3793898600e3e63ad482413cd7799563179ff52fb74ee770249e174025aa889aa327ca835fc71022c3729227b64cb1f59dd849a8878fb9430ce5e06d1c6cdbda67ccdd035be4c0fa4dde01c493f045596ae74cdca0ac39a1f28e6bd13a990ebec1b4e4e3287b4526635126bbd13a0345db9de10c6d82aa6af936e8b7dad92284ec4ea6ee0845039603d4212ad611d9f22ef26b3b3eef924b67f6c8e507603e7c897f7983e0792b99ea3b5aed5276b7f805c3e7e94202174790ce38afa5cc6f9d14cc1fad068bd5fba4b75c381587234cb39cc238202b571c73fecce414deae77b0f95ffa516d794c0bae0c00064b1e009d583c64922d175e45b4b906a73ff5cffc454b30d9ecabcfad5a5c74b7866860b7d8b7b01c864129dc3afbe5deb1bced4dcf615f59807606a2925cb2b2075c6d6f356b7578f78832a642cda966c79d8c655bcb78e2692499d4ca0f4f6d9beb22da7d4fc648be68f92087fc7137b2745f2543c281d92596ad3941817ed12424bb5c3c9ad222da4de7319c6517f5d1a0cc920e9c496721a7cb6fd229bdc2e13438f4b147379a4c75587e1e3f1317e11c4af4370f6226532b20a121aab83c418d9be952c3d277dd10476896dfb256f0594e135cefb40d29718944ce588f3ec5119489f581e434a723b5cc271bc3b0f12c6654ff17581363741dab197011c5fc442b5d9e81ec066faaa651df2e62770fe526cc4f041c74217a8e4397a64526026e120808d991522273c66a68c293311c6f749e1517f84b52e284d923f2a667c4c9ce171b2016939c2fad55749e326ed89db709778558ccc5ae61db7930e1c4d80139a791d53f1ea4a79dd91caf3eaf6a45470a0ccb398984b0e3dec50715423f92f460675af5b2d1168bd040409c9cf8cc0cc47ced8187d290633973f7c2deb15595abd3c6e198af356a8ddbb89766ea132abda09b5a1ddf79d5388b1b82a45f715654cfd0f9ed139bbad2c3b9975f4fec5051712ae7cbf423f66a7f1f6eabe464c2640bdee48e3bff21d721de059df7b4b0cf2fcb7191f9439d379384f337394f5f8830c85be21f1783ddef764ed0f015e880a3263c08c6768eee133fb564c805f91dffc0a86ef988b7e38103e8b710fe28ff6c88687edb267387e48e2c9178a32fcd48e7b0a4c73e5a98a1de1b79d13324f793588f163cd15cf63b9959beba528432928c8ba7235a5a219eb2cda70702fe77198d40a2296572cc45d42245ee8acce742031e40e14fa2a2268ed79415a10014277664cfd8228a0f5ba51dc1e66e9dd8590635c68aa9349ef610b80784c258afc485e61271035f82fd14746a93c594a4b93c2145008d75df7301df546de053c3e34d312af238d0c10a4abdd54592a82fe1189a083061938b66e59eee6dda2cd3f632bee742af416caf0ae69a3903eb682572678cf43fd75a1f6dc7ed026967ab22872028066b5250e23212baa55dfbc286ff254f90e004aa3545d29ada0458c0e77741d663c7996d35a1c5a56a0b96b7c9dc7d8b1e9a9e918be46855db1abe3363dadcd283e8daef6429b5d23c2820df87d2cf72a439660fd8196fb4e821913d8433c0e199e90398e1e345bb1aec72d10a5be48d489d7f0b36039cb93405a7d38686ddcf906fbae3e27f00c8f408b72104a58f8926b243ec29c114c6cd21cc6f8f0125f4ed2686301749d56adcd6d34cdbf6f781618d9cfe6e1d0565c7f660e6171580ed4670811d2af76586566f8fcad1ff87f6598f269cfc7e7ddea6efc875592fa0139e5a2241420b02f64dd996b83125d5080ac01a1f476e03057bb16c2a8bae8f5c5e2e423acd3f1c69b7327aee1f1c83dfd801158a47c2063799e5eb2ec43ce5c86ba5d524a33b6e4c9caee51de06210d89eff1d076fcf45e54c3cb2f8e26e02151d87dcbc1f697f447a100d8aeab4c2b2f9f2ca3649cc3203131a883f16376a21c7fd008ab803f1605532fea90a29d0d76ed445aad99cb517f829d51ec1396c01dca996a8a376f328e2987beae8cdc702155135acdc1e269bf587768106cc1450b5fb9d89f1442b9a3ed61f98ebc9d38a9a24d080fc73d3f169f2678ea40478ac823a4711a1eebe73a0345e04cb473de2f29e95e7c0926b0b9bdf3cb73a28caa44367843507816732d97eb2e61b8ac7dfeb80e84a64c7e8a6c7999ee7d5462c65608dbee31effcda2924689e1d6e16b234eafa15b2e44bf0cdcc0303a328ae604d8000cb3f755deeea80d026d05f7cf02e853781389285100c9507c6b23f1701ba12e74cd406c46ee937b6446b6fa43fb683408a1d2a93ac0c7a977fbf79f2c4e9b981934886ba72c53f07dc8b383558d32c077200f1a74e8d20620fd08252a1d8bad89a8cb08f015afeec82d35776923daadfe75b9285034bb5d7eb00843d1030b9093e1aaaa7a5996213c8b409d6bfd04e56df4389cb03bed732093ca3ca1b887cc73f2f86d6f7a751e0525b891378fb22799623e333a38b7c7098712d96aac6b284016d01c1374dfb7297c18f3341895bc4f5549bbe2e6728f604b377e121b19458f6b0e0af0a939954401e88285724e489b35c3dd7453a2e02f938b693e2c0fc67e1518870e29352d57cdc5500b1a3ae66d58131d18e851c3c29d9c826a9105dc9f22af53420a8d388234581af748570c35743f8ab45cb98508a2200e66c44f95335b906cfee86f25423bd967b59c84fe7524c6113bcc2f85a19bce5e61b0bf9cbee5a5d801604d3797405ad85de261493b1aec0efb7ba602ace4d43cb647d3f609a2d69d3940b75e7f2464083b3c012cb83110eb57da0bf17820363185b2e6dd243d8b5e139e1b4a580a0b5f7dfe7cd76797d5091ee955b24c90f51dc536ef3eabf974295be5b43f0b99932983bb20592bacade4841626569f48bf60ecc03c92a98456ce1b0468609db6d0d856837d08ded7a3b7f8e281ac41c65feb26d0f62536fda56e2984a87b81f8fa53a45ffbde649644c28a8d1ffdf9801d89c37eb7ae305609155bdc856536fc6587c33609843c16924e573337afeaaaceb6f395cfff6f6d29b68e1131965cfcb1493e257fcadfd9cb076ab22670002e7cad9d1b181427645099bcbe879dc9f02e5f5d77973bcab3dc3f82b3b049ee72ad8fc878aef17b64da79c36ca765b217d855fdbd7d8ebf9645ab63538431f245f8c719d57eea45751d66021e64a0e22d8ca4e6835242f538088180048d538e0ff28b603914343df7c3a053a27d80093658edd7950026414c465278354161290b7a15795a88f2e3530a535d415450912036eb790ea8ddde40ba80fc8446221193f45d174ea82d9567442a9a9959d3af572c08483947de7f8930c2b3bce143b8b055b13a4e020edb80684433c00ea2a4d2c3130cccf93971438bb5a77692e60f1e6516a9b6736eee82483c862d87231e6890b23ab177692a1d9e193f268e67b67b81c88488096b3bdfab4aaa8a78bc0651c170a5b3f4de2a73b5110f2992553d891889cd51dcead4c0e1fff529f033498b011ed69fa8fe1a4f0e7e1d035e73baacd963519fc6438c7337ab6f7178a34aa7a00eb809da31dd4406642049db8dedbaa320f41d27daf41239ce34f3a14d63fef8da95b8f6b5f83c8e5eb1314bf15cbc70229eb3dad358931d35b8d8a21dd7d48fc3d8614e749457ac06fa82378ad2763b7ec66211098d01324a3946b6e091f4b02a63b68ce6d1e0d5c184ef0b5d88a05445d887e946e30eedc189038262745e100dd6a5ad6999a5ba86d20aaf787cd2d38ced6874f7bf7de9b2d7c14ddd5f444829c1e8afa1d9319df61748d04e9ef898d571609e987f32b6d86e91004633000157b007c2bead9d1723e23742ee2c90eec0d900718986e635d334dd20977b0e0490696f9a84f6f996af160110a9352bc80904b02218ba6176db3ce45918ff1c6315db83ebc2225b68f7981409946800f71dfd95d3d9bfee6dc8626837d24ee63b65de3cd04d6f407431ccc1b1167ae78f19ba9f68f98fc070b57e6c0d96d1ef093a35e0e03b0a394a93cc5cf104782b6d060b78f0cd8a122516256f1def73dc8e8d7fe22ea791f791fba2cec5d07e4e7e2868513b558ffdd20bea21eb659678cfab283b1fd07efea20c09df7c6a023239b276b1ffd7a5de048252e6367b5c5f2819e5d6f7b27a69ef204ff781d6e93fc48eda8868182bff4d87ae089d478e9d03e986529f3af36587bceb04681885bbdb3a2ea972a24b5384868f337b207235cfe9c7332ec49714108acedb402ee9d764ad7e2a9d823dfc9ad847a6a2b97f3466dc13f76b41a66adb0cd997651cd92f1cde137e59dca50416e04df3f75bf4ee3cbd8270fcfa9c4090779d2b1a342acec93fde7670490538c1dcb96d45d56d6f7ba2ec7a4973276fe95a0bc5075da85d5ca3a6f13b21d718399034b0ef9c14a147f087921e3f2a470adf184ab17bcb6dde346a47d95cbb70274f428283dcab3936b0992de7740cbc0b761fce8fd35b7f7564197df175fe869bd0d8ac89fab3dffa302efdb8cf589bfc8ee349f49dbef68a5cdfabe818c3e4b8efd7343d290e400d10ebf47a81354e59a1bba4a34d1c5e07701108122f7ae37ab611d6e2e2d7ec3997a6f14572cbfb46144857de1e1863255b6b69adf4d056a6ae0187102f7d1ba1e4dbfe2aa8e0cdbf9794996432962c7e1132b69d9fb4f43472bea1e17da9c2296710553112f5b267e8b82a9784eb6620e30d5693eadf1e3068023b5142a9c897f14941d1aced37d9fc9382bdb406c85e1d495a4b0749f7ccc683afb5a9ca7b4b16c34280a08775c1da37c8e831b4fd59c429eaa1acc488f50ddaaf2da0af1decac01680ae66fe83f334ad61181374abba0957da5cddc8e088b98f68d2d41b57a663986ac6aa8b72c051016e9b5f8423a96f7ca56e973d384951d1f3bfb6c14543301704f8f4dd679aa91115677d69e7362e227fe68fa63fe39e14567a9838214dcf4c21d184518707466b783b3acba76ea83618dcdb2f814eaa6cb487c5504ca23f204031dca4bb6b5b053bb9fb454549a41104a46dfeb53f5a7909cd31afe766f754f4244a4099832ddff17c9f751a3509155eff2c95564b9f0feac2749433fcb539472e528cdcf7357af2bb86f35f721c4cb0079192e2ba5752374e20b7f89b0a9af43882e1e3e8fd765e265c0d0873d59d195921aed08c61c87b3b73ed175bc06ed2059a5d74f0705dd6502324c6c52e987914fbe32a8346cd40cc08c08564058188bc11dca0d17e859ee396e136e983ff048d9b57b341d4e819e7a96353974fb42473eec06f3348677c46624a71ddd63184860cf930d9186a2f49b32d17c6c5c5b4f4eae98f570d9b6949dc58ffe50da83d8b2ad12d3cc72dbc4c54bac3e8cc63c1d0572ed6e69d9d999fd0fbb64ba986d41745d0044684bf17f03840a9614ece93ab460eba2f9d372ccb3fa0adf84f39bd3730334573ac1296237f84d8d0a2071132a10a243edbacb65d9232265f1c2898283b12c0c709dc55bbfb344615c31d7930b301855a09d761607410c87f3a2b9dbca59a8e4deb2c03b2448c47d62512f0106a4a2da154f7848a99aa8b889a9c1d391fbbfb1ff9273bc0a2366be72c4b1ccee563e5415df13a4f6b151ca903210e84a5a78603ca1fcb8cbe39af8d0d7223dcd42f7e5210870d1c9c5d862b7945e954deb39314f09870bc884da14800c691b41d2352468f82ad4121001624f95924468f5316ee41e6084f999078d8bf90fe621eb8834511b2cd4a0e301577b07791a1a672dd09071d96501a5c70cb7bb8d9b2a34af2b9140070c9f4bba308d5fca46130653d4b8f908cdd2df4950b9aff83aac4fe54c1aaf0c336913a0e69ab6a408e37130c231a7a1dcc7e0f44f0542002bfdc4447e01fa1f21678a401501442e8e57382977f793b0a9fbe8d8d3f4e2b20d8fecab3c666a684a9a4a6f9fdc3d61526e8df0e163ff9cf7a5db91971bd90bf9bf46bc1e8fee6e8bed90e76ab0060e636dbe501100bfa817f321483a5c3db514a8b373ae493189997d39d41d8d9f628e3eae547df3807e54343bb7ceb869f4e0738cf9a626d85612bfdc41822cb814af8b49bf4a920032bdb0ca2dc88ed0939f09d9f3bdee93a9f623e8756c395df800b05fd1d41cd03b4c58feeb9a5842f1f76305549c8c58903117d181f8ff5b1c44ee63d7740eb6d39bd04672339991e25b3a30a63ff9713f431dab1fc71efe6f2663738793cb120f81ae24e38a23cf511290b953e9afc13878caf00065d450a01252e2654c6a5750ad309c51e34bc8ebd8d0c599802aa081611720428201ab6e407b08dfef089aa79fdc77816eb6d5604d373471cec43beaf2a1ae26bb0bce7deece06b5567cacced2a0218385c5b7e0795a7cbbb37b9df230d9639a1ccf3107915a801f1c8fe1577e872274e418f2ac03eae8a8438c1066e427d89bbcc44e9ff441f94b4e58882b9e8d655c3507eb1a7b7c9321a488627edbf4af7bf7a75cf708d485b219c3590701f1d785070e6f4a671cc0976c3bf80058dd18d1964811aba5b66baf8985d326b5179b42c170b36823bcbd6dfedc77aeb32a98db14fb93d9b0cc9298ee2199f96ed7620e5ba26a805760ec98ed545a3993552bc906388ada6b793ce8d4876909a36e200aa7b5fa6acba99c0852550720676b62bdd0a8741455467291d8d26b32a4c11d31f497b4c1f0bc9f9883ddf8f619ea27f3a98d011f78c653a9056b682f30de95eca803038fac18bedd92f0ead0cd62bf3a1b245b26bfa12bfcb0ce42c65d065359fcebcb0b7d07e085f525bf84979ee9dfb2acf6806ee4c24de26325f3dd3eb0e14314217caf5df64aa1f0962bb043680c65bba2569dd4f31d6ea081b092c88fec7a6788a0db42b5f748d060586650ac42588953fa62a63a278b2835953942fe2cd15970ab95785cb977308b2555a21908d914419f6f4eaff16b75c05b1a88c83971e0b19a14ef9f39a7e38e692fd4cc1428498928425cdf287501d7e1391637fbf373b9856c2d5bb8e66be1d44bc71aa1e3dcd1dc7a1f8e2f5d1a5ab31f271b454c7159716058246091093fdc8551d911af572f101d8faf4b888268be3f4be23c003501158b949249a5c8f7a6f933cd745371b6f8deaa28f0f982919536f6fef2a38ff8be69f857fb5c5a7888226ee6592350ddbf6aad9049b9c37480dbf10d0f1ad5f095f456762068deecd595f9234bb6ae3b190ddd978152f08d48629f485d0680bdf51c9673e9f499464a54ffd120c39baeec15cdb5dc83ab21d7439d3bcdfe35d2eef7d7efea65d79a720404ef1637d1d6bae3c900ee16f90ffc201bfeb0377d7e3b3f8f42c3f1adf8a43ca55203baf97a14d722f183fdc43d12067abfbca489b028b80b4950ff387179c51e30fbeb63ecb078fbd658fa2a0acb6d737f5d2c6e36fb2ec8befb16bce79f1d5b5059d8106d6ec0ccbfb68d012865a0d84d6f42fc85fc8a343a5f0a9511f8690b4fae61e54fb4fef9b7b17393cf6117698740fdd9eba35d0cbe64e27eef49ba575a4e8904a750efb3e711afe00bf84ca519546513e691a3102a1de843d4046e241e563dd3ba9c89ca56034f5e62bb3f67858808748573b120f8962c4ee6bfa6d9c458cf68727d05bc9996056978422502d5232189af49313c2e00fcbe165c8b98f7ef99c1f86020a287cc7a29a16bdaf31b04dbdfdcf842ff80b35c5d5ea6e00fa8743957d55b6a8fe411e200aafe22592b3b3bc3769641f624a8789e5583198dca14c216707e56e6ffb39214351ed03dcd3da1b9e91abe65e0d9264d5339f49b3a70b3fbb33e22ef6ac166372a0dcad9e16653bf86d545df62a16027f1f79a2689fdc9fbb139fe8433a6eb249c66de27c8d1fa079759412cb67e7e9a936e6dbe840c20cae807775a0d2a92dcf74eca65178e99b5a3bd0dfc7790c2fa02c0d448088996a5975bf5f1e931f11bbbfe2625ddb2fb24f0acc7d3ba6b8e8076627dbd696d058b98c10b527f5e696d536f92c76530531d041e264c74cdd729cba5796825f54b89d8a61edda0c82efbfcb0f1f42661eb165ce0c2e06fa19bccef46eccb1bc351cd68ce09d7ed90dc64d00e307bbcdb591e2f9e479ee6802e146c1666cb04d7383ab588e487d1a7cd1cef77594cc7067fae4a766c008a5f6b90251434f4ff1ee32bc7243242640d6a810eebb40908e1616d895191343ecf45c0e92a4cd35b7d99e42bbdd40782d8669ae165ab9258064959ac0a02417bd035c030c79fb9a244b15e55e776ecaa35b40b52f7175f055584e2d24d86492023451250304a429f74b9270fb1e3dacf66783b0118143e5f8ad7f35d70449a09a3364a37f04f90dbdf6c6b4525f1d987931d54239257c7851f5105f13ab8f199138cacff9354eb15695ada4ef68eb478859e1a604ca7f86a583d093c5f8bc8399fb66085b1ee89390c83da68b963e8ecec497dab23e74aa590f011ed354ddba4bb16ae33dfcf8b062e0a36d08db6ae0f273baac3abb51fcd8bdb8eaa5c0118cfc43128e7fb7ec35655c3a00e6d21545ddae5ba1942d2761a10f67df706c2c478490758c37f9cdcedc4a598878098bde9249d3d9ebd38b1464b63c3b94e459904248de59bc57421dca4db11f274248680a92701d6247a09f9b89df2f36514271dd432dce15ddd524b0be40072ff87b446b12bb2bab94e941fbda4026b2beb264b7aa7d11fcd3515bb8de26b9b7068f52366bd8f3db2f9c7cdb4c39fbe08d58f452e3e08f0c6831a7423dd6177965a451cda3f9aad56d3a51444d4f0acbdaa4f44865caea1f57af7e7fa0047628b9c91999d00409f144b3d43416cbc7048fa233396d7e42bcd02f56dcc7b8c9d630859b5a1cb8e8db28ee0ada2104e5e1894237a6f611de746aa7fc403a40b9195883af90b100ef4c883a6635f09948627a28e89670cb3de3ea780e70e3605a5fd60543e9bf8e915b3cd8a5dd849627405541aadb39a58fce9a2612904039d5d0d276ec01b65db45ccf6a5d7ed6ab3a2a2503fcd7941a06c3e25f116f3b6210f52b194c8eab1b44e2b1e0dd3874de368574c397798c9e90ec0056a1167064e8f8442ed600c8bfff58eea8e4cfa89c5f4ee53cdfd89010a4092fed5a8b75e15933c5955c3270ec4200dd7510f0dbb22c202f1b04d36001fa49f9d613deec899054f8e1ab06783574cc14b5c1784c6ace809da4d290eb7bdab37ee2620b428ed0f2f4cfadf997f6bcb5efeea52bb5469e436bf62f9ba90eab214099c0eb139142824df8ed5a1b4a26dbba682bc31727ffc04581cffcb1ff7329c4c581a4550e0d69bbe0c09447ec736720a35c586ced75bc8eb133b46fc4c0a9b9cbfa7c249f20e41e3399073a451c1b3d1b80c5d2b4caa1d8942cff83dce8431569ed28699de8a77a9c0fa222c5aef255b6176441f390beb9397586dde61c5289a29e1d3c88e23043ea28593d4107b0f336e02fe408f45bf1afb700ee043e5fafd705c0deed35261764c8ff198f9806d7430f0f94c021d2591dd0754f1216b26b0e2ec4bd029e779f6954c80fbf56a30a86f96419451d593e5637f2e74d327dff5006038d79b244223bc422d36a3a7c2f760972359d0c525b8357b5741a6edf1ddee5fd0ecc7f31b78640924b5c91363fab6e419ed93d722013b013c3f8efaf53b2c7a59d244cfe984d6c83aff8174ff5631cc77c3886dc0a856be623deb6dde551a376b257ce09ef1a67a33703b344cfb51a8cc26e2be18ea2cbe9b47f3aae1ba96e465a83fc1f7146f83e9fb85416f0824a6ccb8e33591eff44b51beed087281203ba692d06e7a326f3ed1b4fa76cfbeff32d5023317cfe49c0472a1860ff2f88587ed0a8cb59937fd72125221a605ef0ba25d3a43668d89f2181b577e974f7853b751ba0f4d2d39f5c72224c3d265842b491c588817755cc17f6bf80e9ad00c8ee0e7631eeeb9bfbfa5946707167b44c0c4735727e80fb4b766de2c33717e14117d46491b93324a7267dcc79ba175787fa9c2ffd655fc3d7ead7d20b59d59c6397430951249a048831ea41fdf7fc215f7d4761629da3fb72cb2e371c1782de965573dbb437cf4fd7b2019be12c3ad881513ad8a1a8e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
