<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ebcd3f6d278367e1a5cbe1ccb8fcab1c85debb1f6b06f3130879d3819170771770b19c6b84fb5a6fb833464a7a990a3b5444603f4dac09d8a14d83993009bba9b68a11831708cf002758b4484a470744c4e6ba9f1c09751e2881cacdbb871ebf9cb350a2baa037b3d23d6aed2e66c775b6d543e3d5e22b25cf77d1dcf9644cf1f66390bbc1dfb36673adb9e803d7065d5d66b25d74985fde957401b93198521c96a5446d400ab14f49d1ce9ba71615c35ccef525a945d5766b4cc8f52920b0614a5ccbcbeb6cdd614197d58b11f34f3625c75289d5d3dbc9e596ab1a216bdeab07ec27e96b076a1998f894f0d2fe8e73862ca476f9f0d45936ebeaa469cbe34acdb81520ab9c157006c2fc535d9b2d4d80c3e1d7fbcec092c18e2c33dadfb2a6217f7a5eb4fcf523ffa8ead77cae6374589a919481de092798f8074db842ed00490b7d6a66c8e068882cbc0b0a0cb82c872ad397e5578423e894940d3b400c9af7c0bf56f226cefd3e0b62d83a31aecab0ba57c0aa7d6097d2ca64c311987c9dd2fbb64802512925c28611aa1f047ee7a21e994d33d5cf15214afe59685554fc9f1a19ed945ff2d6c882e458528c8f9932e2bb9978b02db2879910371df36e58ff0d7ede032f4d8c371c60ff43992e92dd9c747b05d0483d5eb51fc7e4ec22fc607889414d23214feddeacef6111e2b0016152801dca8fcc7138d827a63682d3cc394e653ea3372904274d86b68e9d1c1dad025733190e468c8ce98ea5c27a0ea783312d135edbe51311631b291395abf92790c0b44c18347044ecd5f5cba19c7d3b11831581cdab63c8330bbca4b1c784061643406a947b5373a8a28a4236a1b6218058c44c590de0d0487f1811f7e3f89c61fdfb25b0dbab01b4a22452989478f50f1501cd9c02cd36518d9ba27eadeb5979e348aa1a3db1182f1cdf08ef44ea570dcae23613bf701f4f24be6dfa10dc4d8d9cb41f4aff71fd27d25d21dbcd54238117f648cec40215f4a895808cfeec08aa261844aa85faa0fec10b80d1a6d5ec2116efa5d8fe61a4c9ddfe97b0ee339ca5d7798add9e161b42d64cc4980d774b92c678d2fe32c501fb796c801b9b7367b399e67536930d86acca19e3d0fd84829827c1d3bb893f0f31b7c10ef890fddb56855b7dda9330f69b98f8d628e2e5ac67725bd4452f698e7f1e7eb5f681e48d4f6a30896d248ab8eb891094f6a11d383ea810f935dcb06066c3bfb44716a6affcd3a1a9b7db57d301c3978f369d6c43025fe5783eae3c809ad9e5d1abd2c056eb83bc41ca030fa9c45438047acdfa4c4b18069960f4c2f65795774499314782d643a22ebb976630a2418c74818e91e2d6cef791b00b290128bf7ecb50063373dc6be8d9c2ca989c9433c49d048d0659ff3124d3648b94cc2de594a5efb0009426800fe11c4fd8d8b5cc112bbfb1a3c1b42dabdb2eb22683518f785e1eaab7fa6b734af8677d80c8a51e9687cc4704b161f9a14b912624e8b2df7ff74a54f7c06f06f3111dbd3eb8f35d964d021d9e3662ab96278b03d20033fc595d2e6d118ae8fca4394ccd9f4619f2883bef41915a1e3d5bc5e12cce2bf4e19262fce841393bd58ef5175a5ff3e14ce88ad4f90f7d1626d7e3df481a50854a2f1fb20906fcb87dfff1c5f260069ac60c6823b2b033762220a271dee0b38e58b8eee16961f28c0eeb591c93e70f9e9eb3e5eadcffa34ec531459052189a41956bb90a5868932211877f6bd2061ff6c72fa4b61f889fb4f0f9b5d5524e6f1c0aab63d6a0c423402b17bb3903f9ff9ee6af15ee48c342f0785e49dbc53b97d38a4291dce3b04457894c32cf4d0fa3deefdc365a766c5941cbf169e1423f5ff86d05039d6d278a509b6592746dab6e4d8e11b31a0324eb29a2a57c4d77a47d7eb5c8c8ca696ff88c09afae76c5e61f3f15fb490641ef5bca04c6e8b881f0f63cd0f68dc61657f54e05fe32fc0785d2d712f5809458944427ba087050362bf4a382c73715b7d792f19439a88d0ab0ec87bf4443d3a2d2d443e259f204b40597d066edb6a939a10b3ee1f392003ac3dfff4dc88e947bd366b5567520ebe642243c0966273c0a26f7e3eb5ae9940414f17a7e994cc45f27ea498529c8127b6d837a1838cd9bf2ab653093cc4fed9b40c47a419eefdd6531c68b33b663e6094f7dc58a2adcde8a08b3ce08673b90b8e83277e7d46fb14ac74add1ee59fe6c7ac6617f657022f5ae8790b5939ff28b93f7456e15e4644659eb084b83c2008b7f32c4df391360bf954a95daa485d4a2eb889df80ff8cb0a68fbe3dfdf27d910995930c95754fd98bdd80df04b92d6c47ab7c7fce16a5ced96d2bda1c1cd71946fc5d3bf141a3e27e58331fec034520cea8777f3711402b90c5fde07ad723dbe5a06078050962ffe04bc387b3daac4cbba2bef1ffc475fe53e0a0b29e315d1fb32bb570e3b9bab43c177ce50ccc308f6feac5fca334e69e7d7ebb7c9933490b07918532e3e14922a6ea399c468d477be99019fae6a5d2beef69db3739bc23e58150d398dcd8bc7896e0c3968932679ef3df6a3bccbf4ce6b7cdf62fd13366cd3f8f689d4826dcb2fcbe81ec2aa00158de616cd28ed16f276974db9d5c20609fc69bcc56c994cce1aa5e110530563cdf290f1e3bf91a92b3516bf47d08c7fb9295353615ce07500e00158a555c87bceb5a4f9128848d9f278a3b253f33905480b092a9846de73edbaecea940871d84352e2496d7c09e496a98d357b1c10c7da32653d6f9848435cad2d7f50855eb9a622a88503b58371150e11eca966491b796837c3396b7c31d9b15111ff8786c1a921f21598807508d94ccdf23bd3c142be416d5a0cb9e9e28dd974df7f3c1b6f22209c11afffc445f381ed4b286107342bfe883025f81cbf024930ba9381a99307b2eb5452348a3ca096a3d48106482708c420961ef1d4bb6552986e4687e405d472d199b0d3d9290cd2709a0fe67c6fd92bf85a9ef0c954cdf08efc6ebc809d6ec0b090c02c6f9209cdac931e1d2e99af50b3795986f6b98ebc56dd37075d33abeaf8fe4098d11f07d882219028dd204eef02adf073a5c6ac21186406d19d4c81a9b6a73e375928f6c73ac907a5601aad0b4262715cfbab0b19c595f586366e16df603e84b4801addbcea4205937ed15ba54caa91a42be55a39508c07a925781bce00074024fbeee12760c960f93334c9a1d8613fe9c309fa1a7913f359473d4e6927c4afe604e75d3588f16f91591da03eeac4ace2da601e401d24b492706be212619d80b532c15cfbe6b793b09270864e176e5d603af78e3031963a956246a392f0a366e74f2c64a66af6ed7b57cad4fdb5559bfea87a699358948432ec720dcaf644ed76814793270aca527cdadf562e19db3617af48033741eac55e08eede443df8398c20e4944b18e379e9d448160ac9ccfee000e521b2dc50c5b786a6f4dccbecc1ad62d37d3ec8a16d5586e30425ae254040d110c620aa4b3a3b0dec99485c47c6024b7f153e1f3b21980af2ffbda13a4fb535f72afa50939fc30d1fe250122c61182fbcb7d06b58c059d11302ac6e320a71da0a0636b01e20685f7e142563f9db75b4d4af5382c82fae4781628fe772131d504f139de603a47848d0d0c76ed30bf30b565392900f9ebd635f1a5d548d71f3146efaa83235270b18bd8d7495177a03011472b7d4c1876a4e35a7d8d0e26f09e3b060d630b1d68d135b622da8bd31b34c06cf13ca72b1b762c74b53f1349a0137f808a369136112eba6f386791374ace6bbfdc6ad1c1427edf36bcf8ef958bf47e8956dfd9d7c5efcc825a95c7942f572dc62110d5406b8ecce9efdc7c17e5945f35443634cc64f687a3f4e7bb89440e35d37bdd31ef91a2355b9c5bd475f43c071dbe13d7cc9d9276ea83a5cd151ddffb5e823094b1d2c678e91ea25d39869888080e95abe44d035530da8e8a435ac74c1db315f5ac0e218cec861381f97206c48edfded5bcf0c154d0a90f92747738ac65f658a8bd73b99621a3a7aa5bc3de26912de5a63a964d8bbd9579596e78360f6b2d2cfc7dc301c56cd99a7adbdb104d8aba6d03d759b5304fa3dcf447a211c39a6090a063dec0a33d77e3e5dbd1cdd06e4dd3eea2ea93746fce9a3d4bc1bc00a34ed1e9952284faaf05fea2673b6b42ca654f70323410f2ff3d9170dde62234544e90cf5bc72510db7999d396006b5a69eff49967419f0d94c601baddda7d087d0f65c7ce039dec5ea110e6e6799a9f1ab8a7be5c030060ca7365f3acb6acadd3f9b3955fa23b2851efb44965b99d771a91331ed57b46c4aa7bc478aa4cd31d661238de67a6e1ccde1868979582a193364fecf9160dd4795d3c342c6b3fbc67a4c00037e2ae776f419d1f9e36e885a9e789ce0a39f1e2360813055a66fb8a6158f0e87dcbc8531cb385d1c5f1a974a6e7993c79d2e82e1567cca25f5c5957920f0bc0147bb54c78a71de9cbd114d14709eaf40b2e799d0d9b5d6aca6bba24fe5945f3da58594a8c421ffae548bc9f1d82cb7503ebc4076995cab176d912e1b86ead13d7b584d3549dba2b7c5945e6e0e5b92c7ef2be995429e2ec774929813be0adc6da9b3e1b9cde7e2bc6d213e74f7bc9135842f92626b469a9ec1e0eb6298618ebb7f696546a5299b7f04e5ff02581f7eb6cedf85f74d216e87741eac0aeab4ad13c6fac420fd63bbf1d159bc03bb288de22df8eb3e94dc354a1622761befb8adc18e03d71ee0d9d037598038a7164576932ba672cf173a0d87ccaa3c06e57ed706f842dfe7684fe9fcd26ce94152e27b6140acb4bcee64b498902b85b7290d77d215cc74ed1ff9bded4ec384bf902efbfb5ef04a451def3c2cbcef5824b889e0739c92ae6620ccababfc44e34bf82ad4a9d797bc7a1e1fc8d629a3da6fe341918cf7de950722495bfd069001b00ffa3c3c30df1687d88604699d7539d03b89d8e5fa2e13b6d26612d013cd098c26ec37dd2c993502d8017e8530c612c12b612c60106fb5876da0cc2bfc5704962d293d8dab91cae4b33b9ae3c812f6edd1093f214319358108637ea682635f17600d0cc0318d4c88a3bff7ba792fe6922f5d9f32600f1e2165d65788e36855a8443b74c4b2f2d9215926956108341dcc4f68051ed9ffe9db6d17adce9b37eb154dd81c6b711456a67f2076a4656b0c6006769ded60ea4cf6dddf18f4d82022df06a0c1e71d86efc6aa9ff607386063931d60bd49731c65b56ae2034bf2889b9c35c364f2334a239e5e0f09a23f9e6d5d5eb06aada18b17236496b1a7f6f65ec69cb610815027c64f08b2f5c07a688d0aee04a0057b532e0dd0616d68c70f67068b6b50ab10d5c2707ab92cb5414809a99c87e0f0bdcba1a2af7aed6a03d6bebb17a4ee67df158ba1fd12dab122aebb2be3da7dcf39bf58d64b57bb50cc67888d49dbf5803b008470579e14768364d3915aef09249d131a8e8fee42b2eb820b9c91f80790ba2cdc042f6080b2e0c2ac28e6048215a8c4ca8005ca11f86b197217167ec961f5ea308818489e642129b787e4ca96cd7895d523804188b354d2f2b51094eb5cc8b800b937ef57be306091e3fd173dc4170ecb1fdcf8702aab20a568ed4c504b086aacfbd924f004a575994ad64549f03df639f978e10d415220ab04f4e7a22a254d668dac4a0a053c71b3b78fdf7dd1f48d09651188cc7de1d6b3f97d3f75db1494108fc662666ef559e87d7760d45d48b6378b7b9c8d06a49fb52c6ff9b494d205a96e09e44e8ec61486f3d12257a8f9daa399a05abf642e3f511237e98223656096b0cdf7b0b342460f673f08f28086004b6015e10c0506f9e2487312e0d7d568ced8eb3b75d7781da23432eb9716accf101f6650a118c797fd785e2110c85029eef4f9734923867d3655fb963930571e6ac392d86528ec7ffdb50ad86283af40f05b0a50963088a59eaa65b55e3614302d9c00c9b478a259099547eeba4e2c9ee579f289ae978732a6cfe1373d2c5a67d82ed91882216df27a89a65e3569f4d8674bcf3f7fa7c26e2e976d002cb289dcf4afeb1d10afaa6414b68b1aec3153dc5319815792bef139f60b39e40d824983ccc36086cb1a868fd8a19e1566af0d158b5d635ebc1b25b63440ba0813b66f706c0cad708114ced77deb213bae3445b0128babfc31f2bc4e023de3f95cd2cd7a9bfbcac60c0be5feace8951d048bdd764b69fd31da363d573569734e073ac73bcf3de052f7a4fb51dea29a853e4360252d0b0c5551452eeaadc251e7b7d9f19cb83f842b3f424915d4fe0a6a54830f3a346af054eb7ff401e9b9af9e4f70de3b570ed99bac2687df15b41e3c767c3321e47d0f53c5868a735188431d0a8c171f608842e2f21c70bd581af7040b6f8c34ebe55415ca6279a0cc730bc68aac6ca93712508a1ebfb9888cd2ef116d3e621e77d22ba906444e303876bdf383ae37fe908834cbef77acdec9ce5192efd65c295e119378550f7d61b069244c112aa551a1118f926918bc4574fd82f9a4aa32e9965058066400b9da7b65a431500aeda8855ed85267920916291cfc0e107369c78a78c39d8e638807a7fecee89f6e5411fcfc725ef3610217d63b6a7546e75e81268c1194d77608f4ae533eb24656c2557d5959fbbf92a42e3720bbec99752e1e4d227b9f6991491d67b03f930687a2425ab5d04334e256c5bc44915e19037be40a2d5e67e729e5f8ace9a0e535f2bd1d603d063bec6c7b5b58121d0bd1278e6377e9df76f13e69b9c06ea3c5a17a0f4949aa2453509ab9fbc4b1a49c9bb0b7c9afd18fc73efb376f3d5418707876abe45dcd71ff3ff519897ac5ed8e19099bf7d9ace6ecea01f9eaa1fa276dafa37cab039b60c3dcd8f05ca500e7731c5fab9600e92d500970f219b72c889b64e322622544f5b5905819cf0e5f49595f5a054783e2a0e2448f3c397c80c482f88c708be041948cd49a2d5dbef298be4cf6d1731c607eff5860ba02f948ca9e976b39d05f0c0c35ad92ddd1d5002681889ba189a71f5b634703b0a989816875e7392c47f16c9050b34a39230f93259f563338807b6d27e40fc3463277520cc703ef87a8086b5ac8276d766b9d31bff26079220b4582a9f1f52d9f4127b3f94c0f4ce6b941b3c8967adf3789e5bf05546618a43a65ad4085ae885f9ef22a23cbaa0f99e934e8125a0818746b515fc4390761781b9593a4f60c4e776030f18a595eae50e1448d140767a0eaf484c3ec8a7d5dd0134f4fc2a8f5dccaea16bb6a7a81b8e56f0cb411763e8e212a800bf246f686f61ec8f933a677905cf0f7122fad5c167499f43e9a02b69ae983797744e5445258f812d27717c80a0bfa178c5a0c0671da2bdb92df8f421dd7394aa67130a17f900c0070b4c8c2e84ce3ccd123e1e2eda097b9705369f527d017665e054615608ef3a688a7f830c7d0eea418cb2e49101403ae0b8db7a1b80e64f5ab462ee9db1eb8e11dc9a310deff34a21b136c8cbff4c1460b73d45ec63432669deca6ff5523d8d7bb08877fb21341fded2088babbc47e606d461da6833bf05f0097684e53ff4ff4688c69098b12e8520a6ead2cfae620a46c78e5dd02126bfe176c3651afdceeef265d3ce718c05ebd8cbab6e35991dd9b6cd7546746c245a92ddc6dd5a3d7b9b11a5c74030a158947b575bf9e5e9b35b53f33171cb42cc22bb2ffb01857ae2220921dfe872699a8aee6a0e306fb03f0f1f9523031c3ecd7a230a0a851b99d648160afe957d55ceb99085b9f8bcc08e50abf1cc5e249ad4cc28227f950e800fa20144f67c37309a53919b692d052c28fc2d6fb069b56d06f8ac2f28e1d4c33edcad88c466d23e7f61d7e288a6b08b12541515584f6a37c0a8ba2b178bd8bb53eae70c8e605a65061add3264e2009dc7966bb9d34f5851d011ecb4adab47b48c035ace23faf0a7d8ad23118321388b5172c84c4b33dbd6840bff565598f9bc36f0570df2ec8cd7cb6f4f367fd0b6b2d6160897c5c1917f7c9a3578da528266ce14fbace8a1f6d72c6a84748b3e72540302d14623ea9c7860b6c5ce4485830afe2d06ff1ace0fb7581938ce41b6e2d69349307ff98cbecdc3f38f0aaba005796b65e1a865657d2691a45564c5f92b6203a1c2748d31a39443fddeca99a78b70713e8dd70c38693bf61d4f23cbc4bf909b2b47cb06cde0efc60a0b21cd4e3e3d75bde55d8610669b8b4a7472bea57d0935d91fb4f77da6a7afe92ceab2c74e61c722e35b1bbda7fd9a139badd23618f2e3f4b5548e3bdb8c8ad70820a529eaaf92352f6b7c0734443380cecebc2fb312ba57e4f35937c9fa51cea430be35959b462725bb333068c18b0f69c82faff8aa4d2980f8a103f54822d18acdfda55595c96b0f26d95f274bad105616220973a216e5de031719aa03e0b4cca99bc3cf020870e1dda4b9c16834ecb252aeab719e8363e45b294a1a893437f9aef2001dc3379ec2c25644bac9a7cbde9dfe5e1d7050eb8048ea7e3d98839f4390a5d242acbd2648bd424580269e27954a4a3168454dcc3628ed3a8008a4d503c08dedff26d318f4c9acd397b075af0039496440fc9af0c80eab7bf7f3d420a6c31f7d7c9c18739b96d8e375c33363ab1b68f17f8b6e18a743f3ec94580253878fdb6b564bee509086510dd1bb701ef7e7ca0f94aafe2c73f506f84ced2c5b645eebf5ee7d0fffa501e339ef43ba9301b6cb05e29c6885e42af3f436e9725eb0cd4aae63298991731001930ba9252303a50a7827c90e8afad2a82243a154dda389f2acc489d533fbc81a9db6a5b8264186b3b003a0c347b101949984de6f0bf1f7e66bd5caaf6c322b4b0cf18133c8396ed3a118b8887819b82f12aae30b7b9650269a72e48ebfa3eafd02750d1cff9768cddbe091d1b80d7d415d1cef23dde221d602f231f0c140a82487cbfe3df9ff7cf0732f4bdb144bebb9951a122c532bb03c0289f563ef1f8162711a070dcbb830c2e53e2efebe1d5794bed8c4fa22a27722a1c81e9eaf56dc782b4fb6de68e72b1c13ca8ccc4190d4c81f34f575ba881a5a23f50c50e971fde1ca5f43d31ab15345c4cb952744099cfd2bd45b101bcc7ddee53974b9bc592bd8da36b39f989dacf737bb20cd1774d52205cd85843f63ca906d92e7d5759489d5db7a829368fa065026d11052ac40a94a2666526748da57c1531e83e6c51ed3da51a409bd8172a58781cb0481c0184cc2e06418ba62b28955696f4f764d53964c510dca07b82f750b83ddd0ae4ec5e78d20fc369eddcbe2bc13adfe3d69d4d5553f9d0c0fb70408d2445af47702ddd197cb73db9d0478d2dd42a2b7162bcb56a6e6bdbde4190e0facd68209f1d6c0628b798cdddf9d9c9f718f2055290351eb113a0035b0527550362075a064febc7a7138c05fbecaa0b824271e297764f6a1daf45fd8296e7269d1294b60fae850fa32099b1f9dbf4e9e3007bc1c4842e700ddb4c86338097248822198e699779955e5d396ee2d3726919c06ce70907c2d2f89487c138ceb4659c1f5e82c90229734c986b876cb1d828bca5c7f0912026c34c2e403a947fd1ab15197f334d8f565e030631a50d9f6faa979ccbe2b57db91875e45e6e766d54f83987790df6c5e6aa83bb39ddf0cf321ff6b00c46e63da7f4df185d087983810e66ab7800a64f435dba58e07e694dab8303987bc1a5843e3bc35bd5e1b3638a29fc0e94177110cd1b5b39f47d5c61bdd3547cd48d336e9e0757b9ec49bf338e66570ffa08014ab5663ce3de44d999e66155a1d2639dbf3a64e86726505bc60febe841f589ecfe2f18ee2a65af88f0f0f40a5ec26d991d90365f0f598e10a3913c341f46070fabdd340b8cc63f6a674dd939562d1bf3ff2deaaad23a4f980e55783b752a048015c6d59dd2a488ccb50f1636d79228e5295025b7e013063b622cb4f37d98b044c1ed72318382ccb8a4d3233af4085e9523c6d9e422c7fddef840c60fc94f2ba199958d408cbe04f39350c4c17d063319e2ec7adc945af226960647316c2e4e1336e52fb5eef28e77cfedaba0b1de4d00d0e923cd85caba599e6d7c756b749e46bdc3044abfa02a5799941ed22679691d588bd16037a9018c12613ea73264c237154d7b4a9a84fe8ccde138956939f33567f9dc64d3ddd05671f2b6b49a78ebfb232f36c4414ba0317a3fab8dddb0b056415c596b702bce201db2d31d4af6b53664fba18258eef717e195ed206021f721b0c8ec5e3f6728b5d0ccf285597d0de674fc3497f273846f4169596463b57041a6f86eb947c9fe12a49fa9288be6a0efa408612bb456436b36cca2d262e2453f8355018bd211a2419e6feda8114c82231c7f51159295a574d5a8310725641b51ca6ed5f5fb1d5cbb9cd93480889b5c894235c22f9b1c393c5c7c3f4cabb4add66c556e3be62a7e9a1185e41b13f610787adf25842ccbbb2613aacd902fe7f439882416c701ed22e9a8ec57bff7cf558c19272b493e53e3bea1766cece56bb7c19bfdf83a42aaddfa1fdcd88abcbc45d408b369cefd5bdcacd82a95a80409098bcee3cf9df0b97a833a4065603fd6d80e5fbbf7c6d90e60d637cc3b07f6f5e7d193854b650fcf49b7663ad6c625419035d2c21d54d258fcd2735f6fd55a4144b2f222269d04b669e083f3c065a1d3b758953e54eba5b0910ea219832ba92c8ebaf8c8f8eaa6d5303430c9e5f81815368c6fc08cd543934b618171e3d696e3dc0cddf01ca73ea39c006714ac5925f41c89a25ae96e76538914eefda77911295bed9ac8ed0690d13307395836fd48b368225d883d4f5a95591eb2f3714a69843fe4ef7432835aae1552ea27ff947eb4592860f5257ab05226ce6b6fe67852a73e1e2aa74fed491a23853b703e9408161b85a761eb13a8cdb426e8b5c86d2cf524f8db1704472038be1ed48fc1fa77ac7e9d4f3d3aad0184008f5c876a9a942c5a0da06189f060b77769fd5cb42511ceb13697b179c12a92b6a6ece098f0aa0339a2db08d03ecc20b4f5f23dcfde5636255bf5534a4ffd1b9b148f90e05306e4dde3cf56bf4eb9b459b2befb2c3dfc01fde0d8143538183a3a851c03360ae0a5d758f8a102f60191d2e6cc4646d1ab20915d1806305de7351311e49de0ec68fc5a6d525ab281eb876faf6083389cc3c8d21ee989902da0584a19326da714f61f8395315b228806d83b7730b611ed04a8f94bd0b0be0479902c04786f8f464c2bb49000cc672b571d59ff4e781ae3e506d8181a0a89000b0a047b5679e529bc51e2a2078c21c182f8a218e1dc0d4887e366d766457011224b112416421682dd6a566ad99a5f4493225e960379c1fea1320bfae0bf5afc58b9c71b57766366089d350b5cd3935f1ca7a1bbd183a0292b39c357885229c2d305f9ee4f3e16a34dc16088626f4a42500c003cd95048cc885c8ab904b3eaa7c41ee865d00b7bf7a71b7832676eb2669165d413e88bfa351bcbd0d140d1e69f545e064a3ba18acf3471c77f3579594a0e87ce5440d44f03d93f0dd2131517a4437a588b02c0e3665804183b9910d3c7865bee045cf4d75600b46dc28086a8bf3e9a02f4e6dac548784317a8a2f05ba7d4830cc2481b085351ecc9b0a59d447534be61e30c88aac1f14cb1d11717bbf4c0d27601c1aa8f04b147d0cd03098f70d2fbc2a322aa84d912fcbf4034e17b6d0546da89a393e146a8d1f0da5f5e63bbe7546093d3462435ef67912b6ddc4b4d5d6c291e37176c042fa8e52ff734fd4821fd4e6dc6963a55d3e344f5d1fae6d8208fd8aa9ceba5b9fa06fd0526e5d380244834b2c71f6236512f98fdcdc4fc9b1db3b15c024fd34c158092fc359991830ba389a5db68ffd9744efe057c3f22557cc92bb801a4bee7b1a59f6749e07f8808724b8272988a26ed439baf2185e1bd9611b6083d31d0e8917d5f23778194499643363d7d5ce4e9eb14412873b5d106780f66a0b7bf74c7cf5da8ee9ca8a0e23b33bcc27ec4fb354d0cebe7435cd0982b6b5ff04a739633db2fac14d159e2ff7bd86ed0349c9c833d7878b94a5fbf5c54d2ff1f0983c9851945730a1704c88c7de4e74e35839d38fd09f0435b8323e3309866dbf0d8aa2c356464786c27c04f63022fed954cdb0d8728770d9d7124b43f2842b3b37a1bd018719c68c3682347f03fbca3806a8126b16c71845cf380b2c4102c236d148964325e7bc8696c6c4b7ac9a80d3c72ef35379fbfd4ee196350c8dc24b30aeda2b382b09ac24444569bc754fe0d31061cf4f484046a16f655b29f14f15d36ed30656beacab1fd32882e05fe3720fba9f801ec2fd9e74911f381d8870baef088adfa3ec6f7a77d1628196c709b6161d24bbfdfcf7a29db0e93e6998d75c9e409715dae175338a06da809039ecfb9be6fbfc8338e223cc914a0e6b3946375926ab6cd1cfdb682d5720762ec21c3cede897ff324ee804c86520849d09e4d07ca91a769e66737f64ee24b8fa9b3fa4b85b0f0b6aed59a93616dc88343fd7c8e87bf99789c0909d96f90445be22afb77e2df1541a389aa31b319657b2a6e31537974de73d77e7412d567253ce41bb539314e8053fe7aa3eca7b4cea100d2d30272a07a0ee8bdb30bf362eff4fc55e969a2da7fe9d778e3f079a03b6e52da4a22865ba705c488f828042351b2977300ee6d58abab7136c7c5368e726d7a3f2a9c0656e1bd698ee4a08a0ede4e683153bd3c4b7114a2ac66ddeb8917f60277beb2dfabaa4955f9da18ce3df67c333a4bba905dbe78466850ddf70d8795cbfe6f4ef63bc05a4acf70c5c818798f9d20f97f8afec4436cf1a7c10880835ae028e16cc21b5646c3ca1c09e77c9a2d8123de7724a56e764420a1b9fbf5979bafc667c3834ac2eeac890992e1dcd209d84cffc458b36daf51f22e01c347aedbcfbea0f66c2f2402af49021d2f1fee6b699fd8497b529ffb8860095e2472a194d5f172cf81ae784ed869de7fbb0f7c9e402c2dbf649c8b16c8cd626fc52bfe9f41d4223e13f58189c26ad95a342aa091052a9da262e7ab592f562f9d9b9c6db5e31ee72cff1331b89f58ca0778f4d001a699c588020e5518393f1a9248361936cbf01dc8c893fdf31a9cf88b509f29a1f484043981b675c2dc575521b441baaa8666d94b5713ec7bb7da780b0dcfccf888ff41c0ae941bd816347ea25715bf58cf8977fda05e2224a256a30ac9482f357f8817d2838a3dae65afbf5a01697f0ba0cc52f1060382d9544f29c8560050894d704431c1887f8d3298494a4dc53647afa8c70b1896a907efb67958ba0ef802d7aa13f32af3633db172dfe003832d42abbb32120a7a86c08fbe857d0f124404868c7ef4fc3ac6360e36a4f12c7018ec0c6089738583385bdd5cb3c2c6a275050d5ff75d37b8dedce3860363fbf17bdcff86a5e8a3d65f4640769113e84ad6d61f0c1b92b2ca43295d3ed062d122ddab713ec4f298c01470b9318c0ef086fdb8046e8fb66caa15484ae4d45dcca280c2d6435cf18dfbb5a9409a4e1d23076ee01a2c94ccff6113f3ef109d0d127f5bbf3f68b36157ba0cd8ea4d687348a9c70a2d43c53c37a039cb8df50a2f08f4c462cae2b607a7365ef406332eb5f0a54f3f14577cba06cd18ac4fa576c86d4e6a8bcc5ce836c26fc10cdeb9cdff8b0cff3592fe24e188a953bff3836374911c06cb3c26bd2e0945027453b3d378c80af66610516e70dc3991d0b63e3345e96aa2b1a0720aae18f328dec9f8821f66867f57d2d61f9c2c59f5b3695e73f54884e4b4264b606e5dbdd8f716ba310b3362cc3fb7d352d5a2ec497480f2872cd488a76f0103b0d5e0cdb84e198f0d740f7352a1e4b47a2551a62853bf3aaeb2cb85cb76363b2fd1c2fcb68c6fe0192cf0074a597e5d7c5e20373e54e66e0d0dc2174fc54086106368802914147cb85d90fea0134864587624e2495b99f828081fac59018c2dd394cd86a64f49a7c94ba4cda7f3b3c57d6fed590ef1930128bd0a51b97fe36b5a1b466cacca2b59dcfda4a1b053abaea249c5312fd8742506cca43a8fdc79a050aee1e1b28f71a1fdfa3449af210137a4b36ed8331b68e5ea5c80d4f0eb1d68ac22324570b0ee9d63f0ca3311eb5c01a149a0d8219d1faa8b993a99d463e0840edbf3451d86f783d839632e4e6f44c5ba788ca776ffcf3a212735134f112769a2b5142d0be8f18262bf86923326d3cdbafdefb89a9449ba73725c4268b3497e860c5eb38179e94f28bd991ca519bce7fa43d41a6035c8b82b51cc4b1f58da58d74a5aef2fa4d0ae9037a13c60694a3db4c3ecc4d754736dab01b700824d013344390d18e8d637dab18ce4b88e29750a593c462698607b314b3ae1dd6fe95926d108cf47e4a7f8f64062f9f7283ae0d1e738a00bcc3e891ac3f79bd1bbdd17345aeff580489280c9701c142e0652d2aed9b755cd1ea267d06bcd6b53cb9ebe3f0336543a0fbc684dd7bf5a47a1495580391cf46e445d8a291a39b5b5ec1183238dad6dfa97f7a88e7293b02df7ff3807575b7a322e915e64a561ae7fdf858fdf54af80f076d6479e0e25cd3fd94e38183f07eb2b3ef7765b86b9da54270956ba49aebfe3c682704a9041d5b2b803ac1a088649a9f55c9f11e8aabb164af15bde072c81febd9e71acb0afbc8e0596dd478898403e150a2724ff96cfeb8a44a49c58d595573f04783ef15852cf270103fc84b5f08a5a36591162875aaa0fa5712151d8a037c51c4fdbebc1b5498298228cf13d4113c37850546c3f653329ce761a2cef643fef6e47a18970aac0ae4b40c6c7e64919ba6ce90ebbcb23729b73dfa5bfcead289b82d276d393f3236a083d0a38a4ec6b5cf91d32c401e380a49c0399cd1455f3756f677e1949c53a17da8f9935afc250fc4db8339a51700b47cb4489b53537471a5e279caf1331dad9e98a69fc109f79c6b11721626125bb2340bc35e70de7c11711bbb549d5b19805fd0ed520d5c04593a759f6f16c3fccbb22d4a3162bffd34375eca8372f97a7b0ee9e4800e0861457417f5e62d1feb7261b2ffcef2c436b922f975d3ef85a8288935c3d6d995469d18e9d36ccdcc4a8bd9cf1eb329117e60549a632ec948541b7665c52a1bdaf8c7172e84977f2d03acd29a31320447ec2e7b633ce71cedd3a446c4e48191493ead10fd8f26fd2aea58c2896045e88317d1ce7c5bcd81c68d61656f09b87ab1334e69ef123304e279932a6c27e600ef4d2768c7a254720707b5854dabdf80a8f027f74c1153806f539389e174668fd5e728f41b5466447fc285c00ad3770cbedc5a54a3d9b5c5ed13e0b05a0ce71e71a88709f75c3c0c6c7ed1b1af78531c319e48687eeb72fbbe7b2b2aaba8f68d581a09d7a0ec66a045e2e29555ba0d3e49d2c7cf77e222ded3bead37b436538a8a1c5d05f792a49df0b6edce18d819d89c767013871e8ea6bc79c3363b146451ce49cbfcd70d03377631195647dd53b79c5970f85796262fda3e78b8b491598ab54de6030fddb3cd14a2af9e8c023c5c4ee80095669f7a1d7c9b482cf96fde99e27ed4a7b5d73a6362ebdfc6fae9c27ff0d7659621d3340db2072a99659c761c8525446a478cceff961679071bdc88032588e2aea9164e9e1b7168d39bec65da39d47f2475274f2f34ba1ce8e8de46c9165d403d6ee50485f4114915dacbc55f0241932edc4313615f7bc1b82c417be024f0890b83063ee5574eba85a957520153e0f485219d0b97a586d1f5eddf0e041360afe3fe1b3775b994f2a2dc6d96f7af98940a5f2d82a308dc2487115b08584f29b6d77b671b9cdd319a746123a31a84590945b0389baa6b333180f2a06f7c0615c95bb76950fdb19d6ccef1926b924ea76ace3fba8d2df23a4205a262bb8d13c77a9cc661de63cbe1f793a5c3e02f43fa55e1a1c31e20a99a77aa1bf8dadf8808e39894a8970e9c479cd1b46d5ac73c5eb2167491beb25b2c147f7e6bea81b07d9b15635d8596a0029c7ed5f83e0399014dcbf730cd9c643dd118522008b5c104700a17eb23dcec2e6398e20004c5451c14c78f99770dc59205813cad51174a1089799c8359dab72d699484a077df4b2f14b804e7f57c6057de141e6dc81d00e7e93b6caa99456e8894a7b968ddd35db257ba695f3efd88c02025ebc7d895a934432991b252a0db003fdb1977854bf2ad4bea3a706dac2821bf4b410b5084decfe63fdce68188a18addc17507174417745ad5c97dba1cb3f9c27fec7192be68edfc2167d1d0b759801f816c618fdd238d922054b912ae20aaeb096e105bc02473ac72f8c2c1c8265393b168103683f326fe2edaa7de1747171fb766c6ff65a24b207213afc25e8c708b43aa2aa247e778ebc62059412983ddeeb4eb5c2b3ef0136322b3fa193dcee681961569a0950446b65366d23c02765b9a61c8fa0542a1bb1b7c6a00b8129750503d3a01b4e4354a68a1a91123c24cea9794f1551cec14a2eb43efbeb61f4d91e14128b9339cecb26bfa32f4f0474b70e6c39093880cf99377f048ef7b8c640a7c2b03999a7e987876f332b2c6b35556649a1505eaad3237abcba92e055749024106e2263a2d1fc4488f78a2e4d788de26baa414e0cb8afc756f0e34515ca9d1290de37d63d5a4d641f4fe6405b8445fc940f36d6c209292702fd11356c1fa47e168301fcb3d9ab3a437d2f589acb0301d439fc6687ff28a2cd5e1646cebf9702cd245e0598dd0d46be190065089895f5d73fe598b5ac8237baaa30e1d43ca2d7a583bc86c3ab492a9914cef8d1b96a0ee9488bde6b3ebbf9d79c817e2a528650f0b051c7cae84e8257f7d073847317b3e5ff8f1031b0acff754131d813760bb6afdb078340e1fc86b9117fae0a15ae9e9a8379730aa7c9ace484069b4f4a8e1890f7ffa09a61d7300549e7216cd8b6317640498a90f9f120f7e8ef9f626730d84d23fbc8183cdecbe3950802ff4050245302ab3b7cb9328c2017b54dae5a097f6fe2edef4d67639a55df17dadf851dacf2bb24d3966bb15eed8080d93d6e10f3436de0a19b04a4712000c3f570f8542ee4e8b570c367826fe84a6daa6f465ef90e315e400ebb239eacfbc4d46544b3bcb6ac48b3122cedc3cdf1e2e77fd9b16c2cc772ff2c52f9b3d3fd976b58b2781ce695270cfa6807ff6a14dfc69135482bf3e88823ff8f1f8e89bcaa362ba3d0653d238bc9cb8277a2633f9d1833eff88cbd554118518a45f9feaea6f2682849b4a8411723cc83b81c9c2bdbce45cdec8345913d8add7ed4db8859690c9d21d8016dc6ef4739fecde74cf7d7a0f8e4f67c86c91c4d4a1872af575712a00145dab30a3ef3311c968bc1b0ca048826492bb02a78f671e5a0d1ce79ad0df1322f5a04655215dfe04b7b260918c1d8283b09b016b06576c000fc3a46f14875c08683c9ce9c86ccc3907f5a76747f57f46ef74e2929eb3ea3ddd5f702bbfccdfaced38abeabeb752feaddbba482c01b55909f181ebe9dfd0fbe8a8358f089d380f1d1417611dca2ff1d85ac7b9fe28b07126b778a54427a3f09d7941263e32031a11270b4604ffd2af7afdfe55406fd18472348ead5dd07ce5584dec4aadb8fca28a248d7bff5a1a6873be01c11e66980d5f4cb664eddba7c7342575e327756fea6a3ae9d13bd058b9e17dfc624740f80e703cebb700d5df9663addc4a0d997673135406c0a70c08bbc5ec6e23aa9268d174dea0b22df0d1096b481b963713c39606347edc6ec1a70aefb8d8b04bc7dcc817b0fca4b0549c9c8fd3d6f1118cc1c59b38adf6ebd4ed43fb48ea1b7a7b4e49bfe92dcf6622b54cf9534c6e17fea634cfea99005d94abd4905cb3bb787a66a5b9e075a6d617448ba542ab25d9f27094c4c4f9da347767c96cd8828f5c48e9057cdefe9fda31f78835c47b6edf4eed6d47d9bc0eb80cb91d15a8214756d28364d3a3efa47725315ece2ebeced99061b40f4704865c485f1e4171bd5f276ca8d93a12b021acc93e78ca7f28e43cab3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
