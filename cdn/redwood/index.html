<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66c2c952a323fe26b9b28b34383083fe8a729a947ded9abd540cc9ffe3cb18dd459d31ad386e47ff0b8056c47b502b2e811792ad2f8a6a245be81f5a25db2d212a263f023ca872312e9b89bc555bb02d58f2d91cf928a8afd6fc930e1005e1b070a8d6f25be94ce85ea4d529e917d3442c51952b7bd3ec6bb981225c14a60942247a8c713d32e3e3475b97a1c0232be068257bb2a15666a432d13d3556a65f2b412018fb89ff0f96dec2cc57af0b4e32df704e24964a5b63325f85f536be53cd4428b0c4a3ce5951044711514c7a24df98f7640794fe6f5bf80446fe07ad31c7b8a9ff9c514be0c58703a84d0eee7d4b9c31200ccb3c86f05d1d64408a2cde6be3a95a18fabae224e48558ae02856f5c25a27673fe74044140ae7c60dbf8f96eed1c20d434e71386d308e5ef132cbbb48e97943e26a06b80bda9a40dd78266b8d5f8c081d43370b1ef8f3a9d4d4f8f9bd37afda44716092eeb1956689c081eb83debee9cfd8ba5c5d657d9ec7f6b94761a30e8391e59c5cbc534085b5ea04960c5e71e5bb52d27f791b9acdcebaa593561accf21a79452988990de4610f104882dce4b6950951fe50e1000822cc4505faf5d39cbc0b66571b1d3f42f67844e384ae62a78e4499829ddd34f77f3f249ea9cc6fc439d8f144a465c3ec7d8c9e93c5c711b83081e8f16bf07f4b81ad2155ba1375a01c6386fe3ede25889c86220da88b84a41aee0550d77dab6bec1c9578e3ae11db6c90b850357264c2fcb18b73ccba06f006a7a06a4eae55e7e28a0bd0729b3d3aebfb802469b69eb58da749997e8a8902f36b51c572aca523a72876f85ac52221b03c29ab4aa711f5ef4894d7e6a10b37cc8f5a67681fdc54156e29f83df0f6ed7d794122f4a00efff4274239d66890248c1404a538c178ab3e8c089feeb42628959e38245101573f456d476960e581e5c3396e91e398d95067dc56f5ab0abd55be89d86e3e8f6ad7b7fc61b4e4a557d1d60d646ec9741e1ca0bad38c3ca7ab954b54eb67e7ddbc3a850effa67d65dc3525884662e562a7b59e2ba6e59cb3b4f3fcf829d0ebb65a7f864b3185ac2e3a41ff5eaac3146959fa5fb8367dbedbe677ba96fa9302fa3f3a0d67b76c07acec4a5af8d5a2eaf4afa061baa2face3b9feb2b56cf648af80370a3d1dadd87486775213d7dd1cd66802e6c81f35de8138eaf6092242c5d4642266594dee2e2065a545419ed7c0d9bf1bb446746c9f96ef1cb53458060c754ebd5433965dc35b98cb4d4f784483b943235ed89b7bc7a3345521815f22845d0bbcd55141398726129f65d1681135febd8ca0e6f736c7e3d31a7f1b08e3a93e9bd7b41201bb7cb65d6489c3f1b89877f46cfc190197062e3c923506228f38b70c82901bc6b0f6bf41de9e5e46f07ef6931b3503af7c2e6a3fb3df63b5e1ae5979e099f08c7e0652442d663824b3a5781c74060257b7bcd5e19af2f1d746edd3282dd6550219b15b8c90d5c23691e919720d097be8dbdcdff561fb64e1648e995f8008c8001d801c107b34fb3c01dd8879ef0b6dec01a79987fede27a484df2e1ff4ce23d52ddb48218f7bd3a01b40a5297d117c09a4e26f229150a934fa065f72e79024da79251712767ef857224bff522cad155e78d384a88b7f4d63b07a9a29e9029dcca4bf3d391bff883715d5a1d58802037cc7cfd9bfb7d51cdeb861396dca63dbaf9eac6aaf365d8545fc1b3c00f74b6a3224255b6a3320478bf48e712ba82755c90d8abe1b5f2922020626ea6fd5d3050a57a6b75f1629574f8f9d964f4e811e5db33765b7d5a76e8e300edb6d5815c8d75c673087f52af11b61a0a588aab341862e231a26f5fe836ff8c51c446abc7ddf4b683a1f4c2acbf8ff01743adbec2568188ad11ddc53586c0a48e0333ea8fb24dc341255f5884b3869b7a87d3b3f8185e41502b3b308801f89c8812b9737be7d0ab3c8438dffeee2678f65e8d6d9e5c94590333a405ad49db8b89512aa33f88195b7579b4db325660d2927eea12dc2e110e0e9013c07490c13b9d7dedce0f1e2b613faa0bdf9a57eb9be35864dbac6dd569a96a94416e97b952ec3c2752247a286aa521717c8128717d12d7b8a1d57d2f0326ed995911c768fd89e0dac5dbf4461a672418a3ba4638f9d4d75c516b482e59f912b8df570b42bae5f40a28399cc1a34578845bfee64a86f4737c9c782217bf24f67dc3f18d37b365160e98643afd079f8040aef453937c60388b60a3523cc47b75f8ae8148222678473994bf8c5ed5bc7633168d0db7cf35727690a59b6ea2674cbf5616ad5ab906403fe5c1770c777fbc15e0c170d72812872c98782f9f37d9feb9b2e3172a4689512fb356ba2fa8e8d56bdff8a3d2090b37306bc89c96b3f3dcf965e047bc5ed595b3572ce5f422258d9e725f3c0863338919fe8fb7d6da1816368721abc607083db96325077babf5d0780055aa80800e39fc9a9156492d6f23cc020d33bb975a89115ed4751853ea1556ca81bbc17c36c40686b92d1c960133550c306203752c6faf9d71841916abf596b2d99dbff3aaa5a1f2e8a4cda2d222d9e3871bbcda6da58f81111c63b4e7af0a82ae8a6fe2b04986f5007fce68a7f519375b0efaf3370751630745687e59a93dc703e215fa4f2b0f7bf456311549956dca8a9089a308c253d5585b14cc62ada7930ea90347314c12c938430fabebe57a1613948d334bd4225673d1376a2500f495862cf9b2fcc48e54d0e7eebc621a3fa77b05d3a436772bc680bd649719e4394a468bcc684c11696174f36fddf66c19dd6cc5fdfa61aa26a932ad2dbdad711aea0677069b7cb1f51a9b5936f7c61e2a940820834af674546767cbd795732a2ac7ca0d85b2b8bc3f8eae85aa2d965047a357c3315c9029b05265ab2ad2bfd09fb283825a507969a8e96f44f719cba8411ce727ef4384dde771b900f45e32ddc2fe04b742711e70b3957883b826e3895c116bb8e7fc8dad55fc70c145406880d6e0aebb9584d641bf5d66553763d796bff68070ec8c6f784e8d44268f43e3723ec755f538439723cdeecc507e593525613e40317f899d11d13b8fc3744faf66fc539313fab88ea607d8ff95967567e29dbb81c5f846f091f4ab71dd1912f127566de5b7aac2305645d430e2e54bc684ef671d8266bcd0ec9feec12a0fc8823c6d32bf8461a31b4e8e549c94b2591694cda0ddf19f2f0c12c1d45fd1f3c0d3dd353964f5c3ee3b97f88dadb3b8096ae0e700f48f529525cb2155af46a1a6feec43912d3d39168fb8f5f56bf285b03788d715be2bf82a1d4a1ff7dec42ea3b39ac185e770f7ef9a1387c3fba8514ba52fc477a663750d02a330b343d806eb7018da51e0a0f75fcf57ead86c6dbafdbc8f84bf4c14672f20e2114aeed66c4416da5ab5aca3e637f4758356f78f7360c7342e1d55e4471c0d2c81e92a7e0bfc3096dbf744b1651bd49fb567110580528009b65c0e5e01d4ba6499235b1e380276050998a9748dcb347ae162dcf37260187e504c10573a9da85e001187d57df45b4b7da978a1d2ef77f113be2407c22500c7e11567dfbf64e241bc87a982f2f5020068de75c907dbe42b7e4597aeeac32fa198501e8d6601dcb8fc60ac933eadc35d3134d5127ee5f9625f899add03ad8f850286f902cdbae7567c2c440f20e5ca2693bb2dc677155c6bb1e12c876630f80308e1f35abe8e5669fe7d35eec70744c8cb50c8f5040b2999e6919e52c8510efb0e5036e9cd7c3c480e1f231ed39b9ce22b8fb2c624276d9a89cae41626d071e321680bce293de1e944b26c00a4d4fb699d2d5290c1987edcb9e6ec4463a0a4455c020163031f3fea18b36cebe86307ddcfb9acbebf0a1c336b09faba66fd89f8289abe74bf35e75d30e7575d3931a875523f2fd0cd68098b136fbee1bbc71c584d78e93e5d35ce3d9304a62332c074fdc0e5d06751826d550473af08b7bfcf734a30f19094418b98e28af2f497dcbb20fb052d5c45c38b7b77abf80970924e7f7d3e1a133999c3fddacb93ee1bb109dbed651c9df9f7f6e2cd775f825061c667dad5ec3fea5797e9ab51f6f201d36997120fc9c728ca53748fa65efbf300c4248299e42fc225c103855d3db00089424c3d95bbed16d1ce8630b4055b13524b585e1fe1930e9353f7e330b5a5657bba366b84f91f7bc17932923df9e27073e858f7dacbf10171eaf4ddc21271fc645b20d5ca5b628deb91cfaf9bf6f39c3019c6a2a9528217e2f3813abc691b5b3613bc1c4611bb6d55c5b9cc17c4cd52d3221619eacd0c3ef57d9b2b311dcb33d4a477a19807210c6b8caedf0cb54efd655f488848a288471e1342236e7a3d3480143a5ddd6202e3c098143214b60a6d2de87efd30cd64feb5fd6abe13eeb8e4f2d78842b9cafb8ec488b1435a65513bd80715ebb4cd030f20577ed542a9140c5887d053302f92a52b01f2e782f3b6e9a443239389d810825090a96d4cdab280a2d6665d816969b41ec4a4615c4f86e816423f7f736f341c5133492b8abe08e4060d8ba1d063b595c1770d8f6201d52f72eef91b126ac101b328d51231d495cc5cb9e5c2e21613214b0ed5da71f93d510a5b93da805abe0e00b32b5f08358b58c7c39d65cfad391aa1259936bf791817209136d34e58334a7fd423970c1a03b12a0904bb78906d5e57d5394ef7448f4fc49a7f50a8901abec4c9e42f3608338ef783d1d30f20b3f5fa37750e2e82aad95f3793828864bb9f1534da1ca82969d18b8c6c91967513dc18a8e998893c80c2f7dda82f9ec15005f114f20f97c49f46ec413b57f64246c94bde584c2b12265935f0d3605a2fdb80a2203492b3a15f6f16efec6ca4510e8709a1aba7c0ad7cf0ed96a2b3ff7a68c128783a1f81ce24812097845dc0d6008dfb80c60de0bbcbff97f2f0df8d6ff56311ae09681f1dbbfcc54f453dec46e58a8394ebc9405b251578ab3e8b3b5fcbeee535abc1eb32f78ab71c9ace17789773aa841634f25afa7239cd84c15eb8da4aad2e02b6eb88c27c839cdd74cd9044c9214f1e40b5695c2cb568c680027059530b9134a68f534e43efaa57dca59d011ae59b4b54c4bee63a97caa8eadfe2618c5958e81dd8a839afeaea48623b421a225fc0c4b3b58fd20486135decdbf6b70711d80b577298da4aa873930f3b8e560db5685341ced6d300b9dca16f2d73418de8f064970c5d3bc0d03f5e4a58e5874d25118ab683c16f9c5d99378c62390b4013e3213ceabaded98c8b3cb42f164b6c37b9c45630c2773dfe4234540aa45c23dfdec8d3e4fd4f297521332e4b5e49e276afc1ec0ca343e5cec96a4ca17c0e67fed7307cc7f8a6ce17f22ecd72d3c81fc7b3cf4e1d77ac841eba957a9b3e31c485dbe18ce58515cf8016d115950412809101299fb0c40b25d2208d26523fd5b87fa963c11558fe27f674e33969508b95769f1f52e0b0f269422e5bc4cf0b1fd8a6cf5a4b310304a91ddd2718cfed1b03ddc1cb2577da8720c287c99404bb9af1738e80e79b2083b8799822442efa8301f7719796eab9239d6794ebe5a674071937c779e1e136bd96727a67a6f6b5a3e8b119196ddd89ecf78df9333f239ef8fa2be80a573bbda65f70b66809b1a8139565620edcf650fb36c4c49462e8faeeb32c8acff198c2317747cfb45d4afd04f9358f4a4202daefa9ccdf7e0d2f12de59e938e32a2c58a2bd3cd94868429439caec2294b15cbdb4c145031a3cfbc2eb17a48b94eb2b71d6bf43abd1b3282a017b2806e5db1fb76b2d251156c855872da05c32ea4983d2e315b905a3ca6a186740dc84748519c7ded39d399dce90836308ce24e01b21622b34dfe168eb1a17a8189bfc7dd4fdb633fbfe58208ad73edb622a7ce00a2e0cb865f6541c2fe7f92098fd30b5f7de0d05e65ef590d339919aed93c71bd03a25c8ad9faa04e3c567b4e8e5edfc166f2b9c3333425bf3be59e8edb4285f4ff7b7193a841f484cb401178109f04300296b19c08684439ff17ef82225eba5ff0222dac8747c7c7de564f28342fa9e4c24ebe110e2605e1791f1c5b4b420444c8479da7469c1978e14d6abee8207b8614cd48f6c24eb81803def95009c7b1f5417389352584b567aeed6af676558042bd11025f2d165cf1c4611031e486fcb7d72c692cbe95e1b90b20a96cc9ba21c4a16614f7101344a5273eddad03000e444564c85cf3ffc53b5dc17f6b849e7f187f51cf27a2b2869c2a914e3a0fed8cc7d3c86f288cc3a8a1441be6d9275d9503c54b9bd52b6fdbb560ab993064360a3dd0c0212c3b83f4885ed692921b3be9624d78ecedd093e5b70771353a402b8edd995a9f6823e5b97651fc005cf7c46c76840106e5d96bcededb2cf77be9d9d509f15458e76adda5f8c108b566284d3cd29a448af049ea03eed16a597f3c1a782e201fca1e9d64eb98685c9ea82cf27751a92296d14f42a0b6f5a0ef73077be931ba06179e6c56867f133a985194b51149ffa7421c53fdf328c793e9b11d038555537732377b33bc7b7f9a5dc4c56397d329bde8f4a3dbb58a5ab3a145bbc8afadeffc15851f115a4de2ff8741f15b9c25600522f55e7ec8eb2a2e0ae53aa1857f4dd731b7b641a4773d761c8be2785793e05283f5ea3e788129df0c1e122a72079520cd8f3633b2ff3af3d413d705d1b34d85754bca0fe3536941b866fe8b62a10ce2911b427554f366aae0f3fdf4ed326f803aa921d4569b5c9a114f8a8952f0c88b9e8f02cbb66dad14fc9972b868a45bd2d1a915f2e9bac55f3e8952104b30e23e6792343f8ad9a8371c2b7561503e933c6587c9e196904df7c23f0bae2f1d7dc4cd702a3246e22e3b78327517bc963290980a6781a12cbb4a74b53be7b5615a60d1cda90a7ce936566a72f75fefedfb7d5a561445ce3c05392b63230f434d7398af307b880b43e78d164c2f8ef8ef44c35612cf6e91a3d846e61385494ab231fc79d2e2e8ce614a4aa615191e0d0ff9011dc0d249e0b39e64c4718221e213007ab07f28631916dbe693cf8c7cceffe0ce1e7acb7441b5097b78bc0b1000bd27260cc711548989cc8bdefbafc6f7027000392d56894aedfb7d38bc6c627aee3ccb5cafd150431227e5d5108db6d3f614cbac86b47fe13766aff7316389084d9659cf1a8ab449cffbe677c38b72bf0415efe64003f6c917e72353090bd176d792f5729488cbd3a749afa111e72a2ea07808a7e05f89248fac6b353988a1ca82fe039e01a66c5bf72f94288977fe7a5c3e19560b906b532d275a6dc0d75c60c96df519258726c4f5a73be7510ccc33a2888f531aa3414fba81f2dd8b9ef5c2509982a1c9020a13149fe1c831a5664634f54816cb3696271590487d6142d7f267214431e61c5b1170f6942e6f6c4567c8936b28d9e4d94d0014c7d08649ccfd6afd6cdb3fbb9faab3e9386b29162ca6280e970fc59d089ebbe6fe630356a7945d4732fc1755b9a448c3632467bc44e0bfbb7811dbdfe66073ee46297fb62f9ae461cb082b70dcaaad04eda55e4614dc98e53b1b391143bcf8527c903c0a6c3f5229492f813532e9e12b7a856f38b10ea5489bd2a0c5eaa72f6381f097e82cdd3568d4502eff28f04a8df1826dd45cfa2b60954025690f89ea02b9afd8699a025ff921d182a6fb39f574c6a8ac363d740abeda153d2488d2508ee21f67c4052f4f29c9eeb948991f704539e66320bf685d5d752d9df35dcc02183207a26a1acccf2c31b6eb0bfd2073394ef68675e21da6642f131794caf4e9325697596bee81ea288cd83c0fa9575e75a5fffe9ef690d9b66426ea46e7ddfc193f8bd1190585ca80a3649e0cb27ddec9f2e8191616f1f99cef950807209a143f7c05eb5ca10b08334129a5ba0c59e7e5f7d55f0299e76572ff87f332065b54531833b0a0588d4e099cac2d5fed3772a4fa99e750de947bb2aed2d7c94f2e2b8b9b44e540c06e0fb826ea763cf283a47c42fb2dc213b0c78f52fe88526f55006d61fae450753a0dfaac3c350e4f91b8bef4bcc442978a164a88a5f0b061920c93de8ab403815cc85a83099fc8671057b43c086e63021146f5706bc054215f0953ee224442eef132954131728c1bc1b7bd55a219d3a66bc12bf331a25e099a4e58048b360e0f30401db7bd9e24a0b2c91807f2436ec5dc7cdaa4781e5fc9f01125373c368d1460b989fc7105f389e7250c81f55922c672d71c98baa902b480a5660c6049e94f322f766adcff95f725a7e6f593cc444564f320d0f413ff6db19b24cb27cd9520b18d8006529a98b0795d9985c2585b73a68e1c5744200ffe3de13e46b11a81687b5fa4d06d0eecb218771063528f0ec2cdb7675cc68ba064bf5f9700ed3a04783278a93ae298df20d68994721597a61b593878880ec4eecf48fd88c4c776ee322cf2008441fafda70c83c6e73a9d6b85cbe5ff0d3d99c7a322d9bb3a4caeb4c2264933f0eb66a6be8504c1e97ebe0440adf6aaa94f3c75aa10c586d8f26701721583641f97b3ee9a3ad4f03f74a2a37e1ecb758a3abd79ebc096ba16ff1e9ba67f91d5d0cee4cbb7296be2d9272eac70109ef0c981b0ea06b2dcc139c1914cd69b73de1e8f62a410381cf67a44218f78bd45b1593210f590cfb4e09b6211845c844a81fa0a3a6742b7f2cefccbc5179b6e78e17f50497da564b289f32268a83a449beeb520f2cdb8cd92e5e29871310293831bf9431b3441ef2f787807abf61d3f849f44ca48f6a8bd6a305a9a2b310e454a0269eb330f0eeeebe4f0b1a5194866caa9a48f8c74e5f72e31bf6ca914f32e5c48c9ff17ce9dfc383ea7bbae42de1ffb2bc85b350ccb9b0ae4802cbb5857a38548defbac248c14efdbf9e8862b5297a98b6582aebba8ef1258e8bed64e68738529ffc806c1c0e9369042ab8c6c26f6f52833b19c71fe4b872200a16fc3202c0902f4306043a0becc316702899ccc33e16266dbdd1418a0e66b9a2b641da9400fae53631a97d0ef80716b97caa1679401faf4c51a93c6fd69b11a69593000db08b4f474d78871113cd630fd8496c2297cc5bfe1a06b275bff8743a4086b99554d342c8b307d6346a3aed7e2f69b3920d6682584524e75bd8f4af5cbc82f2b96a9f91e077b0bde0d4672f4f1d1f6c717f28b2c69de4978f72a3596c0b1bd9cce5567938440f916bf5fc3bf548143f0f90375c07c13d900e92e51751ec44d4e9c62546075918371a952994c778a59d962c559c30ec61dbf09b4fa7e3861b76f2dd17793afe307e6a4159a57ad7cbe74005139ef5541ba0cb3bca59d5547270821dd25017edb68f7fc95de3637b2aab83af3b7c42592e3a11f85e9671a5bcae2756324a1e2f77bc8770ea095dbfba62d4cdd3ccecfaf08f1ae06f15013d936cad561bfd372f367ea77eea18b15b34277fbefc9078cf978f0775ed62737df1e5e7781df3eab58a7591b010d8d8f9e9ef43f07bee8309b1a3ff2aa713dde8acf40177915e210752302a28d3383fa82e0ef3b48df53c99b46f298970c4527f6851e7bff20084f839fe67cdcb168a0fb61d3479417cf6808a49153841be13737c41edf79129fab716d4de4a7725525a75985896cd98b268e3e765fa607bedfda5cc11d0452492f29f0594e694142bc87e0bee7dc400e515aa586e7c6d267934c595e42d0dc6dfe5f43f266b7cbd3a3fbe91a33569ac1e284f7bb84267bb490a124d6ff4e736e00c85ff8a0c33e36bff2f8fb94b99e60f558b9e37db79e71b453c5e925f94b10845e2e0502a80d0ca425684c345b1b94a405d24ace27852d92de431b190971dbbb58a57746cedc7e4cb3864f5aa147d96144a6b96c7f0b21bc40d3a163ce0506df83fc98b305e66299b1c773ec2e53787abbeab8c833bd02684bf96c05329427a862d4497772147ac8dafb54c50a61e006706d9f61e9d60448637aebe69212f7360a85d8084f0f1fbf5e16db6b1fee644399074d7936e7e1086a33db6f000dba681a6249c1b8c1cd427e66c07b25a49d0cb7be84aaab225db2fb3cc711ba6f212a5ce273c1d7f536332ff2acf4e2a9621d52b9a317f7c6fbcc53da88796ac3ad66452274a4de8eb44d96266d16245b1d2c80f3942c9f392b0bb8408444a4db941afa7aa5a1f061fa6814392e857462ccf07b8708c5960eca5f5147ed4e7ba5d298c033ada4e9b8296fed2b62a0070be06289ee70a20ff8e9efd02d8900b6cefcba5a1f118ead23ab5f0c6530d8d8146296789096ed8b470f2543810b1009536ced6cf5cf325767ddddfb309cf79ecb843a8af8e75e2b3e6cca996aa09dbb0f1a7655ddd96c85f03ffc5280edad6b4e61a159bc1aee853d662e317e03c3117cb8ef733630e6073aa2e42157c2c2a28f6fca4e448a46314dbb29c86a5da9996a09d45c60f8cbc7ec782e98827eea50a302623db4dd3d008053e94048f2cdc4bd90ff31cba7582202a66768c59ff7ece776c89a33a07ffa0ae32a1e2582e1fd0be474aa46cea596df05c4dc0693f6ae6a536e600b402669ae3aa4c426583b0bd20c59beac01d4b7c259842da5b724af256b853494fbf36de9b89dae7a364f7ae462fda030a4e555832a1428358f4a3f962349dab61bf47a1eb057a9a168162925bca831e6e0624487cb5103f0d73e5bbb06f84b91f76208b1f76b3bc9ce426ae56e0faa6cda5ac2736ed358ec3ba37ca98dfc8cd774f83f7951317d959a5e67b596a5ccac1dd9c9b541dd99f55c2863c60c90d329bc45b7623cfa5360ea770ca0fdb91933f29ce6ac122e5ccac8cd48774540bf9e4f9e214ce52cfa07b8fd5877ff4678dac1e26fce5036a55e434a130027e99d6c06598aab4afb5505f0f1930d6b8abd18c65df8317f9798345e49dfe2a06afa7436d0708b5c60cbeb40135bf8aaf4df319f872e7283bef7012d8a4ff4a74590b16fef250a3928fa0cf9c64a624e5e6d44b5f8993e72fc7addd5d9589d5ffea6880d6899459f3bc3879c78b10efa38ebb1fedeb384458f5430ea4a023ca0a359f8b20d67f744ca7e1ff0fa3fd4dad82358fd3e5073c8610afeaf879523d855198bb0447c86490eeca40693cd9c277137ad439e168d2bde07e720ff711ec6bf7bf14fbe55bdf437e59656554d6ee1b1cdc55960f5612dd349acc0642d664209e8b3bdf791909a1af0d35f65d88a909d19fd72eefee11d25836aff597f82216ab859ce6def501dce436a0302eb7a336177e470fee57971123c1627fd1e5ff4ac88138cd7adb82c61671fb3238a2231ecc58d6603df1b2b7aba3d875bf75b7dc2d767086ad8413711e51249a7bd0cd60db985a3c60075229d98629415f0fb62fd67c17fead0a9e36aa120a5643cfc1699ca23918b0b2ef347136a593b083f3461e7c45f594cb8e49650abef9e6456a43f5274bf9cccfabd7fb2fc55f116df606a222a8ce97d963be4dd406f0e2b65c52904478d9de1651ce75df084ddeaa07e2caca79d501e63df83f7392373b9d4f4192a7e1295b72b8035ba804b0c63fdb485bb4e32d9691e31b90de38bc3e8b664014e58bc87454b4898f7a0d2c5fc8c34a543ae198a2cf8781e05d5ab39884b5ea0dc7b5d13f88f99c5074712161dfbc7a329978d974cd2f422a8dea656788afc9f5c583806616ef6db03bb0c14653ab43cfbcf6e9af1fa7ad32ec8e7505ed8e7d3f121bb4fb09731e058f7317175e192e12b9524cd1b6e2cc77cbad41160c10595e3f5b4c1804e80bf1d898b3275b9d5e55f6d0028dc92c7af24cc58d990f4445d5545b45dcf9a87fb0c5ae37195ed27a2c3da1c90988b8242d7970a047409cf00450734074813fbb2cb838a68fb1333e70088af53437a7b0574a812995b49d57c6e4c79454ea4cc0817a6faae1c75ebefabc2b36aa3a02fec57fd7453da042ba025491d960f0d8767d5c114c2a461bf964750525c142b20bdfff69baf26e37101bc593da8d58575097cbcf427e3f765dec99fd5609ba6d642cdfd2c921c8dd02cdc981e21fb7c34ad18e5a1c4f95aec1b4372045a24bf4747d6111c4aacf6068adcd7a5f12210bcd96b25c8d62fc97d192a3b11bb373fe2d8a1ece92398ea28d315b58e95e59aa655d6b976eb1a2e3c89db3f3ed28b0d1e98ec4697d03f3a67183e2a1ba155130c874527cd72ade489349f82939ced9f81934a561daccffa902b34b595600a83540e0bb6d8a2cee49c55a6519a7bc4286a5d03af4c353db47f937a1a34887b113a4cae0f2b0b32e444e89919bee0f08888d2d9f35e2ef66e3a7b587fe9d0ca29f52cf8edabb1735df66076793b12dbd73dd806359fea3f681dbe9919168251c14ef092a2ce43a83028f158a0f2582c1c90b8d51e2185c7d0003c28920c71418edf810544ea34d97299172baa722ae67d6cf962d8064a1f60df6e76a34b1b0fd1814c5b1cdf557378d2bbd82ba70d39ae3b0ced64a9ba2328fabac16cd17b38e687ae37f149945a6b6712422ef3803bc6170cbfde3e7d17d8b4bf53b3b0aaaaed2faf4a514dd2bf698e845d1f5ef1f7c0ad102db3a2c297f00a80a477d46761582b67e0c19f1c6507fe244d3c8a875629caa2bb711b982df8abd306196b6195136956eba21be8636e02f50bdc33c255f63ec6e61e8a95de9f4d241c3b7d142005196b3fa5f2b872e8d616eb9dc722b778bfeb3e1bf99e0e448a61609573a282049d4f372e28c03971b5f6e329f65fbd6877b680489ed9fb86233ed46f1afb52b58c1543fb9b06018c6e5cd84d3be49d808454dcbc7f81b37412d25cdb73c895be2e91ca8f2f925f4b53bf7686a6d29e74c6d3d4d7e1c4cd356196a74e90205c5e53936226222fdcc081360d6657f8ec42c239c898a84e051deb0b80da1b8df30a34a81d93fc3901c08eecd1d124f9650cf3a6fd26c821b4d2671225180c069392aa5dc41ef526ee1643ab42a0550164ee9b7190720b559c6dbc51a3fa4ddb4a60e4b479d24343b298b62feda062dd1037d6fa66ae7c5f40eb8916ff8e81d90f9a7147db6edadc9b1ccdc484b19d4c1e6757498da58cea5f2a19fc14fe86c4467187553e10dbf81edc0b1255849569751de14d02dbce34c608f3466e1946aa587d47cc58e59f94c0b0ff1546c4d2abe68f332e5181380b13d022061f360ff6cdbe933de9fa34cc26026cb76795b03a58263c4e55980055f11bfb7e89a8dedb5cdb5120a9a3fa951e9d97f3ad5ea159f1e46f956fbe40c907cadccd148a4d489b74e78f7bb43754669d14694ad166dcf0e5831c4bdb4f9767f51ac8beef836515ed830d455d61d4b9ebabd33071ed7327ad8714d844fff83b239d0ff98afad224b1b65a47432f28198461d36d584ac1e94e393d96b4b076ad9015434f881f2893ba1e0a53ae32b89d2b0b8d77b923ba352dd82bab5fdaa2a2522829ad32a8f075598f20937404c596bb70d6f86299ec231d3c4ef5bd4798d3a4eb68d116707631b5f39d144d458a0d83f4bec17ffba6d864997f092ab5bdd2e2e2ddf423ed1e33a5a8871b4a6c83891a1abcb0b0ebd293484d41c47e6a89de293dde24411718f7f822ab34132473c1f0fa6280924fb9ef9442ed9c971097c817ba7190138c061512fa7726f8e4dee4d3b9fa9541e19759bd60e29f9f702c1bb91ff06aa8adc6e036e48edbd8f34a31a70f91a8ebe675aa4d3ec210ab380a5b0f411e691912d01a34c0b529b79cf3717bb46531060bafb9f3a743ac1eca07e6ff3a40288b0e303305cf143b441072e25dfd0a4a6087b50e551877c72c2721aa069d43e429977fbcf9fd17805e1c6db669f26f638009dbfbf1ec77631f6d7c4169cb613e9f274c6bebf100745639a5c34041dc2a4e4f59a52cafdf5cc9040f8028a0fa9aaa6da1f3d72b38cab50c43c96398537376c70e3de96505b990ea91893971334ddb8d87371b4e347cf149bb028f9adebdd6306480774510c50a99104fb19edd18e70c26f21435ef93a167a8158d360044a07cb631c4be3aceafac9c457a366c2b91e8e65cf25dd62773a00d2e3d12be6dba5ab3cee08c9ed4ac84d3805268046944de0e7931243d2c57ae0e5d6b4942745b7733531e47768817eb77120d6b792d95c284da0b70f08ab3d939b229ef54a60390aa32283f400d60b3f0f453f76b043667b42939fd3f39ec16f051ea05d5e8b476ff95eaba2122c03b99f80e58408f17cc5c8b577611885b4e2043e939a4fa8d2d37e650bee52b2275c4f91afabaa71443acba94ced733fc7ee95045ee6364c87ab52bad6a11068abe84949ddda9c168c881f85751b751b87ea2eeadb3e53470e9b21d1cd3a82700a67ef6d1ff3db6929fe85245c55e4a3d6e55a31fc748a0a8043556e8abbcffd88b82c695f5f89c1dc0314069c2690bfcce7dc0c07f22ab44a5f0820d9350542ce5a8f81ef9e5cc042c54f66a111daeb7da1ce1a852da4b837e06be3fba22ffbb45894ea79ba7928da1b2aae8b22827dec02a1b13f45f4d56c1756c60aa1b069d921f30a8bd9293f29e38b5a62114737a8c982feb01d9a358fe3de6d6f7a80cc035b60faf43fab33f8724a9eca791a5f62b245fc1b4b963403f61b0e7e611b9f8099c1d4cbbc6b7958a66f0ef6dc36881c7bf5176a7a5bcf01290953530ffc7874386e13cfcaf0086a52c1641c894da0c3b1684ec40799c3d523023f5f7fc90f15f598f5ba5edb87c2b7f6504bc41e73d53298aaf35f34e58b6818a5493c907585c609937d732e15222bbad48208a1140075a439a31f775a2bde90a7f2c31957b47ec7b5138637fff37cd06dc87da81759d7f0e65051495c12f4b62bc01347f62265540dd50c1e6ced3f10d71d93204d601030a43e135f4bf5b24905dc7ad95b02a9d800f9b51d46b19d509cdaf018ef70fffa58d83f0520804ed9ce188fb7ec6f14e93ad13a0d4e15c2b5d6fc1f7418e0e1b10516fa002b6128a7b8117abe4b8064cd519ad733df0d259f02edb40b031d34f8830c3970ff85550867e7614cc0265f4b86338998985bbc2fd9611bf67c7c865a76b03752c02c22ff36945c10441b325a980cd9004bd85a1a6467b8eeed4d43b132a66bdd9260f1e8d1071ed475d535926c319b16beffbc46567d1d260d555fdf6c542977cfefb9f4a73083a53900ee9aed94ed41d1812993f08dc8a31d1dea8103e2e1b0b7c96566fc3893c3d622987d6ba4acbe465c79861cb28e90f33800f4b9db6b2790abde822dc907abefe90872c8bf9f96bfc3f34ddb5da9d97d928c0c7fc91e718f097a934381ede73bb761b21a9aeacaa2ea2fc3800b0017f48cc3babd0dfc330d459e809b340c2ad07ec672deba20da12efd10f3aa70b35352a73a49aaa3182ac4f94af338e91ca958f79b18c34c77e6b5c2ce6c0bb104e3d8acc12e8fca566186d79c548d5b0b5491759b956b3ce74ec54db3c4356bb8b8046710435e86aff86b158e265c7f647da96b5ded32aa91da18f70e62b4c768065f5e76814e431766319f7d35641031e40a757623d554ef2ce7417fc245f44adb2d52f72b49dad36e4d7f9f4cb615b959740b4fc3f6648e9e14f12f97465cfbd5e6f340406364afd43d5d32512c2d1128565ba355d92a96be207357e9fd5281d4f3b28dee26ce5bf4ddc4129dec9af3926c54202dce5b2b9e42753cf11915a7f6b8e6eef1084de9c2bcd8e05c2da1589c795ba9e79c3e9e5bc5fecf3e37ae219983b9cacb3f73d8cc199a8e669058db11ca7c26ccb82a9eab8536c345825301c824e3e79fe265b989f029d6d4381e77bdd29f04dafa707b2e6f0364cd3d84b90935d2761bb52b6d02de891726dc5041573c9ce98f296320cf569e04a44c21a41455aeb30c4a947bfe202fca0a50d40c935d0400d0993a56c1bd17fab57ec977a4c4727606b2e378ae53995ae292104d624c8899d40af103aad6936dacfbc0e1634672dd420e6c4d53a271d43572530ae46028350babf0444ea86302f16a4cb4eca4c4ef0e2d253d453ab383bddee280133596c74a08e238018ff36416ac96f83a355701098b66581f1a5efdd69c141f9d3a038b47254154b0eecc084b341bc0ae86f1dd57401717d23f79defbe6e28b2730c7c690e1d1ab1eb0d60b1a8c0f784d027aef8904d397190cb60a41baca2723f77dc6b0292b123e01391e15685d133f04bc9067bd17f947923db0b6abfe454f8135ebd110c62ecd705a62a4cc925fc6f68aafed4b7a6b0b60812b493a9499ab2718d1a4e0c944693a7a7933def1f89310fc9f23dff7f0cc46d486a432dc538fb5227d2c52f22ac4d0c4bd7dc8ff71f5e83691c97025c4bf3f9e43849a5bcdd34083ba0d50658292336f50b3cb6ae1f06e1bbf7acfb0c9cd371562e5bdb390d695218c5ca5e114d89fa7c708b02da74e7c9a2e980ac84cb2ffb92115659e664229e0a127b4fb7d5c63c87b5d4c20bcd4224d9d9ab567ee0589c92165a7f8292686df059a0bb14b04cd259226f8af971bda53cf3288cd2edca840bc70bb89fdacc4d9e60569465998ab7001cb2835aefb0c8ea71e73f9f6e3b5eb65101096fc18d64a4ed349c4d8b1f70c45b02d602ced650291d027249c7d7b2a4b993d60f1341068e2a9e814baf108abc330e4934dc54840f3725ad8164c454eee5fbc4b5e22611ad8331e6be45988c86ed27f66bc277620463a86fbfb8cc10b33cde8cc4f1d77fbc8246c9a8a949f4329e671ac97c204a2be8d9f3601abae149a00c5cad84bdfc03723585c3903a081c941afd8299234b1d4375fd5a5dd4715c4560410d20d382bd5589396ea6a0d7ae14533cd7d5938d5a6082846cb48dee5c1bbfb1e696bc9edcacc68f2259f283813f54c55b63e1a71bdff1ef1ec0bdd3282bda4efc93ac1f7ce51359ed0695ef5e566d176e7669581608d76ccd534f00f16dab0cb7dbb94297fd99b0b63eb8342d2005d3e79d730740f8ab684c02c64b6cc9e35b8eac97711a37b2286ff399c01386f9f2887d4028a499e565bc3eb8bbe38d7bdcc049b3738ed0abd66a89ebce754702402cbaa1845e85e85b0db29c73a808c1fe56025ec1f48f7eef801faaba3445e64a5c8227dd5078ef69c13780c163e702df10d76ec3e52f0445e02d6eed35d249ca9d5ad74f6f2e4ece9b9a218a05e4dcdc15a30c6dbd4e268030c3a62f6b5ec25807ca82412f1f55735a0067357a8e17d0bdb06b4351ac6bd1f10cec4806c3a80aa973c6f19a5d4859e5c0500cb5275a792323e57d20fd1a0fe7a11c3b9fbeeb2397dca682b5edf3ddae494dad689dc355df38fe07b546457fc93d3b16fa76d2fa6fece1aeb828c0133786c1b02fc9731d5fdff75355b7a595008e5b50024167cfc6b0fd3ae1aa08f4137dc4e3827092bf2a1beaaa3275f6eadbad981bd00cd83a79d4a4ce8c67bf14f41a27dd3cfbfb4a67bc7bb33f7fb54647ccd766c47a99590203ba7632799b723a9559064a01ffa4583dc176d6b81827d5ac4557b44a7b8f549b8588597d4ef3cbc1467c15c2af1ba75ab0667f77765065c9f65562352fa912704deaba5a2348e6b96cd3675de9d887fcf967d071a241c324c7aa4e10a8036e6e9fd598eab40cb418ff70f2d47c8d515ae9332d565b7fcf3bde45995245981bea0ef8cabe60a018abac6a4dd52c65ef47b57f1bc968a3c9e077f32869bc1ed5f77088dd0cc0520cf363950c40b8e14d3dac42da793ed96c40d2c390c9717daa584f1839bbdc045c7aa3b9c62374661b56994dd6d90c9e7044b3fa1fefa9605e7f20cb4ddfae63a2b56270e4b9c3c6fd9b55d6df53442ac6beec1145ec5b3e96acd27bdd07d3c8b378e39483311ff1b45573a161201bcc863f8c4f80993fe8a0f1a0f02ec603912f214fc86beb6c4a8e6b1853f7dd14bcd452663ad9ccdbabf315b3cc5a1e61dfb926f42bf37b8d2c5d599a5b83f2872f6c656500ccefd912964b58ab12050267f3decaa9bf9a57c0203b598422cafa03330d8dc52621ef081259a65a8458966f2405ee4ff67357d9005819adf680d076888498a0924a05fde4c280aa585d60e5b284fef986858985350f777997b35d1facd82d6fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
