<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4a0011b09708ced375ccc81f6c09a72fcdca8fafef4b4f673cafe64b7725582dd714f1a17120da7f8ce43926932f46e2ba9484bbeb4d1610fd9ff2b2a86fc8e1f1cb34d839dc827a3629e23eefc04949b556324b0faee3736fc411cfa90bdb323929cd95d6bb64557598209f0286bca5fc880987ebf11aa91c2277027b9de968861ee4f1888355eed225e58c4b79137211ede524f40967062bc8b193981f01af5662475bef57a57a294d3445f7baf1bcb30d942ca2a3b2d80fafe8338bef229129dc20ed4c6627c716c9475cae63ab20f3a43d4ed31012ed171fe5eb88c1c8834236bdbff9416d972cf4a854bf7b35258ee08a7384dd2bc50bcb7cb009c63d396b1df4a4955fc66eb0b25e80bf87ed5b3882d9c6f08b86e35457086399a53cbc12cf628c37fa2c5918d370a0feb7457fef444c76a732af5454ef36dd9a3f8d8f5a11893550c4feb7dd85205f13b7996ffffd3fa8219ffce14ce5ce4b6dece44d577469f5b594989f2706629a48afe1f27c2357a6125a962a1482e8aa10ba6e234992d81cd3f7ce452881044b44414d9df44350aec84e622ed66c80039f8715f0db8192b20db14321d950f58b9edc7f7fb3c3832725236424fa2c8034a70b8266a5ad45b46fc483905db698c8c4e9a6342e9e60654760feb12a63557216be18dbec521303743d2a360fa8bda08f8cce37d48fafccb7704833ab3ef3b7e9e0720550bd1047975e0602d709c7a5a9c0c5b04d1a442cf7ff15185ce52d358a422a4288d61f942ffee56c577050ef186dbe669510e1c8a0a74a123d34ada59750b7e05630a6d54205e1bc4e3800415c49c3f112bf0b5a8b88232f429cd83c7e390e951fce8093cb3c367bf7e93b639eed09e5a5a3f2db943a004484c855633422c1102f22694cf6c7bb63dede0b200c7d2dd11b39fd96889dd0bed396b36d3b72875e664d12837125d682ee8e80092fb99ca52a00c2a8b7eacdd5a1ee6dbb1cdb3518bede6b16a89124f050b73efb9b7d3b29628703ea4e4d9f1a574a126424153ec13222afca16d264e64271b48523554835fe7e47a763c54ee8a1deef1d8231dc99fa926fed0489ca13ea6ec84cf29411faca763acbf38ffdf7b504c3e50d7de6d88b9a00d6b93a7b6fd3dead3b889d3873a10a88ac8add53c757601d5a7acc28e666d44ca0b052daaf85f9bb80b8acf348a63943cd83071e6aeb74838d1c500eb0b96469e37287cc39ac60d8f451bad4d5bcd0eaa3c3a6931fffef9a44296a009c1a0d0917d974c55c3dc0880e7f21d0201008b64676b252f3036f5643efa03e228af33382532a534d051bbafae202ce62454b171339b43034b4db1efcc26ef1b7f0d169f5c839494497ccb55895f3d6f35c70eba9ba2f9e0a03c00f7c2961c28541f308bfc747e2d450683f1435983303e91488daa2e2fd152e114c3176d711ab6b387027c777a880b6ae0bdb14adad90f06a274e361fd67b7b5cdd2009631205e1919788ac0f88158e180ac70e6be602ce9455df7d52c171133c97d01f5702bf49b226aefff00d85bd690ef3466ab73b8854fa040a3a7fd240bf576d67c3045bf21c0336e5ccc9fb900a1a4e6b23995c461423fb612fb2a6440524c4e8cc18aa1c1032b0a85457966f06ce5d7683cd544a9e259d07d2baed416bbe20faaadf4b452d6e19e07b50c3aed0fb46e86b62a82e69d21f0e40759ea54699b9fecf7a5df2ac5b9beb69a582560fb4a3afd1956324f4abaf8343a358407de1ca435969d408deaa5e685fe6290de112f82e70c940888c85489dc4f5df5963b144b20acd663da73ccb86868f4cdb1ba8dab153490a7fa81401c5f73ec1b47498a2e973235cfb5dc9d3990ac1d08dc4b352a8fac3739a4d6e6ef0e3afc15ec59997f6072c031cda08aa6ba578353687a0e6f4fe6a46739fb27aa347bac6aeb74f3a2b6bb18b64ad15d64d672146b19e5bc9a6f90daf5d8d504f377447d082edc5e2b66dd38dfabf830d13e4bf26cd5c4ef53bc702cf4e3e1029a1097cba7ad5abf3c0b12e918640967dbbbc5d075457e5302e83a9b3abfbaf9d77ee239d6c25e1fb01c07d22a6bc16210dca17a70581429db0f5629de2a95ac3c795874a39a947d16bec451f9a6c5ce2d065529287dc12b876b6502851fe548182456528741c5274aeb57501dedde060ca50ecfc27053518356dc5cef8304682e3cc95be6ea7ec55b71fd664fb1be2c8f98a39e5fcf3d32b7f84f773c133cbafb2bb98f18699270d1c9e49dad9fd40fb33948cfb7c9ae9d66cad480e0549941196b65b61d3a1df2b9bab54426c34e431b8fa945aa0362e3c00fb08827bb4003e646f92c2bd348543c761496adbc05147263d4e93f4cfff4a6e19a3a4306bdb1ddd21a75cfc8d322b038b9dac40114e75556b90c00c7d039cd19ec0ececef1f6c54ad9d71384288d810fcdaea93e9c9b0a64feba48ccba8cbc26f91fcbcb9ff99733c2b11367843a2d2b404b02070e6c80fac7126534ae748518c8d84698d2c28dbeb9f16a353d4c3b4b81205060bdbd5df490e79c45e0837923280bfd1a536046ba162e5dbf10ef06bb404130fc35e3458acbb09756468c851942f67f26127520b2331a3dc12f59e1818fa8632669f044917e8e6c9cb1c9700469704d25c11ec4d0f5987bfdeb375c9a9259a918906bcc0d7a38075cc4f68b212475c4e077f06989aa1931e463c49255cb5e3b5168c22141b810cbbb9a6a9e4253ced9505ed8616df2ae440c1d3e79f1739293874f0e47cd6a4377ba76ebbe98f6bf0f02c71f12d34a99f3cd2228e1597f59c24dc766e3f93741641602c9b1d888f46a296cb364c3caf1e21dbd7a181cf9143606adb2aa9f100acde5d358de499191a310ea78a28bd60c4c1eb0b8f7fadbc96206851ce962c159fb525a8b7150b4e60a61549ce16d73fa42807f009323428328049fa4383768aac8609b6a72ddb1377d08d65afddf5298e63de9cfb36126f016943f257ebe0516f858bb154cb5035dc53b963ad172f70515842ca2d12c9fcf15c0ef9334948dbdf00010bda25fd75ca15770a0fac61243a44267a10b9afc94a3f754ff3e9ff579189bd6a0e899331f7e8827782ed093e316bb5d89dc1f1bca47bf73599059be333ea02dd8a9440a39198718905d1884fceb71a838796b3bfdebe602540025f3c5bf88b323a18d227a8b39051fe9d0b5a26cb62e47b42bf60ea7c99068243dff2dfabaae430e55ca7dc83bee3155c550169911909529d0947d00f871ec5ba7ab98889904fa9aed56f4cdcf84de04e4fbbe8505b9101460f08a425677127112e09bd823f72998e867c198c550dc8f1a56957b84c29905bcfabed6ed2cac227be9322361962c2c732e78874d4a216d2bfe06b3cc7ba2954c9267c08eac1daa85183728ecbc066055f34f720c94ecf540c1f20531faaa03aa5073746cfc4e4b861c9c4b7eaa9873042f3e830c30b8254071a4f48aa56034f3684f1a26cf2216061d8a0901e6e4ed9952e9fdafd771346b23bb3290a6c0925e1faf90ffe84ede5dcf5538e8d27aacd27d2a9e04c4b8fcc68beff84afaee42ae8bb6c22b031580b9c4e7b1434f6ad1cdb3a01cbfb6b381c25863bb126b7580f1ae542e8324a181d5174864b0f98c9057807255f02c2ba9ee17477cf1912fbf5666c129a5bc080ed3621561b1a13680de883adbcfa910352be08e9b20837620191869637850b1b63922d474f43c09662f7538edf3e0805cd847156a8c7a886606f080f0913ce7b64cc890bff98c1e6c08577f25c2efbecebbeeb9156fcfe28a9c66a51e58fd963098dedd3e87111da0f77628c9845554f3f0cf859ce8edc1dd083d8b92b6fd7c30864fdf22995b789139a4e5e6a4ff8cee01ffbf4a9d6b0ad238418b5cdb146b3600bda10ab1dff2cbb5aed6f2408d3743cc63bd46afb0e34989ecb16fe9d99c87576b037ccb4a661132c63c5b57f71931211cab5e7780675357f1880fec24d8f0e21c5668ecc7adfc2559a88f0ed5325f4dff7a8019b93c6c07ce0cd8be24a709f0151203a7e99758b9e49f3efb62a7085e86add0a4e0f7506dfc79336f10739c2e79b1be2e0cb9844c6be4c307a4552b361ad806c581e3fbdd4c5dee6546d3de43c666ef961bcade6b884480a801f5d248ce9fbbf72c2bb88f736f917898dc708d467885217c57b7f689ea5c816eb06984e7386ef336cdd1406afc22e6ff608f93d6dfdfae68033212e009d162819d59d7be0e5069fa0d262d322637d24e372b1b93fc6ce8b25cb71643e748cb8623b2551baecfc40a1a99c1c5f14c8255ce532360b2cc684d46cccfeea2779893c6bc77d6f161272aca1b06578eb131ca14a66cbb52bfe393e6adb1a2c3c05b11067e8883f574e913a7ca3a9a4846a9bf81ff2a2355a7cde838ac978ce183048132fc8ebb51b8de1a6e9fbb7af3ef4438980869b04ffabf18fca70ef0f6eefefab3f970d67750981201a0d7887c66f404556309bf84fc9166c5f4040c4d4acb8d752793c145e714712d6f7cde23410ae2dbb5d148bdd468590c743b5228c7c1efa6bf22f1c8f29a9dee869b3afc20853fdca255a4f507150ebfbd65f7d4e9c98acfd66d2a3c2b407b14db79729a5723b41cb8d9dffb451f840c299774906fc53385b539628d22a5b4c7288469171981e70d6f28677c9bafe0340af0e05d795c846f6374fb62a67e712518ad46807d59ec3cebf841a90a7986d584d2dbd95975271fe86bc690da7fd436dec12967e9497f3f2867fd8f2af4ac989b673c47bee32f5bc1cf6207179dd89afdd305c54233e75bbc65da635f911a95bd169bad79201837960628ab2817d6e3f9c5d91f82bde917a92482c367e6bc8613f7d4f9f5327afebeda2cf59088fbd9cadbf100f926fc76bd0d1e8ff8c55afa3e6cfb3e85cb01d72262c22c53b654fb6ea8b7d92955428f4542c432006b981245feebf030ba6ad9a4b27f2a8ebd8fb0321441e38fa0529ff5d8153a735e1505121a5831cf0853a5b908c937cac59fcda21f32356785cb7225f4b2b26246cddd669bcecd8bf0dc0edc9cb09c5a6cff43a7891dca7d88801c83299adce1f233d14d43e6eb5910fc8f0e7a968f75c06fae22091911134fcaccf7463733c171d801f8e701d7f17e8dd13ad82a33ea5414e453b5c21e3669ceb6283cfffdc2e4a0cfa80b13ab6ac46fb27d9458b7b35b3f3d6a5a91f03010aad5fd0f8bb969deca5ebca8702998d5fe4dd6f10ff72f266a438e7a0bb83f975a20b19ed84386b09516898ac914ef605b4e86ea57b34c7b85c93d037cc938fe52bfc27fdb279534b23d5a08370e299b6694e60f5c5c935bcc10c78c6f0858e91ff4a023c7b2937511ecac965e3dcd4ae01172ff0eeeb7d474e319270a4c1fc4c98fa9dfb796174d470ae38ae496f6e960950051060c64f06226a3d1d782aa58ae5604713c0b5190dcb1f69663810044d575cde9b431de14f6378cd76cf6d09ce3c03fafd927c2af736456e10ad935c75d52c6ec290e697cad6967223dcaf9804e28bb48bb5271914fd9b057e2a63f86a8efc7782e3f4a7c53e24f48513370d860a93abaaf28a89223cba38b81b35765dfdb6fa3ccedf123e4ab3eb19920e2b3cb39fcac8bb92d10f7c9fd345be1c55f64a4551a2e07e94e95d9febfc8697691e477c13dff3e5a1449ae531eb31ac8b35fdd7c6ca64bbd7ffd899e14d6184e8e392a543c6cd42a56e898f231a64d2b62953117b0a8f93c633ae8a26e038b0099a8426c8a6a7942c9581f3f38e08bbe25ac243015f74aa35d161376b331075b613a179759c94be87c9efeb53984369cda8a71bd278ab7f2fd3882435f20423f20d3e888990a8fa62cfe0eecb1f3ed9a79e42db02cdd030d81752c669a8150a9886ac6054cc276c85cafcc67422ad7a9362c8804609542cc51d708b88ef92a4005d497035d76b35fc9b6681e441274ced0c1c2bd8aa280e5366a4a5055cbf880ea1a9ac5274e27cdcf8be8f28ae9d57ee9cbad2c6d3182c3f2abc2e1c5be28be270b1ca870db4fd74ac7e43f40a758e59cb2ca593abff8392f8313d129c5e35b689f0a4130686b43a429ff691c59a413927304bec51b397487a18caedfbe6996a91ffc65d3d4eada99ddbac0fe60b7a0b29cd9f367b7011280b53be78ad9c7ee0867fe343d526837244e5e6cf77436129608b36c5a87a7eb7b7dfbf7683c56b110e718cea5aabe5ec92043a95de0c35ffbaf79a3aaa38ecea7eadfd5630d515a19c4c56c727b2e963791f8f59f7cbc06948dd7b7c00742a456f87903a756d151933ebb0ac331d18655ba7fbb7a69d8ac218cc5504282758cace30e46a284c230cff022bb73a71849353045910112d33ceffd3087b9d370de40131bcf16967ad1d425de910ac679abc031cfd052a3237f91b5d0b3e60eace54e8787b56db0a8e792f33c23aae95f7e6f30a3a15c95d93ff36797881e5c85b498e30c2e0d01551da2613fb799ff58f5e918f538b88c5efe8fa581c99b85c6d6a850f36ecdaa38a384e597bf7c161703f668534f2595a7a175302e46f348385d52ede45bc0a3581ad28607a5b3ab3e754b71c9afbad9ef531c4d6768e8e1091422cebbd3f0bdcf46634abe94a9c3190b0de0d312ec54010d30a48b0f099ee6535c059745d2ea7c67125ff9c924c410fae88256212d5058f0b0af157ffd0183859e5a38ca66ad0f63f05e92355dfaef203842ee1d21ee1b99e614ee40fac9038eef24685c2381d61114a4cb1ec3527e7f6b70e1aa01caac76ebcad74586650a844817dba6b3e62e784f8a409219202a6eb330a996ee659f92dcdb61de2f6a68a3b181f2537bcd6b79b16bfedd1be642acb25d7cc83bf5c250bf3e300d648f6b31068949a3b1c241ab9798aa06e944a3fdcebc9a9959876851ae0a5bfee46ad7b5c207c1188089d9298ccff20d7128685965f6d26f805a918646de547212b552ee5ec1e3a9e30f28f8dbbd58770cd213c81d352aae64ceb3fccf188d2d0d08ae2f4b7eb20d08571ea3b0df9824f5c2af9a06cfa944b7ee4f82073fc19c33b9feb6fe3b5eae3e335c31aaa7995d9cf74dcd3a2cf8371029599125ed7f7750b2dea7ba2f1492da03c3d9b939fd04933042204d84e92ea0dd0198646ab4b54cf0cd90c1551e1871836aeb3df118a42780baf12b9ccb0fa0a56a48444b4ebe59eff75eef4e13ac5a3f31424c1e74ef3274e10b1e43db6416cded027ffe71cea39dd14130bd0e750bbe52e156986d05eededc96a6d769bb3e8daeea9bad671da12b00f4053af33d05ccd75f695cc5865d16c3a5721754629f0ed12bde2c79009136204189d55b93aaf3623f40533f42e6058c5f606566cbe98718156db80180c945646a13e74678a011985d6c2df836462f517494551b5a01fd342f1c99047753f12adbec5d865f43a85539847a3abed789c304a902be8672ddf119bd5a71f32b2531727b4ccde039e47c791c867cbd64a000d265febc88bf20e319d40bfcd0c62048a0f70d82d08d065488245349d32c0be6e04bcba4e6c79591a6a49a2945c2625f64c936d5ec3f6187cb3bfbbd156e0bfc6b1ea063eaeb16c382659f3614c72b1d2bf71667be91df4f0c7ef57138e5691c51191a9ba95e9aed4ad515f6fd544e88298519866bbc2e02c79840aadb8b4da0264ef765581b10e337c8254704d732418d92f898bdc6ccd0edf43181f953173dc00f42ecd6773d49fada6c745d4b4385fdfe60082cc7e9f2ec6d975a85725ae66cabf1267d9a52fbc4b4fff84b694b87c984899585938f81a592b4e326c8d3388b39807e999719b38714219399e9161f54fa6406686ff471c09e8af4c9846d21dd159ef48c84309310a8f68ae5f1b42382e8e52f386df9a0af6557eb4dc0235ab557fc5965a27b0bf2b03461758e780f5243950b609b6056a1442ce6d37c6d4739d1232e7c3d864249ef0179a2943dc922f9d101708117eebbe15b24107cac53ed9324c1df3dec018d499beb567b1ce4cce09ecb7910fac410b13a7fafe1dadd8a4d403b1ffa7e741fbdac1c6d705db0db981d02dd3da90ade4bae213aaf6ea1ef8da5b0b4f2aec2ce3edb9e19c5f7775b9b1b5f5c20108c9a5c158ecc5bbc8519549aff01053df2b9c5b7db23d86aaf31310347d807d5e1d47518aa1e0928a1d9c4c2bf84a5b5da33718d32f3ab9384fabb56a1d3c999e1f7b26a96161db170b7ac1afb72c0ebd3309e9d933d1d737629a45800f35721eac58be6d2257940061067a825671c60817400fcdc990df5b9111e4996c026895003d2dd8f6e8293469c7aa261f7f10f46ba89929c5bb4e38d6c424d1dab74fb50211362e23e745c0000b1210817b87fe4ddde6df65b20edd9118f57e5be1442eba789cc69a995e7ff3c1e80d6932e8327347f103f1bd50d3785b98e20d0e3f761f87fc64b165c551e67fdfe2e63cc39def4bb974fa115fd2ade0662317827201a848d48ac5676e8a9e804ab414c25f533dbbf01ec3ffd71ea0143befcd13813793fc07cf58bd6f7b7074e780c892f864e0ae44e0e6583a8702316ce29d6b2289cdcdeabc1072973330dc8b898105be1b98a3ad301438f826a1aefcd478eb3a51184cf086138908bdea7a1f19fccb7acd0ddb6ae4673b1942eb1f712c1640f862cab40021b93242625d9deff17ebbce78cbafac35c9d0dfc8d87284c85734eb383af5679a5df71c165467c20bace52e3e11e2f72caff1f942a374ba66bcf2d70514d964b9328009108a8ea69683aeefea9e4f623ff97a68378376bbb297721425326194c0b3ac30d3da1079586124a7fe3ed810aac90e28d102def252e0ed850f503fcea9bc024f99e8318bb104ed20c94fe8fece316ab653d09e3bfd5e7476b936d256abca02d4c7642a3b6d2b1f1b24c47aca6dfecba190e03d6f5bf406e1badb794aa58c5fcc1af1532bdcbf19506095159bfe4b8576ef313106c25cdef9cf7d4c2d964f6a59ba9357deca95ce3345b5fd44120057a2dbb536660910db507db308c06feffb170adfe72bea8efee4f845ca252e02bad8dd3892f066798e803c5462538989d3fa8797f7275a7bfcbd86ffdda432bbfb9c8ce10e744125838151b864d8166140a8ce20c8c4e69c2823db7040153f7987dda95b9de344c4f68bcec8432109cbc3914a476faf044cb843855f0e05611086f35880b475eb85cac5b79a1e9dd974340ea86555136789879d4f1f49d30931d543b5cb70da18844c0c6828e104fb0c5472366a6b4d7dd4c875171d1b011368c06698c3d9069657cd03570755a5f2cf4ece46feb434891b14acf455b35d0c3a1fe72f202edec07ed9df10e2f0ca8e86b9f4803f26e1e174802760ac37118d212b660e7294a87fe28fc7041c80fff1409046226e8227d2c9e75a1845f3e6a24cde84cd6811f93718204720adcabe775e62c430e56e4b7f34cda680fa54d21d83cad32f02951c85a44a630f0a91cf47a7e92f9a25f295b45c1504de2871872cbeeb6a1bade473d24f830b4333766c73f73e10e4fa39915a14fcf90128bb4db8bfbeb90c8f09197289b06f219d7b9c0ed5d5d46c6ba3cdd9e561d2f316383f8d835c08eb5df6f4372bbb74a87918d03ff4eb7b8e512d6d0b67d5eba63012d82e731a79fcfaa115bdb979478621e1c5cbccbe22a678aa4feb8bb81d3ef97bb65df14216c21b77910771a96679e4616359b13c2d4c94d630fa88f0ced2287fd44261dbbbc3f6c6902a9b5e4b48fd9ea63dbe28fff5611555474a3c8698c07df39d498a352aa75ad183ba768e2e0f01f4c3c1b3a826cb6a329ec08f679dba05dbf16bd427a06a88b2376716b59e427f20e90adbe425bd0b85fbab96d8794bfddf72fa23da4f653fbc9387f5c3b0a69aa51f2928179f9de7cc1c87843f14e5cbe6c241573b69e07b29182e318a0c9e84ee54713d831c1472644616c4188f062582fde0b27c60532a24051c371e950c413634354aed000a2788f95d2b1cf4e7fc5f74148ae009d6897319cf9045e06ceae354861eb3cd9e7d2d7d5afcecc3ea7a20f04103d41c088225f5ddf24c1a0d5dd73fd1ec59f48ab8b8961d00886ae9ac6067249d81f16363d126965f31f112d58742993ca88deadac3be6d5855b3c01c9467f0c8b15badce02e82d42fc40e4d1b692a5359d9d7fb8eda34b44a033fd85ae225a16b859a66430aa64dfef6c8c18f49ff235740fdc3ba2bf1f0d5f0ebd5afc3cab13484a31157ffcbf2035b4a8fc77fc0893283115e9198680b36901eda619ae1406793b33acd822d4873b053e487a5304150ccdab7280f066ba499fe9970095cf5d55ca509f1920548f7eb42ebba5968b0295c8016d57dbae1f96c35e7d8be213c6f633c53b1478356a3150d390d6f63937c417cfd12f6f437b0a62d52e892700fd49455dd480b9ba346bd26f72a7a841099daf0112f8aa24da2cbee6c9f25c7e5830f8136ce742ba9f867f8606dbbaf7bafd23fe5dc795f64cc4b1216242b0733c7c6131047aeb4eafa18e9bafe42726182c2c6cee7cf01d5d900c35d622d606aad71d77cb498d1b4370868f6c7fa9cf4e62ee6dcedf8e358dce29821dafa447a66ccbc3c970a6c8bce7611219b7669b39a7ba8cb6278d48a4374a87f2ee4fed7d5a17a4db95845147cd8fbff8de71a7d683b42706204cb7c9276b4ff5f2627811ece3381900a769d2fe524f61e4d8645b2e8ade3050999d1b719af8cdd0632472c654304567d204395f5aaa962fdb3def235697e41d758f8881f398965cf5cb31e287e57707d5c98da253cbd08c243efc2b866b1cec2eec657b45743914148b33e6275f5243eaa225a792705c942ba61d3955cbc73e24e07272ce5758a6678d7bd9098131b5611af62cf831329084beebf96aac3eb91432a244c5e6aa7e415ef47b74e599063e4b7743668265254c3189c4d8b99c2c20c651247a33f13ec8d329e3acec4d14a2321a477b84c3bf5513c52fcf4d5e243f5a712c6cd9b3812970304e0319cc7a6fea9f98c4872b213c862c545b4867e6cf6d5ff304993cab79e50abad1fdf3044f20094ecfa29bd15196b2fc65c8cde6a2684032b263485218f4c43c27a71b65f83c662943e2d1f163e764d888a6062c93c2ab52268eadb7815b544b8f6a8a3491936cc65ee080146080594b87e3fdbcf1b006416570f93fb029c90aa6c73326a200e2888350b979ac38358ae49b6f86fabe5003d9ce79fdd6f7f863e1ef4c22313c7c172019f20be8a74626629395d9bc4916382d57ffab4317e2d1ff53648b1248ec53f2b391bad3880c4ef48d15042f04f4acb847377d345276669ce68ea23dc5c83175de01227e5416c1a7cd3e98cde9019f69854f04fb3230bd46fe3b9d1ee5a0efb407d0f51b7f6b87aeca7077051624fcbb5f9b66ae5be7143f91f899d6c0736b2f87b0744d6764f3c360e5931cb743f1297a80e0ee95f6a4f1420f3e5756c4832df991f6c6c2c2dcfbeb295dee4f1d7fdea9b0d7f77c8bf7f1532c09ad300029cc68523fe70bc7ff12f71c5e873ff20b16f7c88a2240da83bdfcbbf08ac12da296c7542e743e588f7d533c740455575a19c005aa5667f2b2be23ffe371fcfc075dfaa27df13229f44700c499f5274f20f99598fc9e0b254a370acc9a388e645166d7bd50462f724123d81025e1d1452eee2d44f51ab23932aae7b955f605f91efccf942e6a960c89ff8b4dd81b594040924cf9bce0b63595971b2720e58e352f6266ada7c5ac64a1800e07bff5a0593e3bc0de17147e5797bc0e115d2168231a591c43286ea5f7a2f3cb898753a1f08ce6be73570ffc6ba2782b1c619cf06a7ba08630246e283538e492cdf36e08c0ce9bffbdf99ce5602b9a4c462f60c2a5444922a1e5719f6244ec6bca8f0db73569bf3365c28946c93041f2a267fad5691b4280c14e64022611d4a4ac83333b87975c9417ad2604aa57cd88f877355de6a8f24943c17228f4ab61790d538503916e529c6b4946359b337a5410ddfa6c1d262c17c965a6d36ea1701e4daa676916cb70b23fdf9ff7fd871ffdf186d7db5fdc30316a868d980fd02e3edf167136d4f73ee470fe3099412fd98dbf51d200e467aeb19fc125eca5b8d1a78e4b0909c92dbabb11d5a2b0c2b8ae03796d82e964080d92968137e372d68b2b4cf7a82a18f585649fd33a1b402299e3d0c0a190afc880b2fdf3492b9810a64a3b5894af44215b70482871ae1d1e1a5014ef2f381d4317cec0430dca5e0fada51036f4a429c7348c520cd268f03ce6be89997b8aabbd51b293711aa6b76efb95a619a74f74d127930f7936aa396fa8af85508dd6e753908a8387994ec9936d6e27aa707385fcde3b5f99a2a0ca0a50181febb83378727274eccc1c07ff8c597c5097fbff485dbb2d6e10e691e3fa19c8a3847905aa9597ac92b658937bbe602ff324e5757265dd0e404936aa3afbb6686254b0f78092b71f2ba4c8c056f2d4c883535b77c7e9960dfcfafcf4a3e159190dd3cff0b9cc87bc54e58eb365b69cd301317196dbfef726be7540a2d35ef4ff035511e78166fdbafb20eb47de69f9342fd8d613bfbdab26fcf9caaeaecde648405a19bd145bee53a57e7386bd7a04253d5323eee0fd15517e7a9d969db6d055810048fb94f0e556b0871dfe5998b7bdb15d1ea14c95fbabc4d25597dc2e76e14bfaab995cc22176aedd4be40b69640fb8b5d1451f47cea57a82e891d008afc10fce9a1ab9dfc72c52b67fdc4439a9bae0a1d7d74411958644648df7d31213c51b9cd3f83ae31572a64b76066ab35974ba1cddce7cf9cedfe7881088404aedfe3a6787080b2d58e08f1e4aea87dabfb44ba4d89c285115b2cbec3e668a42551f4abb75a1ada6aee473c6816b845ae495abc11e708f22d2648a5959b3c9205a87e39cddd30391bde9e202e78881d137f1d76d116c5034ab88edafe3c7bf023493aa25b289363ffcb98d47296f16d30388a18e49d916d64b9cc2490b0db1d1d5c81ecaece9e3dd81504c13ed6cd6c654c60f13b72c14a8c352222d2e95b6040cd53468fbcf997fbe0855f28485be0419c83c86bb087bfec4a2c6875dde84a1ad50f4f7fa78ba684b06114e00236c68c747f417b79b5ee1284c0ab65706da4e8280a6a2e0a4a19150367daba8580db603012268460bb2c4fd11f897d83cc294325746edf108a3375b7b7bfe6622cdf7cddd6f4fee073e533857eab494b55f16354b0ecbc313e7b2664daab2a73c1a753f434be5d6f795499cd7f83cac5a2104a9c29189d9a7b85246cfa5a1bce0126dc7171990c84b66b13f5d5f65c3070b1e5fc20b68d62792656230fd7ddf883f98f2b65b1288fdafdf8b82527954b6c7e04f38a76e3727043eee4f46ae98dff6d5c5c060b0337bd9141210406fd78fe0b3bf8937e5ceba285edf99384150297d816d38ecf3896a1d18611f5240792423bb5a08fc749268457ee908f68fc9727b02fef0f9bb30ea7d0b46f414710b109c3001c0c6cf77c847e416e2f3536ab3e9ac8b2abe5eae8fd01f0c7aab36526a369ad5843ead233fa239f0f68636c6bd35cecda52592529b9d621a359ccec89ae05ed358a00f8fde58f33d5bcfd632ca73955da4cdbb3ef73ad8f78ba27806727eda8493ac8602f3caf11d3aabefd07b87dd1af61fb36aba9c96a2eb982157d5a6c7a19bfd7fca8a79c68fda0468b317331cba3ee5b9f1438dfb4218535055f1dfb32ad485ce2554241e19ea4116eca0e2a6d63541f448a1bcee3bee9bf1729271f85926f8f6dee923829665327ccdb735ac3d7141116bae3b75374f622b2dd9d7fac66382bab9bf8a8da1510ce85fbf30c4245ae7415ead1b8d5f05d706fd3c69ae9d8ae16f3d88837597aa0b32a73f7d033a6a9c6c03fdf87421a91476a14f059de81531a8b6b9a8343405b2faa3e77319372f38c19513a5f78ec821ab23003c61b7532a1708027d40407963ecc1befee1d1a06f0db96294813dd0bdc4ba3daa2dc183a338021268408f9a01973605e670b92e9bca3d6e3c7eb64c0984ea4bb4a587f31c3573a125db1e7447e8cf32eb94a4210c75625ca5d4fc861c66d757a664a15b76bc9035b5f868cd790eee2f4d13df66a350bb29a5c6009b41de3c12322607935083b297ba5d5a84280e98a1faf2000d966e2fc879690b3fc466089fcad8d79b1599e4520e111d73d1519f1c0a398507b8d71158c24b0fc147a828be7a3a172842f5a7f75a01c57978bc64ea0d23cd5cf481e45a7e0d9c3fcd19374bba88bf4c323b64dff80ab62b0a0cc08059bca6b0fb15652f4c21c2eff4f2f947349488b4543925316c6f2a938e01b4423ee468dafab752f0d023a3318b0ea05a0d9e1c83f308b6d7927956ddcec64276a726e25fb682a31040709187f67000faa74f1c2b1cd9b57a933d4867f6c6e70fb1f62bcdb72755d48e41358c49211120282609e3c87802210ec50eb6f95b6bedf60736cbb063d00abbb703441f91b7595ba78bdc5a3d18fb5222f7ef5872dc67916e954e9c6dbc1d94295555678b0e2fcb7bd428b11a88258764e5096f60ca65467ec1cf9fc8c90cf03d883d0ac76c6d61de800ff75f810bdd0668ad668c97981289b904e72d3c688b7b9bbcb6c343ee6e05c274825031f7bfb2cbdedfb451c65080eb5a5fbd18ee25d53fbe11ae4c4dd1652a1c304cd50b619c9acd5c0b2891095bd2ab647427f93b087ad556c56ec914e29d27c0696b6847aac1a7e1ae508cde58dca0930c24933e998d310393e19a8d520331e19eed6820bc33104ce577301271aed2822966b850378d6102946a7e2325974a29135c6f3227b90c89a47ebae43f5f0ec59a9deb1fcafeb6db32c2ede2ce62faa6b8cedf050c5120173b8847f990eac91dd853a466b00069cba9e0615694a483b4c00e5ae198881bfba64592d2398b2808082fb411279800fac97796d28256a46f2365576ea2b3bc781dc1e199f1a9113bc3e238ba61e117055771bbbb9c6c7fda87776b05e829b339a21156c3d7794120bc55721d5e04091b245fdc89b8df56dccec8247f988e9161257c4e9b91ec141df9b7bc809c7f9831cf8b14d8d6ad1df7858d8109b37ccddd8a33a9dc8868476fa53e80e6c01ac544424604896147c38863a284942f8f0211dde7557ced0bc202af61a43bfd41f019e0add9e5955ea7ec02208670c93af3306713d3d8ed27343a6063177e04130b5f9c1c52cd2b470d54da2920c764492980775fb1f7b53dfaace0257aebe81bf054d16834a8d455c8a7c7ed91e5ca4e7386156095deec0380033a3881507a147039d6d5085bd1d89474f09f48eba2acd8550e3e564274f170f96755d285ef3b09f230a723691e9cc865b49d7ad76b2fad3095b18c26fb73d3d804a125d9bf5afcd52a438187f1047d7a1b7b0d6247f4bf6989b33f3871c46319a377713651d09c07afc5084a5154f4772c23aeb3fbaeb06e79ab317040027ccbbec01ae7d0a7765c5201c1bf9525520894f84d7f29ca9f6592494d5e491c8b728cfcff0382b44f6f149c26033ce18b1acaddc8439451f019f4151866e2f8199f6ed9dabe10b33c31330371eb0b5e33014a2b77d31459eef3c1da52c0445ff9e67b3a0488b01def2d2d555e3905ac2897d415b5aa129c23c971f6e7733a2d58c434dc067e336544702b2bb67011899eab51cc7e5d591c698fe6d0db631a40d1c2effeb308d7011a0f2a43546f2df1562b539b4cdfdcf34f5c475772e7c95cea3989927fd44aba48180c5950dc58d338c1601f09a36a68269aa9894fcff276513a1bdc01fa2cb279e433df204a4e4f85f7989e36670bd0da3bdfeafc9d0bb0d5b9aacb4163c4aadc2f1305a0a92fe2ac5d818f7d1f7e7ce89f47ecb5658115250c1d6272c94b6f00433a70f6bebeb6ea8399b251652e37347a31ecb9d1cd718336c68a4f45f0500baca4f73bad5e4af3b424fb985deb6e112c438daebb56c19a9d65893ce2c317faf646dd3daf267bf90943253b734e4deffbd24b825dafebb8ad29569d393e38db6a9161f24675fd2af61856dec70f50302ccb6dac1260aaff6e5cbd541d94aadcb24c612321ad788c5e53bcf311b4a0e34696a81c0a3d4e16e1f066b89df7f0105d4e36830cbbf6bd188c0fbdf3a4a4658483077b473be689b6e9ccaa5d35c20d431cb5d2e4b4f07d23795d64e0502e4e8d8ec9d6533d22088797d361ce82b84a417f14e47951f5c1206292a6a6efbfbd06960056d240db9412d3566033ca31fa39d1b55fb0c793781c9b50e4115615b64a75e44c199b2d2258b0f479af16257cb1605a6422f8cc2276ffa63ed27645c84ac00935bea400b42dc03e127ee82863870134f73bec4e15be7332ba350c430cae3c0a4c0a02a3a2d64bb0b8b9a4a6ddc5a7e1be7392f67ef64b38c2a2d6098959338c439c042418dfcaecfefc994c60672dd355b4b1015fc740ee30dc47aaa2906cd0fcf5859cc68eaf4f6e26226b12f1a925a4c901ec23f5bcaf60a6b79820bf29e1c9133b4756892accf84d1cf7ed4c9d2fb4d60c834a38a9887ed4feb218e58a7e72155ca6fe683e3fb2c51d8c04d63fbe678e54bc3d07cdc8f2c8ec630c814c8b1087f61838d4bc035388fe62cc868223b0280d4309eea2ad5d60e2b35d712f4813756c106dc929eb86cb59fd7b60354392fba03716ecbbdea0b48529a3291514f569cc6d04b54ee4baa0802dcf3a914e1c05cdff4a03d117a4e9b669f1637db06d71f44141bc559c7cf0a90f0def03b4fadddefbb5e0ae9de0f8399091a89c181baf9f87e0094ff200810769056abcc326d3cb4e3244f04e9c91ddfebebb22a6b1428318ec7ae2c44b7b7ad54b0020f949898f9b76e30fb79703f2767d175ba057b70c81ba369072242946ff1b4bda44c78a4bbc44379d2b76a43c3a953424e78850cee0b0cfe49e85790e0c32aca66e9ef2c869dc398bd03927068185df292d7d4011a1cf81b74e0448c969ac16e439450298a33f2392d6d3d3daca1b5090b93c7749b2e304bc7edf55a5f2b0260ff903a2889ca57ab6f805969a6379bdf274f6bcb60a19ceddeb6d50f38881b9cf76caba031272bbf3cf9d8305122b964d2f08ae3693046918193136f2240ba04a951dd43f6f0624eb137d82d6e08d0e97c2308879cebd35f5dfad4c2be0a88df077d7bdd601bd3b66b46eaa1d5ff9aaa7094744e45f2b0259b2787d3fdbc7b94b04e0d7a7cb58ff0e26ad2a5c4f33fe403b4f5e1719b975775b33fd3e21b679cfdaab94422cc0a76c0f34742ff6282021aa5218b4c074f95bf0711a66b54ecf2c09b3e899c61ba9169c9488e86cee0e632c4fc542ac9ee0435032e72609bc7959457d58679c8474e016c10c505192c1f6af96c4e88a3f079e184aa53ee7e679e42609f0f5170c9d1fcdc312ef79e3c9d165e785c12b2124d91f18b639e80e4d1a30e4ec4b97201d1aa2c8e9a3480122d687a7e9bc1cbba85ad22cfb702fc04be2576511a1b6b2a6cecc38c71016bcc56d880de0ce4d4275f14e09e248d531bd107c4142cc186c7bb55f652b7295a735633aeb681844a2b71070192eed9f88efbefe38dc26d64d83b654dce6ffbd6d0d2e04dd68867467fcd2f0c4e6b4705111afe430b38d9ed29f334c68a5005152615e1d743ddb88a60d3109319839a9916eb8ae06b0003c61cccb6f4c3f0a474e9f392e6302e1fa71bf43f98b6f708ed5822a09ec7150e8a155d766e5a8493baa5cb694b6530ee271c2a6d29b3862e491f7c18bf89864a30199ea365217e41b4843042f40ed8574a0d47f676308822f989c4e34bfacb4d0ce49ba1429ecdb02932b304a7117e2e37e5608e34e5a63e7a47134799c77abce3dca31fec01b71e6d37e08bbc141f6b8b7c04d8de9ddde2f85ad75fd3f0fd7b7253aac5c499c809bce02d5a6d54dc51d5cc9091a4d9c283992fa059c0bd2b8de87d56fe117b742a8ec58e6c6fca539382319deb4aef9f5818d69e476c63deee153c892b3304fc71a4767e94cc4a99c048b9a3bab388ca973b8590ae0c9ab8f6df3f0ceba7cbb27808","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
