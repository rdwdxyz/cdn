<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"86a0075d77109e6e098a45d75595dc83e12d8b4e3fc54dc8f6d9235d3708e8e9a2e913e7c554f812c3b87bac440221a5729ee87662986c1e2c55d1be61498e0081ba776fef1e2bd6d612debf14c626d6fbdff36d138ba4eced38b55572479bfd85a0afdef1b09af07b81f9f881a47227465422b4d649a64fa0cf22edcdf46869998c79b8efdeff136ca1fd0ad80a52624cd473297b59990604b9bba212b733b590bbe94b697389e558da8b720de715fe3ae34250857638c670c021e2feeaef0f358b493da49ef660058b51393db9dc7fbe6b38bd50899aeac4c3e2c61fd2277cab841496428e769aff209813bb5c08bc19f3b5fc8c6c974fe0c8efeb279d40d905c99f55ccba89f4491f3596e95aeab4bd99d7dfdbfc81ccbde2e89c487cd09ee34498997bdbbf967f27d1e904af44b60938fcb15131f23eb26166a6ea52f72e843628ccd1fddfd5d58780b00921e9db9106a704c76fb55eb930d25078af05c2882dcd768e6a092606583d14a1d15e04302fb0e0a84aac12407595f8fac8e53a279e04ca64c9dc3e6766f5d22e4eebb99bb9b92c276377eefb9d60d03628df6c9b0d17e5aa787559cf8d340588b6f1c4631b7437af32996b6a32bbaf1638c7a2914f62c51cba1a2cd0f7706afeb199d5bc5b13d076d5a326e89d11c8fe6181645e72135480af4136fa6fec741f531d380a6e8c08948c637264ad576bda3c3c0d682a60ff3c4588dda23e020b234e907b87e1de4347222ea5e9701c67cd05feedc2032cb9278e90fd479ee780aeadc4f202b4eb62729451758a31cf7c67d18af9303712db23e4ac113b8da2a856389eb804bcfa93d3274af3afb543f86ff2dbe8fedae18af3613bac812273de539b6e4ed75f415bfa27583df0a605fc2093c771d8d66bb45b586ad18c0432a7634f6b621a4ba70ffca50ea274bd2479b854c504e00a4eb33610b613e73ed6b5c46c2c3bdfbc0384ab49386c9eabd9a57b1fbe2198ecc487b38bb6cb71221c3224c83b5872effc74a08f37317a8d7c4d7fd08070136e9150858a4b842d5782e687b03a53ba677a0ed6e8361456eba81a7d7b19915f09d00122d1c659c95f1fea33bc5df2a17349cff30f4f5e96966e3fb679d35ba40165976643e42058448f4b45b25bc9b3ab158f836aa3c4dfad04d0299eed459a527062928db2244901d11dfdafb4a13a901bc7a1608d4c1ca80f799a784054f6dd1e483675c040ff510247ace43c7d7e9a07cde991612a3e8e915ea7bbcd2ad4e858c48747139d1eeab79d0ebf8d4534a33f06402b5cdbed1a9ad2d50f2f9c6cad704b4fa365f09a0d4723da37f3f3c46ead510620402883a273d2d0585ef476048e7b6921a144c24b2fdb69782077aa64ef7c56b60532049d3def634973724ab766d774b7f45206460d10e0813de3315064d354392bd641dc8a9151bfd9e0e80f3603245a571e7f6b616ce5267b3cf2755b6a3ab30ab1cbad7e25e51f7749b0486176d9409428e82363024ceb10f5485467900dbf1c286ca14945fb0959ce4f418ca74270f1cacdb5c4f6b6d2ed92824add5ffa71a9ca10f573f79404dbbf7081ee84221c0c7b747e451395dc57206a8f61badb036e4e9366552a005c9d428e475a7afb46f47f57a7c4031223df90d0db3e637296396d8c00c78c4455d9eaacf1945c8b3fa9f64c101afc49c5fbe7f9ea4e8ffd9c29373028accf6fa7eb91ebbd644ed247470c6d3de08698b809e03b19da0bba102194a9df421e7fcaa62da26a4c4fbf955fba03e2098be6e946ed477689fc4d5111c0f1a40656cd8a2b5a6a1ace05212cddf431d65cae029c5c40a33d21574f244da56f4b5763cb5d635c9ab951a2c034340d42a941fe68b8b7e3c1c0ad5cdfeaf0f167c94c1ec802443f6d20f74c7c2eaede49284abc626b81344ffad9015d5784741ebcacfb0058d360fad2bf69762e888d78a59d810fc585b248ef7dceb3199eaedd544bd5256abd8687c84c547ad745a840e6766b70493df90f742aaaa915a51661ab4c81b87e45b8cbfb8558ebc7db01ee26cc5803305843c1258d2158374ddff38ded5d90a6be9eb6f36bc8084cbbac858f7f9acef387a3633e4d83653c33482347bcebe4dcde386fb5d3306041c02d2203124f7503783fb303e3d6ca4c9fcdf9ac7321d88ccdc555cf96053ceadd2b014edfb588614339972aee83368e6234eea77006195f20f1496767efe0847875e36558abfe5571370b7161ed3ef460168526ad4997591676e54fad7be8a33d36fa841620baad2f3ab6e1a1b03691f74dbb4665f8a690ed33d0d652079291a9bab5d65dbcc38b3b807219c8c8719e099b9fd8b36202378703a4b53b93c5619b505bde96d6228f4a1a41e714c765bd6afb81ea1bcd4cd3ea6a55b45478b39de39858dbf7efd849646f713688829738dbbd3589db9af5bf1fea852973e64e6c57dfad02be7bb2cb11028aa3827df85dd622856d62a2966903e1495779f7c3dd3c74e789dae8cd443928972174daffe6fe5a53798dd38ab96c956a0ac2869c9f89fc2617a8d131b5c4f24e793e7b4c15019454a8f2a8da2a0efc1c0ca15652f419f8b2bbd09264131daf0911f4e8a662965cbd3b5f2d3df30429822f47a292b38517b47ae34f95057932a472f79da8824a07f8e7098829011c13794961357b99bfd2b33519e4b2e8febc5d0f8c9a191e296c578956fd913f096e48615f1ac920f0ec883b6f6c22194c47418df21fe26c704edd196c94f846d15240da8318e810e0bcb7dc6fbecbcb6d424ed86eda5fc18a7ff5ae8f789a46b5e21726ef6a6caf95df60bdd17ca89ff231e912c9806a7c2b69f9eff1d09ce65a3748cebf9775ca6e95606d3227ef4f293d66b0bab1d2911674668572017ee39ad1ce89a36424a97d31f8ef946672cc788155e10fbbc110fd58c99dee3253f57263ead8d516686ca14c68856b45e175d241f02f9bf7fdd6904b84c1d7f6c1820fb06b1f8604e12e9c99ab1c653e638199986e0892821c1e12bf1a4a48e64c73c5bef88f27f60e91e199b146b8c7ddf2d6fc9e92ac2b38a47da8d5e791abf9dd6b1b0570d0246fe3df027be8855fcc3da0dfee9009b1429e669d0cab6629cb970a22724fb9db4dfbc3ed50e17fd7b806e83791b4bd9c0b20d144794caccf2d73b1fd7d1ef7aef6a95b9d1fa87f5fb23e73ff6ad0d1a1c560d22b97accbd2ced8c5ad3210dc66f1bed325a50555481a0e2149012886711ced464e5422c4506775a9912d15911b615333f8aee27d5ecc937895509f5e58a5c80afcc4bbf5011c81a0e4d4910c7e434974dcad25e4316f44e9db56cb26cfa2888e9f4ed913ca0548db9784029f6c0a55c77ff042eb247ff4d91c256a8980030806e56ea5add3e5032b93775e89d57def08e83b7a01b198b978c77a82b9869bd56dcb1aa7c010fac4242f46c090ce971de251b6556ccbb754200c3b33a75a5f261764f604a2fc0c3ba737ba4fbf3f9b700c97a68328a099e5a856d0a6f565a17ef518ae9dd12f5aff3adb7b6da9a0102f966bdb27c2b5119248677908a6618ba48332360a209d6fdcd69d3aa8ba09c36ec4adbee55701b32dfd6b1a9c3149ef76b8814b5ece8c25e5488e8068cee52ce43113f25dd7365cf83f0506664868e07bb728974ab616bc5fb0931416eb6d58270439c4a9f3c11e5114acaab1ff4746acaa7c9c17efdadffc552a6af512f620d71f7996ff8eb773eecc6013da80887a3b8bbe01ef182f7d63e8e7441bce17e3eee98600a24fdcf8da3ad54f6ea82d00204ac1e1ed43cf53a27e7d50ea5d84773f27b5a550d2c7d18c1da0f61300c7b23973fb568c520cd12492ee7410430d9e75c9bd7d4cfafe39fdf0a984a2aafe679502b4983fff2f33641ab86ff4f8cd6f012d9a6742e111446a4e52fb994c0d4122c2ac79286b084fbcaa7b12af143629cfa9ac94a68b278053e12eed9638b36e2b1727c4e1c5a14d2232f4f8c5fabc204b322782a15ad8e5d8e82f0e61b6f1be77e24872119eab32f899f547305994e38594af538877a41a6c7e6a69f401a00db832d1c86db788a5d59b11c316feabe339682317a028e45ffd2c28c8fcc7721380d409cb33889754c51d7d5ceb806b9c79e23f323c9fe5d74425bf22c70bd4c424b48fe5aaee06bf1625d76e83419ecdf4eb23c7507ac47c976dca9c750f3c2fa9d11e58ff69151fd127b0cf21538a0786bc9b29fc36c010219e54b7dc515d64330860d3f13cc0177531ffde3f6ac180e78a1ac71ce14f8ae75f4ea6ffd4571f0c9db67fd0a0c54526f081ec951bfe0b395fc0332d30af2513c8e5de27aa11b5d5a9ee6972f580e5c72525141554360e681801e0821c35b3e1f30d0dcbaf11720099d8b4d0b140d089012d57bbeb9c27bd7bdf7bb0da2dba14e741fe851dc08f3ec7af4964a43c9b4852060abbea1449a6f5f9228cee85dc4a9cb46a20b89747498088fc20666b5726f7bddb0a3c64370f9de47bdbe12af3f2bdae48946e87625056971f29e77c44d75ce9ef3911149c7e32ade0c2ec313c7b0994191097acd8a89f224c8b205ef1cd1befc298aebbb4b6f0c7ded79ac9018a5a70d280cabdb1ce65d7278a6d4d7ac2911fd76ae138233598da22cecac3b4587915bc6df930c91e5f9deb024d026f02c33571c43c637a0d19a8ed2c2820ea137a8cac0c7582b7bc294e76cccb76b7927a82ff19223cd5758584ecbe582d37f43160498d3c1267a6f8e21fdf721b4d48eba48fe9130a62d88b58c5bc5924b55476e5f90f6913bc7aab5f0ed473ee55ff7922f413dd7a9472c0a5727f2bf0722fe1d8d8acb45ab695b9a6c1eb4bcdd846a8a439eb961dddc920d3faf8002da5d18ff1059b9db7688ae3cc4cd8e49ac31fdca14326a8d06f5b25e9cf313e728a4482c7e4fe4806853872fbebcfab722dd74ad8487dfd5138ffa79f6ad31d7e1f66bcd84cb6dcfdb156de3cfcde40776757f7cca1371d4a3430c9a5c6d6b545845f79c23609941c8f9a2a6239ddd786bf2e6ee32b234c0c10dfdf20db47f00cbeaf3340a242753c32354b7e7e7c0a728d6f87639e70d7b56f12bcebf932615f8b756de3cb73a3c0a6e67f742a43d7179e57a4c44e614010379ca906ac0642a23c14930f7ebe61b917e8705134e68a1ee691d8cd20a9803924863007f3ab3bb890e9bc8858e94cfb19c2ad4b112f54db5f636e8bed6feed518454e337ae7328832a83827426cdac4c7af70cb4dc14673f3a8cbe8c3d3e8ef48ac2962a2eb85bb8196eff87a7604e583dd1cdfd966f771c0e88fd05fb46f204c450fdb8cb7c9b813df52da5df4cbd6942345969c42c52b2eb9162d1d5d0bb386ac9efc98cb9b127c3c23bad254b691bf108d3d9980e5f45966cb3c6993eabcd4da4860b438f95767d66147a9f12d04d4bd3e994c88d8607742c3bccd03685ae7094f2781f10a1a97b6c47fee2e4dcf10b47beee917d7296a2c28e92a6ac3cf67bd96d334f02b9f43e4247fdfb89daf2f57151daaca994fde0a42d9c8a8326a4dc2a5b00bed4f3a0f2bf4c11c5b597394580ba76ee44a8221dbee4de13a054c1c0a564b572523c41070a786447f0f00747d5765b9df158a41615e57e2750b8411ef5b52ca768b517a537a1b1138a4fd3b50da84f851ed1eaa96a3bb7211cdbc8f2d3af49dcc1a99712bff92f125449240c1043c94cc2b98f068e937c2eb05d73af93c971798390672e9094ab1f325947eaefef98dc759b8f1feb07a638e0eba15e74efff694c15bc043ea8138e95787566e5a225407f1ea180843031124a00bbf769808084223150cd6300ad24e09c6adf69f51e626b6cad2c6f37cb4a6b1be4e9fedf6d478a4f1ad0957fb5453a5cbb99a2ac00e12d77e7c173d693627e113bf09f4f9422334a9c1e21d7dc81a1929ce593273ddecdcaf7b78ecc4204b142f42fbf79a6f368bf2b3402d142c16cfea3db115f8444fe79026edb3473fb57ecb0ce7e06a3a1c433836f8e751a8e723e2473091a1f643ee0e5b37100e54b8b27cd28215cf8bed5fd7748491dadd089a650c69036a9e875b06e8f4a492766e5ded3dfc078a859d2dbd114d257fdd631177b83b941ad145bed0b4ebf281548638c5b9215fee68b6286f45d8f903148ca351452d66e2c263f6462879d4fa4d418d0ddbe9097f533e60b7a043bb8cf44bdb3c4ee3310289ce7bc9bcb2e2b64f1e1f8c0ab97a5e1c2af74b29cbe61aa67ff9ba353a58815f68e09b2ec874c8fce7585a5d74c914968919c7d5a925a95ade6961d589ed5267c8b518fd17602ef490b4c9cb723d0b994ef66e49789bf7c5c54c7efb2f0be64c0c7ae58f8100439d69ef7e4a1d979e7fea3453b6b875a4890bc9194e0c840a917c611cf592d12e42546d842524fb23ef388cdae45de0d6c3663a1d72a30c429cb5018a262a6185d6a764f55d54bfb79a915982795687e38de1018994b7ab8a5e576275d2036eaa66d58ca844de47cceff322a9d57c99f67241cba368aed3efe217b18d46d875e4cdd1c2d4fd156d180e0fcf0ab7afff31c5d5193c00e0dfd36db895b0944dcafc5fd732abf4b66eaa4dbea41941aa697aa9ecf4a4c662cf4356acf6555820518ed211bca0fd7f6ff04dc2e410db1920b4a7af54d5e53c4250bfd88b87bcd106a305d009791b93bc784521b1f813bccaab970f399fdc0bbf154cf6f6b832ae2d3303d446be2ac4416f34857b8c528eb18b06e60b8b2bb40a70966af923ccb97b0f9b79423638de2b59c120eea5acd8eb18bb99b037e6a696f13f565b29f2c62b8ab8cef59605a36a3bce34be6023a1a812394a83f7e0d1cb4063d248e77c261ed50a171b8f77c94e87f2bc7af14218b61da2b7cad5e3e4f22bc8b04081e982e2ed2f2fffbce354826b846f8934c02d537b0592343167564664c045db48c674d6f5380a2aa8d55de27f133783435b0ab359e73b1a59944599c4f5edeb460d6747d1ec3df3038ae56160fbde6323d938724ad60321104fd8d3bc9decfe693a9b48358b5937e6a859afa97725fcf823e8ae9eb3cce54fb5c55951cace16ae59ac305806e961c2fb04a614001d4244499234eccd988324c0b6bbc7807002d667d4dfd8979930641c5d4f0762613a386c284efaa04cf1296aad5a8345707331df82f6b840ea087798949d743c5d0c8180dc71bba3d068d7ef6d11a52cb753d7c7a7e1dae52a1f51c8099122e0a9b7ccaab50034be4b2e24b4bae8f8ff14b173ba5e665317504a5255accbbca82061183a8cf7fd5bc3e204308d2b5cbc305d213f3f03fa3c17b35dcd7a9e600a44b5e4fb17168cb2a5bbcfc7a27b439fbe7536e2a126d45fc98ca2aa879e98f78a4bd729c90a747287efa88a1c524ed16c45f18222e4127fb583ed197daf518d7929723290a17df989c860d69433521ef35f7c77d855db400c5845bf7794b7459a166088e24ce6fa8289bc546e79289781e8f3b3ccdd73108ecefe26c7011b11d13682d5ce699f30044b82fbfba2a44f56bd8ee7f58e19ada506f4b27559b0d1dad7bd3329477e785f669ac34097df24b22a7ebfb6ba3e245c2d587cfe5a8d7856f61bc9c75f0091c1c58df13bf32a1f803ba1dcf2973d2362ad286dab7e6ddf265642d677b93809238f45045e8399cd490cbb52e461a63638ea129957b2e6046591ddcf29e1f1c757e5d7de30bcc60852dbb5f99c7a8f7941aab93fb958d7d3be515faae247ec338ba14e50373be6d478f7f671b6a808ac619dd9d100900c2da2f6c7da892840e5ca07261d2c354177173495900771ca82cd2d0626ef99d78a688d2da3d17213658e4217663ba1f746c612863dc52be1fbe1b643c355a3daae692c9abad773a7f8adf11b9393cc70a252fcfc9b4cdfe06cb2b03e229332ed730956e902e8a7f708d2eaa9456c4c096796e4cb3b836e14b6e5e0e6cc7a0756c649f79180eaf812b078a6048ee3af22729737d43c054b5361f453233f33070a8d73aaf54d9ae8b45089356629eaa3db6f58f940b4d8212efacbed6d0f591ed27dafc4a3cf68a7bcdb15ff1797a18aee513cf83a68ad7504fb44e893f357c4a5eb0a106ceb317e925c288cab883ee75db15cf5b266d05065b672fb4a16264c21ba1622973eb142b343abcef8177e3345d6bb85a98ebd8d185b3c44c05259396b320508911560a26ba6c9bf499aa40ff6c3a4a4c5de1f46ea715ca9c2b6672641f91c12d5fa0e52166848a171f7493d1aba43971e90fa3bc00d57d167c2e4ab5e7daf9e00bd5efb073f464d16d4f6ae968873055fc3e31a7b6ace9ba5c926fe3cef16eb62f200c35a7b9322c718e9a21fbb3bb668830bcdb08b8bf62e14c0bfa5b8f02b8ac75497d0dc3580d754208dbbecdf8a7b49593d1740af28cb5ed0d130dbf1e7bb822d1b6bb050fd3715292f2bb961710d5df8556cb71ea8162a2ab8db595b501bc7023fc5b508de36e252b4d25085623129c05c091255e7e630e2d5484d19dc6de3c779bf9991e1ff33a8b7686d53c966d3ada4b0091d53fae35035b35300e863eec6ac399abbb27113e445d16302c1627b665635ca907935e94cb7793413c22f3256bec187531c43fdb18684bf6df1b6c44dec0a096120de6ab25a6458db04ab6400156369f29c5e1414817db121f9696d45a82b67ee1aa1ce4255f919fb100496f686aa332d160084295f8079bb15e0b5805380ac2e42015c5f4b0f97c1755c7bc849574bc6420e28a778febe822ec89cd76cb687acf00b987ac70d76e9f15ba1bed86b00c9c9c9e07126d95fa63b3689346b93e5552b27e9a3b0903c85831eeeccec165c871dbe242d1c95bfa5adee976cfac4262b6267a6b367c62d132f289c364a44751fae838afb667dba75cdd64b7fc65edf77b26f2210d84da58164498c896332f449431c7aa6fcbc146560f83319d69ec7c3a146c845526de61f6f1448eb3a71507fca65938957c6a70877738fb6fe4d8cb6c3e3695c4e3e9ff72b428b968836fd0eb5991cabf3c08a2d18caf3f850be18c76e43bcb2fe0089b1d30e21af6b425259e2dec86ce8e74152fac9b8b5ffa15eda30db1afbdd26ba508b559d88a37a9316364100862cbce165775fe1f660e578c3d50d5a30b8018d924f91ae85c03c20f0fc6e396c87af8a972f65c8f367b617bf9f388e90baec0c3141ff086327ca3a574bc59862763559530f26105de5044156e7405a039e466c0864050662aaebbdf34f011560b9415111c8ac6504c84456653dc418a22c7ece97830e6546c0c7bff844a73441751a5883eafdd649a91c762cf96aa91f358920663ba74e9b20e234f85df6dea19a1acb2c2870269073005d59f55428f634c7736ac84e8512da7da97eed2a61d938cd4108844510e44a7073c9995c1605481d718216cbc0c59cfb4bb334cbaada9cee5a971539f15881cb1bd0d3b22a663f1d386194422ff59164087e8488eb6541a1d8834cac1b3dd13b236774bd5d7e97131901bcbbd9c4f0a4e49b3787bc800d9b83e58551cda9c6b09659a70385cb2ce7f2888ac64834a85b1a12bd4ca4a8f69507918725eb0e4354deeff417b1dfce77e1fa9e7f369baac0cacbed499d734e634d114ad938b7d06707873be0a9352504c469d644b6dc060b495ab717be7045034cbbde813c8d074faf7d09ba69786d7a1115b074111691b07b9474c046ddcb5d09c1b6253f1b57a935f4b30db850fdf66e48cd2b150d26af0d2f5cdf276b6799351597aa92c0c127ccd2fafd0b17afd0c88ec9329cc19683ec1aa77490ec286c0bc52bbb5724f37e5e5ee452b157c0399a1e51035207402389d3489367ab58069f956bd8e18b59aedb5051b92a66779250373fa94bfc46b5add033f82a1d3c36a392d5c7c7ddd02a31adac20643a0bb9e742f2749655fb148fa9e05c9cb63240ed7a23ec59e7df589b7b55d63c3906c444cc96a7730fdeed1ca9969897c2301e76a295b0906be3f1fcff71455c0ccdfb4e91f9b85e49fb74582c300ea0a59ea41077af86d5b01f0d8c753b4615c8a70c1d0522877bf30febc72405eca05e0b404c86fe248045d581ef87200c97f00a2c8eaae00de286e78be4b0e14df799231cc335e83821350f6568c40d36db8b1d17a28ecc19e88a4d7c5b325ea4e4afdcf6a600a51ea5013a70c69e78abb9e831edf063ce72cd49c598060906ec0e6700b2d5853a5fe9830a3b4d6d39a57ae0c9ea2d1b5f15686071d93704e847183d89e7c6bcba44dd2ca4ea7756356253024468454a33b869e22b56018cfc5c33b0ae5c843b4a35f7767711d2f5b45232d59959655d37e152562d59437580fa2cafbde13a6735d07b0e80ef195dc113ab6665035ee9c3a94d437d69c7e3a9371443f1658f2cfc13a010364d7e60b1c0dd56668e87de7f3a0a4c019624e13f721cbf09a6a0de0ca689cfac154f8af8bcb3448f925293d42ecb79bc58e747aa8f4dbfacfe4e8ea7507a334bcf307a3a5ef36308d2d20f95581f7dffa256d15d84e36266097504a866e14179b77058b4465185fe9daa1185275e5f93992da341573947a7cbf94a089cbac68d6a5e220baf3ed7aab83e201575f6f0e47940eae6f21c0d8e56ef1914ae8cac8993b99886e85a09a3381f5699ee1b5d5310040a2fc16a27eb2a8407ec1b3c857ea272972a85d9e9ce3cf4b03e8c1bda0f323063ce3c3940bb718b115e6e301d1cce0346e0c3632f98ce6864b3f320be58d3c0a2e2b23afbcafd508c1929b293fef8584d5c0ede8756aa3d9baab3620c7af90b95f96c2704953d8885037d344307979f5030019614d759ee07483d47891388fed0f05648e31c3f315b29617e20719b81088aa82ed1dd86c7df6ad1dcc57e5ab4f69561a04cd8fb8acc4a321b52f4430b14bc2c7433310745a8ab7d99020402dea1ca4924c74870dc6b84279047bb539c5f7f977d232a430784ca9b45f91d1409467eb2afffc7535208ff1c743758713d796e0eafeddf6da656c650d4809cdfd1bc8bfd7784defa551988b6e2ca2b26a17cfa831fe733f450d1b5f2f0f9e11fd3d02902d9e81e0182cfc8649b524510f22d7b3e3c9291040b219c508967af725b02d7a1df44840cc5f8586f62d600c596fee1ee122157aa326b9aa79e8ccaacd41da463fe0e6bc7bd52c8039f2136452e3f2c4497202bd1085dc4bb0f3869b92012f4ed6475f898de633116e33df45eb20c95954010996768e56e153a52cfc7871509d59d58dbbf80b969ec949f34cec44a4ab69a9b595ac200adba81ef6ba8152302c46c6a42912ccd362ff346808c2ff862aab68592b488e54a02a0d838ba439b165e81d59f8b9c05dc5402108a1da5d6ef9acabcd2e20eecd9bebfec3468cae68700a7b363ca6efc7861b4a82c5378b93e87aaa29552786249187a74f9e09b4c05bb330b89b74eaa983b560cb7b5715b443da1c71bdf3b976840cf183f5312d20ff95cd3792f11502aa18d4ea35425afce96d4de8c018b2b732de32331f0566db4ece83f5d4ebce0c3908a40612db03905b08931e9c5e433ecaaa7726e592137902d51128dfbe52704f274aab7c6e8102830133987c2c734cc0cc5dafb63d362fe5325b12351bdacf4e32518d7e6c826026a5f4cc8067b7f888769ea1e935bd4a5ab0a37ccfb11983653eded9bad6de91d20a9718c655da11d5125b00c314a82f5fa39cd2d58e601f3de1b5c129eeac7166feafac9063b5a8bcf9c6c99f07c07b9e08e37571df6bacb8fe9a51ac317bd78145c0d68c2de2385c15d53e969cb9209646ad7afcadf60ddca619daf2ab95236f5d0082acc27b2a9d16527459ee69fdf4a53206e9accf8b1bf92f2c76b62fb934dd495459e623dd7b8f1ddd25f86e4abf2fe78f2dbe91ecbbd577f1185afd230b76c08032444c7853ccdc27386f5e7bd38ffa11448bf43e731298dca5259636f95c565f3c206efdb8d137c13d72bf4dd5608ba11f687eaa4857d8da018d778a576840c662e2c57d9b2b77b8e026acb302127409bc8fbbe8314e9eebcd243240710f93b993562ca56e3c5b6136681f96a1665bbeefbc4ef54fdcf0df6b91dfbbc7c29d77e97389963f589008fb657641e1455e61a4fb27bfabfe5e8672f2b52a2625c16848a7a6e5846f688da42176db4d317922356c2f560cd0b97612df1df5792f6ed0645c0efe08b53f1895ed405f063b7e94865f6837b1ac7a974970416ec2ddbdfdebd47bf6d95e2e28fc481b97c4fcdb7f49093bf0f0b3c2ce18ee090ea83530e55fb10d0567155a1f7a9c091d2a8f54ee0ea1f9def4637f7faa750128d2f074bc913b6d99b0b113fee9988b0bf79407c79f18e180735b082b2655be8cf20a2b53b3a055c11e37b5b9842d10377f859b3c972f25cd2ad1cd031c24afa729af274640ea8308955306b7b4499ec5aa55e96d4e88e97e28912fdb75106dc7d35821ff9a2d1e7b865809155b33d215d36608bdd7f86846ce5f8e919ed6095debbadc6dfe354eba54f8a6b6401d4f95fd7aeedf2f5f640d490736af40c99e9c3bb19c7e151ad454074deaf7cf8f08bfc7511d48e8ab6c7fa4a47c4cb7a7d3c27980988ec912e976ee731577f7248e549a6d83c3394f67c585ffd108569955e549ba5cbb12a2ff40cf4d3c72054ae789e30082a116c65728a21474d3ac1d913aaf8c7e3fd6c3c1a90e7668714481b2e9158f764a107940247b5b257023620cd5d5d7dfde38e1f42e45b5ae2c0234651edfe4e2caf4f302d4c5809a8e7755e66a583bb93b29fad404ec07c3f35675eda8e01c7a1ba258079e78ebfba8479e50b5f12b19ca870b0b1a88c52cd4043ea9b32b1de775733c3e9b23f8e5debfdba0201eff6b363b033004d4c476bf8d9fa8380567b4ae486127955c72d3fdd5b72d0f0f3595d21460092f34f23d86d1d56b04b970e3267e4f2fd0b43423293d3cb61b26f25f0abad1ca1ab750a3809c6b671990361afb9056f6a314562a3d79efd860ea8a8478274bf910d0c27a00930afd115b7d2e4f7d91f4dc645d3d13c3b43986fb21066b3d38b5f9ab3e02746fda15c22456ac15f2f5603d584c00c644ca264acc20bf3d1ac8a9911013505ebc8ad59a1ebaf42010699d20bad97a5f304c488d16a692d8f716c079def8c2cd0a6ba04c811f720a952fc1a050d4451e17e57c8c8def5b67617c86540470d98c3e0af41d713a78dfbd836a72c4aa3108658c611cdb1493788ecb02b9ed8c96297ca18865fe70e4426b842e120c174aa7d6c923112e4a85bf91d0fd90aafaff0778f85a8ee11fc3edb0bb12fdd734d06066da94f9c854095c96267154f5ef14778226a2a1fedb013617b8d5e7084c20f35991a770fb1e081465862adc936a9a6cac422be49a66617080e348dcbf3a18bb312983d696c8d2b009a282f0308a14c0b32e25688220abfa73857a7486679a4fab473ac64f8485d8cc008e1585f46b4a9f2940543b537fedbe086dca45174aae828a440629d623347fe9acd77c8c4c87b1258f5162f42cde7f732419766078b357d1104aaf006d0cb27b600931fabecfff144c686beb470c2804abf9ab4af67306e6271f280f0ab8c35aa7aa11a15090e3b0f93a10ea8e765782e9d87bdc2d743f3fbe02278f8caef890cf115a88969fc36b52867699776de969570fd88ef3fbc222d8d3205523520c77619f0731aa3ae0cf5fa3eee5d88c901fadc5f5508b0083ab5cd57668fe5c0758f2503be8afbc330dfb63c19f393f149799f99ca7179d6ec3d1e4bc76a5c6b4de6ec59b3c58f73107e8d5f5aa88a160ed2fc535990f2154d85d7c7517cc13c3c1a6a652a88c12f8f2b0b0b976f300b158d9eb1a7d2044472d9261c0388a2eb9ba30cea872eb0554698bb7c9ea304e5b164a9ab5866e6e1ced55634be2c981f7ed48305c4a8745437b997c0cd26cd5bf2d2134071dda0cbcc44315a34e7cd7533506cf2d021cc94de6caee49ce7cde6e3019991deb90a7e224ce4513b0daab0cd417c1e887637d8098b40b013eb591d627089acd0e92e6f56f1db277be176dc80d85773d5d59e8128c2c222fd5801e1812162ca04a86cd861aa1249707989c95aeb4b4f01d60a629244ef714f4f1dc8c00df9604abd1dba089ea7847e4fc61c3f145244192f1856a86c08db2269c17644b171aea9e846547fe355fe1df15933fec5bb169c045854a8631ff29f47ebaf9bbbcd5c37b0a82b3dcdd1efd025eaf4894d6f7a0938f32f92f4ac7f58a84f026181f23351be4ce648613ac3104af7d9d46e8b4cfe475892c7928f3f3137fd224c0cad6dfecc7c0d9c92db9fb2954dd6f7d7ffaa36474f0a46d82007425d1915a79b97572ae0a486ffed70dcb130a502a33f0be90fe2d242914df4ccde54e47fe35745c9a777e424a4c94ab198d3fe3e0df6f36f5c73e049798f295b89ac07e3eb9b99a7b83e18d7d7e35852b385ed61d9f47ce010e14872b2e627bc77d6a66d6537c4d6b265be3bf98e000131cc325d6efb0e23d544b8df486e98d3aaff7faad5c602893d4adcdc87fe6ecccabb8f5fa0aa14e416a10c4f14f2ac07a511241d2a0bf930a4aa218a96967f7d95acadbf5fdc8916a1b41fbafda5db8eb4d704edd2cbc6348f00848db2f4bc12204d8adfc442d7dd6b5061d6239010fc62e7525b33f8c5ac5b17bc91206cdbf488e116df61d4ae6b84bda7263b4cca6e03c8f8c7847928543844af5a1a8c278f46b1ae5e149ebdcc07734dafa7b582adcdc0096f88d2fe0666146f952a10dd4294c22c1aa38bdbd6872a56236f93eb65285ce70617b751237ef15f68069bd8f93c1a13e4be763ed3dbf8f96d1fb0e685c441875b97d9a9e9d4031c2cad3557005d4f7446fd2e52c65bc7ea6bd3c5fcca9f9bac0a5b40994059386b6ecbe425ea8639787c6f542e73c9527ccda4eaa32326864e41b23d888bccfffa4741182727d2ba4167e2a58ed19ba6ae7c8ca072f059d72c4e9fbf68fb26ac1ad7d444e00854f043c73e4d0ba0a4aca18c00fb2ab287d78d673e06445c7e58de0a9a69dfd393cf2f4b08f0f0afee0aa32d28b46bfe35a5a1f2c0b555e80e7509a754c3724269b17637706adc0c00e447a4494e60566038e428596e81a87643647452839cd1ebeca6c8d9061be4ce78f70deb1a7250f781ee04a217522b61f07c29fb4f65b86c00e8d4ec788124fadf065b527cbd0de56b2eb14adc4a00c4f20ea1836f648405e555422f898e77186a2c6265787b130e158b626955e25b26f7689fe90a4d2f167679da63549bc9fbc5114d8f8bf2195cc41e16553af79e502688d266f5e77e78a00260c59757c62803e03b223b3d07b03ac5e56a9401c9bcdd99beea7108561e669ff362998dff45bf0922f2e13638c0d39875390790bb6a96688c90e90e6d2871a674f79de8e239d765340ab691303b444cc9406d7abc271af06ff44af4fe9a21bd5e997241e3cf7f6f2c26eb515d2524f23155e5b4318994dc795792c143ace6bba4d23438e7c709535ec3266b4d551e9df8ff59decab7b12005599de62b309085ee9584912a5c1b9b7c06fe0a1d5f163610ea7011d77e03a69285991f6721089c7fac2c7d902a4dbfb691be218c1d0f18e42f5385d3520f5c83a1e77f5c0cbf7fc48e27aaa62a30e1fa0fd7e4494278ca3aebf416f2cd5be7fdb00466453670fd638d849c82cbb338c817e7a74ee407302ff0842e260eece503db353669fbb6da189c41b68fe00aa14c672638a365c7638f76ae327a893f308d075e7765710b3b4a5986112d9c75badde681d38f18593746e9c2aa8e1ab752284583860c860af43355bee370955a56cf7aa9f11387c9e2d07c55f5a6ef0af8e8bd8795df2aab0af96f25cd6bda444e5eac733dc2c4971c31b50c9badc24f43e289f44b28dd0de94eb10ac60c296f3348a55e161cc0b50336941c1b71e0e5c447b597dbdd7040bcca79dbfdfab1332a37831d9d58bb3ecdac8426a8311ca10ea4a7cd734b327c921d72e01738e72f67693865184337f023c59fc8bb3b3f4a5026e73bd8f9acc3578993ae94844b08bb672693a3446dd231ea7ac78f11e03bdd3a644a79386c2ab627953905b5d731ff3340579a39d323ee89edaeefb35ed6225f09bb58c2fd30ae93e34c104d1f5c8f54efacf3e000bde81e93c0bea71015558046e793950ae1dbc34e584216f234d2ae86591778b734576a0edf4f517f5b4d4db13d71b9fdea83a3308fa8b94d4978c749c2cbd945b832037726fd1e380ebbe6289bb572b5cbdf4a1e420a969d157c7ae6d1e29015828727f1690d2ce9fcd74bdffa22890008bae62df83a4135b6c8c55a7c83673ada33f68212ce17986b4e7f18109df80178c2c567c3f2123b72449a2939d2181eb6c2d82ecea7ef4faafec5171b4a6222da722d81cb83cec52fbbff7ecceefda133caaf1ee29f8595decb071141d8b62dcbcd3e93277d80245acf1cf0a40169d4df9447b5f413e03841c0f3a423f2bf110dcabe524e8ebe9a8425e1842a863829b08cc708da695ff4b8fa3ce39dc81875c978dd30df9ac7038e4bd5ae30dbfb11043072b951554ec0efae02efa1023ebee8d120ba3b10230cc3ddab0043406d3c3284718dbcf05e24bc55549e3325d82f294cf8b40bfc7bfe8086d0c11f2b3f8e360d825f797aa0c47c3082fc14d7e4d7e9c5cf65ba2dd72c82bac617928641e318b7021ca20ce90e08e4f76fc4942f21dcf70def6b358b45e8dde17df1daa3bb9d1610f761afdb753896618d68f38b759f8a3aeaa518caca7b1c3d8c39dd62726402482bfe8cfe3c00c85755d8003a135ff4356345969a284ce76ab3d0f3753155837e763d51165b232d23a6e75bc9c0d23f6702a51d8d159378dd99a299987b6450184c6ac120cadbebecee985c1d0035989c55d4e09e80b763d6a19d7a953b574cf20d98a07c1cdf0f7299eb04de54ca7bfd704a0ae341e0abe49738949b60293cc9ebd1618fa641c54e4af7f8bca49a0863bc8fbd35a55e0bb08ef9d91e627d1cfd26a63d92db4220256fdc07e4c506f9ee767341e1b88457c5689db84afd41caa1c187eda1df03258a9fa244e617ccbe64e76cb660fcb971494f4393b07ba5492b71ba382283080964204dab36a8da53a8a07990d554d59b3506e030d6f6f12373f5efd091501c7f406f00c998e3f24ae09e3cca706751346f5b6e6c6c2eb30ee6f9cf6d5d863d34022a282d6cb7084ae3211c1bc0d06495e6a4844663d03b3aa60b05ea48c10920c84208245f1bdae92e6b8f1828d0ab7698baa2edda50da3d814411c77019e3f558451875c537cb6c23baacd426427a45fc86cc4f31ebaa7f38216c28e8659c923563abd8ee6d85698533065c02ade219d9dfffa2f117dd632ef1261db7871cb6dff62d244fc67c52fb38d4a2aa270a66a21dcd8bf71a5d388b5138fb7abf1ce466185365eb811db8217d1f522c8ce426f7f67f50b4a2911ce83a2c7c7fbed4cc87ae2ed8bb342cbb65c5b8f5c2a0e66378a0bbdf528927c88f23cb878f1457b8e691a753710ec0055acc838afa9750603856b2edf0ba70f813897b6f5a1b25cf309a237a6f5023f345fb06f925aeddff29fff616bf57c69b0472c456189bab884efafc29cb696bbd382dad5fcef23fb6d0cc72a4ff7d5515a7fc627035c9de5d8392476bc54900a14c52548316911c86f5fea92019dbe253213f1d0625a50583d10b42379fa2d5b67ab2c79e10626ef9a4535c3981560f9657497631f2c782bba64288558177b04d9f1818781a68a9b25432e2571cb4a277dfb7517dfb0df2a858608a8232bb36ce64a273063dece28833cff1289e08896674e0fc899ebbf8a716bfaedc89d2b58e05af22da327ad573e23b7226b4f9637f145adef3d9671f4238b4a2488b37462e7f144b1ed08594fc8ce8b614c54e36362ee2a6d13b8e9a61584d033beb310e66c9eafcffdfe22d5d3cae0420b237fd861a2e5cf98eb251e20d2e09d7cf8a7c4f94d36295cd8c17f298f986e2d24dbb722dadf9f4c5bb2864ffffccd2a9f4c37799033125e4d7a2ae598fbcacbe75825d0636b609555d1f5f5823","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
