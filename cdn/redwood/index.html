<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5062212904c1c42322e3b3d2618f2224eda38e18111c14414d67a6cc4581c69ae7bb82756912761821ddc962e93dc99bc8120fbe737817ccccae49b9faee17e248e64e12de50eff919acd79a2ffe6aa7acc8c743550f755cca4e76cf7d197d82cfd241b3cd61461d85bb04f5266377e419f5bc870457ceb5cf9f7e0dcc0fafe955afe33e69beef0065915ab44dcb947e7790c82ff1b69fe78cf6eec6be614183ac338d2bba983cbbf0b6df407988fecf8ef799a3a577e717865bca81c36ee19099841fb4cfd5cbb77b74eee40a37a66fc6e3256e9723811826a94f893936be5103c9753f84d56a330f4739265ade2d2779e3471b4119f7a143fafad26c34d1066b03540063ea9b3e3b2d5ece5d17cbbca8f41bd24e7cf2b4ca8ea4f9222d407ee7c78cc6f23dacb3d3e1e2a8db408474b1c6367ef453e906e0e15aa3380b1aa908903d4d3de119ad0563c9cbf2b954534b31e68b02872ad441f60d6f8186f9cd2a7b87af1211f26b4aa45ed45edf93f60b051b5ccc3d8ff4391e12e9665361a48db80aa965202ce3bfb816f28db02cdf65711190146b4b7268dceb982df240de155b024fc512b39be9d294f8b78acefe5d83b704848d37accc833a164b383b0393df5042c3b0b4e33cf8a8f9666e74105f278a4f81869ceced6cc69d7bc263aa8bb6720999853126d3d4b6a46e165c6adb01c7cb11bb9038f26635567227853266eab186f4f98eddde1edafd8ad86c5011e88ac38efdff9cfe41a0eed9ef2b42f91627e0c449b3ec162fdc54c8b2daa0b66803ba567d87e041cf65b0c7bc634da1c29a12977cf99003ec4164727c456cb38e0ec8c3273b96bf8d5ef21656c04590e86c3b59aef853e3e239ca7dd2e37d21e8c39436851e5e432d3e4776b24ef478564c6e003611aefa8a8448b6e357938d74fce142dbd5462c119b522144f72d98ea642592cd8914fdb3fda72e7a68478143917f06a720f11b7ea96ea7195224b25d26cc69f1d226501e943823af87b16f1c8b767df8f21fde1a53d6b216a2387c51d7d5b7a3ef723b258b5ec26e34a772cdf52ac577cc07a25a05e469ea2d19200a61081ad64bfdbe582482faf2b8688c314507d8322f2a094681b6637a490f5d63e34272b1be643463a6897ecba3ee76fd3aa8a647d4a707b850b19a6d3f8827468b2a1024fb82af5879e79eefc8753354378e74f884ed5abbc54f1645b617b16cc2fc7e22a5c49f6a1aab22522dd146f0644a4e23726898fef329e9cc9bc24a844d6e607acbb7d63f713df7b0a7270784161b876e5db7f3bed7734e232e6047e01579d91267dad53fdd5fa2dfdf0145a66e9f89c1b2eb8b7e5d832d7846ad8602465b6aa81b576bebd8e58858b8cd47d8397bec8f5cf1454c9eeab8968cbeee4e50c8a124927ee027979b39855f583dc07508bfb1cd10d6041e3bc8642b41b176e3c9e917f4cc1c40376a8678b3c91474f418c6f01a4182b5a5ea9212f51d410f74f76df50bb9439cd94cbd8a5ab83be29deec17abbfd9cffeca3cb00c46f61bac813f771dd60f16a749555afb90fbb960d66719ab60fc3b093c4472320a77ab64a406358012c13026f584b60fef09cb363ec650ef6fd06df4d9efd54bbe010724f6ba5885d88103945ad8f613999fce0cc43607fab62695769ab9f32df9b8bf1a71b919eb5f64ffd50f7b24ee239dbb4ee866387fafe046255a2c6ae3067b9a64be8cdefe969765df97b1a0f4a4039b3b9bbbacf7b43808e0c2049342cd1b38072aa009b46a09f29c15e6e9c839aafe106209f36bfdee69bea3daa311a952e347b05f342199c8d006bff009bb7e97a8dd7fd3cc478af6151308acc8d96ea581cd6c1e1559f7f9a7904fb83b7e7eb33196d0cb7c593142af29bac1a47aba72b579acc511fccc321d7e65da778f7637b52e3eb9855a2712f002c3a7120c4089110745348e50811bfb05d26c629586d41bb55428203ca23709e0c6dd8f9baec6ada1751d8afd96c4f75f0664574738b0135f7bbf31731b552cd16540436dcc3509b0d57ce4c24b95e0e732cde7e61b1a6ebe464d2f266d52cf70ec673e13029eabcc3ab4ed1b819a58394dd38e9f8bf148ac225be76419d192de01cfb5a301d7ad569ceac0c3e5c20a78923dd97c10478f0c83c0671cd05eed40bab0e7c44329cfef70680d3bd8ba1661b5409140d03c78f03835751cc2c88e3bb619f00d766d4f1222925d8139800cee0c35964a04fbadd2384e649a5d0bc2a11b18e090bed78898546d8cd61d5f1c1056d0234a2f7c16e55fe6a5584cf27810d790290718b4cc55d41826b6820ccacf0e689893fc9116bcc4f9608188b97f2f1646ebda5ab4f226cd4995d3c77db9bf3d0ef879072507a50a3710a4ab1c1f1a537dc688006b622062100357c0fca6f7798e6ef3dbcc228c4591187bbadf72cd53e1200a2c79391c9e2d53d6ed13bbd89f7da1026d611cbc511f1fb858047f322ac553a174ac140e4d560b9019cf6f82487d352f7f4d78774db2163426928769ed2d763f8466649d558668aec69bdcccc9f42c6e6ce24488fdcefcfde5da222711cabd0265de5dd6db32028f5640eab2193a1d1668fcd9b4973b7479fb76e55128f5734e34f06080d2e434c0173f4dd454815fae838aa22933de2d1ec41b5923ae7978fb703c453bccda6d811ee0d00e9ef5690da96b02e5165c94d36f773ce2596a379164ecf4e365c0b90acc91ff65a79570a459eef00f9c86b999df2b70c303d51909d423018c86d1fca0bb66accabd77f729811474aa4cc23746b469d449f9e2e7e91168faeeb34aef73151f1a003b9b291653f1eeb161fdd485df095d6885661d2de0690c775e913373988743bd619f730587f388fd36099d679b33d88ead1dcfd26b31d050bca1600e9cd89b642040c27ae19bd13a1222580693d55a3fefba2ce3c7f409d1ca60d83f97ddbb57873444785ba77b4e341ebae4e399f35a18dd72c4e7a1a1b421837e5bf9c0b2081fe638e596b1ffb4ab2af74e906ac284ff49bf0a583817deaa52c000dbe44246fca18b0730bde55388ecbbf6dd6156b273cfee5a59266235fb883fc961ccb710cf82d7cf0f37db8d0bc1750d786f4455d9e224805e76bdd1fa89671d35d990e71b992d460f6ad58014977b97c9817356587fa26ac43fa0ef3d8422b60047e3ae1ebe51e524377e313defd82a71ab844d83a0ba10a16d9ae719eb4509517d3557f7eb5aaf2ce934244002288fa79f465fec0f052f00d84d44a3b28f74a588035fb2e6f111ecd301e017ce984c49a19d62a58a7acd8f1e6a21252dded0ceb9f2aa09309be2e6a4aab3b37d3a888c9e56250f9ecf8284491de1c54867c7bc9f6225d13f140647a87611eeb4395a52bf41e1c275d3cc2d764902b807fb3e642de3182ac8c0303609403fe07a2fe1374b4520f8a98703b8704024345087cad9c3c7ccf175a702ae5a3cb529381b817c6efa22a4e7f3b10a3c6a47df7015b8aba09a8bfc8fc22f3a654367522b5f950a508d137975ca496fd8b14cc0ec212174d48e79cd144bd9d0531cbcd1f63fc9cabef93b6c7548f7d54d937a0f26d0d2c219e56174450feee2e2b921e09d2e19f8d016462cac54a330c0919ad25577536ce1361a5f5d7f2d6d448c7c6782d2f30949229e63615ba60187913acf07355e109e49e5b3c85e2e8f5b0e2fae9cca1f65daa82bd0b74f83e12cad44111a24fb3c9376b41aac9eb68e804485c114748050fc09e55c04f4648e5960a74aee816e97834681d83e22cbe3a73e6846f4e699e1ad685dd7ff85d2647190315c2c66515f8108ed4adc03d29dec39a2b4ba2d40c6af6bde30a311d7d4ea6ca5a355dd5e1b7653b54ca4517cd2d6f02621c00af329797b95ffdf35668edd77330a3294e64cd2a1c5ec30cf71fa5052b4b3cbad1320361e6c897fc67b21f4f2c8377b5d15513f60de395116e3513aa98f1767a702bda6d52a5e6f44e3fc3f1f275e1dc8598615b4fdf6f631a7e2caf8bf20b6914d84bb153bfb77a9bd148f614b750687920f77a006705f92b6e55510b724579d3d4d86688ce656c17fc8bb051c7f149810094e1369bbb608c8cbae0f69467edc97460a80977ebc6904061345374c39adec8f35a7dac3a4306940a67c922cd13c15e62672365a9a2609c011dae382c75dc0092025a2ea311ea08754e3f250557afc0bdf491b2f3dd7baa72244fa9ea85cd48fb41bea915982149d4332f8a6905ba9e4615fe6a85a8a14a74221a0062362e45464e8f05dbb844ce0489d4f32ebc8f5a0b63bfdd37eac10cfecf3de1d49c5a6f66830625f14bb783d1b1056df544b604f4bc8347540a3c9a5e54dc717087e65b3693a2f62e6682dc98efaebeea61df5765ccdf17cd56e2a1e16f2f3f9dca97dd3f36fd79312cd4de309369096fea801a7659bedffa42c5ee39d1946d9c870ae02b989a91f351dab9c1196e1c6474b93e2d1566b35cfb300a0ec5c47aa524d2f73cc671490375e9009d8429cab6c7ce85f209402df347324c2ffd6ff24669ee68e21d690c37b6cd2fea351bdd88b89a2d8ac3ee025b55bef38cfe3506f7cd9f196bedda3272182066c925838ccc26050b53ec9395bd4617b1582be5400839b0d5c313304bfb66c86d9c885361411f98975635e804c3ede7aab71e1246c037e13cda01c7ec273f9f6e6a6cba4e81b3ba2a49a5a91f9d8c73b89436223e8244f206710574fb8546464f5ddf3031c309dcddd0f148c0550c7bda8890b3145ff3a2ca3dfe4db6f18c2b71fb94504dc7224a90a121dcec56d6fbafdfdf5bbe80161e5dd6b35a037f7b1da237a8c9d280baf6b3d694315ae17c8759f86eb6c02b7c2f9dfb51af7708ada9f7056dd2a163d84dbab738c543792592628002e79b2e0dc0becb8ac77c8662212dad428abaf17ccfce887806d8f3f26f548272aa63431e88cc3a832727a3fdd490b9905cf5455cc8ffaf23548734d8690144e3a255e06b2424cd1ce1ce825efd97e76165c2e0474cd0cf4a2a4e73dc03af5b516158e019988faa6f6886e5d688844090c1d07d0a0a3fed5fd30e3416ee70564074f53d5b43e6af45ddc45726f8f0d4bc67448b1e38ccf6e073cc7d9853da3db86a809224d5539422e02c9258324f742839a6b016d60ba60bdb09541ed3e94362375c40727b3895a43ae394d5fce9aef05e6a8cca08490f2e5c3b6fd062f757766a859221503528f0c807b956c0f77f08f6dde364f03e2fc54c67ce7c8fe1d16a4c20fc68b2f75df4113f731d68a1c993ffd77a03fccdd379ce3112b7171a151281acf25bec32f2f6f44e876b6bff8d9ad9a03702d7a0b4b8dd4ffdc59141ab6233afa52dfa4d3d9ab0d43e4f827f59df6421e1ba2cd878ec5a36da8f2a28d8955578c1794b65cac45a131ebb068114fa3d68fd86e8d759096d60dbd4aaa1a5e65609096de21b72ff6a170256109c90a323042a59879f42d57c34de612c8dc72dabe984ef28952d9e3622911c2a7742be659ed43a164bdedec4dc2a3246971deb982f9fcbf00c4af5c820a32df3d7520b1a9c25820019f1aa188cdeefa0ef5e77be316406dd1961288100c79cfb4ef4c07dc3799935a770fa56448eb4bc112daae499107fa6be573cfaf2b816ca25377cfe2f7f66b57abf23204f8cb0a7a8134a5c52ab59cb3d7b5c9eb33e588f42639c37103c13faf773b665458d7c733a77221cf4a8144fe20231b1d2c5ef30c8dd048b0d68c813ab8e1be2fde670b124d6b1e7ef427ba5af2b26513606f1e02c9058fb3ebf8c1d1c86078b473ce22ffa3346c47cf4aa7edbb0fecb3445a68c33a8ec70f1ffd4add10f19a9e1e74ac44c11acd6ad2ad7221b76078abafa59694a83dbac99f699ed1f52e4f892c6d77d053191aeebb62d14bcfa494bdeb4e806017c37f340ec2d4f84fcd80e2972aa4df81b94636efd31c4abfe7cfbac324ff6524c5420578d981bc7dc22bf0adadbe7aff6a9044a16546abc701bd1d8142fe98d825a1a90b33e6ba700707a243574bd6d24a3aa327311ceab83d2281bb68ad5639dbc6e7530ecba9fec32b823da2738ca71a81b361ccfc1874f825deff698e350bb7ace13094d448a6292e7d4dccea188218e84ea2fb96659c94b4a14009bea23158a25824123e8df35385857d3ddcfeeb6d57e383b19c27ff247c0d53408fa9e0a86263c325ccfae133f851407963f9146a9541f9d29120c675804286604e3a4dd8015e4d8eecdcfcfdc6bb6fcd2268ab59225c096338a1d949c6dfd16d0ed9d7185e1c1c07f8422d7cb043787ed971dea54ad4013e7e248791d1a46aec1026832d75e055247d442ff869ed049fbfbe1e85b62d05e0868dc9909a512acd4c53c6dc3760ec7828118c54f8ef46301d91e57ddc3af805f592343e1a249508c1af94431b70eecd50a4fffac89970c71e17a3a2d4ee08a70ef3d2e73dbf566b4df232fce90fdacea9233ee63019400bd65495d2025f3b409aa5617d4393a013a10c55dffa23b6e9ab4db8bc4524cd5f9632828ceebeed0ab18fcd8c74ce107ea62e59ee401256817f23c3dd750658e0fd23e4c40052bd0be11befc0454efbac9ab69381f667fa191d0a7a61728c6b9244596c762461dbf6e13619ceaa0fd2e87e26c34b5af0c76210f792f06eb40158787b31dabe2569f7633149eb03f6dc100289829825ea958ee936f971819f32a2636ca6a321384654b4a5f3b7507026b4241d0b2d423a24155608c0a6e9eef4ce8da69272d535283ef7b730adade899839f2e7d4bc05a9b4e29779a9d6612203f45440c68acbee85d4c219391dcf611053c67ac3206445c3432451dfbcdf0852ebf3d0e4d00f51eee375b2ccea81b9d18fae9790f02fb45adb5fc45b887115d7a0cd99f1ae19ff0f06f23bcd1ea8b7e8f0eeb5bea12dccdb51ea775604e00840711d394458f29405cbad2c3c37f79818c7868abd00173d9eeb0ae96db3e6e46d06abd8bd372264e69fad3e1ed83cb5acc4450a313dc31c7b72d3e3b3e9232fdbdc38a1fb9b11e9417dcfb17a04de720eb39bbde8b85548a279722c3a986635ebe1a520fc004842df0654d03756f734c0d6561c0ed5788928983ca88d510c524719b2d3a44b788bd6342e0e9f064b5cfca420a4188095142c191c0664ef31e419007e1d8a3107addd24d1443d4e7bd37ab2278a97fb449d37b60054ec0bcb9b6f0575faeb2943d00089fb1bf9909fc60b66dcdcee170815742e2a1e816aa6187b9e7767d748552c96e6c8637cd5fa378060877fc9aa1d61096a4a953f673f7a09bfeb93c46edc895d912d5de2ace9d670706e8e05a960a209f7f7242beff5525f682ee641f0d62a9918c65a356b19764131d9b19f02ee5f28bfa74d2761e4c4b04db00a14ffd40958b4b58c4f45086a296c78e32021bc2858108e8238a135d1eb55a5f9b805fae51bd6f927431d0de83bdabd166955892d7bcd2ee200840075528804a5d7d3ca775dc3df95cc663a9959eb4712d7c3393bc1f87c2ebf7f7448932e84ce1fdcd30652c242001d75fdd61ccd1da559211cf552d215d3635ac2f83fa3da988f53d322817fda7a844967e1b42cb19155dbef965f3c86087ad99ca1ca76886b4b4064173aac241fbe7090f8b31fd2f2b56fd8b4d67172ccadb9f82dfcc521c596caf178b36f5eab6e35e3b2846e70433100fd006ac649680648b696feda58d492c5d0c52894c01adad910df5d2c924b36b59933de6ad49768e126f623e75714898505fb259f34d285fc11be2d847e2465e9b921a662c8616d7d90e2555e3b18bbfd0ce0070d6ac92a88bea4649a798405b3ce2f791500668054997df258035b3c428ae7d0a86045e7d92071d9865d775210f64f00eb519a77425b27e8ee56eea326192253cc2645b6bb5a7b2a3a5331c1e1dacc9d4c68a6b239c7cf44879226f3d1c49143d17abba7db57a0d81f461be05c31bc825c5052dee209e784040af1368e435a028f25890720ce1c25b5d4d93e65f9585dd227c39e6ddb1ada2f5b8fac14e9c41b9f30ba41f334889ea6b487b4598be012cf25ab7f160f65a76af3bfe5c527601d97bf693d89fb69278d2012f24757d3b0359f7f1f6738622640144d84ed7b680fe053f8e79137eca75457cc5462014a27831fadadc2ba0578e0a57a62962ab8ea5fed9a1116e7369675bd7a9f309b1d8bf49ed36b336f8e3240d2bcca03cfcc07ca86d28fb3f1b95d6bc421c788e57168ab7c976690dc60605dfa26e91d270239365b1e69de855e2d8e336e30b2898d62be79ab221a661b316305f533ec5811908b26f370fb957e6288412d316286c7c3fa36fd580e4271ecd482e218365f529b1746ac61148904bd53bc3bf371d7e8ced4d05701ed0603b71316eac25a90304f91abd497b17ba561c41d4097c2d419112c4406a96144f81846cbfc9e09e0c7e6f894f76b7ab8a07c611bbe01f81ec0dc1c729be4b96edb2b172421e2605f95bb3dc2bd3e98804f2969ec13a36bbb9d2d751e0e90b4113b3dd9f504858fe1202119ffaa7371c52514c75c7259dfc96acb6c326f295cfa6b350631ee60a27b743b31932acbd928cb3b97fd037beb7bd632a14492f8a8d828b4d1d67f05de5d3579978054ed82f422ce0ca3442443c73832e2fe0534cb47246f4eed5c8bf50128cb769dee4ba4483c4c5b9bde9c35be8e3d20adfc4aab0a9519c1788c4f5abd8f1568ea02c60d13b4f46c2a90f8e03e3354ea98dcb34ce50ef108a1009b0833e820324509e90f8cc3d07e4d718df19ae72f79f730296c08725e1897dd5f70ff061819a50a7f02cdcd92def4da196966ae127d633dbe111f62c4dda471ebfe5e9af9846a4d007572f078b61eb0400d8be6070859d87f916c90c7605915a41bf22ef360f57bd35985d333e59a754f2dcdbf171a3e24eaf0208603867e0841fe3a11d15e8d3cb0b3e2bfa537675e448326fc829bc0caf3e6f8e97d7855e4ea1a4e109908dcc9f1606df3c7ed0bfc37ce11e22c83644186ce27865268944ca3a728e0e9f6b3ba6ddc16bd453f54ed8a5d04514495711eb6b8ab6a611af2580faee9a591dfd95fc01e69261fd59859f6f25bd24833cc502fbf4f69f8a9c21c74c735b1a45e633319dde7031e5c022c643f098511282c3539264b14fc1f4352515cad4415ba4e20599c8f68f9343c0070add0b52b09b1feccd614a0c2e85b9164f7771c6986d01668dc32e5e9ebf5b00e8ab416c51c352dc1e265df5e55072a6e2702a7160850a91939183bb1774b7e378dcc4bd9d51a9ef61683a0f20b8518e39a6d77af8e3d61ef11d78c4ac6a53f9e69332160215f9ceb8cefb76d9b44110f796db72b07daee1dfcf425fb77b77f05d05c97dcb4177ab28ddfbf9f795539f18eff717a21530583c765f596ac05f1353e8d28e1c638b38ec97997f6ce3b4efe84e5026632efb8647b9d4e276ef3b00c7e85d0f9a06e79e703772ecac6ca2d970fc83f1e1ba4e742ff5d2909c13b85ae7c1fbd2d8ff7e1e20f638f4b153ab70452cd8c60c6dbd4a0c817e05bda1cd24ece4ece15199b57cb820559f73b52f1adf17f179c6be78eb1d565070c2d8a01fe57bc56e7fb53e4370ec4befe6b8e3cc6cfa00d0b33d1eb433af26dab7a3b7effc019679937af3682bbbe0032fc70a09199f541b94c8eb5b1660eeb4ff9e8952d0ec433d37f39b48b9f8e326ab328339f3bf8e652ef066e13fa1c35e8bd4c30dd52b59a8dfab6b2eff6618072c0c1cc557af1b74a3061e7d34d4d54eedb2035da2b3501947315b830c79d11fb65c4bbe9161f893cfc5cc62232681a8af374f2d771d625d65ca2e082ba00b3004cbb422a1a040dfbb16aa13ffddd8d73244325425585ebbbfc42b1016d59d727d9316fbbd6d7978283d8c5f3c60e907193613e31462334bd479a907c12f129e5572c449930cdfe101a48bc972f87fa3c6151ddf5732c4f34215d33da1696a66f097ce864562caa5158826a4b70a39a1a31bf80c987ac3f949baa305613219007e74365361bafbfc7ebc51537c4e0df697e0b4f6e4f6e9e6a575c8f5a8465e04dc2e68101a2963ad6613ee0c564983b22f33e479d7e43e62200936dd28f8869584d07b010fba26ae627848dce880b7c4c54aa5bf968fce5ffb17395c8d5b6b53aa835a4914287c038483334a17921e1b47eb2dbffb49d676e81c9fe1612911a851b0eb944499a2dfc0f79b7b7af84cbef83e339bcb2c92e6cb0ac0e5a1063d3e5aa4f83e63ab7a5261c79195d326123fb542f9b5827eec778b55df418d5a0e92b8327185855794c5a129763bce70f2575ff679cc64836653c4ea5a7308a1a83646ddde735faaf6658e72bd94db8425bcb6bef9c355b34b2559fc101b4216802b1e167908995cb74e0691a40b6cc09ca898957ec1633fc371f4a3c6d546111dccc6ef1d914d2dd6352073e1637ba194bb4cfbd7d5791b88bbe2f219c3be1eb8666d4a08b9d76d19ed7a8de1ccb1e9449f139e960a8b4d81ba204077ae6fc765b82c861142956e6bf8a713132ee84840fd640786c4d8073598824f6c5542e0ae453cfebc7755a1137df58c5cd1049ad0e677063553d68d38e0028b2e1affa1ddf4243e164896d5563ed48f6ee8ac375621223e6d0563936489b19b539bbdfa2d1e0a8588dd93ef5c080a0bbb03d2c3a893cbebef33a3c744f6c7c05d03ca25e3329d8ecaa2a43f5bde6bbebb763bf9a869686967cb6bb7f9bd3102f2cb98eab0e70a4df05db41e351631235df3b3934bfe123e83492e7b9c80e24efd949f1b9b1d4a8a5cd5c2368d091948a969c1d69a27fc48043540d8fd2c303687a831cbe7ad4abe1573e3d2ed2998d04554451b801abb4dff53c8b3c0ea287c10233c9e7ea93a28d5832a0dcdab3afe1c6a42f66a0b57f6f72a4e0a685b71798b760b221bd2a243b78eba4c9fdcaf768220e756f83d7aeece331b7591241de028641063e8ce6331b09544da89944b0832be322ccd880541a0141c208b16d12d05f134bc306cd19b1309e12cd5a27a30306a5bc3941b913f34bbddd90011ddd278bbaa3014022e4b2a17029c489c44b8671575e2bd2bb03abd01950c4379269e9731cda4d3e36dd613a2d4e6e86fe7fc183fbb44b4a90abebf1d0e26d22cc3233fdae8bedf92d69c319d3b4d090713a9994e4f506c43eb2b8d687ab8db0067b6c896d93aa2bf18903779836da1a5a4ec177cd665fe1e1894359413b39fd4987b1a8c6df8103add57849302bebdf5ab16547ea15ef0eaa699d6eb3d6c0c625846d9b0e9a2eb2e2c5e8cc69a1f51c310428661110b3328bb2775728ad88713dc05db11db3634fa3ec753574dc6635b810d2e12a5de51f888dd7d5f8f3e7b6d5be75bdb4635f33e0b8a6e81998952ed552232300bb11fec06497eb7430484f6477cd5486da4446149dea5da0feaec9d71ae4c67107df9ee851b634f3bf92b28fb3fd21bb3a744b084f135f2ec01fe20956dc9cb9a0e021f1da0df9e1ab06898abfbe32cd14edf3471fd93efdedc766eb629c58c8100191b665cbe6f3b159fd4a4765beeff91e80e24530dd18292d0d7bfea2c480cfa9dda62b9944e2faa2263d0c0c5710d311c2dcd1d9e98ad0baee5d68d60cc6474bf861f1669b75f99739648faa19ec39e72d53313e9061f4915012950484a78ad96d693052b6bdc80c514f0e17fe5fba7874d7686124521a256acb5a278b9c456c1e880a8e8541765db87520144ebff6e082e6b6b9ccefbd530c75e4f49ea33c97463aa77f9b214a22b18dc803fd148ebda328154e946642090d0e092b8e91f16397bb5c57f276b5759a2955992d057067dff7451f7cb54ffd34b6cc7b10a5b66f52e67bf5a2cb01639ccd290a918931d0adb839b1feaabf1c887ccef3df377a83e3123c87db6034a37197b0fffe6707a6ac1652639e348c8b252c7b50e64de57092155b655522706dc4d4cb857f8d717e529768ee9aa519e9469b626a32cf31a75b5f144c7686ec60f29daf34bdcdb7f8792adf675d19b31de4eb020271a885015ebe4a62105909fd2b053995c29c7d04926ba5b7d40a2fee2218e46f2f34ddb873d87360e5e0933ba8647823046f791235c4fc8bf33edd8dd3098c51a04f3337e3a908c3125d689b344b38cb5253f8c05770f722dbc9ab501ab11d7fef153ce76a33d939e0ed47ae88f77f208f4155682b26b38d7522813f3ed9a9264ade5238f1e95f71dee531e347e2a252c35ccf6c097a0272fc2f421d6c4a6fe248ce63344194aa26aa97407c6ab97129708e5020460725792b89f1ebff233ec210d95763ddf252db2efbe1c17d6e73d11d43a6ebedcef5b528a27a42462a05de076817cfa206e63af870510bca14de92ce476b5683d51e8aceba61d19615cb91198e70c18bf7fd6abc11cebce7a03494ac89d270b7ea5b4a49cc8e76e92b8ce116288afb67323a7e2f9d77b5d8ba3600fd352fba1f85390f8794a10f0a91c260580843e71da470c3866e59331d69f4b06f2cf66079fd39343d8870e193e964c86d574e1131e0c67d20baeaf72e9499d2a8d1c1b202725e4053d55ff1b8ba24b5b4eeb746c6c57f6484d28410761fd70764b86b7a60354bdcbea227b444d808677905e096aee411f37ed3c7a16e293a902610e2d5dfde55754c3f3e4fd533ebfa664165a3988629418190cf5f9b18a7dc56773acb29cc84502674b48f6e1dc7cc8b105fdbafb9cdee52f36f0bc7b7b82504d3fb686680a10f4a06cdd43193e0417117aaa6445e95a599d0eaeed1403937297bc60169f3f18aad19583aec2de60fe6fe665f0c2423722a87b66df0f86afd2b44b5c273713e90899ec9f5ac457be71922b2c14149103c4beccea3a1c723c4ad807c8739b33960829095abf47edc0240ff1c476e0203f8bf9ae27bcadf066636de55d9a6690509973c72e57903fe6e13f102b50bdf887537976029ed7d6d70a812453d619b3ba9d0e9387adca22b29b2d5167626296f2819ab4c0f636dfb396c93663ecc569666f3729b09d0db8bda2be7c4cc6bb91f3757d9d8dba36dad4d7a13df9ec8fd7eea45aa0ca3f9e18b9c2503ba7dd1015794594364759ed82fabc30e2c2262e2a4e56cc305cb5d6e9510749b587b17e1e3208979135e083d97ed14bd7a04845423282f5360dc82f0a4d6d236b60e60209cb953253ea7f1882b8fa970929e69b5466762439cef13cb2a95f6fb33f8a87e3cb4cf4ec0fec9803d8b946edb0c70ac41a7348a1da889bfe6f945c66786f3a2a4375287963ffba14cc0496ec3774f6e0b8b19bba70f635020b8475ce5248d7226d0ebb0efc3e0ff181f8146ca972eebbfde29e4892fca755e7cd430454ece01129c2eee91cd0e736b964ddc928c8a2729eb647e2a70721c8c35060f9a53bb108de4d9e279676c76660d5aba076fd9265479980e4392b00b3d3604b47cd5895c1e8e117b8d9643a1ff430cc878d62d86bf6fddd445cbb91a1c18e7aad33571c35d9f36a711f0048eff227dedca9539d4280708b10b214f85d60f6db7d74e68f1fa4493e546e48ae96536d91fb8bc13b7d9c4faf4fc40fef69814b1d3c28a5aee91dd7db1ff15c2e36b452307227164222ecf5783428420fb62a7420d42dcbdb84823b3c6a94c9368ec32094e428a8102424e5d68d1efdb393b654a5d82a4324dd178840e674cf0d2d9664d4139409b0b453e2961930943f76134b3b20dd8a1eadba8862e11a741b1182ea92e3d85a8ae8a5413e563a6d3072b53d5cfb9fba6afe6c94b4ce722d9393c773f1de025c4a6b36ce47239bdf83e6b493aa54d2c8553d92a7cef93e5933496b3c3f5c3a9fed14510937d352c1b6f6f336c30a4a3e0d8626781af673187bdabc984580176d9373f6969bba6cd6a9f33624b117d06eb99d75329cb994ae30da17421bf38dcc7adc7be391af39590ec9a90fb4c6091602496b81c1b57f25d94bdbb7df343bee1a6f7d9e4d7b264a9e9848bad3c86e84d4ac3f9f762f46e8f1019418cbe7e1140d4a2f546887001dd490435fb9a263d2a48ed056b7cfee062db7494cf1f3c594f8cf1ba6c02d81a6656803af8f5f25c1824573c000ccc8a4a717440d5e1adb2c3f344a839dee1d717c7eb6d819daf74f4d080e142d139912219d73b51ff33ef238ae33ec95706a5d81f7d81bc0ea5bb3d017654a06bf318642aab3346c5782c347b2eed97d2cd5ca02b6f4138f92efc7a1d52bb33320145ec16e4d6b477ec65458f7dbb28614b7fe90858f9fc903ba04add74db162b5eafc21007f916825d25691e5257e0c4df630089d13c0283502d650f3c8370f50c766c393a16312766352d3d6466d6a9a0b635c606a9f394a137e4493eca19893059369fa94c8fd705d7680e95d91b42afd69c3291b51cc3bd82dc095aba1f2f125756b71f72dfb0f782e0f5b70088fa1182b968460f7d67e443df2b7e3f96e45b159785c7fc808737619597fff2d3b3ace3fa6cf662db725805489008cfb4820b899e01dbe62fd9616e0228a5d697c1ed02cbfae565a332ec25e843d6bb4e8f99f4a7c701d84585c8866f889379fc174b99031abc298a8eca47c1acb08e3ce314b51798fca30481ea76a967fc78717fdd5abbb2b29fc7f6b31f81b5531ce54c76417ffe621b98f2f97218b4e7b3c4a58e463338c20814adf5c4b98d4859d6014992350282a75d375552c984acdf28da720d562ee9eead400f7bc0c637fd3c6c45cee2f0c674c2c0694b6389d8d8563e867d90f43af96e7d9e1f9e3d308bbc0bae1f2f2cbbef24709531ab57007d282784d22728f51b9de63afe4239af776decb04e076a2b27276babad060df92d2557d2c583979eb0ca2a4201a5bc7fcf0d11ce47dae4f81590f1a9fc36712b18046d149750e453655d015e3b79d322f0d271eeb3614e3b0575a0832f6980e95ef0b889b0f976a425243a818183cba8b49c92bd67abae2120c4bbefed5b36a918567f2bbf66992e65fdcc43ff4f5496eab0f70ec33f4c410a6ba10f19c0e80dbebe890d9eaf635bf476abdc4cbcea40452eb7b2be2f9ead0ef960847b1e67afaa5547db2ae25f2203beb7b51fd159924aeafb3491c520fe26eaaa1ff68c3379b5f61da0177ed8db721799843da28d9c683717d29abb4f27ad03edf9085c86943cb328dbc26efa6cb4b80dedc74463644c9746bb7281a849faa2b5e3f0f208d94344bff9a19892beea12c1219f032a0fc384946c63fc1f391c0a976e0eedde1aa4a592085effe4f7a71fbaf72303452f3f36213a74f918f50f60c6662b2c5f129b4d2d141580b9068a0c3079457d7b2ccbfb4f1cc81a56a450853806c64a6c9d820aa518a059245fd97fb866f5264adb17df3814dfc3e4aaf566071cc7c16ba1d016e7e8ae0712541834541d9f5b253069a411355407f51ea0dbd71d5b065ac049f42300e940a0929cd06a6bad4691704ad302fb7a2f180575a50cf67ada0271b84e33463bf5db6198fea3545003692c1af777b19d995758cbbf2a4087a3dda626e9754f1408c0d1bd58e37bcc320c1435475b1809f164f48c1056c207c0770b836fc7e186f46696054e7f4c1a02fe990f012127aa3ab262bb8b45304edb8aafe4c4e958b11b1c7f833b2c59061913207ab3741033a6d41c09d2728d26ea731ee606b0077673a13f1d56762a237a0977eb708ebd7295b5ede97e88f7a6ed18e41fe40ae6e423a05ed089447dff42098b57fb8ca200c7947dcacaef5873aafb808a366afbdc755e9567ae2dc1e19661063ce0b7e24f47d05588d673080df9114918e292c49a0bb8ad7e937f16c570fefffa28fbef235bb75ea4bca1d85bafc06add4a03a748000e5592360ac3a73b95558d981e10c3d7a032122bf5ec31a182a4778d6ac5ae26bfed7c510e428d3c4b96dfea4d704fd7d14e039cadea222caa1b8b0f43dde4138b1597418cc0b6bfe45f59f1733da5a44b14feee4036f2881e714422c4d45fa85661266b7170b7d8b30e801e756071f12423a55777abb6adba9edb5c4abe3051ed43032243fbd7b5f0549a5de754b42d6d57c90d01c9a973bbafa46eaf4a8ff36cc316a017ee75ce37d120ab04bbd3449ade29d0ef1be0dbf8494f03c73b0581bec3fc0510c4f00e56f76aef758ea9ffbdebde9c6c9a7a0c65c2f64e9ad1334300ebe622ab4d7f56b9c64fa7d5e150879a7acf6d2d5c1f3e15bb98e9f9ce88f978c8a4ca89ef8570a6208a1abd487753dc8aa28a203e6a8a645217eadd25c518257c23b21841961047bb12c5fd58dbaef6b9a36ccc5f09558ad981b2d6bed4267089d09c77cefb33b70e11fa27613a7998492e58d39c1421899f7c06ad6a75149e07dbde923944d330775469981fb71f567907d1800d82bb1fece655338bc594ece3c5330109c8782f98c30ac822a8300476f0bb2657a4ecc5aae3212ecdf20f192564cbdf5b1e62bcea78fa29ce2d51145961abb775edea419114ba46fa382b284419ba5a3bfb7610d2584643618e6146fad0c6c14766119907ce51f2e9ccc410f114c6e655e723bc82663e242c191c96f0df24ec6b3ab03bc271a586d5c7b1b1734d8814920fa5c2933247c9f62c01b8086892a63efa5ca43d8018f485bd54fc77b5f05397ee791103bba6dd84ccac0bb107ad92558b192611bfba8827675f5b8b47b77ba0ddb5b06cb466e9eca24df886e8d969c126822315810b30183089741f2d2f298b55c0a8795e5d0bc75d08701c2cce32cafad2cbd6c66f5ab28f3e85a24d1c4a9f788b6164acf14ba21b3662c7d27e9a9a7d68433931e12fa347cc525619538f51ee1a8d6f6a32bc6dac4a33bf76b2d7b24d569d727cec2db1ade07b57ab3e1ff02162d3cd13b8eb658ce6b9e1edd78567cf6c0c47e292618ddacf282fb9cfd0bc3aebdf406a9f2852e6b7a28706478bd496e818fd223440cb60d799c32e6abcfe3bdbdd471fe82087e345d7c08a555d930acef5b72703ed99d2ba2209bfa9ebb6c17ff1b6eba73654130b790b14555085cf939952229db0cb6d890205b412fd40d134adc3559b09b018ef8184a4c83b13fafee25fe1c0b0f229639091a1c9cffc0d0332f47df9edce184eec5eee982f27dbdd2e21a314c250d5090c0ee8eab01adf982426bf2134cb283e9d61dcd42ccb23dfd4b9a22181aab6280ba6c1ed663ea72ad46b281072ef24210bfde306a4b5ec58d974e7442f0012c68efa5d7489fe9c7fa940c4786b0216114f75ce1bbc3dab81e3629770f622f04af103da7cd7671efe8d3ebfe69434809e496f12bc1a4b29830da8f83e55d2b9d6a904de3a394d81064173cd4da06b619e770af907f6c25633d5b6080e3a3b0ac985af2c37dd586c6d7c9bf1536ec652ce13c34234ed7b9e7fd43abf99d455de22cc6866183b7550f56115a1702f6bf644bfeb80c136575c6a83f71e8273d5185b1d05bf6e14d56dd2c36e75db5c011201e44a0137befbeaa19d8560ce5ac9654819a73feaf285fe12566e58dc792251c99f1e0b2fb0ecc099427c72c2298ca6371319fd9d4c3d96bb780227e1546ae5008c147fa20416587c7e1fa00ec9658d3154f9d03455953a2bceb2345b4fbc3951db210a0e9d05be809376300b97d4b2ec1390da083212ddd7ae48a87ffaf16a7f4de7ca76ec1fb194d39d761af09dcb4471c6aa98b7f8f02e40fa1296f9f52d5543b3d60c0d91cb500255d88c485e18fc8845ca63e0aab504410f64cb51aec19bf70bcc9030621a92cf8442916a7e74d1afad664dac0806d9664edba645588c25a48904657b49f2fb73abfd728ab16eca1ed8b32d57f005d7cf34938e1088578e5755e14c9d06b01508025ccb7500e7c11aafccb9b27aabfb0a5853951fa3f31529148a75343222081d414a56c3cf232b590609c5a61409ad2e3b69b3c9ad66eeda8e1c3aa043fddd0f13bf43c24d4258081377fc151c60dd2ca1b16921ef6cf37d57a7bff64bf53d55f6eef90a4ad15095ef6c903547de2418e6bcaec1daf348aaf7192092fdb1a5670de939bf85fb5465b2db2a4ae2add0aabb538addc6b0945ab83194679d5164b3852a146f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
