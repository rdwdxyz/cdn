<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"19756ab9c28774340770c432ba33681495f2a71fbe65f8874f8b11e12ab3458d3d818708a955c901e41f587cb45329c8caa596568422d7ded6dbea8c09ac1efc39f233b78c2d733e0bad1286bb447fb49bf42105b708e62ea9f9aeea66b321eb1a72dc3bb1eaa2c1468ef0b6cc7935780c98d765686aa3c135dfc91b45c9550d8c96a0d1c1bc73b3b50af2203c531f5fcc5355cbc64b68f09b18d61a6f9eb6741094e7a3ebe606774a747415a5173b00fb9f1227373cc245e197b97aabbcebe9f232d314aecf250e38ca3e84fbec8e8224b6ae41d05fc6b06eeda525a81882ef671551b4804ae5dfb74544fc76de3ac1cda2d570f9163de7bfa5fdd32924c4208707d31cab9fa41428722dcf599082367c5572a259baaad49e981909988664be02c2e2549380447dc21ac474e608c8a9f4838186776d117b4452d4ee2712cfa6bcb7f762fcad6fc10878e8f34dcb79c6495d9dac69fab74836e3fc9d286f114b8c64176942b8f53698f401cb498ff5650c5920ba76c746195fb0b7e6ad5cc4a3c3c8dc3e8df7c7dd36dd7b7b2abd0e813c9c2cdebd178d6bea8e60b79c3ad33a78d1e63ed3accee8721085efe52e7846a9b1439a00deb60b9fb5d82e07138e1dcb39485de5624911059d1131e76b3a8d0f882c3a4a5344e5d6c233785d0d50c05c1a4f35ea6fc1afd02fddb97d8f2e135580e3e5206e9c06a151cbbbb8231889ec0e722cc7caf6015a6bf5abcaae7e2962c88ea714cc4ebcdda64224a18e59e79196005b0cca57968d757a39c3058ea85582621b598e9b8b63f9518d620b2477562dd21df885b9fc8d775eebcdde346017fc8365dc08e4f7944d08c948d96c8787de472034f0d80c8832640a99fbacbc6a3b89e0ac8b953d3caa9526e95685085ee9f42cabc076c267017f93c68c529599fe0f46a67ab22986ac63e6290ef28d404792ac5a85e7bf284e518aec895f872c4bac0ffbb3cdb074b29e56821bdaa7870b59825a3f3f5b7846580ba360f4ee508c1233c87a6612417409f2f396d85a708ee1e3b2ae21971c84d55729e033edf4cd8464b6e6b45d05800c2f328d6381cf7de75fe6a682d88166737fd8da9a218097d049180fab76228867c59cf27321a0b5b7e7dfc46fe7d8b0f2cd4ffdb0b393a1ac53899e6101f4a86b22783a08489e40396cd8c89551a15f586079308d2631c7bc2e8a029d4c9a28f1f231ea2c4073f53cdf083b6d82171967f7d73e6278f46b61069571c77fcb0ee12363c2fbea9c873d8787bda13f45b52fb31bd3f8743e02b16e89ac8df21e50a52e77c9e41094856b1f1a0a1293c08a5a9759e26784d181674bc45410501c61f45e6e0e5f99828dbd714ba656bef57663abc85f99655f97f5829187d8e4f1c32979e5684d3d25741dbcbfd834dd7272d82ed3b16cee982b13002fe5c9a16f0fd2a6350096b1be13d9d2f731c7828e24efeda7e6f7a4f7848274f622abf9e718bb30887aa4ee43653f950d3c1f7585bd5215792dbefb9d51512e5fbfe73ab633eda690a3816a7376f6921d588270907666eed4aec14934088b2f6ea8f0438624ba042694a35324cda649d935297fc22738364f4e483ed928889a4d5c441e52caf98a9f55702c5ce004185e33e4519f7378127082d3cb958147052c34822077b698b3ef0f5192e63016d60323672df184625c64c677cb3222a21ed593d01bdc611f1d0f6aefbb14af2ec624f5e267a668e6ad3d61319cd9743d0b0cd99d70c8868431cc2eb372571919ac8144e11503d736d5d86e65d22cffe6e7b24e3fdea8a9c93c0d91d765b7a082063d81922974e54f84f3c3c363b43c3885a00636bdee226b836d0f666c43d2f6e5e8a6904b2c4adbba9c046c6019c976d5091a6939a93b453177bcfcc043f6cee589b1851f234a8b448780f43243e107988d5934eaf1074d7ca5b89792f52d52002910e306a908801cf0be908be61be09b9a99afc3e193736512963883e307f6f7e61fd867fed5e88d0cde3003ffdc5adfc0458d51b2012714bcdaeccc56c51ee188412dd2c9085fe8da215c9e76bf981460640a671897bd41ee71bfc7cf9982edc8b4b46ae95b2c837f4d4b00d49b217bd1e7132941ab6bd9c39fecec4e6e13a7ae748d2e030ee14e2f74643dd47cbb9533941153586fe79ba5cfba2970ee0a3415c6fe6d1d81c340470eee16bcc7b26062ab9755d52f093ee849d616ac0b930d334bbf7da5acc931723ca534413e94388e1a3ff1f8cf10452aec095a2fa75ad36a6de2a0fbaf66bb3f0f24cb8ae6e93aee6cf67f1dd52d4503f2e41678cb7201f02f2ac50d88872e3dc85277a4280b260dd3c539d382e9c90641da9a00e070429f83c048e0cd512e3604077d51e02953a6950267f71ccbd6ee54c1d69e442c621163f212075996052cb21864020c563b2c08b49f95a5ad2e7dcc69b918141469cc6cd497db204bb11cf891706d733ccadeea8d7078ea8934a47ea6770e63c9363a5c614b5e1170ced78f924bca9e052b66dce0788ad8766142bbe3e045ea107e5ca0c017b3387d92f1e3459227c0b44116a9db4e9ba85ad43db3517c30f799de9ba8470094f8bcb550b4e39c9df1be0472eef9a29f34402ee97e4e6449e21f61a6e915d96d390a7c826c7a065cdadb7119629ba5dec0ece3a179da076746dbe2c7691c5e55566e49d2a6519f7e7ece92c051d59b3d64829d284d4e6dd044a1c7b6b643e0858986e35a829dd2d44c995bbb6ff79088bc7fca01c4db5608bafe82c266227562d6621fee502ad279d6e6bfcba2d1748b4ee6d023a55712d21008f3dcac3bfedf9df112e347330408f84e61be27e9f7d7e92784640b681131b5435dab34dd828f775104c309026ed76266341dba0d37fe038d891d3daf69c2999c012186fee2f87c14ad0b32c909de2465d5f9edc09d16966c71c0e0fe706dfe9754c7cfb7ed38ca21fdd1754c1c5283b697159282d0c1cfb91c6615715e1825400029491118d970c809c9092e52d53a1eb7356b4554824919cef80479bd46de3162a2c07d1b5da0107351d1c369c6d3ad35be405694218f7eaca378689a43dbe6da056f4d97ec4d857eebfb8e46763f38072ee7c7e4fbcf916f3e9793afbc88bfe3247b3ff219bc02c1b42ad469467be33e512f362f22a7b1cce576af182729a10e1fc9a925e5796b886f76ac38fe94d9f21df94af6d92b573a4cc7171f20d32e1cc4b1b49df3a09827f0100bf1170aa8f58b85d03e29a1fc1f162b24b3c77682c443fd6e187c30f32e99d2fa895b45cf462942e613260cad85cf91d146d7225e9987beeec3566bcd2a70551e2783db7beefc096e47a3ef3ba68be05b05d6f6dd5b73598a3f073e4daad2fad49942ee16d8ddf57ec0ef529f1f90a8f972e2e3a463d7cbdc1314b3a45412a3997547093a429808895aceb49cc2cbbb83e343a4559b175baf23dae86dd1e7ec2548e5d525577fbcbefa3982c330c3b7d65e7a82f36ce9ce9ebf581b114311036a5fcbb9e56a948e2347038139d4b3d8d9fe7c511dede2c6ad46f057c2cf0779accb2b7130877c044b7d6d80a1f13071fe56c55f39db5cab3e781a9e89b0d1c3ecf0d8a26313aa24ff2991dd482133d1d5322df1090f0b4893d1ec6ce6c76eb72cfedc8e4b8a933babc6df393b6d144ac15ea1d18a0049d91ab891f4d141ee2c6688fa5643c9411f646cd9db29b9bf7899271905535a82069da01599fdf88aa3b79c20ac82c0233dd80d506f8adc722fc3f7afbddc0603bace94a204526251f6a7861dcfdbe0562cdcc808b95ebc06c5512da1351dab4c0d0be8c95a7caaeeb66349ef547d595ece82abacaf7f3cdc6ab3a7968a60c9672f3efe3e6c9adcee7e96e4181d680d4ea4a9ccca1f5e9d7caaef77dfbcccb5aebe946a42f000a36b27f60dfdf0b766c37c96be84d36ce4de824676374912e1206b52573a590a01770248271ccf89ad2e7b5b4cf9888d1b840ec2e68dcf425fc850f6724f394a60d290541b5e39609d9103afadcb9a558de6c6eb6e56d489cce01334ad36668cf9a5083b6c67839e4c8f1f82c3ebd84e0232917ffa7037a505a3a2e3d5057993f89f178614dc8cc05ed069dc910e54dd73a23311ee0e0d2bb58c3bcc5b577555cb7efc2362bc0e78dfea6ae84f42c1e29f4cf754e3dab062d22bc8ab11db83e6b36d61c3481f91d1296f4729c14e42d8bc38b3bd488a801f3bdb2d0834e97d124a928be813e254f17aba3d548c9725138f62a4111c9d40bd6230c615d1a7a7fcca2051e5f88ab66ccdeb65270fb88440dd91f23a065b756ecc673aa9b32a3bd1f7214b957ed05114336a9b8cf39f83c6b880c96ae80309688822b77d5b45f0170fb391f3ae1e5d6b387764458bf3e57896855054bad1d25177665b403ebc87437ae6298c08a6b2d0233000b23b15dcb9d59b81e4ce4db43ee6af0f2e884bc033a28ffcc9ef061e4bd1e9b4d159f0c51607ee529ab4191e9650702c95cb4cec894e6da265b0632916447eef1abb324f778ebe09bad9f10f5d6b9ce4815681ad0611f861bc83f40fddc5ec10e90aa69a6908348c52de12687fa83210d62345321114b4563e4dab5f27fd80c6a11b2de6b5fef54c404c088540258b6f092b38a36fbe58e4b652cff5228b2f79b11ecb24aae0389606f21f7d2b49350d458a00e204093b951240595df16c82dc82f51a309aaf8cdf61b6c7a288e9a93cc572af6f5c8379b1cc8851612c78f3c1260ae6bf4bbce327d53dafc9970bc80bf2db8d61f44812a11ea10b302c52fbb99daab1b7e2863437d9e9104a9c19536894fa812906a783768954177ce6e09d09fda230c45717b0f1d587c80e52e9e094c012b7bc602d9b3abc55a737067cf8f6bf8a8d7d120a4d05f48384bb1cf173912ce8062f1dfd81fde33714e852c07c46512469334d2aa8d55e6659f6219d7e2c963dc47a3dc98ac70280a6e9c9996e82f5451b86755a3667f2444e44c0ba1d12253d8113f6f05d1c4dd89f3d49d027a1b46e44e1985c3f026886b4172f0f0a50a4ead15cab797d6f7bbf86a336717f31ebb535c185c1fa3582596e80cc1e5c7d1a41f625383532c42caf0d27d8808857ace34b1cab115f530d5b4d2f055b0d869c6cecc21e633f8827d5615e67f2173919c8f9bdb79ddd2a039b1f4521b4533dd68aed6452cb8b28f51b07e9f130d76d4eec7b011eeaf3f000b66a9626eea9dcfec8f4e24a1da72ef8f3a1edc57693d0a70db0dca8f8b2c42d371a2a64903b950db9293ab02a8f4b1a1a33bc7f7013372b13c592755797d08283844df264072d9e1f41450fd9513b60075f7cceb37dc6c7141c8b1335310d78dbb6a1216c81646316c0914108b45951d6cef9a8c51141ab3902a5c40edaa85f8b35c7a69b115223ccd228435950c3471aac1f74d3b16c3822ed520f67d90c85f2cc89282136c4f7491bb4348b985ca4b987e44abe15c35f95e7341071da260d750dc22f8c144a80f838676b8b8a117e06ca6efbe750a35be11a21159693d5465f3de3d101495c4e50e43818fb1b839e298a386ffb114d876ef56603a54df91b6270592d1f67fdcb65989143b13d3d59ede7b5c43bbfc0f084f0721aa8b3a5338e82d0cac2d6fe33bcb4bdf22ffc4b3f023a0b3488e04d39e8772cc13dfc7f53ce3b4579470c16a1803cb06fcab001067a86dfd303e213d20a1421bdd4ed69e26fab3476101dc9992a2396b6f049095849a84bda990568333bae251055ae7514195f034c3784aaade0651ee64f4ad2e2310e3d49a285a0230cf44e19efa6d9f3a4d67cde71e804074d28ca2322ffd220e81ad9c7746ff2a72ef065432afbc1017c734834c84b3e0293053d3fcfb6a81bc9a3076b91a486485913400ab0f87262981c2f74c4ce1bb94104e42b27a362c9eb4a78fe7c46cdd76eb600d62d9b6b1936e5d623fb3b5ca7c9742a65c76543ff431d91d0d116a145aca1215410caacb63558783f7fb8e94f03773d6d029a046e0feac88d92dce6383c78e1fab061a94adc3888c2a60fcd2fdaec9d545a9fbd2531d01d9de26eec145977b8f1db227486c3160c954807fa7480ecc5ced477f10e16c791651b8ffd71ad8bfd3bfcf9e805d7876f77de7ae325cf23cb48cf659d2c52cab97a027ae5e4f856f9b1208b107401eeb92aa478f12e6d9cc67d0081bf7f828b1d6e64f2712512353daaa2a81be060d60ba8e4d12f20c2332c8a0969dee0392da3a7d4d30915e7a8175879172f892e2766ce57e51672e87f74201abad3251eaac5a8e09a1224797b84d4cd7e6df3c99ed68320e415ec003015e2b9cda514b9ebce1c2ac29dedc478a2eed5850c972baf857a58d9f0dd4ff861b494d835002dbb35ee9f4e625448dc207946f1d8c56f5f05afede44eb3365657e6a76b7fc65815bcc24bb3fc3e057389f860d9f64dd15a5bf434bcbc484a0faef3b5081a8c8cf04f555eb1a64e7a4a2b6e5ee1da300c9844727c1b768ea8c0ac4d0061022fb0ac4ed34d81ed3d84a66c77adb3163162d532e4dbc316c9dec0166703b00dd90b3d2a044c531bcd20ac7240bb19ff70df09c6a03c52cf18836dd5ac4f974762fc88c355c1f7d51cd1122ca32382ea6733fc46a0f98b1bd4fb23ec84f0c1dbf8a229de055ffefdc7dda34e9ad50c08061f3d686782cfc6053bfd7d8b1aa3f737e0f783662c6ccc3cc3fe723056a6ec402209f7a36a609498be4e8132e49248868fa99f9e7ab70fff8da09d0549c95605174597ca939e7e0bf54b14abc729979eb8f30532c2fe732ff046b2171d8cea8cd4cdbe487a74cee1bcbf3737f86e1dc67d1b6d72a58622888d9b8ba62587010b06882fed9c1a8bff20c956fba0a2d134dfbd7e5de854002826aa19432d1aa9683a533f87bc4fdfb57f5b6348a524868df621d8d20e750d9fb3a501c8dc2047cf5ac036f27f0aec2fbf06a67ca92f40152ebf11847f308b190ce76db67ea6f53227f5d70f7f731eff1bcd8e19cce865f6d9c31e7fc9eb802a48b09a22590b690384bb0d33e252f149426bebd7ea2e48531c0f50c5d02eb1a8d5d7ef2beb595f52c4d8d3903ed16188eb60017bf57ebeee51c32b1918330c0c3a1e52ddfc64085f5e759127262991a87080657b8d45223deb769b39b84126d97aaf6e0d798270a6ebe5d777969805e794f7652fec01d7772bd7c6ecc9ca9d75a35c0338ef5c32d438f3022812c60f8d5512aa85eae48d233af8519b578e24eb62d7b8770398b1a74606e9c4735ef19fc53c8b679b1026d9ba961a50626212d779ef64df6712a22b22350d29d4115826c2162577d66248b665c40a5a4d73848af09e9f2c1de76ad6a3caf4d4dbfa2ea965529a33f692b3dd89aec2494f9aeae45035dc8322e88885da8e42a7eaa3498d2d4cf2402d5a497e4d18f3bd9888799656e7b1928bb00a6f3b5326d74dd979a858cc5172caa8199d95716cb58722276f692867c3aae7d6fd60ee3b4795ae6ba16ff06315a1c5b4d063081bb5067da20f0f98d9b3d8376752109eb804cc71c08092ea748e7e55cc2e0a2566019e3070bc3687583beca0eb061612c19d07af106dc3dc2f4febe430d9f723cf198fa9d42c22f08d34874803d991d5359789a973b2a1837488010070343ebce2e229cae21f133acbf851b1f2e2bc95abd03466ac4d88d66d9585e93df076f5e0d4909cb18016f0fa5fe1fb2094ddb4608b0101544b2fc6b175169a4c553eb8f717f60ff5d5ed160a1c08abb13327abfc34c33acc662e8a2ee5780d6cb700f657e10af6b5a39db4d24275cdea41b901f76bf1f675e7716a3418f5bef6c4f49621aef7b05bb6af06a5f4d3ce471376f7aad1e5a2ce1155921ef577ca16975d90b7e9c03e5257896306233e06ec277dd7adbac7d5a253978c1d7d4f224d5df66405efcbee62bc5b93537585807cff36870c97d08488f669521d06a5eecd5dd9067dab29bbee3ad0bef4a3cef2de4197aca1947c31c062440abefa00c9cd9a6393fb8a27ca942d134095c4b65c4b023d912ce25450b333f12adaa63c873036ea52b07b7dda675a96184884feaf4722860fc371acc97142b11d3ffaa7ae65e86b8835af826d7c182eed91c7db18b173bfbb8a7ad1e726a7cf90928f2a5eb31322124695e1a97dbb68508431a9b2d253e33d74d999535928401134c79c070eb8532be5f8b0258fc5f718efb574e5e924182748eb11bad9936f79b34f84b3121e22b5c80e1414cb206bc8e8da2e480decdf87a8584f67d046eb78d8981f6849c2256e4d4e30cb80586ea239bbed9022d2dd10fb19aecb0c4611efb6a8bea43dc605809a7100a70f4483d8f12840f6b9b0ce557c0fc794f90a583d5b72af0386f3472e596116d4786237a55348d727a70160f6378a42616fdca8b84f70d38fba62c44bb3a2041ebdb36bf578870bd672ecb88405d5ec37e731c9f587bed80ca360ad239198a5fa6120ae2709d06bf3773f21cd1b220b0d05f8ff67d076de5c6c6b5c2bae81987d2adf62cde8b26bdaf427db505441781c89791a49242fd2f41cd9ca6e5691231c4534450096362c1afd65607675ff4c09dabf48b789aca0b7005d333fb6b8703898a7ba23d03052eb176fd72f3b8ff46815545f4b47815562e407bc5a3bd3fe809bae0bd77e723c19355efb668f4448320205b49ed7f5547834b9a21861038894b876caa733aa12f1b29833b7754831b5e9113f29430e745c0e1bc0d385894d0b658a63cf4078637c5d235c33dd979c1e830b7598b2c7e15a5dfbb372149f3f17c2a54fc3cfcaee08bc2df5e42c86a612f7bfea9e182745f3ef2ebee1a3b254fbf1f703344088eda4f685e6ca8d0a04db3bdc417a203963d62aa7be0bd3dc40122b3df343d1be2ddabb964671b5d141088ccba61e31b90be1e9b52597fb6d45e393b710d78e86328ae909303f5b42b2e09f09e1454a98ee6894b89ec2b97a9283fd95324eafd8bedfd8057009e64ef9524cec523e87b6983f30b40d4a87aa5d4680d0b1bb2b8c4ce8deab4979d03152d55d0e1b99d256eb04e19cc6fc391855adf753f86ed2bcda7cae9d1b113bfddf8e9676e87ed4d4bc114a008b10fb88994d3f8105dcd997d6931ba9603dab05caee28ebca04171bfb66d705c129778a1c0df88f9d6c269664916ea63abaabb42c9987f253ca6ff81f30381e26fd4b8c4c105bb7386281c5b1b450a9e9a9e0310276f8382a24fc4786e24f76edf22e1e04d0c33059b33c58ea20ad6af0d246a1f44155a95e01bc8385be292b26670ca744eb2c33e460242d50ae2c43e4003ed333cf23c852e3ad796e551fae56c9c41a2bb82814325e57a6cd76f5d0b018e466a424cbccb2649ca3f94010a5e73a0a42c64bfd5addf36bdd6e2088d844a9b244423d5fb9fbd218cb18ffb10f7210be5f5c724fb37b795ac23baa83e35102cc12eb7f1b95f91bf9327473ee438da25fe88e2aae20229a0abbe7859e5b16d41c881c7b20ff4ab38c52dbea35162a92606f05d4a587c4a9137cd386eee54d7d069dcc24d2ad668fc800d96fb8b50a76f1da888a9d91be4e1a63644fc7d23c5e5e645756131d46f78a6fd4ce5d2529dfd620dc906fe65b411f991c724dd984a456da01b3e35e8e62ebabca9a736fe6dac99caaf8a2a065c4fa881dbd07d7bea786c31033c953468caa90c59afe281cace2b66f681c4c57361504b3293b0d648e0b9a6cc4d3cd9067d204bf98e34cd3ffd62f5d1e5cb4e543cffbcf461194c72f6f79f82d54194da04752f50db57c61d1e53f2f7a9b5103a13cf9b72ad611818256175c15bdd2f59d27284ba7d7100170467a84aef36ff995e988a0988e39f36953b67e72f3696537a374f51f80adef8f374c843a891c6e0a2f2c681d8dfa3bb8cb6ea32186ab79fc5f4e0784c454d215547999b927f1153a7ea8fb70c0ed91ecfff92e065f523ece36bc621c0a99fb74f47829ae9676eb5a522f7eb83c3c1fb311e59797b5231d37156f8abec356ef38a8d855acb4779201fd8fbd9b6ad3a15f04947fc18115df598ab2f19d368d21cc1288ffe2da35d8c6cfbb4467a76be4574542628ccc0af19f066179552fa5012c3ef15403dac072f73d26655ffb243a36d2f45e6bdd184cb6526ae98d8962e3e481c3e6176a75704ff7b22a1fa5cdc00bf6d7066b08a2530062e7048878e607bcc3527bfcfbd76120b8e286764e96d22eae6c0795528f23673e764f4b4d491169c8bf2a62acaab825198a096c3b8c0e30027f5518fc257bfdda4288f3806538c8d5a146118abb76446f510f66cd94ee9e61878180dde0d52a85afc92900e31afafcb7dcffaf6e5d51c410f6bbf04972f4576b0ff021f93a372d4c0b4c226bf8506ebf0ae95e406299607f286d848fa5f9304f7682c3bef4e2258fadf079db2e046e21c3685786acd2c1648b0b3f68c63b3ae09bbdc6c43b365180d9e1c998a375413c027fbf664c3c558c4efa13e622410d4392ff4483287d084d3b302ac12cf9b5989ecf7e1caba54d55b85b2ceb73f5e2d8ac1d6b01d17a5cc5078031895d3e1e4a7adc1ea6e92238add88d1b76fdf62f41d7efd616e0a4a818d546db0d5a02cc51c4e1b8dccd5468ec9a4486c4c456bcdd05290c187d85aab4205dcd3d478e76c436604634d5b3d80286e58ac69e7ef7b9eef76d497392d5b8446549606f5d3cba60d418a5ee8794482828f21c5f6327c7cd67ea05bc21dbd970f9c9387426be0cc8cc5687c0a3d745aac2e40e1df598b7ba674e714240c37ca5f6b0ae4ab1547329ae321495d457bd8ff0d804802694ad1e75c6b087ca15f562a01cde121fb3dbe48a9449aa731e2d1da72985ef6b03676f1807ddd2240ca9b3948b84442af57e1f00ffbe29a25a0aa9c3f69c2c5ea7d4711d53487163dcc523ef562bbc4a7be1e53f498831339ac2179fcc28f68833cf47641dfd502b95047917e0a8d1321777b274941a7945e12cb3e1ecadc2c1dec0fcd9766e81a8c7bfc3356418e06e82fb369b213fbf9e2ee643d0ac440826035f0c3d0e36f8739abc89f616172ee74c03db8ad3f69deade252398283f713ed8210ca06e85f93f0be9e4fa949610ca595d7d3d9b5196804b61332f4db34defae80a96254da251a6ef4ec38d4a31cbb58c60fe26d5db6676c7fa99e32086613ab2c58a3080e638d302bf07394df4e60fa327f06b075562decebb11fe9ebcff59e07000b7a1c41579e60d5ae5f4445926448d1dfb824f0ab610e7e2f8caea5ae621778f304febde66e1060b173fd1d4f98847292fd4ec4982c742bc753e6ca0d8488b1c7ee29e3fb10b896cc4f701e811464d337890270f9c9691b1b3dbe9c922db509c32b9deafeba3df3d275d8364e552098f0ec444cea45dc3993cab7c548bfc1361bfba3b9f9bbf13226f47df82b5fdbe4cf5009a25582632f071cc57b8642fd7ae60d4a6797f09dc0107b7f389425eef5500984364ebdf8866b7eff748a761f4e32005870a58f5dc4d92827d3f8d1e464215e81eb036134e7255729fa6013df910a9ed0f55c96457b72497b2d3bcddd906b12ee3d5282d7dd042872cc4ae63757978331d0c1be5660abbb0e06a027bff81d0d2dbd2288121a6d58664a714c260c869d8b890595c0fc17a7d411e2d52e647a226fee125a519c72ad43157dab2d4f281627e2e0a9aaa392ccc58a4c660016d00c28c0075619a9da162c721aa206554e032f4b623ecb3f2f9db1e36d4fbde6f4617929533be58f99b4187958a55b9750e8a40dea2ee9b7db318e55a969df7a4507ce2289e7e102f7ab8ada3b322312510a9b9a5366dfe2f755e3eb05aff7148b3724613de040c58dbc35c5eb6580386f1f24b709d3454f35c84ed6297d57908e7fd621fa7d3d4cdcf23606828ef4b46d61cddd14f6fdd2290d39e70f071c3feead00e2d61fa3eaa3079a818ffe589c25b0994519a8e48201f499f8001ba53bcec0fcd31d3517727e4b9b34be118e8c872c37a476243b3030f66e5c4cdf9f92ac01da8f6ff3901d8848dac4f284cb3abb7eee8e2e353faf1f3ba8254134aff902f7ea97938ca662c4df099cc7a35bc4cd8b3ee38ec17f7b50eb744d0af8dfd653490311ecd6f54f559e2192cd90177060a9d8e221e1c7e632f810bec2ab035554020f9ef602cd2f0a38a8491b897ff961b60397e845f6b198b12dc5427823dbcd0d36cd13494f324c4d11f76d952a5c965abf82ec29623bce8d0a9ac76046af36886593d2b53683c2facc1521886a4dcdd7cbcac0d6d5ed79f2caed42519b7614c71cdc221e459b4dfd363515f9e2d5fc80b61ce33e0f84ae80319e582d33ad36f54a6eaadd690dc9f76881e518dff8b6745118bdf207d67bc23b293b3f4455c36b412b2ef5e624288ad499518533a59ff4f66e1175ca04b68df85079f39a3f9fc6378f53145ca9d984c91d062385ba47a08bc32dd880deedced169847e49ef56203a4f1a6cd5bf749a08452b9e13e8b0529c91d9a63f38dc624821a031e2b53164c5a04324e05b438312f6a8a3367107ba3defbac0882a43aad07fe61e8d452a8e5fff2988a19ec91c92e973734d3f3ecac23d6a103eaf68e66958fdd764d8fe71bec2dcd35c374096938ab862dc74eb3da6ef486171a22906761b7c0fe4c80fece31fbe62aecac1dadfac7979f761087c7a200f7874c050592df4bac0cf096d9ad0ef8121040df708b7c54a51670c1612a171747f6bafc683925c2f0124530872e1d08c148dff9540bdf265434670795e8982b4dcd4eb7f7cd83c276ef31f9a6a08aaada32471fe3a6655ba24c08984e8915cda85aa6e0bdee95adb7d0310a2e334edf518f48f3ebfa53e3a5fffee0255f53fc72eb23616fcdcd6b6d46f9d9f29e390573dd206c2629bb40fb4db41d703591ac88c8fcf46e0483c4f08f07e347cd0a5b97b18711e9f7cb43b962c3f70dffc230e6025a811e3816bd6690685b5fcc0f51f274e3b15955a49f0c234a7c1588f813f23385bbc42c5e695bc9221b78ccedba28f74da83d1741dd9793cda3e5490cb51cbdf782dad21c73f07892dc74fb7b25f6cc7f61f0ca4f8227a6302345bfe2345e5e5f581a3870c01bdc780f79224593eabc34adf20228876c5faa97b975384dd23b9cd20d5dbfc5cb130509e389994ce7b6e57ce27c2bf4c4071c48d471d52a2733b8cdd481697e92f4d4a2852953f6ffcf0129a18bf3634cddef1c20b9418bd3c35a02c2f2cb5d6fdf0f27701bfb1994806269951d2039a968e0e294bea4ea9348c3da0600f21227627f9b236d65e61badc4fb290975044e4186579c98c105e4b86f81843f06dbcfe33eecf4f429f230fe3ab2ce8e147a256c788c2c8948ea623bef1c9677f107cf520b11eea2132bb8e1cdf98cc11742f597516871444416a185ab7bc183bb9cc5220efa018ce20e5782a7bc6a5decd2c3d83c866fa8d1aaa1243be3c4a5a30a7344cc4617185b9e13b6c7ad17d15c3d54ac0d9cd36aef92b4cfb42ef14da7194a8986d66cb372929373d978c3c6cc333423aef6da25b9aee8d1b05199f39a06705bbe07edb3df64591234b85db4985483b94660a635a4d14e90ab8101d101f8c01104a8598c14df01064e4053040c7fd85ef2fe9e41a118dbbea572c8af9013cd3febd12d6999dad12ff74a174af9b2b57845e4e327fe7c40a69fba9cfb3aff067da2a5b866a85b200b49d4d9ae4678c687cfa2d9fe1c5975d6795a3fb5f672c017b80605b9ffe91765fcfa0d6642dcbf325d48c309ff25cc07df4665e5686423998da372f787ac686443f94dacb1c0dd4eb99717f8f203b5ee5859e41ca1dae3c16f58f4a3dc25a588d5332800912431709c24c691e29664db149a0d6e01bcc22bbdf7b1890bc565363477fc7c4809544e875ca689890375811b4d21f00d5241cb5ec298bc2d4d458ad1a85334677a060a78c935c381dfdc6882da1378b5e63efcd0861c728986624e1573d45d998273f6887513653dba6fb59513250b3872a67667608dd81527365bb00f8b09db0361ec80505e4aa666e50d9d2bacba20e55f1f7c9c6f3e7ff54253235dfb923c60177f6efd1aa7ce96cf98683e270c229e3d955cbea49b3583086f6992ff2500195a4c384a19c15f27f7c22050988b93beb1d9c8c8fe5a4c7a74820c0b39a408e3591a767bee4861600051ad22a15dc0e9902818bab9f90ecf474bc8c2b76fa05e46954057476aa4c934e91c239a15d5732c34a18b85650c6151644e3e4eb3e0d2365e02ee4a81dd56930162f17866031fc52a218e44b09654c7a9bcc1261987d5472602ea6779f58a838d70788e6affdf120fe5486fe89817ffcd2231086942d7d7b04a72711676ce798854f612f988f62f13f6e998c99a970fb90e49a15d183370b85324aeb1b856f669a7493b101787596a4287d1a99305d3c636786b7da5a329a52a30d4fdbcd124937ee53dc500aa7b03ec69d6cf740529685639fddafa42953e13007dc7380baf8fdbbb90b8dcb83f5912465bbf94dbaafda7f5c776d89c2972775bb4975a371fc833bcca0e40b7b13067028c4c3d77b58abd1f9621f3bbb7778a373cbded5a1ac70703c5dd00d918cdc439d7cd68ed5df9b9f0f269a7c046a49d36cf5fea1aab1e0449810be8b736b2591077395da6f12b9585f87362f43e73855a83913e5c717b8f00ce0127662f7f6918c3a74d44480f496ddd6892e73683fb7546d6a616d27cadcef30f146826c807442d1677925b9b62496fcc3d3dfdcec244b1848481bb6ca19c7cbaa4a6030d7b8644d50b4ac02df687bd587016249cadf7da25af7bb81d365621d9d1cb0922f00f99518e52983b12bb06093cab390bb979c88071494a02dc8c3665b5e1fb11a342e0fd4bf1b487582fa5347f3b56209e40dcb3d8041e36318d7f5eface8faa84e3866436c8d74290352783f3aa193bcd9ef7be1c06040f21eafbc4db394fc2f9d4547edc97fcab8ca01c041abea3560381d5323582ad9687c2e7f5ef385255469ddb853f54b55d2719b42671172b30e03b29c2570445085d6b9c2175392419225194c93c82fe407f97aa831a35323bd3081333c9b291b76f4eacde80acf48eb21c80fe3d9e3f9bf4ca7b279ead939b04a536b1d00024247dd85f1361bb671bac3617bbc826a899267ef43bcd2afeeb0fc270cf79ef057181990ec0058551c788fcbd9ba70ce2bbbd02cfde76f0c713cbb04cf48b79190a65d41d5d569eb07c32ac6ee975ccab1bddfe4e508c50b3b749d6142f4d83abc9317ef6b5fa4554229ec581a2b456881c07e9cb2b38e9518c614fcaf86015acc585a03edcb8b14ce6c34ea54e428d2dc8ab8a55ef76bb3eafc191de5a9168113286d79a9ee4cef4f22edd71884d17875b91f3a8ab0b83f22128a4432c944d1d79e981d8a698f6bf08b62711775733e765377564e64d3a5c112d920e04f85feba8297c083e0589f58badf81aa5a70cd77cb8c9d85d3b9231a68436cc34c44f08df15534cd8802fd67d91e86e6fac94f8954efce10f607879bd1313e2c0141f79c8a570d8c6bd3495b461e845586f31b9c305093dcef5f68cc6e173e60a593513b3275a6fc1f4eb7fd624c8d4a4647fbe05b5518be030f953643776ebc63370dc1ac112b1aa21fee7eaaac2e351bc930cbdf8ddf04bb5fc6e299801cdd9604045ee8065d265c1acad5241f768ac493875aaed08d32e16d25b4f23c7705cbefcdee4d39b9c1429496f1b0d326f69097d1da3ad4ca305a3604a6e741908a0bc3976bc619365cb636892bfa2f3c7929ac5dd6b0cba1cb208b5d2285338539db5a5e1fabe377197b1ab4b10befd139cd9585c5b8917462fa8fbf64dd4b71051378af364e78225efb2ac8d2e9d938932b6f0c7937c5019c7626f36242bfda061060a972a50cabf1d907d634545fe0d915bc67bbf10a0b2a1169903dfb8b2b77ed5c00a55e7e5642f695eafdd59682c1d0ffd47428f3bf020efbd370ef31f15ff04a0b54a245bd4cec9262d6422bc5c2e314552a6b77c42da5c053145568d4b6a48d20d2ef60fc0e6fcbd9004b89d408090913b968dc86200538774c6bb4601ae113f201f527558f2713eee46175b9cd797155bc8cdb9f10eddcc9b2c72bff1550de62cd30044cfec6dbcffa980a35f7330ae6a20f6f65cf11c1ed3d2b87905b869b3470e394ee576d6066f838c5e6a36b4471c1d6451ddbab6942132dc96f89985e0954be06ebf37a6e7253233108feba698bcd27a798df6d50f1f59671e1199397b81a2a9cb0fb4d600a24b0bc8e6f1a693a4dc005d5698a65719e6438ec378b23449c31412312efd4b08027304520e4b5095d3065b2f3ca8c25ff659965992852c1820549a2faaad201391f1b7034c68aa4755061e030b1af9be138b984f675e5d2b0df1fb8d08091fa350dde45ff62d0f08c400e4d398f87516706b9f670a6f998d495a881588e3085853918db81474a6fe96a2f02eb4b0772fbf5f3633dc6142bd6405bb7be09c1c5121efa9c1e82581b0bb285e56c09a908592752d7c693451ac1bd79635b17e21b2e86ebf0df004ae09d62b4b4a85aa2a8723f04159e30d22732e8456877b0cad9a99784c0e683f7f753ad8a2cc19e7bb53d4ffe20cf130e95251ef2f8fe41c9f1e976ade3bf538d262207ddec5f0bbd90807c44ea8df152a32118ad4680259adfba6280c23000893feefef3cdfdf1d6de7655d19bc6211729595a34e3887671d9b85a5835488aa37d529615da9120b412daeb59b16320ac7f7a19526a0ad382193d475fe6012677ba7914c3de6c7fbece13f32d1d51f6eb1ff519dadab69690f301328538f32be458264228044229a973f4b07a21b5d0b55041d8bb28d093a5b8c3711b0144e373e0609d2abf1755f2b2e2fa8aad94b95dd4931dfa44433845670686f9f12e260fa3c9190d948c8b0a4ac7a67ef187e240462699c730e9ed9e86eca79156a9aba67609da4f5413a347e1391c0f241f50aa668748571e396186a4a4675d4d563e49d21cd3bb5d8e3259bafa06dfdf40aeefd6bcf7260b45efe74a17b96f8e706cda9ecb2cb797955fa4dcab6fd60bf4fb7518d72884944ef9cce6398d87f53298412c9dffcfa99ef8bbecec2ce63a3022002e6db0a683f4de20e28efc211f7fab03d5ccfd12bed162151bc7209d41b86bbf95970155a3cfcf3c66064224fbaee0a9fe1dd92de9ede5a6f3d98b46e74baa782659bc82a902afc4b5bad7f9cf60a7b8b92a35af97038f8aeeae32ec19799fc80abb35f0c9d10f9f9b0eac0ca6727eddfb4e258392a53d18d614c899f7ce5a1c31123bbb90076470710308c0a531d9e5ab859fb0e7e28cb78e0104ca78abe793bc1f8ea88099f16d90bbaedb8138e59004498788e4ad4581e093ad2ff44d593a29bc0e02ab93223bb7d139dbf3d76e86d4e04dbc37b71f6ff87b44b931dedc1c2c7aadd474cbd00cb24c11dd834f2e5b23ccafc6e481bd2455b6cd1003673ad3b071373e9d2de231b1db7b1b1795180772ae6f57e420f43ec6eb08c9af3ec6251efe95e0b0ce2b5db652442b1227584598c42f05017abbedf79b784963077e87efd561d9c0b36b94bb7777af08360a0382fd9a7f63c1962540bf206c443cee4ce70522baf4360065aa8490edea53b44e60a4e20fbd95b60c9b0408652989c2690860dd3ea6b0a8e500c38dd03e5b86f3317155a0636e0dde71cf838c41239caa9cf141dff00d271569c949b79e19c63db6bcc0c8eb87a8b1efa0e424ab55a122e82430647c30493e31c302e4880cbe885130937f969d8e1aa2a692347b8fbf08dc7c35e870db3b491168bf040063fe78c7ca295183b15018cecf7ffdc8a073006f9e608ab68f9389f3cc36ebf25934c068eb235ad65338f462217da163858e9f8c41cbb9f03e0ac8fc262b4a07d643a21322c40ad9733bb5124f692ec07fac1590b97a9c22981bb36e60717217a4e70ad11471358b765f8048d088818633864ed44b9b20c12dca2e0ce9fa165ed2e46e64d03530eb1553aa114fbfbd24d57a1ddb72e64917df6361a755af140873172dccd9cb35a5011c45","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
