<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f7cbf41f554d8a79250a37f743a56b9814978de3a6d5ce4d86d7b286924fe5594f41e1816efdb1fdac9896dd59bb3f43f2bcde08c96e2ccaaaf2e67e6df482c43f1e7de4c1d56e4b49a8491e79204fe8bc4a2b9eb564e73677d13c28f1e38f27f5c9ca3a5de6bd3322ae4ea89f3f84b24224bbc171bda32f9ca964792e0a538a4f835f3aa0c75cc4470e0a6b4646ec1f137173e09a19640dbdc60f2caa280db166611a69afefea6ed95350386a01d468bddf96aff42d71a19c0047bb031da0b1c728b1784d010661292e8c354c4c53d432a630a0c4820cd54e86ce343e735a8f79fc6550516dde5ca62c2e06d88085ece7415bb0795d999b010c6eed8e3aa441d756ac931665f635c33277f9e2d5553ea7fbfcdb86cc0cb3c3d434c2a0de39986b4e50828cda20e1fa1cf3b0f6a0bb9a8cbc5edc85b1908a5901e0a4458592e4d7fe25236316f38011649efb8a5948d23b014f72d595eacac0195648a836282a17ba0197e7d37d1c3e2a0fc9c4d75e6d803179a5a29c1f2809bf2a14901bfbf84990563ae122f6914daed18d62a0d506243ebdb0a30d3fb2b41d24e4411f4fb0ee18f899dbdf8989c21c0d736ed69521dad841b98e7faa36eef687208cd2ab12ab455e77a6f1963490739317771d5ba44691394d05c158a149946e4b960356df9bfffd3c6d2c3c8816f212701bffb8f1f003a01630b07ee9b9ee4a7507553236891899030d26c1079207517f70ce2cc4934eeeb5d20099b07f8b3ef45f734c680710e1ea636bda0f952fd7b3443f97da35d46b762a7c2a43be0adf88e39dde51efb281520e5ffb65ea5a33836b563a13b87e16b7ce3d278fbe978c146aa96b8bc90566c28682100405c1ea9efa6b821c5c8559af646c71604602f66c0a69964dde8443bdce4e3bc7045bbb41ee098c6a40370e9737134405198729142fb4c276efb3cc9a6f354cc170427f6a289026c72a6450cc19b70e13ec0a8692ac36e0025a394ed1659c64fa14959d9d77f9853c5a47b09e4a78623fd241653281a7ca09362a4f03f10d5c294ae5d175b8c56c2a690239da57ef06f4621e67ae9f7c86820a903b7efb938d03718467969dfe1e38a6d75c48025acb50fa8e9e9d16129891d165898a34f8b1067a70c50dea31234eb319aa3d43288b85de5eb0cf7a10afa359a98a9e6e08ed57460d8bac4bb0f4a7ca594e31983ae457cd0faf0b996d47bfbb7af7f815164b2f50bf49f3677561b24651572946fbda88dc2b9a2d58e1be76c460f1dacbb7052ea640a65abf5d672a8d1f7392b1b2d2e39cae1de025de86785724dc3e8baea612e0e63de1030c80a8a9b30d7da3e788eee5bf6d37aae06f72c38b26318a9042c32d39f8e27d67c5aaf47e8d210ed3681b317471e137580af6b4c0525d672b3f246dfcf0945f10d229a068e7580a77f7fb0bbe9273d80061ee274ef5226a464fd2c6b9a57485b51dbec0866d4d0b9cce6642d7eb0b12949e886dcbd8ac5706761214f7f939a0d07b85e44c9f3e42f30899cb3cc79a7e6490770191affd940e34bb6901d0d5ab96c5b7c810c2acafcf0c6dfee73afbe7f60e0e5a633731c1e500ce3d77266dd9a3795b90227e131cac99cce92b53dea2007fac3f47104b6c8ece245e1ff259f6552e2e9e01a7a30f03565808a4ba7ec412c0fc78130b07d9bce8a109a8eade84b51bf15473d3ae4569a82b968ca1a16455b198c7bc9449a9096c73d49805e5a6af574a919367e13122b879c694a3663d3452009cc1f2a2e8c2e157564fb6580f260c249aa771f2a79e82d6bbb1fa10d87bf48ab74b3f9cd2583d69bdc9447a8ea2396ae6cf6e094bb32a9cc817113b70fcd2b6bd4d61e40ee95c6921d876ea4b4e1cd4ab0905f9f92ea87a7ffa8d489c227ce4220d8eeaa89a289cf6b8a692d487111efe524a8cdd4f5af34813cc6a71d0f195bec542f5f030ec351848bc428f9ee379ca9f50ab9c83251a8955fc9d06e37b1b3c82b6439b4cc99d7bc54da935aa21d5b6f1cfab3d6f17b052f445846abd4b055837d216ccfe79af1d3066c7f8f56eed011a304cb460974164dff997b66e9a6a6a84700ed135ff7b5fb48f10da5550ca2b678f60bff4bc52a7c52d8ad872d52acaaa85ec0bf2f0288a5710d07c63ca6102fdafa000469e128035d8899afc08461d09c23f4b0cb0588753c621dcd56d14d7fc74145d732a8ea937a5311fac4cd297a239ab30832239e01df08e68d6f93555bbd35dc0848eea2059788bf3bfd84ab6ce753543b4371ba779ab3046df653e01bfbdc5388bc6ba9778589a25dcf2bcd0f73d1fcab84b1a67fd51a40abb5d79cf2688e478c5bbf6579456834cb132e73352063067f322ce4746f3a70ff78ebfc02b2ac3f73f8e88edebd38f39028d271be12edde5f7372a16fbe27c7317e3f6ece811035d49541ba70718c61d16646a7b78ef3b34f02217d8235fc9351cd47d8316b1383f452cbcbef3996ba2e53c10b7a9df031926144292154df3d999247f05ffaa366afffc9ec840c0fde3e1b3f15776c11fc99e9e8e147e61f183da3bc4dee65cf3471ff19c1bdd1d4e78eb2df30769eeb722362b101807eb5d23b9d5a79831f3a4c20e9d6b1b1d4ff6772327b2f6ac4b42e0855b291475c006c56bc6c1f5e9ec51ded94c2f6a1b46a3df0cb8a4945ec3bc43f1a9f99929ba1422541377d60f2d7025e4d85aa272e605c114b93261d91ef5b792cae97c0bb344099824127b0b4da62441b8456bbf014a71f7ef2834d888b824bbb71541935d4ca9cce1e99cbf4d98d5c145e31bf62df172e8e440cdecb9e9c898fa05841de2e3d6b47c521c4d0e01bfba307c80365485260698a36672f0a6eee623b243c43d24aae66249e82dad17eb64948f6178f1778a0ed701fe9f38d996689719f98cc5a9ca24073164c169c94d640d33f129c8590a78a43c0d9bcfba03f7a2dade2a6b3e3798a68c08392e1e8ecba20461ee8aa4dc6ab50bd8d102cbbefb98442fb0adf2d139240120e033ca83be27d28dbb3234378cb73ab74ee2f14b8986901078da69d7ee87b8ab93da0ebf9be1a5a6eebe3bc5c238f74f70b877e87a310c3b4f16b1bfd2da91c851f194da928cc8036baa6f38aa430c26527ab73aff09d1b1b3a8847c4cc19e772efe39b1a99c23b4957ab65e546dcc1ba633d3cedb10332552239fb123cb3df07ee3a6602635873e3e589d71b21a4f21416efd20cea362033e23730c3027dfaa5697b2e5266b73c07735dc8d2d76229213f6c429d18a4513c4b12216c481220dd27b2285ad3a3ca6cd4bc93afd910c4f55d87c85225a5c8d51cd67de4e50146fa35ec00e29a2bdd55a8e4b165d01ae5289f5d006153e2da1495aca4ed46605d7db6f6103389296ff8def150dff670664811efc3a423700a0cb486bacc68c5a2f779580e596088ff6f940abeff24f2a62feced66fc22830d45e38ae5294817cc44ebf572f1bc550e06682d8a4ae2244d16b55a49d253c3a8a0f912f553f701ef906691612c4da8e5dc6d5099e320e5a44ef9aec83de4e2b4ee527ab8851c13783bcc4463aea1175f7f63f246088dba801dcde0946890d312bc492d2db9094f62b31da92ae4f71121e01ee7083654b42e9575dfcff104f9c12cd42719b92c10d7b818b542948989797d38a8dbf4ad40b9e45747f8efe2ecae2cad09ea7e93bfd3d8c8e2200f369520e87894fab0b5c04b1345687b5ed33bc07d069ab28f1ed239f4bedd4ed32f6dc63c2bba54f866c691e21a0e34c9e87355eeeac977e12a60aa9567cffaf4f9c96bb2566d800044e0554fb9ecabe75a9d72c381f54bec8e206c6a6cc40c2550310e1e80c3f52689229cfd3b647eb4458777407a65a88f20ef1d4382c4093ff1a46f8edbed8ec2c735ae151251fd9e93401e6d57674afae57161b5825728220826108a0cf2258910f7bfe19a4908e914e4bad6466aeff458bc0dc63147b541f22265b028cfaa8e394cece0c7d042f19d3cb6909f4c61efd30efabd35d20e057ed7b4d3f4c8f6d3234760ea082e21ecf942e8acef3142e863984c1b151adb8c30120ab7415add33f60038f460f075de6fceac239ce27eb50592a5f3986a2d2931f22a5cb8ebf807441614a158692a9a0c007fafedddbeb8db29a6bdbf9b5dc615d76aa2d4e495a43d5e4441d86d52824fe50a22c5d48f75fed4935f144aa5990feb698ccdb9a4a0e63fbff9a68fde6cc7bc3a20b57ec4286cb6cc757b39d1949330583a5312c1971b03e382123db1d7c9947a1f0d152ff52ba6102f2493b3c4ecb2e1c6ec734588b870abc2416b3d6901efa1ef1d73a6e4f5b32ff97c3e04597902e3ea1cc5c6b83894ff48264acc06a44d59faaca1f114b37e04869d8d0bb4d8b6bc7fc82e1d3286140c09db0dbadf51291154d95241c801ea006e835203119b7836122f70a7e7dd5b4354e77ea874996393ab86bb92f0fb8ad487ad3338eaca2de77a791e9869813b3861c43c3b61ad5029493b77e1a2ef7802cc0ceb08bb7ee438b337483d5f00e214e46a0db957cf145547af43407060307f9b17f793305f945fa27ccfb9c684b5da0aab753dbbfdc524b58974d845a8863c0766934f7d8a1e1514c11b4fad2b4221cd4df8f18323134e8acb8cf0f3a937b8a4643534b74a88c287e68ce5c9a38099a968ccb93b9f8f4921aee2b7367dbcdd97ce3bac9b753d2215aba30b6f41714369c0663b116d7cb100b633c29aabae9d8afa06f2def349fbf10ef837a45946aa4f61dda7d90705d90a4edda5bfa4f48275c36e5b1d4f296448ad129d13ecf4e6f6095a80b39bee1e5d84b5d88603f5eeb3844c9f6bd33a01b1c0924bfb1ab3c9a5f05c8506340fc0b56732f8a1decae8920457573847d9430f9b5bddce24283baf9fc4e499a36207fb6c36306c83e51a48d3e394375e14a915ebcd9777e45e34b782fc7acd5d4944ed0e4aa01a8fbab17c9c3389ecde20aaaf448ec185601d7a2f4c374405e34596b71fb2c4ba592d860235c6624edb75395dd5d4d28065dd388d1d5a1ec397837bea401e257f5c63b09eb17861ff570677ea25d07f2e8d7d469a26f5b9ccd038bc27615140a233afdc74e3264bdc701937f2bdb9cab01af461dc628daf036c1d8556b0392d0341c20911e1ed70c38a2c37cb61fafe235f597c112bac07e13b890d0e1fff768253b50d9a7f69eb11c29e81dc9263c6cfb31bf5e4c3802adfef68841de6b700979a7e22e2f373d345d14ba9909831fe16085841dec63cd9ef8842bba5885547bce837c67013d36ce27eddb4db7206e152f50899172197a3a8ea93d3cb1fcabada3f4488e7a0d975c74faa03217c785664b49c7bf097be263039894d7dc9cd04ab88d7356e65c72d5a8a37a28b343c5438e44117f5374e10a197ca4bc254a884851f541a005fdae44b4d437f969f56eda46ae87d692e32c74943effe4a87c45dc739123a69c95e423561e6a5e3f757970ecf616fb09bd7d876297ca6b99e9142863f600deefc003fcd7bc30b18c364e0006d7c21642e326fa1325d6e2c616cdda1fdb128f28b3f7b1aa652682007e84156c7ceefb6b6896b2a8bb037a1ab8814f72ab84e4f1bf30443276e532ba589190614e236c9bac107ef1f6da9b4a41efcb9be44959dc02b9cdfea920863a070920d2da6095702bd736f057e48846c2b8ff06e28abd269a88778954ddec6ddcd6d69e1d1ed232dab42fd4a0640e2a36319abc8cf8685d14d14178392a7e9e0cfb94c5be0805d89953f2504a16c906c6f43f320001324468bffe2ce8dc5d20d8a0bbef601522d2de2074d8ec58b34e5a66f1aba739e94c518d8361b51aeb1888c159ea73e6a1d909e88d5d9dac32f13349e8d415febab4551cda22ebc0678bf4b38ab89be50f9b8617a61d8d85ff444a53529341d2db6004167c80de09d377b0eb737b9511b663f2f2c34a06f9ff3fca0f83dd29edc2306614a6c61a5b3701579fcec3f1c1770f7d51b6da63e9d7e182187f3915b1b5f8fb3a608fca367165d3d7c21ba843c86e1d9ed4aa48d76c120b0dc4a2703d27f3d7d9d26e28067ad092085ee60c892c9bfffcca3f5e8279f79b94cae5f2c9655e98f08d5b015061d95f92abcd1b40fec5a4d42fede00bf219ad7f5ea3b5a1ffa9b309308d2b0d328460d20abc61ccafee444fbd223e4393c19383d4d2c89b57bc5afbf08c59398c2bd3386c196eb41d07b448c41ff046b404365c3727e6ad9af794d446690acca78bc551c8c759ac460be1888a39134f475ef32f18e2360af7603f451aefeceea65cc30c749f01ce68145421679a989fa9094e7b76e3c797c867b37f2e91130aaed925b9d22f9931e447a41b8895ef32710070f18b6bdc9c72c91ef5a4245c179d2a3866d056e0f7fb980b33e3d3c330be4028edf249a8a99f38ee484cbbdfacae9cc6b8a516d8e3e67bfb42c2ececf62ae7cde3f5cf549a8a8f66d934102d7e8ccf3be4b9f0af8ac7e88069422c8c9525089c569150e1884a37d2a226562f943abeaa8abdfe03499575f44e18c53e1e105da6a598ee27e45a1d108c82b505b9706b8b952d9c4fe21595ecd73ba482e69f0220d2dcf6ff399cdb4cc341b68d328f80f14da9cb326050933f6196e9c3921ed499e6b389b3c078ae99f6fe5e9320ea16d6dd59114e934908b7ba20c0bd4ce25eb3fe0bb31d0a9088fc8ab31a76a54d183b41f40149a19157f3291c9026f9c1a5a93c71c13894411d8fa83d77b25e28166768f3560a711765f1635f763a93134cd2d4a5e07fb28d336a42a0f33793b7fd90321725f7445f9fd4565e7c7ae2264f21144398fe041508bcc64e6c7c2ced63198d35d2b1ce046a6a6da5fb18fca6c5f8960340f576854df8081e781ad3899b285cd03e44f9b677d9812e607ca8f8d464c6e3a0d745052444cd216eb05f98f7d0d40e956036ec29ca907c3659cfae3b1834e84a2a05c55a4677a9cdcc3bb95c7059e5669f2764023e84ee390379c1c5583aba98fde7b49b9bd22c5a13951b02037b7f36d0533e3b4a55ef6255ce85b1fbe9a1764602acc9617b10a1fa3c9398cc5fe7b4414a8b9b0109b47188398ca8a2c8f4f159439e5e6e75a4857bb7226e391e274b2593a070bed9e4d97ba5b3a549601508ffa2a0e801b6599025beccd244a845d98cdae260dc3b820377a37d7a779da99004a2db17c876b006d9a9704a0d6c8850bbb0a3017d7c5f584314f57160dc466e374f16c23aedb8c6bdd55723099593a7bd6cfbbc57ccf4d1dbfe611b5f30fd1f7ef6779f21bc6421b30e7395c70a5f34d71257d77897dd7dd893290a6f2263d66915a8124a07877e4db21c787448adfcc0e1c81a38eda4aaee5ac2336c7ad07de352c6f12427822276fde8d9c7823a6fdd2e282641e72f2d1ff46f489cfe4a455c9601978f2be8d426757f309dc2b75c174ee2f33b241c5f03e5ba619e19d93c002a012bba1277e097a1da92d8623b5d01d258bd5e3e19b45f42c673edc34e40745235a8b61f83b8e776c885e3969b65ab0628a8aafb2c72a279093c9d524d3446c9b80d37a7d8c427f52ab32c10d8f891f3e6efee407434967c3ecd5f40d3514996c451e68b1423548c0edc008acdbdd148543734884433cbfb1bb6330cf3c95fa78ef5e4e23dfccd52be4768f00b9e29c92627b48d636361e99701ab8f0cd24c206e6630092a8c2b61245d4d1561d1c2e5f3b48341a7d83018f69322dfeba2bd785f431bf18cb2f95c64f6937521f3e96af878725d2ab087d9e910d2205708cf85365710293c85409c58c847af27c2a592a45d1175e6ff847e11f69994fe0f8a1cc86fed9774bc67dfe02783ffbe6b18cae2546a85c2139cf852221d083cc007dd734da58beaee2fe90af5e11bf2bfb0a639b9b49b9ddd2fb63d2308ae038736d38f3ed186a3b343f83f10febd84f6ccc72cf50ffd0bdc8a20aeb6b729887234144e4c9c80642e7a209ea9fd1e6041c11f6329869450e91f068f109ce2ac3aaadad4ca6f7f2166851c8d91f27fdde44dbf891d6bec54c26de5ad3ba3c319af5b960e2193ac53cd5d6181501b05c5801f5bcf4b4bad02eacb8230e630e42b457575d5da62e71f84bfa9a9e0a1ff6919191b10bf46e0c493fa1a3f207c9dd90c724446a1d884df2f7070ccda0b11a1896e44c52445b81a9b8b1e2a732108e9b4f94cf265997a225447b6647b0c1a63d5eb6590489a46807f65e5f8541ff1d6e8704f109d775d86b7286da10bae0823fc3359e199687a1594468fc17af319fe66371812fa86c8d8606724bd7f7015fa1505fa6a06a1d39b856538d20d55702dcc17505526020b24644f86ca7376c35a24dca7a81bee38e877c11d0330b2689dbbad2937c1f95578d0dd640d60b7912fc45f90969caf1bf0ceded2e1be0bf0b714e6f1add4178f06e1b4d6078bca32b00507196c0a209ea065eb23d45616357630b3881840f0ca921a660214460c6d1c6fc7fb98bfa49d9a301960ee0ef094ce30afe002c83443c5e534014fee5a07d8dbcdf694fe0c594656d02eb50b2267f530b2073f32183717c2880ec1696168e3ffb15224584aeaf0d38d885fb0c19198b60c3db6a383c5977de3a0b250006691024aabaf92103d454e9dcd08194b18c9b24663e9f5a522f86c7d8102c4834944071814933d7c5f33e4f37f91411c15f15f1c7208a4eb0883d3b98d87f2ba7930135f6b845501aaac3e8d39bc808b5cba2ae678240e320a21a1fc3cdb660205849ba185f0f59c25cda97b10eabf0e61414500bbbe70d6453755363fe6b493c2b9d89b2b3ba21b7dd03d005d2d4a9aa74c7a6f4c6449b24095c12f73a4ce68775642accb6e778286ec78a02589e429e960cbeb35021fe4b6aa21ade2a13d48beef65a0c7c60534961bac8e16129b9d6bbefe030b03c828a4faccc95036cb4f3d479110624f07ad1d6c950b51c229068df5f77734139af5633e8fed1e77c5e9bea7048d48c74541945b24cf3144bfec69e328273f87e94035995b90e3cc4524fe04528af220a6e3b90dbd3ade6e5d703430dff66e6671b52118257fb47233aa6210da18783dc897aa5831c061d9e72083e7b0a49c6a2632285c85c8156978e8e08094d70f2136f09237ba15fdce6788de45547e9f3f351a35370686102b961bc3a8fa195464dbe705f0582c56a8d553144b961f4e09a250193242960ac6edc7a15c5b54a5f46b23a1dfed537800690ce97ae58bbd52374d3493f7fe9a14dc3eb77be447ae117ec7cce5c08c549dac827e8d03168597dd80ae8d7b37b1136ae639cc0b951bd73dd01eb8af38cf19e0ac91f5ae65612804c93d549a80fc9f8d8dd9b95bc53db6200ede536bd531821eb5aab38a892aa8ab4628bc0e9bc2d1f87eb6fa4e3a8b2bbb9cb2f9b8ca058ddc914d0862b8142cc153669588eb062c96b11b08c169ff6430f5370cd1e689ff3cfd54bfb89a2243d7af4ff052e2c877927c75d5af816a01f96689458e51e1c2170a3edd1b71a5c568da5c55cd65053055fcf651eb88e24f12475725263245380267896f72069cafe126ab3e4aa5e3e6a894e2d60665a9333bf681f7ad59411e39f155aeada5dce64193b618f730c24ac538c5c737cb439d7f36781ab668c647e1adbc51e60716d2c0efb2a6d48805e45c17b80c3c39da0cdfde81048d6a6786098486201a0830a1c5623a0a82f84fa8a1632ee0e06e3405653046cf512dc0bdc39a01328fa923b8b3e82ccba3ec8633aaf0ae8e4ed3640cb2eb3ea9864938c33c36fd10a0d03919050f8d63916665325950040d5f92be821299340c6e8008682cc1abefc067ccc3282029817c39da7cbbc164cc58ac9e144ed850bf8b6cc0b29261cb863993ad1dc627ed8d8b5f31533a94d60890342de30a1f3e0283c8e9b02b26601202d02f31eea4079a419d5d9dbd2dcc36a52b834ef24b337f37543da49ae44e915233021000c5e2930b189b6b2e5fd3aa76b87f5aead340fea951c862763f67350539d0638128fdc3b94f5f4a12eaddb532011bfe399ab39b180d8c96abc9e9d8f1e4daec7d6ec4c6e7b2dcb48bf73d10bbf486804223014dde2fdce71c73461e99ef8daf39bbe8453835e8370b5f97f19b0274d52eff7b11c12abe0047b3a11cd0fb0d1ff0d10aeb123bf74cab026723a1ba7ad4f15d15df18e57bc04825403da15a92b32626b730cd529dd15afbcc567a0f26b8e6e0372c5549f8e2413d31ca3341d51aed3868c6ede13058cc3109c2b92c80222d02622b0f7cb09f111d4314e55fe2841ebbd8f19067d4dc7b594262875960c20aa8ae089245b5718d4c6acbf776b2ac4256799511856783a13f5cf76dff2b43cec216bf56b1820df7c8ed9b7c62503d8760725092c43585c357984c15fd21aa1a51a92e5d3d61619a74002100620b5ae06ffabf55ecfe1c057a0afdd9feea3aad2795d6086776b988b576a129a7613d038a0bccf73176a494f49379bf30809871fee5bdd3cac4dd1566e7c9fe8f6a9f702fed4f59e8eee5306401b69e8c755f2b306a71c2a55ec08aef070a62e7862e969c583dd7f09bca9167ebe3e709bddd3ae718bdea6e6fa3eed8d1817fe789067019ddce6c333f8867ec2d0320cfaed61abe0397d74d74ad0a4d99115c5de96522119a71b7f5fd1ef1c4668d6c52c69a5cca8302b2d07c8d03337555597ba922818ee6e66e53525545431c8980d20736a958ef0386596aa1900f3dda730c04926ae1f5f35fb4c1159904387be8e6a8a7b387d67909fc4aab6a4558c0caf96983a515db134783e5fcd454848de3c1707bd12300ec2c8f3614473e6e7c2bf253e35b264eaa1a38043b873afe29ea3214d8eba1b62f834952f78d6cc198140a3f33ad2e2a1494bd48c25a7d3d77b5ba6805df899c37e4a5731046a6731420034640cd035d58215be620ae53dded98a9419cde89cdc9267a19368a2bc9182f458582b5fcf9b3a82bbb4657a87901ebc5536df2f074f0268bce36074e18684702e78bd008ca2c8e502825a27a7b4daf1bcfab34f83c649f8499f71a02e8e2683b273c8dc49dbbfe6bbf7a73db064e909859894c6a8e4928ac3cfba645d0d6ff853799395215942fd01ecccd5cc2934f8ab0d953deacd4a9abbfce27ddfb53831d616e71478424f0cc50dc4410c127cb53b1ca72be32efab0636f50f9b4e2326545c6921aa7295057e202071c7dec07e4c88aa0f390204b8fb91d57ba051e8ed50d67718642ba700d2e22512e35b524cd48ce5e71ffcba1dd3f60fe7ed406b3071639426a07ad166fef18f4bb0ccc5ae15941e125c2401a25040d5132e81fca9b79dd7f916da53856615cc65d7d512f35f799f83a2d00069674640ad34c72d3f50a4a94e1e999efeb77f1cbd029bb33bf22e85e8e05944e07c85de318ece8fe6ffb15c0c018bde6593b921dacad9047f100735ccb15883a575151ce306d67c3e13625067caf978b6890e8a87087e2844936f15b0ab98a8de7ab821ce3cdedf6def4e22b764fbc2977681c63169fed60fc3e68a4757a9294bdb96184235d543e3d39ae52b6323183251365993b94d18e84ddb9ad5f1026d1c2d6bfbf18ae90e91cc94b8e9e44d33880bcf2dc232fd0cfbf158cfde66b52c5f61e09fb1a2113d72d1c8ddfc4a45b0f0f19ffc64333e7f014a7f3cb2a9066c9e6fd7d50cf85f22257d7b58d6c399bd315908df3ab394bb7f8112de63c00ad7c38d4774d3a213cbfa950edfabc744cd584d66552eff1cb6f64aeb562ede3dc399065feeee0998b6bfb8573058c77578779caa30c47f5a2bfe925517bec269a6900bd2b73075aa4ca584fe7f72e8a0836f2318b48ec05a46a603f5200e91b9ee2313c85f854365ae018ec27686fd48d27c8ba9944fa0fa18f046cd1a9d7ef952946f7c8e0949f3669da1da9501a5d67c0d4c0737891b415ee7c1158c2f7a3a5c10219d3bd2cf855fc9752b9f3dc69bd801799b618ae8bf598663b9290c8e17f8ec2f2b22eaa93fd1f7f8a78ae6f477c07d4b6de6c7e8718c7d6aa914af038c260ed4ff6520ca40d81985b2e89440f40b93f8016687f66176c7d6373b9d70586fec1ac1a9fdef14c0c804bd72d13a39cac8620f95949e85ea36d790625d90ac28b0e9673fe33a81572eca8117ae961c719f3ad64f5f603a562d47437c8a0de8a8170aaada781ade25fbe3a73c9f3f3fb58f1eaec0c0c6df738e392484973b2b1e8dfadd1e5c9fa9cdf362511738f060b98223b9db0aea9f8141dd4d853dcbf8704ceda2b85073dd6ff0947fbb8e9b7cb951d6e5011d485c61e5a61d49a655ccf9f084374b4e6a128e384e70415436a61911658d283c3613a6933b8cc926c5563427a42575cc70ad4c1cb9d4d247bd048870ca7580d41ace5cbf40659a1bf7c7af8751726e4f53e4c8072cb158d4a1c74520876745148e89b3949e78172e765c810191422b60cf828053508cfabf5759c16522a08ab4e72d4cbefe31d7c432041a030305e0ece437b715aaa0a0adf092423192ac5723af40a7908e3d7ffaa86ea48f5ee4157b5a7cafc606f6a606a9b5ca83122c01ca4e405cabea8ad4e051c223529f8e3d265d198d774bbf6991a08bc9be9ee70761f7555ed56761c6dea69c1ba39a4609ac94b10235ddc484eb0ae1f93daf519fce848697523b553488c7ebe41fa2372331a7b01ba6e9d815ac7a03e6bff0b77dc29ad70ed93dc10017a1eb0bf53659af33cf859be9fc68ce8037e7194fafad7375e1b8d54f2afa7b483a3b143bcbf43e8f673f073d7ee12ad7e7196fca8aca899b006fc97c341df131c2e276b0c6c9dee070369d551ff27652924b674d80cf584253aaa69b2cd38175e1474b98e4e502fd6f2bdcfd50cd0ff033f12428dde019cc17ad174a43912c3dcfc877e6b01d07aed524a1d817748d56876be48d0e77bfa864cf7ee4f2ebc78ee1c30522338fbcc425240b223501c3be5b58593d34d17b7d2f088aa69c98a8fe7e307bb4782514d845677fa9fd9ea15496f16a5b870c2776393cb58b2377a682d9bb53a4ddeb9768515ba0e1d24f6c6e528379f5c4dc3b77c0494b01ca7f13e74aebf0e807d920be7881c923ffd5f8aa5f972edfd5ac6b16ddca04c435cead06803290e3e29690ad1adcc0714c4a33957167bfa26adc6d018c9041f8be502c6e4930fd85cfebec487e345d7a987cea12bd29932d69148a5960c89b384d372dc0e512c602a5ceed1ca196be9c2b76f755fd1fbc6fcbb16459f9e01b35b1e18d61b8d776c2959e3114cd79475f5e008343248844ee5eb4c51c0d696159a3f04207bab5410b6f240579e9d73f48ea3e606aa427a95c9cb1e25cceaa9dd32056b836c08dc3c5936bcd75b0c6fe9dc8547a84e69b7861f1289e367dfb6ceb3eccf359eab538a300e1e03363d7504b404027eaa835a48517bfdb7067d3f4bedd47faf98e32a0f84ff8b64c53f208ddd366a62e945722fb50613d59e581c071e09c221c76470f7e0687fb09c714fcaee5e3329cb811e71547a18db9d3abab004eb296301e226bde9a78f2a78275a7263eadfcd65897097438933558edabbb3b06fff2ad2b4ebebe54a0e94162728e78002e8da5060a6729f34826b7244cbde9831f3419af557591946a32f571525258befe9a22f95c1073cee60a8dd819eb354c0bf0a5c439f0764b4cd9f9fd25b6d0b4e842cd28c5d2cb225ef690384d0089343d6c32b30305dfbc1aab64b15c7f7c120f172906e59126ffa493ffe56fe1535ae0ddefa87afb048e7abdff5faa47e69fece2d0889e90a2c74f528e0b93e6a12713631ee5df5631d49d3e67e03af0eb7a3f808858b2c1c6fb20491cea0c260f4044ef6dbf728f8c77b2828ec7fdeb53821d6a5879e30d39c276dbb3723b0f80064c199bfc3e48892a57a57ed4b2f8e77faac793a7e67bd76ace2ae0ee77c9066e2ffdad5d2041eae8995965caf15087d93674fe78390dfb512d7e09b0bc8c6061426e3254f4301344c7c4eee984590a02ffdef7bc481006e5b096d0234667413906c7b23d37530b8da4c70968b99af9b503f8ccb5a4ff0cafd6a1899559aed7ca3025c68bb32c5ab1d37edb40b1db427a3ed309613edab9a2b793ffa7cfcccaa34facaf66accdec3bc1b98382cebc5906b0091ffca89c254746b59493fdcc222da51af3d82f4c3887985717cfddf6dced4390ca0318474ca3d4a76e4fbf934e15148c0d892fb86c8621090278bb3f81de5d0742becbb7dab7738acb068611b4e596b685f15388e989cab1dd65191ed8ba785ec5b6c9e3ae759cd1b268b53ab89c87e3c106df4ccc474868d30df9c82cd8418b9bcf1842b130d7296d3739f79b568e084353ba0da072bcd10eee902c02118a7a7692108af0445b901255f204c43e3c1f7d3fb87da4e53991553fa9c1651db21256a66c6be0bc35054238fe06a4c68bb54a012605b6a215a9d8a41b8e7e9457a2d39ff3f5e0bd6ec0b0895ed3cad307d40791a1ec121776ba394b7edf6f6b4fbf4e60a6ed81851cd87d804fd032f1bc334431d885d645e55389a3a010a7f92450725a9ea7fca796a6101bc27cb4375ec792183b6e0687510a11ce42df6530ca1416871b387dbbb87a9f661b8262ef1ea8079d7df3b502cc8f351210df7df93030b7a979c9639921a0c7f0a839e321d81c35c6a042e487664d844a1f2e35f2a180ae64c448be8248755654687df6131370f0c4e61850f974c76382e7f075e20452d4adaddf101e94b74e5e813b9f0450eb2a5f5fef3dc726b2fbd136db2db5814287315f9ff0205c3e7bc23841e9b8dad26fbe3da4137a536edb2d181b4b91b3f163e2487e1b1d2dd71b5557f9b25a86c9df25f4513a373c19cc2a500c094e5d5d13c3d0449400f2087f8c20242f2c937fa11b3bf5b46cdc940319c21be32c9a4e10db59bbb903bbe9a8256142557803195910d9fcf5c209de51f66ad61ed279d239eed44391439bc05a9b385eb42bf67e32191bc2449536aec4866027092a14a53be39078a7f4c36db56bf75f009f4f1291be0ea9b3a8a515bf1dc6a91c83c232d22d42edf10cc743dffc097a410ddc2e3377193776c64ac675733084899a9d44f98f88fa859829ef0377e9a5ef1d9ef702d7dc3fd8629fb01aa74cc17fe31896b30aa2200a28cac80ff7f779cb6a3524007331fb89b4efb33a15db15805c935f0e361006f3135cda2df76c9ebed73f4828f943dbc7d029c56b679fff4aeb2f4169b68a26319db419bc302daab9d88229b38b3e31e90c823f74dad80209a993ec90893e296e2934163444d1aaec51697ec35c252198e2485922b54b40be02c109285f84aa25ac4de03659793df842c1678d3152fa393447109a9c0fc3cb0da98c6b6f937a918b32e1ec62f2fe7c88ef32a606d543ad3aede0e4f6734d0c993a3c3ca6fd1ece1088d3467b58f7b44ef6db36b5299c4eef2f92f26a93f75078a7157ba5f3e4c75796a15931240134ac0f0eb8646fa1a0be5501c2a18be8cc419b9a807ccaa6db2de9050bf80baafd42e9fd8203f11db8c4b788642cb6e3449beeebac55ad07a792e8e51f54b79a81f9f1ecc5cc7e27e79c89c716d82be22625574bab720577e385fedd171e2e72d076d1352c503aca36b737a094b4a9869d5754eaaf9940c6646f0fc6e94b0bea9c13f8283d641478341ec5dec8ca5059ba628237ae62d992366d14139cb0c10f94495c68aaf79cd2b0e09cdb7ccf03230da952a644f5c550d8b1cba480c6f87cf800e0471fdc9edb68f763da47efde9b54e3181663474eb78a95d0f114af05257ce9c13bf84763645219f9f0cc2212d7b82c878996a4f8d4e4c0a6d2d2e3ea2b71685b60d14a3ad974dc349bc2886349e5782988db28e71304b0c6a65d798e9047ef93ae21858f3eaf22638011533f4183e03208776d095e8b41bf54456d8e6feaedd3adc21663513a36def4e54ed5c543e77faa78f8ab78e460c0f31a1be43bf034139fad51e6983a5713ba2cdd728e5c9cf976246284083b8e6363b9a838a0f3ae9bb934039503fe8b45848a33accea9d5447142aad1161086b9610be381716c89504ef858b5faec862fb5dfde4fb5672466451320e4a83d6b0d3145739bd6b06b6c74f6e3b5fc2d5a6736e1e8410c1c69978b27ac684ff83bdad370be5cd50ed5323e90677cbb227c4aa1072c37df331df77e133200813502eee1ccd18f16d04d52c2a4667629733d2256b819b89cdeee352d66f3fbaec75fc3fbaab454bfadf68a12a08fc38ccfcfc03e5a1c275b9fb80f5af8c4188c0e0b2c224c19236ce0d7655a53f4277549c4e73553e0c79f958ce921e238bb9577e72e8e90fe03fe362d9065b69165bda7bfe780ab022c69faba8e6a788a96ea1cf6bdbec3ae774ab626840d4a0dc0d4d0a7b495280a01f54f925d480fa9c53c6ccefc04a84ee2bc3a105b341d3e1c2b60cc30310d8d0e34b445c2611d4d373b5dbd5e23a1e7bfd38c2b2af5cc8920ec3f3688d51e73e024812021164403812a9a5053c1c29c3c679e1b388ea8d94dde5231d32ed9c4b1deff2943587ab53063b3cb5eb0175b04aef2cfcb2c1f5ff02fda2a89a1d0e810033b588b89125e21d3a5faaf99364682d4cb0b7803da1a125b067c143aa6c57006625d705b7691f44ed2588542210d7620cde8be3931df38782d7bb9f74e66d52f53a98d2377de8ecc860579d0f2def56a38df289a42998c1475073e45069ad14ebc220dfb79bcfd66a820870f38d6a22d4d63c6b57c1465cec39e37ef551b84f2b83808ca93201c6593570ab9a838dd5e6e097460e27c22f8e286f677622ec0fca46d6123a36dc05d6328577a8ee869a23826ed9f96e385512583bb8e28d48d0b37abeb66950414d0be32e65f37650aabc2da805d61a79c5c2013c9c306269a2da20c93409c0200aefc7257ca8b1cfe5bfa11ae503cd3bee89c60850f6ac54bb74cfa1164e677660bb39d6a035e9952b3ad3e4861fe0352be820c22fe63eaa0e0e2d90e8069114e38f910c0c7c7e16fcb9a408802d9fa026bbb344f079a2dc0b89cf1fbe6d81eb2f72ab9c1bf572b88f7eb3376038fb6c9669988e51d90bc0733459e37c0023e9d56f1cb73473c35b3e1c69df68cde13872a5b2633c68f60c41541b8069033799c31e848a99a094a8771ca907c03ea493028ee3a9197114aa28ec645bfa07e1b890387cc15daad44abd223a561ecc777d3ab0909d05079769cfe1be3643315b98dfd3d4a49d48355c699988f2ac416eaf16897cabf782e69128f75ed3cce514694d4e510fc6a913cbca2cfc8a949ee471402a667cb6c6f11c015e995ee9570d064e6db5d344a589b80b4636ccccade987d8d4fa0575f82006746b3916abc4ba5274fee06070bdfe84bb133a81ba298de080f7c7088617b16108fbd993c44612f8d88f87bf7726f76a21d2013fd03cbac4d3ca54c6bc1515029a3a7cd589e7cfc6b1453ff644f64fad59cb6735f00b3fdb01fb16dec660fba994e57915c8c465d65927fc00fde0bbd4528132d8055be7d790a995a94524c38694fe683d282c6fc8a8404dbe7f32832c6b2d86f4affec6589132c707aa08d1189254312846fbceec0a91dcee573a4daf9c2eb1e6c7e1af2026cdaa0b66a1500d647aee3a37734a9f137b045fc038c50484c0a1ceda31016c94d4c18b0a9cae4e0f5b2e7ed24806548c3ca54914e317c183ee4f45febd573b5892b5f4ea1ddd1e9bcce84d680b7fb043f692ed35d6c63d0732cc15cf348975fdc9381c2684e45d4d4663abbe4b3d421a00e4194564dac1eea55068af7851a2c28dc4b8148f45059786b744c95c23d4b40981b44e7e2869e3e3288d3a5c38f51206dcf633c0014e0ecb4c110b5eadb92d7de99d744be20b97b184179ce15f2498b21ca756aed658f71da458b05e76e9ed2d06c5440c0a3a377ddfc215696524ada62f0f2aa60f3bcc75115c3cd99a46b6c39155c3dcac89ac0cc4ab235da7aa44a7549f30cf3ff18028c4114871ce561d43305ff1cd6e841a65f2eeb525be0148566be264e6175cd706e2aa9d5961c61bd66e8db0f48db404681c7f5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
