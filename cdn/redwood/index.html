<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f39d7f52892dfcd0463f5e6f4a9d8c5bd6e6e1f42582298d723a015485bc31b0f98210e369840904d5680361f95308d7d4792e759314c2c1b4ce6349e98113cfed5e753d4dc431bf20afb803d9f75cc1b93242963efa6036b83e4fd6c40f4a913078d511e10837ca5e76648d85f050c25974584671f9e931efbbc566cb620d084da25db9e3db9e7432cb3a342ccd695b3cd072aec7823e5fb8dca6747cff176bc052c51dfec1fa10671ad396673d471e140faeaa954ce09664c2b68aa2d13f81f5d7a2637c91191ead77a0423e395ef1dba78e3a563aa4c1b00c37500e9755e51b8ecac4b9c3b636c0475f9c76346bf7411c49b29bff996094a6caf0115643e931f27382a423e005dc1e9edd08b192647339520f5efdb3c700b9bd358b8022d6547011c7ae57d050897fd1580f482fe49b0e9b728b8ccf795253bf6d98f6b7dbc3c32d4829358e7d9f1cb3ccc7fd75fbf6254828d34a7376a5a6cba9d5999826e2b689308f668b252644444a081c868453b4974b2be46f7c44059bf4369c74151a236de5d1fe5e1baddcb1321f4025b5e4da58f5bc58a8cb0cdae5e3f1f4e3609326c5115540de99748334b193a2d84708014cf9a8e67159f0d263444bd3e3596810aae52f114086f7c66c79277c8dd2eb159a28526bd3a85d2efbbf89a5869087b74f457076383901d0d69ee756ad0a9dcb5a2b1f9946ce7bd791c0935ae83ba44b074a7da204b13499c7cbcd822fb5c273bdfed66196ee793e2a6dc7a5cffc796c502a0d0f434c187c8aee7c9bd6f977bf4d8cc055882d59bfecb8cbc307e628aae0b9619d1ac0c97eafcab2e65bc8818cb8ebf15d00fea8c9146ee1ca21574de558e18400ac4697695fb77a157290a6b6834be62eaf43c451c4cdb043c15fa26bcffdd516f628fb850acdfb663f84ef11cf97af8b4c0c23a592ddd0e841b9f538edb661fb6856f1592a1978f6604b3571f80e92d186b25a98a8975a6a81d5f85dcc07f7dc65445df650f89aed1a4a480df83addcac58e8539b88af0036826c2dca796173a3fbf810a96f91d90217eec3b8af1ad9cef97a77f7211f1c87213d22317693fe319d0fb6250bc88a094d80dbb8aec77516b9e3dbfe9b68c78c3aed4bfb777daf9062ef5cf57a6b5f6d555e732fe268dceb3a309fdad802e332c4a6444608c5d2bb824e13a871afe8be14ece0f5c9c17c07a19e127c26318edd992054c527532d79e9e9c93a6c129756894c5feb933e6f899234075dbd36f03caab2bc959869f60ca26fb47d177f86c385ef25cdabac52467365a537555dce5e6609b3946171717d5a4368460dd8ef59cf5200229af72a34340abef50b12fa72bb2a6b70eb6b30ed4a4ff827748636f3d9b1e903bf2277b604e3e2be6b2ff25dafe329b30ded4342211a26057b5648e2aaf2e26914e4608a22336823e2d8c293d851ab57282a766f1e6a0b55c06e6b29cff9d7204432ea2b34dd46fbd2e42428ac528b970af1cb7ddf9690af2b8fd5817082aaa5f2d6b686c8c03c6207279cd4ec4599b793a9cca21b3ae4b74f3d461f875ee0a8c11d1d13eff2e11ae9f4f04fbdbbb54da2ac49f8649e516c02d2cde46449cce591fa2383b735be7f3c90baae0b4f4f08478381da947d03d31bfedfa89255b49fcc788519c11b0c052ef9e432801a5f8c9c1930d4dbd26f82965e6648c834b29428d317ecbc9347d6cbed4ceefa7f054529caa5dcce6d9c8b9673bae53c306a329d2aa377d615d7f0c309be3cb65bb8db3c434d534abfc50a217c955f325d0d341cb9b182436d52ed506ebce4afbb6979dbe95d972472104b9b362c15e20415b82ed744a706c8d6f7da1673e4e7e47a1b2fe3f6edac0f1527044836b0daa6e4d2d9c0517c524066b0b792b91b8a4b3f3e0b53b5b9117217814afadb2c71f51306d82daf53fbea4dc84abc1337266f37db87cd66a415ec8572b3aecf9bd339aadc2fb27baacca975958eb1676cdea995800b18bae26a65d11d14cdd16eaeda5149365748c4a759b8531ad109abffcfc143af60127f45939325b7bbbf8d781ba0644e4391011b03ffefd719178a87406d97dc32fd4bfd3d14ffad2c5eefdcbe0bb23b0373404485fb381189b68d8285d8bcf675c624a4f3665b18907f55c29677680db8ffae3266db94603890e93b31ef8c47187a46c1551990610389c51e5a7b0213e5e33c5e7f5df1ccb3c0a73970c7cc968c2a2eabd2b781be610ae00a396e571e8410ebcf5eb847692af53e633857100abb6fda52d7e9069af369548acb3a4ba20740f45c7f730d91278d7910c7ecccab43a93888f292000c89578bd63ce34891c6456d10f99e4a9e960fbb40fdf65e2f0c733970d0ea441a9383931de7b93593c9e8ccdfb975ac5f3a8e306f7e0bc364ead40e408e433b1f8b239c05c0ff4f242a372bb2e23aa975384c648f16e2ef6f5abeac947e3aa70f78bf87c084b98b30b131e9fd7550b924cc5f26629a12f8b511319ba277ccab5f3c9c7cfd5d5d9883359d2b29ed325a21b247bfd3af46f7c2a4a4309111b93b2827bfc8fdea0d5f8d2265e0704ff834779cebf48e0594dfc5903c5e7871b561f5f39b855b8a1136d304625c9273129ebfc37409710a7083db0961f2b087210fcb5148066be7514570656684ac2bd747a45c2b793084aff3308697ea7c0fef35e03b9ff47259dee9dff3a9a66c3a123b7e025bd30b441b4cc23dfbe4de333014851c849852ca2e3bd65adb4a58fdd29bb28df76393d84277408cb0061ad5daec5782e0e529b6a2661bd27c960f540c0774427370d8a35a1336ef9db48b3492e42e662131ad7add816a8def5a31eccc152b74b5dcf0226369e339cf7b6ff2274bbb79ce61d5d37c15600be96f04de98e81777a852a0d5926cbb35446829f0fe9d20e057870f4fecf6facc28ff045a4f0f095d1516f0adcd7c12dea0707248952a5a3ab7881997b488257c855205e318d800bdfc808eee388a9b9ba90764f75a198b22d24b9e4dec9eb692eeef6608eb70817095447e560271c88062b09950d0048eaa427078d4cd4db9f41a44d157691a91c3369d60335082cd206b0f4cab88487a42fe71d1f7c824789331f5199b1fd7770cb5c6e3619e075c08e81c406911686a3c579dfdc1eb8a0d0f7d2659ad9e524a70b66f7de665d93ac7864c84e12a54e56627992fedef1942c06045ad65894aabf2855a60e5be1fc2999370d05bafdf1a08914278287cc68f1992ff7e54287dbcca657bbea47dbee50144092c2cff69069e954a83202a845a351a222ee7a0c0274cec4051b266cc0837c8530b48967844612c00aa32c5b3741d46a6930408cb8f9d79d8ad0856135b60b2453471afba15711315b030b3ab7782d77b18f0cfef91b7c7e5cd2528ea7d1f2d2e26f5153925b6714473dbf1dd569c6ed93aa0dc9418e8e3daf8565d8abb713307d72cb8099610efc743f41be57800f4fbe6f2d76ba774681aac86b545d0cb403b23537c0853ff1936d84c970892a627552edd59dd27735a025397731e4714ff7d577692f5b14775a403c8efb333c0eda44a22e51f0d43f94fd47633f569c0307a2fdc51f24b449c7c48e6a1297f8dbe42bdab4dba24cd97e6bad66817c827380fae831eb8a31eb1d09a9c7a4ddea88d700a9fa53137d3a1367218e172abd8357a2e2747ad3f9af280914e5315657811cd1c4ddb903eb615f09708dd1c7b1d2dfa3aca59b765edbaacc5628f3a59ff486f9a2ff405f4f880ee70696937c975ca498536e8175e0722a8f319c3e34a9a03fd4da2030a4cabfc500f4cfa03dab3687dca6dc7fcc39cee13178355e3910202b8e48251a00eafd17ab0f0055863c1a7ff2416aeb18973d3ba7c5d77149ce806a41a268598ac27f9fd4b3f9e179797ed7523d7ba466fdd345c4e9b07e40ca5a421ac3a026d0aab070c1b918fac9ea191491eea006b19156a4dafdbec4ad6c58c288e3702af635c367f7c8a753d02c695b88080ad2c64d4a1b4f4aa4d3073f4640a248c0f3498f710aa3e353a448360a1f382da2264992696eb71736c21fb9c4fe35923f56eab917e79de58fdadd8986f2afb32e962a547ef351de67800846057dfb20256ce910a03209a5d849bcc70db984e5a51c7658dc867b8e6ae63ab1bad2055545ede47ebb865b7459b4f653cd33cb45eaf1dc00bb70d6415561989f8319009e00f9254d11ccf475468022ed67407a327a2913396e3b59c9d2b5e2f86a3e274de9ae4d8ae770394694be7077119a852d3f886d365393a285c6b43fbc1515029b00e0402f9f70872fc5f89d8081cdf897986c3d16d9738070ccada71665671bb3ae6b4416d92e07737217e28d518584fc72619ed729f8f3317954a277b1c9e8b5c7129968ca167703644e653bb6a4bf21621a88dd4f0473ab27d1557f98277bb5015e566e6c1653d69130c3af956441a1ccde1577df3ff0d03242ab9f34562f96bb6c14be9687c64d5199ae80dbbbed909b0f65f4a223f1505fcf17b2324d3f12963e0020b51fa38ddd3bce2c47241c0ed7927c683652e66b0727a294390b74f85e67b177916b6e9f492cb934b81c307744f0078cd33e4cc5bf2701a706e3babb225c81af474b7d086090c220b97e2da2acbd9d228d0282437acf156d0c3bd2c3d2c42f05cb2419f4e0ca6b805c2e4c8dd298ce84657694d51ffb4b60a65d24010e41e5013a3a2d74901cd9830f741c7237f996f86b7c04b71efce32086acb7507228069f7240a80f7cda823198f9601991695eb81161a48cc766c61ba2f31459dab18315c36f97fb18538309b0fde999122ce75dfaff0ae59633984004a109a45bd0d4ef537520b91621a144feeda7b4fd168a252885afb296cfb793ebae16647e7c461a7be4a59463df0134f6d843ceeae14aed0b934f8d2af37797c2509535090699c01772fd41f885ee189ed9dfaff166883a05cabdf601b23d11bab76aec852eb996322523586eee3b36cfcc0803fb05239632dee0695a35d661ccce2fa567ee490a429e2f8ba47fd90d363432162d722ec980d12e8fda658ba53d4dce92c24d0a6f68dc8002694f167ae8b750aae7706b47a0ac7f01c561763e8b37696bddf28576c7f21d3074a605d94a0bc87584f10bf3c3efe8f19bf1dccc471f7aadd7640670e19e9c6432c9387d18d22fa1f0b7be026d3428849db98cc15af0ea72cefa7609067bca1d677fc60073018ffe0b39814ec5c5a373428dd4755a7c2ea8e9b162bf03c9e07aff8656c06c88c95f47d7e7cfd5dd15584edc9e753f4a933a6dfb6a7dfb12e4a60dedc6797c8054e8fb2cb377547c349a12c9aff6640be53770e040b9a2a7b980df26e11952fd39eeac9c7d06706fc0f87a1ccb633b29afc154ed188b88ed6aa2ec18962e64d2ed61ea8269679c1f9a0a57a0bc054286968c2616b3ec4258507ec231b341567a47a0e188d7d1ab9137ff1360754c2de18e658ad3b389a071e5aefd8ad3c4b73cad04681f5ed048f39a656e45b7450185ebdabf877511113ec1acef75034aa667b213f246914cd8f452698209a24bb07239f53f2ce47c691e87074bd6c2ccc0e23a56fc12aa7ebf3327c3c39704863bf798296e4cd91a790c42d362de6bcdca69699582ae7e3512064b084a2a214e04924e7469b443f11f3fcf16086fc47f5a8d6f2f6ca4c9781287f78f3682da00add545f85341b43883c2cfc0c584b37d7e3b557e8b5ea377e3db705b584eb5e1479deab0b2f9861eedeb007a5e3c3b31a815161ca2d58d7e854caebd814b227ccf704400733a539656b5ed1900dd63806ccb7c08a52c407b14be2c817a0b6c86b4e61890dd3a842f6e51ceb99bd81ae4d0ec585979622622679d880619499e479a5a84d72d532c8792a6eca5f37d99413ffc6d511b49e5ef9d23f7e88deb375ea3dcdec1cecaf8987afe87dcb450bfaaac29fab90ae5211ad6d9b95b91b6a5c030a3c998a523e1da6198012e82fe6084e70e754bf8eff99ae0bb29668d8cb287f5dbf6e3c7ba5c1811b3df749da7da2f8202821186bbdc478cb6427a15b40f3427284ea381d2a17e6549e2e25cc1caa3a1e7938ab9a436d8e91ff8e187834ec5ad51d1494ba14c6d0c753e0b061659a903895a3f175743eb8de0ddee7eeb87f044d1e68f75d173e0667760cb60da53760e576afb6c66f01128148ba0933dd4b2b47aa86a1b52a7d3b9f4dd3782c14be080cb83e183577daa52c8eb74835c957b67646bbd3f24b855ca6e0ed19e58348b9c759ddbcb87e84916d7a23eeaabc98464d5111fc200b9b3cd18846946aa21f21f0a544c495e5c543e6d27e6c62e85d0afa5f55fb6bb51a8559e1605bb86ccca64814c3c60d602c422187a7b55803c2fdd5df7f4b182e50433e5e9e7b72b004a4ce01f2cd6ed9f5b603c6f66515148577b2d7ba3d83d886263e14016451318857370e9228b614abb45e85b6182bc649addf9ea303f6c50f8b8c40ffff5cb566b83b3b39964ab4cfcdc2bd5d3b307580808fbf08f96d7eaa2c071b294f712b0abfec6521cd29311f82955d4952f6b50e8aacc2a6815845e668a8f2c4c6d059c1dc69faf42fdfd499739ad7bed85745a84f6634cfca40d4fa16cc3621723315686c1477f5a61ab12b3cad983963a9231b4c236815b417a207adcd791b4e1d6f9cc53fdd59d394a5c7b7edf2f9b09422b8a6ac4d2382d2539b610bd03da0f254e4c0a1bb970ed8abf1b7c266fa268038286cd5d704caec32399389eaa5097cd34c38f08c00af27fe4878fd2ab5ae6d71f149811fe6b9762559421b47e908e3f48194d6a54ae537f4c7f8d94040b3ce5baf37ca067099a0f3e6be7d9170996103cc4f701811b9b4c0a9efa81dc99fa2a6989e36d522e43a94b9a88658490c69b88d91c28260044540164d96ca00e9bf45e75446d031b76b401043f3ddc9d9c6bcfd7ba9e0b5fa6247dd07f4ec1476bc94c6c7b3173f0b99dcba0129127a23456126b32e14efbcaa4f921b4de347c4fea9ee40b85320075686fabec60008176fcfe48e7acbf54b5ebb9da72f63107bc862d6e2521fb7979327a8f2628befed84a38105cc7de243156d8f95ed0d80b669bea5faf2ab719f8e990d24453dfb4d40ae0e2d49c97860fd4c40254f3dae234978e5e51c646a67dcd0c8e22dc9cf926d81512b7fa589499e7aa389819293d493d56f3512a33087da017ff1ca23d7612f5a275fd5ee1acf384fb2e4ce443d432d3ecc401bfe7d0adad58102229ea6683a4d0edeb603c36f9074addde2a9f5a13478d4653abed289cfbb8ea3819f48d7dbe21ec57a5b8cfae73336190efd42afc04da1230f18675e308dee301535a2b962ed47436107db29a0cb64e029906ef1189ad7de9800316ed2d9c940ecca41d554b66032e427b0aa54b67e6114934ba2888f5463ce3fff7c8aa0bc6d6bae1d74de0c41f16d3a17e97f48adf44b19275e5c2deda2fd481408922e0a0febd75d39f91bc4b94217e78bb3f1b78a4f3d557fa7561b9891acdef604506115dbf4c0e8452ce48f6a5514646119c47fd806e74a241831b2cea0a71cd22e4c8096559db27183cb5050bafe09b0ac12de9e5a9ae65d0685489abd10140746c95e5c15e634eceea7e79f342d6d2d672b14b79d656606969ff6e4b5729571a8d553cbecbb27a257fdb66dbc8411fc84a116390d74d87b23eea3a91de2d6bd16839c845ff3e5fcf807ab2db3043f29f10d1d980f9b8c105ee6474c41c31bff1d71a22244c10784435c7a38e7c0999a3317891a09020f9ddf93c3462cb95fdc316ee4e725a317056030ddf03093fd24941e2b6c47682251dd2ceb47a67516175e7dafda74150b1f523e7efed93744221c2befffe909aa4be61db091e137488e720cc08d4d090d7f7d2541221ec471817efa4a9ba62802cf6a202d3567fa4ac3f9b868dc5c82431c07534c8495bfd751dc4a53a25d33fe2a30c1397c8eac5f0c357db5a324cab18f6304a7f93ed65222513415584c686a690b48d97759b80036676db80e3947f28619cc5e9cfdde68e9096f80b754316e39844dc7c8a46139bd1a6e7188fb4179d52521467a4e8ae3d71be6992df30865d382a743c6a70ec10c0ae7f7ce07722ec021e662066a5233e9a20250671e939a37736a7d6764235f09c49cfbe302e6f0f25fa72994fd7368679b90424c0499aeba850f959a236a2aa0d0d0be8d5ccc21c948d10847dac2f445217de5edb7408d75b1753cd149870e796cfcda6d0f667bc29a42c194b9c2612472a876be8e27cc5ec6b13bd38c459570a6b0b7550a51abe27fdf29e97c9ccd422151e7eb3147b02eec40f64339adb8683ad1ff05a172d70c949a4fe998997f5f70a8927238903fa12acf1de888709d48683b3667865d7c8abf979770122c80bed36f425b3397e20783b2875ea55571c07267675ff6f8bcc50a8ed9f30f5632f3539199971cc59c39b0a95e90617a18b2974c830feb9c0ab391bdd834238ab5b9a9136fa1a8c62f85e875d32cfef91fddf3ec2e8fef46a731fe8214200c3e0119b05cae5e216528faa54677f9e810a9dee86aba68a990512dcdfa8e1a0dbe1eafeac111578848424238882143f12aad1bf5a7d1ab646a45a6dfaa78c1024fc87cb01d82df647b09a622cec26260196fe421eb317a2cfad02e87d8841daffa45dacc1ed7373a32713712e05c824a38e7a6285be04b8443042570beac1f2f5fb9757020dafa589973f7531b7e532fd6bf1543fdbe65fed20d3fbab7f0d780484b95a827cdd71824c348fc2705af73e17e505bbcc1ba18fd9a456aaa5899efca0d8423313e0379982250a04f39753f05acec10f1014eea1b342bf0d58d8ebe6e39a937cd9bd88c202af634519f540bbc2c593001ee7971564f0d87c67371a6ec6df135209ad072bb054c1af19a19e05fdcca35523837d5869faf3fecaced71197ac9ff9fdef5da5631bd2a37c93a6236555a0cf469b00fb5a138bccb644832b5b2063413ecca178215b84244ff8f308a350579a12e408bcf75dedce928889a12b90c605aa8adf58ac91914ac63f4546893a355b2f409e5d5309aa794500931073082f0dde288864b07e356de7cb532667a3068e8b18ab4b482dc3029d25c6cca97615795707597cf2184d55c18d390a9d4434d7fdafa6f3ffc548916a159e8057242896c3ba169460a93ddafb4103c4639fd457601444e24a7475591ed856a57bb0eb17a579872e71d7e46d4a9e02f8a65bf40ccc7c0d0b7700fb3ecddd04d02d926d5eb176558815e19c47fa70bb56f134a931011f00e52eb151d52e3e857aa4651d7d6ae516bede69ea687ed7adadf2fafa9068098374df16e83eb792263d060fd5ac3824eb4855e4fef6b08cc843cc407fb1821f3914d661383a262d2074b12fe3705fe8b662c6413dfefa74e9f3fbc1165e34062b21a2188536643931c439dac0df6a74854cbf0b6ca86a2465f6580329177d1a09baa9f26d445af5676ac0aab893e5c68e42423e9a3d0387c40c980ca9cb50ec38a1de1d9a60b423e9055f531c4054dbb4732986f2ffc6b9522699f75d6c42410c2da6841c1fd494e09aa6d94c87f583916f2060ad18b1f74118e5cba7be8d7d483591cdbd4234434bb4a5a97610997b776c770dfb94b22eda6588344e1fa71061d69f9294f9c5abcebdefe126f32b9f0ad924a469e20a68306d92befab77d85141cb4016c9e6bd03f10a93b0ea8095d94ec5685411f04ddacda33311bf67b1c2fd506208643112a43e45be43df538633f85995d0b44b0c569ac37b4765d539a59c3309f1ab257497e170d8192b1e9ed5b40731c7dfca25b66cbb26aae597a4863229e12b45306040aa90692658ef35b8e2ac98194d018696eb071a26cfee01be69e8491ca303ddc1ce15314859b87cd113a380f1534fca173d0ce2f21331e6fe98c4e375a9fb37ff71e261b1c1dc8567819a00b20a7e8ff70c460c2dd522abc5f173dbce6e9af1012db77e6601fd095515d3b184246dcee257a7938bb0bfa6769c2d4bf9fc5a28d38f96f7cf0108ab7bdb0433efa4943cd6894d6a09617b4c69bbb75a5fe7871e6169165f6835bd6ff79d05ca757b3980fb8c5b0289ba6301212870bd604dd4fe1e51155de103becc41311ef592fe30975387be45264ae4df77f359fd518faf2590f1dec52eea6625ec1616f722d416b8d334e2ef4385157eb2836642f396b69ea6033244bc1e312d0606a741da40eee29f2c3adadd3d4a1198c7b5319993ac48033ebe8b78bf1efb488fc6030b26b38cc97055ea0d69c9ad98095968822bc01cb884211639c12557fb905375469752c5a3e732ae4181cb38be6c9afa6e8ddb5fa1dd2836287b9440fe277588399b677d2eef3c2130c69902a35453dea0880c6fd247b4c406b019e56d8379d665b38bc4652d088da9a2fbc1e30b69f79feb38ba34209f9764019fc0ad7dd2eced7a890d31d4c6e59b655b31c45611424ad1e8d9c6b9378a463edcb3a3b64df33b6ff555960c3316a095af9f07556adf79e7f5a1222492e9d94f5fd9c00d8a1cb3977168b795145c73162023983f060f30a558afd6c70b5709efb3b677e67fda55d0bd86b8a95ba7fdcbef418e12f9c31616459cd0825660c48ee7ce1a669cf25ed3879238857e3affaa3b326173d5bc65c381755ee16862ebabd3cbb9f4c2f4448acd9f8a90edc7b02ecb2e80dd3eecafa1ddff0ea6f4edea63d0bcae284406374df2ef0b7274e73eba152d9df34988d4906f46df71fe99339ce897ddd3934c55406005ef5d5a463534fc58f6c68f36d9c3bbf5fca8f26e458cf570eb5e3029a41f7b3f9c916a5d1abb54381f192b9a176800e76ba224ad348bca1e5615489f6e18aad72a710b109187ef5d036df0e1b726b00200f36833c7c31c87da5a4ac1279a7ed285fcab7370d9451f3a4a513d266bf71db2cb8e95987e86391d1a1bdac1fa53bfceb48b97e2d56c002a2016e0968bddcdf163847ab5a039a4f51995be170f18b7c4d283e5cb4ec7d9950fc5b4098c0eeee7bdadae59305751f69998482d43c2c885ee992f733635fba2a63e8baaf5a0d2452bbb3ab7815273e865b8ac111c519ae1def309d0c8e6b41f228bca3b72552e342484426496681ec1c8ecb8d021ef064901915fa01884ffc3f65fd2779ac81f9f5a0100739fe279a0b205e4705ffb83c5bbe847e5293fc083798f19d18eccd74c21e3efd1f6c0f4f1708d5fbe8964c238d4f9eeb6ddf8d12f42fe0e13c81617530c73022d652bb38ba00ba049c00c428127bb268ff0b1c24249ee3031ee9b010e7a7ad09e1eeb46d69f473ebadebcf2d96574b173a4751db6edae23a635537250a549088315235431454848d24b73910d4a371ed291f12cbcfb4875498a3761ae5f429d30bbeb31a8b20b68ae8b353b3e991f7edc7f52bd88afa37ee85bc0ab8993074a628c929955d6505a8012fbce24949ac221b08137ad82d7b41c326551865787443b236315f814f85d0b6c36c1d6f8deeccb1a9501f862b5ea03128b1cde23e602b7e81b92d4f2eab96b0a4e623346ba8883cde02b3282a7b124580408e901a069b0e2520a0966e5291f11066f10d56f0fffe31e4677cedde2a748d8b7dc343597f8aa93f3bfca7ce4aa9e7f865fbfa334a43be93f95ea89cd1c7a84ea8879f21f5aee852c8a8f546040ec43d65c5efd0edf111f5f437348b1a6a5a66c04cbeb5817d92aa285b2142c8386bc02ccfdb1678e3a216d99157fc09299ba6750444952759123df9737553639df4186a12ffebdfed0a790f4853f76e23fdfd75e98a2a45294b7b4070ff63a10e5f9c77bcee6e76f866d5e94774e44f470b239228e8344938131531ddcdc019be4730ab03c3bac08ef65d75e02b97b18e5fc8c23e5691b4d8d08bb2fc3e66f95096dd5109d9db9269e43076faf7ecd731ad70b7b72f2bc7cfddb8b4be305bc41272270920e744f1a8d8891cce4b26167407a89fd7f0ceef6ff5f49471b0dc438a062ed66e2e0affb17da4ce7e2351dcbeb0189401f22524d65278b9df9b655344e57c2760f724fc6ef1168c06b93ea2907e4b195a29b5b266eec09ffff75e276e8274b13214bca1ef009ef4c337e9bc2a1b108ade27e1423642ed323816206f359654b590d42743e527802b6da3228f782e7b4329b5e54524c15e877e55a6b0a0a30240258e49bd6819d353638e09d8eae45079e0f541390247534bad1ca31ac1f5089dfc9f335864feeeb9223c486d2ba7091cc66e2de36ea0efc12b67d1f29dd0553ab276c380995b9d5b58952a7cedd47e366e71d8d8607abebfd29466181fc42c733722d0c53e45000105d09a0a36d1a590e83e2aab5342469b3b81a4565beacc9c7643c86698154bea7eb9c3aa76317d95a329c9786f105d41777bdab6842c759498f535328b52cbffc36b1ec954ea855f9b135f7876dcf94e1c897863ff67854f130158c435ba53c0b99e50e3627341530f74bbf7f0f8d368278c771d1e6dfb85957d44b81ca53fc24fae4ca8fe101578dbbc7943d60170aa695621be12a2a902fdcf728d3c106d83ace81593447aa98b6f0ce9c408921436f34cc303928463dd7401ce959ace828c7c5e5e5a25e793c5f0fde0f4292a5f27b0f0fbdac3e90a37ac475ec9a2fcbc25524fd8d90d880cb67badf76a7484b4d1715155ba8b0d7fd666f3356db1e552b6c35951ec40c9d888783dd13b3dbfd79814ffd0948046d0d6c92ec90083ac0334a0aa114ea5906b6875b13058cf396278befbe475d2a4580888c07fe303962671b64c512674a1739a7bfd47268ee62fe65c1675b769abe94440cbc780907d23e4b8e687b1d3e0c196a80ab4681e1b46d2c5fda820d509472ace96229c8c0525bb637036707d289980e2eae7f10972ee4525219b63be354af1f39cd53b3b9a69cc90b73161708524554b4d5b4062a4c3599a08fdfdc2a84a7d10aeadcaf9fb1322b20729db98c48de07e2d2e24e482406f7c02619685fce0625ea33f7dee39eaac29f14f97c07944fd3a6afb72f00ab5c8289003778e257b1bb4ea2b1011ca513bbfcb1a07e4a658bd208231d85a1172b2f79e0c0be80c6f58e4dc35d0f4630959daf843b32f7a16982cec799ba0ef6c03d302f927004ce3a1adfb8bb6fc02ca5ed08481f30af43b6c2619dc81562a212cb6488030d6a58d7166ae5df1d47c9f58d028accc3c6bc1cd2904a90d144bf744aa65547b2c0fd27de752b710db7e2eb6b8dab657f37689060f94b879d71d72a4ffce2d671e48dfb658395746b41f6112ca0bad345ce91a5427987210edac47994af281cfac560557ecc77edbffa608cb96782764e0ed9e23a60a8f4557e93222b4dabf858a9fa6854c0af70263460f37afb89941c1e9a13f09622c2245bcf62980cba0eee82eb6faf0fcf416f1122cd8c8bfafbc431782a1bf17a9e5c20482a475c380f51aabdb2c7d9a813884d5d098e7f1c451a766c466b6d61f7bef8f24082e922ac514ae315e0ad53d6c68abbb49b89777319e37469bd16aac69bf3b519d08643411a9493f1d526ab2add00ddf5f9138d9b262541c169c41aa5369a43341aa381606b6fba620368141ba3227af9c30e8f737d493690f4a4df57a5c4eac35148ff876513279469bbe325b835d7f32b9fb103c79800ed25a864f04faac5d48b0abaca5ae474c5502a7674e580ba76f88e8529ad2f6039063d4ae8d9b9cdb7f9253e444d80053718b3e5d18228179c8a1297d99cab321b7c570420d90d85873ff28045018f66cef8e2af0c04c38357302f1d754f9862edf90c2e85a738d33d0ccc523ada1377392864fb2950a343de371893fe624b39438a0d034c07b133e228730fc23ad12a6ebf142a783e8901318c609410760611193f933a39b3bef399a2a8e9bd1af34d31bf9d8c7eec6adaf73d6b472fc2b8ebe8f6c3d47081bcddef0d7d2afcc45a7882463db73320e5fd30eeba0f8c96b0bf6f266c2df6205a3b2cfae968bada3088819dc2bbe40fe3d60f34f5ed20cfea4d269b2a96d6674c7ec551681f22a5947816e73c4f98868791f6562358e8323850fc31ef550648c3d8eaf24abe9a8c2ca06ef33795a94802d11da4368d16fc0efd56843c22acf307983c584993835ec011d1e8293879c808025de22abe564e73ba4509c75449b39ad2bee89bae826b39212f71e9037aa552528b65a6e9a8e81b895581f51fe67ece5a48368f9f1385eb4b7c03880fbf1c2ccc88edca34a1b5e6c8b6964f6647563572c17c9363c5ec0e3bad6e8979ac75a2b9e9dcd6664a5199f6d3b3f5b67a224554d98daaf0a0bbb826b699ab92fca2bf66f1147f46c4b2a565b17651635860d46d60b4df4aceaf1d76127f658495945ea4864649207e2b0afacda2deb687597d92ec567e2ad329743fe9965a07e4ab4e9375579ccd512230492e7393f22aafba5013526e7c4e98b04afdf43f53eac08b45777f8f793dd4a01bc63b5b2b3ea78253fbde20b5a5103ba383832de7bf16b3406e93cef24a7379c7b10a14ddb1d453c7862c5790c50ee9944c4b62a79502f55dedaa0713fd18b4d5b4a4212c76f13d48ad0e1dfb48ef07e22cd9de0fde616e11863eb0f308803ff3751e6c0ebb34387fd39853354d073e5a53900dd7feda73a1c2e6ca7db49135edbeb6bd5286c73ea312db4de862d37e3eb19751f7f77cf3ee76507d2e6bc664dca62c2b0d00df09d8774dbab8740e73ac088f7d2ec24a5a25ac9acec20691402580f2c38ddb852df9ce07e4207c9aa0cc19a3404849109c1e9d336cf76389b18ed020d2c20dbfb027d4c774b51e59898157e44502f8f76caf0b195fa544c7571f03bc8e4792c8227284bde5a4f89158f3bc93ce23634964fe4583a9b090a27994224440bab1451797e7db1d6276cda6e791791878149fa2080323669e1d9b897bd09e3163cda62d4610a7e0727486fcb25b211c780ff2176c6cbcd28f66d09e6393d40a1cc56872b192a2c4d8f97c5f1f28e00389b4680f4f9f6d0f9b48db8b208d44c025a18dc630cfd891c30fcccf6c7902c79da4d580204000c1a4295b8b0e27d4f2e0e4afbaba4f1827ebabd537ca16db16f32e366fb85dbebba2008992502554e755912f26ed8e48569b0e5b49583e6cf6ece2f5dd0039a34fd1167b6d27df6c04d4df1b3a2efbcd91e4994809fff71de0a7fd1071d64bb35abf8210a59c5c3bc46ac1d411f9030b4140808f11aecab30b02e96ac87bc4dd6e108815846204e1faa4ddae5a1fcb2a6ed00a4d3296f7d29cc006f0a0b9343777e9d5a1656824ddb8da089224dd2179a5f51ffc995a14aa0d0bc9bd85aa115b069dff2c653a13312fda5c0acf39326380d72178c0fd6a215f4610224a1e209fb975b4335dcb0c726e5d6177a6e0bbedffe2ab9f4f2b69704221402cabde01f23c335876c58e0ce2de31c16e3fe6545bf924927f9ea1f5fa594bce1d3aecc0f97e88aab12ca715d6a200d81fbe9b04660995858b2c3e9477044e8b8c44f96426309ecdd679952c0d205a1d51156eefee3c50937fa2dfb83e1ca242d852dbd4fab5adb6d9783b86ceee465adfdbcc4d72e3cff0066cef66a053c69a10ec2e9cd20727ee2bc5b0f99a9afd3ee0db9166103baed57ada1e46cda3d51454dfcd04f9e064d5a8e57b5c10dd802709010cd8ea0fc75e719af682cbb8fc14f678ce6ce5f3b6be9bd400b68ba169f4cd5d1070d0d512ed7ae9c001fa11d4f91c4a8d10c031e3ba23144a9e52daec465267c35e55240e557eb78f3d7b1173198cf8afc85e99aa82295fd67d4ae9bff0dc2ae8ec7d39fc8f1ba52ff5ac67e12c819247fe3107a1cda19e16787be44089235d3328e464dcb84a51092e14ee795e6e44bb224f9531ea23e901439dbae3e0546ccf14624ded92e6b5bac32ad6f1ee47f595eac318de20fd94d88aed11d9704c9f1ab7eba807c55095ebe35985033d8fd4b62be57f502dd78f9a61857a02bea91e856bef567cdbcf52f34c0a8caae437fa2cbb117a67934e3ccb44689591393d519aeca878656e0aaab4051e28210d17a50c86fb34e84c0cf937c87c9c0c7388a442119c3e44182790cf590037e8379efc8cb6e418c69a6c2593e25ce278f0e46b40638a613bce36fe7590e92926a068ee5df5a1d1a4562bb489d7ff4ec0b0ba4db624c60eb02b1ca0cdfc8b2a33f8ed5fe7f890d1f209dbc7694793b4c25359878d425c91fc13863c9f0d507ed6680718007b02b52530c49dd29b1c8cc94f0ec73a7a1c465e5d33661efaa2bbccbad01be419075e0218deb29d7c6becc754a3967ab31df9baed0248b04136cad173ab81e5ad03f38a96b6b5d0f6f19a3509899d2544c564cace8a6ba73433362e667933e55f8c2595f3d3196c69605ff2c5ce6f0326d6e05bc4d3e39102ea50aec9df113c7516de76fc88b5ff9d13f8255661fcff748893a39c5b2fea33266894f24bf4e343a6453ae801ea6677bcbcb6ed2cd70c27badcc14e5e826434411937bfe0fde139b3c20ae27847b33e32bb86fab2433cf852fd98ead96fba18b05a40f3ffae6d9febaa9611e33ca68d0055579c15e6b598af3adf06c0bb98c7370357227979be3b5ea124a0f9326dee1af3d08038d0f6b741bede1c9af4f22f75c747777fc518ea705d82cf1bf0bef61170a62d2a70eaae7b6cb5e56f571cee5cef03a607fc56d3e248cf9b55e53e94bb819cf0beb3c2b78f595e76beeb1cb626ea7e8e2376cae0f6e99b360171f94e328a66aa30609aaa958a8829a4f270100d8039c2415bed4ee5cc02f0689eb4611807e47412512315437e8dfe446b4544e52a75cd0c620d69ed068dc13d26bd4c14c1efaa8b11dc604fc091de5f5cecf09aefd4802e4d3b83b137d39df5322fb7c916dff831c246d09f41a2e91541096eed43a97538f8bbadee2fb5319c29b11524e681b6ca0d49c271c147ffd580f71f9a3e7d3c1e9ccf0183dfc589dfafdc1318bc64033c72f2230cdc594859d95d00cc4411e72de70be12991e141d91362209cfc657acbe477c11e287ea8eaadbadd415a4e8857d19544a376583dda4c6750370866fc7a84c999e0ae70928d365e2ebb542573213198c5bd5e0ed05c753882e7e5d75649a737ce2e463cc3b8b555b15a1403bed53de2d70243f326ff50ee77285ffb4d1a603921ccc07a0f1136008d6c888e672c20f7fea749343c4948be6438d156139f0c659e4bcc984ccd9929b72bc62ffc49d52b746006b64807ebdaaa4a217ea36350ad292b0481093cacf1bfb5336633267133ca8d693cf3e7a34aecd71475769188415d16f8a2b9126dfd6acedebeb682fec2045225aa395899be496740966a0ada9852cf4c438927c5efe610a6d8e88afc701c01e1b908ce3530e005e0262e8737c1c15a7fbcb9d95d54c62c39739c4df1b288acb02ca96e9b69ef36c855e29f7cc1014d55a1c8f447ba82e852f663a82b9ff950445e2ba5caf82e8875c4223afe659100f1b4d5d74be1d3255e121addd29c989dd2de2f273939cb8b096f48bf58488b2bdd5c08d2730453859c6e3a8090f321a6354eb2d77a05cb91bbb67c2504016519527f42c7a01d6e1cd73f89109d66e29f8e057f0582c38210b3afc229f698d062790510dd43380974e430638799a1f837b4ed7c356da61247875b5020c23a6ed1994f2b8791e2292385241af16315d41215d74b95a721e4ec4b3386ae187ddd2c76b81a73cf6d5d6eafed8a070c1348d2e70c8d60236dd6f8da48c82add88a29f0cda946b5e00892cba546b8b479e22359ad70dca525a799d8f6daa1025d30d90c35f8ee469b9153a157d4607f9db6ed0b6b0bc6eb3d732a7fa579682ff12af3a9da20d41455136a3611f0216c3e84660bc705bf161a8c4156016c021dfecb2faf925ac296ef8f7b17caf69bcaf6be1bc879e33285dc69e97933c3562f52602542ad226e01e0927a4401e204fa62042c6e8649c7b9353e313627cab96cb46bf1dd83b5db8d2c3c971bf9bacd9752ce19e4403dd3ead0bd64ff3e038195e4f1dcf3d00e6c902caa084a9a383c5f2f26f661539","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
