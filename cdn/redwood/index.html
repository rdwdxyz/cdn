<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"160aea0052d4d19eccff574febae3004d1658a5cd72d6296394e70fd22bb1bf286a59a8276ed97a1a28948c52880c27eda50aba33af2db9eb51ebaaccef3446e753c96c7b7d1770849b51fdad16b739d8afc76337b63b8a179ac330b61bc286ca53d70de0feb277ef829fa559504a384bdc1d12736dfb62d066ed19145b54a06f00078c922744880ea01ff177940e55a61caa35f508f010b62c37d1458e4f733168f169f1544587d1c79c25baeb2622a4424475cb049fbe62fb246ab31e06f951f77d9e27ae6e1d145d17491f684ad8d45e4154fa5b360d213dd6403ada43e6b4b4b12e38462420588dc5c9f07963bbce15672d8936214423eba6bd6b489ebf032a98c895d5161cc12caaa5c4748e791296a37ed919fefb8ed56c0e60b5057f0b01aae0a6a5fcd0b81d8a404a0ccbcdf05abc7172d6a7f73b61a2688285d4b87b912641fe90f6ef75a4368c7b4ad8ffa51099f6a43863824c7bea349a19be66eff35dcd80398adde6d0e511e054a15fc2477c53ffba0f016098ef5c5b6e0b35e6f0b62fb98033342ea6cb605803102c2911057406a1cb68ba0895467e2850c08b790149b6668f91e8cfa2d154e25d5a8e9a3fd945ba9471c49d5c399d93eb72f2e911b88f0a744a89f2ba7e67032f79d39f8f914c03eb51f919a69bc6d4e9465b9a7f4be27a47e059ee03ec8effceae3f07f53a8988385942f23c49f05007cc433cfab831017bedd7c0b5fcd8dab04466276cf4950997670e24d5083ad6f6f16f110834e35e9a7a563483597f6f938f0c1283b396daf9fd442d93a2be94542baa0425da01ec2d30ae42b726459759954095adf72d8460239676dfa37147e77b66ae6aafad4be3a0475c28c2e9b0c50442e8dc57da3a8c16f5dbe14305e538b6a9d5dd9d28ca423a4164e8515d89ca1d0e1ced505cae9715c3381b2d20e71367b66cda63b646ad88b192af21b3a7dd28cca5b89c39b6658f9110a637a7a37d84bc4882abe92a8c2cca35b8f706435eaf49f952b9ea929fec781b6652e3d6582e078d7757b28f1a23b44718d39ac2b3ab8d9f67d4b09e9a4ee7e0fe3fcf03d1928f612c5d4f3a697f635c384d146e76acb6f4643866f943c5f7e7d4e66ec310d5eb96a89e2a49cae39e836c1ddd5a029f46f381c9b2020aede04b16671ac5a4c4a3003cb01efafd15a09cf2fa6d7d21d1b969533bcb9eac8a9f5980ec1abf13f58379a9e4472d498d37bb5ffb614f156a446e60752e1b406d6ab774ffdd194fb182e5eb2498563d98b3946338ad8d834bfa525536715c4e45dd0ead23c08a66a15a79c0c936215b5d5113287ba9af9bd71074f82904e4323a452e0c0a6c935ac313b4e9a7b1647ed3708017c1a872e224d3783591cebffbdc861a155859d59a5db3872584af6ad7f3f47768eda87f15d6347d3e6e500bf7570e33a207f0606fe46a0a02637be60d5455a0c1d7479a6167aab0dfcb23389e501d1aaaa911cad6fa6c932eafcea86a3511e0dc5f9e9a4ccd150d43f1af9704dc62c988f957739d66fdac9780f0f09dd75a6d16d7baada68ca19cda3ad336cfc07fc9d30aef770fb2ca4124a56417938d41f0b4abd7452b2b0adb8af7999da7f6d3ad8fb454d54afb141c74206102731143d38c9446342c14a1cda6a0bc9d91cdfe75cd5be6fbe300a63debedfd8956a42c56e188fafd14128a4261871d9ee66e591a8bbcce40d05367d01e0c4b1fb7a9fe336bc2fb31882d597cb14510a6f78d07d33a782e859557b13f9666aee30909b753d5d3b419cbc01c8a95c5be27e29b895540ac6af6ca52a9df51aab9938473db03ef8e6716296550253901e6245f46026585172efb7c19a4b1f7b343f8dfc0905b5ccbedc8080e727d51fa16a28149aa825c8c1b2b02c8ce13b0bf1ec3a927b15a014ba7e83a0f6fac5a74c2acbedebea938bdef43731fb133e1b44708d8572de5b3acc12afd102521cd845f4a5b692f566fd29140cb4216f508a85c8271bcd1c61b1714cd720720dba0637fb0b16e717318f55942748461fc8a402628a7d7baed99c180f13d24bb505c4989f6930af4b97e0061349dd74bade0207c15b21246b2026cf431a28cd7e872b9f92d5cab301bab4e9c94e689462499d6fd7e78794c0a1ac1cce5c091ab2633a63a7ee407ecfde2e55e3f3d5222dfae24ee0b4024503875c8e07fc8dba840eb8f9ec452d58ed4dbf845d3a124406714edb13e7bbfaeab102b95bb0833784f1accef2dbfe403ac9498f82df971ec7bcb46cc2d7bcab0b278e156234e7910c62ac5c524557602a4b1d6af31a49b1316b7f0ed5076ca26b25e12c9ec558d399c78ed970efcf4193450f24e1c00b0b78644e4d8e82d626f81a632017a21a7650370b1d7c6b52ace7dddfd1a8da459d470fd7ae8b028694c78f59423af23ff189fba5efc01f5d2cd79b493f0c2fe6140c7a5badd5af4689302a3d2218564ba7f40399d49de4d9708dc9b563e6440510a00f590b1c7a26f23b366090985315b25c57b265b207a091c2fb783c9b09790828b383f3c572c92fe9636d5d09ef0a08a4c7e01e460b94595d62a88713d0f2ce51737d33052246f26ee2f9887d85ea3d4f8c6b8b625b191cf30caf2c9540569a1386432b15054c3d096f5f9d3e475503932a5fe86d39e0f6433289354f63745eaa4b527f67d1f1c445ddca3751c139b96a3c1c9330959242edd601ded47ef00060208e06371b04ba86fa7c3fd5b1c34c2197cb7d36b66b5cece1bde9de7c06c6993807d47f4538fb5b9ec4e322aae076ce6b257c06409e60efaf1aaf004b30a7fed645410b5013efeb3bedaeb701c52ac2e56ae1b3fd7142a250704a22a684ea95f5d904761d499d901edbb991fdff4341f7875b93e1e7e0e86aea0a3a30d7afa8a1d364577f93a77fe0116c023db07a347608f5d31780e4eb4ed4d3a0c8edc5b7b762b078cf4f56f9bf4fcc3ea5db08d0408eaeda3158e3b8efed6abb7fb6f35684a3b623bae56d131347fe8ea92755bff459c44f7da0d553e30e6ff814b8593d5f80f7839128c35cee8641f851df779bd5287001b853de4b13964120ed75723181dfca0df9c5ee80a853fe2c51dddab3b9348c796cb474952cd40cf47b3ed36f13b454113171d4c461c73f9a1b31d1e5c0c0135678bb73ed91216536c5caf1c582bebc286fd638b0a835f780bf091d6b9003c38973ec1773a1e420577426db62a478455bfccdfe95405fc84078c3b2a34bd415af13e432b803c5ce4a3a928710f13c6fa6abc01b07fb6e5a9bdc5e64567048601396ae101beddf70fbca35e56456039d187a5c239d284fe63d7538ee8641fd45e64ffd2bf811156c04440cf6d017c21ebde32f271f8cf4b38d9fadb3e8a740fa1fc792137e13f0c66e3f0e58af1ea034d6d1d3949c57b46d17815e1f3f1e85b012360f8aa56e1eabb9307be8417c57c07855132b5e1001504d250f7b375fc8abf2d27ca1c9754cae0893bf76703ea6d57de062346484642062a82201374236b8cc2d36bf88a4e9565d94d2124ccf7ac9354bfac5ecf9406d0be5c40312a59b4531613c657f48be781afa6911f613d2674bc8c478324bac7e90f97c3aa1defb14362ab1c64446b090e5c081818fa0312d7830c6e749b33e62247740a906b6f99316533af29329f6d224463c2d73a85971d551de5426fdb908ccf613d4897f75f706d8156389f702986d279c68ba4eea3d6cb9d3823fb00c0b5772c73ab8df1462a170dcbf99e29b57ac98651df8c392d9eb7af3073579de998e668d87b50e57898c86b7c1f23b1f06fdb9ba9780f064f9662e756e00b731cdc3ee799ddeab48409e28e81ab791f7f65e5a9672df1928102106d78738b31f9eb2c902c7ef2e511e7935f1a2f6ef9012b5621b6320ca3a87f06f4a1bce032e35f4982e2b9ccb16237a1acf4ccbbb9968394cc2c5174bc936caeedebdf01ce4795611269f0a0855359b7e524178992c2394e95a4d6380e25377ab30b39ea6157e70c3c5db25cbf6408fbb83040186ecf36943d8edc2f3a6a4a95787fd8f9085de37b153de051ffd3e79c9e70b6ceffcbaacb5b90126389cdea00b716d8e1fcdf1af53f58b9df46a7f70429c24a3d1703cdbb51586ba086195a3619f54a3e2e06dc6ba711068efe1c52a0c966b853189fcb4afbc938c7e7790761a730cb5640fedee9d331ce30004ad24bb35be324e8e0f1ee5ec753bfe1d3c18d22b16edfbfd29baee22fadc5a3931dd9e478dbf7d771e34f42df1dc56cae000a396a882e4ee1bf2c7f8cd3f582344309e90a005cfa2df8ed99f794ca8ea36f83281dbcafb30d7cbb9f075d0869c6fa10fcafc34cee1be26727ea10d37d248c245538d7c62f1b97688b4ea11ad01eace4248cb7adff497943d291b905ef20e6f8ec4937de11db50ad0a15004454c5f6e3d0210434f1a0ab69d3693356356158ce37e49ac06e94a0cf5d6a432d8a90c5b1b1c0d60749923e5958055666f87ed97b0827585a273e37732841c672d88223110a1835544fb7b5816607e48fb45b933abc89ff853c6de95023fcbdef9c673ec304d143e06fc9ace4e276ffe486f485345a3af12b0f26556ea42f0f4bc8d1994c457f2e6fdc56630340441a66a2cde756ed65f760ec31a687e496010e605cd6dd66478b70ad10913f27a4b145839518c0d4cdc2aca7407601d2e49fa87bfbdc7074b90121aab9cda8a08ad81b6d969393d2d2b7d5ba67df41eb1fc59ff1f24b460e545e406e9d9f1827a85e2f466afb1e5d049c137396fee0c69d03cb57a0d8be84e0d06e2e95eedf779cccf09c45a1110ebbab7cb6d919490fd4c548e60ed187060b78bba69ea40976b9920241021c9998f4fa76d2cdf1bb20917ed37875b429f50ecbeaa0eea3a896cde3d9ff92d6519dba99bc47a69bda54c414610b31c1a207aa746c2ca2729db0abb7b626263b43ae75cf877eae4b5bf228808cd0ded55077e63e29377b21765aabdd36ef8d9573d7731708199a0d89e2669b249d26e03481624407639d341fbc88e5174290c4d7de7f9caa3cc90a97f96d1aca7fdbe132adbde899baf0ff87f663a9e192b58c49763e8ed686b2e9bcf6e2c54ffb3294018c9467b84f9d4e02c6ce07a70423f804e30f9a13025ab1833a68df4a925c1bf5b13e3bdfd2d656fc00b376d6660bd50fb8e3dd33b344d30c926523102abce0a2fdfeec61556a67abdac408b624c5b65da0860184313c3bc01c39a525dd7775c49c651081f29c3fc4968db8586e7fcf6cbbae9b6ebd4b27a2dac1339ca2bddb97c5efafc9c97490480c1724b2fb73cc40bb1c9e6b401e18f08f9a09c4c9cb53c0b015ed2583ca693995a78222e5c3088d41b6c2781293322fbf26be585e0b7228a56db7624e7dff2993a5efb2abdde18322397ec1b0c3d18fdc9c618d2a49863991dbf4b967aeafbfbd4a0f1ca3ba939ccf5fdcbf3dd85cf3a7002857c47e50dc4c4b2997b04e23ded6268e8f4bad8e6c1d1a569d885fab62fc56c0af77dc74066717642769798da17c920a01befede07a9b5ddcb86b4f7d1f741cbf65b527fb825ef45ad6cc992768a6b20de61b477ecc12a7645fb60dfe8ea2d5ff2a2f158084340a703b88f5103d15a810ab66a66b48a29d57b3302cfc5128d4499db8a875e9a170393457851872700cdf94784fe82fa398baf43ff574c5d27ef70d1cf4b38297512690bf4daec69b7a6c666e6ae6fb9c855bb849490813f36f13dcab448715d67e912ac011f1f92dfb9a2181039e29c89213d42c8586de1e892c2480a5bd3020f875336d04a7375f4d53b4ff6cfd7be92b66cbc32a37040a43acde7a11d5a8bb6286e5ebef305801ce2e82704bdb856094a3a8b89227c1a169e63a6a94ebb39b58bfd78abaad58b94710a7553cc645cea6d795325aac1e823d4ec7433209652baacce0c23c3ffab390e96ad510fc2ba30dea70de84922ce4f4db322c052fb23e053d03fbcf96a0ef4da3a8adb46abea0d56b29e304b83a025ed89f15ce8eae1f8a250b51c5b695f8343d230e4178c77b333bf80f33656c85d70d4c4e1545fccfe4444f2cc74d92e60d4162ca10da7cf85c05884cb5d8d944830cbbdca057d0cd0fcecbc849afb3ed781adbbaec177d0a04678d7d1f6c87668be87921417487e0c92469e343fd752d1eb538caeb4b7116e844879b3ec2475c952d111aa945e9cc38322b5670b94d60fbd9f8cff03d720fd392759529b7934ece85f369433a2f3aa83473b452a816bbf0388f702a44a33f0c7c089a27c6e884f66fb168825672e2a33aad03ce0d9638f986f5179fdc2fa2a443fc9eb2601b7147eb0c97278324dc57606006dc4b8113f0492dd64845f344a364f9fc2b2ac71b90083484bc018420eccbf8595494cedfdfd47a7a2625e14f905b47817261faad4d0d91daacb1e72861ae82eb358a2e4e47d0a55c545e5527189e5290834ed25acd3ed1fb352197cac4685a86d3dcc1972459d872bfa91a9674bb4fd2ab9735516604ee949617ad9f369dbf389796cbc3f78b78b597f371a53274f99449e5e3e61108dae9f60b72b9240ceeeed7cb85f3601bb8fd478abcccabd43bac0f6d79e8bd645f1cb9bba3082fffaaca175f49f40a77be10c9eb4bc7dc215e488a519eb0a564203848c487233024cafb6cac9841d25407419925f00d9990770c9605dd956209373c37cb9bf96c3935b2142bad3ae7ad16db274497da3f8d966a471ce2ed39c7bc6ef09f8868e2c2709d06afef746081c6615f47d15fda7b2cd81180bea060fbb147673ef22e4595977cbead895dbba89ffea54e4a14d813235c1545b778e3e5ae2c54efe8159149f112403047a13d17e115935a6584d3db922af27b6f74d1a63872e4819e1a42a8204a8c5635d5a60a80f128b4ab31d88d8f3004633a0abee14b77623b0e56e3d8c01f5f138cb3f07f457adcb325832403f43165bb9793dc839c899b352c7e02e641567ec643426d178a9eeabf4f7afd358cc44410bab3131b31fa37cb2fe4637bb17eb50ffc828af4810aacaa9e458ad92e9410c38a8856014e9cf97ec58b01744c599e9f6310f498401be10985ebadc992ebdeacb56f408bff3bcfd05483b2905b8990d4202ee108259720688f7fe817a2685092f26e487c2b96450872dad0304e8016de15ef4de6502ccd9c8cf67a6eab1517621aa97921d90e242fe50a37ef1ac5bb34aec55e3ee06c830f7502cbbd09d829fe9db3a0033b99c8fe461fd9376596f9a91c3f895e93919d8f18f535f7dfeaab6f3a69f9ea560de18d8bcec134eb53cb038b6853152a1d760e6ca6f61b08bc312494771bcc4eb5027ea2b74767044e9b5c39ab81c9114f578b08d02013422338ed54a6e06819d12f11553512bcac10b85f8e4932e6ca973b5bf46a312d568c091328b7ade1e33ddc6ba87e7726f802a0a500ac402bf25c674bf8d3ff56c43c6282687baa2840ca98942e56f0ce39a232733c04ff868310a1a5bab29d00caf9b85834c1ede2695acf63878f995e33e856a8db60046811541698f9565d54267209efdd680adc596e23793e7952a518fcd798fe13f5d7968759f9c6e98368f57fdbf7320f317278ea5176039ac5c6bd6dcd9e80689779dba0e9e5948e368ed5c8ee840db9c99fc6f83f05704a8702b7e92e614811167e811e421748d3fce41dc9ae5def5c24197109f175c39ecc417e9c5942de0cb2067b428b1ac1e1dc9465107bef1283c1ec11aab96454aa6ef8675543a100d3286a354ccad463587b88b4f851ed75a69b07b5c67b226f0a62fcea12c04b0c35727966d7a30188857560519700c99b43d94870fbce6a2071c5220a809233b49a769ca00bf545a4ac210ad4ac32aaa411659ff5fef85e233866ddf9ff3ff71505809f89b1142c130302457ef774d3df492d6039b1e7a53e8ebedf335daa174415ceada5f941457ad8f03e4d22f98cbf8c67735d65da18bcea87710980fb166162e0d8fdcdd624d1c6a8404b14f05bf85e805897a5d955e173e50aaec3310fbd8d982c73531776c97c5732c934cdf5fa0f37b710f77da34e70d07e9ec51b1cada58bde4d31645896a281887eb8d7a4af340f756da938fe4b35b1ecc384b932a52282a0d28221af050a59c54e9682bf069c8af4b9cde075643f726a3304ef70c19f6dba8a351715feee8251696298a727a493beb82c7f51c4f914d941cb1e9b3c5c78db9d1afcf0bf81214c78363a02dff6a5c02e9ccfbcb0096b1e114547c74935712cac01154b653eeeb1ecfd50295b8df0fced5a3ef6d79fb6526f11e3c1a6e11e640d454a8d644a1f24a78c0ef14e059b1bcfb52efce02ee699fc3c4e535fefb5cf4d186137bad6eef3ebc8f274e55c8bb90b018c0292e2ac2ffa908df7abc87eba99784a52f0472e1c798e80eea7895e4f67c3bf799f03b594cd7eac3d544e8c269df41944acfe2d8ff96d3207d919c656280ff56bb58b52d411561fe35d904f34badca8f77e9be036e909568b4539ad9087b29344168d2625dec3c957d3181b5fbdd843d4c5644e378175a76d41e56177b0295fc0f500f4e50d72ce06836883cce9b58387e6cf6b5e9b5d63ea644ac23a15ac565fcf3e74c5b3c560f7cb969118b4fe747cd7197ea0b31d7d69e363d881e5f4f422f5b3f04edd50ecba59099a2b90a63828f024209866645d23f4dfa7690640e8167adf10d38086a9c87411fe86786bee6fdd21851f9533270c0291a0adae8d19fbcbee63d9a8b0ac7da551d0a5f190528f823d197d0bfc7844234aed14a83cecfedefe795a5dbb752e0e4087af67a151bfbebf7d360b74ff0b706a3259c9f12296dc78aff56987ae94383792790c68f6f624d8bc9e29ba4c88cccb950eab9f15e46d4df398a095027193dfd6ccc90dec5d05594c96a6b62d6951ca80e212e4175d0b29aaa9eb81c606c339325b92c8dcd8fb6542ace59c098bd9e8d28c53cd74d820943bb78c0e5f4d1448353e8ddb765faabebc739441d155fd9c292e4708b6bb3bdb46463f4d281a0a139213d66391066cbaad1f01698fc34c13630abdab9523f6d6901aa313cb9fb34fa2c31d1d746b5b4996a6e4065019e51a0cd6e90d2222afa192e06920afef4af600633d88d211a1fb411c88dea330944e16d8156e15e2e17d40fc5735075fe4f8cb3204d18b64e00370a16d899b16f7a159a6bb5d1f4959ca9c2948b30d306088ecf8590bc8cd07c45fbc4857b8f9486fef0d0102c6b93d421ce478e97536bf06105fecaf8f0311c200a8e99c10c788fcabcc9b8b22ababfc6ae3f9a36083de444f8a62f88609f9d0f5d3381d7d98b7fe25d8adf0296d571dff4ce57cde93666664292a1d5db4a886d848ce5c978c362375a14385705e52b322ad4347bc1616a3eb9e8308c12ab5e559fc8e1b64f273e9404020e4cce5f4a7f98d0c1971f004d965be989f04f4c85a5f2c94e6dbbdb217b3200e42a5d3dc4b65420ae2428b382607628b9cb506fcbfefbf8d62c0329f81da6d05c1ccadff728ab3a65fb7df40694db722088a1ed30150a68c479a7436c1e3e49122e62eeee6d04d4b62bc21c5dfd896512579af45d3db935fe37af835e6e6c2daabd84e897ec40f65dc7839c660838e8f9c1b9a7e7b5a870541a994465ebca7734491c90abcecde5062388b35fdbca36c4318183dd86a48fe2ceed3722a969f4af09a4269fc351aff62589524d6995c167f5aa7b926e0a3eab3eba4cb9420c8313f8bd24d18240feff30c44732325cf6cd90393a9df00a2e7f7905e9a003348817bd0f503c29a48504af1f7e57e4b0aaffb6f88934f56b149cbb7d013569915283d15414f34fb882a4c261bf32b031f6f586384ccb1df171662cc21a7087999c96ac1fdb2bec600dd086b15b0df5d6809d352827a5223201beeef2ec9b0ba877db54f8a6bc6c3867df040ec5a8bb82b09382a8ed3642500aa788151c415a529db22b76437ba002489da0d66abdb96034c507b0ccf2ee20f379f2dd3f3070d8a7976349d592780d6cd4800caaa37ee0f7abd8059cf0ae82001b34b50cc9b5a51ff6bb1b48c4e7462d9e5f719b1a4b953b73dc5ae84b48a0504c8d99a802c18bad6c29c82e6432ebe6a22868016d5ba2e39ec3965fe5f3be42b08e1bab9f9a68dc0b6221cc603d44664e0904b5b9ebf35189235c87bd24f0debd73b823dd110d25d4b847e2d9d3c6680af9117fffb1637cbc1146549776a4bceb4718b8e41fb6e10dfd880de1344a4013f2d52bac761275e275cd3026c0ad9c84dece14392de560d5366f50c0e9ac9b6734c27f57a09ccded03fc48645e2ab801fceb45efbbb0be1d221ddb7be334ee5ef12d1098f8813b034293abad83326335de28d503e6ac270057087531f22eeb150bdaa5c992d5280c4d00b732440204b3a536fe45eee0ce0a0f077b7f7fc4e09f582908da09e7028c6145bc89bddbe9b0f4161e025488ee661e7a81c97e0663161996d310073b51e1521475921a50d1b287f325c46cf280e2f976590978f14ffe0c733d3893accea3141ca3b3bd8e8bb41f03006f0ce02970648b3bea05b53191365d46df298ec2b329102a6cf6d386585e85c56b01805b115734633404c74215dde1b3db5d76edafc392c1dd0df49699c05ef4be5de37c013fbd86a912512db70d6672dffda05cfc19ad673209d7afea30dbf45a7139685eadaef77a3369f0df4b66d2d109d29f1aa102d62d4973031de1f395811aba4f4e794b1277a9e2a7c6fdb2d0e840f751bf8b08c88665ab7a3dad4f4200f00a8d16e77249c1384b14eb9b618a632a8b35bf54d27bf6085e5425718c62f7a761845924556437204387476f0c7ba56d6019db09c16ca9932eb08d6d6121dc19d6825cdb9af6f44c7e42110ab40e14c40fcb6d2ff2b28bbafcdf3b3e81a1d264a859534b6199d37f1c519b0cfec9b7f26e2bb815105020b3e5768d84c3633f659844ad11d3c408f0f5c38e5de39f5597ec1da112303de5b9d98db96b7af17709ae130b296c23e3a3875c8711e8e8d6c7c0b4a110ff17356ea53d57f9aa0a3fab578efc8c0622b31cf46e79629270e85e9223775184dd1c14a630807415ca2e162dc51d0dee627f44e32cc9f08f7878f26f9a6be188f9456847427d7e3495766b076cce91b4aa64d864055389b7abd7ad757237ad4355c4bb31d5c952b0d3d445a73b137a758cbd835a07a36d9686fc298f3c7a5f4c913ab257c1248a1a56f29128fe6514c1433c8b9de447b6d74caec22ca1445ff11d15036ee83582cce89ed329cd578f9417509bf42ad842ea460221cf98f9532ae99bd6832ced0832c2d042be0d1a2489a8c6f001e3a6179739b85eda93add7cae8ba81fd9c9f64a80828bb126ee8828c7dca7eed928eb3c87bd15a552b2191cf82eef28c82fc6eb2857694c9afbc5b56641f94e0eac565fda5ff12104f1ada9ac73a3fd81cdb62b555bae79e2346273063e2de701d5eeadf916933943f1b2195900fb1e2787db796a1a99d7272449cbcf38624054fbe65d1ba9aa0251635af06414dc120fdf651286e32acb389d7976e4345981873ec074bbe7ac284137a1825163f3d2873d4a18b91ab53a1718890c3443e31aff26b9b9e83d37717432ee5d4fa9668c43285a49457dd70161ebd62211aa5780fc0796695bbb7b9c6ba7a1724cb1b593884869dda4db723275fae03777177b7c48a0dc274f307e826be7930d7dd25e90a14ccdb7b81f251b6236d1e84e782700c784dcd3c29651aed63b3e0cdd0f15c8e41237558dcb5e7362262c85e78a3a92c04a11c15edee6460d097a8774a85e56633ebafa5ff25132830a1f2280efe69444ee0fd18f41a5d005bbad5992292c155acfdff2a122b1928a67170541dd8e0fba94078291c24b69585f5345f5107f95284f9243f1be40a567e750a6df91439848a504b70a4c4f0c394a7cb856ec0bcbc75c6140c31ef5db6877c852869cb2e8add0bcbf9bf39a5c8a937798c5b446c5f110b38231f9c6938856cf0e2f24a3a199e71501358e2a64c6681c6b887314cf8750a9c2baa98013faadeb21f08310a11304ad9fbc4a87200888fdd06edf3958c3204cfaa301b047730af8c95de14e7f9abb08303d4396539d4c92f77f93f825622b71671b16de52638fa0ee88f25009c1bc4eba064d39137caaae3b2aa42e2d57423e0d1c5528d6974cfdd2987a2e14c81f720dd74c6da155383342390367ada976c8b8e2d826e8298e2b8f0d984f5901d66b640fff58c754b2f084aca18260e88115bf7db55e0ac4862900ce762b0eec816fb6b3781ac49246230169c459d1584ac532345b96feffc40dd18ec4c1403c195b3a473bc119843139fb65de5393410185c00d4960456f31ce168581e76bcd02849b2b4e08170ab92b2e5596f54af90ff605d65e0151a5ce97ddffc4145b5e5763ac931374ed88fdfc6fa39a1f84e9dd7fd3d4fab12027cb3fe332298c326b9b62e07949742d975fa41f81fa709aefbf606a314a0518d0f71537c0d2b0e3d9769c97376c1711445e468e0d1c0993f22809a7b8b585567043230fbc2ec2e52a923471a2afc3085189a3364730435ddfbdcad76113996c9e10bd522a6cc55d3b2c9c8d7826341912acbd0e4b8432ea59b62cf39c14abe5b2c7e60979eadb91852d36c4229a618ccabd81b15d559beee50dc99d0e3e5f9a4e287840080f60c1f682ab32d1f2660cf5029269fa6512a8c71f1ad8045190b491225487f8e9e79f66f419e61c4fd760079b5d488eb7ff972e740fd66e0f04a5b9a3803b2e3a7a99aa222dc106341526c84e804ac0a76b7e94eb66509a9f7fe3dc1549aff0df18a8a9348f4b2887fd35bc698a813bf6c206b002771fb19f0d5673f1b404436f146dbd1798102c50704e727ef9d682a2f01e9e2928ac5d44eaa0fe877e5f42800b52a62bd6909bf7c81bfe29ec90ba8a9eb710613e68915e4365cdc7883885afaebecbeef6a452eced6d9d2491e1ba283f5a6b2079e486ed38a99138bd2912826b9bc3896e4ff34bf79e037a77c17947606da50c8ab254bc8ac90125b69e1953603d29900bad86496357a609b8cc8a360c45ddc21ce7df6e67d6be7f2b2020bae09d4baae4fdabff58f2c9bde9ec9dc60f5edacafcfd33eac7fa740dd48544747476569df8df5c71b0fe284d318b36da691a65f385cf4bb1c4e811dd355267d159f6350c47c116c5cdbca86377ec8224935007896782ed44adb27920a6c077ff9ae1213797213de996f19dbf1a6cdb1d88c47d4edaeeb0678e1250a06c0824b8baa411772f5b413737f7f089fe3eafeb116b57455019a758c5036440142af52f7a7ceb6bd60e00eb15e5bbc6464919d262885432126293997a9c3073655587d76c1cf330e16e62df8a72939cd525697665844cebd428143d1858e8f7c6f7153e9ed53ee110719ccdd0b4f9584c10292c24ebd92914a249f26385902404e3531b1b8ad69464033b4cab15955743f56cc4abd9010e0f5950300abbdf63de42c29818cd9d385e4d53d17d9437a88251be8e2c6d6126c55a977cfc9d14e38ec346614087f5e04d436199d2ffcd7f5792f01f423691e27e469fa15083c96d1ddc4acbced0f960983459aa9a9ce55e3ea0be36b6e2596470f64838fff181f8a0ef54dc5f654c53db6226c6750cfbe1d08468714fca22aa53fa5c70b66444ad7b6a8634db4a9e9dca4ad4a0abd3206705b96368065fe4537a8130f4bfa2a367d2f18d1a0baff71c7b82c061a536f99a7f726e0d27e81fb733a5db85e2f41f31b3344a8dc9b345b5991951d5c1a0ed56aada195433b13f9a5309d2ac6e64b2bc715cf829368776f52d6792492074a566924ed4c544f611b4104baa1507309a7ff8e9c1ec6bde75a4f0a348adc99639b3cf53fcd889d2361cc78e07aa724a74216c68ce8ba887c687aeb33418fe84127d4dbee17192e5ebddbc6f7e1dce7b954523f61a6c10c06ef55727fa6be03282a82dcc5344df9b96ef2974c3168d052e36da155b70534f18feb3125e9e704bdac10764e77656a03403c91586d149501aac92c94643264fcea3cf287cb067a009000f37f0faf158d1f4cb856e918256ba9d49c15897ac1704f912502816c61e73c991bcf87bfe2268d1479665a2096932c05a2b3a1bc0a6d31663bbb18a207a32275f53af3380a2ef2d3671d9ec9d03237e7edd577e44787cdc489a434946c4f7e709c559d7b901c34ccad873fd1b83b0b52ef92f4282851df62bead59a9a696bcc753035ebb0f03da8d95a5926d84c03bd62e482b87592c2bbfd6eeea5efbf4c57702f5775048484d9eca47b7ddcfc40c8caebe7e48d1e5cd6c2b2f0a68e1be75717489a7f6b252cd51fa6eefce97edb7203533333d65fdded5c9ccef69591b7885f7ae98feb78533db70e833dd37988fb60bb9545346cb6aba9082aeea1380fcad2c96c4229f36c8bef88f73d1b519bfcf26260977078ad896dbda3bfcca4e87975e9ecc14b3186249d8064372e31ec7fc6e80a28a6a7bc0f1caf8b328c294e2984283732da266b42c27bbd28c225736fe6827a22ca2292638d5ef59f98035791d66d1541dc3c0b02b7d31c5efcc1ec3b16e55a2213a22166a3bcba089a3dcc871209cc2361341d43d8ee55da8b32a83a36ae5c850f0d9a47fa3c2ffb072fb19fdc608d066464ada803aa61e4e857a93f5bfdc458e09f64d659f9ed777bcc05fdf3bf3478cf3f62050c73ff6b47e0711e9537ddfca1e23cd3c20d998cb13d152abc232fc3092ffcf19204b88c3d2eb497e6f365dc8910a419eb2b91c390314cef541faaa7cd100208904d627979221801cbcf3edb8c954b3e3683c5f72d02f7bd180fe284e10655ef8bb41e27a54e8b9055a5e05dab7ac718646e372375b9761fe503484e3557681b3b3a473b462fc427e9caeb3e9bfe89737aee9d4293a40515b049a2d328dff11da2fbb8b34a63ff49b63cf1fa9430820c494810dbd6d972bf09ec6cd2cc7b01d13d3977370c82f1201c13f89c18040e4c9109044ef3ff2c1320c76acb558c228d1a523000f6e02665f9f4b824a139426a786e8aaf7b60c8bd3467485fc46bd29258bfa9a1b1434fa5a3e25fcfa79c6fae10cd059dea491d0905f1060695f353ffab2d32683d18","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
