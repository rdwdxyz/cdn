<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71aaf28f280436350f4102a22e76760c798f3912b363ac41ceccfdcf821bc63486eb21e3d67f92b796fea7d777b05f3038a636d7db727e5b19f8ba030faa0a783a7824b738d8495f0d6598474e6d4c621e81ba6638a0a80a4d9b172a082edad7eb48a9c64f36f93f07bfa7b31b1a7d5be35f22b2c79762af2f418d6687682bc8655bf9b4d9e4fdebafb39e950365fa0836e68375da4f68efa2938540e72b321f8876bcc88f06966a4dbca2e209546522f26a963a5dd3563fb8ae9bc72ae353e50b160c854340d10aee63313d6e717b7577de8603cd1ec359a45490dcefe9b84474aaf3804948c9db9ebf1d201c9f85efa529b6ae89f7c5a5fb91d7c81e851fbf79979eebad245ac9b0ac4ac1767c546b8fd092a773c37bfe960c33e6c0de2cda511a754e97fd9927dcbe18c7019e043542599a5d50e2914b326fbea22fff7bbd5de77b2fd7a34e15d0c8ac1eaf3e4d489c8eb406f77e499c28ead725ba8d1d21bc95e305b2e7c3225e2c263734c87e576e85558402ff60a4e7ab33335ce11d8ddeb2262ed81cdf5a505b0845e5494fa22b8f3437ced19f49a1af9618afd0fcddbd32f98e83f5048416d4e49088277eb148f53a6a26575f45b936083303ecc85a347b59c054683dba1378d80c0efe4e16d77d6bc220a2a8b821cb66bb1925401eaa5f5834c31b491a8bc20bcb815b500ee17dae057f5ccc68c60c5e620103a04539d9cdf3b0762251d7aa08d415d21bdee0dc3a9d4c6af60e82af8b825b500c2aac2eb9c6e7ec7bab118249d5fd3cf57d031e6be6a16e042d7d5823722b07924e8c57a1ceb512d65e2187ade8e4d98c8f33c13e1073c0468cb95011d5447cdd3e09abd5c32976d6886646d7d219ccc93f0a48431606f54c48276c042b5185880ac44f1288dfb764a3bd869124c8b6f207adb5e9602f1c87d4116c7bbd1380d3ddf447be5ef8bede92228f79d470d696facd44f4f287c37284ce3977df0be9a60631546b19e378f44b0dc9fca59decc81ab210e6876a1dcbe1cee3f15311f2a062906476a3242e449038e9d50c6d3b95aa7e8a39ed7b204b7ddc272446e022768b79913bd3c92ca97b88ee56db1f7ce7b7f0c00041ed78f1bf44f3a2112202f31e92b05fb010fa73e0446852f34f5ef0536e6f6f552125203e122365f96ee4d6dc512ca43d8ca37d0d2ba12afbc942e7d17db719aa7d49384895d34e9df8b1d845e576818cea555ffb1bfae5fa4b9a3ae5322f197b481a19a1245b424576ce47da72186cd6b3a11662321f4d2d2d9f004b45930f5a6cb4d414d9dbc95ea984eac4bf69383c0f7a20964a393c05f4d6244b76f3c2e09cee81cd9eec017116b5c1f64c500278c14795e007f9978be2ab807b48eaf5948dbb872d07c46f67a42bb5ef98413dba6b009f0e2fb83d83509984a230e6371ff5a0ebecb78cb11370b6634d7749f0921c2f9c801be80d2f086b034970fc5eba9aee64a5757cdce0d95113c64d6b4ce68953f1bdfe66448ee5c3183bbd84b3d1cd405d8314b1493ab5fb369c74b50c70fe41d6afa88a4035c542f6d58ae3f8a4acafcecd024bff81de43c05583625b8e7649435e04faf8b144f8b4cb7ccd6aa0fcf1601c31ed906ed0c9e1814f7df4cfcd6b0a5689ee914f74883bc44f23d3f9958c779af6734970829322958f96595462da96af0d2bb79c3a493fbb2e127387317cca782649b39630bd7dd2a891f8b094a9d7e45c6779e54575438ae6eae5551c0738a8ac0fc537a62b88e1bfb2261237a752550f57b5d05a7d29e7591ae0043fdbc132722c261277744de712b5af38ae8fbe65a7d6a322019f573d6dbd4ae4bf682958c8a908718c8f084029ca0ead69e295ae997d201495b8e3e0a51e3f31a5358adf549aeec0d8d62e04b4373df1fc2b73fa4996eb88b542203740d1e488201da3f79727baf772d770e20b3f57fce07f6ee70ee8a556ff14279dff5dd4d1d9a0eef8929d36a6c2627a5be1e1f3fe18ed0e911a47789ef040042d35c553a0bffc6fbcfea2cb13a8a153471024a5777104fb92b784f23c0192d0eeae81b6fc999bb130cc19ab5e4605922f2dae2d4caf9e1ff05b6504161e327d3d453a7a5ccf3d7550755fc638f93ddde3aed1979c7d3563285c6ef7486d5a5c86cab2bdcca40e602cd9f36b88a05aad08a2ba4f88e0780ef58b4c8c23b71d7263cc1f2c23fe94379080b5b59bc85d9a268f5c6393b61a759acdcda5e623b2b2d18dff424a54481dc097aa43c6c90e3f229a92a4536dbec515325479e4805a346d93edfdd654b52761053a39f1dd2537f27ab4fd921a0f62c62690752103484b3c5edc899fc1aad39fcff4e0b0be51b172ec8120cd3eb51b4a14a097470d54a6e944f2a6efe5710c4ccd314c30f2c70e1e052b58649e50bc564e6eb3fb4bfed48c48e8da7c29fc0143512828be312e98b1663738ba8bcc88fc07d11a903f4533c409db1f297fb06ed409d0442a154f091829b6d89f7bbf40dbe0ec105808dfb134187bac42af44797687d0fbd76ddf35df7dce1193b241ffad2d10bec2f311d02870016b025d3d4069cfd60cd74ffc3a216e81f0ea3fd69704f4a458bb1671352fda9ceb9abd8e82e892384da0e922bb8d5dcef39e4b2bbc887c1d8aa706e6495ef691b58fd1f8562f1411b19da77c9b67db41bbb4e68337d621e8b3bcd4feb3ff20a494667b132c75464841231625dc3e9493413f665235f8a9e57cc24b49530305279a83b843bfffd67a1a55741e425e677b9499fd16a90e7285aaaaac9be3546d2707a2beba381afc011e7f133d96a96ffa5a5c4ae48585514db5d3912831ec8cbf2350233463c120f52ae42843724fa803be3263993575b9ad383dfea4bf4dfa6b9a8d5a1d351f1421b67527bb6486f47fb32970b528f086d5bc115636663bf50ce8fb9c8007ac965ff4ed8518cc4836a2da5f68f8cc5f54ae9f158bad108ba2a9bf99b6e6cc24f09abb3b8d77ca3f9d1880fa4a4fa4e943b2c7e783945173d043e1942ec3b99433a23e580b509a0184c4f21e329386875e9f98f1131fb3c2d021549ae23b9fcdb63e4c07f75beac5a4f67b00486c8098931b1070dc5a1d4c172a03cbb7df6b8133c7616e58d2c25580cf2a86ef03f89ac4d0f8440eebeca02561dc9d1c1d1d41956a8a1ac18f379f7bd2356c6249628fcc83b321595604081432555c6a5438ab9dcbcc445f7f6d94768e44a6c60b0a7960d176ec46bfcd2fcb785bfbd51056f8726bafdb93b01d101c90dcec4051d5414c5eb3629d0a766fff62b6bc51c7ace5727120cda1e44b125c65480c8d150eb8537c74dfc5b22488a70d0dd59655de50cf55dba7f44214f67c4694a4be43e7321486d00acd94ce023088396129c3f0a3de03a9f326236cc1cbd0e57145dde1391dbd118c54220a346c40597f6cfebb1aadd6ae164374ab8a9ba65660920b5619b405c066dfd3b3e88fdf707728ba2ebc0af8cec6f64ed8cbf058aee122a6d756c213da9d45356ba87505f8f15c0d6a3bf5fcd65c08949989509a375022abdeb0feacc5e5602b49521c742bb8ad1e285886e100955f15a4fd7b93594898775ebb67fc7275df7e11c08d82fef5223ffef7f2961f18f3dcef6f19ec55fbf4c7f776d03bab7c6b10582db1802905a64e1e11ef4cd9caeee51fb9467dc0dcc57fa0427ffbf1d3f08ada733bb3a940ed978b0f6e542314b102e74bba778b8056be6a3ee5a15ea8d9c12fbfe668f568e02fa083d8dbdc5e8240704b700148a25dcfb9a7531156dbf0a46103cc97b4c0c64aa537d0a0c129593b063b96d51a8a6ecaaf7026fec0ec9cd4e579aa8a5dce369b294da2a83648be742cb81fbfa59652e591b5d0a6d1d250b14b0003a1934efa9ab5c473fc484a2816703b2b4c5d8ec7bda9ee802f48df3b59887181304a0ce0ec1a6b7baa4454fb48cae4f53f9784c0d2b4d0d6b2eee8be7df535f44dabd1a6ee1b69c215d0098055ecd9be03e6c8bd5c6112b22ff4c7b35327a18f0ee026fd2c6d957d570c72da794ccd3aaf6cef505a784de80ecc9966ca28202e898f2d45f2f423934389fb019e0bb741c6825e43952b1e1f84365a6f707a8d7db7686829e11271aeb357ef1ad4b4b7bf3f3ce3dfa24f224e1bc9258604425c6f2ef4b13c8a99d380525b50c6f831023c7db597f7f5d9dd575db804b5139384e6e5135e96532447f9a548001a9e9a0f4c66f900412416b1a9100da384cfa5dbe876ec0c8955c955de2f886501ad94447e0f98770c434e93a2e91dbd189ed61b3fa72ca2f14d34dc48062f35f5eb1235ec05d5bdd07f9db968e9f6b2ab3d7f6f56a92d2b08949fcd3faa06fba8af31c4e478cbe6be412b7a4a572ac559b800bf6be5e6fcbd55d9d791513cb7c72ec31caaba6441166b8bb3cd2b9eeea05fdadfbdaeec6bac223d83f4965294f483cf68f5ab923ac7e3b24f8151b4abd625080d919c7bf2b2d710ea1b1c421293b44bd0c2d37a17dcc71eb5be98b48f4bb2c7e98c9fdaeac036e9d8ba9e97e302e9dece6a68326f625abc529635f49e0138fa7ceacdb89f8f3aca89dc65add38978d21f415241164cc4b9be772142bd62eb657702bf661fbb1b66ab8401f8fae1e8a9d91cabef9efbf89e58e759ef54e1f762bd4cf5f89cf51b779ad698e5b8444b43283c374c23ea60e5e23c74b899f8b37a435ce0942a2141f3d1154a2d7c4326981c754b150803f508225840755ea821fb78f1638b1149d759d36b634ab3f979bb978ce3ee175e9a828c832d764e5730b7242366a441bacbc10a2f18fca06398dadf8940aebe2549ff1150a92d0a3b9ae199abced63cbbbc4743974a59e280123835a75f2b7eb76d90a28893be94192d646cbd907ee30ccbc7691e8369ef0f86a0f75091ff09acf68df2471661fd7ad824117668f0fbef2971ad24a0986bc3347c8401a147ba4e3fa2e6e121461b423f8d8ce04cff0974d716b679f7b35eb9f3a3b9191784ce0c54f52830be5fd088348d1af553ff8d1b0ce1a7279b59ef1fc3aec424d4e854325bb15b7de66412aa821d2fa11709f9f7e0d00395921f2423313bf6bef7f135486ddda9456b7cb53feff177aa5b75a46305460302756ff39692f9ea9f944154d761eb97a61870433913b0c318c4886b57980298ed1fe29a0db47318206ecc89a21d7cdbf3028784c4d5528e81a07201d783e103e25dc3d1bd4b0a4e35e04e53e05575bc107349f170e6d425262419efc7dfd062a589faee88123e7946685d10fa422dbdbd275dc81719dee772f858ba5b1f88d01162c79458498724750de11212363bbd6fc8a886ed1ad49c1f48f2db337c99e4141f3facaba36f40b82eca65c8cf9d607456950bbd6f6168b4caf0341990b6ed81edd8c61f19ac71f0d6e79f474e0f54edeb2673544a2b2ba5bca50bd7b6b6aa54e7fb761648df4dfb878a906e3bde12dbc7446bc72a7560fb6c5184bc451b0669cda44f6d5e225fcabe2775589c03a3d36140a1b2c02eed581609423be5a18482a9327d38b70889e422b6e1ed4f99c67ef6936977a933491c66f333c0d00aeacd5f3841bb387ac38a89726839b80a9d0b874c23fba7a7c13915b84f93fc17a8f05595dc3dae43072017b3c56d1d4a4ff222a983a013858dc61f91f9492537b5d8e1a0dff5935f19f6c8b40aca2c3dad35287d449dfeb5244358ad95f0b64ae32506cd08be6f7ffa7a96b6d1eb8013fb56adbc3fe8e48661ffdcbd6a95a4aca240eea6e888753c38e4366975ce9cbf7611fd7d17d8d617165592b4db63d1678b240ca55620726c988bd129560e4e86b683663febdbfc8b45e1a2c47b569d10efd872afa0fad0f923455642f4fc52342eadf5dc502c953b7f30325909098721bc5be055a817db4040c4779c74fceed6f9c523633cede845705dbf0c30e185d3bded58882189120b88eba9271c0a318750d90f97d7e219a8c796534084e1ab113cc65cd8adc0b1fd6f8e9edc94eba40b85117cc8dee4d82f76e55c2c590cf5ffcc5904c5605baf01db9ac48fa279157d3d8e9eecdcce879367efbf5a81db75460daf9ae564ae817efa1385d6a0fa2b5df8186cbe9ac5dc44cb9c441fb504768a329e631abd002c6fa8ed2ab807bcccaf070ba3542c5ccaea40b0891d3cedea0b7d3da3555a63ef9b23f5c5707205cf89a3ca44e5cb35b9e1bff5e83530051a360e2629c6bce437cdff516cecfd3a0b9e3f7b5e15c09d4915f7c9f61d04d5f58b2801533a16ee39d36809bdb958717962ae6e0b92b5b1cba6bf0cc5555a70013dfd3f395584c84a209f52a7b2e15449cc147c5ee3697a9cf79f7e9dfd95506f352fa2a55141b803fc1522520cf1759f69c1e03106e781597eec3c61de4f2a009ff6a02718dcb55b7bacb08cab671632873d59a9b7770937bc9a0496990b6d09460c104800c0471f1e97a6e7dd70496efaebd1c0615ea0fe4eb3c1cb87ba10630bb2b1e968f398005b936ddc7c933f27172ef089a516393ed2eddcb41a88f087c33186fa988e88ad2a3d29a3a474eb0914c4bf6838bccdb58b8f25dbd41821b2fbf6d2f3d29446f64726ba746ba2b44f93c31c789ab7758886a15cc54af1cb7626104beb97bbf5af6d1a74e7662bcc26e360841fd287a4e2a10be394c751b4bbe08a9c543ac5499f33c2c9fd531dfb239a221a26f7a24ccbf3571102742ef656e31d0594a257c4ef6ccdc7eebcc4b41f98060cd149b4fd71cbb4d67ca3be3af4b72ddab68f5e4ea5f5df6d3ca11692eb3b5e0791eea6bc0e9eba57d049ef047b8a67a566c135e77145b33a05a8b865e8c3c44caba8f7750922596f9a6f420e47752aba733cc2314bfd430016e870d72c12525cec28229b30cd73071e1453a5f99e17d0c7f89f8145358c68616e19d2abaebecd28a0624ff787fec8d432dc7223a771d8f5eaac7c274f90f9e808010625a96f559cbadc30507e8aaab9b0177d925a6d156d1645ecc52234fade5d1f3fd160ab96d0a882bd4fa61fdbeb4928c04430eea70ed8985a215d51abbf58da9b0fe8c36ac5bdb2313e84dbbb8e8981f03ca923bfd63deab6fea346fe5af7ba9ab3a29f1ff7be5cf9a949c32c80ddb3b8c2401719be86492b98342f32e278a7ff2922685429936cf2e8af1955323fc234614c4572c269da2ba92ba49c89feaccbc5ed59314a690470ac3e89cc096a37f86c4bf2be3392d6ec66f9711c84acac43dd087f368595faaf7ff3051e6e7479f7d1799b6cdc15ee1f1a52571047f591f69df3218c92db51b5055e899ade7cf6e97db2bf0c936bf19a1dd11fff9b16bf03b9bbdeb927de7b6c34228ca6d7cceec9a53e96d09a014fa7da398f6bca2166fcecba0570622df61a9b43bcba2a180c1843189b17a376121306635fb311a7a7abaeff58472d3c9eccc253dee8c9266e9d2e4e205ff5da7bfa739e2e5ef2fa76f1f2543c69cce83921e6f992898ac3eeee52bb8ccf7bddc47c1d62bf2f5a0e6f3567cb8e6ffd21021e3316211733d7017116615aa7aa799205bf5ce2c201bd19fea95c5efc3cbaf98df4624d65ebc015570aae16df55492381551b54846c596b09dfbf5999849a4cfaf0b1539ba4b537c064b7f1ea043f7fac2420734df22730f7755146b0f846b61ed2a4e4762b7aa015879f1db7e32dd020a47b0f572695a35caa02e5311728a2224e1e64834e0a91a1bc598ba1c9a7522b6667a44817b7a8c644fb4333746992e750c9de827cc1b56d7a6c96d33180589ac415ebd7215ec91bac0d87fb4e3437950390d7cc9267f4c0e8d90077f4543bbaf36b8f6a79b6edcef1cbb8bebef71696a3ac041b376c391a9ca30a6bd1e54ead09279800095e1fd66ad74c3b2b6cddb87f302dab02bc19558796277093e4a877a12a550996b8ec0002afdaf606908ec7088a4e3fcbf74fffce2e382d826b47224301286629de9c812e726df93b7dfc8cf8a6b4217fbd363d1de926596b5437f253ae1ae75e1028ccf0c8a43a50fe87818d4c7932c63442f0af7f251f4521b51c7b5fbeb8822c3db609718bff86ce97dc9b07e1948d435d4d27708452624427c7221c9463e17a76a7d62c04e8c5b25769509917240633ee21411bfefa5019389c3fc99ae505fd0408fa6840828129e4bcd9dc7daf5bb0a6905eaef7265838124d846a474d2c4ee649ec9e6a605c99605ffcce5cc261b95441ebb4b7c036f0e6a6d1225ff462d463b525884ee28b4cf7e21482db77f5f6ab1c4abe3010eb039a7e3033a50897215dbe4cb2960fa539637d6eb826aac7c26b46acb1df136f1f3f4c4f57452dc84a2ce0285fb00873157f5c9ebfc726905fa54c2bc02c4bb615e18b1ad3bde789accffd44d3990b8a8faed4075e2318998d257bb458b15f293166845cf3ce3194937e12a9444d6c6ac8fa0ca0a3720ed3ce97bb154c439f633beeee2deaff66dc95e6808091b9e22ca5468e98ff5e0754da9b9cba37c126d06dd6a0d273190e5f51b39d734034d03347682de4f5b92a0333e758018b6e435a9761eb984f6f0760d958d79eacab149cb939c94ba5b586afcf54b3687f459f407a626e2fdc463a9c4e429ec0c1403b20113fae691580a7747e1d38bbdea094434e0fae9c59921bd4fbd45589ca53a2d6be73c645db66847666d267ad0345cdd8dd6de25404cdd3b347f388c80d4f543da3f3646670b7e41c1bb1277faded3dee7e7dac186e85a06750f22d148f152f352e7cbd8ee4e0894b93a34ba49bf655c437bd855c34f313149a1aca3f1301ccb0645c0ca62fff6d5bf3ac8829952aa2842ea2b7e9db1372c6d6edde52924c955764a923e6d2b417e3909743d42b02b15841978a2267865776898e3d6e3c192bdfb3123f5252b7150174e6a402a4ff85e9d2b47e068a69f5e7fe7bd7f9a751e85023972733e53ef75d5c05fa5ecd0e77134b0d13df9ec4958a9c8ab7abb141a4beaf04e2366d417651cc18b90f6361f5893702e9011e2d3dad93b8a6d524f812327d990fc85f67916ca5d27213f425c498cb36697ab43acfa0bc6fa7d6569957f9567ae319b00faa23c678fdfa40694664952712874b50b6bf6e351a63afaccb235fcaa92d02dadbb53b5586d49e52a3bc92059b75eee0423f62bf6ff709ec22bfea8f7225051151e3712f513274e1fe2d6269fe086297983a37bd3c2543153d49f2e32ab684758ad27bab65ef32e7efcb01a4d212b82c8cc117a92b00122d5ca0b2eca426025052c34d1d4664043f8b7ac7d322148f26c45e2b907d6767f83ee81a115d7fd58b930952783bca5c2ca163043c6a36e52550e95acb00fc751527d2429761fa64469059b3d1c37a4821354eb468ec724e223f3dab01e62bcbbdcbbbe4643893c0bc962d420e0c25683d8e1ca948b17dae502635adaf72f617b0ff2cf843e7fc16d1b7e773bc595da56daff4f805f1a8f862bbbb5d86aeaad46d663312aec3fbfd49dbaba486c10580a064336b9e82cd1a7a53721de34c9329b452baf51061ce0d707905c7104e93ee9c6c3a15077e9d47be81ca2e6ab6e2dda6a3d46e801c2b87da99a15ca463a73828561ba283237bbc97af444dfe23b74ac98034d52c3637d987714bbde66eb1bf2d443b626698e99c948ca5e415641ced2d7721f49af0f59d11a93cd7a16b10805936d10eba3be65631a6d497f6b38f3b26e2c4e05a5cdb8f27f9d97ea6bc77f1fb9615b6dcb0da8b737f415e1106af93833d1b18179794ddf696fb1c4c73ebabfcd8e6c244a2e0f4cb96b458feadfe90ce6746b91632d25e5407601ec8f7e799492201a73b2f7b84013377b5bb8b0312f4c7c0637b7df9dd477d0ff2b14b8645f3c7be36409c33b3fb9c66866a7aa8ff88b56fa6de2a03aea5f418fbbe444bb691a4d5e868f91de992376b59bc39f719e78308466c47c3b2901b1474e97e97644743cb11b5f3a69ebe5ef74847719187f8bc95c313bef985723eacbef652fb6d74f964278b57893d5082955ea00b9001a6f8ffb08a3e119503b5be0d58dfae7f6ff47b02bed9d621dec0772bfe5df04b0f555b21bdfdcdc4b62b52d7d8fc0bddf5fd2ddb0dc951466baa4a72c7b23c54a47c049eee815cb194b4fb23bcd5a4567098fd58fdf2b6d0d397d7de5709c6d85d9f25f8f8ea54cf2ad5f176c921b2b2781d816813c8f76c4e7f9f57d6e51bc45bc287b302311ddcf2dad77241d1ab587cce4a0fafb8e46d1b39ca48735d170d10a5828112531c917a4b6e364570c85f732e85b359560bb61a5bf7aee52f39068a7d0610de240f6ffaa465a9f8b7b1a52911ea599b338f661dfefe46603d456303b8168535ecb8abcb28d84e36c33efbfa93c6c328732096d87fdd8f5b355aad9142e40caef3a3f313d6d60882dc558583e1b73bf59a93743e5f5ce45fdd95c6c37204c6debc96c69307a5e2577c7232c4e92d2efe8d8bc7f560292e069562dbc5e5faaa068e3086ac5303859922ea10a2bd470458cfd80e649fe7462d7f28c04d5caae084ee713b7111964b770540ae6bf4abda9a1e7240028e6e560dc7632c375d0c8fd9bbbe4847fe3b4ef57f6a5d22fe3dc456b571080b866189540a82218d56652eb68bce3476048806f25714dd3440a988b0876879e62343aa53bdd1ff0f7ad0ada9c8496922af1026132702cdcd69976ad004e6a3def061bb70b860d23e735b3e6da48f7f24d326a1bcc027f4d22d1b8d0e8406cbb92f0a13cca19685d0d8f17f483808e3c067322ac83f71cc9ce09473e2ce53f4aaf0e3c6f54243bb3c3c29bf859bddf008125d457dd6e8ebeaf30fb75b72094376e713a13b096a566cce51197107be19a96b79d4dfd83c8b75586b34d119e88595075ff826e1592618fda0b11d2599474131aa31efbe9a06b9aadf10e36d6d604e1124035ace5b7a3082c6346602456f971cd46c0726e7d077c4733cae53ad72d2554b0444620b66b141ab8ed746f9f4e05758764264f4dbdbde458c3a5d106d1ef710a4819503cb4936a7e7e0e466e2ccfaf362e17aab34433f24dfa54125565f30b8a1d3b6395f7fc1b711bfe47e30d60a8dfe851a4cc9158e5491da9e02bd16b698674e17b6f6c1626a2905ac9755622f98daaf275cc9c19f0463fdcae76b1310cc1190908c5fcd3594f9f5151d815388ffc2fb2bfa82e203895fab62122a3ab548ea4e25c47b5d10b7fedb3c3682f99b3d6a04e3e767d120fab5a870ab412bc391ff11c512ee34dc1893af65945c29849022da8979dc7c6e37d08acfdd929ff889e5d937d60fbef9cf4cc48571abdc7203420e3fc85f0baabbff6bc40a9e170955af93dbe5d0519b56c38f4d028b474437ced2d78bd4dae4c2bb8f13e4bd4c65ee4440fdc72476a6ace66b1a3d8a060cfc8cb040f41e5e228e118a6237360979ce70a3d157e020346ad45913e7f9f5eaa2c2729c777ab750140bbec90dcb1af713d71284b4b64d17cad199e6e25782aa4a4c68e81ec3e21e4e48b3e1dcc83c782f6302656fff0bb7fded52f4a53fda04f3da27412d53f24b8aad08c71d37c7a663659358ddb8d46e5153b4b6a1b1b6105b258da1c3bbd081a3e3406d006fb065eb299b64fd72e07e5e7e166c2fa362931094fde41c122a27426e8f3948953729f66b00cd4ec2ddd46f6dbdc767b89864762c45b29a4fc1edaa04041a0781062af6c8748abc23ba7e29c18f47b7b9d96ae9e4bb43374c8b63f601bff7e4847fbce4a1f128b1afdd036bc0829e24d424182fd85400ab72a884436ed96f2ca004a4fa1a3730315d1e5cfa4027728101efba9d53e62350959c18cdf2921f3a06a0abe298244d968eb94a6008382922f60bbecc0de0a3a98e30b4469c8c898aa735c478929ce4b5ea071247e2a98a54d9c4b4efa264cb0c2c5eb3f856f4da2566484ec092e11d03003db92e8b4b612badd15a46a387b863d724ad57d48ef6c4aa60933def14c49d9d24aa6dc912aa7874abca6a6330d6cbb840328b69f66c0f467577be79e59cde93a142d13c9acc8b8df39aa441bef373ba28f1b68e7a5b57a244c97827e0a193105f0914650f0073ce7c3fe0e3416591b92a815bda5947f668cf4e6e548ebf8a2000820daf2c458dbcaaf80698838b3c74bf35492571a79096c93a90f11fe992bae482f553ca3003bc975c4b71769f836043df4b9bac39878cbe277f427e4a4b6e121882ba0b5d88343e2679acd56e18cd5fd3a4a12a400a2bab3a7d7bffc7b9970599ca86799ab0c9f2eef3df1f4ab03b603cc8b04481731daf19e65605f57839d4314d7c0f9bae58252fa9b2f058c1c3def76c7f071dcb5d7a6cefc7b30b121ef9865b888157b65c97a56afa0f6ef55f5046dce2885c391c122f3816edbd9a9677b55f16367d521bc0fe16bd086961e3ad91aa4507f6265a4d0c0b6becc1f813c90c635e6e0c3f870975626bddd1367308248afb2da1d313f394204dcdebf0d63d648d745222786185c025f94b05f1735fef99d58a4f1c01e08d2fd915e58fbf0f749a2fc2527d6dd6aadc58fd5ea50d3bace736e1cc75af761e51b0fed31dfa797234d102337c779c4f53d5777a9b560fb14f9765ec83240d36cc723e0c82f5b1772b6d4140626eb41826ba7dfb152640db92f539f8ef53cfc66858b3f85d2c2afb8a04713571cc106954533d1d738c109215d5ad0ec9ee275b3e4780d01d273fff880ab4bced2848245f83fbbf45e90b952b8a75b52525ece432085d83a09b86f2019284ea2dd5a14ce6aae352b587ae4c82dbf51cd7985c24902e7c902edb859bb11d912cee172c446b1c6c61463259bb0220cbe2151d5b81bbeed4fe52d6b830484659df9543e5684ca1b0af261b4368264b559f6299b7f54f7bfcaf9f01fed5d337d3aa571057e1056af8f6c5308aca7854816dab3b8b63b3da237eb18b9945bdb5ee3c26b0651317e5d724fefcb78f0b70f240f7de128f173cb30d3767c03384f042628053a47e302f9ccfd4e5fc7ad8c91ed1ec3d8775e64bf9d25e372268c2cc36fc9dbee0544b03ac1d0d629c8751f2fdd6f16fa49f7002d280979d6d2e78879847fa486670fd628c22ba316b10f4a4d958e4bf8209546f93e84761292c56bf5f9c53fb760c63a7ce034fb9844c1c5b94c33a890ff2d9d5fb4641948802c14ac57cc24af989df52943305807f084b550dfcb48f3087310c25436c3696fd5102f71413a94c4a1715c1726c9edad2cbf95cb2bae589aba2b282207d7d8a250728c90caca0de4a657f18b4b04f0b93b033e69dd7bbd6d036be8205e1e9289c05d76c79c02ebe8b9e5961d2fcfd35a4808e8afcc79445d6ea0cce6820b6e4fed1e909bf18f9356c2e3daa6c3ee6fb2daba902761fd15e003e7049941e928781a9a61e92aa5973a3130151466d3b1a8317db6fe6cf685ee00a4891fb56363083ddcb8d7c10ccacf54003e6370206ee9de0b8c84586becf8c2ba4b005711c92eead9217fb96b3b370f0f3697ce668aa6a8eb6ddf7355eedc22d9d072006ef156dfd465c89033b5856cb6d85b4448457816a0f41a7718550fcbb2f7bacb2db20246c4777377e75437835c6261c951674dd20f2a015e0ac9a382ebf2c63c5eae80df9e4b1c0aeea412ec4d546e901ece0ee07a1d0d0ee7feabf42bde54a6143986d1b416828a45b860ec1d2261db9440c4416232b13a6e127d29d03d71dc03ca29f9b53683955006621d56d59c85ff9ba8e7a5ca9f496f75813306a80581d026f89a05ce310ba49a9547f2abb568486322945c576797dde0f691df7c30bde37c785c665ec03109b5796ca8d60351418ecab3e6066a4a244a58e96005f9d6e06b2e4d2bccdae19bbdba1085cddb7759e545e6406619d2ed810de62556a2f674eddc01db5aaa5171a24dc146887b83b4446e723ead60a801ce1928a7cf831e323368122a8120a5331f73dea1fbe9f596f7aebb708fe3e1345b1d3d1043e63840a01547a3be7877e727ac3b1a6aec3f899dc22a4fc58706e640a2a7eddcb61e44b9aa8be892d9681547ed2ac636a129dbb0ceba38663f6c67247564ea2a7941bc1995cddcb3de7b361c81ef94b9b50e9ce4104850c18c98e740c30daa29c1d395f8df896aacbe7994d8673e77c600f7dd2d449ab1fd8fa062b275ae6627292ad3e0abc1f7e5e8056b75ef302ef951560ca720d395c0d77479e429ef892a895839bf344715df271e4664438b5210f3b29aee060ff127c353bb7ef26c6f34060f3f49935233f8e200c15721c4b761a5f6e2c6c8b07eca735de204ba200948c76ba8a7875f5340c19119c240be5f9cb16c4b15e972d1442dc2489e6586d04c32f149dcc843c0340cb9900b13cbb3c27cbb22407b892b215f39be08e38de5334a21d5a873b65e676f1abe72a08b3baf13b5ca66853d716bc55f1852b29a609bf52980f63a1ddd2caf70c59e8ca154801d93c692b43d510963eeced7dbc7b45c71702613e3af8011f5ecfb11edcde2d114b7c2b7ec2b0d3780c348e2990cf817b61da5295237fa94b54b55de09dea8bc183197c877008a023a612a3b6d841ba97bd3966ed42a1e3feff9a6881832cc82b85d828cc49e37dd3687d418460ede4b35f03683baf36803dbd20636859562827012ddafc1bf00b6b72e25acfdf75b9aa8610aca9e903dba5bb64ee1403a39b915aaff9a335bc7cdd20fbe2083851bd90841d38bc382d83415c16a7e70facfa4b7e0cc3685bc719e32e8324b8bc306a3d6b7c4708cbb2b92ea7ce7ab6591e3ac32021514709eaeb3e91407ef33332d3480bc195cecfcfe549caa664ff652e1e4e26f4284e57a9aa99a690fee9fe4bb8d5a0cbd454076c7c79e04513248bd431b1051453d67a53988af946a76fabe8f386c739ec5c403762be11dafdfba04009a2f1684d5c6e613f4ccea62a149ea3fb3615b46000e6acfa449b9ef372c650246496cf2a322058d4f8b0622287259caf6654fa5c818d7402f68a5227f604817b81794a0a3904fb2e2e25db40c343d04dfa23c76bed16286a883434509234d1a1c4a4822a74d8a7a65e9809050083300c81a98c6d34dcaa693b0507b871777b64fc84cfab8c9236c8a0c8e2f3a746af3dfe9ecd6a2aafaae5fe9a576edf0db8cce1130e754bce7aa8dc39894ed9edb3638ce1f38ca0775b96faa142857adcbc4e1c40973d192f3f22c9797a1233b9f1c42e1b25edf4eeb9c9ff6f350950523960d4629e3777bfe6eb7162abb0acee04f841e4d6af765d9fa6db5d9b8291169c2d61e82f9a885803ed616f0f53fda5e55cfaa5ad81999503e67b5c7ad4b55c1ba69e2e6bd0b57638178531ea13b0a7d86c625a337625ad966779b0e4cac551ffd3d2837fda779f35446faa28fead911903555d9754654561caec1bbbb869b1c14323aaf00b975cb957f3218836e5ac08768763bca33d9a453533ab03256777675eb973f49c3a6f000bc481a7c745b89bf7d3b1dc96b86ece3ab7446a243f4b4313b115c7f774921d2639745e2624d601eefdbb2e34e9fc62f43336e6ccbc9c7688d84c16d77b7d47de1157337486286f0ca0810132f4830d390400c79eceebaa0abcdb1803da630729c29cf242b62da29c1e22e6305831237d25ec29b288adb3a878ff541b5db4af181d190955f1f7fea5928a8489a05c8ebcc9683c2ae860d47060deff313e20dfba7caebeaccc963ca4aa1dd0a087b5eef1111bea32316181f3e8db4e5afaf86cacb5454de791641c7bd555cc7a17be949906616f26bf86f81e0a0e629e3f506207af862a70badc25240b078b940d1a705c48a1b591294731402b01568c3dce5e4fc8682fe9796d36419ae9093977a2ed3ba64d0f07efc8731e7010ed2d080214f18f30e4382215dc4fcc97344a388b3de126ff328091a99c1cc8926a6329947461bfa2158d0ad8a7c4678903ccfd49aae89ab3663e3f3073b8e0a65a57578cae71b6e3b1f775fbba83919d56d15e6163af97f4c5d48e6ea2c75275e93ad2ef571c7547c3e7994d9d2010053acf13dc60c5060dcf0c7681564059ab6285f03f8f3cdb6acc648e2278e483ca26ce9b5aaef711e482282ecb3a23a9d2e73b4ed8287b759e93c22b0da4a882846e602afba94a009f44ba23f8b545c350274e7606f2a22844a2bba078ec799fb32cdea16b630ae7d766382776f619e6255b27f7d80d5e504aa4c911177f6d766c2642f8e4153bc1a5312dc6bcfefd69e68d5e6b2c4a54883d72d4c379df53c2d698eeb83b664124c669a280407da09172dd3df12c1daf432ac7b8a5473428bfd807bdb8bc178cfa3e438e9255a75d4327a6fac629c7725f63bb59b88a36905e7c9522290d770c49d0a5af99cec713c265b6c5a7d85889b3fa672fe53f20dc11b023a84b34f6af4dafe07bc6723913072a0793afb69ed20bf391ec96336bfc855915a51e3dc689f93ed77ae5f580829a700657c1d198775069240df176205bb1f78739eaf7568566111a8f77277664e8eb2c630dff79dc10a82d1112f1beb8ff6cefe0e69eee270b30eb36cd9ee68414b61af61594294e21bd01686dc077412480dea4d8eba611c347cc2a56eb6ace18332d2eae31e0ec10c20aec64b093f891802ab68bdccdadfdc33c76d88aa25f7df2e5540ee5046488b475a224ebaf2bff5b1fea302ac977661d479841fde23ac66c3a8c8fd363688708d3a193405a926aa3595e7ebb2ce6f5547ca9056c688fcc65c3d29cf063350908d7a77405bc39e25b4026c53c248f16c760e076065c8dab7638ed4e4b119a923a5aa097fdd12ce069dc6d994a740b422a5188e7c4ed804234e5f7df27394a5277d2d2daddd0e84f610d37300e640b8b4acf5a9d26b08e82d20ef1993d1d3ef635d2fbbed08963ebd0392567bdceedace87d89da33eba14875f194ef26be3d6be46c977d8e1288fc8a962ef94229ede30f9d76e3d24ddf28760472d145a2cd5517ac080e02fe2659e4b2f9de9106cb21453f1795b96fb42f228b879da6925342ea7bd8afe048d3d6f4f0d9fd2c63d2e0b4b47e2dad98327811bed54b737c14091489846c73a772fe62797dcae35c2b9593bd40a5e2c9a18f0ec949d632bf98ec6e53f281f659ef814dc228f5790dfeedd015d016d95ef428ab4b9eaf9c88798c091bde77bd364c524089779589cea0ea33d75859da4f3d9288d70f86b329b45e94941bc6b72c58f2055f8a9f8d6b97fe2d0612157d7dbeec5b3961323f7cd02352d9e589c0a8be84a754688821ca308cdb7caebd53a0ecba3a2dd74d0000c7449a8fcb1287d28a799660f559a022fa7f9393ed60cf39dfefb5b834f571442e615cb6d14a24285bd15c8d1e3b11b519eaca008b9543849bce4315b8fb86684ced01b29cdca5c8fb94eec0f078b8ce67ecfb5973dea2f46674e998caab94ae86925f14ac541fad46c6632e7f5b93c2641be6a6241e5f0a96b8188faff461f2c1dbf1a6980542a5cedea82f691905f77579c7a8b9009041c7e3049cbe3d17209e98546082945916dd44b150cd94107fe4c59995bac650097546701187006ceb03d4b3d0a23e404cc02d2b7a7f5456c2a98aca3009b62270480a96e6549bdffce22e17465081b19baad9e93c55d4e38f25a24f3ec01c55ac3e70f6b59887b1b923981d22329e11e6bf1932cc833b0aa2ade015d0f83994b1794cdbda097d113faacf938e15f3be86664e65d94ea4e811c522455056e1e4696a9bb410fc3e89d3fb7297a55acccff1d584671e9bc6d68ace2627bfcdd9d841dee9b4481194c59c96e0e2426f3e613c5d089db8cc8bf8cf9008a2bf891b379625fbf9056bd794466a3880746fd7ec8a4c2e5ac06768c8f0d1754b709a59d1b9bc7c6d659ef97caea472c9bf6800fa1e92a0716d9ca09a7980eeafdba378214fd0f8197133fb11e62ecebd39d1c33117a1d4ebbd97378b4a4a5fe2e636588248911bd118f8d7a93c583432ec60733c5bb95252dd79604a613a5867290bd05a8076c1678b9d27c30167fa67060be4a04107f320b498fdd12331687e1c2e94be9fa94f4492255ad80d68986084f9c96ddf8a924b2c85e93502a2a698c2e0d420ffc3f46bfc5ff733505f427f86c5be","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
