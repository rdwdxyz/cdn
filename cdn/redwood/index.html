<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2502f66bacb42f6b34a68d45e2080a62db347b3b4f959f68370cf166e82c37310110ad50c6b4ad767cc3e343362bab737436cf784247e452f42a11a5109f985d709c79e088781e8b3755db9aa7a2e5df11e12df01da0d2b988f5d1b94735eac6da230b5655ef85170f1226eabfe15e9fc5b0ae345041af1507ceccfeec97843cbc18f4da1b65c5a68f1a032806c5936a880c5c685367a1ec94c278f39eb6bd1cd950858969f35b903a3c5826a4fe88842e7dbc432244741a3ebe05db3d92fcde89e1d4d67367e96730df11ab5b1a1dee09856cabb5584c5784bb494910924b953a80b2507f7eb8760ab420d5776fa8aecc7522d65ea804ff88d834bf906ebac4d16fc77fcbbc36a943641cade7db03120d78a02b44c48fc9c6933b169d78883704d39dac32a017037b2e33a4d1b6a5b87f92d813b32e65e1304e5e8178b70ecaf41698e6f71e853fe3a2030d82d6aacb81d459dc37cfad22c931b2472220471acdb3bd3766caf92a8b94b605d7a64da813b51abdb47ccb4e04e8c2120bd13fe624f2e8fa4002a1d6227f9cf9ee145f2364c05d478f11d0f8ad683de6441e15924b4fcf4245730e2e0d56628465b66862eaf2609bd1e470a7102ed6d7ee0cb891873fc8d4a287cbfc087a16da2ce5739ad4da194a041c87d88c67b205d68c2b41bf1af6d0848038da2cade62425e5f721b16fd0d04cafea1a1560031b2982c9e729c044139b2b3be7c15da2dcc9d105b8dcc7db3cf2367df3ef65476a0f3a3ebebf7c269fe947f6865c94ab881cbefbb6f32682c6da13940e1fa1ab47bd18cb693086da8d0821058e231b18cf2966e46a91fbe43fe830b22df6b5674b8b06fa93af13d00133c87f73188af0727cc7b435e0ca48d6ff1b6c8717f3489d8af55a89d6110fe00a2698ec1273134d75ffba9f999fa9051f68882eeb25bf1a04ee7c1ffde2e23388a112b6806929e486ab7d08dd2c6d17112b469f1a9908b3c85783b7d85150487434f85af9a542434a9b499ded36ef9ab73ab925d4320a5e9e9d3f109ec7576ecbf2c8b6519fcf3f8a5e73c64146023447ca81bd6bafbad96ebef6214a3bbab9634b939e0d213aa445ca6ae9455cca63587f80d18535f64dc943af800ec60cda41016cbd656fef0148f4af95368b6ee5d5aa19bda75d4c09f902ccfed3cfe4e0782408218903a17200c9457729cf598c2b4ea228d3121a9bfa73a3a0c0ea418a9898f231eac9ae1b889d88513a454dbe601ac6e3f50891a0f41cab06aede73f6d1b6aa2a50e7becf6759886416c22e18833f67da15ce270562f5d0832be3970d48bc662c891d0acbbee22ba6ad826adef4f7da9e2218ab8a38e286419c978d8ce79aa32cf9a4ac173de12ea1f5b339e13ec1bfa1df43cbafbf587d24196586930db5974b573a5988655724d9d792f11b6e454ad21528d4e743dd9b3155199ff48d55ba4b4e349c399d05a16c7e47dc7807c81bdc51908743bb5e5278de0b54de47273d0adb89f6f42b7eabd1c5776dfc3ecd92ebb7197b60ce81719df7677b1bc2cc5d8d4bab9454b83c6368eca45963f033da897624c8c5fb1598329a1ca5ed352cdcaf9faccf3bdce694caa7f1bf8821f4381b055c82f2d05a3551a4db3e3011db9c09c2e6ed05610f53948179fb73983702b1dfd89d3163b45668efa8905cade7ebd4cad0c3d8e598ef1ddaddc7e65ef04b04b10e5ed3077f421ba978c26fa8e31c3ec99b1c7c1236a93e4c56acff191385ff33bcd0920c77250cb64a29b92fe468c3a22639ae1c089f880b577f4e490e07f962f3c4f3ac425114b965b010cf76ab32b7294b373cb34a642d038a14bb14663fd8b06ba018bdf0f0f595e68df709aa83c959e71d50bb2f26b7564fd503365beac62bbac738f89f2789d0521363f2859cff0424733037a3fe2884845e7b937c162e55236c53a579f870bab3db2fb6781120abde4d59ae07ed4925436a31365b2dd6e9cedf75f5fb704abeda7a8ad164964e308bd88491ff7f5e8d2dcb8f0730297e5d901700e1c9d8d4eef219fd7f1f53b543fa22a9d79b6d3e90f4458ce48e1c0efc893664b0e820db366b8ad007b17d29bdfdc4175e7cbf51bb56e7211408f0bf4da76f335e457466a5db27644d380b21c484c30287e48533bb189f2c1ccbff9489d80704f31b1042768f252a29cd1fc4d7c82ab0c140ca14b0d0d6a7e48f21539dd82b3205159f99799d8ea112f3b94fd0bccfbfd6a0652b3143f71f79a4fb4b6f77c5faad46875a52c454d50d00f4068b6f716af2d42adc1f26c3f1c27d1aa0c48548736fd85dfd23ea7d1f09f4fc30592251aa9d463809f4cefe3319ac163788abbd80f12355c009bee4baa9dbf1bc6d62562640f67347f84d79c6d799865f945ecd2cc62d617d7dd0a80fad9bfc84cc80d15cc5f9bb74f746168947fdf142b8ba246d8bae85d8d1e846955fffdf99e324a59baab1c2befce606adc0e5c1082714994b9bdc26bb85c38d9b1d9ad3c5df7c90d2f282ca56aeb93ed54a81bda5649e645762b78ed40bbdf39664a4c45de8e6df57313b2f1a1de762b0e2b6cd86ce6ec7c1ecc10666300bf1193289acc1b1bfda6cba3a10e940b0c90695d14a26dc253a7bb060c1c402f8116b683eea0e48167b5f0e517d77c942a9be6b302296ab5e097f595d44256963e182e139c83f1426839a5344c119f801babac3db898354decf7d00fef4d9bcdbd5e4899b8d3a24d9b2879fc73d440947f10a471666af539de6bddc6f956b0fb66e08b070edad24775f71d0a1d714240fab836e62b514225765c971c94c9383be16d0bc4b3a3713e4bed1091aad77cab9ed7b879b73da824d291f19497d17bb555e44386d66c40b0d5e812009e16ca27c236ecd13ea15bd7cfdc80961cf3785a7ff740be3f91b260b681cf652d94fa5b2c0a71b65ad30a7274f9c61e27e1b22c39a1b1f8c11287751ef90f9325c34622bc60e87b588b9116b2e5fdad575daa55ea635839f656103ad117877433f829c7f816b120a28f835b9b3138ceeb7e434e916a4dfc6b4a51f4ca5e1655484c8ead4abef220024c924b8462902a758d93d9ae979d3c3dac7ad5b56a3d8180fc613f6951f0fa58d13dff2dcaa8b3e6455be147326f3a816d546ff39c40117a3e2beda646c18e6c7c3e476b20d0d4081328e0e891aa7e824d81d045d36b715ac095912b99ca65cdff1477e4a8ed46574e315247a7d1c7e66bd2927b1575435644cd6fcabdd04f4777947fceaed6d203f507081163a83328b7e0e59d3cd595d6b1e24bc03a7902085f8384eaa8395b08bd5113e17c5c98f813d8fa7b40993e7fc69a64dbc97b9330a9ab16990f7288cf96b205379f5db2213cb3228ddf69c8f9e511dadd6ff9c10610b52f21fad1dfaa75f4a5d870791cd1ff4865d33119e3f8e11a1bc00e4f0c9f6033b7df536a937ef05400f60c443f4c41f863d3a7bba88826698baa764864b484914ec931186b1dd339f1bd17023450edb1d641f5e04644b4933bbd9f8defdce008718f44909eeb35abb07874b43254b7f5d38f7fb7f820f61a5bc7c0528649b3b478c7b7cf5b451277968832b03de24937e8fc28307b4eec93dbfa311f0bfb84065525dfaef840d615c949b8d9123659d294d97106bed2e3ff23939a4ecde6933d6b6fc629c35823211c6298adae95812cec0ce3fbf13ee7cd444a52adc03d106f3f65268b8325260ad464d40ebc0c10e072b467a11aafb2834cd629f78c72678555e7d2bd6c7b6609f9daf23eb17cad595567ff38cf20a94b368bd7c2bb5719f106cdd2e3154fb8f2c4073812060911cbe1a20ef5730eb70905d9fd77af83230ca794e3d30bd91621f066010472216639d0473c463921f465dadcdd1395af2c9fd16b4426c594a43651e2c5ffd3d665ec614d7041a25d899325516500e246ef006a828ac3b8a91ed0852ea10bb5c2a24f61e43841904424b0f8ac861ecba9c9a5262cb15f633135be66757766fd15e7c747820054c0fc219c98eb573fe3cafd6f614ef65f1c65d9d27496d5af65128f2f48f1a8572c6b83e972e17ffee11b837d4e166107ea49bbeacf4e5fb8c4f96bbe5543f490ccb5d1eeccb9ce5b24a698be7d717c74b35b09701848bd8dc8a71cbc4597fd2fcca2a3edcb9c73119f0c2f84e6a0c8e9a8fdd36acd1f5fcada3ee81df0561995e3dfc1dde5d9ae044efd2755b7250d015720d4bbfc9f3dfa60b28b1daf590e496032ea03b24c3ea83b00842c13367f026e8fa273967f2ae0aabf36a1f313dd3d6ad3f681669e94d150d1cac8cea3692d9b90a7a66335f3bb8920a120489d80389efdf7a2031e635f377f25cb6ef42500e6668dab48ee5ca73b3697543a748d59748ce71c93954683ab122e1971c1f971702c48c2dd68ed7f17380a0044c076cb5974238553bb86c91edca69676edc96495b01e2be00dc8817eef2a9830534a6dd0ce6fc85f48ebb5b55fe52d208222c162a643bd6b00ce3e9c2e11f1ca9a518c25816f96038dd28ad0a3eb49050178906a06196232abfe2c9f9dcaf433c2cc7fa22be616d076b3af34d09ed00c8f75894015766a7f2eeafbbc9353875e2661102e1e21ee91e0922d2b18f93be9293caeb32b767d3d635349a9f73111253fb932246e2f17de5f4c71a1f30875fa61244c23168a89cb31ebf5a13391c71bb9654d34da1f8feb0cc19236aabf97de1b2f072ded4d909e6e9b96a2ee7236d30ce99bec9ac1f155d752f12deb298a42622dda1831d3efdc6596c5c00083fc1c5a8e1e9738283c9a4c27b01bc58f5f84f4d6771e2b66d16065b4b8fd47331ded29d97225e48054edde289b33079b8593cb6969f1c4c9f2f383fe6c7a789e636a64c6b09d18fd173c88ac1d49586a64eefe2865af314cfe63f277dd0c88cf63dc9ec860727d815a41c0b187639584f17ce753857a595785c5660c4ffd35c9d1d7aaaad3e8d65704ef1923901e8509698da5bd09cc48dfbc12e5d61338a165b14a0b1f8858d068c758aa050f883f479bbfd6c97c64d77f49f00cec9455ea5df1d9c52565a10c1108453ee8cf4f302ea67f93fb647cfaea2c33f9ed55832f1f53143752b7cb1d6fab0e98ce6701fac2e5fd9ccd2aa089fad45c9b478db25a812f2c79dd7f0d16b76e856fd1a3e0bd9f75427b65b883d246167350bcd4d70a99a5d68c4e680698811864856091e1db62cb6a92975eb02c73956435acebe277889e69ba5d4b791316a35fa292add336077e728ecfe71af4371cf9e1cfa492fcf55690e8441917a4f0cd4c78638f63d960675f39e4dca02dcb7bd4f7dda5b3bec4d2fe85caad91c32a915d342ae402672cdd2766aebbd4b48e60007bddad26233b510dafdd69400ff7adfc6fa4e81fc431f9f08315df133446d3713e1cad08d43fb089ad6625a3b0c9e7279842d6b658e17e10e7a4ff3af901661e405c8b8468d623587be396c3fcc694efb2599741d3b599cbb2da8d11caaf1941c8ee00b73b08b7e28aa8055f521fa10f97ea784fd00ec4954bec4a99898119eee56641f5ef18a069267cc4cb49c8a7c3582b25934b35838fc535108105b22822d8e464568a6a1278e7be87c0fc04936c63d7505eaefbe93a53a0bb874aaa3b60e90c24b27f60564f53c3818f51fe7694138a2e56896cf5d78b96d61bcb7eb065293ba2705a633f52f448acd9b5dcec23dded803460430aa4e34305736aa6d23d449d1e17b33b69834703ca32696d133510748d22fd09af3b926b3771ab6ad97949fa2d69885c773359c853f29ec0cbd6293779c48b06b0c537e152fb2b706b60f876b33056c4a00560dcb07c9d3585d57996574d553b5f64c575e6bdd2ce7f7beff58de42987df851ec5b3ba0f03142254b2c867ec6a605c635ae86c667566e8a0d98798a31e3c223735ec38e30a3b7d60fd1f817cbfd94b817438874783c93d63c7275df519a637165e749cd57770ca42a435dfdcac3916369ac5e1999b51041cdbd527aa26518ec90946fce909d2604a698058e1ef3100176931e52813c061dcb2bb5a445d806342166d0cf10b9aa936add02c9409f552224fd6940afc6e1187f109b733618f8cbd813e982f4245a4e80bfe8a9d0f83cd53d39ddb36276521ac63e6ab123d3f6d49798f495d43e9ba36a6c1e9fb0554216bca2f292e30075cb45422ebefddc6198e907c20022426010dbb1d892d45eb06531056781553f7790784f488b5d286901516804de3016297e198177917450d3f47ac8d3f8c41f2a1a62aca5cac039fb5db3740d43b68f3a5197e6a00dbf40fe3b2bd5c68dd6729533f543a163550c6203744be76be8dd41ee849ff2691c90c54e6cc71fb113847c6b808405f6497f8d3db3d73110560fd6269091f2a273d572b2e4509e39fb7736a2d90b9a938d5bc108680c0b019f4047c70aecd215ee21b39558cab560f0e0f4db5f660c602afe0826d1634acb9fc8223e890ac403a74f742c5505166c0b8843734ab7d6073968e0229fde4f96b637e18fe955f69a56e3d80f9589fb8f8479d54e0b890e53cb1f51d53f92d300864ec7a95a9c38b011281d38d307046dabd3e58171ea3658768d2c3f11a8b23199c944e5bc71780486851dfea31ac3cb1dd013e32b45d1c4f1b07915a1fe44cbab9a7e97cf5f9e17f8eba3d67c2914c4370f773d90274a4d463f8ae69df28be4b03c014a1cb912ee3dc169f3aa1259f5137067406eb7b7365bee65ec828284c9ece4d62ad5bced47f30f93685958eab1d04148016b9ac082665234c47dcc0be104bde69b985828ae37716a4dd02e03c959ace59a1b550391930ea3cfa5808d94f7cf217a244b696071c84af9ce5d81fcb6bdf711c48762c96e0ec370091fa946fab06c57fe15ad7e24a0e062564477b9d15ffdb216c071e1a98cd70b523ddc302278cbd71412c17b16e7102c893b2989625d6a59bac26441606084fadcaea0277b387954079a1a464793ce928ecc52bc09dece16d6129331fea9b5b983abd2ceab9364ed87135c5db225d853e53e0d28abae504a3dde1450a2637146106f89bb417a89e8a8f6084c6ed090defab570b87f76b1c270ec637131646d35efa5fb1b2b8bc42bded3a2f0d4744745f0d116114c7738baf6b91e62ba883523bdbf8b18ea260bdbac38fc9f063fbfc9b2522b5a41575fe25c061cea3b952d2415b04d5885073792360f228f529f1fe8db6c22cdf9e543f37b8ede48e9562df94cb5ea2fa824bcc0c1364c912f8d072d4de56b6a6e6146036e5dc431e30cbf5dd62ea6f9671044d00d2e47d1cc87bca44abd452e8ce103595560ec866577e961096311a1d708c5e527c7c94e7bca61dcc6e26738ffc8286053f2e4d7ddc389dce7e2c796d88350f3b03553a9ade0aadb88e95bfb90909905ceeff104966495d573cc4a50480d0e64ef10027f01ee73c299bbaed0e043d9c50013965cf1787d4fd1662ec1e4df76d82c6f93d0cc5a1e5b7cf5be873a1742bf909d3d3b1faac0fd6843ef1b34a30b60dcb28a744b35a379e48b98d3c335b527fa3de33aaf23aba5613e430db9ecb754cf071ea4fa25bf5f4e7060c0a5b833c40b443d25c80521d841e5070bbd93cf8202b67636da9a87c036a3ec17407184415af2b346699c89c86f5bbd96b39d451a5239a3c6e5444437313fe9aadce2862fcee17da8181ce02e3a667f1a8695898f82e9348a2e9d41dbff26a9a8ac20054de7cd2c221341314812bc0ac35865fcee9eb57c98aac0cacf79c3d7cf65f9a5a06a411f8f76823617d02a2f35584ceeeaa166527071983512f7d7f341f69f87c029b33a4fc695561096e268a6079ff495f7ea7c3c9714c9c57dc7344928ecccf481c75da6bb628946a8ed4a27ec01798909110e9c53d6f0f9e184c0ed73056aba0197182a51cfd321ec35d57cf94174ec16fae6bdac5ee4349426d7f7203bc143544a046bfbc87eab84aef7ad63394cbfac0894479a14c34d4ae3e7e19e65e31997fe8fb7c390b2b269ca5c6337895531263736e80acb6ed6968bffbd8d43472cfc2d444a22cc7089a9bc98e4489a1a0c29bd004fb003b31a30410be4d7783564373f8b47dd977e79b6f01afe0cc29e72ddac732b942edd28827d415a624b5f315a40245f30866979bca0bce34bb97e82039321dabad404dcc0600d0d696f3a5caa2aa861910cc0d93d6c58885958be6b644d6aebec53b669c503c73315e459baed829a641997eaf30e7737d72e353a1158ef43212808ad24049bbdd6bd74bb7da1e5cbbfd10247712bf958929cc6bd337c6b31dab4295f47d0c0822cb4c7e889d688161dd84a6e9066eb97475a5e2471758cf1e9d321d5439661a5062e8ccadf1a2949adf85880189a71f1492a09f41036ec80ec770a664fc816d51530e5a40dd3719e83a0728912ee622ee37c47a3849233b0add5cbc04d749e0ea0e26577b30856d6b09d5794d127a1449fe9c2ab74b1939effdb20d43c30f579aab414838c3ddcceef62fe1d7fda8f35aaa49b50450288d9cc01a079613d579ce99e8de8e8cda4434e3df803375a9d262ba525c75b9afa24abe13219474272e898abb0005d0a10704079ee32f7613d72f6956b60fd5ab71e2c3ee80d0a09fbde9d4e5d216f9c4f7a0b526343345de6ef85abf84cab88e12fa74baebe4e13fa1dc982d8da95051e0fd3ed0bc9519f8db1d2f6ab3a3153f9ee5977718402e439a808c78bdb377f9c2e44b644dc4521cd69dbc92a64c64900aef7d79fc6461bf209b89e895cf7e3c38f2dd51eb3ea102c6adfd468438f3e370852a2c5aaf1c8436b0e593957313e9474350a98f1fd2bb96a6aea64bf85c7348374d22395d25b8eff88e2fcca51ebb814e17baf41bb3f7c39d0d8fee634b418e0dc60def74aad9ce58d4914b840731f8654a8cca1045e52e63cbfd10ff3b6274c9e5b842efe9832b01a1d6084b7c17b0fea127a60ebc5b383691a42c235b2759492fdd468a75dae6904a420224e6f062aa5f6057169b6cdfaa56529552de22f02c766320b3c385e5f6cbf0c755c95c3131d432752ae866ec7d2cf37e5acdc0577a62d337d38e9556816ecf6f9a6156cec54c9e0d462554fecd319534429863d48bb84d8afb2a671cee27432c8035020a5918bdabd20b4a9d22d657dfb99c173ee0d08be1da82cb4880913b09f39c9f8f9824231e7e8519b99f88ed7992f650563b34a5264baca795a676250db050351d9758504e192fa89d51ac04d4b66d3099a10cc131cd6619bf9317adcdf21ba619f3f0608612fd1d2e7de0459eed9e8e0d75cb7d5e34145c60056bde08188fcb86091442703a0736a7b915a96734d9ef45bb52980860cabbb9abdf04e2d51b3ab6ec7018997f951e986a5b80c95ac92a99183c24620610eb9d4948f1a418e7e2fda9249632276d178d46ae26c99f0ca172837f571526dba09908c0ac5c06c53f6ba623bc5144d61fabb9ec7ac16c707c5b93d8cd88e2cb2961c7e06d5bbc1cea40853d9bfc5da23fec1f36af8c905f5b34320790e638d37ee6ab8534ea8ac391dbb6d5943ba9c28cf8a6dd86b1f1fcf62da3723ddb0adcfcb124592d860169cdca7d8d1427a0567dfd9e86ebd6a8300aafdc624828a32bcbd62edadcba8372e984668b6c4b0ec7704bf5b248c9df8d49b4834697d905adc2c5f188919a8c0a0a17436e1e5b488c1e111291cb091c8b52285a23a168f4db5c32b4861e7876994b5256dd92fd83839681aa9af54d46da45754f3bb2fb5de59d52cbe89ac03555d5bb0efb8bbd1ebad59c57f2a4008d092510ad9f398a845d333d5846812aa87aaf964037a140c2e824831476b89a2ea8fb03604c924981cbe9c89411038e505c33d1a88071ee0910464e3ec2abaab65881afcd7a1de8e2b8925493f9b17acc42061106745a0fd181bbe0508e5405c62cedeb574aad320266a0c115871509ed835c83f8e52b4ecaaf9b09de45fd9beaf32978e93753f56fe64959917e662a5ddd597e29db850b568d2db5e5dbfbea761a1e46101c96cbc60e9710bb574e0f0c6d3aab2c3138615a7c66bf09f59e0bdac23778368f978485e8f1bb10f38390b5fbac450014f92c183c789e6bb09aa9e82607a004dc84b3314eb2f49237f684d59cc6cab1b21e4603196c8eead870c51b44d3348cb249d2eea9a214a6cad3ad9d4d0de385c004f1c926c26ecb3122fa49e4182c91075bb35bf02e7dad40925d010aea0acac1e1ffb2783d08bf6cf15f833ee9d14106b4581d7c83cc6085225e5f56ceb7efa0a49bfe8595dc41af86f5df809997d8ab68879654e0ed452496efc2c591ca0ddf359e5da1781d761bd17ad67c17fe0ad072557aa98cce5d027379ed718d6e5b81602d4ea59c5d1a92a7bb72456d81cb12974d2e2e3d76c74b97280b5e5c4f04af11017be3b1d00c25b186a7ecc8656bf296944b9c781370ee84fc2b91fc1d18965337f55749885820b7028fad069bb72e66c2dfdf0c10f77a00cc903d441d037522a315c84d036b9b5eca8f11592823c9bacdefe00a5691d4aa32a0b092bdfb945fcf24cda30957131d6a709affa9c14b2fac4f5ae0a93b1a553b8e3ce7d0c238c1daa89fd648e108ab2b8cdc8e9ca907e971ec1ed68b1e5346e643858e4f62d6911046343eb0b3a19f9656d7776634846d13cd6aeaf49bcdfd1c686cd4a9b1f2574835dcfcb31528401a67c83df69a7cd4524cb926ad8bea118daa1a8f9271cb57d32ec76cdb9c1c58d25ce41757d29409323a06ec9511ecfecd795ca39baa6f336aa293d8e1cf4d753b99a89c528c35c7309d3366134ff0c3b8724d79e763637bb7e7fcb824f6e450db4db2fbe850728e48de30fb1aca28925bc94ccf1fde496f6aeba7eff7c9f16a3e6abbc9ce9fcce2874e153007389fe6c475f87bc5c168ba19b7329954501b36d244c44ee4e9fdec174551d98c32c0a8035110ad4e7ca86621ecaafc4587d09eef319a06afd983ab2a1a874a037fd4a0ac89dbbb0cc23d9d384bdb0f609f14019ccb65810b4384e3fccc42792e6f569eef32dd022e1694ba48618183773dbf01f46bc1d49b097cdaf2645820654dd7eb246bbbc22e1bde72224e10a8b242db8d7b9deea6127dab9a8ce2fec4fc688a48305d296820eccb7d0e6117aaed4970d3cc203ad1bb23ac9cc5b79062115ca4070a02eb3cb79202d4abd696cb03b7bb6ea1b71f8cab6520ee01bb21b5bfbc08dbb879285493168ef278edb29fa687baa0c4fc7ea79f50e6a05ecc98c8ee58ee5d556647429f62174414547ea2a00c57b673ffec236a12770d1039f63544070952bf724564002d3c55d76178e84873b1dfa083a98b9f2c3532344dd8e1dc7104c94c88300178747ea83b66cac8f350b27fff1a63b5b723299533273726a625c6dd4ceee43e9a5e07cebf3973dcc5988790eceffa7e66308ed3738fa79689312595176e204be657414dc8b7bbe09bb0b4ac936fa1b5a3fb64388a07a44dd70eed93a89c3c67143cb94bd1db23cc353c809b618aaff8a600a8268602f136947868ec7b558287769bb7f09f695f488268478d2bd0e513e07f2e1e1739439b5ae95e1c59cc0426ceb2a2072071e745032a92d61d3e6eb1ad891b7647ee1b21ac71a4a0a950592ab620c2c676d21192ea57fe1d47c95ee8fadddd96e116384f8abdfbabfc586c1ab3db535316c20bd2d38170edb933ad63decad080218f4721a8bef1a2ddf6ba2700df658c9c267776e826ffee52647f47097ae72ea015bcd8a5f2ce7fae5360846f907741283c52691308f512143a43024b2cbb791504ce42c18d5d1624a3e447e4d9b4ef563323f1338c12999ed8c5014d63f2c22e13cc074cbd342aca92e0d2916b8ba43eb6d5d0547c73fe597f5defe3035411bfbbdd568caffc8e4cabb52cdc76918fdc54c4b3cccf5782edf7ef18f228948aa6248db35e68f2c59c45c44b391d7d376dea5e7f5360187b50e4172ab9de78d3acb51da95bef4dbc83fa325c40503b2513ba070a656fc4c93fe19212297ae07358dd68c45a0c771153aee06bf86daa68372fbea6c98123cef1c526ec19784dca405ce2bfbfe07b43eb86a99c2b89a9970384a95971ae40da3a16bba4569de0bfb94e7d3eef03f6005ff1ce1445a3f090123d7792b24fbba5fac2e9d9041fe6596b08fd7a2106c193fe2eb57a710632613a52d37091b8127c4c79657929dbba0905e6f25f5408b80eeae4e318c1f4e74166a71eff41330c43b103078ba48bd82ef4f12dfabdf3db260c6e42a32c60ad3cc64d6ccb948e81f23f05a7785e37c5529f5c3515f2849e5fca75500d22fc3e1a1b611ceef7eaffe9f4e997441dc674b648434c5c6acbab328adef7c7f8528050f4ac8bd5685115f82079c89d492536a9b0ab04b2a1efe9da254de4e9d492853fb4a1f4d83ee9131ebc50996d727a2f2e521480374219d2852d2df01cac28160503d5b3aa0994a3924c420af34575e48c6b072ee04a3a4c587342c205c3c61f194a593cbd01c64355069157367a556aebe034005cecdc8f8c5e30f4d46d61d708490a3b6c12b8db8f811e824c3b1e625f4b592cafce80df77e490b5cf33571fd25cb9cec49e7f3f30c7f20ab2269f456c6c45e6fc5ce2d4fc47bec14d5d75526f2623988b975e95455c7278a7211039b5101b19f18cd1f53b6fc3cc10a194febad802a0431555194c639ce447fd2d85064103836418348e79bf5ca065e74d228d9e74cd15f00669d0016ca39352f430508bdda2a745fed239e5bc1905bb89e0689f24291853f93d3e07b0e0ba0dcf91ff2261f3f4a83c66e592677eaee2f9379d0b7cc61154b77af03bd4c444a94a005651d91065a4229d02835d646499042e972d646d476c4c5b60bb7f764a0adff7726c60cea138653cd9abd5b9b184152420c0ee87d638b10a1945d6577c6134adc83e4e17b734c78131b8f04db3b5f7b0bc9193faa84619686db10b0439590f909ce2905186f61749c43870f07307a6dbcafce2abded7461b54a2bd98f804eea54385ed020f5e01cf9ce642b0aa96e05abd79d3c07c71bf7577c7a2dbc1b0d41faf0b6aa9abacc23d7a810e419d85fb6b3fe379cfa9e955a4826ed133f88497de2f5134bda5dda3cd478818d4097a19f230661344c4f0fa3c37f5aa4b9a109494288ae53cb28a231ae73f657e9e046d34a6d8653101f64fbb1ee802542d170fcce984fbb954ad16d3abd1df6576834f27fdecf9888cc096ed5027233afdb8b555da899e7f6f538f5a760b09c9637d2413f086dc910cfcbe7c5b2e06247d3b52cb4e50299e51555afeddf8ec099b70e0d7c0fd99db9dc0221824c9f095be39c0bb3be7446c65cd912a993c1fc7431fdc97b2cb42c80f09c5afd191966141c62934b1f9f7fd7d7a517af27e9a29c056f96eb5f1eead58743c19f350789b90854af7b02e221e6cb3e83041abca00c86fc4a3e1f1330504752167c148acf1b609de736b953a34d271c12e80b0034f928f5e5cd19bbb7b685f5dfdbfaf90eef30827140d858a89b1dab37e36d8c081813b090446e7dc1d61419422d048b0437f76f4f869338ee2d6a7bc19a2f4b8fbc4332e424b9c668785daa08aea79bc10fb2494df636a984479bdf8fc1bfc155fc1c472de057b16d22a0ec8d0dc04ab4ce9cd4d2303870e0ddf1b96199c69a69815e4c16e08c01d7149f7e00aecdad2638b3cf472cfc6d1315feabc184dea82042010f9265fd993ccb42cea5d3c1e4d8ab24e6aa2da4a495238281d92cbb0f66843ed7bd824c575cfc2f7be6323a030717b075c0cd5f8d198486ccbb039b1b37745c0b9d0bdfcba6192cb25b6f9199c65eb16771ad5bc44a807e6f594a69c8b361995d352af0bc77f3c034ff3a37b62e44c517010b29597ded274373fd030c4ae3559c7364f551bd6873493b91aa57d4baad2ae82cb00670d65af194b48b6efbb2cef09c6f89a096c758f2388284b4a96d5464203a2ae777dfdb113a02bcaf923c67ab6327d7a857c13e78d3dbb6c40199851f76dc88b8a5652f283e4bb8e4a957b2d709f086415bab79e21538d371ee5417519766cacc56309d87be05e71281d23b362c8cc30e2448e271ecd64b6ef953ba9734981083517d57f2dd1a6e6209d0c2e089af48fa9169faf10dfc3335fba53f00dd108ee41403507b27b0f7796d59ed3251b67eecdf6724b8a4644f0efffe10a21e400da30e12c29c9182a9908b36e6323d751f6fdaf2af943b2ab227d26eb8a059a9a9f5622c720a3a346d55bed6844e3bbd422b500d82d3f1a0fc6d30dfbbdbe3dc8c094325b2ccf3c6fdcc6aadfbedd50c6b1acad8564e54485666096939d045e1f1105dd0e41c706509a2c441fc9cd59061bc2d3d5b4384542523aaf1b7e147c803946f530230209afbb50a1a2f1f1dfd1844b77d10fc9bba9d1cb124a8f50641832fbb1bcc1f9c40279a469ab7dff47ca4dfaa00b76905ce74fae0fafe2c2a64bc9c0ceaa3e3e3f79eb04b6ea63980aae7f5d3efab7dcef2994cfaf8904f19efbe0a8800c6f1642b1f47cc4dd08919a8664d88021cc1978db0d6c35ee50d061fef21b30b44644bea08295b97cb7e1c6371c2f47fde22fd7f93a880a0099f3eb26ad2a7532e36131a9c466b55514688a930a4e8b6625b23e5aaf94b7c5f0339a7d4d27d30dd6940c00694ebbf644582b599666caf48f9df5ac5acf0315580e0451f95442b0125abd03fd0c1236b92e922469644738f23e1eee2fd3510cd3f74d055ffae789c5dc4bd29fc1851e5b5222134d7470a9e79cb35454f1b654a7a15d243c7f345a70095a0593df1143b3ca032902e58d337a9bdf5baf3bbd625f580b75e10b12638b02b75580059aad331ebd208ae8e50758dc4a3754810b96de443c742aba080f4a41880e99605a734a0cd1843a7f1efa4bb006b4b9d60f255138bdd15f65a606b188e4b497d17745de250c8bbc1179c4909cc2752837c40fd4bd3fcd8264463066abf6b36bf4ba39f55f5cf35de17657c1cc2ddbc9ee9e7553a81e4d565fab5b833c09479af2d6e335a733517a1029fe62f71fc8aa9c4f3df80d6ccacc7b7bdd821da9531bc60db25d2cccb661111776d27ab567926f1169f26d24671bb38d8fe91d85879e05c9d234f1fd719f3b22cbb795392","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
