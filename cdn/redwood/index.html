<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df608ef0ea95e5765d30b86c89ba97deee412a047d4b2d5efde4cc9e70bbd1a4c53544a379f3d93ddf2e3a5591b4578a6b30038ebd9e73737c83ad8d2c4f0176ae5dedd48f37cad8c43ee25006eeedb1d6bec247ba4b16cd2f73ce07ca5839bd376d098da9a1f21169d8787afe53f6df3e80cb010241c68b2965c43a2f853ae945c9cc2d69e5b59398184ba6ce2db938ed307be994221cd09248684d2786e826e0c43a9855639e4367e44772e20f8f08e67a36584b58a672c7b801a5cb1daf34513a35cecedc2165a631a1e0819e4a2aff7ccdf000f414994d6ef7e54bd1184cdbb33ec79c841e994cb3b52c51bf309d40471c314ad576ae94c3c9e3c16a5ee02acca9635bc513e8c78dadfc9aed6cc0a3d41520ed34e0d57ba202a6cb691d349a7db80baed679e8e91fa75ab469e0c99e0cf9573c8abad96c90a76b2e088d86cb47f8ff61fc205be97cd04cedbb9db8f067b27c6940a7e41645877f3dfd51f0119653699b0770c8b6200199b78876f265b449ab5a2e3cc5e55af2e8e242233fc9cd256d0f926e6ffeb8b6733fc65c4e48ed764c0991b08cfe7fd8617b7f7f5c7fbbabc57c9469a3a8453ac7f85ab5253cef3e26dd24ab6a38c8b38e7bf1d37f218c9f560158ce8185c9e9cd7e8bebac3d6b6e3bf483f318887b10dde510b50592b276101203e70e32c9a1ea191192f1c6e2fbc4c175793dcd2331372f8198414b465189b09374f151c9467abc5b54b3c3b8c18293ae7981fc9f01fe8bdb108c3f7455bf7d801d43b6809c63298d26eb907c3a37a05275483e5b41b8337fd80ad01c0efb5f6952fb5f77b683edf8567883c6124d1ccb88d9e4e9ffe22ddeff48fb4193048965c0954175b03ac3013ac02b2237c088415d83b7d6183b1b7567c504e4ed96a1b67e190e7e2360c259fb55d85c483c29a815865b73e93a5a7b5b3171d45c2a3a979bef6163349f12eca4bd9e792b9a03bdfe56dc6e619f1c3e50933a797253280ba9df421a8279b60819c2d339c5fc40161062f640f87dc02abd955ac7f8a061b34ff8bc35fdcf609c003e64731f685b47e4facfa82c92fd0cc4a1834015e367a461b0e9666d1bec4b0404ce9c10b7c86908d7289c091c6103fbf2e4457d7da830f159ca42b9f4db6196c11741d392710bc968984b1a092f70f6049ee793e5b1f240e45572f021efb2653dc8b1f8d896c1e7fcfffc960d649c0b16ee354f9eac42f565f3f7f247338e18de7c0cd8d46e4908f94a9d242bc22d6d23db630fdc7b7bc197e16bfc7ebb4c9dfc4458228cae901e6947eba0ee537698286f220928f030bba4151ae9c3f4969976d2e15f7e912064815f91dd96002a724b08ea1a49cfa3ce7f4c9e132203a431f42ea424c563fa548e2000d4482f5f96fd41f71da06a5bd6836c7057f8698929a3b6326032d87d42464e80b33938eb17f1f79c06a717514ab2dbc4c3ac9a4ce602e39a05219b9ca1fa2df4316d345f30e39e402da7460926ca38d578b01d771e82d5d14f4f1649be2a8ad187fde1e7a17b14a736651016882bc097bd277194c2de5632426b79080b8b298ac4c027ab02958f79401c025b2cfb968fa821b3c079baedbc376fbd9e7c4933cf3385d1a53487afa375690b161c443e9708180c40181b2771a4130b013ee0b46cfc63aac1aa64ca3eabea6050d319d701cdb8fd621645235a9d29828d3eeede20399ddc86b72bdf979f20744a452ede6148a11d281a515ed2a84abe86206a316afb517e80738a56751902c263cbae8ecd39ffd7fd4f96d2358312ee0237808e52e19c8e75ef972a6926ef4cef7b68c2f98572a145b979f01e52280a3a57dc503fb4191cdfb521615fca8483bf7551f19378d71c246bc0df4217298cac9726edf6776a50c4039c5876d4ce1056e6a2d834d1830763dedca859f6949112f963f6881fe63cf96387b8e2e4590ef7614d68ff5b9d34e42465524edf19918b5d42b0cb9606cc70cd4e4e26c4df2c168f08d0d8335db92df07126c8d2964aec5545b54ea3d960e92a2a12471a6b6d9d3c5cef60123baaca512cd34108c4c75b883dca767ad6c0ab1007648e2ce1b31424be5b3fc8854eebea48bf986477e5b69036e167c00fd1a48ec6838ebca85e31eb40d3705ae30feb734f7d6dbc744c116d3916a8dd5c74bcf063b45e99b9c66a51711d4d896553a3770dcaf402ee9c64165c596fe9d7a9539a7ffe6820dfdb3595adc9da1daac10a3e4dcc56fa97591df3855f0165c800ef42d868379f4cb74b7d9dca3509c65830d5bd00993b8b27619f054b59f99a5b576c30c16b8b877157a5ef3165e16c5647585a84b0e945d11b392286a0e9f966b9edb98b078e9fb079f66b741640bea0a702b75dd6c705de9d5c72b48063f20107d6ca283820b4818ef6a353b7fe55046910d99bf08b1a768163d9240c43a60e53d45c7cf1813336a4257411729c2d6510baf7da22d0ed233d70768f47c324b5fb7d285efcdb7ddb26e42aa3f529490cc9d9344b56ef4c624612aa790a0bda417dd7eeaadbb2b85286133f42bb81e7489373d0a90c76c2f5f016a20d199824c1b26b38473811a6dbbc81185fb65acdd5576686d1ee6e4b10b1713b04ba49127e4adea1c4cf3d63f0168faab9907dfd55d5bf7d1f350552d376bacdb389637d4b6ca3f87562f84b0011b2dfaa8d065ff9f8c438213ec5745ce2ccf8a4956789782abb260c49e47c56edbbcdd319acfd94b15fb133dddf1980ab9d9b1ada7b593538dabccb07b9923f046fe0b8c85c141de31099fe326342e408298a3cdae36c34061f84a7b7cb1f34feadeb922a10fc5e84e46fe5df2a42cbf249ca2f4a20889abfb566fdd265e3d88c2f38530adf00afe68a734749a1e3f59387167c7e0b300ff54494e896eada8546dd4598373857288b7ff3f2da8bdc3f55d982210e3fce9afd344f177ec6551afce70430dd68d0bb2da6487e4a2ec9036d17869cb5348fea0dbbf869733c6e8388ab5fcfec34c0aed79528e7fa7f39654b3f09694ae16a618429866f08172db2295bf77663bfbb36c5ddee3940b795c9a8b4854772e9ed6f94732f9feea06190cd28858eeff27a92fe1e98f69971d0f4b9bf3996da27d833a1d0dde435bf53b98b59744423eafe471cc73b081873bcd02981a12436751de7a5748553965607d73222a5fb73bf582001c3efc4d02736946e38b0bb6654016e5e60aa41c27ee5f0b8947faa58d610901a39194dbb2d7c4e394787623f7f83a2922132eb22bb738cb6c9d47704ebc002ac591930547d7d9802793be2fd5c5e3460d51094f94c1d35f402180c7593ed8b8e88ab5d92844a2457d5afe38913f224cd801d364a35237964b2952b7e4eceb8b5e4c590837704c87c6d9da7e3852b4a9d31febe2a22fbe9fe084cb77cb59f1bc03bc50dfd6fb2bed8c6ddc6b88d604beb206f083db193e213e8e272393fcee9c8468ebba0b07091e8c998c29ac804b0ae818200e4079e290383306ba161836d88f25e40e93ec6f4534e0d26b3b8142a465ee6a9fd8394b40652c8344588ad1cab80f62cada7210caae2c529737e1a76ac4cffc5ba0327583c394aabd09ed26110c1a1e16197cb1efc0965503c34e38c5fe64c3743e908548838028b125f863c023112b86c15a086930609434d23d21582d0a372a3021f569e928b6dd4c932600b18e06519e27f776b230df1b5ccc1ab6fd3ecb01f3a41111b55a23ba6442aae17b4c8bd19dcdf9bc3c25a3e1749c90dedc2865aba39045b7029ee7364e3e2df455f42b7cc0bff1559e085104d8002329b9f5ec4101a535ef66e0355fd21869baacc891c345d53362931c8d2dadef315be36163082ef59ce15dc98e09ff603a1464eafc20c2a056afad69afab8bc7885925176964ed2235708f3a21197028f6183b3e00397a98aabf49f9441f9621573dcb78834d764c1e6e2d31582450ea9b4ec056b67f4a3244dbb98631a0e486ccff86aab6f2ca5a3981633ccbadfa46a562088c3a92d77e5a78b8ebe7b7239382c8937d933a375154c104b010036880d886074a2a5b4f81a429197c833acb8cf1e1da5db9bb143408b9e8fb7de247213d2d7f1337c82212d174aff0ef3e86755ca5d65f70f987da6cc3c8453c15b3317c4635e0e0a34f58e5679d528db1beb08fcc7d61fd1957e145e32586b23b0e6c9f1e2309363ae9583879aa25e1f0ca45d14f0c2e268064f0c0291227abb66896248d3163f54ec181d7cf734e8171a8c6f36bfde80afaf075ef39fea7c4269b59a18b270147e0cc70c4511aaa52c3e041dbe6a8f0580a6772adbe0ff96d07568186e4fe85ab0f11675c82b1f64a54c1209baa19e5116c5a1023f7d9ae05d5b1b066931a88ede98d1101392f4c36a7e8affe2429abbed6fa1a61685669f1d191e45cd0f964e0a6d45e3f0b70f809695c9f2f49f617a04de1d8f7eff880f307fb4fbce3b710c2cd89b531f32389f5671107d073aafb174199b10ab7dc1184c6d7492a1c73e908410c36713c80347885560933c9b1e6c2f851ee0501a811071af22cfab8f2c58047dcf511d351e92a1f721d3e421a342aeed1e50314e39985973d4caf54a68b44166e2a372ce3157bc917e3a5214c1c501478c2ed3c14bd1e770745d5f04c28a1e27e286c80d4578090134c5e6c31c3944751d359ebdf22b928ab366f74fa53eac1ad8e62c5e51c0343e53f7b6b888e01f1a9a4abbe67512bf722609cc0b50bedb0997030dd3ad4dd75744584c7a2ab35ee686e3b859db890d09f853efbed88b0ab017e786bb78072bc7335cc5497efbd8904170f497782200a4157abb0b4740a470ea9e400d663fbb0c3fbf28674e8b5d5b41bcdcdf8e418d51ae2a40e60e75bceaf1a96c22189594a2200718783c8222b1c2c5a218ab5b0235dc0d86bd521e68143c93f53f16f4b438c2401f7a8062ddd4aea3bda0b86f7cad8f773e41890e9c0be3bfbe42167a560dce07a154b383353407c65a2cfabf9938859629cafeee217b69e32093b8aef536bf591804fe626b6a8c3d423c06dde8a9b0981bef7eefa9043c4591c883409707cc95db485545ec1c8b2645d23470ea9ae19ee9c6128c6cfcd68d4a7919138d940fa9a8e8e7360b6da186d9a975c9470bf3a243d9b1fe3a9c1ae24ed7f377d46662bb51fb66abf7e014f598810ee5128480b0e129ef7d4ca4a974ca526a412f28f720e46b2b1b2c43e058a7ef9d0b69db4b6335f8a82b1d3dac4ea96559404fce3004f0b6b11d96baaf47f160eed0071c09d6d61799222122e508b2aa1eb9ce50e355d0d6db737d3a4429ac76139a7a60b02b6875a501a83c7e845c317ddeabb8f5d094e62b18991cd1f00f1eead6febffe6a161c115ea2dc94ff885625bf8443561f5419602b809fa597287113c32ad72a74b2a6a38826f9c7c84e196a0715fdc64a03daff467c07858fb9efbffe1055776a29e5d9b4048ef8b5be39b1280a5fb6acf28f7e7d406b2140dce15cbe659109a812f156b794d965c4c5af8257bc408e086ab78328d92900ac45791b7b08b93f6e8c9b23fc9d6604326d60bf505010cb28910455d5659385ea85de530bc2ac9d7880a1ff5b7c2b7bac3f786ac79e69e94f3286c49d633991d8a61787d37ca994458c62ccfcfb3fa4b57881b752af76292bf05b61e7a120f918d2de3595c2bf3a7c5731b3485374834d8f4afe0a992eab0e834bf22317a140823a3a734964208e5a09b09c9fe90e68c6b47c27184668fc203fa73f3c686aec1be051bcdb5066871e552a469de71d8746560267de6a4a5f3627883828a13ebbb41850133a0951e178727847dcce1576c38067be34e093df8a526b71cf4daf7d5a007422d140ba870cb73fa932023437fb0da1762fde3e0194f569f0c6bc483d0559829772b91bad7d4ac302628c87f0ccdcf9285bc02f739312fe99c144b0e0bc253352da20b520dd2abd5ba4320404bfcab722bce401de88e0f895d7b0aab8f33c507518b1b6305fc67d63cb9b5d61704c6ecc66cab9e7ebb2fe56c6fd00a3e450ed4e6241d96b3fb1833b831d61d76bd5e76c62282eceac5bede3533c7e5d23ccbcb0864e876bd5dbc97224d38d93a95ba1452ff69a732795e54881f6d5369ae77992fa514a17c267199178737a679fe616c7fe9e06d026d82e499c789c1a10ae577efb1bb45d982751dd403ee8e9b52591df785688e23a59f247af2c85b135d7911e5e03d58ffcfb30c22fa83aeef8d66cdb872717860ebd1f726d6868d0b1381d4186b9dc08467a2d137e70aa24c76f4eecc3af56e0d293424c96e82a023230599a39e05086295c3d4ef86b0d06eda509393577006e6deac4f5015060a07c61cf8e6b5d89ec74fd40c8a05ddbd5823baa076f81e20346f6f445ac8ed6c41694bf6b8a9554c588ccba86c11603fd484f9ee73f590c22d14fdbc69c659c3fbc5e249a39d0329b7069ecdbf059179eb83de91382fc010325d6c40e2a4bb0c62fef0ba331111ad33148289f862e82f1d832dc4d4004ae2d7c80cb342ce7871e7bfe0a41e370ebbbb33114968144f7b8d1d12d98b60859e05476a96cdd29d1dd106038853085cd5b59812535ac15cd9e62ff22869817e97f290f0459eadf7dcc2cdd8abf7640c60654b9c0ce8b0774ae7ce4e142a6695146209514de4611327e1739d099bda420b85ba2e3214be48a123fc85e66aae9fe2787336e2354652588ffc0530ac4a73dee5e0b72c1ec996babb87bc94c204de63b17a8ccb152b25e258311da77bf6863116d544d0c5103f1d5b9d2de1824d561ae8b366873ddc1b1e92016550f2cf1eb0c2ad1016bbea44846648404ad9d5ece46d41e23232c7d3275ffe0df7ac1909889dec1368130e137c1b5a2b140168fed1b79a11c9819a46899220c3d9f7a96094011befb5f9070fd8495ed341ccba04ce2b0b60d199d3224f30ca649d1515909f7bbcca429037318b1e152f1629288bed3f401de48da13faced86e5e5cf24f4b58bbcf3b557e2bfebf4c287ae6ea7da00f124073357f6e298ba2d3439b041e162303d786675ba625b888949ba1b6a6c684980e06244d4b18a6d7f9d420a65d6340681a3e13f4928cbe497cc565902925c84ca17fa9765f79bbb23f0418617a65ee88fde07a311dacda768f9d6533e27627c53d0042e12570e64275adcde54bb39be76fc1ec4fe6c315e6ac0b2e5360acde0d87535c59619d4519e65cec71b675157c4351947ec4515aec2c6532e78d9f8e3eb1cf8c99460d12ec0ddde06b5e1cbdf4ad25d72f0c082bd22bf24dbc31e7caddfd8a135e7b7797018289782087bc8b59a95897c3000f84a65b27dc6cb128148a581252475119a365453bf07cb6f61856f26c199ca9f132666f7fa33658a45c83957c97906d0ab6bc458f6a38102e4f18d90086e22102ecc168fd18d2fcd0592a29fd02d1725ada608596999ac51b9471939b40dcf63db5e0149f1a46e59261887e6d215b5e5a3842dd377384a6d1f96ecf96b0e65cbe07c66c1c65c2264fe5ae39da2d3fd9d2376940346df183fffeabfc675d38e75ce2c1458f2e6ccaa7aa2204dcc16463eb0d362206024c6b753962b0aa8b46b6150b4202a2a46d0d6239025222f6f4ff022bbd0ba243e2e9569a55048d20079c6f6522b078fe7d18fd325d2a60397675e9382cbf91e70f0d0027e27560a3c014374b29dedb56d7c917c51efd55a5ae836f43ff953953f8f70f25cf4912a5f008df00036154b1ab0e57e6eea50cc69b107d4d85bb2d2e62646aba9272fc108555f1b7c32dbc7ae4318042342c997d83884aeaa6cc1674cb836d6b298469e6465e272f7033e9bb45bc291b13787433dd78c067abbfaf1e13dce9402bd61c0ffd591d3b4b8259ce6612092038fd6baecaf56705a1a98fd48ebf154ecae1201f571311f9aef35e2c6972379a26827024f45ad2314dcf6853260e7668e64c27d4bf1d44ac667ce40b17ec72e4a444b3aa1d6c120758ecb45d6b5cc82ac6d6db922d7129298e9d95fa0d0bc9ea90034ae7daeecde232d15982a74c785ae71499f6132f8dd62b0e82f775ddcdcd80f48e40277b902ff8e24a779ca86e4a5336a94df694f067748f03fd837a93eb93718b87a62b07a946a9e4960ee7d87ede04cbe69a5833b05383c60e177af5759c739e5eafd21219c49fd30c125e9722cb2ee8b748825b7e35fc233650cddd9700f43319bc2450c190644b7f5c63c730bcb2250256f13021dffae6c9fc33cd853ea7be5ca0db3098de96d359d8e07077a07ce33af3bdb3df336989443391bc4e120f0d5a90d52035c01bcb0fcbd3909e501cfe94ffdff8b600648902a71beb242415fcca34ff264564f85805411e1c8d1dee810496bb7238c665f1d1e7bf48ba16f9fa4d7f94f19eae53489001b811fa8dc36c505442a446ea5c078ed7bf68ae3809aa2c18deca2e2ae769bff71ee5a38650f4291d461349a1d469ffb2dcb84a062e66da92370346c92fd46a6bd3e7cff7e220670a183c9d577f593d854ad95e46c1131a6628d1b52fd19a4c1a7b022eba3036fac669929aceba26af75d1a1f5935bc8146959a3768ddfa6b2e89daae1ad1fb35966f6277ed6203ad06eed273e71555109d77b069c46ea74ebf37861d476fe6ab9306cda8bd74acbe2fde6549c65aabf2c94c1125df0eb30bb79bd464edfe8e753705f49baf3a19ed859a7b99483b511aff9f0da2d98d04fce74e0e0505023fe8cd085b809cdabff9edeabe02c26ca3d7a02afe06c7aac0d0c614969a73f44237df65eeae23229fe772a757440b86c4b1a63b3ea0aad223ae9a5fd8a4e4dc944df869ef6b0ce395611864e2a0628abf796c6a19efcc6213963b7840a01c2c20fde9fe6563e1424c0c868972e6d1da34bcc3018c8a558d6dd561062ea5f487170fb5670150e7c842d7da1b3315eae141787be8f3ab8d442b12cce819acdb590ce679b6cb3aa0f7640f7adb69fc704a2e5cdc9a9044715bb90d104ebcefe2bd865abc9ad13e595f769af8d30b572da00675bda3c6e8555e1b48710d8e94a71da757946f4558c24f96b3626edc19d81f7360b4469476a0c5e452a6bb0ce0bc9a608bd37899799ddea2e5160c042e86d85411df4de1b189aecb4661f2f82b488b1445304f32a9c0fb095ad282f8e16b7a945621b995e641185ddf2bc4750d9497967fbe0bd7e07a1a90f75725fba7e066c4ab8012f407e3d4891f9fc3cd926dc4329b973be08fce10f0f3a4abdcb5a93a8b98beacf5427f94a73f8e0d093c026f85180175a3d73a1ddc0d196f6823bd1632737747b5b87ead284da091db7817d3cd904403551d4ec4ed472e1fbf41ebc4d4e600fc12e4472f3759f9821f8fd50d2befdf96fba208d8825db36b991b405c067d70961db467eb1ad003047276f185df5aba43b096f73439991896419f4b4e0bd48c71283f9186ba17bc6680f17037c7f05e2c95f89f23b7a7f3062cf6075520181cd80a45e71a35076164fe1078b22df7c798e51c35f29c256d85b430cca8aa08b785e3d1aeab71282baf75c32fe22ffbfcf7f35dddb84fdc5f27e898195dc0969c9517aa2d504588e46c3968619d7ff38f515adcb96af9c5be674afd578af97dc47ff91561d50f2871ce798972ce9d3c6dc6a1b3df1022f20b8e5e24e3b6bea91aa07ced55e81ab7e6a696881622535beedd9673fa47d14cdc25696c53e86ab67ff63ebad5e4b6ec17cd93aa91c6ddf4251920a80a8fb0c03aed5bb2ee31b4fb81c9d658151de8851d9da9f023d8e7c1d4275c2d7a355117b9d16dd6764625dc3f75baccfbb8fa3d66e053e19fc6bfe4bd3a1663497e8df5bbc7d578a8efc808d277e5838f6d55ae9fad51a85a380be969f193390345747f742fa954c097bc91e52af03942e2f8ab9d41f136c285acccf91a90a0d7cbf33f12170c3b22936e0e43a0676468a89a04cf85ee024825169503f7188383a896c632f8cf22bab05a280d5a982087feac3084ab3a6f8346b5b53cc038b9c668ed5cdaa0f7a179273324ace45dc5e8137b23a5f96e3627ce38715022d6c8fadadb8c8d645704dc1337498e2a1cbcce9f1d41b4ebd7bc49b1671d69e69f42620bc08430e8942537f14c47e55915c6f7308b4573be9106a37abcff91474817259fbbf228e13b04aa2f4d13c147202b108040ac505e2eef1144692171f6887cca4898605e4146fd1c6cad9583ace7874c426a74b8e9237d61dc7342b48cbb36254d11cf86a78983b2b081906213d36a6c01aa8f09a24f38ff6aaa87d14440487f85fe359f5b209cccad5ef28123240920f862ee0a60e6c0a25e01641bff0f224b6114d03a0516518a78b366f5e901365796641057d279cbb06e3ad8a22d07ca63d5c7e538ceaaa40518e0cd3d09e42d16314e8a2b13013eb1f3779894d648b7373f402e19dca32b5cec50c4a88f4f53521d7055d7e10d099afa798ca2f2ad328a7cd9672682fa1cc923e67b87394d2d81da2185b241bbc42eebadbb3d38aa3eb0699dea395e2b5694dfb4f7eadc1d4512af4c721a553d49377a0d35113c503c2c85b622eb40d8ded01ae578f78b51c651c6633ccc9d19dcdb5bfa18ae520445d9516dcfec04e4cdaf91479a55a587a9c82f45b89af294b500e1c4bda635f0b03aacf7f265b6e99412729ffe0f6dd2c90e75d153f91a505e1229bfbe5ec505e3b937c86914c45c17a6cf1432867310c612fbd9632682fe90651fa897a67586a438457c62f26a93b17497704d009434999082ef52a44075e6acd0e1e7b5826db4502d3b1b0b88e6fa397162ab1aafe075f84e162c040f125a885544724cd4e1ac8e59456e4b07dfaf3a922dde20196b94741fbb3d714a3643cdd0ad9d54539e6d494af2146298062b811582a28a3765cb4dc21c51dfe11dfda982f97df1db12016c43a3bff94af1e78b8c6e62e11061ab4bfd4d61d90326be0d170946d4f7faeac4653cc94fdc620611d55731ce2c4545627d44bf5d21f1aec72c351e132e5997a14b25225ec9dadd0ec5b664be4d0b1ab032055456d5a75114fd95e60dc806020041d18e236f5a1e7ceefc433ae16d6a7e8ee2fcc01ce99a587676a4139c1c00c240f2dd9002711411491ecfee587fcc8bdfea4638bb03608488e077e571b08ba1aae15a8630a358683163f79e6bf094ea0e41a1a6331d0b34b59db29ec2f62ae6aa9cc23f8e5c2af0dcb80f8edefb7ecd9259f9672df4e4dad50482a75237efff30ff42833b9691c02892fa5ca6a6d9aa1f7bd077a239cd270a8b49a6a91361f32b6847996f02e39ddb6edba8afaf06a0c0508d1ac615f9439e3bd1e684dce8ca94bc216e9872222f31f68d1e93e9b5089bf01d3d05c3f8d0506672532c0eb4a8023150f494db9f06e0025d36ea14f9a6df52072a30532607908eb0df928c2413c6bcb4204e94ac2de0ff35412f7197ea4c9dc1a596895e0b91fa2e99c9e6b9840df930509d0840ef8104e300b44b640eb30fdb7e2f9e066cdc31294d5f14964fe5336533d62829330a6c0ca8b41b7e6c9059490f808efe8d21b56952e159bc04e7f9358fd415b20fcef0df95f86fddd4dbd02a4721cc03491951d063da6dbc14f38b56e84e1c089fa1d961bd189a60f1c418f4a08fe26736401cff052f2249050aba47faa68e12264e4bba0dbbfd07bb2a44edbeff12f6014aeebeecd0259748f2a29c1b3256d04d4a6b06c40c3e6a2b1a7f6d2dceaf89d748c1d7ad54de0b0a4b86d0ba1d189c300a7e3979c52a952120b0f68c080c8e2deb9d83bb1a1079062e760a3cc2c1619f6f2ac51b385599ae33e75c0525b9f603fbb87af188c5c8b2a3031967db962cd7645f51647b8b9291a5163f2843064f2906ed2bd0569043eb40856028b4b33a165e5bff096df1e081e9d74c2b6c340d0cda3021b9f6611ce1a9c22801303b7874f3aef78725431b39b889cf33ac2b64d894918fde7459e4bf1b50a6f5fbcced1eaa692cf255d887d0fb1ae5b52777b66c93ae1dbfd869f2dd826ca5bdd6713b1445e33579a6a39c2b89600d1bba131dba466b17f6ac889b2534095a02b04467c7186499e448617f1204b957351640d5e4dba7c5cfbef02748352aa2a487963c5752ef465d9ff4abe6f047d916ec9dac6808357d50a07fc0864d6f1c8a73388067983d9fb75d41339768c8bdd2646f35260d6560d472503f9f0d089fc2d79d7570f5a99d74fd74bfd1138f3afc977646413f5a979ff6818baaeb13996be1a3866769e90fb4c342b4f2e71e7f66f153c08d4d9cde3d392a8b9a252b07f7d2a6dfc281a60f19cb5083cffda6ee94607b399aaa43ff9dce76196a5d1ac8d39f8ef04b58a41d23c8b7de1d2c62e49d84b77eeaf9e8341b371d1c536843ac1e9deef8357c36b5a2108cd14f1510963339fe0ee458f256eb0418764ca43dfa98d8482f6b15dea93fccc6ca9bf8d33d8723e645d47655dbef7a3683a794f306190ec0b3a9b013ef5a2088e9214f09653755a03633c451744e199708fd7a7604fa0350757d17d13f1d22482c8f9d08b6f7ffe12a4cf1a7e46fc015aae4d1a1932c74ac4f240fad1876f4784da89ad11990ff80735b5a5a77cfe34d1f7e7fa4d99b9134c124387fc8e162dea7de2f1dcf47f5a3fc36b3b7d645541d5ccadbda16db6db4b8acef9365fd41b470f02a65531e8105b2ef60e1cf56d69ab293e8cc0ba7023ca011fb087b0a6764f47462284017fe36ce02888fe8dc17e083aa6d2885f01b4c835609080df9911d1419df2eaf70470b48b56af08f32a37787a1f69785e64995335180b2daff916b738e9513daec33eb2c42fbc09bea9156deeedfd6f0592cb90c3796c59e4bdc41dbda6dba190a98be4e88bfb6ee230da7f023a3566b781f85118246a2d0b1e85dbb0dc3d5152e281e1f4a83d7e238e8b3a19f93543acaecfa133b0b3db3c4aeae75754da159115c0854cdbd881f4206f2ab63e584143e4377a11dd4785ead74a5051a36f3cb282a6589bf01e88b3578c17f2b0be2d08cf761ea9eeadb98403c1477611e6cf3874c5fba38d7d966c973d720cd50c7c997bd607589c9799da552ce970f677f8634febee2ab0d59fe1a02380cad827a80d93a97c4c256352696da9c60b611a39bbeb72f87ac09c994b6636e4180073523db29d55cfd6221135cc9da2c2058f914d03de3b1f4a35d0e38a1beaed79edc69e78d9f8d3c6eb9386e45090a686851d32fff78f9a2c966fa1d2eb38f8b9dc86bab43c084f7335207219cb996869b23a0d20484f3edbde4aa44b2dfa4538d34be6893fd1d2c55f70864146b8e41a69f171f23b588e9c61a0af53918be1062d3d573c8dd9b47bae65d141927fdaf2d0239b3828341d447904914a8c8aeef40de8aef5d684fbe13c1a297007c5cc8dd47bdf7c53f81bd27207c2ae8b2bf96f6256eee4f283ca8d01adbd241564034869d6b2e033d8361fec5459a59e7d10aae484e3d31590be1f2d6e0f63d43e629387d7ce525a9ea9f6e0ccfa0d37a35e89affc423c936e8a26d5912afdb3099987a9b95e769479233e022e91ce1a8763ed6fc8da140b87d9faed12f0976ab98bf5fe3e970c1cd5b7a71542373f89ee37250a2838327a4e10b3bc7596e4357c3b04b6621f318fd5ddbf47c2615f13deaa639fb10eb69663720e9c799d02f6c6e914caae023971b65012d171074fcb5ace675af2111eceb3291b3716e303e50b4d914a96869be3127b706fdf9efaeb691bdb397ac061dc7fd71acdcf6d7994eabe968228b95ebce2cc0526510e8cf3460ea8e03dfba181da3f31b9c5bce87a864a8310510fd73e577ed78bea9d1066b963914523fd8a198ede030bffb9aa1040ffc943e1e478b33e1c6bdbb69b6ca1d257a86a69874e64a6192a818bd6698d7b0f04cc249904f3e3677ad91418239d8ac8d0065012c6c75b497a0cd6e35427ee9761cabcceea1c55fbc6cf5c192e4c8c531fea1dbfefc13f372637c1af187592c12b04097d082ee7c4bf5ffebc6730f9d032cccf0be835434803609fc9084466e6316577dfabe4a81681a66e1ae7ead52f75a97465b4c7141f8d0b12b2559e9c1e77e599c15141707f86215e440489184dcf354a31749e91ae2120d7cc4896784d5c9e23ae1eeeea982e54ae807b1ee2c2fe2c2a0d58a3710110ad1b331c0122a662c315f1682f32776bc2edf3f336f58f13654247ad49612b3a94d0d8fdcc60d01621bc16a4097947aae4e3b8b1985e61100615a81f45204dce811cc2304a64432332a23caf2592d5ff5821e78fd4cfa0c934e4aa11493a6931185ec1fe869ad6afd6bbce34756f979b4340fba9d079b2e1d4e11564cd0bb8f34852a50243e4d0e3919f149458bc056fd5da573159a5649a2ab1edc8884973a12c6ce36af6e9028455db82884f3e73b11d97b63700c59e5c038e20da4e3b93e41544d1b6042818dc78cb275b136b2605d04dc1d01d1b3c174611ce32f2450129ff7a2244404011c8417b87d9d583aa20550c398d38d9bbb82dcc99f6144c1818ee60ece82f9cc3c166a5146db5908f27af148585fd3e3f5be1a727cf3a853aa36c14ea521504e37b33f93c4d71a0ac55d70b5afbce9da6e279e392f96c03efc25302171a01157f29bfe56497fff1eb0085f8160f4fbd8185cd6a2c5b832018e4fa9f52228583ad8caa0357f2792d817d022feaababeafafe6fdf105ccbb2598a46e1cb3f08039564a2980a434272a52a3a382551c5e1da2e10195448870f0f213945846414b6fe3ecd64ebf266f20e2647a2f6b6b78b7180d438f2632af4ae3b427d04828c1a61a9480bf6cf1d61030778e5e12b28c5469cc293daa4a2f03988ea827b2fed26eee40637ddf317365fd6df95db42361d403d52fc1bebd0f66b85f32aaf7b7d0a0ce229e5d92e5cd7a23db22679b5d7083a741af07c09647bd4673b53dc9f504a4cbb19abcf2497f6d368cba374a1af996feda0ab300f80a9eee8308c61c2e3e4ec44bcd2c8545bf4c48003cb32396594eaf5cb24572c84d9d05afaa96cd86d8c499bc7f046ffe74f201898f129edf25390e156c790d16e029d10dc1d87b69814b2afd5f19eacab3a5f241f806cf54db1d297f45c205e1f1dd1b09d50043a89d4df1abd8b60c8b4d7a0edec68556b5f8e59ca3b53d92c9e446ca14382776d80327038624b2af35275e2eb4b27fee6035f30b6bafd65a38232b7b1d24bee45555f175fc078136c00756509ff2d7ffad537b88f2e5e93cb090fae508ad23e2ed5d095fe03bbe6d633be119afc623476c5b950fc7825dbe66812ccb9ae82e9f7ffca00b6d3022192f982bb4a62f4f56ef949230be1fb33115c7480e2f67fb56eec3e3f22f1646d4da6326c24fac5ae027958decbe20d0d414cfa4c0e648e033ac053fe7de2070efa5e5efb26723baf5047a570bf648b14b071089d30d0a1d5562c1e2e96506d35644c63308de76a932ef35582c0659331fa3acddb9b7d48db83b79f66f203965d5c2fb8e24235be5c24dac8532a3eeeb1c28ec337646e8a5fa985ead1e118a4a8001b2f954f8c371119b6eb3b4b423e2194dbc146f05f1c77bc7baadda1b04638ace216674c70d26768ff0bf6e423912dc4a28a41bdef6373f71f8921b5b55b0bff535747e8f0066ea3f98ae657939587c3e67df373343f3e545ec16ff151cb2ec6834217f0af152121e54874d193941de8a8ccbbcd5147b8ad928ea3d3677fdd3b4d55fb9f88c7bc7fefabd0183e8fcd802dede8cf8ab0aec0d06c2f3775074241c110d1fc6642282ab8dd87e1687a4017a05bdb1bc151bd1c12fd95e2835e48c8d8594fd8ec036552522a4df75c3ce45dee3c1d523cf0c41655264d9237ac7d71954d27b867f6854719333f6e807d0f1e72a3c60c1338e483238af2cbf738233256421beda80e25359add0cf2089ad101594a8a8e50b97cce94b608c355155f68a80aeb2aed01e7bd14a536850a85c34611809c937fc928de7df202126f336a89a1f2720eb4e709955da752a0da452f859ca8cfa18d45e407a09e69dd57e7bdb6064d2c2aa47c912f4e6a39c687aed53c3375c844e54c424949776f9dbbeda1b2bd5f9c68dab4588faf9fc235aab2822f3d2f4bfb8cd88f302c4a96fdcf1f4e095c6a2321e286a80d3d9f0bc0c0cc4fd56b79a1ab76e121cbb6132b1cfc7148f8d1049fd338961a8b8c9b86df4ebf9b1d075f0c51eca9ab043c118670d9e047108a427f068e44b9c2b0f69d20f582acfc18d6846e6c438c78c3aa6e4bc6f2916fd781d3b549958749b3f3961282fa976852b40612b7cbfaaa9cab91d41484fd04ab6d9054f5bcd52c334ba23f4e2030d69214d4622a857c8815043576c854bcb8c9e7b125019cc19e0c53ef7ceabd3e46b5db4cdea2d56480ed857a88f5e77eff2439117db31b01fcd3cb725a058afb5d987b14ee2e1ad6ab1e46b4bc29e60025b01138d7b38ff6261447e2e089dbcb08504d2175dd5be9bd099607f5f7c2f38d028e19d356be2d2b33e8508600c69131f4d5ba5ac225cea2b5ffca5c009c043eb4fc95892b13bedaa72fb465ce7a23d242d861600d143ca74e4faf35f36616ff426faf14ef65eca40f5b047878fac66e2f8c9ad24098b209405690efb6b5b81f8092b2845952548133782939f0b6dcab93bb014c2958015a127b40eae09cfc7ca13288e9c3fd11ba0445e4b5f8999c779e745439399b797863d48bc869146e7f45ed5d0625fe708a86c1fa835404c013cee84df09c3659d7a720ef0d967754962e56a60a8300f56e6e5fafef7dde9e3ac308d62903787b27aefa3d4fbb01a488263f60c22c76617f26326bbdb689b31e78ba741c568c1d3de35a9b6cbbbe04de0f0a7be1c700a3579db92c2f4d6cb81b44be11bdda878b0763d1d799b0a2e1a5658cc88352a3f851ebf7eb868f23424a3994d34f9ab10b07df4f9a46c8a9cc30f1498788cb38435a18f308a34b25a1ae15cf61c28a45067a293a3e8486f1a5307f3da06cb90d9ed67e96989fe839b81678c43cab507157393144792c36ba34892cdc5f789871aa73aeba637dcf176ab99439c0b295e5f33570e4423e78ae6db5905374c78f05937bda0c3d6a6a0234738c0ef8a283abc7d9d4858fc6e5d6567b0cc0f5f9855abf9354f8d84f2bb9bbe4cea91dea4be496ee432f1a3eecf28f4b62fe3606f5d6bc338d57e4a221fe96feafccb46e7d2534e7cb024871a061e112b1e1f3f3f4310a50fb41918f4863ffab5e3ab91985f06071319dd4b0549dc0b0fede3dc61bc5bcf8819358be1fa7c19300b63d851d17e43815997c0507b839ffd3c9dec25d06913b4105d242d4f7b81b7e958303ad733acd02089dc22f2a603d16190b146cff855e2ed56d39fdedd803c3d1e54345e7e739461b534a9fb8ff06909619e47c45f21486d9e996600ce93da6c0e5533f377900b1b9d876f465aa234e82ad47b0cef1d469c921b690b152cc99cf3de8b09214560c4fdb736a1ceaa3886494d7e53c205fb95eaf43995759c59330aec6eda09da14983a8c4acaee62703c357a63392df7c2138beed1d83710dca2fff8f89d97d7a23611851c21cef9024eca5eaf230f7c0de8fe2a2d5bac06a0e8d4e034a1d50b24b49c712338cb8018363d29bf61ae5c2cf459120a2d3ec9cd840d8b7f84e39abc4a9535062a35120ce0f145c51f420fdfb342c2d4f6e4327641d6dfbf89f89be27fa5b7ff89c2585a2b82fb476a776254317a75038e4db44f785dc178cce26184cba4c0d1dfbcd5d414e0adca633ca9a40106afa82b03d4efa6240c690a36f8483e8f1383a39a8fb240b07de0e0a0a34617a53bc837df612f8a5e69d2a7b556b316b1b0e6d45f146df8db7c7b06551c203b01d59721c5d73f64a827fabd2c4d9bcbea8edadfdb9407da89c4e2835f8522e519702365e0b68201fb5e4dd0887af94d9996c01938b6fa0cf3a0b1fd41e95314f2689789887d22f245697bbb7acf84601031b47e515a08fff9b191362fb6414c1dce8fefc5deff170ff3b83d741633a261c09c827d225d6a7c808cd08a6f1267b90525c6250f16a5e39db44ca1fc3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
