<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9590916305bc34888f63122b75682d70fc38f53127591070df759b696ed57849147eea21669fbc5cabacae34e0aebca0a44ea5b1ea18b42403eb06391ea6f24afcbd457fdea4177c932ef20ebcec12138f3c39f9bf0197f08d6d14b8d57c5beaf5ddfa055f88f0a5f65f3b7b75baf55db2eccd0bad03249a97ce01f6e336db638ac569bdc0196dbb61d498e49f50918c284ec6aea922e0d0ace3272f6a8c7017cef12d7e2c54896163c7b7d19e734ecd91178f25d316605c825ebe804cb8c5a143a7e415c5fa5c088e61470096025137e7a92e4ebd1357403d112ca3a916f0d40abdc2857b3aadd19a1225c32e27e4dc4e4be69f82d1102d878e2759e61cdd12e62a8cc8e49211a7c41bf643fe4177859e5917e8c76624ca0fdd1593af8ebeb98877e91d93c83dd256d9048d9200b564e2b248d7d22d1569eefe5dc951429cc09c4aa09d781769a1a88e280f82ad7d96faaf80786d75f4823bc61d5c49c8e300d220d39843b433f7559462aef3425126e5e2111674fb10bbda993cfeb52146d4c43f2b74c98b4c6fa742c17368ff5956d79481f3c9ce7584b544ea3dd7e99d1e361ce671095ca28e31ae3948b15b079d0aac380f20423129a7d655f6abbb9ca963d9a33e143b854e53d0939734628f7dd1e65608fd39214df1502149609638700132ae414424dbfe5cc1c8536377991c49bc4dd78953a1d24bec49f4ec230b3278fdca62a7c86ae5d2c0574052947dfffea93c092cec190482861a4341a11f4b83fae70a28f9c05890cea419bfa641969361ea09f19e2be414df8f673984ad44768a249312e1ad064d014453007bba1dbc7f75d028bcbefbccd517869dc1275360051a4a437a046516cd29b1d3e293e0129276cf2966dbbf8c40ce919f8191c2a5c184aacc2d92ec0cf05a5925f4183544953fb416ae12dc7c80704f546885b1cbb15957e6a80c9ffc3ae9e31dd232efbb1f7ad314fece5922c84d0cc48dffb47b2a0c9338f6a38d84c8c23f6b14febef59fef5b3348baef67c9d8bff24a8a14111b3a8cb83de453e3552b7915a48ca37b5b651daa5a37c902cb05be9bbb5ec5c85f2ce286638a71df14ff36e3a95f3acb092d4f64ade4cc9f96af1adeacee8febc8745c11a3795b088d388ad1a33e011e69fad36b76aa4bd16913316a613ff127e8430c788510d32533376ec84eff3ba5076a5bfc808b4cace0497d44b0be0d2731e546131e1192600bc27817927258074d8008bd7417fbeb36b5e5eda6ed99de71ce12ab0b1399b6f1138ed11c19459ebef927ce6e198aec67b0da67fbec007b0bf14a67c7443937afa0dff591d2d44366dcc72f5ccf1ee49f6d96484d74c2c29576f2c6d10357c0ddf7f697dd1932e9729e4944ca418ccfe6ac83cb9f76427f6b7847b7ce4e337c9fefc4acfda6a13ebeab675157339e5957e160627ba5f69a9095fdb137238c73739358acfd2ec46cb4a365c3c869a9af262e61e4aa8c6c12e4d75d3f8b84a9188de4dbec403b2759f4721aa412033c7c67a541cdd39107fc140712de668f54a669e4713c57c53a7a0e7fcdf20a6d366c28de5da2e5b473e683f221731d00094474c139757d812ad0b9e4cedb9033b4aaf0406ce5fdcb28d7b74b4c1ca183aba117fa343d1924ffa1eadb2746957d07370a6f03148482ae1a16946e2bdaf2b21c786cc586d32642dcae81f9c1952b5ab8dd1034256594f1b1899d83b1b03203701d7010284d14361656f93caa820ca46c5456f22b64c8a113f37b51e3342b2c8027027133e44f30abe17306313e8ee5d9c8eacd4d0422b222b79513b4d7a53fd475a316100507e2c4c67617af8f7dd33d73ead648f6787d405fcb4b20d1e2c3122795033a74bc54a243a0ff5cfd75af9f7f7a19be58ee94ce01282ade4f1c14b0319c7e9b2af665ff90754abd7665236a64c1473ac6ac916e1efe348e8532d8f70c112333e16918538d62943c3d70bae8ca43211c8ab2640ef9004d5df2f12ee4a34af33dffd27941748826a27edf283fba1a0ce72ecad5b9ef95e08f57a3110b608a826e86e835637b0b8bd13f75ca0fe45678882f07a130d05428e67da38871665a6f593d24c565e1018cd7d1949852c9955a75a41472d8fa28da6e47f48657b309d2586477a16b29d8c0ac6be2a8b504558feced777c4342d06f813964e219e9e7a505b4d48f926081688ebdfe209470dc0a18e23b17699ea541f5c9332ad08d12c1cbe5bc91b260351460c834697acce2e3df4746d79eda0e69a9d377f73d17b7a3704a522ba57c3389dcb4d9a58913eb979f85fdc453fbcdb1745f9d8570a34242f6c488dc19a3fe6c1450d904dace752cf57f5b427f456961c4d55a6dec6d68ad745882b60a56e5dfb75d4b2c91a7de44144bac6ef620cc2ae6b51bf69ce5d9ae8380cfc89eb5132571ea49398b17901c5e56bb5c9fe760550467054bcd7f0ceed64ddc1810b71043aa098f4ca4f957cb6c25d2d88035919ddae122cc92c389b310cca944c6da114171116acd40ff58434e848a86585274d015057846ac68e8ab0d56d72411595ab567f16587a8b6c30413905da67ba895ccb36a7a96e2d4f615893b3ae4945dbcd6de41f40eb80463158808f949bf2a8b2a150ddbb574a527a752d72a36bf0b8c6456fee6a709d6a37db2e839710d2011b788d64b58908e301288fef69299b049f85df49f754bfe1165d33206eee5e80d823a64953400b3d8a547d463f6a71a67fb93d18173d35440da3f440bd98b17c2b01eb0b83b5f896c16f284210861c664c746f0e9ce6bfa0521b6827821d17c4816773a3e75485e441e230af486c0636b760cabf9c9f54590648b35cfffb0c9faafa5feb3d88c89056cf35edabd9a5634b125d2c4604b8f1c173b4147320fd9a14698079503d1c4667ad88ea9076df8d43ddf90f193894a819f87dc498d2beaf0c63f8aa8a9c178ea6d0dee8c1258586526f25ca7bba188a13ba3c11b3acf994f54014ce32a9880e29a5f197fc6796c92877e3686e498e52c5243bbf14d1522b4b92022eb88aec74eb769cca42d723a7542acde4b2577a67ca5ff99069338c2ddcdba70e26d14aa0509afbc10598dc3ef0e28ae18128c18afca6b0a0a00c656acb2c69842af7a61b0a346c054b25736e9a9a330f6c3b74b29d29e21c63b60bff942dc0607de4507666426517fe50bd1c8af41736790854c49013a28c65ce02ff3dc20759dbbd7e7a587d99bd2c8c21faef15b283322b3ef4501ff6dd8b7a114e21229bb70b1c01682d57d089f9697c980fd45f67e92b69a5f9ca0ea623535be37c251e4eeffdd44c709c22ae9909a96386c3dd47f6ae3dbe8719d7c0d1431debd82fc5e03544896ac365491b3081faef59190584ff0e182064f58603bd690feced89cdbe0ea688b1c371a520c5e2f93a082cafa1879a0122fabdbf9d02378e8e4929b979b7519fe3297d6625728e980a1aa1720e6803f97f5d1eae79626c780d5e80f6ed3714e98a5d3d9bcc6082c38549a52ae9cdbd7f7371986275807fc86f99e4f82b40df1594a1b9387c92d7e68b1715b95bbadfabf013ad04f331b6fd2e0a6d85d4eeca86adef8fa40463ddbd2a750e4f191c40d7e92672021eb6bbc9eef3836667cbeda1d4ea8e58b2a72eb68d6ffb167a9f0a53787b68141f9d5e6a194cabac2e538531d464d85b40846a768056a1200a076908bd046161ee117b8a8cd09939bb8c7608f47106be7e2f5aa7efbfac6878f70fdec20799f0ed8b49fd2725e2ce81fb1a7db86ff27fcba0114b3e737f63b705687b71823dcf2623cf388602856968dd99b2a100821c96a553f601efcf0ffb9dc61caf638652917c054fa57427909fb1e235e19b341333ed6cd0f595461bb204028f8b5e0620677bf052bd21c4e2d23c56b5f5f8744b7617e34b96b60045487beffd76f6315b13f5d51737042ccff82de3e22ca759fae9d423544abb1e20a712e08a7409dc548253f27e9e2a222fbcfb778735b611029c9d471fd533bd8a109882d729fd8d2aa81bd8a1e3c6dab7724db8b60e75ef2aa2c0910e117c0e2d692d92e4472d36efc46a1baf54d74738286840a2afb8b2de78443ff99bde7f24af279d55cccfba391b988748e766585ba048cc27bb8d347b29fd52e36b53333e5d8bf96daa934345bd70c4e82366d0d29cbaf808075db089ec4291497f4b6c8649f194d85d9290532f5e0ae2845a9c19fab4fc79c9bb56ea070527ccc40eab8229a304e1ba8ad8b5c34c55a5d2f0103ab5ff50b1811bdcb5adaf1767e5bddb7c9681f40ace29f0a17e6ef4ed1435136a56bba18d3b5fe438896d2f527b9d3e6ce8f405572eae95181d4eef847bf5502b47dae4d307a9d97b0c66b5a8aa797f1a5cebb292db34c2656c0e8034e5fd95b6e3df661eee1325f144847e928d074876b3fabfb9a7253d14f2dc77e394e385eacc017bb31e2b9b61d0430f56f839bc7629189aee266870c4b8f5208ad4cdb4839d45ea6524f40cf6027f4091ae5239a303bd5600eb5166d4870a7d2ea2baf41e78424d0ec9c09324ccf40c4e24a4a47022fb27a74f91fa28ca5706594d69cf5461406d5fed7432b8fb0e4f0d619cbe3d9ac78a0148f4e9c4611bd891d10a9262276de7096b6a5962eead9fcf0507a8dae9af35b32bc11505bf348e0237b85bd132cbf0f4eebb5269eb0a95d743099ea140654ade0a1d23f22c9729c5f8e170d52f25a0585709af816fdf768be77c22cf1a758dc2b00ed18f80898e69a546146a08f94fdb12e7ef5392492a1d41e1f6dd71518f8b15ae3fb0ee66f0207b1da932c15f4e72f8139dc778d774808d454d4c2ea1169fcf9a11141bb9dacb39cac6473962a23db2eea6d46c8bad6b15665e994503cc9d0b211907a2526a5724630182aab14380166f54b07668fdd8a6fabd919b97f2bed9134f0e24515c5d6a35746ba0f78c35f4ce0aeda434088976e75ba24741ad6c128e415ef97642426575d13179a9a27b235ab0ad016418fa097501761b41d500da75eb10d522ae1e592395d26a0d023c403d53f73aaef385d6d57310c7577c5cc5118558f5a85840bdcdad4a41a607e17620e406ff357174b47c1d75aa836db1e622dbedd6d7ee84045393c694a2cd0e9203b0cdbfaf7136d44f6685acb8c5f8fa90248feb61a1ad2d05031d1d0662765e041bf4a7875d8304e076120688638eea067e442e90ad3c5175fdc05a69bc0cd01309afc5a4aa39607c010eb84cfccc9260c2a8ea57be3f876007a85425b11df38db705b418f1abf8a98d05010ec6c78a421f04f355d48cadf4a4bc3c8645a5cabbe9d2980bf295e1b8d2e4f72eb7ce18c73c30aa0a4a148c585377a6208254013dc6cef764ad76a593b39477721f9221cb3ee55cd1bcc47ba827ece519c1dbe694697e846cd06afd8bf87cbe7f1f782d8b2306905aa0abc09ddecec39dd9d761645f6540f34f87ec1c966ede40a6143a59406ebfd0a6ccb282aae750b5c820d798a84563d28ab7780af3f0204badcf5afcf5408a3a7f68cadd711bc226009b53f5cc8bf6d4aaebb5073adac5bff9991c03081f2d59e67d7b510f4290ef9ce9fedc7ff9da4b92a604fab6fcde478d319cf917aa5022a1f2a8f488793117ecacf6ef469b65e6d0ef1e273f2e9f1957f174be362f1e494b6a2bcdf1fc77573f6b209ab5e019ef88ccbc53a1b37e1c338ad89ef968a79a6dc860044892adc156b57ab1f3e75eebb580fc7190a1b739a3c746b6b223c2c6d9b48292838d7bbbcda1cfdae7dfdab7debb6f5c0f78cc9c10505637ba4e13d5259d86ffeffc607524c8a058d2206d9e86d117082c260beee78a054c52312b1f1ea10185ebbce29bd5c2133c8ae7b6cfbca1616021034f75fba68eaefb18ac8f491ab9437dee323b20b56ebc7d8ea9f6a55cdfb9bb29e80faa2dea5db21cd5d47e500cde52758b4861aa4e63713b98f1d664be4e86394799c654e4560996dd22663213bf9e3d11012b403e40856c24189b7f9c39ef07572a0adafa468c6f07a13daa3e3afdc17b2d431af078eeab0c1bef9291f64cb774b0936a6d00b7feecdd103b2ddf9ddfab5f57e5adc708947ba017f1fb83156e7ae5838d7575cf50716d6e9878357ffd10d7bb32d8c745d9a4760683d3c319ca2b50ae2dc6bf9418c41b956b7fea760c6fc340b62fe44819bdc36f966d042e99b635db7a816459bc6dee6454b3409c750cdf5b4c1948ed4151bff1bb7b209aa6797dc88c5c73e0c0943c462571a81a1ba15364340f44160b33657139fb75b1ead0e58469eb7634617d7b89fb869a52a44b45cc8154a8ee367f38f9e75eb067471cfe3da64d37724a43dbc8b9c0753395bf02c6b994bb7b7a42c24c83b0f6623ee2d9c41d8f28a3ae75253bbe2eca98696cbbb6a9a8c747739950db3a43308a3479210a4a4eff4e1e4d76ea6cb844fb4ca25155e6741e5a3452b498297f7e63489c263ca8809e38dc9c967e99f932cffdac40261a1fe97476de53f7e05bb13df8dd1319836d015a1d612c1903536edebd90057add48807bec044487140d13a8106d1042ced41a95853e5bb84d61f25db78c10449ebebf0b4f63c615a459bb6e551f8e4499dd27018df4b257fdef7872b270fc56cb2fbc8e435a031daaba7ac00198b77725f81a257544070dbb3b408bb5218749508eabb1de667405eee7d0714a737f14a0294402256a94d8e850eac1a3f9637dbba9655c352281fceadf68252652ad7b0d0e2f2731371b8e69b5e8650701b2e68c4065a36c899b360bfd1af7ee012caee5daeeb434943e7d66a9e7a35a35cf1b4ce3a0c49cc9958749691e830cde2a9c211fca85a7705e16a3ee2869b09175ab11793c80efa42eaaa932f226100cdd321913488af0ef353347a89b6d826501fa28f999371e6851215fb337c6f332a1d4ca0308ead3be3ffece12da75098742a8c8861e470a50f85b8b90556391cf5bad5f62e4fc353f9255eb5d71bad1b218dd5880a93990de5dbac29bc1bb5d34ff51433f32380d3dea1c26d60042b789011ac37ccdb46f82197a2d5ac5497092f7a8a3558251499bf3493504cba48ee1cb7c9a83550b09800fa102d34a0105a3ce84494713f7556d81f746be41e1f5ca09695afe62732b8c6476e6a61d1d8fa7bdb49024abc8f5dab844de0d638289f1933d24277d2eaa10f421142909d6e275abeead64122353dad9e45fe0772f7f54a09143611712cf78a21dbcabcff398a1465174140d7eea8f3661ba1c9e0ec1757f5e2024f26fb1e68b7f21f5253eabcb32e475f5b2d77ffc7dec5ed95b1651da1c656913831db80c92c92f1669d875dd0b6c6dde81001fce56c6cd8783580da75ab31288ebbc9d9a3fa7feace16447fe0acd09c7c658880d9fca6c471430323cb9f9168836e767003406ccd49eb2642e98e487d21ad6fda2e40d55ac251b75eefbc7667feb155ed377458c798794a768874348ab066aabfed4057331c61f25e31221a06ae9d4ac7d38aab0988c9e7de1366173361d519bfcb830457ef07ff1d15a7bd13347f9cbaf615850ad8f950db3786d33cfb88322f426947e3c8b1621925bda5be5794a77f694215791e0d5c25430df602cbae8ed9fac0c8e231d0c27564954269c6a5b33ab7e6c1698eebf84270110c0f58f0cda5eb3d916750a91ba47f3d722a35e52305022aa332b5f96bbc27a3e0675912555503baeaf2a7dc71e62029f085226b11fc519f7d4f1e92b8411a8d3713be4ceef3eee6f2da22008177cde7f62645299bf3b27fb566188aa55861fb5ff7d176fb6554fe9d32b81360ab819c2d9c35177c043d36af0c29d1257c86ca774ff960481dc497c96e515c7f065fe490a4271238ecd818c9f83a8673c306b4a47a658efdb46e3c3caeb578f5df56b0043cc486c472a581f7354e7659889efc237c9ff07b4a66934505e3919af3f974f269afc1fb9943e99be62f4adb05dde72d6f13a4898fc8fa48f33122f20b540152a196d889803cc84e60f2e1e3d1b73a0a864141df5637ef3ad2494ac5830705619645faadf615858f955b61bf75a5de125520acbd3ae92995fe5df6a1d9ff5dc66eacdf88e7cd4d5a80e016881de5806018ef90eb67970e6c2c1176e0da12193d6357ebf4b041565b0ba5f9f29057bdb677c9235225d0cf6fc2f26d90f676e715b2e8c0d4665b8be923f018743f9d1c554c91de7971f462907be2f899aa9e886577e29eecd4b4bea8e295a7263e4be8d0dc89cf671a84845af839f57626aabe6ec6aa48599776962564c5f4b53e4c7d81243262bda0621e14f2c3b34bc6ff13e28fdc3025cf0b0f7144dc4477dbbef6f13b1fcf956c904900a078408b003768cf5238bab4177fd489eeca08d470d942e6a6b371b77310f92ae74e5f94fa139b9a8df65c9ee6ae8953983f75e55d4d57d1546cda33c27865304050973482fad5078ad741db3af437475683d92be5c8591ec2ad7b3d0d45bacdf5d3d195c6ede0edd371f520068765d87a11099e406596457993e4d663095b1f9670ac1ae6fef9487f353c51a5f0c6f2ce35b3c613dd077da714ae2d48540037e5101963f8d8ae7c9e903e7ce099f29cfbdf9507e8b0916dc93a8ec493015c6ac445358d7f442a5f7566f0c67d6e576f3906c7bebffe507f8d9c784b9a895ac17a9a518c2581d49e85d2282c24df94fb90a878a5b524507af48710a0004a710cc864537d715e0989a6c51765e96a406aa2a1bf7f147c82a6280fff34d0eb0c95f2c1fc83b384e01bc63975bcb3bb18eeea251db291f426fe5073d88fe26526832137ab33c87a6b49188237d753318219e1117769a415c15a86f3460b9bffdf0fbabee3e65cef900aae0f06e18a448c5eefd53c986bccba5552c0263b9d4f24dea053833989b9e60e9199354499a0753bc588f7f264cab0664430fa020e53b25ddaf8863420ad564d067253dd6101d1698c0d64c025aedd88712a672ef8fc6594178258df3decafc66628fadd6f278c6d663ae37d561e7702a99878e233ae486492952c96477bbedfd7a1d73f86cf72a7f201ddbe8dfb8e68b8abdda94ba540910cc06eb5c4a41f91269ae5198489310d4467365af11ff6afb5852951b34aa1176eb53f7591beff7f3577753454597a1587ce84bd86b213c4f6a3cfeb353ee767e91fc7f0fee9d06f34fb5e19e65d385434930d992c5bc2b3c03c6420dcf89d8cbe9d89ddf925c9af9237f6c06244823866d26eb52c24155c361c927eea4bd2682170d602bf83c77f3a7ac9cbd6e959e0690f64679dad22f28ac12c40db907ac44b4855ecce4c042f2287121e9afc347e2212adf73262c120009b4420b9b7e8d301dda24d98bd53beab35a4c4a0d4f32a1a78ee4adc8be6a6bedd31b310c595e025e7d6e32d1b2f1606c81dad02661b51ab80fe9efbdc2b5f2f9d022537707df1c27715d0842d4e0031b25889a0fae9e6792f87defcaaff9c4be615b2fec103cc2c0a53e877ede7e5efc67a1e3a43fef66996d8e63cc2a8b47144fa09218cf6ee488f83be03dc033e1328cfb2595c9cc308f8fbb215b0a9f5699bfcff51443c10e92fc29b36ec2667fb4b6348c3bc0de1a47661e87346ecce7b3f3fd1a6a12348fc078e7c8d54f459ceefcf757f30537729f8a34bec7b75badfc49d68a654e32affe0dc7692966bfcb74f0ea42dbb5b431fbb6c0856c3d5544329de9a06ad63b6917f9561e7dd605ad7ed8f618573a526b238dd9a71a7d2c1145630fe1f22c43ad9229831ac8fc716dc6c54ac09bce11948d81c64056d919accc1f0fd27c68797c670ed35c545f9ae98e28addd026010110a356222f2880788746c995bb6b87368c5dd03c638323b269a50472524042475d6667aaa959ec85cfd9087be9b1b7f57acc1930d90972f1d7534e7c960e7bfda3a98b8476097a1fdf11e689addb45538c81b3af108a6062935652ae641889b420b2f4366cc05945a082d485995bdc5162af997c699730bd767d3d7576391166fc1f62003eb1b293df2c186c8a971be803007ebc1317cc528341ba74293a8cabdd615ea93d07279d1a0a1b5fc460c6752af307130e5d391cd878e83f2bd5d12839c14513026e33a3e4e67b35b53127e9601bfaf8b2fb6c68375cb48cc20c400b13af461d328b87c5e06bbc8637a10731f1459c581640cb6fd83babef0b6178cd22d7919c69af47ea36e24243c82728e1ae60fe64be66aa3005ab33ff74b1eb5489096acf2eb286a04a9f88456f5af8c7bd4cbefecf72cb0d040424c530690942f542d8ba36fe9b412fd2d3042416fc520066841cecc8ea74861f92cc2494627c938a91f4b007b22ada713acc6e81afa37e965a0c488a3052cc050e9a225ce16a6ed89eaf606346d88e3ae454a25a97c6271c46ae48cf62777d3d4738065c4cfa06129fedd474360a6d998d8aac6f5e03f293168e2d03cf3cd985e82a76d50d70683c13f2acf106ed17e554b7ed6765ab91d743f3fcbae363a031081dfacc16e69963b3efed8b3ad96f2274d037e741ae4adc2db95c31fd0d628ac384c74c8c8b19c09abdc34aec420015023848a808fd97b89a020390c178f4ce411204cfdf2ca551b9cd9a4cfda1fe6041c97df16018bc01a4df52994a8b109170384b84d62c9f7303c99b17e6b9c2dd91961bb50a23a26304b5c665f3b746939bdf6a0caee370ef23a8f0ba74614457a65c26680aab9a4a2f6bd85b9fdef589775bce76e7a7d2239c9458544fa89adf0d917ae577c4d9319e3e7a442477d7551bb73045a9425a5892b1bc9ea5b5aad364fb7e623858063d7fd5d750858fe740acdc8bc112d912f3cc37cba86bc5f92dc1a34b68c5b7c110adfae4cb0de59cb0d9011a29bdf15e1f02f9a939b0a3a4d1ac9d52e93746c20b07b838ec5377e9d2c420432a158e5936a33308eba51d0cfc5f0f3298a20bb2df5ad2579be47b3a6b897f8555b62d5ca32d8b1333d9a1c120e5e16c900688fac47d6371b348daeb597e60608c943178e6ead84afcc5ec3bf3603c6e40aff1d7163d603b71eacc9706c033537d1b36c9bbd499b7a35ce251878e98f0fa43dd5df1a3298f819281ff46dfa54162241f545edf3566758b242fff216b0bfb3f62484a885ebec0168bc10038b4d8e67526ad5d9ecfa15d497bd0f1ddf551818c3ba16e8d7fbc63cffe2be5900a4a59f6404541d854af32ec219fa28b66bcd337c0cfac197355e9026f3bce9c906b2e2937b634af8218f272ff504905229df0b4547ee2fc1e5563232b7503fed3f746cf2a3b1cd77640189e23126e62e062343698074fc1ec79f1c4a5f8e0f2b841cbd13289b9fe764123786bdbd1dd4c7f27cd2d5d11c6d0c50d69201d9b76b54c00c182904556632c9ec0515a70f457652d922f1e0ccc2cc615e276481571c49afc5456671dcdfcc98f91e363e3aed1a997d6b52d303ad3dd6943f672bf78b41dbfdc63b8c1672b1f823945cbcb0b15e4f9dbbf9496ea967c7ce2cf763351903c8b026c00a0afbfe6db5e1230eb4374978025992d5b681f2fa892bf272952524cc93d444ce00e536a60ec488442d8a320c1795f68ca8894fdf52c2d4b0ccf888c51738d27819e1ff0098682f2fc0b94bd4e2dc393326e9ff77d7fe0620baba612cd95131caa7b95ea8398fee0784386731ae419e4922aeeeb8f40b4aff3d24e6e65ab1d1af6df000ae90ba302056fd6ab87ef94e900eb61c44046981782191b814126e00eb05cfdfbdc63ad0cb95d1ffa1db0b3e2c4e55e02e2742c24b6d67ff83eddf90e344f4d0cf22becf2c1facbaed3221457f60e52590b6fc283af2aedeff632678337ac7f6034351af6bf5ef37e95894fb52f667ac37073f614ab3bd9e0ae155965cbcd7f0c14e5946f6e6ff30dee9515c19051aa5bee3b535537434cd82fe8deef98c96448814690bffa8effff4243d3663b7dc665e47d6b73ce40f3802f6f595e355d9348970eb972a8d8741847dd3177d691ef90856bba2f6a858eca3533ae60797ac899452572b0a4c6434a77702cd61d3285bf5262e6797bf62550c4d2c82c6504cbf2aba914cca59d12bfc1b6f27b98055e135571a0f3abfe99492d92002b8eb0acf423f35cbd5b978b42ea61b51e0d701cc904a42678af1956bbac3e274156650d92c2b9c3c70de4ac46263ef4af5ae9648682bd051686414643bc83887b970681140bfcab0c23934b191b22e87e1c5c25a229818a534415ee81051acc28414c999de8040fae28af548c851fdd2b1b0ae4734e8e4bb0350b081a0d7d3acacc128479f7f8a0c4d6bd3536da7775da133581eb97377d1c69756cb12fdd283b212d41a4968f998da1d53d4edafa6e5ad691851b542bd882535f0566757af577c08e6f8a75c72814cf43da4da773a35516e224bfed1e356dba2ec2b388c70ee9fc81d5c8673cdcec79631f575ba5f0ee93f823df9eb6569971a7a6943d57841f76b37efe0fe84e80ea7cd6b915674246b20e6949ec7ebc0bea48fe9f9ec09910e4cd7365676bda4f2b9a414c1bb8c6e4aebd4ad82a7ac838e93ddbb335f12a5efbb67baf0191a474fd345ed69736d28a234ebca742fb2c4dd08af554cabc54a614a2cc553e10c91bf0483c815f1d887e54795a42b5f1b85bb32bede9baeae57b4086ea4d65f7ffa8543aad27bc2315b5e74ccaa47f402f9ba33a604f5b7c04387bbd9cf8629666f4f325e168be524cd03fca85c66086bf205133c663f22e566a2fc4524ef87c68793ceae4140d999395bb88b78460d73ac8e7394a158dc4f6add95c2e474398a41a571a1974110c0da6d5c0183495554f79945e280f6da7e0dc49283c1d4d224b07733c9b6f6f0b88dd79dda34bbc68071c3c4697ce7124d441caae0c1368a3f36c948aadbc0e648b108b3f9c5fbed31acb6d42d74cc9617d3fcdbf545da6d9cb2139760596076faf98fc2ed6609a48d7ea6db56a6d84fdc5b9b7d2e2c5320c845d300dc286751d4e57fd61f4b7e9dc0af36c25ae7f7b9fe0a95ed112f402ec949ab1d3f53c7a69e11c5537aade6e77c2cdaa037558a153e5a962b335cdaa963a5b5c3b36f10f8fbf6ca12c9c0ce3800d1363ffc5013a36869ef0705e4320fa0bdaca65ca600b08a68f3f2d8b848110eb0117b56f456dbb2f7f3b7b151a54a43d80e95b1df6e7f60165397f808e65dfc9d1639bca51c9d794dc1d9b5fc9ba7594f8eeb8d74db82fe4f8b9f7f40521732fca27a99eaf5d5c82d9c921e2df228a53c0123d0a930782ce7ed2279800f4eae6a09cf6a8e449ae4d29ad1d0dad6a32fb02a1a0b7ed17102e15553816399623c845cef23c36321ba38f13ba856c9ec8f478536683435895eb54c573827cd69f7f01d6137fb3be93e23a2b4b1b04f78c6a11e7b7913b64e45f82aee3b4770fb2d75a8e346b3b20440ada8adeb8f92920018c50eb0694246dff80edfc972104ab52d955f975f45a65299156cce234cd260461185ec8236761bbc91a6f1d0ef974cd55118fc8cfdf7f21a7f5556a4aebf97db07a829278b978f7655bfd7d2791d51c0bed79aa7ad635b51831dcf8f1ec8adb5738f44ca027883b505e0852d55cae9582d68719449eacaf36cdc15073ecebc9784befdba0078e7b8c28f71456774f20acb6ef38d3409ec7a5fcbbc4ca4fc63291cb298214aa2ab158bb28fdde2bf0a85e1bd4b6385cef1e8ea21f8ade49fb5fb306a1cfb72a9d83c6500d5063f2279f6beb8c3a4cafc899b282e6c1e3081f9743c29ffcb2796191b974656e920c57647e5a546570727e3d4af9ac96233e76c1185c79a2500884b36a67078fead1bf0d42408913b19f9743a7f166a402270d8a26c41cc7924754786fe333d1632625fc8a5b0c7e138f621405079e573dab12625f158d1d865ee84049f9707bce0e05576f6a09af27442c7e704ea6cac65249298c171dcabc65ad2ce7639a513ba9195093d0f0055157914c1d10bb2740bbaea3d22a4af2c7c3b9faa8f1366a16edb00229db8c88dd2285070ca133fd6c96afadc49bedb5d5bbb91fd116c14e3e4df33ba9ee86b2091b8788e514a67a7f1fd08dffbd5483739cb7d5acd3e3664cbfe223c3d84e3f07594e99a1be8054fbd891d31e3312ecfcd47c9b5c1384d9715bbd2a38643f75f1c1d30fd76c1bf295b1ae14969dabd6b761e6bee0918026bebf5b6c3a18809478e9ad9d164931a8e0fb3e7112fbb061fb81a9fee7b12ea0b4cf78b9181367274894bdd226ef2d09a1d55d9ffd741eccc4f77990713291a920e32a972c2e97a184f3ef898853c80fa2bf99ae2215de3d7bc476071d94030804aea83c01881a43c2569a6d909171d52116a32fc3c458dddb341edaf05ce97bcab2e925771786d2d43403d928be93d2737ad823f42b3867a02db379385c6af3a38d068d71afc37bf8dbdd6e503392f5a18872ac9fe7d2fa94034becdd7e1646478430019a79fe4f9e4c49662d1cb360cae099b7f894c02986d9ca71264d4eee3fb21d791c37c5b8e3886a5af483cb30d00b1e8ea04004cc0c3607fbc71ecdb44d8ae1b5857e80f72f5ea1cacf8df02786e7b25985ec3c43d5efc0dfd330c83e42c78b47f077054e5590090ecdc5251402e6597f509ae7269ed3dc3f168a380569d389afbef50106b58514dc918bf5c3b3a68405a2df2e3559f7c63defd8018527865a42c8bc9651a7338ab12a55d43d3b999d7e0ab0ac5c7b7d644a780a3524fdd5d460fb30b21e2e5b27f2479b6aca5cd59f81839d6ca2a32ba003ff95ce853f3bf8fe636093182ad69dcd81a511f6dfcb518ffe38c792df8fb407f786731acf641c0664a82a213510ecca33a7fdcdcda26924a925be61ca763fbe48e93f424d20d003281d7ae228fd9fde635ff22c4bd208b6fe4f68ca07a886220d146ee2e61b5537ecb9d36864bcd6fd4363a1ae80723b9e3635b4a1f4f3a0f586b1eabb9338882cc5ceca2313181f14228377c8f47d01b4c8be6bb27ea7d7c7fad40cbc0dd10dc46600fb8894140580a1afbe55b887dd24162196d1ce66bdd3746a75ce376c74c93b2c74fc8d52010c2ccb2d50d36d4dd1b18da66a46e9294ba740bc946e00f1baaf653f1bc5334fcf60cb749129e6b9aac2faf490a32b7f6ad78fa634c0730df92f84b225bb72732770ceddb0240e07076dc9a979221430a4e4288711763f1fe6e09271b78129f05b31ac95ee783f4f51eea64a3f1d29e187e89eff4b00f5ffc9f14b6fa9f7b754a6ede76f7be87380cc06766cf98c5f149ea7b21612c5af93e7749723d46ef4faf3f057323c32ff3b58f0af7600c173c2744bb31045a26af39b8e8aa8a2462d9f6a6da2afbe161b91432e70605e8da3151d819c46fc28736249d12ed1e6f48a04c161efa5d72ec3e463188bc86f27896338e3b88d9722ddc8a335e1b987b963385fac6e86b91b171cc4dc99fd5e4380389c3943b5d1baedd8567ba07551d8d6f09e9b4678211b1ca1da0966bb79893222f9a6aa3fd54169358cfc0de9a1de53c220daef6a22e3e4c3a6f2d78141c3bb47c17265774aef6e267c81432294488621634d8ed77678844b5cf5a306fed1dfbbac3bb41b238fa16621390d617d26dfcd670e3186412043512768b68cb47055436e0269f0c111f52cc554018406cccad9cf81e44781b814c188bb91c2b7ff0f46e3a259ca6a53a1b21b93f0b03d1d94698caf385035afe793726bd5dc14970115171b08e7dfb95c92e8ca09ebceb74c73f7e132acff0a19db15f27004f78e53766d310e1dbef8ba9dea52043ccf797570a89c08b352f29ca8fd0a9674c16d2b730a3807e6c19ef05900ad681cfecfd59e136fff2f042e38d076720faa8c83d39119f2ede71a2b1dd016730353822fef078752e4c261df9e18ec89b5bdb84c70cce7b58d0929aedaa29a85c1b98e2bcc16d1ac30a58302b29b3424bf061fef7cdd8e5c4d2789873e919ccd855df6de89180342ff97e7ae22f0b8357318bf044c01dc786ebd4a037c67b43877e20a4df79691ac6102a5f4c7c4501a5edc99e916e61e634d19cff373233d6f5abc8a7b77e00c137ecb5b2f6f97dd5b322d4a77d2a94313d1b17cde9cc3992445597b8569dbe0e9d099577cf348d1fed26ce917b488398dd25c43f27e7a3a8be2d0ab6beaac20e90fe31b01589fdb8ed62995803e6fc8de1bc2df163187017f465eabd358076a9b0f6c6bfcf738e1d04009eaf15c9fc41ece0d9a970b906840f353117c7d704476b92fe545c1be91de55e841ee822feea1973a34382e01a2b5ba7fb9eaa4c755836d084aa6cc0e84f1a60365343e16ce168634a006def1ccc23996586bde6e0ddf180fff8bbbee69bb8d4ea621b2b3cc6854e75c6d6c5fc28f46b579c42f7ed3fa86add5aa97108f15c342c073db226851a12ed802a7a4c4e279803610e3b430f6ec9a926949cb78f83c2dad11bbf94a1b8fdc6c8f2ce28c29600ab81309c64a4f9b54916f7354223016760de3e8d239ab743f46f6ee48ce9fca8c7f15f8348d58f7261b8fb5a735a6d43eaec4fd4b525898de414bfa32aebc55c1ec2184c01a983c9c3dfba549f4fe77b3a1b7e7a9b313da628b32db045d558eb26c74075c023bea7c8dffff06c1873ad2f6a02166cb0ec35fa614d6ec0d47254521a14c262526b81a6d901a459fa2688975d8c9d0fa4af8de13c69e7d03fea0b9453262c661426e3222e74aa773e76931ca664ddf314a02dd6348e8d3965a424a1d56000fca32097bc7b858a0145ba700998cce9b55b5878e93150b788ddff96601568a11973770479ba32016ac0c8d5ffb854855701068774579343585d5c0a4edc3d8b50d491defad6abf4d6419c724e664e20039bf653bb48987e0388fa9aa551bb22604e53eb11f2fabbf852ca73c92a2bfa0b08449d2bb8252a785844c5c5e3b810a95fff93350fcb8eb3a046d1bbc3bc497c0e3aab2f8655e2ddbc771d6a3b4112eeb65ab7f31c9918b86a039da8d66b643e0ec33b5cacb63a3a2aa4f11c5505bc6160938a8e681ccc818f83f4893001823f2b10461bc6d7e6bdf7d40f6f42a188cd9d6b3f6b863421d2de736142b742dd4726dd2903a1ef77bb4964b8312fbb759826ca8be962208f9aa76be274e0d18e472e60005387539514898a216aafc5ba696ac74c96d17d431a9bffc197ec114f056e2b612d99b7bc3eefcdf2c5cd7f57af7027e89f1c9dcff73ba8204891c1a3bc0be1684b2d482a8723ae99acfef7705f923a807e3fecb57d6a7c0c3cc3085659d6bde2876cf4c4bc67771b0cdc1fe51ed9e1d9a023f3bfaf8b7c2c28d7b72afa2e165316b22e702fa2583845016428c5d017dc884d5b8aefe45df310161b61a98b8045533339e534049c85ead3ee2a04666f18c18b38abcf0a1f0ff9f144bad3f819b757a98ff8bbbf561bf02ef2f5a5f05814f99c2d4468e5c2471a12f5be9e1ae1a88cc4a3ae9f22619f9978145cb4ca44eba6599b437de8c4410aa503ed081f53ba1612561ec13153360d026912c72fb0d2776f5aa09a5dad298dcf6935e66ffceb069c78f36107a863f63f877d0d832696a19701d8da727de842daf0292b0ee3f8d6554743e188b452e46170d76c7e0451cfa774f1ca7386e90c73b21d76bffcfdd023b8f5a5dfc90e66634635eb845b68c5a4ee20f924e714f01c2635ac5843ed7c4031942689b0ad6e6c19483ccd335224e44ddeddd48d70e988f5188c17a6caca8101e50ce9a0e50d834ab9b80be7f4c3b732e867065b3e6b528479bbd268dac7c7e4be6948f40c9c44133267753b95cf9cb36247074b4f8191f7c422c8828c317cfea751c81379ce28362b1067c53342794b7cf22d0bd77664ee7691a809a4e864089f141c0c7a041537bc4401fc95570b3bc7a0300e1ae5ae749b0dfcbc5c34557ea05818e248a9ab6d8a26f1a7a5adea6f13b5df631cb4e1dd92e99d130fc034ed7dc54cf3d5754a91ae1be903ce2375eedcf1ac2cde63558b98f4273a6fb5a38fe78b0408e2c43c0866b92a5f9f63784898286582827b814fa86e9b583b193ed70abbe76a151881c2761a68f99a3ea2cbb1e017a99f9181a955b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
