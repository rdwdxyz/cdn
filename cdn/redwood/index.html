<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c30c325f2d243c6b5be8a002256b4fad655816280906837f53ca5712555d076e656ffaf260d0033fb984d5a9c2a75954e39e5c2a23164c002982a4a57f3e60e789c5bd9933a0be8ecadf66924f69bf907c30233d64c05158806bf1bf0a1861d0a6e053f17f3994fc4167f4165ff7baba2cf8f7fd94608b5c54075b0ebf05c74091b0487d6b4436217310895ca4318cd631c006590cb9afb28e6af58fbc004b1e09cfc6c383edb8634afa004ea01c99c3bef9d4ad044d0815ed4ae7e0e4a31f3a2f579c8821649050968b5eca6371abcfa77bafcebd1d61f51194a7c52d27a1b235d53b4d763103e349f6d6c7cfc1965bdf3865518718ad59c87fb2a7b53fa0dcc641b501ad801d29ccdca2eb5363e8f13b890f750a6a967ce5f636e3e26186009f6e6437761d0a28b233017ad57b8b9bd988f55886e78a1e7dc0c763264fedae83ca4603efbbf292b54ac2596e9923fbb7e48c46ce1b8d67c41a1ddc355f4f1c3925ebd6aeff91c6cf09a42dc96ebe3d52a2936079207d4eb98803cc9c9cff18315faf5e094dc85cd73a85d2e9a26dcca7c970c413cc8428b2a68d83ff5da5ffdbf8e17e90aa1ee512c74a9d382c1fcdb5879186ac4ed59c99328fa383dc3038b66b021b8fc2bd06b3b54d133f5c90f544e835d1f1823e6e7d4e5ae38fd9b93b9dc63eb2192c0c6f1aa663cd74784af08d0df17401a5641528c975e51ce6000957b27ce7e576aee20103ca1c490312d33b2aff94358119387ae039e5efa286b5fad67fb7cdd940ecd07be24bcc7a54693fe1bda9daf63fa49d4c3f5fc89313627df3291eb0a48956da7ec8ca08c132089ef2f8d64dfacf17e0e408e41f674467573560be4ef45f21fdbc15ede89776eb346de3fbe0330ebce6e2e558c407bf6d0c82167de478c707cfa171fe6ffe9993ff55e1e0be2e4e29f51adf979d1f70571a3b159ce6690e00c92262e32713b0a8a700ff75d0bd839ced79582736642ba24ebb14bb963953f86bb6cb8e12b25729b378695120bc0e5436f1162517c8ef500e0d1fe899ace62fae9f65092163e3ed936f30df81bae30a5573affd77bb82a75cc7121896a0c49368edeec96308c9ff40e5d9b6442bf86393d43f24e45d9874f9bc3d85458169e859c69b846503d8bcf3492f7841e6d9cc43c8b8fa952891d761c5886f460149f8f62c04f0659f1997e2e5a72433f7f4cc63cd13cf75946a2b80cf80d5803c0682b273961ad76eaf38dfbcc808dbc9b6847226cdd7cc0a5d07a2f2cf1e2a5fa8152af991920d4a4cc44805d30f67e7efa84828b2032f27f3fb34ee52f67dbbf7174079241309632583381d0cd3e1504e5690da952d2e84b7bd74339f8635d2960ce63c666c5d3f432dab445d51101d318429174ba3bd1a6c034dcfd9960d561f88e492dadb8717992d9ac4de9e52bf7df8aaebc920dc7ce789cc9ddf2886798375b333439deb9bbf85dcc4077d4b9f41f8b22f7d66d0d476b5a02402b25f4f1563644791550e4de5a4324845b4a4f6749de5ee6ba9791c8628290145da3951198c748a41aabe4eaab26fb7d682580e97c5aae524ad56e623e870e32fefd07bc51cbba2ecbd33dc0063ffe454ce99e86179a1cf84aa0d14ac6c7f5dee4638fff0853dc002950ea6a744f94fe0be8bd21bf81f1739174e88b8cbf84a22c00ca241f380c4154a009d0aca89d94b3cb1124b2872c712cb05ff490a58cfc2382524cf932cfa8ae628797e10933613642ea60dcc31f740cd1396920e3b232f6077db138060629a784efeca998e1a5d160cffbf66f8281aaf419ea787263298f2865f27f5dab47efa1dc2a86bc943a8548e11fe863bf88fdad6270a1e53e0f7a4322057044bd269b51a2b0eb3522b33d1b32349737f49431c23aa18cf92b67504251dceae244eb7b471a4ad0f409b611aca4a4b7122f7c290b4863303d8a73c49649c733fecb7c5682e8d2fa82a0c5413d9cf4a084712cac9899d77f3a289eb86e324a11431ff9ccde68d5d9d9f918370f99d5207e1940cf7733824a41d051575fb22c9eae414b1f84260e3c5394bddcac5df74506ffa86679a3a475ba448a4d0bef77958a2996c8381117882b8bef2bbc3726ed1e023be130b417166ee522fd521ccdf279122ad2ed076850cd2ca5993a1ec2fa6c6f7baf7743e4dbb678cade3d4294a9dc5f81d36642a8d2f965a77f01f98263bffaec94f612c5a47ad5af71cc20209d04852bbed16d7e3b8e3dad44e67558b8c15a3d912a66c764defa05b16389ca273684484a9e529cf3dc6b585d01d7f317fabed2666a4d91ad7df1de3d091f24fb3aa7a059e3f183041da39df0b1e69e8f3e7f4378dc549feb5d9712463a134630c9a254d06de71b058eff129b3d7a10e9185f25a80a55aed78ef8608ee70816ed8926a90457b5d3fef89b9bfec3a8e7a75cab18990a812e96fd57483d040a56d7e89ce9909a8e8ab265aef21e912580d044f1249625163b1448d9ce193bdef577139933b3979396c0cfa675a5d5a883ed934e4415013c0677b6021c7c19f68c97b316f5e09e8adea8827b30edd6b9e5548b6b8d798f9a83447ae3b3d286de2715e59a3bf0f2f9b6d82cb01631f1dd95d96f75d3e8ad4d9db7b920ba72f75597ac0b08865ba42f335f9e26e6caeb3c96259f6a6159e522abd16543e56cbdba0d1993c1e60425c751072d19057a61d0aab50d6afb2a4b221e47cf3bb6bb980f1dc93648355e9cb29dee15894c8c27cbc227d25c2912f060c3b0826e4062ca3bf335787f7becdec411d0e46ff131bf83221d9300691246cd3123dc1a9ab068722bbb05757e76852124983b86caa36ebfb903a7551f47286be8215014fae6a5a807481a03ab2fe30df17593d53a2b10c6cdba573f51c8b2d6d592b1bbd21c9351258006304045accb5786d8d8483b15332ec0433d2d44fa044fc5e331b58c9e09809f7e513a47809e412354e760614f0f25f1a44d04fa9cea288f27eaab337efca5f94cc4a0b95fe7b9bdfaf35cbadd1b2e7030a39e93a46a685f6ff6303f5eafec5a7809abaec159e21f7bfdfe5cb01ec67c46a0e1144a0542c0c0502337b54a10cbbc740b0eefee391b087b6994eed4e6ac0f7b5cf51f775d657dad9cbb9b97ebdc30019bf7b9d435102910726c34cc98b3c4b61f2d901f9fc840aa5575f7410b32211ed2307380d2b1e4939b7507afb768a1c61197467e8d0733e93cf146379bfb40c299da4254e902ea5ab5a2b57d15882645a3ce36dd6bee231e91d809e7137efd82ad2d8637ce95f68d939ef0e7adcc9a43e4cbc79bc6f1f1558f4d04b2e1d02b539beaf508242737bb10a9e94e3cc1a2d56f00e0b463fccb231ba1cc69e6d3756a4f9624063c07662e8589b09ad0b806087d01c8267191679f87930e19f1f62ba3fe806486911196fe694115a269cc441015fa363c9b1f82c7a275fc713deb9c6c689d4d9e5daf94f5a46999e7844ff5167d57e38db57efdb4316c0e6fef2b82f092bb3f2f3480d41bd751b2a208421be39d62e6514119ec1f190e82a396c8622e868b37807d33194cf3a74e9e3077551a0b51ac148e894e2deed4f1ea4ee9afd1b7c6707f9c2202d300d43acc1c0a2dba01d4508a2c49891f0de576206e3603b30600e33b92a65ebafb112dc2538b2f8bf5750e7b377bbdba26791e0ba2d18698e70efd01ba9ddd1c0c1b20f6dad303a8aac0f0b79636a22936d402ccf3a878b75d9f6f48585495c4143c9db663a93e2f4eaee0e660ff4a67790c790dc97d752f806aa27192cbdbcfa540509803393206fdc111e8797618ee0a349823746fa04ff71f4b78924ce48e85ca7b982e57f1c83e6b45bd0e159c0e9410a8763191a71200309725168461f6bcdd71f830616e3b607f11754038e5d09f9a3dffa150cc84238483412706ceb77023cdeefc57542e24e2aa523763d951fffee069bad727d38c2492ef1223a936b3fd05e512e2fe4e4bbdc43f57fad2fe00fadbff5f33303582e0065b64e80c51bbf3b30ff7f45a5a8ee5409f8fbe6a64f480bbad2bfb4c53dd19462d16f6968ce6016e1bc92487407e501afb0fdc42b78a25c03f9aca5eca4ed83823f77c0e4a06090c299ea9e5340fe608425e8eb7c06cdbf1c5236eab23c876064023b7d8d60b331d5f185a53b4ebb84c4e2a9533b8e47be7a12d70872d81556c2d21a530394c9bd4e15767ed85126d4304023e63c5545c0c9789d11c6f93da2470cf1c95cd4404b8388eaffb428aaa7eebacd3362dee3b99c877ffe68635bb4a18e1626f1ed2667c9167f833d44217d5af29ca25673dca64d1875314b3bd2f07e03ae6480721fa2efadbf87c9fdb75026dd6eeeddff78773d13baabcfcced17c80ae86fccce496335b44263c02f2f155555b1cc397f54830c06427d51d6848831296922d891420ab2b5f81007fffa85478d526fd52597e37f1fe0ec258d64ce542541fb728868eae092da269dbb7ea73c1b307c1f7b2fb58d14daaa8c82c1a4300fab9b9f6e617daac5497a2a61e94ff635d5954ffbae6bea8e7d43d346c3bba25c6cb296ffdb1b88c3c1232d66f22dc9e4a84b54390903e179cc9b160ab61582806d19d2f460099635ab5c257b0025df7fefed639845ce79fb180e6c4a8ff8d0296b54bb02a4dfb8a5bdb6bcf115aa723cb0f075951e9dde0ee9cfa1b64b41ba2086d23225ac045b929ff6802230eec23f24150f7d6036be72427a3283b24a0e85e46b665d717e7965b2b98ac71c058053c980d6ce8ae529384e6d9369722bfe3a338a6953b3e238874a0d1352e41ba797b6a49b121f461da80154b36d21b118e7e592d0b5cd1d01600742a783fcfa5f1e0172e7860e66c5da73cb1141eb82741897abc3196a8b4c640662b845931cbc7e241d99834293378ecfe144c12340a72789f55ac9e28c9e8f09c61b37fa979f1d6f48106075ba41274fe03022fb7faa91cb092b19dda2c4c677d1219deafbd2015e49cdcc391faa2da14c81e883001056dbabdcc61476abc4c96e22c4181f56486533ce55d5794c4962111cb4a0d51d891580294da6fac5e31b2ed3498356f3cbb4473b128283eee30affc6b51450dcb31e22c97cb579548ce12a5fbae499613c7cd758ace36590053f7339ff1f2b5b757f848dc9bd5969a35a48f661430cf43ea6ae4099127f4d4ac0c6f7d69e71aeb4393f6a5a9b871648c9caee45e0d3de53ce9b04c249e7806f786ffc68a8398687bf4b9cfe1a20efddcb045b9562d458afe2cc9331268d37b0332960897b712d1b2fbbb146740b5b8e228967af8240f2cb639a900c174c0640f284eeec0b9d5cf6abca4341de23543bcf6b322f17371203ffac8876b5088fcd6fe42036c30d9c1f955eaf66589b4a2deeea4ff894768fc4c65a1bfc1930dc9fd96d45a3421f05126b8bc1311a18ce292fb78531627eda561cace59fcb0a173e6ef35e1dfc7e658985bd054ea9acde53d1d08d15a7c2eb98e2d683dd981d0596e5124bb63a28fd44924e6275f9520f29578bb14af569e4b1800ee2fb7a47e11f94f7618f3b47c5f8ff7185b7a91d73f3d4ff4f6177fb6cf46e82d2f1d8190cb5d5f5d520d878e422e68efe867d38e277fd10f04a64e939f63d7cb3a5501c82c0c4653ed4dbd092ab53182f9ffd62ad6e46bcf78e4119ad7b806b36c1a25f98be7379a8999efd7415cb660d88227263d16c5c6b2799e4a553c1c382216d48d5e15a4af5930eda26a6aaffa3c88d8db71f71e7c9b5fff8811d67120c3ac17d15eb341ff6ed56bd36c4001071d0840f5f5bfc400c5d236ad3fa6d45718f521726fdb9c6769d7d381f0ea76ef71e7ce53b2e674b66ab97d67c0f786db9aa4cd452e9d3c2995c7f40036a2dd1bd4db6d8adf0ffd236b9c8eae1d63e7bcdfd60d24a2f3d386b5359df1c0b9d34f0b10f481bc4c319afb8bf03cd08c203ce5cca8359d4ca23d664e3bf4acc2351c2895fdd6fb73bd3f5b35369befdfc14c70f518257cd996bc7fe4681a7dc904ce70444a5e744d0860ab25034b0688b7fb32c35b4780284d98288107d8903736ccda9a7f4bde0d94755c2c0be8ba6e4edafb1e35ff23feb63de51d0cef2d9fef57372c2c61fe1fad191d17c52fa718c9ba33014968d5459951ab53a0c11b5046cfc024e744fe41371db6d766008524398c9faaa042c26a77921053a0b8d7a640bea10715ca6763343e64f0c44b1196b4fd5d517459e8a6aa19ab1e8f04b3e6a070cd97ff38258f456f430351b2815faa98855dec89859e8d1249da92b6c29cc2536600bfd487e3cc969ad4702861301d30416b8c884bde9c6502837eebb042c118b897fe7bf47ee773880a5d92c52df56f15028b39351e97b96f4977b339ff2644b890d768c9df79f377a69b5c8c515251d81ff2a8487284d7587b85de9516ca38998f37d7138c53c2f6dbeb4ca48fad968cdd7598e69a7bc8e6c37b3595a811ec26acedb8de804d423cf146425f6accb9cf92979ff1335af093a602f50c157d5c7f0c0b54e3676b7c36677e720d70de0c2d4d4b557b9165b107d8be92088c576e05370bad36b21e7f51cd42139e0f1043def3fab97d9b603bcdca1723dd630c9f2e72041c69cad59ffe4f86fe14154e6bf1ce2055941e85a19917e5f90a0d4e9eed28bfe52a61ecc0f87325d73a609fc0321d6740dc3d7fd86aad2a42b206ada8ffa166e049fbd6c4b4a4f0ae391433e6b163b39a1f3f5926ad3abaceacfdfe50c0f6eff6cf00963223fee1e02098f690172dffda9997da943f8ee3f6a076266e63159c5c899aef794201729d36b97372ae0207122779171940a69a98062bfbcca9d4ace4f8a1fd2c3f32cd64ce624363282b24d2661cc146f4b6546221d1f0ac605c0b01e8dd40eaf303b54216c73863ed7c30cbbfd9514c65cb2a13b9c3f29b4c1eae382984946a10c3fc2e9c749882be0dbc723e3530338ce0f81eac457b0d8755366b2513c4360af28ff3125ad0d8f5773cf571991de76b134751caf617c9fdc7b2ad1d79ff193f4cbc8810d7c9c4144f2473f5d1c60c87dc2485f8e54f40c7acd1299df6557c0314002fcad8ef1dd418fa1bbe94d8f35e993103bd795bb3a507c00d3ffe52f4161b6d66504e571c087b4d0467b9c2f33ff7a40720667e43ae02c52ed2da5af9a859f0c0c9e8f10c4cdae99e5306bcd9db45b98fd3792b11f57ada57bc0c4c45f270f1be136ea130e93d23bd0c515ca11f100785733ef2e2b03f6dc2c2b83c7adce351a5e62067caa98a45647cc03961f69fe1ea5a0afd42aa60cfc4a7778bfac7fc779649f285502638518f5f28bbecd03f9639008a81ea6f2317befcef938beffe05730a535d9fe3d8f35f5b49fb2248047002a01b7d08e85d0a75a4879d20d873c9fe40b845c82dc943187620f188255ff0245d49411ea570a68a233c81856eaf9b88c895b8601a69c37d80a3942db9064645335933645b7929f93e02936f3e5c8dc37fc690c651ca086509db3c3bd854c9d2d18c89c1420fc91a73c9b98bd18f904a67ad5c6f4115697bb76954db91cc0f0e55c327648766c771159c55822abf696d1df881e1f5af63089854e7a0034dbaf24dd35a7b73417bfddcf6c659955fabb09103f424fce817164f14b8ae6751eb4fde7aa435f2c482955e0b444894d5a11e06574bb1d9c0541f3f203b83d939dbae1a50a1d2509c42b208aece6089e5aa931586923e1f2011f63732d3276d7a1b85396f5b445b1897f6617c46da74cbe868e22a8fc6c0920efb973bebe4277682eb41bc3fceb776b6b19c40e412855764ef0dc8a305c537c38fd87b67c37a233045e6d4cb89235f427d63f836daf2e19a35f66d8629f3ba132b18987e14b4d25d5a58d51dd16e8f053a65c99d9eb80cf4d572537e0283afe7fbe2642b07e55c9a16e50534dd9a2d9cc9b991d0c85afbb102d2e1ea1850bd178f38d2c700edf52badd795dd01024463a2d9ab629d6f3cf1af3fe42135deddd62667265d51cc29b156adff8b21ecbcf2d55b90dd51e73dda75a68019a3bfc197c5454178f4d68864603cc0a28efc8b50868c89885e06528d4c02d2043946b0086677fa4f03b796e4a9139ac035c9e8bda3143f73167338d5cae807bb2aefc1381f574f0c68bafeb2531f9bdab483b9c69fc9a658d0a089c952d3d883f411d32c0a51ff1a23ba4dcce3acba121db127f6c90db044e7bea6d97ae66f906623d0688c338f47388a93ae245831c7d89b7c074baeb5ea284f7831020966c6406c8f001cd7e1be14ab9b7254cfaf2c3c4d489c2e0c77cea23dce35dadcd51e86de2ca79c3b83d36f2d7950ee23da946773bba5f3b7a1685f42327119ca377a7df8802e6e05b83da790c69c0c06f1d3a254a8e3f5280afc338b7ca0b441625a59d337505f6b91eb4895ce0ac4c7a038bcefb5f04b1148219cf37e77ad365c96685247ddfab3422d1a1252ee8d881ca830b61e70bb98e83dfe1020b3be48e84ce308c55c0da150906116314297a816e4ae4e543f2ff3f099a7cce9a4a7feafba90b875a099cddc17c99039f14a2c0d26c1b6e0c3f95cbd29bf18f823c525a628f11e6b58379a3bd73d38536d9fcd8ad8d3bdd97ed9122717de4b163446bbbada132ae532f133755bfe82dce7e068cd621816cbff5b620cf3846be61f47727d7e31fcb802e4aee1e8c92007b07cc749fe22e147f065938b40ad0bec0f836b37273e66415f8b351a864451f9f25c9410e4cfc0885b934ab4c0e7309cdcece7ce1eff48828c5d3b1686a3570e0fd4c809b1c8b1eca3c837b2066f80962eba6175d9c0c328c91b494e2f2d1a316baadeee736b1cc884a387bea2a144315de214724ebe1d051bb9cf2d7a487f701511b3c64cea16fe773a7e4c051d7291aa515771026bbf4a36b28d5c7544d4790433f018d102a01cd43c2b3414dfcb6d345ff832348353f72cce6f7330779fccdc1b82f492cdc06f30884fae4baec202f6521c41ee038d7880651e97959af20b5a8a52342fbc7b44844ffb8475d67f35e7978abfbd81d30b36998d8a9c0f12ed017bf85c8b8f7f94a4ec55cbbb352817cf8b79e914880acd43e315840710031d826d73a608498b7706da66cd5a2ed6ffbd08ef87571e957906049432f63d1ce6c3bd1cd0e53ee546169198ba80f4053c15e99f3b463a31aa6471d445af4e56bac93a8b93746235b8d41eeb079d47802fc6913a78d300f3f87e7a93bef2ad966c402212f6112dbf11d5c141c3fc030740306031edfb2192596d8ca7d3b7812101aa15a1bc942ff381235857a352bf6312619b93221ed4ec3dfa6e0b8887129444f5ba7ce8a8540458d88262b584f4318828f0f549041a109d5206fc3b53b9aca766228d56660e1e51871e4e3b9b95a7fc988cbed9cdaef2f45a1d079b82e94c4b3714ff13e3be6703bd93185191e60bcb75e1ae52722ff2900367aae69ec263ad0ed507bed42d412554782878096db32c0dafb1c5ae84da8c55d1fe03b5f2a32550cd08496a174c90959619d10c7bd5cbb0ae2abeda31af45033ed0f0191ccb765ef7a936806d67ba55a9ec5a3069ab65a1cd9e43621e71461c108dca9a33d4dead361d1cd1d80845d3ea2d9ff61eb907853db7c3e2ccb8f43b169c14fbd957b2aafb3317ae20dc2ccd091d32a39b4537c24c6adfb44588137787e78dae20ea80337c003cdc3db952cc158c244c06dc02fc22230dc54b0d7ddbf63b2d9f299d718c86d2bbc18bc2f1eca2a0cde8ebeb76d65555b0a5836fd1ecab1089e5ea5e3b471b9030f3b54a518a17523ec41ed5402eccfc93103b09734d8dbd5272baef0181315068f799a45bce1272790858823677c18ff15af102b4d779161b53fa30f362b56a80e6b965813c37a1e5a1c4debb0a481a8405d58799b77660eee6dc541adba1efa25b88925753bd9c0379d5487ed2ffe354af785ab1c7fe4e85c2f24d47a3603f3cd9f0219a58787ea8843ef79f931b41d86ae13f275241562f2d01df73cf697f3295ab5487ce14887f25dd31ca74c7d37536e74fa0977216a11d689ba4e48ef93bce78717cab002e68be6d78855a613e4a3b2bbbe211949c749cf0a3f6b5db33452e39e95380f7a80c4063674db4757811ff67142d9b4f0c9cb1983f92424bcf1b3f7b68ab3a9915d2d8c7ab6fb3f94f3d29ac2321741cb782a67f4c8f7888094a72a52ddec9d46e7dfc025c5a501f486b039e84304561b8f65b93d5f6fa7e3fad4e62f2f1e0f7affd88f5434ed1df7cefe2bed9da8ba2a9fcc0ac0599948e66cc12bae5bcda2559505c7b95da37222c7ba22fc4f43877df21b06a671bb5a27381c277034a92a6779d9ea78fe5265f1bfc1938049d403b2825c72c9e6bce8ef26102776b15dd689c601589b3a234fd1b7009178bdf5f4c1be49636abed89b26b0d037cf18892e53b4e3994a5a6c8019b1d4df437911bf015f544754c6673c06c26ae11fc55e5b911f3f7809d1c1901644b29cf3f8b93ad53dfbc35cfd380a1fad5feb3e48a67f9843cf6c46ce9bedc5c17f39356280fd71fca702d2e62865f668aabc857481d31a9266a245d91f826fd48eab8151eb6e29507ec4ce468a316a546e5293a2a64670502250c80abc74cb0c0ea7db7a05927903cf64df2e66b5adad00d7166229ef5f4deb2a40b382bf68e3cef89aef0332f3ba98c0e0981bc721f3441fc634f20a205772af5c7472c21a34dc14c6119019fc26bef547c6e98de18c2bf18abec07ca9bd311a712f0543bd4c68d5f77c6099a02bed49f49c2ed610fe44c1adccbefb29c37070d75cf8d8b0f85bf26b7cb1a65ac62af4ed39aecdeb12790c19546b92fd418319f3e37986173611a916c396ce58ad697d59b0b36d40e1ccd469732d579f151e428fd682e3046f57637b4cf5296a53b7e63f634b13ecd7e86350ed02db003ca36141a9f7ec64b17487e2fca4b554c48d4d8fbdb74dc9ab5e06712bbb3fc97f11ce667e958f6e6a143bd89ab74077406153307d98ad3d929816c25af4d75235b17404479a25f7802d6a52b7c8db5487d7131f43625c247a2c4e728ae05f2df7e427f084bf09d53f45dc6e2a86597c6dd55c533132bffcec57e651da2b449af4eaf94af935c901ba599d5cba5fd89ea878572688686d7a093d696a3f0d3f2ce29526ba52a28ab154b4326b570eda104473a79c1f204e4de14afc92fedbd7b25ed817da5df0f8c8140134db9637734daeb07089718614adeafc83829bdcf148f4d3be8aa20493f49305ea874b6dcc863fc8123e5c393b664b96262987f6504b4e615c19a27cbb20ddbb180e8ba426571ba12b2e42276ff8429ee3136efb639f57208cc0ed8826ff529bf0cb1e89d8f8a425a4c5081372055e17d824b6c5d0cbf200ee360a35646ba70602ffe3beafc33c3eb4e41fe9648fa7a60be82e17f613a89afbb2a57866d4b862f3a7c81e7b9b25290058418bf3aa147492aa2640cbb9a48df1082375f2bd6ff286498d89e45b1954941eeb6be1586442f2ed019e3f57302479416df1e778d6aeeb486b6ffad36db5019f49d6d48f5eca6074b132737c0079b695a74eb0db8e4cf7015e13c02f29b92e953463e1dfe94d118ccc363c9ed90229bb9ef2b5bc965ad3d74b0640d1a582fbf3dbbd171d70036ac0f3f78ec0e6d99c7b39585fce47f4932e93c211278febf5aa4f32f073141747cd15df1bf1cbb8959adc511d593cd599ed501e560b270fb30ad8c9cf12635243881a5c1936984bbaf8818c29f81a03973e677d04efc58a7800af3efc20cafe159adae0194b75c280a713d5c418c7c98da09dc8589f386b982cdf667f2c0376422b379c2841773711de251dc3c527c132521e432b1f2655a8f17675d2a77d6692680c0a4f68270a006d5eac86770c04e8fceab562f856cd668f93e698005966a61a4c98ea20b96c455af8cb58f2139a951685cdcf9e66599e34f0dd13aad0dcdcfa8b2e4bdc7a7d1fceb22ad76042e53c6038e5d5f30e62fdb62aa788e90f99c894f3980e23307584042ef84f8c0bb32cbba9a5477d5277a264fee6266d091f85e48dc7d4bbbbd91f988b23b103b92ec165cc343bc56c07019c6e83137b778321e22669d32c8260d151be63b4004aafd25fd5151404aaab00a59f91ebfac8a1a2c1687e945c703528ce4d0c130f9ace37a41fc50e242b02ed583516bff7ea00475331d4de638a6c48961974f1ec044b004acb77957f3aa4cc1ce01e2162bdb9f18acad942f0769b9ac4dfd5babdec148745d60c9dc22c08c421e6ad673ec3f8fc374ccdda0c3c7f57ca88f670a17f3ea2e0a83c996407a3e7961ec3782828e7363afee30e4051e3731e88e06ac260006dcd6b19ed65af4748bd41bf2d24c33083a896044e2150dd7322afb6e19db5b81e7e8f897b2ba5457441cc642c800970edf1ccc12f9229162c0f39d7cb5b4f77b6d360fbb11c9289db586ce93b79ce79853c1d42f31e9be5a01d9971feaf8b8598f38f24493b15d29f7cc874802b514d5a20d012d6a71fcb98e1d42e8b6c005bffc6f9b2f463c313712bb98d3b50a57b92bc9dd7908cea676f8a861c694143e8085b39f777478312a021af79dc67a8a87ef862e8143e10e7800f9dd6c529aad03172625e0145cea643b108c7a0560a389796bb2681caedd54ea806f85d4899c662689e30b8a45cb4683d8fe4a2052e939c281c9623435f66364379bb1ef8838e671155bb781d6dcb6b35e0dc25f177d50d1d9341c9413e7a30223dd4c75222fd3d6fa417dacbaeca62b66687d2f521f307acc934596ce31f10c00a03762da9c44a8bb78b85d8f978c1c0d720fe19c98d59db150c15db258802828e331ed8c05450bbdeed5c3cd117b2829ce840ab7e98ac870d7ac4cd2b829640c13c09daee61151639c4c9d291e5a43856d2a172da8947f3df44b802ffec61ba7689fa802a4b952a48607e9a7f04c442698f6082b09eb2710904090ed187ef94b0d227077c7f58e6fa836a67d3f1cf548cf3613c12f65551246036d4ce85eb055f3bffcb45ec1f5783dc819c10c0b43f7cd9234f1f491cc9f15546c39cb00ac5974bcee0bd37a07e32bddfc24b03411a7f1ba4f7f6aed00f0d1a2bf0c7db5394034636343734f3f3820f3d88a42142383ec5c95c5275c64f68c3f5db525a75177f709b416d4b6beaa418155b3db592daf04d157283dbbe4553e7a71fdc2afd3da8667fe9fa4939563af41a99f3ddf980862d79e4b9a41376e9ae6047cfc24bf7255fc3793ebff9918c47aaa021f8ccd5abd1ecca437437b4351aa535cc34cb9ed431aadc7a14b7ae1c808607557e5fa7f23e7f94a839317086a203c478d408b3110e685ac3c884149ae2a52aaa29e1808c1faf10dab0436dcdb6864b311d568c5e6a02b4c4183127d536eec89edfd6f16db1ee0373d44ef9fe5e905743b5ee7afaec61ec57dd3e7b5ed4bf15987b7770b74ddfe17a3de1df71c1e17c2413fac57c1ee97ed1f28d4c7ff3858f12e83bce4098ce2012a410965a4547d71f8f8b0bd6e7068d591fc786fa5554dbf359eeb2275c879ae19d9f18ea7d321382b9ac1488b469aa88e1148ce0a1585c72f4098fcddccb96c68bfc9ad08382714b6682a5036ce84f1643bd57367c1cfcfe0cc6f7594fa8bce1aac353789955a56f4e1b8151fc92c1c62baf627f94022e55f6e27e785a0a02dd03eca010aebdae8688b93d1e1504cd016ac81a761d949118d775b6433e64f21f43b9843b6c1eea6817109da562aa866cd1e95e3623ef9d223a445ca8f54d733cd4dbd2a54272f8e1cf515e3e1b91f159e827805690c15f0392a05c197cd86c6bf0365b90e4fd68bf42d47cef4865ae20eb215fbf50dc7768c3de6a8a99992f9e0c8b3304757488f06bb974ccb7e533bf6fe341e08fb97692172ae3c75941b7c198b53e04b5e6544e0fb99b3689c3e4abf3f4a4f7086283f5ebf8ed989ca61601fceecaf97b28b4f65928c90b593f583101f67c16696aca155e5498506c6113a3aa66ef76a6ff6f781843b1d4951a1d72e406087c526eee967b1a3e40ab8cd833b211968001c5fd0235186c910174277fa2b7ebb5abdc908b7cb1f80759dd88991c531296af09e6d40370f0b62081f8d9691c811627e66cb889d8144ea3cb2630221a4dfb77e4b25e4f823cdfc4d3037f9327c945f48e814427085a8e552d5377f63096841d351f3a0c816872032335d1eaa1ec5fd935a8409a3d248929634f94f5cee7cd9b1fdc8683b4c31ede17c631640d77a09478bd0d1a13e735e1cced53d9368d4f72463b6573baf1fd94b3ba94779c9e8994650b62053792523fcfca41d5ed11bd9acf7450e9a7328113a150115b56e2cab225b721aa0bae8cda5d16dcaef4f11402f470c6f86949efb9fc4a55e5286e95939bddbe2251352945899af419807d7490ea36f0f797b75a3b4aff13fef6468399ab6e9348891ddc872cacb7b146c6ed4bd25f5e08df9635bc78f181a691f88b5df245ff412d0398931a74edfc28ffa9c697340665e7694b0d998143a2414cd91296819c87036b38938748780838b693a9c830cb40f8d8a07b5a60c7098ee42aa1f5db3bd46f4d514538aad7ce55ab0197bdeba194f30cdf960e09d0889bc86611798de0b326d7d6d0b3388709e8cad6fcfe588607362f9cf60828123b12370dd319c37028622b028e4ae27bd16378d49a8e9ed1149735ddc724ad9a370b658b2c7ffecac30c3fef70a3f7295ae3841de059e998e93e52e36362204c24e21732e7a55e14d200cb57ed5b9ea10471b0765288db1c4f50fb4e5e6ef7964ae8bea2fa388e630b43aabf1a4d29f9d84face2261bfeb5de912318725c1791953e5255c38ffda0dc00014d713f3f55cb69557ef74e6458f391083b4c44301e526c144e73fc0411d3f701fb825eb089336e27147e9c375e354e5d0ea920dae2d4a86723a928bd54ea2fb09e7f3c4b6bb3170200b4f0c3fef22dccaa97429fb450227f1f863e3c39f621ec53827712bc33b55f340987020d1e1294d22a2f79dde1509ae56470e6e3d9ecdec6f4e9fd349bda7ff90fb6fecedc0aaacf60221bfea85e861a67c5bc158ebc89f90bce0d97d9e03f512298382a3edf45839f3fd56e266a82a7c453b48f87f3ebeb9fb5064c06ca9b73add1ae6b7b7a80fd52fb1b9280490730b25b40d4e46f039e282a7ef3a59e015da885c30ecc6d661a556816de1fac2867ab0fef2b3c632bb89f86227d2fac321dea6e470c184bb5101dad5336fdd0c5ac56b12d904b60db57f12bd63adb61e9b4066a733adfca4c84b335d7d4bd1938372e40e2b8df0dd781f0990d9b7f04e10a6ef5b319d36150e5c58eaa5801e419012cd6c827e3181b2e2b76964d220316c65a1659bcfc2a41afa3d937345c81ac85c546ad945d6497688055c205c8b772c78aa20d7fe6f68f22a265e4da00642d2ecc277a08313460fe79c1eb69b77ccd070e3c3c99926a15e8bfa88e76531b214a2e1b74a34d54b653976dd2da53db1512046032224e9ae4cd88f6bfe94d8b3965583897431c01fa9069f1de44c4821d523ff4f3b01cb7029d36c1d386a81f3877ab553c47679276cd088e8c7a733b3b64543f61452b52e9c32e818222724a63429945b9e8fc9713e9bc31245463c4adb8d19e006631dfdd911eccc9d1e86e88e1cbe88f90fbb6df111b71b6b84d7fe7ed641046399f35296a6e8cddfce6e5e6b87c1b0ba8dff0ed7adb1e543ff9f6fc8366f545c9e11ab16f8ea58226abb1e02847fc915f28f5bdd3108d569d684ee38352cfd143cca6b85f197af10a925da4960fa9248d9c2a416d58d8ca7f1bb3b71b313aece5ff7c086e9095de1392168380b4173d26aac5e17891f80d16ca460f6f54f27f9b8745915873a94918af7190c5f6d7f58305118794dfedf95453d6aa9cabc3fdaefd793636b2a167c80877239e207ceafae5f0ebfb8c74aa7a3d9f738e24b217efde97454d0ab4ecbfa2b7224785895337259d12d9e869d3ac1d3cd8cce0668c9712e4dc4cabff8d524c89bbdbd882c3a9458a01674d90107c049734a00687312f1172a9f1328ce9a83f41b41acb0b1567eaf5939bea724830dcd1a0bfc72f4e6f70cc7f17bf179b92189249cb1eda09ec76b1a1eefc4808e73e42bfbfaec21a5d82a6a6d246bb80f06fe655191fd2a31117be73b8f6aac80d2800a535cf53a8668d2daa698973f12b64fad5bfef40e4dc3bdb5eb4ed0e6e58a94a8e8c9f158c6761fefae05109c5ad187fb7714b59f676150b970e10a91e6b06fc81a9cd14693a2b03a0b8d958c6b2ba65d3d8ee2117ceebe7d1798ced8e00209c73c93cb263dabc0e279ad78b8304ba2d8228071dc15a448dd4b04dc4f5d38849c7a331660a948720c862eb36cd07098754cebebe2e58f3c3c684903f193f2c129aa74772498f8c15e37b7711b2a910e36922bbeb5624150610c1d869aa7ba37fb5cf3c36bf8ca37563c0320d1aeb6a8d6c00761f47767ab4322b5e9f496a7376dda4d7912681776e47ed2c8a6a64c9846e502dc3ece42cf67111cdff4a28ba4494e3355ede8902d4a47acee2fe9949ca11b8661aea24640839dea7222cd2dfb160ce021d4ca8bbbf733d46e6f930391139fd4afad3bd3f491ca3c60936e5690e8940e8d98912987704a8b5b187aa0bf9baca77ef1126425ccd292c56ccc69fc481c0edac0202a2cd2ed859b654f51666eb28c8a334a799faeac4444fccaee7b03dcdbe2d6968d46970834159ddc17f75f8b63dbb0e55d1ef87c6bf889351451ff40cde5f55b52f5c7ff456f4f26a28b14ca747c11da2ddfde8ed775d0ace4d112af26f9f100cfc43486aa19c9ca6fe62c2298c878355602130788bd3260f575cd1381452166a5051b77a8787951c2ee498e0731eebab3879128a5c22ef41ed2477176b3693699bae7d81096a16142f16d8869c156b4bb0d891364262e8365828d371c8eb748d0a6f55cc8670f49f1420f32ee6826c5f3f3b79ffa09fa3106740590cbbabf8fe097950e3053089bf8580084a5475609470bd7b56ee30187d94bcdf2b6761e5a62f1807b7347dfeaf384e184feff3bb7ae0c10b29357f1d6f5b48b494482710feeccbb4eb6d20d45c6b77187784c0d4c2871900ddcc7471fe1730b9f76d1a91827d1d036d7275726e604bdc19e50fdfe6edda781c29ccb43902e792daae7faa1ad2a18e17db946644072643291be18b593e8689355a365b87d3b522b1fa51d2525f441180f22593e0bde662bf81266e05ee0ef670c2d1c4d9d212d22b92aaaf272c863742b39161b2a460d6a381f8c655ee42e5b84710322682e89637f22808954d9a01cab0344d3ceff2767ab62e4a623f56d92aa42f10c63f257e28823ff8953bda54bad1b9d8a3e9e72615a20485f16814a86a6de34af3a1ab8f91ff88676bc34ef6a497ffb57fef9bc8f8a2cb064586e3b794787a579959db28054d56fc8d66996af08171bc2644be4fa6d7efb5c236482030d7f357ed592efa78dd6f0ff5f8f72e55ccf110fbbdeb41910e6deee768c90abb138f376c69100b0643dbdbbe178a7c189532f889cc799b39cd3bb3807fd474305719920526d23d07fb18a305d42e0ec077bbe2bd9e0f01413acb0bd0a5e65acd330e131acd6a4bc55d3649966b137749fe80c61803ed5cd62416cd4f5b7b36f98e813d689910239b37c02b8f3d152ad93a9ea56d0cd093093f63384d5120f2b60adbe0dee78771826ab435d20f06c130ad7cffd289ad27df1d9da5288a6f44a0837e7e1aaf0ee6ac34e402a80b347412ab9d4160bb70b10e1a920f7b8f0f0127e60f21c0acecdebcc23cc0ada79429d119774281b1ab4704b45082dde0f3dbcc80b9973c266c657c64048a363c62a4dd4d96159f97bcaa34281fccedb04414e8eca33f8a021498770529f6acaf094855e467a4aee92c1904538ada98cc0d70de982247dbf08d094f7cf7122e3c2c1e57c57e5107df89547b9e042936d0baa3c53a76c2a8cdb5d6db21f4cad8536b589f8a7eebb198ce900ab8e14bf2365ea82c24c9f5206998b69a4ba96172d13d5bf9c9954114fb65","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
