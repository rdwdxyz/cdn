<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d1a7859adf648d7eb69ee67c12a9bb9217eb0edf4dc734ff5aef158391cf0e52621bb0a58c925c3705dc223d43de13cb695642cb05d7b62740e7be10286f4e91dc2ff38d4dfaa7a752380775ecf74ffd4f2a8d89fbc179d35d95d44d004885de0b18bf20351e49fdae90d46e41874a44207ec48e2bba37ffbc2fc7f6c6f94f1b64320671f15903efb1804b6c52e05170b33a179a9c7f6c77b5e0f1627f491d3a7b6b3f59e371695db210e99847c4ab004eee9334b9c7af18be5c5dbcd0b0bbf8caa0c88c604abb773b803991b23f76f70270d1cca3447c8bbb0f89f019dc21328c45c0a1914690a68904b6acf462a9285464cbba08a583244264bb6ce0a151d41aef42db4954a7fbe17c66d54105227d558c5004303f706e847ffd9a8e6aeb3cada43f4273a1d056136bf7f2c7870c6e0578419929f734ad205282996bb6eb401a3c2524f51e52f05074483dfb1e3662692a9fd594febade0402492228d7b33c573d018dd49c33fda8f2dc408ccf6b9fe48d98259e0ba1a1e74b194e08095cf4a7267f1aa6bf84de711ad1f91bb82d35ae15fafc548c8913dbd1ee5dff60fc0b1a68d975a8a25ba07892a58771437b61bd620b4efec19dbf73698333e88b7c30bfeaca8088a914d3bc830a350b8b4ad6a0082d2642ec091f5630c6852a76d4f0384d5c8d7d11d6d2d03a18fa36d707c8532e0859509f481342090b84b4352279cb252c7223ae318e8d7ed09d3c4a993de904dc6b7c23f9001cd083c777cbea88e4d8538787d5bcf48b09b7becf705b2ae745fe7ebe6b6bfd09a5414e506ac56bc489c6a007874c8e8dcc32f0ce1e84312378aff73a84836cb737dcb305b36c02d7af19f67894fdf29c9b8792c23eb114945efa2e1aeaf5ceed73044be50f58e8dec7caf329caf7cb2dac28388b27f61d42047846e4bc55116c846c56f22e313e55a19b085d0b753adc24f98018f1ff53f6e0ab296e95bb7c3f5e0b1a4935ec8b69005bede28f91ee45032caa7a2b1e73e9db4899efff01a9d413614896c3289f83b90fc3a5c121f86ff063de4dd90939757e9508a34015ac720cbd0290ba5aaf7b4d0437699c685cb35e15424c3c64680ad539f3f3e3443e55f03a7e34cdd520aee833d5b9bd5162e37bf002cdbfde957abf81fad2407de13e4b823fbc4e723f05f8e62f436e9e4e1780da1568bbf252dbe2e2455eb8a63d9e8457052ec76eb98b32b656c3ef0d82e5b6212f3d67582ad6b1b452e24ff295fd0965c95af675f774eee04cf32a5b88689a5a564584c37c872836580ea16cdc4646b91f9c16e9b0d64271b55780e9021b1fbe8b5eabd4bc7bd00ac9e60298adee864cc2a561f0cba929317a18391e83adde2a22426e571d5e820f3e5b78befe409886d48ad9cc70b558982545d85a2a7ea94ac66a5374dcdc4856da7e391f6ad983952ae158966ab5ccbdefd5bdf4b7c93ce301f28b9be6a42d6f70e7a81fb76a4cde985166ee13906e9ab3e9da111fabfa31d277f6a83eee040f77d3e8ba7d4f110edcdbb3f3b891949653e646265efdc3b3475229c7ebd4ea5e887ba2bad4fee61bb942f68a5170d0b1eb84635f4a77e1414beaeb0a8b6ca3ad48aabf240b5dc7ceff5ce1f3fcb4ad48bb0cffd9dc93c188ad84229a5d31dc26af24b18be57583ffbb376abe0dae3c611989ed0a797bffe9c27003d211d81b0e1cdf87d245c4f8735a77869afdde393b9c9c31ecfc6bb5e5f0b3d47229d2b3f3b7ff2a972c87135e69d8a1082cec1ff589ffb191b97af80f33ffbc88e5f9b0e46981ee8cae2039716169ae9fb47258586ebffc4b5eb557fdb39325e9ecd8acc2b70462124988e461a905f94c45c89efce859fea7ab4a4037c1cf85bee66d98fe00b8f862b81988c0ec58093cb5bfb2cae45e98a90563cf367d7707db08c76770c6aa4b048eb54cecdb7b79c6071e97227d53bf8f170d5f4ffb02555a221c2f6c5f9435e438da533d66e696c517542057abfba5c825f2b066973582dfb6011c40c822bdee7326dae3fb927327610acff0b726427b280d87ba3e28ca04d12c85c544d95fe9a6f0523ad102c4e5316819aecbf8944b114b691e87c04fbd2906dbb7fadbfe297cd8a8466031ebb1dd39a6ed2526402d71739812a15406d7f66c488b1a4330b2657115ec26e7d736d7058dcc4f8bd6317f7974495de5b7f86d051e15dff482a635a5798cdda5a68c2ddc1c156a07a5e47302a5500693d31ccbcac4746193c59962bda1864b05980728727396c8998a460e0964bc841dd3b9c5eaa01c60e34a3a1753ca736a683763f9e7a34f097ce01ee70e104e764caae6de14cb1afc70828e8cc4105f3d4d4e8bc579e15517a20fc942849790b3a43866628e52e28f85a08dfd4000cdacfdebac324a0245b39e7cc160a38661f3881903045daadb83192731cd2c71ffc8b94d01f3e9d3268da07165f2a72b888fe635fe132bd07eecb53d61270bc5d4e780ea78ca0b1e2d2d0475388e2a1d4bfde539791c020fc0c7954b599d0170ef5266592e4bd17005d838582b5705d2551ad436a2da12271d564089e3b98b609206f4429d10b2045bfd80da6a1ab6b211d7912927051cf7dd1754e7fa5ec67b7050a43ed86ce2de6d291a942768dea0c798e09d5c868999129da30386c462a9a6ed14b1100336cffccb05f70d8d58d20b1cfe56b9d0760f9b6b609386ca30bbf57bd073cc77eab387e47ff13ed1751fb6cb61f849cca7dcb75e76b89b5bae747a9f0298e4d7f97f8a5134dc4d9c3ce8f715390ed34670f0928dd3bcb6cca669c4f8c7be7f51a2c922a76e45a50afecf2001571957a587b2fdeb6f2be2636019e1b289f07c518daf218fddeea793e73b310c84a4b07f1076265a2ecafd8baf1d0cdd4e6dc4ce1026f7a5a9b29f97920182dc12a5e6b594829061cce9badfb090bed2e20327a12011f162511baf3ede02784e3f585f3f83deec74ecf15d2ada8ef9fe849d9b4c8bf31054827a04df1664361d11011bd759b9f80bec81074d0f710b83aedb6d446d5f62941848c8776823e87f7c1ab8d3610a38e86f529c4c95ffa45cef7e9b055c4737f8d1b145532661b7e6ced29a8a729a587c80de14ed02784487bb60b62e77313128e032b4dc85fd2d81a21125b1c75864aafe3f90e771e206a2f4e5e54fe16461bb6a4d62de9078a3188aa3f141d20547b63a688430b08aa27881aab4cb70a76dd743de7e9de2110f0d409aa5c67618d15c436831dcdfc3dc85cf3bb25cc0621373e28e22c81788f4aab0b663d1be7bc9bcbc53eccb13b9df6af21e390353700b898dd318e07174eaddb6e5b2451b605cf9b33376b921f9986f48598f2f5307d0eff7bf14640250b53b328009ada0fed1197e7d0c02112df77e5d97fde281fc321107b006836166856e37175abef86e173c285a8daf1be43f93c121f2822f2b94f1bc64e533252e15230c913914c54984ae6a8ef3e85785e9c3ba7d8ac94cc18da090e8adda15033b2d0a6ff384f176d9d247ae5b9749a1e72a36266743971bd4d6fc05725b740c4f004e0baf83781c522e795974b139bdc8df0a197c48b2580b5e16c30c04921a613ff7b56ba622586b882f6b2e6faded8bc6cb5239b9d6bbbb871aeb3a6ea78d6c91b52f553c0985d866d874b76ed39fafdb072e981e0ce03b5ecd2c9cb8ab15013eec90ec6c7f923b91b21f28d0a236830010bee6ae62f6368f0f2d807a69b0752e34ff7e9294c83b5dd7c47c8ccb07191b82bbb964b01aa657b577df67d5987edeaf2066fa27146bd3d0e5fa1efb9497509cb77afd08053894d65437fe1a9b66bd6e2f448c718e1a63643ef322c9babcfd3896848c85ace1fbbe3c39b2e1be8cff0941524c2db1efe635c22df0762b2b8efe6c1b9f75d3dac6c3d18d999fc5670c6e1267f44329974450098e962fcff226d243c0bbfe9ae6bd7edcae73320d7853e091b3e4f784b91b517d366379eda3e7154a07e74a907ca22f94814ed730977c946070ef24457d1c5c87d21604d6e84b8887d69fe5a896f75250e8debc6ce7a33ae43f8a9c0a923a21ac1ea5826a213d09cb00ea184f23d4ddfb79a12e5be4947c64b062c03bf8d1cf7801a6d3b33e9604bfaf97de9adfbb8a46c26b4b5eafe877cd67119d2b6c6461951e7fd27dfe0f7f87b227322814dc6507c88ce6d70e74988b3f7da3414527b3c34c108e84d6e44e8b25c5bb01d36c77aee63159457d7448a047294113554b23e8cfafbd55fb08bb6a4a6e388008712a370b05598253b5e62348949c1e100da66bf2d77e73526bfc701afd6067da1575c1363cb90af9a8033fa75c0d7b7eceb2c43eb8597126df66ba0251ea05ffaff2cd0b2f8a0780b98c40ae49949a73ac94d42a1779b71f6d004d79272c8107b82caf29c79e0a40e9e446e84cfc0e316f760abb6bc1f818f4ff011860ba26b0022774798b94233bd651f46abb68fa004fd43bec13da98ecc252b1305b5aa7b4488b8ead4606289037c92584edf47c8badd687554ac261c2cc15cc879da959d09d8833b00c62e66ad4a460d79e7f6d2aa39814bc1ae761b3cef24aaca47d32878d9ba0a25ece4485d8aacb80ab3eb8b993990a8d9387fffb56199f4c031e278115c6d11bc6e0c20e1c3b8179223fcd6f8b990498000dc6b5969bf907226961b4787a9e4d68ae909eb6724c2ecb1c89aeb6bfd2e8199f7055ba74bdf44365f4ab178573a84e02897d3921adcb3079e7b799a12cb92fc2bdc25a21d5fa1d9c8964ca1dabf3f285827a6aab400207005414600569f7a2ba09711d9c5d9a2aa5f1654bca4ccd2822134888f4d7a26cd471b444c1396fd80cff1fd85ec854deb25c7a2f0eaf0087470c5d9a76f465a68868452de2ad266def8c1b52ab2f4452eb73709cce1d249c4c59318edf5411f56f09461cf10b507d5d5ecb4600ffdbd20a85bfeff268d242c5bf21c8d1c6699a38f0b50783ac62a14aedad3db6c25b5f383b106b57487ad0be8315da20f1b2c7245459702dff52e90a04f1bce3c6ba9460df2c72a8bae385de397aeabf6ebed2a7654b10fdf3ea1aa42deec9f92bb54604d9b5937ae08274bbe403b107dac7fce84684aa986d0e73b9a28e7b4009bad7a305314e874d53fd0c27034e1632313110f25db24f12b25bbf8f8b59ce535a4cb1dd16bcea21ee46db0202dbbb6759ae35a36758438424593fe303b5026985c76ccbc587b71dac94eb66cbd0903069ac29968ca00ba2c7913d81e468848940d31231bae7e80e08133fe1acedd880cc70299bdfefa891fa1221251129e9e81d70fc76691e1e66536f59a7463ef9b52fff0a6f42c13258258a6b894a92974cff2d7546d96d9ea692adde8dd3b51efe94ff368d9aa46f9ffd57886cfde61ce456b9b5fc1c847c492c5d04f0f71531733288396afd2733db1a80238239f69dc83c7be4cf26bdf9f50f58168a665285d6c6de00398670a168dfcc837b6ec38e573329c45a8fbd7ad3b50c9c345bddf917241eec3043c640a1aa6e39288e4fe80b40126c1435a52e9ea82cf2a7c4af32a316cef0432ed2463d741e44658499e07074c1969419886c0f479a6dbe2ab0e42ccbb2887d60f14116144e4be6369c779d49504da53b2643d80ed168819cb7500ac60ed966e1fc71fba0090d25baff0f90d05899cbd97bfd301646e95185e0276afd9dbaadd33d9481670a52dcb80a9fae60f31b5eed6b16e605981e89424acc5facd90c79bc0a40f78e7b335c5c0297acadc2dc4b04bb2ab6007caed2789f43c11d9aa8d87d1c96330489e590d24ab7cd501738b0a522f646321ec6fb30735720cd47a2911aadb5c7dac0acf0f293ac29a2a68319e4ec0cc6e31471710b24e09e2fe3e005641ae831fce2a904582f4b48eaef6864524d91e23ad7cb08d1b258a0c54486787048f8b32caa37c2a40b728ec8cf834a932c4c35dbaedc35c7197b37fe939bb299dc54cac12244a0df4f787069d02154bd81c6e7bf8fbb79bf9b5268b35a99e549055a2f792fd1d770ed2b84dce70110f7087be42caea2ee66103845215f488923ebbb1c222e1adc7949ffd5816a66590b68bd6889ff4c645e20181e4651c4bd0a0dccb014cefa40a0c878b0e7a9aeef3cc050b594cae36ce683b75c2e2be58ccf1f21032e8817391b633b0b51d8ac9d1b9fb5126cdb3bf7aad96e7f90611a4c5764300e70e48b3e46a7493d9a1294bbf31de07d3b49422cd4e6dda13e28ee2f8a2db250679047866f1015c720d230f0b3306b4511cfd880b2ef47e79b13ac6431c9524d2baad474e759faff35c24ffbca64ffd2bb8e893865b17b155cb80a705cd0ee3bae5076580703080502d4ee0d79dfd0941cdb7ae886b5890e99964edee9470010083596aaa3310cf1883c00a73e497df2f86c61344ab1dace920537f886d6bcc84388e21b251fe1653243bb44caa3ddff2cd9270319f1d258e21227a8496b30757d416a88ca32b0380743ee28726f28ff9683aecca4d485776117d21b140364bbe59eeec531a384e79cf91d7ba4932df31ddd2e7cae30dd203334c07333e952517a550585b30c41c7fdb8b75b98b6d07ed0748d1a5c97deb806a90943e3d5aca358a60092c24501ceec399a80ad5fcc1e6b66e9a9598be77c43149ac54002b8c7271c7a405ccdecda09c2bcf7d71b9ae4591a3f41dc2c6de0e63c94db3fde459c2ef5cf9c4f1a5a5ad69030dbb942f068102513e117672cca27eadc440b5d9c14aec9c5abf6ed8368f72b2bcf46efdb79a4abaa805964eacf5dcd2041d83b460cdebae183aea7401ea111daca41f602eabe472613560b17fae8ec55065b62607fc4048c859215fa7def32f0479560f04652b86760495327ed72ea7f7ef9e9340e1f508fa473b3aff9e4bcec001b42c89366f7e9058f45e7c8f3d2569da133daf0c16c7f432d3336b46b042ea97904f63c6ee6e4a3d27460c58f66ab470a162ef652eb052b7ba75cbf66e709050891d67c0e54a4541d3a28c0c8b8e3f4b99f96fb7df5a1df6a34212c97061bd04f9e7723f5d8fa35f5e16e0bdfbeed42ca19238da1fcf92908235c31532604be763787c8264bc879e2dc717db252aa460cda911a7d7a4c2408acb6aa6928c02af8d41a7b185bd7e4667b6fb7d51de2a9ec3dd0e540ac31274f5f244fd4b4b02c813c8f21dd92f5377e29a6600b4c06c3f1973537463361c12f48b36c2335a910fbbeb45a512e3a711b8adfb4c3292bb912ce57219d9f7fb94bd0316cfcadb0cba2f325cf4794f4d022c94ce23420e5752c2e2cfc27b52b7215ab79788bdd8303ccd334d4b157ca6c53a8b97540e90c3207fd32d3d6e9550ba0e1ab165ff3aff79611db09be1056693c8e3ab23ad71bfdb42243b3a5c825bd5df9173d6aba481371ee686f0be05614af7b370bf97343c7daa80fb329dbc9183cdffd90cc31d0c9159caf999615dc5398a87d49e70304d517ac9d4c6678a9259f84937f5ea4acdd6a0c4fe31a606bd7b5b060169b8266a3a7f2c224cd9cbfe2f5e4e5e5659532ccc30f55f378fe01a8b1e76f5bae1fcb92a797cd0806f70b0895dbdf9e991f0d56cf7796682c86e022d58fcd7d5a72cbde33a939ff58cbe6b5534ec3cd8b39869d5a8f23db7204d5bf447f696dc43b2356b6b6fef2cacc625ce9ab6b30747f06a8c5c3d0646f032b04c142cc1aa26407ec99e86fad750f1c298f1f52d907bd9e765affec3bc1e8aac91b8a3209f2465fc6cad0d4f130c02c5e116f105b9974c40793cf58b8c083f5b63903c6a754b11c346698c40b54f6cab9a4e8fb4dd3a00f62a5875fca0815b0db85dc0809cd301f3fb07827a0f8b2b1a54e17136d8f69300433a0f1d77cdfa317477aa3e43742a53ca9fe255ec2b58192ff3e4373d5dce3e6aadc323592c0d98e56e7c95f8d15dc028f209f4ed48657c6c47c2d69a5cda68a4b52e11e210891a55096058b7f7e991016a563c89fac04c64b60b9f9ccbd392fe0e48de7abc569859afb24ff6427e84684aa8ff9940b4e35e336a581575b6a68d2652010da3937f793f3df23362c58468e3b5ae9ccfb028a66b1dc9152f9744d1a2fc2e7aecca8b894f1ce9d01de362b9e6364389d7f76e7180950b83d8282a1dff098069e46ad4dbb9c9026bb18e65b3ac612c38b02b11abe766b25fce2e65265e98ee751bfa2cab969a19ef4185c1da973febe4fe34c7e8e584f5a1be0e9ac7c9c7c02d4956dfe04c88d83573a65bee97955466db770cc58be7338d1265351d2a3b51237faf68bb51c5acf9d8e0f38b4c87155b5990dc97dde92636e85cd26a28ae2fba5ebbaf1483db68b6f77428ec7752778c0f9cebbfb57be5f3e5ac9e115609788d783f45f7f03b349b566abf400576996d786f6a0ba5ad8caaf7f75b965b8b4f4f9d3a6e03a08f72972e17c12b67f2aeb7d79c8ebff9672dabda034b64f608ff8f41fda9b9bebb19966868473e260b4a3d98755926c1f1ad77926c3a1dd45442d11774eb68acfc845534505379487ec719898b3d97b234f5352843f343e09ee2577f737cc285c3a96ebff37242463ba524f1b5c73ac0d5709fd765ff7b2588298f3a5c7639dd5cc25ded4300de661e9f132bd863fb6b6a26c37211b51c466ae9dac25646d00b172d6274f98e9664760a53029287d24249e3f2e3c2cdeff9616cb924d8d0cf34e67b94b5c47cc63d542db6a48cd41476ddb7f3a41f3e4494cfb3ef2ec41cb4e18ddf32330b5c4e8a074ae7031d94b857da10b5897f2d1abab153c80c8aab25ff0f7276525bf30c8264ad2a9fd65eb052103078e8e4c953d8d3f77067ab850c76c275c3fc82b9df4fcf82b509af13b67d872f9fbcba4a2b6dade50ca7d1a66ad7ca0fd405752f2b81af3129141fe2b9137ea0145473139c6c067c01c92408b30961b4185ef2a7883ef4da6d206319c37b468601d027de438b58bef87218f12710b5aed510eefa9d0bbaab8cd2a1cd36b17580ca2de381cadfcf510ddbb9d610a006e9c1e99649c20c8b169da198db92120d512a23921bf0983cbc4b56814a553919d51093ed1997db2449b0b84bb883180895e3004eb2f3768c774724ce96940a69bca178e536b7428cfef6d0c01ffaddbdc5c46d9e1075490994340ee96eab2dd7ad6a5e08ce724132cf8730b27c2102645a904bd6013910f3d0814ce1a0318ce2ff37f278294ea923025724198ae77846b66a60c2cf09268a3f2338719fd2c9e106a2ee189faf0c0871a71aee7441eac9dcff95c5e71bc71d746d1f2c592116c54b3de540f6f74d38ac332d1b5a05e899754b953579388e172ddcfa5b91c45d209d58296bdf27a8bd5741854510932c5525e9483e589aab0ca91c07796c1a1c68bfbf5d098d6c1312ee6a12a404553e90d8e17f44ad80cc7dc765f2cd574ea124273e8548e213f750a68d033797030517da6c6587e35da2a5a8d9aba4ad7d2029c23ffdb7b35b821e965dfaf27b52d48a53a22a3cebbf69378bb6d2643799af4b45236895187e99acfb3766cc53ce5dabc7ba34bdf7b5577b48044d88adf8ac9aa18b514fdd4a9d06f1f12cf8877f4af9987e41f1fea8ec811e720d293aaeec36746df0f3251f57543eb45ec8265cc518b831e003bbb5f5a68fa71c9e950cb2d09816bd372171daa2aa45d8c0b292b0e89fded3b7163905793618e6db653147cd6741b2d285df73ecd29c589e2d6cb7b618186611de9efe2ee5cc3859c55761732634ce2589a5ccf2c64f759a99deb0b5f695660f93071f0e2cadab4e78f7476a98d2ce7ac93d9ffdfb35b56c1178055997989681dd8ae972bb8daefa38c9a9a8c35fac47023c363e836119c20dc39a618b5b5e5d2edf4f96a2a3c18b45c626d9b94fbe33ce637106bb7d836100d60a7782ecd4db235beac96caaa0f7e4e9e456ebec85b7f96999de8d75c90c04d9bfaac509ead22c58021dea6a5683b386c2172d95ed5b98228070d5f9e86c354367486548f0e026a324f2b8edfb8cac0c1e192efd6b7222cba8511eae33840fa3f69ccd3be7e3fad8c6f27f9f78ec399d7a57a0988e31bd12bbbed7ec4921c4da650d270fb43c6df25299fd2e8ebfc58db07bda9982f5ee65112bb20c1e5d37cc1c840e86319837ca930111ab0201f6d04881ff8345c440e8a69a8702da85d54a70b7657c8b6e06795369b21f63da9fb9cbd218ff3c208f650d1360a224513d19fe651cfd7801449bfe3057b6d9b39ba3245fbe5b1ae794da2d75994584d8a584c978a6db0c821097e84d8434d805e97d8e33d1ae82d9f58342d8b137d7b22077802a8a7198455ec0de78033e749a050ecc9f2ba3106649083552d33c249564e779cc98c0363fdb5a986013847c475e88a654c6219cbaa840d1cb84674df8c8437f28e08047d91e58bfb969ffdea363b636275419d8608d4e71845c9c8bd32aaaacf29ec6a00e0ce4ae3da5dee337c927282f95db750d51d8588094ec674a27847c9bf58a26ca79dc733d0c4bb3c1b22713ebad4ce30815e1ac182806f82baa50d3765abd4c1e60bee05b2924eb3af7cb382d84b616c08e31b1474e4bdc46a8c504892f579e6b8ed07e0d06739dfb3b79cec491a1eceee8b09dc0ef16d3be8a5ca7b27f3afe403e71f1dedb3917004f361a438b30be08b912c71e3d8359017ec0433fb153d9c7ee97838d44d8cd1e89354ea95bb7d098782a168df69cdc964d2944fb54ab656914e5a1e7c4f7cc8ac1606aa7d6b68590594550389b71135687a2f464e1e28c930d4a977e6c04142fd49b5a30c1ef46d5637aabb3cdd5258dafd2c4070f6b8824f000d4f15c6452a1fca03b64bcf155bdf7338a932c24f5db0c4fdc52670edbe114597cb5f5d2a58cb08a8465175a13b9dc4206355368da646bd60dd0861cbd351dba5028a5ea590606fa47985720734b40c2a93f5918a3c47df863d0c08ffc30b9cdba346ef4fabfb27e1fae757d94f22f3b8a3ad9dd4ad6c3354749c6cafe660ff9869ab72dd36927c1be0d8c887e4644eacec4ee1b8da618a8259451782c213a2a089b29555ae82ec83c5a3ce722702cbd8506ba6b9cd4572eaf688950654e0738234cda103097dc4e473b5db9d6ad37324bb281078fdc97fb4f65e376ef19089c42a58007aca515ebf3aa87771d66a0c622a15e434943e6f6147e1ebd70cd93bfd5a5d1695b8108992c35822b382e3ed03df0a68ae999dbe271f32f73a16d368658e4f74f522b15d37a6173596e69e6b677306d81f2d4320ba1fbdfbc2119f2bbe509a1ba56d7e1b2229dde33e1a823ca1677441c5c9a68c1de7690ef85bbc786ad32e1c60a31fe901200921ed36b2109b73beb6e867c7f32da826235fa95222fa463770d636979a89291186ec39f5105a070dd8971f314afbee5c232379e5c889aab844a421dc8fa2e7db9f5137100536c2f4c8b7ddaef9c9f1cbb44a3db97bc18e8c2fd0b5d8d16f4f10c4ec0230bcedea46eed702aa44d3cac28e61ac72693dd05a6cc0c3e9ab08beb9c71b322f8837a304f66a5cb0441232e16805e2ababa44527bbc9f0da263aca4a09f60c6c672bd7d92832c0745e6e5f5879d2ddb08d647c528b606537226933d43d5b6cc0092366735a334c8ebdc6b8a909294d77ced94b973968113dfb6610ac984632938826aadf2706edaa3c2c3dc83a2d3ab99529273cbc75e2102757e6b88ea0e1184935fec9db2df5b73a869609c54c21d8309c6849545394127bc9a8fa1e0dd6356b81c03cbf7de72435e4a7fea5fe83e006d0a0ecb1229a5a1861eaef92c8b557d5a5305b42cfdaa0299fd9478cdc56659fc2e78bd2f3f1fa5d13daa9e7c1d4f99a449ae41e7f4e9d5e72acc7342bb67ec1ac5411b2e948c24d8ae07a7977dee195fce7b7615b2be4ec453fca7ddef9a64b1c510dc2c2bf86de425c495f5a79f746cdcde991c13e13b9c5a762b5a8d162ca23606f5147ae2eb86e27ece486aa784d707bc2f027c52069538e2680e79c4e48a8d5e91acc1280ab2ca5ae3d2f6ef05442039f164589871e3ceea2fd917203d0e91e43ffb89484aefed37acf5dd1997d6048db54914f13633dc10fc80fdf5df83b1595ed187d815a49cd2f047e88341798d53ae44c6d2889c24d005594608b7fe959b0de52206596f3c1b0a8de35f9045826a7ca1afade5a788e4ade2fa3ab1550ff1ee67b0caa4a3b8fe02688e1bfca2694dcdd2435d0e2c80bb2d6033344a1fbd546053134bd84e8de3b03a2ddbe507d6fe77395d8bf86e7d9c5db71f9c9bacda7d5881133bff980dfb6e240284c6215b7c8b1bfcbce1e2a0d1c5647a225db047dbc66f87401fc321b2b4da4742c7aaad5c15c0ec668c55795e3d6b96517130401ccaca007a45e96cec64070dfeacdc69e0c03731840d1f2ee666fd61a7c840f2aee3be0f5ccd4b5d80245d76fa5a03d45e41b29a10fda3b635489e3eb09ab0f61b1fda639e59ea3c0724152ff15e00630fbc8a37a703feb11d52c94c175d94beed78864b743d7bb5db765593759554a665da8af6a62113db6d69284b5fc6545a21d1785678fd0817e0712c6a7e44fb9e2a72315edfb59490bf0906a550d282fe893adc91de86108a2a200fe751836e2323801f46a04ac102dfedce8f5a3d2a0498e34c72dba5d02009e8ce504abda5cb4c0c7ccdc716170edcd01d3c0b1be711acac6ff53e28342730299ae4d16230244e320bc5ee4f0e8a5a6191c585b1e8fef9fd3aa585dc7ef7df048253f00f0c327eef72e00dd0496ca1651bd2df0ceb47f68d17631dfa9c42e664126b23483cb0ca6d2f21524d40d792c2dea56d05baa5ceaed3654dc70921f8a2438970aff9388bb89c0b5a81178fdc2116f084af62e1edc3e57df205110c64ef655b1d70ddff3d9613487e8ade22f53fe24535df64be39d4e8d685684d7a3d11b0d61ee7ff4ede86fa3ee88734705252d49c781f8e70c02dcc93fb60842c3e7d483c7b7a6204fdbae6e8b2908be0d28e2e9989e59d0c9b41a8f934b9a26ead067233173db3ed60c0374b142bef7f46bd28e50620304b598dee33667f770706e3f3962c622cab5fa1c3d6ca637ac960bc9ed0f8124ecccac50f3dbedc12e60c9dc9f010c433d8bdfb9110b02cb02e5236aae6597ff1438578b37271e7caa6fdf2a0025b9d219c5c494f91aff299e46768f302b5d8db833653bdd548b4ab122032e74e1a2d10e8a9974bd80a529beca39a2a1829e28075299d29a60c3e7c6c375dc608f0ff764c29d815cf64a72a22791a02fd23aedc61c6855f247636ba6280916acee66a89042c572f6b9730632b4c2ca6762570024f158fa542f07ec9a26a2416144c9dc505cc18340d05765788e2fb12b24e509e15cc88633afd14d0fb60e632b398c34a49be4a462aff888353984f534cfab822565e29593f8c2922f39a8d90d37b599f22ef28ddc94a470f3b2f7b378890a8438f2804addb8acfa0740943e1e7e3c77a9aa91b79a3656a3f800dc8a0352030b305db5f8b78d8e2857877fecffebe7813ae837f8d993a02cdec07c59fb5d9338d668ac83960346047d71395c862b79ef777b227daac5329a75b1f5ed5a09ece14a7ff6622a9ad0b201623dc84d3825f0af8181ec30b07d0e1f963efb72e0b6bdda0bb7ae05d157a353dc8bb1ca4b98c632d15c7de125d98dc4b30b82dabeca0c143e537fd2b96c8929c3a915b21650b407620a32427e645ccba46900063dac8d5f0eb08bc1763950dc584ceba54b058a646a75fa11116641a3e028961a79f356db1001cdd6e8dc5cd07597d69e4aac3520a3a1c620018837c5db634ddf2604b3ac25c6294073ff3c4243811a30a70f9eb0bb6dbdc5e4f158c950ebf092b95914fda29e34a7a4902d373a8614b0a16104b2c60f46cf1bb7ce787d69019a180526f3b9ffe6df7c3064d9ba47edec835ede277d1b9ae5258bfa115ff36b5e11ffff3e13e3ba55a039b59262aaefccaca87520fca84c351d2f1296a7c6728d5f655d6d54bab977d7f0dd159d68bc85c67b9381a5a8a7254e12688a5adccdb869231f1aa22446c73052f66632504f649f885fc9a340869b77e3980570ba2ba4a0e1a1b41d2021d41a8825e29a987dd4c4d4b04a6514718179ff8fa1b9953c387787ab6780a43283712004530a198585b50a180f4d377d164bd97796cd1e456bc86cc2f977c11fbe5564f5956b004630f492c15da10e95d8344933903a3279aa36738dd5d51e078772eea1ab658dab86cd168b9d6a51f13a23dd2a63440b954d149a3adfdd1353c6d986d12b1c9e50606eba7fe4f40a02b735f3209862d8d8f01ecf8c35f727e1aeb46b910db3326a56ce5e81855a88238e6a04732d0884498be35f4b97305019a174336baabdf405b43aeb7dd901afb562ed5427178a7e7d6a0ff6aa53ace4ea2c55b3190d40077da39d05fe00c50b181206a5cb2e63a5428bbbda1e2ddf08b00e1b0fbc47d8f40b0d49a206ef4f0142e45a080e3dd41c1cd2c69466810f14a29033d87567f142fa1403cf5f9d1756fe4cad89ef68bb81252140eb51107f9eaf1e5fb5d66805ed85abe1f87e0ad50ce8fce3b636b0be72ac4e7d620137214429b11fe7a1bb520731eb7ee45ce2a1ff822cd1bb7e5cababc90bd0baeec7bd9e9723215e66d1950ba74828e84ed0152f0b3fe4f805132a3921ac1083349f43b8ae7a7d483eb8bbd33afa8f62d463f99cbdc804c92a51e24bfc36244b0bc8fbc0404a3195e91252c70bde650fae1d0d6c357ac3e6aa48061019af580fc6dd4662a54a85fc7f22befa6fb6f7c043964bc81b4d8852f245ebcde19d778c238d0f58e8420fc16eb532564cd10a124d679c016360d16a4868b39286487290551664c67e4c4adb5f47771ccd1ae2692b330263a23d84204a8858b1c89ec2c9f1a2eb47377bb946a4f1e7845bbee4465650d2316c0179425e540e06ac297e249b826f991602a3e53ae53e6e84827673b41202caa579597d44d831eea0908a5ee408a21151b369245164b3f41a3a5529318772341412d3fb7150af78f399e3a4735ed5811cbaea1d04bd2ee5108a22773ac266fdbce50458b798920ca901d5523accaaef749d10ba0945de41195d58ccb1b42064afb2e9add25ad4f2a9a5347ec57b5cc4d28aa280e80030f6ebddbceb848bcb6c3188ee03ece8c941cd28c4f557771d0a6666613fe9426dd035dcb012c7f9df971b194f8fc404e9eb7c2190a09c2bd6d4bde79325f562edbd677165e36ca7b75da75d5c052880810a4f120109de9f763b199c602cfc9a8e71b0c07185bb2f7f6fe6f1b3a42665a253eb6ab9f42c2387edd83d5b4312546654f0a94a164b3cabd93af38333dd4c37ec4073bcdc01d3ae3fe6ff18c0172a0fdac14587abd3937b8a8f6d765f4b890044f26c2b5a49c66931274e8a0562e244bc349c44051e898edb6d0171f45878e0ddb24ceeec094e323bfbc8280a03032725ca50782328741fb6e5d479dd34be0735e34584457a09dd7df618c5435754295c238498d6ef5356f199b0a4f60c1a14f6bcdbab31d03987791cdd9842dc112f39d9ad82daffa238b6867c1838eb55005cb7b3b0acc13c7fa29a29e2531e2d152fc6569c2c1e51908193d770118c7e535df0834c9f40bcb6dcfb499559d012ef060f19e128bb27d0ec02bb207507def24efec2cfc6317f32afd9b2f9fbef03a71e27c336d69655d2b800a07a1f8157f2713cfa3f3a2c62e0e6ade879b64eaf638014acd87efd609c0d87eba82bbb5b0580b4c355101618e4d62706524140cff1c9194a90993643776f587c706fb101dce93e01d31ac745f14645c78bc1adc21fcff46f891919e4920c9746a1b81273a0ea317ffac767446a7da33879b0f014803d312100cdf10084080c9e40a09fdd11adab3e72b13c986d5638e36b011650c126b1e4bf8eb7b13830aafbadbbeff8935f42564bc925b56dca7779204ccd59f3f16d9c6be28465e8f22836c8546ed7d8093e558f239be1303a6e215a4e894f14817c1c4563b51af25f6d49e9d48dba9257445cb614613b465ae8c59f457632b7287cd7c521db73503fdb5378edbc909adbf545fe0d2fac31ba13ad76824b53fe124d9512294aa657fda00eb76011316b25ca2a54d290f7d5464caa81afdff3bf7c8fcb70b07b9f04ea68cb175f2b6772a299fd7ed5fcf1ff707379bf419e3c950ecb5dd4f7462bc65337ad0fc6b58b7ba1cc8ee641d1672dbb4bd2545eaa961d0376ced4a75f31976305f7e28865e2b8d22770b7f288ce477967812ce9c13e32ea39db2427f3fbbdbd58eff4f5f5a5f6398cde422cb2cc67b43dff375b826f48c3a91520b1ab31fa766f36da676e195930781727afd614c9812db93ed5bf93c981d878904f458a5b521cda35e35ab273ad5c64f7568bf2a5f2704f98cde0aebb97945c022ee62361524d939981f83a508a1e6ce18442f298d6dc6ffd405f0d673813b2beb038461c4e786de0a1a26524d0df4615032074adb9f095866ac519359a74f7e295841465fc1340992591e96d1e9d6383c34edeb6bc8e204c8ee62555bd5e5b2956a912126bad37634a1444873ffbf1af590bc25bcab933cddeb649b93b1036618136dc31b436cf0d7ba0b67e6fb873cb3b4814c7a3d0398d85b24125ed9095b97026a36a86b1a122e28087a155bc2d404db19ed6f490244d27687416ec8157ed6b60e28b12affd7872954833827cc42b84004d49665f362c796243adf45e3a1b88ceeb8dcbb4a6219ec3cf0d77f7a300875eae16646bb9e677994daa8acaa8e4d24416a8b36e68acdcd041973a439d0917bd41265371a461aa92ce891ee3145426d9b07e7910550edfd6bba30c64c72ad26b3a7b2dc4fa020c21928c4bca3b86c52cab52268e47335f9610d1913fd7462d4b6ed95f247031dd94d6ab87be0bb2e5b5ae34ae7c63c2239a862b4486fbc992b72dafa6658ead7dca140adcf0df81c369d10b2a55047ee5687a47bece9517814aa93a9a06f0a94256681938467eaed2eaf9fe353dc937ee0247b7253141d0dd2990b575f654ec745df8a445eeaa26c1716f55307fd4766128676956001855b47c949a55c9396d462ed6eef9cf1e45c74f60b7fb7b94aaf2ed2e78537099aaa2386f4ffae7c6145f062419b6f8a50f35a137d681424cc8d1dfb3a2a8d1888bab51bf606364f93ddae642ea1020eca60b713e2bf338303e39c9c04c6e96ff90191682fc62ff0659a7a6d5c00e5bc8bcabadda0ede70d63c5d3b3c92677a282c380e9bffd6fac3d7b1a785e7afa6d0a3612375ee2634ef080fbf02f5d1dee7f82df546d13ee434d598f010bf3ba3b057fd50a034e766e363d4d1c2eba69ffb09e6b8a3b0df1ad28bcd3a6a53ac68f6b60e3cb168ad71a9e929583ea6f15b55235a3891ac29a59a9b7f1e97c26c44d7e27e1288a766c38c24ff458d4473b107a5aa396b6ff952f1933f65ee755a9bdf1909ac99311ce9a6e0a5d9e90317fed54c791f824c1746490b854bb9d5d74bec908f11423fddcc88c9068118bede3c3735ac99aa23c4bf9e30caec233e8d14969e49dd5719caba88bff0375095cd2fc7c1e92e459b4028f3fe9eca3c9e289e9575abb28baddbdafa41c27575f6ceff8d1a66f456ef12d080a356b1a3174401c43ba9648892a68c216e00c0c9524b6a0a41f51004b0cb0bffbc8ced7bfdedffc0f5c53b7c7f80e3e4f5fa7bfffd9eccaae9db7243c486e515b35a3616df873d592a4a554ac5d8967777ffee0477b65104122a8ae8c09f8c01a0381f814b6cb86328ce64eaff53f4bd571888c4de241666026d54ac0da30f5621a1c4cde0ebc9c041e3793921871e3a47562ed21724810be09e61a216db14bd76f2b03e24a5c890cef5ffb2b34ba1539d1503f88c85221e169cd198c11bf8a488898313327351b32466de088c66f7f71e3f45c12884ad9bf70e5389de767cc6b2b47269ddd1533dd64e7a1b4121bc00bc9961e8e28e3f0b3e4cf46acb821382f60ef4215d6c5863bee84ecff1839b372f755710f1e33418ac7445dae9472b269c315af2f783463e4c1e78b5c037ff03501fb6da2d9dacb34a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
