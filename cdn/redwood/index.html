<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4de42ce85774ab216f441d82a90d2a959cfe15e6c0943f92d3f303aa8ec806491400824b4389826b5357fa728c92544ca3072076a17a1e1af1b106f99534bb4dd7892b877eef64db08dc550983c9ebe6786358ec021dcb92c9f6582f90a97deb68b3ae05ae2604432752006506125bcd1e6aa8e699d1e545777c9537f9db9bb96c79094ee4b0af617a0f7a53d90497bc4587c0c36218938d4bc08597ce54f55819e03452b7c639b9b7405a6679fcc3052754a0916aa5ac5d4fd4bb9fad9ee243b58c315aeda0d40d0d97f7287da40a9e85742d2672912891e90f7043e200a380165379834925e13634dadfeb0574bb6f5337280628ce3b9db5538466a8d687ce8a0ce24571d4dd1ff0df0a88def4e89cea52d7ac64c7162f05f0424b03cfc818de4f6a84afeed487af5fa106fb5f8b4ac4301d23ec426eca1fd8dbaf35ff73d7500fc1afa94ec0e3d2c12b785de07bb2e2458224a7b639725a91cc9a2117df1b446033a932c7be95ddeef055b4f842ad90d88e47edb6f609d19a8a2746b2ecdfd1777cb9b59bb383a5c35b6074a14d5d4eab992e7491292bac28e78b4284d521a745818526f36ef0078c30ba4daa60b6412f6413d804fa402afb625e4a23f1f619cf8c2ce8de6ddefef47c81150308e7f7f8a1b731d86b53dd75f9336a17f161cb4dacad0a756398b22533cf6757094ba4317c4b8d90025374ed67ca996bdd4bc4b543eb71043dd12eb51f97f9ca236ea45e9a6849d93eb20c02c25a10215ad6996cc5ce640baef38f49ec1e8a04565b5e92950a872e8c7d6493f713b8ed7908c62d2edfbb54c6ac5b6949e6d0880e6c7c9db8b39ca5c1fea40ca8c740e5818c73b96b0ce69be5905a3371cf30e446069fdd9b2e5bb5f69c4140b22eced66774d1b74a5dbc72e5ce4cd85bf0b0b1cfccba2e8123a5c35866970bc10b6fb27b0b4cea61253a1d31acd9624598a74114a2cbaeee75184284e5473fa6663f0acc9af5001e152ba0cfe9519d5bbada5447ca8ad8518a996cdd9ad13bbe077b6a43b2cc75581b1cfae404516e373eb515f2c3fcb9a193ad0ccf6540cee44152be1b613f103e5f7499687a0739dbb774b68cacc88ff604920921afb36a99696688926a7c283043fdea31d9a4acad4228754ff82fe665f7ef4ba301694517d119c4367770f147d46a1eaefc9dc4760094c5ba9a89c0d0505f93e47cc1463f067097aba9897abc7bb252b3ae04313bfd066e8a8a5f03dcb589018bbd6b5c515b8df38ca453be221323128f2a2888ffe7a37466a1670ff1e3116b49a7b12f81dc0bca8bdaafdeab1a109d56568d0c66ff3fb4de70419f94d4b0fe3443202bd132c5523c5ff3cbadae81b68e4aa2fd3664d6b0b478a73aee1756855728d46347afc4a464c741684becbeb153622782a18e77312bb4ddb388244c0c806ff10cd7defed640743851e85f98d871a8457e453f4583f213714ddd47680b5b064a7559c1db3cf4b823dd91216bc5c13efd332340ec945c04d11cc650e187ff0672b3280d20f8e1dba7d0b41e8c1db55197ab401e9c6a9596f09d8c928e749f9fc3c321f150a9f5f586b87994b4722b2a2b9c069261d8d9837c7c5981a8ef821e2c5a769d6517ec3fd049f39e1822840102dd3aa8e6e74f98a782534b2fc3a37b619f768fa6cbd25ed5613da47824ebdb089cbb5896135a2fa2f9f6b8d0e3bd017b5499cb01f55b54f186898c12034330c7a92c453d5a837efabea348f5474f2036b8e85fe4bdcc408604340db2d797a3dabeaaa5bbb417ddf472d93e3ab62ab212e401228793092e48be97c3cfe9e3f4a268baa46972b4702bb0964c81d5dfc94432825c62988702a0413919dff65545e2d16eb8fdab9d0aeb88da48ffd89c98c360d4697107ea4087b699dbf61e6e157b1dba0796128ed26f382296339ce18ba6941144be2ff74dd848c01861efa42b86bafaa635ea9baf2f83a470139e06f0c22e7e9f3638bfd536cf7ee9f58441552eaa2e0f3f18b6449ab7ddd38df114b10a9d21dc0aec65c2262199fa54cc8ef215a371bca59077560989d10bd52e34fa862fe508a2aec23e5d82765caf2ce380d6c2855cbe43d8b78f1b605e9f4b1d0e91def26f4fd970db9067fc4591dab46cceb4f972ac664477c88551a273a17e1c2c7f44d5ced72e343edb237ab12dd0637ac1e9cb04dbd8ed5e2b69af0226a70005951d34182eb566dd564659c6af2a550996049b65af672ce037ccd655118a7cf985fcc278520de446fb41ccc6f06edf0c50d86c218e4b267d0dd3d9fa48b892fcb930358a9bd8c62f100946cfb372e488661b2e6b4ae71d8c3017b3459aacf20465b8c77751953053915e2afd1bde9afc37fb55f914108ee12baaa00720bd3168fabb7839f8403142cfb474147b2f17a77e39f72e2027ae2d854fd81b0202b1c4b5369b0e2f3f782e5af4c6fec79dc9bf8a0745645ccf3c1a280868a7d0a42aa2e486efd8dfa34dbbcd24c3e3e316f16ba7c6e3a954e97efd88c766f888ef33bae12808aef70053ed28c75a7c5de17f7c7b97ebc1cba197e926b5b78049ca64cecb6ebc2f82135aa6a5fb17353f598028a1968a64fa376cfdb4b09e66c5eabce7acdcda93c80f30f9c688a2b3b390758df77c24fdb61813154b913113379af5fea2450484925e55ebb86c240d931cd7da608a6725abf1d4a7c104693f4ec86a376ba374fa06d2b1f1e1e78500f7b9137cf5bf377971f9cac01648fd5cb263b45adfb86b27a498b8e8e6dd95b7987017591808f1c5926ef0458ab5552e3c4fa90b68298b716f14c7f86301457c6bb4a5daddccb4c0ff2a1936b71138e7edcb76e84a6adf7cb4749174420ca4b0fbef9b0b6028a80c9c8232287f5a089b3bda2ced270eba51d8904d51a45ef8a353c9b8e0ea04cceca8e98862a647f6d9c7814780600edc9820d166978fdb175e81b2182145f5311aff2640f20bfcf2ab0f6e91701d914fbf9d53e04b18cde13119dd9071874a71997ae71d52ee4d902c16bdf3360db6c2c45ee4d7c54a2bfc8adb69c226f4d9f794f954a621d321004084a2581c0d9ce3d2ed61679936d55dcdc776ebeadb0c9954675651abbf36714ab7665d48f5331dba972e41bf74d1c4f4f8d10e65fa8548683c383f8fd4182139317c6a64a4230370450fc76c134c090e2d90217449f2b3f50686eeecc36004ae7f3406aa50d5d256d031ea5093b1b4a88720a1859e70cfe4fb7bd48d2507e421aa8de8b0be1fdfd37c87cca360d06125e51bef7fdb3e605ca722a374f4e7091a85425a7d31c08cd319570993aa3bcd9f2650b3b9427dcd0733d65361cf055615c024c2a179adf5487a6e76b7c3cf58489aa36b79f3f0120d5da7f3a32f4ab14395b26b5975d9d56c1f6533cd78382f06394b90a4d6950e2867b089728b40977dede416d5681d7430be78b4f6883c9d68bca47e60cb86081bb52b9d71990ede1fd6e7bd12c451a1c31bca61251f8a8511fc32945b634b3b8a9c23564a35a3f054b1511bf206b928db867484ffe8545a02940716812a3a2dacfa8d4cadc76bde26f50aeb7d244696f8644a515b1ca514bdcdd06d39ca6ff701fb72399c45d313d2129d922ea2f6d324fbd4166bfc544b6e6cd1198b156c8a7f1a40b631b7dd5a7337b9254fbba4ab88062e5c5c3bed8c7cd77081e70a51006536475fda2c860074cf1c851e7bacf68f275cd40ea3da0593fa6f32c9e625f2356a1004b8ebe9858d904d08852004f79d11ab6b4d9476f01a7c780295824e8c62c0ae5132ed119b369346af0afbb2687269f1d84117d0d05f3e677e70f4683fb9ed5686e3b0600c5444e1c1566a4cff90c9a3976f605de683a84ca30415e0b9e8a70a021c00ec98609b955767565c7ca6775cc5af9cabd01cf53fde18e47dc552044533384ff897abc1fecece3f78d0dde39b5aaa469f858c6f40c328e596d8ad5ca977b0e2ebf7dae46505c9db830a5220cb938124505c1650f0c0450ac5d6e42b0b5958bec6daf3a76a40cf47b40e7ec1283443d00796a0fc3270fa9a2e4e9040808f8f6b8e77cbeefe4a5e15da4377cfdad05ec481900f9b65e0a11a196105b120e72b5647c47bf8e8a4301f81ace429b57da1e40cfeba1125b0c85d20e72dd574c16d86abac8c17cffeff6de1a5fb4ab981cff83534628708e9590c67bc985f087e1bfb2c17fc3f581014a94b432643599bbf84f9bdc45ee3ee4b44cc9822e8ac9ce463147b46f7eea7eaed4863820acc6aa69bf75f69cbb43024e4218f270c6940f3412e65abfabad60f5654e7fe0ec830d8257c318dd3e2be5e1c5c43633c3494f44d6385b6acd234efa11d0302fba93f1e1dc3fcac47cdb904f2c22db4cb2617464384f438bca07e944dbd8176ef52c451eb3e28afa473f4fda211a7ca1542d96ee70ac471b08cf07cbda33740a19a83343c581fd18cca7e643797d5486df0c6b0d84e75ec737d57fd81fb2915a47ddd23acbfc735181af72e8c0a029daab4334824317d4269350304eebf27e399a646f8035abbcf606430f9b7dfa0abfda8b45b8a200007d1ced30923a8b1076a546d1969449c98c72fc4fbf2354d0387729c19daff2a320d652b9a008345af55d543522f9db74075fdea97fff59b94ebcd34bf1b22c7ad59a12a07596d217b9eabd5cebbbe1d957d0f6b2633f4c7514f7ae69e260df021a8f887a30fcfbac8f2ec0251f7abc21d4c776205b627b2d6134267bae93a73948cecaa03e6d864dd50b515a37ae176ae63553a24853f59f9a6bebd85e25547d758642470b6f170f0b467b16581d618f494610f1a8487085e47e0948bd4f406a6092c3219258842dc7e53a975f34121fca4b703c04d9efc4719592188eb3786159631d8e5395f34b1274cff0f537124557c489eb601300a1cb7a335c8b412508a76178535167ded75687d4c0b979ad13efb79295809c54963315dd60fef70d64203e8ee480968012e7cdc0c34731b3981bd1852fec01733cc45dbb7c918202734c0181c0bf704b5a780fe88d53b9a9cbca2f45ef0abc58dbcf0e012aa5456d460a997571595c7e2626c5691e271cb955490e6cad93585e3cbd1547ea880769ed3264fae3390833c9319707182ab8205eda5aa4ec0cb011ad50f1b4eb5a32c852f576672da17eecce01fb776743c00abbf1e8827e411e200a903173e83fce8d2a9d4b8bb6f07013f7d60818fd656deab7812956008d0608d7794b2226e6cccf6687afe1661bdc80b44d84ba6cbb750c5e4d6db71ad180b9bfeeb74bd832c9f525e0b4003ff24c495114801bf80e157a17de86f78fc1a10b7c5e5587afbc073f9c30fbe23f9852923b3d30c420b237b388f8468d2615a783ecbec0e0e6e01040feaf3b9d4f3a04857af9ace86276d7a7378a57b04a2927c45758065182f5a86ac8a939bb472fa91aeb2f9ca486c341a4cfc632aaa27e45d35c20ad8a06b0fcd4aa479c775b0ce37b03e5a39c4c73a0a4d2563d01ec0a70b85eef8c2fee02b826529707d9c037349da1d423ad3828b534de927b6d444fe37585533531716e3c53188cc4f4d06b7399a6bfbdf945fd2d53650bf47c31e21433b94631e6b3c03913151d2fb67d3b2b9d7e9d8fdbbd779721233d8a5670feb0e014b038c79ee8f9ba198203837af1ce7ec5c3b6d68902a1478e4eb99756e235890141aa3d9d82930481c0f8d61c349bc113d9fea52eb1131f055129c9e5f8c6d9f2dafc6a9ad5684af88bc49aa2b449f535d5e84ed7da711cdb81bacb0d291335a9b27937925b0bc76f3e3d01f121343a22638c431e7f7fd309ccf3d77dfad820e9d1b3cdfc6bcdd577b02d3c0d1bb6fd3f8be7a71c6b0f5b09cc8ca450e9c9e18efab40c3cb0e3134f73f954aca0631f16ab2486a54c6e59c63985ed051448e1479448dbc1b45b245c4965af612c4f0b14e890f968ce1101ae5964e489b8fbd0e7481d964968de044fbfd96240e3304968c54157176d89838d712b99c5af50359d3953e13d87c8df6ce70a13657c86cd2f2d6e4eeb08b771ba0e66f1a0f4ebc526bacd911484cc008119922c7e292f57a3727a9706c778806a1e643bfd617502bcde800eccd40f8641416e0e48d81f47a709820eb63b4385f5b16bedfb1e716275888da2030b44911ecb6d48447248a8481de24c78e1b630c294d77d591eedc31a7b18dc47d08019d2a18426974d88e7c9ac797b09f01acca5de8595b5607ccaab858359d390a2db2391cd82b384fc1b09b28423aa7cf7867d31467b269c61046a254fad4eab9e3f5a8e376b833cac7f6c2c3923980c950e68ec4b9e42cf8769b0a40e55dab52e81154ffbde5173283c614d884bbcb5a9216de6a08967a82ee85e358019c25592afe008f40beea008cb587e591633af508d3ae497b0866767992feb5993b9c692d85ee292863538d1d5b54cb29089509f81fa36be1ecb8c54396797a19bc7ceb45d5c430c14be0884148418d0eb44db93937598f6cb1c3d07da282f85d526ca65744909a106a797566307a0ba1b50c982735de5d03debbc8aca2424f8d9be348a2f0310f573028668fddd23d934d6e9d35dba74eaedc68c8ce792086e6f38100300623f301b92eb8e90f6c7d57d6f86f93c18ad380a44e0c55b3e2002eaa3e194e94a2288f40616d0347bd28f5b755fe20af1cc3dbf5b458920334fe56371035004592bfc5ac4bc89956c4ed32d0c0a0da386614857a186bdd7ddc3ff26697931423c6dd96bb194f736362cbe6759d300e4eed4e27800ddcdbae24b8081aebaaacce2fa38807326aa26a1dcb66ebbb55cec1ca77d0effad52dc0e241286a09bcbf1a8619cee8cc41369caa2323bbee28e75c046247002b9df304c221097a13071256af296f2538c8e71db60838df76d5eab85300f56d0594132965a3a452dc748005d9875a919d10d3de0d4dcd75f6d84f9ed49344f8a2916e8a14fdb07060425842652fc591ae5968a94538a35a25a7c7c0632b162fb547957184db826fcca49d2be2c07338c9c4e8a0ff04cb7f081fcc75dd5dc6a207f2cfa09038c36e861665f46a05b9b12a1a1c6a3cedaa7b3663e17153ebeb823a5db339d13344fac32f08dd13098bfc90ae934315b59417f48b1a54ac792a29c10196829849a033efa82cfae4435a4cabf65f2f565e174acb2076f8d91e8eaa37e075f00e9d078325ed478951201ba8055600859640aa740a8deea7c5acb36db2a1d2af790747f1f315e09ee2a3da1cab162ef256663656d71b229b12bd0df5a546610b56ef226ccb915d335946249038377995369cbcd55e18c81c5d8e93ba7e3e3c2f5d5aa6812f81721a70d58c749a89306f466af758bc3b3b89f8bb4913fafc67713f8dee78656090519e6d299e4801ff64a7b01788a73046e7688d116f2323a26a50f182f4bfa6f04f075c3a7f9025deddbfdb1038b5d49b393a09f47483771ffe7c38bc3ade587093fc8bb16872a5d721eab63883c538da0f134659e22ef2104c9f11264826638c817424f9787565380a6f2dc756c05f7a5dd1d3687dc92c73cd9a0d1b960d9228d935e760108ff489070b7842a0644d9c559d390888b1f3605c4bc54fb1b8079ba997d5c5e16468d5bfd01ec279982ece19357d8fcb0781f64dc87474004120a597703dd7cb0a846f16bc7c3cf59f3267e1a75a767cab41274f766765b51b377fbf63429ba894ce049c346dd59c5f4ab86d0b29b99739c332bc68a03d53b341e1f217e39216ca101fd142255cde124bf2a71dc5fdd5ad5bf329f2309f4187facccf6938f081270629af6138cc3ed8b1bd8ca39c34b372c8a8d6464708ed6316e9216a6af998d68e49b35e8c9f73874dcab9b0681ba175715fdffbc4a802904faf209ced7d2f3b62bdf30b1f391dae0d3c88fd2595cba6c41b96dd3b791afcc8992d8c3571a10ff1b64a7c6604d8d2b06a109a613781254071ce5b55622f8d1ca7b11d48075523c6f958ee73020ea809ca0327098528ff60993bda6a0735eca3ef274a908a0a70793299a8563c26e09f54fbbc178567eef6242a5630f20ac6d92ff50d085e8a17b1f3fb4ef35e36dab831d45ade9f7a831f239485288b3b43e5a2d17ea3d699bad564515fe8c78355112738557d7de6459cff099187667df26be67ad36d170b0d61650b2850b33861da68c6ccd39091e662bd2e7b4ecc5cc077ef5080ee6e0b32ea440b91c0ca368aae0fa55ac64f03f8cf4c145b4d558ca5299ddb434e5aa973f5df7a03820f14fa896eb7412af6e081671c0c1dcb3ea2870b7f0d1fa2fefe88d50c33cfa457cfce2eb610ddcbe502ff3f1439d2ae32dd5b0e887566caa768044d141225a4b78506e2ed0a11b4c64a8839d936e6758db1441a82ebcae43dca130e449a885b9377617926b8ea057576f109f6024a61d88cb0b58a8e2c1cf2eea53d2a149f29673cca430632d91f85ee0156251e02bbf3b2b2bb60e5012eb3244ae3c9e866e486032066b1d2246458fa7aeb3db2239d7c4257c48b8a38fb433d8dd334c58d516ea456209d209f71261c0d36ce46d3c7468fdd80b2563aa247cae546a984ec61b744e053c8d8d44545364e27c44be21e16536f2c28da74e79ce8541a0acf76bfcddf6ee5c3bdd74ef816a10fb34d10b8f19758cbc8d067503cc1fd0077d1aac0a0cac9cc72aeb6563e132113ef071c31375285e75153fa13cffd4008a0b0643f9b6a041507c523dd5223fc2c16a9419efcbc76d917ba425097fd3b9c40f0e5cf6dfeaba3ea1fc3ba6b35944999998576cf608828173cd360540c14b481d31d6eb8ebdc46a193676d916f142f6d3c085de43893b3ee36ccfd7472a2386f6b2f60c3057e8caa66e3b13c0b28793bfaec736a76ec08d7884b7dfd1e0ae8981cf21d46b63061233da095c1dfa96ef5554b299d22f75d650b7b8400eee5b592a330abbd0789d50e27696322d6f54c557a80dad2fb59d87f9015aae8d8c555cd3072bebcd7bad5c5f7c6099e4b4746af6536f5ffd78d8857ed3eea3c5c5888de14fa7cffdcebd3f0d2c25a9a34d7c756ae8bf319effe5b5f10b836b7705f4d2b4af67c5ca9b11c395295369c7603d041d303cd34390e90b5ea680528bdd0b69f54ffbe91b2b51e26f1260c36ad2d90ecdf29777f302785c60ca1cf028ab372d7e0b9f806a6e7e8cf36fd1729f8bb883e0201e2c1cb3b0f325c565b31e0aba3fffc94ce299684fc4976de3c8a00f875b14f58df880f420895bf87601ba86da9bb657aea2c8cc14445c0b046205384a08accb1373eda5cec8c82cbf398860956e8fade5e50095871b3220ad6924c6d740e0312c2e3df9139b7f6984ab1c0b88aa1337a54190768e2fc66d613f9f2c25951cb92865f700fa5a366214d9a8de7a0f95dca5b893b32a9b8a6aff5ff2ec4d6a03729863af91eeb88014e8ac6aed6a280af7f40b4b24130cb721a829701d961be9585c8782b261d206ad2052f87fc221aae803f7c53fed5a02c82a4b153edaa8c4cd67a0e55b4fb90607e7bf99056a53739c5a8c67ae23a69892b1aafb1d39aaf48b0ccbdcea0e1199c2403566ed96c48edf225543d7f82ad049a4d5f3404fdfe6e9263e089932ffc73889e14ebc21db8ffee6af9b34e01ff8f29784ee4e14a1ab6d5a4a1acef3080a60cc80d9ad6c09f28c3daeac4c101af7f876b40348413469e3b2eb7ad144c22d45402098aa722aa31eaf13b62607866590599b86e6c16581db391a06f012cd6a36b9ce653761a31b81ccc972dab840a1ed8c35254d7b4c9bb81de801c817b00d0ae940b355cf3d629a10f51907ef54f4b1211825486fb2817f85c357373b47a55c42538eccd8b08c1119676a91ba3745aea1530a496908ae03dbf1fa935c2e53ee82cf2ef600264b95cf9034545bd7f7e0401c781a5771ea0240ee4bbadbefa5705e8a39c930c5b235bc4b8c4ab4bba1186f657aefab02093daac3affc6cb19c4bd94a31a0434ea5278bdb317c3643cf9a15dc6b58993f105777fe0466b0b94cdca4a7c2fd11354663da2ee0639f6dc6e61ae245e51f213e892b9518b245cb079b1de1fcde91826f3a04cea0f437e14cef20896c4ead8b0e7070769d9cccae43d55a4916fd75c7cbb4cf6280438cb665f026f313d4cda71bbca79cba5f398ea95d996bba3fed2fe7b32b46f83711dc963066c3b1767d970268e0926373feb04d4807313835314f301aa7977f55348c90ac8dfb76ede39cca70582a741cee746a881aa96c99a890ff23e22b57fecb886e966f764e94b7d1986ddf8f79fdac49c6954d712e478d4e60e16db63cf0c6158513a5e791dd3dc1b0815d71f77527e580b00d8ddd3886331aa5b175fcabda6f5b21fd48233d86270a8e8fb50324935b81be33f6702f0d2ec49987377beec3b3b9236571f2d0be9d9d3160f3939e8a1c2c0380ff45b0ad607d20e749dfccb3cc212e8f32f03a5c737a971e362f31e6f2dbcdb836ba441fce548242e335e7624817364a2584769eb479f0c6ef75b8ff581cc079d187c67bddbed1b8b77321a272400e034490f6cc72ddc64c5b1103105715e3560c205a326f23088e5036c8f7017985deeecef9e45bd585b17ce925839f98ee36016d6ee4404f3a9ccbbbb9c67ce959628730482bd2b316181c36761595f5b185d1d22347484a31e2ead973be734eb80d5315e8a894de5eef6552be0300b78a7b60e24b79f7e7c11c125284a8a2e6467265a657e200af977e9d2e055e9a03d149a18f57166f43088b77f70535d9b3027c51d6993583f27f067b3c3098b75a17eed232db36fe238bd620c43020f94debcd01f9544ace8c8ec80a3021be0aa03c9fc7a34d0aa1afbc5de636e9ec7c205374024f8833a57d3937e8667a7826d5df95661e68272883c746896e2e8f955ac6e467cfcce3268a247d301f53b85f1653b25f5af2b0b5a4367ff1197e819a7baf8032d6a6b640396f6a7626d2353a614538f7c5f195474b6faa5c00885e5b51850416902ec0ba9e583c08b3857869e0469c3d372df17e6508ca467ad16b49661efd511c89f1b9666769853e70dae677c98e1f13884b89c7abc1ae9712388ea1c77aa937b803de49742a0dda53052a8767275eb6d2770e6712ce7db00102b379b77821467dd0d10ea24a8f78e2ca3038743677b67c7c914961ff38198a8ad93dd367292d3cc6d5daaf3ad24eec4f92b5521298a97d1ae1c28e11a35bc30a93222e25da6284624f0798ac6d09912e42338b4b84d9513787ee3370ef8eea7ec9e748d9a11326622995284cc0c2759c81ba97fe58938086031e06355ee742ce73eef6431d96f9740cb840ddf670744fadb25de3d34bd0aa29edece35fefb02b097b57c067fe7f373e4e599662d9028411e28347df988c92b277f7360ba436928a7db4dd8abdaaf71f743f69f356a2e0323ee3bfb1e8716733479f5f2e7858624449a9a339a61abdc61f8a91dcc2488044faaf4a826f63bb96adb78e2f8ea97b131349fd6cf04d283ac6939e0ec752c7975c889b75c98078d38f0398770a44dc01fa0bc35bc1f9b0a3e52a9a4cb5e3f22c600969e0d37deb372883f317a7e3eafe2c9cf78437bd29a832da4efe01c8ac88edff392bf739c577bca6755accebe1690d321c0e30c1eca7ebffb2fc46bdb84f2e775af472adb5479fc8e37b1abccb9cb3d9e533c4643d69daf6d4cfe5d50b6c8cf223ec9a8b24ded756aae4830b9ad3a87200421d8ef154ce1fe211dd3fd687e0b59a22bf72001846aa560f90b11c6dcf8f9bb5505ef33a24299fb8e07ec137a81773e129c80930d78887e02e60d4880ea7f63ac1c8cf67a27a5fedae16915a2f721e42ed4e5034c1b03c286ed930f27421fd830abe80765e1a18100d9903082c505ff7f7090d75976e24741143c5c16f865729d2bc4d24f7c86b400126a5502930cf32b2b9479ddc07e28f9568b1c783e391ac61797938ce5a8f7ed903e0fc9d9f4ee735afd69333664811c024ac4232dcf810703de904069ab98981c7f000695637e9380c6451b9dc5ce348734ef9a5410d69ca687a953baf1a1ab5074f43446fc2206c4e4d55d1335f3ae6fbc6a357595362c46a6113a8f43b7a7bd112a11b253aeadcab42a4e2120dd843a0d99fa60d3deb605d293dd1d6fa02a31d0bb619f081e6465518c04494d3ab2cbc7e623e21fa558e057730ddcab1c3eaa5ddcefa557a412ff32832f1b261ac14c55355665dc0634c455a46c48dd32470a9bca9e7b73d715015cdf9515bbdf653ab714348bad6c591eb6e5d09cf4f08442a9fc9a19aafa83a061147fef4ad161e5386885d4bd2189c28db8997c9a6a7c2651edfe4158f5a13fcb1bbbd9e1f3ccaba22e6bac8b23e547a605f48f0a1923a118f2c4872fe8a8d1d2f56193020e0dffc25ef2c5e2966c2b0fe3618713ae8c2d3b8172d37833c33d924f0bce6b4fed3076269dc3e41b4e9365eddd19da797c12ed9ef81699041954561a4857b9bc59b0b7e8a29db45b8ea355a96d3d4b646d0fe57e3b0a7ad3286a218b9f97d37ce2bbee2570e5d35205a8d901e0e2219ff7910f5e26bb3a5805cd1ebc051249627aa26fd4b457b7f1987a87b3d90f80a199d8d371162c3d8f82fcd11d7d3ba180d3e391b3598cab2c71310f071cba4557711604f202c5e23c8f2b62918c291a39b8e9458d460b4ca92574e906018840934292dc5ff1cf49257d47e1cddca5efb68ab8ed4172eb46472064e7db86711dbe0195b0baadb592ff48e3df69fa10e25fb8ae39f6acccd1878ee1d5fbb1f9bb3013246c04458799e22b162450a82aba1bb08f31089bdf5aa8a13f1f5ba49839edeca9e563c1fdcdc56b4f60818a0b7f2b72707e0e41b39445ce0e9ea9628939de859736932c6ccdc74ef1466b99fce925fd95f027bca08ee95387f4d50680ada7fe1dffab97d7d5b9d9cf39ff878a56e3067ad6e709b5c1d5068b2f47ad88a7cc2a37259d9b496606f40b3045211182847228d82828f25cbc391895b78899751f7605f8a92c95ca2ce730f2d70ad8a4aa5eace68c9edb9d972e1ca72f57a3a8a02ecde2bdff8b67ac96722639ff26b9075680d25bbb38af44f3935c96fa2bd820d9bd085d84e2e95fb107de9c9e38b75ac118cb4e5dc2f5b94d67a555d657ad226cdc9e716f90e51578165e0f4074d39b72f248acaff91641f8e0b05181cd58249c91289d55d4185f169462a7f146550a69bb863f475ef847919bd92ce9851a41ea05b869b425d65db3928d234b494b2750dce713827df8af748ce1b853ab00e79c8d762d9adf9f359de087cc9781af06260c2badb0548dc26eacb8cc1607fd8145f00da41bb9eaa5bd9222adb42f739657a0d5d20b9271ad7ba032f865345e327541302c06d467513f6e366cbecf8aba16092a1bbe4beae0af5575e4a0eeb95561b39f56c5c4c9437db728fb31cda05c05aeedbc95ccfc1d84686c426d707d8f69f1e27350c04bc6a097c8375a796d00d1e0bd5ed5ff6ec4b0918f0ad910b53e2aef571ba3c921d26c46642e4bceb1b79aeb10d9a0c8d0f27e36a813a4b3169ad8034f89d0e42667f27e5bfff453bbb985e549445cca63ab61817599df72ea77eb39d7cabca390e8905c730d23ebde475156c242a359f363cfccc080a0029dfa7eb730f81876eabe202ac4e59c89533682dfe8ddaee7b5e40a6ae9e2cccce75b1fb38b481bb08dcd0f30326c968038762ceed1f879d8c76ed649f003e934091d625c0330f77834a369fa2bc92fd696581d6f86c62aaed93edc533b2a134a47aeeac0f9222a6afa12e4fd3be238c3244ea8b027ba5e2242a8bf02bcd9e9c2df8e1749d415b45343bd67511a2cdbe002d0ce9299338524fac01401afdeb955aa3ff713220478b573b4e19fe50c48fef664efba15b11997029acba2406d310b273aa71ecd9a077501d4460707f6b58530077ffe8d3184ed6dbc4bd37734f5d83f55db170ac9296b7c15484d4ab4c69eb338afe2f930c39f43665360dbbb81dce40bb48b03f78e8ca103adfc89ef27da518f7da19acb7ef493d692feb5c388c95129461a11f1f02b6a4e80d98a6e60656c20e2616b69aaee57139700fd4c3c9021a68296d4e8c40a2e06f85ae0ef77714bd89797afd446448875c1b253fef08ebfe54892f1b399767f684f19b6e2a1196961e6608b00caf39cdc92701015890c29560a993746af1ec3dbb73bbbcddc66911ee87cce31ca0fb09c1e2e6c4369e6a38b1b07ca30208a909280a894e4f87f88a909652fe0ee0714ac27d45858d39fee6f1c76f0d4d2330655729d623c8825763059b2338a118e21c4464420e2a0b25001d02a2db4c2df698b2779ba0009798ff386e931c59b1fb10a36416a755d27764434b33a364178ee85629f03cfdd763e50d291ff275027ef8b8874a163eb9dc15d839c17844a925f9272027edd31cb3af81164a71c1d8e1c7d86fafba10175b67902759542c2bc18bbe0479c97655738d63c02a9ef54dbee923d65cb5a961b6d2857d21c7c98992ec37b0cad65010d812da5a4223c0faeb053ddc247099c07bd5818db6c10fea1cfc4bb6d930b461c38ac02562e29df972cbbfe1daa5c01c9bd98f9f244e0267af7ce3b139d33e669f9604a8ed3061d2f608ef911d473e929e370646d33032c82a367dbeef727a5446833ff5c5b683ed0b98611fddb66c696a57b67dd56f5990c8c35b826b2170f194a75387062fc7ad3d447981c7318d554b782a26cbf9c07d069a874d7da40bc73920982db0355c96b7eb397cd8542b5f88d184afb661fdc1fa3ee033e82da3aa15b3ff5abc2d9353ab7b62f4af994459b246b96d7a11cc9c789429341e21178b2ce205d7485656843454e822d155e2e92e6a6e7ead635e64847ca7f7d45179e46346176aefef1b2d576baee48346d239cb723d5a22857e2964a5e90a294a1005a9f0c7433c72b9846d95c7d97adf959a7aaf5df8ebb42f179414532bfdbaa9ebf26142f3698569cb4317f306554bacd1206d1e85a32113758e22396c6079769a56838dd331e07d5e065c63ad0ea28ba9dc2244e50e85fc7cc3c8cc42ae4ff45f791820870bf8934d2f991ffe677e88b7d09c070648e0868f53b5c2cda7c9deb8a51dd278ef3b3357612612cac49ec334dddb04fafe1b8121d75943d20fc36d75008020d2b491b19aa2935c5a8c2423d0c84f040213068e031d9c3f910699193a04f363284aad6513cca4fd45e3f3989aa8b2fc189c3560ecc9de0467c9c194311a132fea73b237a70055845653d6981a1b69fbcabea2f17b3cac98b585d31944510de55c6b5921bcb8346622d91d0c561d8cfc04d098f51e4cbee4ece8ce1907ddc7efe81f91b90b2f59ebd3ca820beb3e36a4c3df94d8bc2a5b8cc309f9fdad3202cf3f8463be6e3a248ca47a9abd110ca33acb84c407b14b2e1888a227ca6d5607cdbf25c1a8e891845c60049b42b71c6666b2b5168b90dcb0d1cf220429b019b70dfdd675d490a213cda4cb29f22a90e25330bd1887eadf6bf80eebe6818b7ec7ab456172e9f1d6a88d5cd3d74b0c845c960c7b35f6020ed451b9031adbf1ddda6778ba955d6f43b58d996fc49b229047dedc0fcb34092c42bbf5aa0b8712c5bee3203da10a6109795fa1ea698c1a8de4a034b5ec548cb83a00fc2ecedfbea50c49b36cbabb4f1e672313c69a8015d1abc9844d577417c91aba62cf226cd6f1f094b9230559560d4e48a7347f420c2f607cd05ec91c29fca76425e660e20a6c651938a45f220f4ab3b82da83181341b2b42a8c82aa2a6234a53f1510e5f00d5f62e44467ce8afbe6c40111e97602610e49ca553c079cbad29d6dc1f56f3e83aa6753a942d55cb467f90470274d76fde8b9f75a928f7bbf5832b195bc6b6552d1752db9b48e04da0d9487480bde8904793230256c22f4518b5315147a64e260c2a22f77406f30022d1e0f87a8d08087d844976183f958e75ccd1379595557e784b036041e56231b6aa0f9ef27515da54109f5cd7de423172e2f135657151692ffc113e1a78f468449c3eb42f5202821efd8a9a4b07b3f89f34991f1546222ec7ccebd1acc2a04aeb3b5b48ee6efd513c6f3bf1fb2d45fcf582ab6c59095a49bfb42511f81fef65fc0866064f9c1f5715a98c5d9c01b7acb9de5719c269d21751a7d77570db441dc95b9ed1078441f51eec4277da94c611987ba2663f4f6beeefa03433fbf206432b8c7d7ee221179bb30bde1caedabd89ad256e2da50d46e90e7e271aa1d0fb18652bb68cbe9ee9ad8c000fd06c7a7c84f1993eeaf0dffb47a3b9b7b9c80fcf46370356eb79890adf66f888b0badac5b14c6bfa187cdd7a665ec4844fa6e69acddbc367e47e8394c4097765b80670d95e47434c19795005388291abb88cc9522c155e2f0224caa841cb9b558a4505f634bea0a6c645ee06d849151a27e77523842c9440fbcd6dfac843cf7abb300ef192208600a27f495d65d3f75ab3d81745077afe5d435df7c9797cc67f095cb0b96607af8c9ef1c4501739763aba86d0b9ca9a0bf84566c786cf8390d3e2ee3b1b46e8e0927e2363ffe9ca0986cde0a5ec304b1d318025c25fd0acf43b891c0435e6e94fa300cb81aad5b90fef41ef21a3a17269152b1c197a196541ce33a8470f3a04303c2df43f39a8a9c7116c7815dc6e7b1584ffc821ae839f534d306a52ac68ec8aee7ba5a6a6ac101cbc0fa7b3af235b1f28008152cd20c70418f8481ab3151a5b2ba75df087bd14e9db3aedc1e9408504cfd91af193b8df6c15e32741fcf9110e646479ad262ff78d74252f368277c6feb4740a9b20657b28a2e2aee532e60ab422222bacfbc464164ce57fced22233ebc5c00f079a753dfde436517ae0137ab0f5da29083426d83ca2d5bb30fc9c8724f60226601538daccc5587b80b42b393635fc0b27a4497f65e0a029d8d00c2f9e6e701f06f726940b96cea32dee2f257510016dc5168493fe7caf9f07c8628ca0c124ee83dc6355ee77b3ddfc930e1c44ab615cb1e584928cd8265ddbc2ec37c6d645677d23320c97624cc4394ce722ce9a78b9945b4864f8dae6df7b8b24f2eaba01dcb13cec4fff3d0aead86eae5eb8196c131eca25ab0c81113c4ad01214bd3fb89c20a323da4131164a9e1f3b1631398bdb4c912a212f17c3f26f60025ad035f35fe28b814c611b7fd71de14a75ae0d8addb989f0bc61755c7824c04b13bbee206fca4bdba5ff7297386d44b524ccca772861bac862278011c1a04f00143de20d7e09fdfc56d5a277f0db3a2a035e1d4a6443990f8b628d5adfdfd74af68c2ada7e853bddcf3c99393e95f5494cea50f9b4a9516e74ac103b3c8464ee64defa9e17addf987f6fb0ee3b00338db47e072825052b1ba353b8b54ab056693be52804cbc4281f0d66b15e0ff20b25d3d1c8b8b6fb714d1f989cab40cd39c29dc0cf5596a4c4d74467af01c54bbeaaf8b797ebcc33840a85e0d5ef10f888c700e0be26cb4a2308f114c7310536f6dde62c6981288fa54f75036c9102b8b8fd654c8eaea8367d8c0df0fba5353c9e269437bb0ea7d3505bb9063a33ecdf54efc9cc70a7c0afae1996bc029d7eff4c68e07209ee1fb92d40be2825c7764f42e955a53601e2782cccf9158545c90382402355304fbb4e02f0625a938b2d7e2f0d3719137bb00fcd7a9ab425f11ab8ec02a2219687ba3680cdca70bb279a7153cbda4efd4202ba864c23c38bcc4425c67a02004de9e6d37fa5158a8ff7baaa3099b0847f1ff7474ace77ce80351f4361e3e5148f6b2005f47de1875257568427a00f8e90c607aa64cebf078802a8a4172d87d236c9d475d0b368c481e048a943c572a7d373480731f888518cd5405e5b6686caf120eca9f0ab11450bf4a8d70f67611204e201fc3549b052702738ab2f596b26be4306a49f48f67212b6cd78ef935c6c6ea2208ddf58f1bea6962455b4137cdf31dba837eb0fb4139fc9eaa71ed90c55b3e354242462adc68cb0a6aaa72c7e8ba3f28aad4c6c95e7a63e2e112687b782a0ae860fd43dc074fa982444a9adbc8cdf883979d9975cf9374a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
