<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"58e2aa9daaa220eec0ad880f8be9dbe8451adb62b1cbe02ed8085480c2106ecaed14473f283cf021aba5b9831426af19e05825fc9403f10e0698daafb7613b7ae2cd5682ce6ef527ff8d862e025cdb87fc99b7a907508e0a4dd3f6a78615fdb8976e19dcb6862f8477cf415d64999f5984cfc976fd3d0eb525585b0e4c35276c2f53378ad260f47670027e978549c3f1ba7e1a038cddae92847c657253f3f3b7e10757196090c896b190b8b7aa4362aa0f9ecfba0ef67202cd607e9479ee5f3a0237b1a6aa6309b7ae24a188adb7dbb52d03f261f35a02724a1bdef005532c3d85acd83353260cfe346afd376aa0e80ac3f48bf3249cb98831b96dccaf1b5b15696eea8764b89f3362630678c37c6ec229b03fe81d34ead7c8c7da7be7a3ed3f386873efa0612509f96cdc8e9371d49fb292c318cfa5b2bdced6b984052f234cb8163d97b0e3a528565053c3b58df66498dc546c2f0b6f38854b8325efb1617cdb0aad19c7b84b498456a362f88e11d6b955a22bfcb08d17aa1b444c9cc44686c2aea0f0ea563a3bba7bd75728c808920de760dab606d28635f6afc23e153d8fb441e4806a5f7951354a429ce3c48e99f17e78639f0d6c0b383f4a0274b9f87feb0d9eae86746ed7d98950316354ce34683f476d117603a9a457692366844855e67592da9d25950f42811d72c8a2902a18812836210566f03a09dc36aa033e7c6fe85c3e061ad818d824269c19760037e3f40959ceb61fdb6bcb62abdaf9afc006350d4e9637a233643ee7bf5a984bfe99bbf3ea7496ce610ace56b73aecec581de01d1cee3069872d897741539b3fae929c5d3ad792377fd28df835664306efb3ffb838024ee64380411f906efe344c82084b59bb1b7b05aa3bedcc0d0bf22103caac00a9478744d7a9ba2f0a07687ef245fa845b97e213063e970a5adcac5654cd8747d22d5bc293267674fbb7f2fefe479b69fb4e5bc9bb7bd64428113936428b2ec1430bc01ba62196079ae477f2b34eec868892025fb1bbd5c4adab0076cfa6aa198f088d88aaa07c067a4a794bde48db2d8cb12040fb5750d69c1651106e5555fb7c03eb24e55f236fe80b0c0e24ab001b1e27279911a8eb1c6617ee369bed532c190a47c9e85518face880f53228a3e6031f05cb32d3d176c3627a8559d30ffa3f0e8052a72fd3468d2ef3e4422393f8a4f1327386a9dfe08c04974ecb1315980c2c1bf85bf436f6bf7a26402c66a08e6da455cb993308196d853d4a1ac4861d665fd2f075866f7a683e0a1e7829b3c453fc76403370962f27ff9d140cb4eeb635f6f06b0a2715969fffd6e9a34b9b326ac3537be9fc2c237df67439856a73d01e510659d5d184667af9b469f2c6b68437656eed5dc918c85ba125e1143adfe1949f270cbc1c5b43a1ff714b4c7793048bab4408419c2d6197d4cdc348e78d0252a26f422b60d8d3e61ab432cdafb2d26559e90c08a189fa0f028699cc22c80a61e3e7ff7183e1e0d2dfe69053a3bb7795c849b6776794e88c72a1bb90d958bda5a5b4cfb2629f92d61576074e050ed29198ef3871a4b742bcb15a5beb266b4c9e824aca457130feddb3ce70d58d5c86cfa0d5449faba5c2224798716f2d84027c1e752c0b5bf0a506de5873db684f964a99427a33aacf7232a376ec19bf167ee0409b3b0584ab73b12935163feb1f98fa7f5ddae6b617542ee3b18d2fde3fea9814a3a247f84c8e7250f51362fa9d1f818dda3df921c0a27d112972222bcadd5cfab6b4e8c861ec274527f2aec9b2463cb76ae6a825d37df2a4931322cc45e86f57777fb2c4930862bca239793955cefbc2599e35844e946257a2a58998031cb6209227dd03e562295dd8cb303c0dee56e9ecb4cc7aefbeff920899615f08c13a2a4de60f9d8c8fc5f498468b0261f90f0f934692c2ce8c1c0646e09a050f53db35bf859c0a5e59a469a695f5fca2b3ece9aad948495775aa83c6ec952d77bac75e0d65c689150975945d5db46f1a23232a3da46feb37d4dcd7c34534be5bd8463dc9c90961f1b18c3df067aa345e623bcee4b4a749587e4ef2dc42f11deddf09526f00dd2cb86a7c3d57a7025e7d5c091e48a26421f806c5ce16de4056402fc4f8dba5eea037375e667dccf6cce1cbcffcff685219d3d0e76dab9a5aeffb3d010788572b355b24fadae450d6a56fb3c11376a0ca07cbaf6a3a11e906a992cb2a5a87101a9aadbf7d46d567bc8e789e8d48cf234bc50c2d39825413d5dd53e5d7b2f78a29171a788fee2ab770dc4d54a3267ca1ae8413d3237270cde1b30b5a471eb236e6b9c5f1b0a17b3cdf0e5287a6465c82eba8f88c63f89f8dfb349434e9443f2d18deda3fd895ac2c84f401c2d3b6483af430f1000e75dcf544ed4d6cf976db215b8576330a80b07f683a35c3160dfaa40baa26c78baac67bca25e5d3d5f475fbf55d8aae6b007efc9a0eb1afc3ec8fcb16fc4a7d32e42130c2c3c13b17424395b12c16d1ec62c558ac1f8e64e3aaa9f84c794a4629057ab01ba59446e2a770ecf200f7a6d66c66e0a04007f911fb88a8771e9fd69eb749d9c1a45a83248ef3f4290694d22bc0639e2230ad0042f3d39d3b246694099845dd04e90fd09875e5a1465d6981f603afd2efc954745cf34c3a6dbf3845c51118e3ca3b947d854961208693b53c26a6f5886c703fbae12b3938b9f05f85870c3005e147175aee86e8021930735d1850c6da3fd024ca487201777f7a2e89baf05e4f9870134ade30192682e5cdc1f47495af10d95ddc4ad6b2b595bdacdd84f2a8c6e190e021433fde1c41dce7daba92ab06fb51eabdb30856be4f02e096760d82cbca223394d1cb5eec07be376af3431c5865a73f99da2e21267a55838144ad603df2ad23a1ac495b0cb626ee06ff447c009de0db86e09acfaa8e613ba54fa7001cba576ad68817233149a65df8e1360b4d59d3c2a7fe78dea37537541b3e76dac08392f21e0470c4db9f447a5ae1e0692a8110d164ab47832ac8ec3555e35f75259bf5ef81af45928f221f0f22c9f23431a58a39baa351663ee757da6264f95bdf6a327848a7edb2f1a3ae3678678c875b947f70832a355951e97fb618e6e0ca7257a4bbf7e11fa8d2d0ad47c5ed59cb6c70eb428be3c25424e1443f889d8b83c450ca3d6953787d0772eb267f3d43ec4a05fa810d06e859584b8c9b4bdc7eda30c788953b435d1c824c07240c6fbbb09ed95d80c403decfa2703d29a38b60a944afdb24b4d5f8e9a01130ecff3ea56484bf3e23d5baf3d57d97f3e50dcf90b2432d6be60e9cf4d19d234584a4ff0387c182b0c9c6d1ba19bd5ee121b04b2a6dc99f3426bcf44143fe913c0865b7b6444e5f0454744678de5f78a763a696de3456245a1d9523901376ebda2cee313683cb1f4293fda61ace3c199318a8214cc1ce84d93c2a700c3d92f5ca231cfa764938ca75330524c559a971995ab872e39a42ba0477a575badef14f84b6ad8419b9bd52c7081c78d1777965fb7afe7da250c0c1d9fb1eac7fb4708ba2ed2703b4b4894f7f91b4aada4987c560cca24e556091f0d0347875b6a1f2fd100995be46d7fcc9aac901b250f3cea62a0f03d89fda99ca7ea7bf926353d81d434255611170c1002f2a3a9f9188f4efe00ca64f513a0ece002869a76de6dd8254c09f9ebd6c59470e99ab8148cf29f4922df790c2979fe32bd04b43cbc0be766f16d6f4cfb57360a0127154d6bbf045351ed776178d29a71cd038985d067321649e298ae990b0c8cafe3aa20b904cd8f589cc95fae0b3594417fbfbcdc6a37e8919aa3af767969b4118749649737dfcaafdfc6bf6a0267e413dd28f97feedfad468534459b10777e283932712734e58ab685e12c6e58248fb6addec13cece666a6b1275fecb943d47791013503b82f7fcdc45b74b39b49b35f10049d59dd02cfb0875774ed561f6c1e53403db61fff57e682fe27cd209941b7706827be21d882093459372a9d23e199c222fcae9d73c88e923501891a8f42343b96eaba1543a1043a565ad78a97fa7843c8ede318765df2924b874ffa566022e3c2dd54a96cecc12165a6aa435d74b7a17dd6f37d24bd10eaf4954086e1018ea376a74bef82b186d1048224264ae483c950dd9b0c41cf7e5f4abd1ad05fc35af3687685e4486899357cab87e1d72df62215df3294b96f8bf8eadc33ebdcacadf5b39002ce78d03d24f8998d29a189431c1d40e9a4372f89032bd5dd8e129ed25b817ce69462c95c28b6a303a05b88d406c6800edbd0977899e64ff3a0eacebb815dafcad02bd24d620fd1a986d3fcf56d15f6dc0c86924cb68bd7f6ce2321f6df8cc478180eff5850b9f7930bf605e8d726a4efde35c4e974fe5dd38992c3d2345e056c4794e8b038d1c821d6a504f14f9fd92492f3abd84581a8ea184ae98c5483695ceee3f1f964fbcc2d7fe10a3d6db85e1d7599d3e6833c3e413a3e3ce8da806691e4e81ca316e6c7dd00a45d3e987edb5c8135e33b23e767eee53dba709e85a683c15903beeeda178640d6644577efb207624c01ce6eec1054aa9e2cb68d626b4ae3900a05384b0d4d19ed633143c0b7cd5e0ae8404bb907fa411b454aa3c0132610db473cf791378afc7edfdaac90ab99d99650721fda4a9aac7ec2b145c221818ba70e2551d2dd7202548780cbe52b5c5e524883f4691629b0b778ade8132350034ebadafce66551c6236fa6e15a289844cc100f68ae7a7ba631db69d33962444366f561d875bc9b7f73e93737fbe9e52e509b319cfe1ea5b9c420f89703b7128e39c3e0b69989f18672d9f5009d277ea90526e3fe590dffc851f3e09e478ba357848374beb5f146387d4404129c338968a8ce362c502441cc1a7a967e627979d3daf95c0948f6daaa27830330bd3a22e23a97b0c22549a73fbc2c4abdec38f12f62b9b5028a8d7eb999145697f1cdd578f718ff2c1b4d73fab00231b8c3f56fcae6f443cc3119e26da963cbb6960f8343a5161c11c816f8d50004d94a5832bc3e2d2ae7313958be83413821a99864442ec0098819c0fb82339b0dc980588142b8a6431204ddcbd5e1ac56f414b9e8f27e2ade93062ad7c18ac759d6fec84927c0f5601c108bb91fa7be93390c6211b1a80c6dbc9c921ae1d1b9205d7b26f8f1c737ea2838ccfd13ba9d7e07e9c6728e64aeeea850b417d382e278cd43fc97fe1ab1aee338a419250c067940e20fe4b99602538933ffac11097c65ea2dcb5a68a244cf0d367e6261301a3e335a758f6e007f0fd9e919f4dce60fb0ca317a569d18b45c7fd45f0e46e59d8d6e69fae847b3b33718d552789dca9a68d03c8481672630eb5e2dde7b00e12848ddab6cdbed7aa5a825c98ed85e251db68fa085d0d51fe7f85ffaef8e7557bac6e642dde787fb904e88fa00b20cf3edeb1031eb086bb291bb12da52b141a36e81664277bba0872a592474dbd8a48f49ab8f4f3cca972c788994a55b5598f5c5a76fe0cc67a24eb1bf9923a187eaabfe5b2a04f463dca8b9595ec9c3c2028321953e604c6596a7def2212a612acad06ff03ccecdfbd46e33f3dc3b69baf491799df53675cb22e5ba1a564bf14ef59bef51c9868dffbd8e596831b111355565746577d0618c5737479394d79ed12aa832f99af0db25990ee45bf732deccf20b3e8df43ece35d2ce58cb4418a14becff353f9d18b1c11e7bcd572c0a070f7f56ed600bd270a7064b3632db4a14a0116fdb8283328f955cfd5f66e0fc2639a584c981ac47d552fae3460a2a25d5f0e7e598771da23c541cf05d130f7b82b400365a56269393d867846077e2a3eb056f9ddd96be11ab3a92677b785336c992ec2fdb39c47312ba0b798038057ca52b058d464a47e8d5722a0baaadfd1bce758673db3d342f81bcecfa14e180470de0a60ecd6d18b4346ae8be4ddf04c08831981b32732098500b8b2fd9ed1fabb0099af55e0f0afa7e554b02402a2e412a3788dc0a7fae81b7f909e996818c22a90b2014f12ec621957786b1d2ccdf5ad7b241c9d37acd5dddc4275939fe7afbb220b23a42a9e2c70c24bc3253d8a2d9c7b8b7ca529a22105460ffa8e86b0beab7470c266e98c031401d3c477c011f1744cd10adfe896e45c0a1b69555c5b2ce4f945b0e19ef0ffb8d4457b63e9b8968cacaed0ad3110ed3ce20657755e79af4afb36efc469e9df3913cd69e374d109e3776b76236518b1bed289e8439e30589c9aaf55b10382f9cd1a0229fe2ee4a57e22012dcc59dafc2b84ca6628041b6c615ba9b389ed03abc33cfa1f3e51a00fd793c01ce3188a19ad03106fe58ce88dfb9f05f6f7d7094f5add37e096d0e8633287af2c31603eae97e370ffd3e2e6d528da4784cd3795180db6f67e2348176673a4fd2fafdabffe1df617d2528291d5e3352553709b5e2b5dee758d03acbbc05cbf7e60f68fc1f8ed974aa4888ccb4ae7cfd0ec8c675f4e2cd17c0e260040b107d9e118c4ceaf5afbf4d23a7d56ffeac5163e7491aa8bce2eb1dabcb425c36acc5476d91893cccaba5ce16c1f994bec0f2092a7571f93a6467cb3ef2b5b50d7ccc51be876f01f11fa4b60999256e946020280b32cf48947686186cf837471864d8fbf9ba3ef41513c03f76d8e2964e504e475ccf69b01b807a999dd1e4ac718b102133fbedf07af7966f98c69389aa13eefb37807d53ebc2df5caad160afa2d9728a255657cfebd2cb5c000598ba8e1ffa3727572e8742ff6268972e68dfc754f4d0f971b99cf24b20e1d77570e408572cafecf2624bece236c6020a4196ebf6f4c3501a8b6ead7eabcd0810c5c20b5cbd717e8e94623f325315d49dcb56057c30b6fbb6e59304ce7de5b0a90e7344d901dad5a07eac89468625ff79ac002273ed727cd37aa84c038e810a4bb0944664b12998121a639a8a9fecc2ab90ed5eec90c9c2e2471833cba82b3c7aa866e20fba9e390f869c767d49252b2a6c09231edb3f85db3d2b8d81fb337ce717be700720a1b14ee1420de63a751827d2b730c856087855f9edde427c8948af21e6fe1317263f27852d9746a98b00baa7f7baaa1dbda239f3a9c0f650b66a0363ca7ab92dbe655db1a25ddfde2e39dbe5ff873941d8f09fc53cdfe608f78422fee37742a8b9272aad40819d70e746de6e9b06865f9a14b6f478e4ab5fe1d0492c11c0d48ce2f6baef89f1265810382422cc9ad552a554a307c6a5b27587a632597689004cc5127237f85e8cb08653919874b5d5411574f78e103c16dd06fc1a7aadd96833becac52581a2fb0cec6b9a9afc885d2102fe58139fc24580d9c7fc5bbe1b287638c79f59aa50455422046d3363f03ca805d7237628204f7548027dfda8cbfce1667a0d6f48e446d8839cf1fd5c6c79a0e5d7278df9b766f148e60bd8270f2b0870a984d6f8265302315d5f40e91f6507eb3cb525a3f3690acdb135073dd1f4e63b03cedf22e4b77af2782629be3f175c648811f8f4b41ea1821f4a091eb4d113c3a9545a324b04959592468262b0a8864a44edc788b66b4a48d9ad53bc849128da46b1e4558e7b4dbf1f8d053ebe4465f22f408e5dcc29284e2a778e3596e797d6b631ac0ca99cf62dafdcbb8ad92ad166a0bb42a26ea853e2c06460168931d9e834ac0cf94ac5e5bd78efa656feda77822290b82cfea605e94efa1c1aac5f82bcf6d87341ca44d59dcb40fffb6b053666352bccaa3d4955aaf5596b0883eb6a13d84db25290d6f30358117d1ca313407850275f8658844eaedf9aa7c2349bd16516f4e16c77325692e1216a1fb88e010f36fc0f91cfe6ae4a168fc297c8c404c9b1ff34736494c6d8ad189d7c103cdeaf8d0c65982aa098218c571e0d12420c4b2ada7e19949d8b443eea49d9593f08b7cd7376da5deea3e0fc4b6b64ea57fc0a6b75a06f56ba665969c6a6e0f3b6530772b0610a63157bbada53994f51c6ad1f9a2793a6885e654875d267ee1b0e1254af4bf67e460f69dba6a64ed40e2f491b52d5129e1badc32b1768bf7777c1513e5aae7eecd0ca4814712d2e93cb7b4cbd967d84844613c9e262bc7705bac94dd670202cba9cea1c32b9925051d5ad572c3168e37ce7dc4b95f67cd4c77a1c1cc20cfa1a2a02a3d53cd7091d4c2e9b644c463b59b8ea27458f89e0c4b78846afcb4f59a88378e8069fa50f853fbf8c8f6671e27a194a9afa6a7873fe00d0703203b4a24cf2ebb33628f4703c80492dedd54a885134173e90484803e5f04613cc1485014ac394664384445b3c14fce764ae167f2966090e7eb8426b2eea18c7cd512b84b38e225e62129c88d34a62e23b5cc4b3d880d0a208b4e3915916e1a6f01fa072a38f5434e87411e8f7be750ec8ced19edb50cf99c6bbca58e20d3b348d02244d57f86377d4d6fa94f4db2997c3cef14f22fceaa2c6e4f60c43115f7f55a6f88c15c89aa7470358fa46bb606bbb2a902218db554d7fc2a79d0ce869617958c4e680e214a910200b150bb9fc117fa5adb0f39832d45bc15e361d70bac0d9349faf8863176a6383d5de2e4641ba8ab4d5aaee6cda296b5cddb1cb274a85f9cf17ba80b256b4f4d4e6b0195eda7d9aaa504bf88ba37610eaf007c489c47b6bbe263b426a6eea753158ab29f0d6833214e2aee70c1e2a72a491fa124bf035631144ed84b9420fc70c377a2ca475a62244e7920ed6b140318156b98ec2b4dcef01837ae9f4304ac93204389375fcb77b107f30ed36395c792e8be81f68b30f8bc3fbd7ba2aef64fb059b5d8bb6f05f30fab89e2c5257dfb4935d24c8fe6ad624c5caf123758cb554913578ea2f5ad9335dc18329d809be5f8e2d19d67ec5b641915821f6bd2805d83554740267fceae9f5f5eb6a10b7a35bc113addd494580ff98ed4a0a640bc9a120d75233b966897749cb70bb12a7cb44bc3b16b847cb356487bea57888fa0e2b8f2d85626156c68471d2ae4d2c361a2a885028e44a85768157665632a795f0035a0f99f6823b1457619ce213e527100cc63250e2c1cb669f12a32d21a8973edd51628b8fc3772f31a97c9af3f9c92bcce2855e6a251bc6f7120dda14788fc77cd959679c5e7adb47f510025ac5662fb23ba944a067627892c496c6c39b58b61d1e0ec15dab5628a9b459bd141e319c9f5e81f8b1a6d4f0c9e9b682cf5fcbf71a199955708e47cf1c9b4e2cb1b60560a28d9111fffb5706eb68ced8c8a1ac8c622c7a4564b04b64937349b15cc4c3d7890fddea1624baedd755c4858f6f2b983860e56ed3a2025e020ca1674ffea6ee43f211621870b3b40e52e02a5c13a27682fc68345be6d9e1cfae32fef32cba9f568b1fa9ebe95a1402a219f0d622d453d9dbaa068e055f55124990615e2d2375ca3a404ad7f9fbb68ba180861f5a6cb9abd0cc33f6d76728e35b747bafa60e01fcf383fc13cc024874a4e07435603574f974029b07772bc937e8237b15bb18e62170fdf9d2271a9af9e3e89f1aebe581114026642720af035e262ef5d5e53a2c88cd67a8f8cd248fa8d0e02cfdfe67f4ca57738c5b6da0cfb39bbef08a99223ce959eac52c5e396abf68179f7e7203eaf099e8849d2a66614c812ed9c62b016b4223bd79ddb9387bbdd3bac4eeceb7fd623f9972947d2d1950ef6239daca491fc30bd677c0288dd9961538e15579cc3e895d4a97835078651bbeb5c20616c79518d6591b185a553f957165bcbd7d89f48dc8c6a262d5ed9b1bc2bd118ef8d6fb192399bed978a6077a07ae305226d11ab0fee59bf06f5eb008eddc1aacd1080673a5550dd3a7b5c3ba4d5ced151978d302b0fbae6013f698082f3725c5ff788d8d370c6d6513cfd06cabef9a065351911e965eb85a06d0de30da76251e80377b1f600939f4516fce28c72fa3e21c5739b1fe55afecf98ec218ed2fac38aac43d5a2474d7bbd67740ae872957024b56bf1b46c07f6096f18b4e3871d322e5cac13651cb70b8ad204ba94b73306463426645aa08e9c3d02f5840ac2c2c76d5f3b0ee04356a521581ae977c4a78853fc0ace5f37472a8d36ec1f6801e6526349323875134cd5af5b3a9adfb20a2b5d4b4fa5d24bb4e6e5f6d31ba267ef97b0fac4861e5476ad1b9ba1aac0de26b2d093607d5381b0ab8af4122ac434b091be9bee3f036a8622147357cdc6f923bbb59ca2017dac6974ca07af74a40e7f49cfc6d1bb062a609d914fd64693645bc0abc783410d6cf23ed78ce5e7bef39e73d1eac864d5d7376f4fb2de2ac765ef53b7f8e3f599f3ba9c0af736f78f8993c92c4d7cde8d357ffb98fb7e805781b7ff01feacfce386c43c6a6f763d91a42af5a1ab098c5c5d4b37c28b718648f93c77cee1c0a1575c47747ee9b79160682192e52403198c89e5051bf36b02952fec61dae808327e0233d5197dd55c3cedfd6caccdaca58f08d3df0a8ec81387f97aeaa70ee1bf1746badfa3882d3193077ee349fdf992773a1fdc925483131e9485b3552714cc94764b4fcd16319a6f3e9fa9886e56cb50832b80a42e07c3b605a7401a451038ee0bbc3eadea7b43ad6bf419741afdf6b131757256fa44425336c08bee120dce59a58c1a19c9701640d788014e441e98df46d6e491af7afe6f2fa0f7e86a0846053a21dad5197786f0a7f2576edf441aa3f468403afcafd79e55056c93840d59232d5bc022324946fac2f28f2ddabd59cd4ee3b0411fd0f6f679a438441365805ec5291b41943bb2826ee16b82a68be3e95e14b242bad618ab3c81b34d81b3b91f5e165c1c61d16dc8c19a462b173278e42a20fa38b752529970edef917f8f67db89c3cf13362470c094381e64f2d058485ef90c32ef3bb502cac80c5387db2223e15fd589f6386973d56df571a5bcfc1baea546fd0b1276c09a283935bba9a4c289965c15c542aa8e7009cb92836627e9d393f399609e428d9a5354f43698c8daa4e52ed84e722afcea36f701a1de6fa072f7e746bf86de6b12ccc7c0bdee849a196fdb1a3985c641f346c205188fae14144215ce4dd8b5e7d6fe4af82d57dcc2be0e7428050017b916def91b71e82621ac4db451526439279fa9f2176a4089309db2b5751957658be225966e48e08596b46e39a6d270291643d25226b8aa10330dd8f03b5adc79a8fff082a253f588ecfbb8045fd0255481dc0229a0d076ad9553cf295e26128db598b87e5300c2347f0a277dde376b40768e885edd34784ca21ef16a096f30072f0d1b16f811b3a61def3e1b48d3c307e466e7d37353a06c9eb7811f9c7a5754fb4725695eefca9dfa17060fbe81d0aaba06d531d89acf07a06184e5e2912987624b2437199acb1e40bd3ea799b3780463b0eb09ef1387c2eeb29f26054bdcfc78f90ed3550e42ce203de20f2b85239e5ce5a9900c75c46027ca197db55e1be9bb693cb31c86cea745929a5685b30a5b7adff069271640180160c651ae8272c43eaf47319b6c14932928fa7e527f731c154f4868d9f2b1fc375872331f2f38be339edf9b1a68876ab99433fa6bb26978dbff9366ac75d75ebdc8098ae43d13e2e0983d7f9a16e6e51fee6ad099c80a0f154dde8c304507d206cbd92274efcf0aa59ab7757fc762a8765e95ab56595cb030d95e90f8e5d6df9b214a80fa9260dc2a6c3f936fcb83a7243fd4683cd2b422d93ba462d5d90ebf76fc43ed2b1c2ba657d4170ab61576125defd629612d865839d27e8d93afded8698db2cb8b5da3fa47f2de0336f18e73141457614f5bab8e6591d60d6a3810bc009fd2ec660736b00cf7a56958a6796467fae776023ccf6e29a5ae701b8315392b7118a290bfb146641ae9366ae23d77bacee8f9d80f2c9f2f4d41f94d651bc92e7463682d94ec14fc31ddb82384ef3bc0a7c031de4f9c33daf406ff32f9c061cb93a5fd59f2e572c4ef2019ed9fc0e5a37498f73ccf8a53e7b8f481751cef4d896f8f5baf2b4a4f1d3b52a0ec6d09e40a51bcbe8b222c5dcb5b1ba17e82d6bdb3c83ec3583b59a2724697b84d2e7af0ef9b6322fba1dea3f1e454a9c2d09f12fe303bba006917f8892a395a6f6806dbe0769eb3e884a20e56973db2ab626d580c3e2314474ab9b2e68c1de0794f231b00cd169911412df68f2feca447a97374e1bac0ea7d277a0b4f7c27722c446a481bb5bd3b99f9b0c00b3bb7116fd8a6fc15ebbae75f4f27ef24fc2fae94e5f0f2d31c220499ef29d37d28d3f83078a7b69017010c4f79dc93d6b8d390201e7e9ae3d321779dba342d7912ae8011f72a34127a561d467fc942c10be130159e383c93051f18798c15f6ddc69a972d5ae0cd38522e724654430d532ba06b9f9468e6e96e16ec475bdde3eee66b0933f9aebbb5d6a5cdb4e99eae680ebb8bf2f6a855cc1caaf15e37823f6caf5575bb58da3d5ae19568a6bb1f58141ec653f55c5cc4acbc7ceed72901bcd294f0bc89926ced7b5ccd6e1a9a54193ecaf444bfbd00744bb1942644ee553a5dc52a4280defc32a4bab4c252993cff8cccc4ba2e78667932dd4e4e89d23764267a6ea695cbba39bc6b6e5528ac1ffbce4f89227f0fda04c465e96d2c4b7e9d1797d3a0add7cbdd2f377da4446ab03bc862565c8821c325049dc5aecaecccfa6eeb88e42c6760fe825d52088ef0b4406cf27475d0889a371b5665e7894bddf73b0ea409eda7cf49efb1e271f09f8e6f678e1f483200b3c199912aec67fed1007b9d72f571600641638e5afd9c0ffa9141a79c756dd91e6dbac2700b1ddc2bbe7647818fa34455b754db70a645be2399c18020185d10b0f0538ba9a070da0dd642af00e903c9d03369b0e169d91064517ebbad80600d456f0466276e5f34562a6a6a0a0efd922c378a9e70b994fbaa2b7a609124bab98b18fb8da6584ce097b667526f738580bbc6a1654f5b2a0d20fb6e4110a326414ffd03eb44af2b7be83e1f99ad4310cab7a47fc67b45c6e882a57f023f419f9ace123ec00bb1795c7aeb60524abe0802b2cf56239ab5b5f065d7909f8fcfd954c6691779176e0f0b82195014ed16f0e16f0d6b20f8ef2debdadaaf302c26cbd45d8d281495d7f08c09fbc933b188c0356ce84dc534000f48ce829f6e6cb5d57eb014e6457966d202f31041ab523d5cd49b0c1ea67a51c26d4c70173e68c76258fd0615d385ae79b4d14f60e1ee7e0c7f09b0bc605dfb22976cc9ba150b5d78e1f8e3f6cf77b349b40e3824d36cf4879920e0d2dfb608f64a18e8986141a533256e195cb40280997626fec151d56927b3051ec658ff485d70f5b10a9adde660d44390de4dd65d8f98ddcb65aa60683f0620a9c949a1be65ed97e56086eab67799cc885748182c76d37bed40397a8198d2860734c74468b9b72d2aa7c891303b51fc038e6d0dacc23795a8b7660768ee1f07d87ace8774a73dd99973199ce8519b77171b63b055806016a82fac21933cf9cbbf5a0c4c69aaf96199df7eb134afb0082d3d29037b38bc1ca42206fcb1163aa6a24b5fa2d9ea25c424f020fa872042d11354a92836ae50eb9df2beb27e1024e94d483a389c1225393a56480a0840f8a4e40a0e296408450fd6fc625f802d2fcce1a696e27812d6426b2cccfe4dd9805e0048489b47a94f21a5a18de636c39c62d8b06ba10b424679e0afc4d23beb03937e9ae777e53c2af048d6f992dcafd77813c3bc4b7ed2dab0fca7f60942b2ea8d5ff6d1207e280f600efac00edab53e3984b074a79959c9cf17a01dcfca7c5bb03f6ef4484ee471c65bec261b32cad406237c37848c34f80abce95dac7ae15ff2bd7d07597f008eb28a93d607e08ab61a4d07245f61df72a21453747630cc1c27beb7033a4ed5eadb47a178d459d44d15cfd4881beb5cac26351966a72c6ce10d3a6e9c7327a8ed8cb62cfe632347d767d69cf1bc8f7cdea9fe1b32b3a38ec44089830d06d217206dfac0c1c180678612c5b215a8e757c1aed916f615155ca0328f2ff769cd8b9bbec203f9e4210780652d18f40848a0e18c35903b295f5adfb89de5b50881fb4cded083a8592abcb907e21c0d15e594a7bec688d7fd45ab34f533decbac247cd7c32294d8e4bc93c3795c8ef5fadb0eab2def3aafa57a0252dbed9ad8b629c60ed889b34644b4562896d03da05c12ed0216eadc857087992a5a61f3bdf11c8e0ae23731e6c1610a8cd5e43b9c5a21f271894db0b6dc0138a75b163a1ecac4cd96756f263f6403a2d84a9888a3100d4e2b46e60733f4aa2940e3759234810b0f3cce237ae22087ea5e85ea4cd752778a51e8fd2e4aab44dcdf38ecb06d5c00ecdf435dfaae2c8690064c2d08b3ca95825b0fc73db645b25bb99e92ce336745a750d88ff01bf2bfc41387d3b436eb085eae3b81a5fee99779f3bae86b1755dea47cef8592e75ca94026e368c75b9157b1016a6a25251e92ad57552fbdf6259939a3a449638b0299a01ff86e15c0bc25a6d2b6887c94ba8402c4e491fdfb1ea1980542921d7e478a8f5491e9e5b9694c8198bfe6ca32d5414dcfc81487e737431e59e95978ca2c227828a4548cf323af37e90623fb82a9bd23c60c463fe5223ee418d3dd251ed8958e950bc0bc104da78f4173e576d55b61c35241b9faf4fd864cbbbb9bb68ba60e92f4e8e511cd51fa8a86d4e2a6e558b3bdcd78b00c86514e8e96b9de05fd3d6b20154ae04a152df846f4ce0f621ad1804dbc218aeb26edec777624fd63305a04cff084e13811336c2fa3e887517d0bb7518e4c589b8a9081e6fee0b564923957704b9ad415e331e2db3f1bbeda73cae801d3557a4d8977e51af711618a0121a8c93327c88d5ae39f8b0c472db6f7c3790476387cf8b708b8bd82fdb1a7ec5f02669c4fb73786326d9e23f5df8507826d75229efe875b75a71368e9ec99bc4653f6411e04d9feba805be3ab39f15a71dddf70b9a2bd18f94be483f285988f7fcef8b416d1e8ad98454b9fe127e3429b5031df1e5612aa5146a110a46de55847f938fb8d5845e52348ed35b80c3bcc8049cab0097d8a8103d161c2a68763d0ec25e46c4dec58c7cf463f62fb8560a34420e38f14767d78c29471912b1509841921240d3254b82d9c204a347757c03d029d58aa34cc5fefa1de3269a67e28c17a945ac410ada0ee41a2a799c2819b50e819ba91910994a54ba50948946327be59be2945a31d0c8a0cfab558faa39c099d4de559b4a4c9e30c831c09666542840e3637b0d9efda934e61f377e14587e6934e36e6fa6c68916379e4aa6bd8890230ca89ea231053f08a14bdb82b8b713409ee5643140e6eee0844ad0f952ebb4595b5d882e3c46e89886ddf5b6ae792d98bd1419707f7351064077228868ebf7def0d83f02c4a31cee4f5cb664c86cfdc2431eaa89488d5926ab8f50462ce7689773d51cf6cbe51f8b11a081cf57d6413a837b77f5de22886094717f992ce1411b22f9f6c1dde73fc8a6d7774145a12267856855a70f45b9a3f0712d29904d1a41290f72d2aa23d86348ca67051c4eab4538347d180796c862f87e5ebfc28adb1b20d2854545257826686209ff2bbf2fba04b3008b726db51943f00b6647420715b8196e70cbd78e82feb5413292da09f410987fdc304621fbd4e6f0527bb479bf87acaaaef082014f3a7bbee1d38916e89b48f04465f61f913971053de4034b44908d048a04abe9e09a59447fc77b36c0e4e2b0421a5ee33a8306a4638f102d8957548e4292de2bc908b039dff2d50c667491f41430b16eea2c7a53236bb08c2501b9a4c819738b4d99b8ac52d7653b5831fcf746e20238d277749068bd997d1b0f7a85766d31f157a16dd9e3c91ad43880a9e66b52381321f3d91affc3ad8d1bd8fef2a9e2d4df1f5b164bdacf599abe48e7af888a8dbc329a395394fb4063e4643442fed8217bab50c549b889b4d350fad3305dfd84a2e9760139d73cfedc1c0f69929df09fcf19114479eb1d8dfbd857967ad2ad3586e684c6a1c487d113aaad01c7f522f778de88b6d4f5a7efd0ee968e1e6ed6f0bfd47ababf4d59dab78638158354b916fb4b2b4515e8e687cd4073c474fc1bbc05c8631241d51eed4d6e60af44e20facd6c2eaec79cc6390ba7a6e6b3076aa399cc66046d029a7eb50f6df50429e9db2309fb781228778767fa505ea538d819876a194c66d69bbf0efda6fc0cf359a51ce40629e9759d84a00fa3ebfefd75aa780ea3c12899230646d257cb9e55d7f1d4fe5877e40aff2f1d8c90f4a8b5e0708abf28778a11b07f5583643060afeb2074aa7f7dbe68a9ba3a5588d1172df6800d3d8de670da29bda4e72980614995ddb452a2a0664cdeeceef31c00ffd7c1dc018db11ed7bb6cda544f56c4b75f6b08e7596cb0ff407098b9b8e5818f2b26e17c86138e80f20b8d0c5b825353e4739e8e4a9e068daf2b5a30f2e0b1c8d0f23f3c5bb1893b8f8a4cb38d9b9760198a1c60f8d6c4f68d87b7b7f45be1a4d1b4d669b5de4c28e36463198b722824c457bc410c492ce745be1834b67a8d3c000b56c1c331c4fb9e38ab19bc7c82b12555bd0ca8935c8a5dd683fa3c2017a45900706b6cd1ac0d7d423fd164ac2cf9c30f67718620ca68bce88d4a8069d31ed55692a028251b91c07a130474a86b93c7042c3e9628462a76e5fb6dd75de2513654a1b57d31a5eb75bf9f397d453ea4da93a077ac56690b94097d4f719392fafff267ab555441b9aa73204227f21851f5d3bad3c639d22ab75880f13a992a2648b01af15c77dec85e6f92f076bf0c12cd6d4bc3aada1d3fca9191fd731ee60308fc119b170bcbd81284f7fe9d9c60978d2a0e689cdd91bbca789b7ec3b32eab69c5203c8831fa18952bc50d01e5675f0d7d555c6d4c263b111a1cb4ff61beba3112ad89fa176dcb73475e88e03d3a81286f1cb9fbec2a65a5ef0cb9bb9afbbec0879624849346fb10f9179fa01b1217b4b8d2ae780e78bf8be8245e53e449b0e8289a7416fd9860c317e9b85f9e501f9bcb844eef7f51c4566a937d9b5ef78124dc2b6f721f96162eb1acbdc9cd2891221c60fda6cf7c22f1a6449c65f4428dba5df87388ddaf9f7d0d2ba7e38fb61da63a6d178591c0ba3c5b9f29800510c4a9d223bbfa75411f3301a1a3554ea93199e0153100a392376e40cae1053236426b9dd110d18d63f56ed946183594f0a1c6918a5bb6eabaf5b099cf419be9e244263bf19c1b5ccaee86b582236d909f3da2bf8a5a527698fea77b69f4bc661c5d741443f052d38815ebd12e0595fc9e717fdfe46f6660153aa5cd5833db22760e4ea54616a5fab335695007a2fb835fb6eda4010789c8f753cd41ee78679abbeffe2aa61f42adc999a09a2fd91bebdac1487625d7ff51923d5aa53105fc87aa8741808ca13ea7c9760945ff04c5fcf4d7dec161c3a039bf23050d13cc2335e9688ef931dad41e325d4439daf5c78a51a1069ba823b15ad957ce9710a76cf83a9983206667b67697a40c0f0514d0ce9aaab7a6fa542f19c37eebd5cf4467680ce9ba79849743f441ee6e056f30892e21eb0f02c327e24b9c3b7f5f12ba5d0f174d2d0ea1442b49243adb42de446d7ce62e63daaddf78ccdec30049f405cdb9b02be4cf1e28013d1b9459faac41b0ce5a62b7f80391f90d4a9f41514e37bd148b9d08af050c44a6505c457c3d9253a423a0a8532c1e2f29a4678a98779f6658ac743c2d8836527089f56fa910357ad41e8fe9eac1f207509407d012e931b30b6fe9427428d66e1848f5496626a1afa5ef0f267c31355af2027a40e5adf3c2e87b7c5c5e71ba249f8fe3318b3c20e97fc1ff825008cac49728de45a1d967b3d164fdac6841ac80ae2dc38286e557bd1b9d5648632282b199d4e4548284a51d5b5672c3fe7e4f68d8bbbd650060c9f4d02868af19e978e3eb0b5513d33fc74fd4feeccc63457bf29f9926d51527d42d42a7b175c2e67aa863a4d35e9ca29208e000a184635dcdce15e74a1ec89183d90fa55365ff137e86b6f6bd122264ec2368fcddce092deeca539046eff7cea576a59ab95f69ca2214eb4b22776eb09e0b60acd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
