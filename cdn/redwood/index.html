<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b6e0bcf22bd3fe43326a192fda032feadca69d841641a2af05b615292a5b53686267e50fb10095eb0f361c25ea8fa1d9dedf8449d17dd87a1a3587a4fa1abf31b44e03a041cd6ff9ba7c44580fed77a0a2732cd5c6c862369cd6747d8e92b5d515294f6e6c60fc484a40764625aa2fb2c63c76739d8769a304dcfff632168c3fec6453407c2dc0270f8a6db4674546585f8ccbaaa7fd84589e25035f9a4f5769910a1ae59ae19ae4df4b8af02f14cb3de3725b61b767307f3333d944990d246843f95b8c70a18e66a246a524bcfa6093000fd9e5cc353af683dc0be1bbbc3b99257aa89442ab6c30299d41f06527cc9cebaf4298edd32eb4ab4613ee7d67addd0366d7fe0a02a7bf86303584fd157615d5cb8c2b592d2682320369569351b31723f1177b5f05ce879fcc02e2853ba3332231eda0b364a99be0dc8edf356478790ef5aef62125cfe1b8a804ed404abc681509fab4c9b4629fed36bd702c0391dd6ddbfe4ddc815b5e7e978ca91db0e71cc47313d93b0d23feb4018114d6062f7215de5168c3fb817415d80eb41fcb7ff5c31d37a70fbb4b183247aeae69dbe00ec78e1be4d18a855b271a42f262b15ae23f646a9eafb23a69fb28060c956de0e63effff21a11c6db35845c90ae8ff7410a19160ef0f3e120faa5c80aba86a0cb67409cd267a4a096e86e0a541e9d4f26f0bd05c699efa8ce068af6f112db0351e5036c309d4652b325025e9d69028292fdae5e793746f118837dc8338436f84ab9727167ed3c242aaa1ee97d69401a4e9c430d5c82add20faaa52761b61129a598fbbcbbf8a36388b615a10788a87641a446910f644f25b8cd6e7880f6c60138950bbfbf7e1bbe4c7a697be83e2e2aa562a74295f19e6f8ef0acdbb57696a53fe30a100f918b287704b91c250acfe3c5f819583fcb7574c275fe9bcfbb9cca304c14ea472f868dfcb7a1b3be75e7bb4b374e9207c89b5527c295c6cce6697c096eb2338e782896a7bd77dd1f8bb361ad55a2931feb54996761f1dcb633dc33b4ef3583fcfbb23441fc8ef0706db13027d63ecba7d2e2abc97d41c5d9f13951eedba71e6cecf3d6b3243dcda1432cf6dfd26dc9a5dc12d32455521dac67e85288faa8436ddd56316c1307bc3bb1fa112ca192ac15c8022efc25512f902ad9d0ec68b4b7b9f0f86f472f8e2728e75fa1908afadd83a74f23ca4629173e829f930f2cb22a787a02deb1e9688f5c302b48d6f5fa2afb2eb5f22e41452622a28ca6facd651176eaad0b747a61eb53f4013b5d0e2d942c8c57dc46b79727e1ccc679346afb0b573b0430b97786642c4228e5fba678b8b9f64eb7e38d6e17ec397eee2c5e8be1b88ba9b67dfa63f14c32fd9a8036a83a69da239b3189b76f358ddad11285f07cc304d51dbc749bb1963a7213a98eab080e317a9f7000791a9541820f099683adb4288e2fd9fa867d203c5abca2932202519b41caef167154249d0e0ec1d5b4e4a00b245a0c7c57b7fbdb47ddd3805ad876fd940436a3c01c904ca75fbb854b78c4df6f6c6dd99e8a85247e214e17c9e92dd27e795267b6db0fa3752817e169628b4d91e951cf063f168ac4018733eca3a1825ba21f16cbd7f8e70a3d6ad2e0d262846f59881cbc0993315e412e524efe8162ada8b31d213d46dac92c422556339f1e2e3ed4bc6e5c309dbaba36b4466832bce4b09622cfb7545d48e2dc1739ef77e38b265361990e17755b902bd26a962ec59a260c7fc8ac18648a051c4548182735e7e450d3282e3bf3884b824beee213c441d026afcface66cee657e967818d7ac5fbd8999e2b8f9fb4edac08fb3b1f682fc327155ecd0310147fef24708fd99edd6589d59f77e249d1b3fce70d46b975c743899c14db5a153a2259bb208aeb793e2dc50f0ec393d39357d92fec255cca73e6fd4e256d823fa17d21b2aa63164818f71c8104f60a1012b2c6817b89beb19b4df6b539585399173ef034b73c13875c30f7c23391811c4617c7584d0a8fafd7965ff0024b3cd0157eae1d1146180bab971c914647c28a764b281d57295b851b3a6eb7a4f7861c4d23f5c2bf0f51647c2ca6257c7e565ea2c7cc3cfdf4ebf0a6fae7a2d0bd202030d82cb1d27d3c3530f2513d816481e807584457cc6624bc4555cfad685048c8b96d368bd5c47b9480c57bca680586adca3730a84f9bd88666b658ec1bff0468b3583e536bdbb2f688c6dca1662ac7b635f01a26a370b089c254fab228424f6bb5623657961dbd9f57819a3a58c6dbfc43ccf547a70989c0bc7d353e141e29026a81f216527276ab38d615e6d17dac2f2a2d5765011aec96ddb7af1bc3fbf76094fff775a9aa5499c449c7d29993bce833697ce21e63792a889898440d5eff7938c3c1a23c71c68994df8b54fb1b8964c40f07883b85862329f9fbefa5774a989ed0d60007d2b5baafe6d489445e8ab5f5f0aa278846fb58d13a8f6fa60365429c2e281ac5facbb49a42ec6cf402726df3a24a81b52dabe35a6834b0b01a6472c79befba40e2a1442ef68169a1b9b8f1d2454ce784df6efb3432c4cb75a133690425bfcfeb10ef3ec4c74272fdb00cfdd426604dba2e087fdc1c6a78d6f437be571e5379f72cc186825d2c035af65420c931c025afe441135cce65e5f5d9d4895fb81f48558e63b1d445f9a28b8dcd9a51535cf996d3d9a39bab04f1ff09301a281833e79153bfde3caa84ebf8e32ed5e3fc7dddb1fe0129455e3e61ee3418d847d6fbcb41fcb45df6648c92982381866a44422b444b1d6fc1d0dca69705df746aa13327fe028ecdfb3ab40578f0bc6139a16b25d6e39296bbdf903619b71909b802465b15f273118485517ab760a8ac0b46fc34152d42518761e340fe0752656253bef85648ed40c8662f1319de595ee39fbc17b19da35f57b4a84693deb060db5d3ae398df9cf24247ebdd2bc52d7486e7138e7b3f1243ee728570bae5d783065318e7c4783e021820a16bd4626cc12108a4b10d37f7838f2ffb50b33f48f3c7f522271630e77d2d55133646975336cf0583561c4b043699681e9a35cbd4ea5323fc0e0adbd24d4eff90458c3e4c4cb911a0e41ff2d54ba71f474dfca296e93f9055af20611bb7dadd8d3e823d49db5ddcc190eeb1e1dd0c773cdbcf46171d81500da18ad271ad661c035636c6087690f106563a5eb665d0772a8a977c9e6bddc53b3d85a85e35795a0967f1a11218e25e26bd88e0b703a8e89ea0ee1ca70c80d3a3fa45e91f200c2c9a18991209cd9f297e925eb10ed0fdf52a0714247d46d1ec277490a3b6886975cee6b4198b1781a3f3371b06ba39105803d672765961ff29f1c187651eccdfb357eb557d34711e0e39c4f9e62024ae0376275bafc61cb3e2e78f8645c27da504cc7e92ecd90f07ab6d3f6ec507733e2c226c34cd1318e65fb021cbfa94a102904ecfc1eff4935cd1e9c6a92e29866c01eb0a249215a7c753dc1df88e3fb23a7907c1a353359d1dd7f074b155d42e972e0e54a3bdf32f5533fbab197b00c3ba7d13d554053bd707c8e712fafa3e7e33e34ab55517d5756804a74359fa737f48d1aa55f43cc414d6d7acddaf66bbeb97216cba126ce572c99c97860e6c287adb2667ff7fb06983cbf6fa913b2eb9d34fd5bfe9275b6a1002e45acb7262da302612d9face0d3f1bae851e7b7c4af5ed1f06ec513e8057663dc7cf0b03adfbd2a08f008d4190241868b70f8c25039ce2c3fa9b357150e9c51585969aaa9a8d240af5defa62d616fde71b45de4be35ab386af2df411b5c2d95876d9f923a4918f21666d52668990a6a067cbab8c27373f9bd9bd2757044d3f7dfe92567d2f38166f70c1a007f58ab08c7063be83eb3ac071b54b15dc865fce50be21589a304aa04a14bd091ec19d6f04a471b34da48264506e7cb5d26331707e8b37d076b18d05785de873cbd01f9588a5ba364d0aa5c8cf922529b7a8d876fe4db0d8194b6d0b695ee28fc50c403677dfb6c6733da0d6273f27f360a5912461f549c5dc487c78d27f4f86393ba3c702cc09076c7763034ac5c0e6b73942cb6d9d84e91913f7a8d1625bfd3154f3bbb64d333f129e0aff163f813be7476bb09f46579355b7bc9af05cd38cb0a74b3a5b6535e903c4f68becd6e4023fbe1f06b2b1ac30673ff77d87e7d84a8c57586f7874decb6d29ba61cb6a84455dcbe9b991928c1df60939963f1c920d9299210abaf76e67b2cd2d06eefe073f922e5ba1e43dd094300b74596713ebf7b2a17eea7798bd27d1867cbdbbbd4675a1dd76507d405673e3b2c95ae668deb464595b8ad8a84ccfc93e29bff2b64b07bfa1e8a1c57757d2b301ec829640dae09698778dfd36d8c5bedaa9b98bc1e932afbe3e03ba97c5e396607a69323e4bfead22fa1acd5e60cdfd9b7947d0058a44a8575e649a33311c981bbc96e1aecd5b296ba3fce61d20569ac6620261781f4c833388302c03f4c6fd742f21cf5c243860755a015bb7df2fde96b81f2dda5819c6f970e7da13c23b1988f979b708a53da8b2f0092b10018d237fab4c57a52b803dc4d449318fee011111b2c8a7ed956de92902e0bef6846eefafee00eaf6041b2f24c0d1c3415ad764e341d95284774328327d787c7c2e07544c1a1670c5183aaeacd625d9f320ba09f081da4bc2941c9524bfaf03c6405370a45071e9e580a8a862a4e241bbe64b263bd117421cdc4f011dbed5cf536948415aee0e9e14d65aa4964be25a192418143ba1e7f49c8f51d3391d1eb4f0454771667495c669368ccc6d73ab8737518b90d1667cd473bc222bfe97e2924871c2f1badce52dfea5052d832069e2144fc5833b757d842fe4a628ea80f073ed8bc1e66f868f3136dc5135941bbb2740b2500435aa953d7779e38b1950377054dd27e57df46d7d7f0de88bdd4ea9e1b8e94b1d14c13d352fa9ca4931f5fb9b8a2247f0812313c4291c759afba256d0703cdb7c14202baed891f32e91397c164642af702248defd1f5116c14b2c029c712f6030d94210264d0914fc0d7130e997215c1c05f4864d3b409af2f168f0a19b65cc97655e67b539ec9998c26af75d024760f81b6d2ba12a99b97456241dc8f29f797f53e0c1591885ee38e97f7fd319a3d5ea2750de3d19700ceda0535798675320c78fb9ff5eaf9228fbb298141364376d9d880270273a3aadd33b5f1d334b96ee8d23dad1eb7868993b8063786c6ac1bf43642b0f857dbae61392e628bc6cae687cdc1c7e13dc3249195371830a5d9168a95a95983a2c5c56ba38c42125e4294aa6f9e6389a0d63b1e1dffde04e0939071109d17391d3ec4d78de724f0b2ca0a9324daa29bb450e1927364a57ff7881f88a9021917546a91d9cf188685843bf4e6b0e4b511625e5b2141ce6b262c45f052ff512440ce335215c580de4b325fca61029ff423bb45fe145c8c81b0e7595ddda8026de125d165659234fadbd416c936336d43e158ba6a51e89e0146155a477e4760d203d3f0ba6151cc08d6d4ed90ad691bc683543eaeddfe2c10c51e9872a9713b149c0ab3a5b4f76dfdf574cad521b5bed5db62229ac81045974fb00e7f42a8e1ee55a04358227dfef1d93089f1d3e68010740a26a93ba91985eccc657101849ab92e694a41a2b8a262e2d126c6dac907bd4d21fead1fef7674f8afb1fb255fa29d41134d3670bf93dc68d8995ecebdda1d186d6706b9e6f6c8e04c8647dca8a212d04f2840af13f99d05817ba49b824fd088649a717d720cde9a1d426a8c30ee9f91070edea5ad2b2f3d097b287e83400279ad779fdc3c9df2d6ea23a6c134e15321f12706565f501840b26fd433b2c55a020ffe6beaa3cf047760a8485792c2b9259fb179fe6e536e6e59317aa461da607c7fee459a6356a99e7d67e91c840b90930599f6417de96aab0a4097980a712585d98d11ca1e53dee9f055a6ccaa434b1dd1a341c4b38a38f78e871e623afd26acca0fc098ea2ab1aa7edb95d52455bff459da95126d4051f87bac93f5ca7d2c643e27576dcd9c1a69ef8be0902fcafc285dd4e54444e4b67b0a1fe7098cd9a11e6ded6de169908678274eeeee3dc7f571ac3af6e86b867a8b531ac214095a04b49807ffa0fbe2e643d59d1c1f1bd7b024227455b514ce4dd7881eccd8e4f37f2d2eeb9b8c495c6586e21a09eff1b6dcf2b22c44a32430cef699b591b71a3c8dc43ee2abaefe7f6e27920ccdee5c164ff14ce812a7244fe888a78e057b2395780561b10d391f491068312c5c5b299dea84ef2fd72baf89d70d0d874c87329bf9daaa2d135111d3dda3120a728fd3f03da3759c9f847e59a431ad0a8a2e5f9ccf9ec4303442c0df6b42e6a80d51c7d04054c866aa6271fa54c8b8d630b2047d578154b0b6126fd6bb54d754ebaef8ba41106cb91d5dea60ace887e479cb20babe58fc503069eb1edf370e69d4d72bcec57a8fe5fcc5b633c7e8f43c9be504c9ce00f8ee571efc5a4ce67052d239f8b786569652072135283c101039a1a5db3bbc8102a439df22bd726ec429ea0f4fdc9b8a95ec2212a03772e23da352009b87247047f54e6eb6e76b35b1e5935e861ce13a2bf1d8da8aad476a5796f714c27888ad9755e0c357abcb4b37301f076257c1fba9ed473003bb245d0989d8e9e53f838d9a461b32ee0dbe24f233b58f46e49e068922ee15a0da28345046216031753e1b2853fd1ec8a937bd6a3a75523e1e225ff3b5f16ece1fe826b19b4f4605c1fd9117d6d63ee30b4e66221ad032a9df3c3a1181a2c2afb5c21ecf68fcee22d20aed0c1de7c1165b35b1db63b4357943b2766cb3729a27aa6578b03ea524a30e312b6269d97f2694597b49d15f75e6b17651a3488ae3ddb4fbe1cca41cb9396cef746974ad951c70c9c17310fb59bbb292253eb83edec5f7c11526d320d22c05dbdf21e4c313dcf54fe227cc59c8ed3c826f13cf197a6ed136f10cb118d0e1c9a45753ee25ef2b01d71b744fc171b7b12fd6eef01984ef51c50a5e3c1ffd7bb9e477d730142e9070166b3c8caf66b60e1de35695b587dba285244ca2e8c3894894a6ebada0373499a3a7cebfe2e9b27a5431ae7c2b1d885c86f65974661dbd9b0ed7ba8f0bca712d18fbf98b0368ef9c4d3556ab62d580fd250334640e8637494b3dafb74e675985c219e20aa4bf0c06e0b1bcc410e7545efcf8de86b7efcc6a4a2847366d5d6823555b10aae28765f2603592ec0e05913d8f99ad057f09fad7c71a323cdb81568aaeab38e756a736a33ee7a538507a2ba33ece28f10e5aaa77d30ac545cb55ee33aaff1584e4ff466f680f01ebea4f62585095494464bed84252bec8df7a8c5c129989ac463759d112bc4c18e3f88edf422a9cc8d38bc061d29759e383f51e6a62af0d3c8a8779049258cad0411827e391169e106833d74692530fa290feaece7776e661323615249da7f621ab2b0251cf636e6978e875efd971ac1e7424c54d3be513d3e93bc52158cf04e47da946b336aeb31cc28155332a1c9e6d3fe1a3ef55f22d6292e67cac66db91a5b8b343e6e4f81ba91dc0f437415ea0b516cee891d17dd254d78a17a6d5d82758720649f11278ad0386dab65f7f401808cc8e6466136df5356c8e76a8a9a9feff563b07d276bfeefbe98596dfbb22cf9d6b0e09c465c15498560bfb666f1d46ce8d7c8bc30cb16ad3e99e8db49f5a8bd71cb456fdec05f92fbeb7962a4b3eb2197edbc85e3b2f47e1645b47ca538871728ccb29a91c87b6fa7f249de072d03d8be63fc037e119b3aa07ed43ef61761fd1a0926af108f4f6cfa02152c9a739e174f01e3561794697b1bfd2c4e7cb9586e1f60c445d95cdd3260aa962449c0f65d2aa8020ab9136626fec87c153a444905a81b661a69b2cd079a03a1709f8359f76f059bebcee2961bff6771288afb36c91bf4af0e98aa71691732b4df644b787b4f3dff78a7949d0f723f1d474e7cca2b6eb408576f2c17a474f2f7ba4945629b16038902c3cbbeb42495b7f3dbba95a5dc45a07549bf7fc7ca6a17e612d98f24dbed08c0d329b534f2bfe16301eeb6d4f77f36a803fb80f32677e91dd4ad233ea2dc0c4bb5094563d5e82bbcfa7875982a521f9be3caf9563b7a9139db7b2ddbbb37678684c8fae58f51691ef17f114a3804d3fe64a8d6f34223d01db81d8896bdcc93f6e4670dbf9841f2b80b7444eda82082a8ff6622fbd175f82cf9812917787764ab140eff935707ce46d1cd4ed9c2ac4ccbe9ea1449f93cc1621fde9fd470379f4c7d4426be93ce5e5184ceacb31fb123c555b9e1cb84a7d295009bd46e3791a2486354b3116311ea68acbb5c274223d9ff666384ae991a98779e526721ff966bd756beaf36e5291d2f6035e98ae4ef28623915e09cf570e09acecb7ff7aedb342a71404a9ec2f9483b4bc25ae316fccd276835b6ba02c2835cdf3bd075e037205fc4c30fe627e7eef2ae49e0549c0e7b5c1ed102b3f994e4d552cd9caab7231e3cc7f1dae1df4640cdeedf88931cf1fe2f7b9f6c17a5a6ee3699d58acd2e34c15828dbc9e074d22131404e130c749cfab3a0d88ab00d6604808545f8853fde8668b6cbc5a56365b543bb419a09f11ec40d3a02ebe14789d1d5ec5de376cccc0b7bce1437368a416c05d9bdaf468ac78af68c70c3a94771d334e4cd0a6b8e819fc3da8fb91e95f1a7d7d0657a02daeb0aa8a1291fb040ea9ff5fbb309cecb60975927b8f6904047759dd2c88a84317c4636b8ddd1939d4496c9d0d8ade1f4336c1d152bce6065df531c1a6e7d3bfccfffb21e08d7160853f35c6d5c968f27cc5e9f9d691d7ac76babbcdce8ce125ca0714bdf4d75746248fd1d8dd1b67affd349db8ed8bd273816fe2f99f3612dbe9fd57b125d9c5454f8c90799fb7d1d87e9d0a3b01f116fbba03302f6bcb7d7d217479eb6a76eaa08c84244962dcc5c78243b85db0fefb3775a6d79465907a1a0a7a0486eefc00581bbd8b54350d3ab1b329f8cf31209c71b123837d7932d54587c6918edb0c11d079e3fd620974d37f057e56f7f9193a3c08d93bd6605bc18c57494954502250a3af06d79009289ff233b38c28bf38008e126d64af93ebf148f3db6cfc664ff2b431b7594151afefd71fecadf5ac0346909b2684fcee6c569c47538a5033603ee9cb5bcbb796b9be2d5ab598b3068e7d4669ff03557c7e926903ef888613f3cfb75df94b49bac7583972f699dc802a0d0195381414c62b07c59e6083d84e2d0c81a1c2d8ceb8717fa1ed5db14e1d59f48f677f63091a61a90401ef9e18ac116734002e69f68fa4d99a27c30c38bd68fe397f1521c42ed1e5267d3c40232a7b243c7f2f31cc65ed900fbf15e12e1490b3b4447c41271b084390dd74a4ee04ce57e4c18ecc6bdeec08de5db2d1663d9b66c886635f7579cf0794d62c8baa10f761f21879be1181d27c128a82488cea2031df4d1ec3dcd6aef520ab86255e67aec16b299344a67720590b196b6c68115f991b11a11c89cb0b184a5bf159f87fb91120b9833c4e031a12d6d6c9dfe8830dd876308fc3dda3c620030337457b2c1798dad185de84fc0564c7d350eabde3a43687b0a6521fac868118d38069cabe84c8879a14e5e475fe79d7e9f828915ad5e9dea7c7f45911262cc2b1381b783b2aa2b430cc56a78e8c1f1ba66f93c3bc3c352e8b0865fdc712a155b67784086be1c13afeb78eadea0facea2eb5b7da7b406379f595c32438edc0c92ac46af76b69f60707fa2e2f82987474b0477f8942725d86d808aa605220b510ff2c2c2817de76fc2eeaa554ceaa3e5fbfead06d7e58c1632602b2e14425ef2aa4f1c9c328e5caa3da648b154a7bb491a85aee85ec949ae806c686bcb0a98486420087fe09749648db4c6792e73c88dded14d9e7f805295d3065d61f441456b22f35741138df7247bca26703ccba8e7044b7285d91cf6094288ce32e539f0ac63325b088a49f361bfc04efeca14b934eeb084268e3cafffcb6885875d86f79e835587285bdc13e6db71ba4673ddd707e449357255dfa6cc45429c3672115908834ae79c171fa911d38d039b6774a2c891b6f23c25d6ccc7ba789af77059dff5a0eac4a3bfcc37aa4d146296ceb2c1f2684b3b0155d3293b91c54fbdf0dacecb30da10fa8e9fdba1a762d679bc6a48c8bfbaf69b3be72cbeb8edc77cdcad6da153418438f8af52331efbaba3a4539d916b9463b639297eb0d43d94ef349b801d38806d044241ffd8259b7f73f8cad8c4f7fdf0c0a2db799590bab68ac28aba3b003d42221b9f1f2e3c24ad04601acf14db6c941ab0b5bbe889a194177b09993d3393fbef896e37afcc9987481ff42c34683d625411f55ad054ebdad17c6c2ba3f5c029b01e48692114a9a01dd32feca9e563314b8874d2270fbaefe5cd5d18699287882435df630866d5148acc9c3b2e763ef3f8c260c342372ded2ef6fa38f55cac112b2528c5cc09691dde42b7e6760ae291ebc3a463b59c93b84b3e974becbc54f07c791a24b90a83ee184f946b6e05241e71308c4867517441ce9116de06efd7d12f27cf89f7eaf0bf0919387d10543bd78fcb42e84f9ccfc78475eb60b978d9db6e1adf8768feae42f8d19fd91533f103d875f22c29d453e469a0e1764aebe79ecd3b9952ccea6edeb7585358367fb0c60b52aebc861e667a9abc277ba1003290cb620bb27b375d3aa91e21fa66298c877655f956ddae605994961d2b4243f53371aba67d56aac2287330a26628d886806b4fca1da88a5d5fc81d43f4bbbe08a0e9b9e3a4abb573aeda9194bc8e9ab939ec40731cfb5ed5024999df4b7e4ad97621d45f04484874172245ac0b1f803f965b75ad28948834b44f2d74ae2450773f99a99d45b19bd3266486052ef1ae62e2a10781d2f2361da38906232330f6254454deb43d53036fd381a15cfb8d81a77e69e5442dcdb371391f2dc0c0ccfc197b31ff545e6dbb3ebc5fb09f5631cc38b5376807feeca182265b684c7ca0cfbc924b2cb08e1a79842ef9ab3fa66a39db99cb0819c5334eabd0137765ddef0750a7bf2c9de7774dcea96eab9298c1054a1d2f0d1af2b066ca1227902c92c6fb6b37fcb2bd52f4c80c032310c5e74d87d677d944ca43e88dbb7b0e778a1f13173969f0b9f3feb4fa9172023c2239d0f05d4f1b51fa3f7a40a3326b762741800c71775a51e449ac031fc8b577d600b169aae04f0f57310cbe687b72b4ff2a0c5d470b3b33d7be8102175cdcf242c0799c9fd1beaa2baea704147d24b8bcaa4d675472fc273bd42de24f532e1e8a59ae50e04684739711235a549cc31b1d28a13d15e07ca5839dc6716f50c0181e9dd61f7cbfdb3afeff561df52afc7a72abcfa69d04f1368e15c9349d70abf8a6e7c97e775c21ea818b2b704aa06172e03ea09d2a5a308af51708fa02e57e4ad49f5469571a5ff00363f8fab20c907545205614c6b4d601253bca5efb52b37ef2274eec729f4baa9043fb4cff6d4bfe899a17554a7ec729c6907abe1410d4140e3f3b5eed5c2005547d765a97fb70f6abfbe0b9669518a7d9362f893607caff28a237eb907077aac40c47745db7b4a536ea54e36e6b2f408623aefec48f6d08b1286a3676bffa2ca96e04a67cc59db7b183e51dce988dee4a1cc685cb7ff2c40fd1130e712fe542716ebf1e77b80ae07ed91ef369cb4b875036f250a1c5b0f7c879a8a3d44701ae903dafff7239d24bd0999763d4e3d98057e3d9bac4fcd0338c1e8cc5d2d5e10ea0c8441c37e6559e4b113820347a3ba67e3811e2657027dd878eea39968a240bb9b22a1e9e419b2870c161ccdd18ed399a01630eed2ff3216fcd48413c24d29e8f6b09dcfbbc5672fb927f0bd60d3bb4bc4190b96a102d2e64a13a3bd365ef3092efbfaea8836700e2a058d6422439e5cdbf12ca31a4d75cd451bff73cb271b41836f01a20d9df6ebcb07c2d1892bcc42719f5a8f87fef36638f8e862852a22e958acfc569cb9112599d860f100ebe183816a064ed7c885d43d7a64180cd692e71aade503e3ef78bafedd267d471e3d9360a837b462adf8e47f0a5bc70bf4cee27d478e0a82a0c10e47819688d20c74ab093a5e2ab43114be90b5a33e4c2a9161f79c29d6fc9d524598ac97ac274d71866f20facc06a1340473fb8f04ff8e0841915c42a7ba99e8e931c1b9122f93f3d6c7447102a32ea8caa2f18b4613732246bc6e94e20e4d217b9fc0fe808998ea89a74e3f46f7ccaee457239346860d6bd205d2b5779b432039ea7f5909839ecc7937a23e428b97bc75c2d1fde460022c4dc8c7fdb12b3eb4822e3f71db1ededbff76aaae219ca678a7fc0105593ca4532eb854546c0dbea8e14ca5859bb52d56c1ddcf75b2e7909258b425f3deb40cbbb1501c3e7650b2e690e29a8a604891384694edea81da5ebacc9ea8c197298e9b2361724f018cb75d02d58bbb6ed5a67f3b89795cfadb68c83f7dc70449f1ce0ca7cb93892de0adf7b17d9bbf349d21d2e8779fad596bdd48eeb29bb7271e6f14c4754111bd62c5b23f9ef8b78f7e486ae0141ce1d933e2ccf80fb4b91550b28ac939249c0857d940b99d5278b7032907c1fc77980dcf8f0efa4f44fb9fcc7663a13ef5bb9df6b7f6982786bff066743d1314e7071b074897f882c57ad2788ee049f0a88e6d8e25ae175d1133ae0919c295c65acd6402e97877d49a6c855fe51840390cd7e095558a53f136da1873f311836dd5eae52955a4e7bffe09d22aa4a73baf266422dba6101a1bcfc4e1edd48b52bb92259bbb708a29c2b0914fa8582abef655dcaa36494deca3c06cad3a167620085f0a1ea6fcf96208bf29d46b5207604e345c22e4b46f799ce26ed8d4239e074d44b96e64480018b265b6934b4f36ad74e644ec387d4081a2b96697bff3ad945799c513895a49cc316789fcd89406c8da392a6af63995b8feb707aa54cdfb89b38ba5e7286fed84a4e75fb156ca95d69f88359611d18160f64c6fd3db359219d5a44c2bd427ec46803cdedef5331e470a2ffa91b50e775db13a561ec16cdc9e6c29dd59d7700162ca350fa3c06277a98a29b21c3012a3b96d5914b97898962e09321d92ebe8ecc24aab8feb374e6efadd788e59f3d0418bf0269db910aa8f469a888690cd09b2bea28b7dc959c5b4b57c7b71172ce81f70921fbe95181078ba2379d476f2b4792a60aaf0936385ce6f4aa199c373f2f12e98af1f6ee82c6183bd815e06d670aeaaf20ef85991cc17ae2c1b98113db97126b89265befc629b6d9b1dad2321767ecf4a846d6df9d3788ea99d22a4044297df379901bf44967563af359b7167ce664f240c2094edefb8b90b61036baa9d418ca791bd30a452759d0f0b53cd9e95a32a9e1118f669f1f5b7ee3578436e53b3a11f1224aea1972152a7a8b5eac84f974ba245a7b600ba6d90ca357a442ec3f176fdda1734e82eca4abb15b7212d027d830a72fbe1cb3293afd3bdad1a99b3cb6d13febf76f985106dc665a37f37c9cbc3d2e3feb6f7d30b4fe02a973e84dd5d34b936241c07fa72b26f6900f8a0d76228efcde166cfe06129383a735f1af96f13dce2cb094712ff147ba284e5d8971278b6210be71d3f58573a1cf93491d4dcc7e640482121ae9c8ce0e568f5f71be93412dc98c53a3c1ff470baee7e7a26e7d4784e514c71efe71b967417a264a1efdfa99f4c7c2252d3e196e320a85040816b930db0f0f95809cffa1d3c6d53f8309d0a2d944c81d9db7e481a2fe872be379f79b06a3850b34640c4a7a9f5c75542ac678936f68357ac1785cd1142dc756e326bfcd54c635dc6f4aa724ddf1ab0540e78c8b86d014845267c730d3ac9a20502db92acafed7874a7aad95fb60928b032a70dca29b6c0a0b08c78f799ee2beda49e4e9afde8fd18b4d9f5c0af832f4cbcd164339d3c5dd831fe87e703941783e7745be719d6d755d8bc28a3c984e8c5a8ad146e562b8f0671f77962f538fb8306e4502b6b88fb19989395a1073ac11087510bddc60a77ca54e126beefff64afb3f2e6e3b4af24e3849ab79040c9ef5aaae3b00bcd92e869d86fc5e3322953c5bed082d1dee9aa2c997c583f969dea42261c261c116a3a428ef50d6b7190dc6ccee616d320500d23060efde2707aa93d0a85f1ed484eee28709c130cb99d852895733086844202cc159858a6b3b6029ddb9b7399baa21d4c7a4ecac629681ed8052381efae5651269e79d28886d7788244eb986413d183a4b1dafac3043dcacdb8cd48fb2c928e728c2738a245c6bf5f212a5ada7e43dbbfc540db0536cb88936949a8121434a5356fce91754b271a12fa2251b049202c6587e2ddbe3d916c19271c5c80de0e8f4aec2fa8c223fd08c7632993ec9ba43e44f19a6f0afe8835a4b190e6eea41845117a5137916437e69b45c9a58aad9027d360609eb4dc2f5961e59e3d77a9fdee5e405b952c119316641488d6a690261f4fe197ab34ef8303b8c3b2f1cb7371538164a4b0784d9a0d498e715a2262c8572539f4c06f1f5d3480c8c5be3d94c444c203bd99c1b3a641789d6e85731676e64db3c898de154678eb1a64bcaa3ccb5ea31b34dd0292c59048ce166170d1d054a418a074a70b52a07cf5e43a4118ecf91a2b9fefe8eecc3e8b8038952d40803e9cadd90119aab72c790909620b9943cfa5cae4ee3f227ad6ca02f72f99636a551b4fc45d01aa9a37a5f5a3bbbd64d25c54d8202a116f98f824fd5ed97cdecb22b71d31bc07df9bfa4987149983c00227ea49030bfd5c634eacc08e3142eca58175b4dff682dbee932a2b1fd3427d673c20569f7b81f3a2c3dbe696b037639ff16629403a59106dd2072efb5415b46901529667240bc0547b215bcaf9e7895a024932f90e4437138b16958b3a6a75934330179435019bd537031962f59b2e64775af80df76541d4d51693145d350af0b07020d7222c0a8d188df0fd7a9b8c76f3f060d71f865b73c3994771484abad2b368ebf75a13a30675f2a191fd239701d8b53cb7f2b2de4d42ab7d9347d392cc5c20951ac9fdb4b04cd031b58680af90b2d89b423fe2570cf0b91d850573d42d09b9e55c733dab78160ff40d2e2409d019734486e5eca93f6fb6c03c7f057fe3e650079839cdf0dd606976b29036ac00a7342b20068b74d8b08427b67f606f4f0cbb31186566abe4e99c8bc3c8bcbb38db1e0d84ad985cca998e37083e8aa260ce16e8012afa62a4cf5e0d0067366cdeac31dfc8ecfdbf8a5cbd09c2e1a96ab8256ff59dff7ffe4794302d361e1fb3a303cadf030daa26c83757acf9a1979b359fb44e2d5d4ebda32d4e04f761730b369b9fc3f231ef494d653c42e237afd122e21368d326a082407c466e55935c727d90d408fdd28b9715d337839e10572b50521c9badd01168e4d1c86b4b6a0f9cb0f3487b526828026b81dbea6f19efbdb896d253667d5b6c6b944420118c29e1466cde1d3d1e1b558a942a2909cd3e515d8d46799ee11da0e70e8fb2434f81e51dd9b4b0068f0a417d212b91fcc342c1d4ed67d74f83a32da5013395e18fdb6342fd5057be646c4e0782c7f5d6582fb615b1c506804613936dd777b0934fcbe52f4f6c230c60a3f4d87b3d1da22bbc6ee29b93fc56f35079d6a6a8a32d8cfccd94f455afbd87df600f07416cea8ed6113f6dd5235c46c64a636848913ff6b9a57b60f9a9447345fd5f40f8ac00fc3fa8e6c6e00b24726f71331ada51ab644bfca11aa14dbc1795f5227396f98203ea18f32b08603d0a129a4687694f56cbaf254502eeecfc63a0c1c696d7e7aff42475e73976fc01d65f7a756888ed925d515748f0b5d96f0ff47c7cc7033026b86f7e96f53fa1711e5cf5906adff8dd8dfec20d834e7155c2feee820cb620ade7270ba54859671fc23f382925429613f8ee469ef00a77d65833a28fa136284178cc44a747f22a6fd4cef2b987fc013119a86541c522d70afa67d227b89f2629c9eead3fedc03093c2e218cfc48aad6e22f0c166f226caa434975cadfc75f244cd6c9ae01b9962144c368be64d12420fc7fe35e7f485abcd5387e716ca3aa1029b1501ce25429fc58d28fb86731e7abcb6060e383cda0bc11fcc1d5e1fdc928744287d24b8489ebdcb4902458454f9182b74aec7971acca66267d0bc97281882c795cb30c519d3ba351d16e2eaae033e7ea3002af90b61fedd67f6272d625afaa951a222003f9dd373698caa21af5c2d3e3e84e6af47d88dd233732eeb504edf717b1ca6e31d45c88123afe759f05b8f6e314c3b83ae26fd874f6f754cdf94c19f76e48f693d0abb6737643982d3bfe282806c2a73d29a17016d163db51b6a3bf57af7ee1184ff64f02494065ac654d73345d26a61f5892ca4c333ff63c4104a924f1bd507f4bf77848a0987695baee029382aeb2c19b4da4cc4f343ab1a786c3743bd75b0c896b1c801797c57689fe10cad5fbb4b5b0958f58eefe2d45e7b3d50f9f0f136d8181e0504d09f4c0297626604f5b66177f32734144457a275b3e2cd748b6935c23f1e2c92c22c8669e0dc61e4a46725865201b289d83193e25556b6dae31fe40ed51eb4316bb594f1948d71343776be6316ca07ed8d80fabf6210090efa56cd65e739d4aa0abd8a632ecda7cb0c1a628dda8decf849b37e3b295a5f428a0d059c39b60b844a599122af64b5d3efa0f1d18b80dcc3a52bcf8fdc34b61cbeddc4725034cdc11bb0d7f37cf0403d92d044418a7c6c7aea4602b2c8de57eedb9dd2acb5f02ebd11946435cfb930c4b1957706d58735b0c9ab1c90af10c1d3e7c7c9e2d045eda326767d734e7a28e6403b74491816f048e475766c13eeddbb1ccec2d1cdc6dd5da286ce0f38058bfb6b6021552e4c9bcf227220406e8c489b1902771be9b0cb6e7eb12a967dff1540d6f3f736319e5fd32f45fcc600e671100e6be01c96aad327454bf6e677d5914a01c27138a9c8fbd46e2f496b7c48ab72c9d2027b861dac69d346a9605f9a8661b02e0c35d08909cf119c617b0f10f5be54b9f623c8fa0ff3b06b237408853af6739f207a2e010bcec563f142f77efb8dd33a6aa501bf6a1d2875d117a7e887c909bbba1c7bd22794780b188831535a46c1d2274710b2c28d9459df5ee067810c63ab65c77eec2700f47a71fd12a82c5ca855efe257f57393e6b6dd0510b78a3f0708c085dc5ce221cf8ad31e81b11f0b9ef07bbda150a6017d37b6fae28d896d7853854c7e7c940998a017d0d9d938a3cdd70f2ed388124041215c8a37a55e9005c14d72d3b625c6fb475ae28e6c73b27753ba7f59a9789f1b88f50dc72dfa3bc4e9c1ad207416f544e0b962cb272f9d8d027254b5ab6e0a7d7b20ff91619b96bd04693f986ea0df098197fd19492c0b553e595f9ad46e6da026bb76f0b4523699c489eb706fef6f19f6aa1a9daad2e0d9c202bb82d3995d1a26c8e93ce4b1270d3d51334852b91c13f26de88cc6e4b7f80a473f61abcab1ac658c4e43d57b9e0d9ecfbc548b3f4ef887c82915aaae64cfa34a329291b45c37b738247becc4e8809c786b70370ac7b2dc99ab92744214392742b5144223aae44ae0d6b7c9ba9852386e58335a3a4f20cd43ea6ed4e5fa5c1e12f19db93685313317b39acc54fb726e6284d0fcface604db1b84d46870707425a669f2d7a812ef25a7b53432e27e050dddfa11b1b8e8b0adbd7dea0b5f7afa2e14e29f8f7866d72845fc43ce352e57a67124e76ec09b1b1e4aa63fe30ba749953798266437b385858a729a9d31063e42188ae91e26d49f00552d10f90ab60888880d221506bebc8f9e463286c146f14189f840a34727480ce92644f0d65cabede9e7044d7f4f6f1ba7fbc45d8cd8c6dcc09352b2ce383ca44e6bff634f7042c95a448254315dba120fbf5a8711df1928dd6c973c8dec850dbbb0f7aecee73f481effb7e11ac82668f219d7c6b2fc9664e348908e5ff25a243212d5b61cc55b09cea8722c7667939d1fbf4a631b53d0bca6fe93125f63fb3c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
