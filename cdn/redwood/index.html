<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"45640575c983c61e0654dd6f898a0cbb4f742dfa40bd842ba392f27d4d3e04fa9c89348bcbfeebb2f20bd65ed955f46f1948dc82e6c992cc517618b22a9cf48e55e7df2914414dcc595dcbf4d0b5a0a20aae3afbfd5d9fed82abebe8e61d8e4e8879f95b14f2c62f90130adfd674d449007893ed61e9e019496db87f1472ca3c799b97e3c83c27dbda6bde79d90922bd638f1e728713556b7cd8d2b2b863f169c8cda09b36332d40b86dea279152655ff73aa2d87d41f81e83ef63f30f7fcf5480a5723d4ca78ae7b77023bc3264050e5c9690416b0e4b54464c11ae72ae1bd71ed33b06de409634efc40c387f5a169bfa2d80bc8bece1f32b57ad26bb188fe12877e527d41d0d4674632957b0bbcc99554c181227846f2e828d86277ac02311095f683b79b8aa492a21c30f6b462c707bbb73f5e438c2deb7e0714b29e049e95639c8b501f1e921ad365ddc82fc9a28ff9152df377ed750454a99795798c4d66a6d99248ce16afab8170fb54389ab105fe97e838a6a77929110b2ab0ce4958febdde154c08213a0bcc8f152b4a919a3f5e2d0e1a1eab553fc379a30bf905e8b2cdf25813ffaa622cb5c95eb89afa61cf4dbd12425bf89c51a843cf23e2cad9fab5abee902c3c4d45912d6c9df50c3d167c06a5364c34724202d64f11dbf422a0e093edac14637130591952334b262a3695fb71f4ae4d02a2990429e80ba48ff37648bb45a08573784cddabcf97d5fe4f67038fde08c87fb92faffd4338cea6e6a4d7a2aa536c5363eb6b17bdf12757e8b060719a2cbe44967864199ee3063fb9401c8a0f7fd97ceea05ec77a98041d59ad67b821b43816845f6a5262a1f67fad6263d1538fc9b9578b24adac8e7b3edc0fa16f8aa03a426c2f0b1db14fe57afb7057929bedd990092236802c8763983fdb8b415a74fcb9cee862ae77132963e987a62e0b910c168074eb0ce30bb84ccc118dc80a5f7f2a6cda9d718ef7a8c846f74a8af13883ba21a00cfcff920a554c04f080443c2ae38608a5678e14561ba118571e0fccb864d9d7daa97b5cd97890ee02c1f67b6381c54cb9a2ca01214c7b30dad0da99fd5e919454121cbbabc26cc78924dc38cfc7d56a40d37435e6d8ba1eec284cd15f5eb9cdfb65a9c8cb927917cbf3de2cf4a6f95e497730976fa7b8e8d59c6f3093e33e0f2a2eb86b10438145fbfa7f9d5ebd8f5f8332600c2adfec89b53d29388dcdb645b1a22fe297652320613fea054ee4385be03b81aca3e3c88a48738b47a3c125a4dc0d5b1359560ed1efabf38e79a1c791195e78893c6be6917c1a43b2d430906844e01a30cc16882ad7dca7c27555b5fd806d5b747b1c5f51f4e2e4f04abd2ba6dbeec3de81a37631c94992e5306e67d89f5084fe7c1d16555c0f102691aa2270b4f3de329b4bd01571580f0c69f8b750c028ec80907aa7e600b0c0153adbe3141b27e0d668d0ddf45747db695ff177fdb6e9ad84429a25d865909747124f9384f10b669f8361c891d387436e29e27fc175b53ad0bb48e8b14c923f81ac6f5b39279218c3ced5e2eb0fe9ec16f7c01d0f271aa1a1cbb37a6320749e2bd6a4fd84259d2a1b880514f9c68ca8844ef11dea904befbffd2143ad9b6cf87d136b4d50f3653f45aa4f2a31db15cdd219ffaf1179e418ad8ef650b4420ac2d8a8ea27707a8d5cb6a2ff79b975b3810902e0bfa2dc0dca60f498ce60c0aa6d77a1203dc9419f34249faf429877328297765879b252e44903b6073c47da44c363698d69313862883367163371ec6d0b07e7fc6fe7041558fb9f83c60861aecd5270e70c1f03d9f709b5b34306ff810d38010aba4e32009dd30fe22063c09af90c5be7a8e59e5b79fa8dd6d08d5eb79fb58b68bd641f8fc9da4efb346cfbdf19722c0578000ba334d3ccc661a404c4008027732ba87764bb45d719fd479c5821a36acd5982ed72562541dbce7737bac4dc805729c7fdb73490d9f0b500ebd696a769881679271601744282e66f4307eaae2b05998f99ad72c11eac5a02155339920b1c7b22fac35e92f8dc3aeab097d2081fe26aa96adf4274517f1b51167c8a7ad2737ef03cd8aebdd0c3673317b43bb43a6e927f30ff1fccab7987873d0c4bf0c71045b10a06844241be927126bb93a555e379b75a1f3a40e476031cb9459426ae45f62f6c63dcc54a38f44c57ae409b3b1d00940865018f968ee3a3e089395cd214ca0ae0821fc1ddad063fb127f0caa620d2b4d2e2aa6c966fa9d63e2c8bd683466b6dbb474ddbb1465aa77321cb2a15622fd7578fe260d250697fb8a3a40a8b5d49869094b1e5f88539b462814ce37e8c47495044fd5757b26052aabb127ecfc218854ef7edb9b4ec2c34aac430f7fa40d9e7b8e3e25b94b0d73e8e3a680c746f529de3df53d4a50bcae52c2e1283c89b70603f7cee0a53149d5f20260cfeff277d4f1207a000fbfea0ae9399474992f207451ab25d5681cf322eaad89fc9ae1f483c651d51494096708271e65b4178a9099205da9ee55c924a5d37f825876b9a831ec08d3e9025917a7db9b8dd32a3a4c45dbc937ee33bf4b7c534c81f931eba3866e343e4d7e8a5f99b7018c93520b558a62e649182e8ba224de7947c5eb8181c5668d7a097d0251984ecad5ffa091e239aace90e3c8a4748c0297e13e10ea2714ddcfc752ea4225e6bf7e98e6d1bbd7c750bebfda5b5b75233e52c33a947dc320202b7a602a79319014b6d16f295e09e5959b23d1ccb2576ecbd92231c338a27d68965ab33a4c60d273e3334d26ac160d447653d9816c902b79f394e344cec753b24b0f7af71b9fc7d883b5bb32eec571005338b9cd840f1fb1db9601878b9e5d8b41cf39adc3d2207d518e51ba58b573ff5ab109dc02b0bc1aaa3e0951e56b8d4a9167d6ed4c841da969e95200316270657e12314fa4e1027aa1ac3b18d3d383d53bedba64f9f6aab3832d6049c77ad5eb779347a383e89f91a92a62a797dfeaede7a0b75b8ac49819e2b2046a2b1450841fdbf62010b6d2380b590902f8078c61f7afdae886a5ef3b22508cb614fb4786e04d8ba4be1cb5449c0a17766a467e1e8d46cd358c2c465d6dc5d26805b8e0212a533104f2a3e4005d2e71274df441a68a3252eb4ba4ba0214cbae162d65ac26534b7912ec293724ea06288b0db6d9fd98ddcf6cfc022c48ee01eb6bac9096c39f883f1b5ea425ed2cadb578ee279b34debf2c841e76efb3125cd5fcaa918c32ee745590497886a5f1c0b42537a75350a2806c918480e2f75efb55bb4521b4f063dd46ddbc934a583bbae9720b78939b56a85aaaf35dfc9ad524d2ac9034f396ad002014f1b151d7b0745f8dbf051497123227017f8364e63234d624fa2fe308a28064cf56b3ae15eeb0b492f4cd6e4bda9abc655e053de948a32518170863ff44e93288151a33efbefbabc50fbad99ea095b3d823b524db1930ddbfd913239f7ae6c51307a58d976c094a82b729bd304a7309df13703a019794191abdb31ea23886dfb2960f42f07a57c4cc10fe0591a0a2b2f35af35383f1bed316d47b8edcc261b4a149354c4c73f41d212fb093c0edb63c2b44993583368caca5291e86cbc800778bfbf8fbaca09fa9f44377ea0aef2122bddf60a3571fa833220561d8ff30ee37a7f81ad0a34e2690ea32b779983364fe223a0f6a81cb703f5bdf91adc83c34f9fa38692097251041803c90d0e0a721123becb19210ad1aad8855ea3f820155cbf448d31b59d24a479ef6f217f078d579b36cf8ebcbb5ec9169c2900e29b22779bbba80e23670c28a37fff8f79e2e4ebcbf5f55c48ddc08ab12d9d87259675d3f254cf7bad0edd6b87268b4b51f34891179902ead282cea27ba53e95937fa31732160a4933e684677647066ca01796ab18067edf35877d525ae2292a1177274f4e29cfcdfbe98f5f9639e8d809abe6e367422a05f9d99b3f760b36d3ba3590c73ca0c378f1c7248a02e93e188a8f522587ac9521a1c34de6d9eec34b057a030a1fea65d274c29959eb0e5e683bee480248f001aa12b1b75cedfc8a913190ee8cd0def67c9c86d8b15ae922611d3fd5250d6a6944e517f560ac0e5d3d36c329a4ae7c9a1b30cec91d2bb8c8cdd2f2bf3b5b2991bbd168fcd9a3ec7f54594699f900f98bbb046d80012341734b8541aadfbe4d93975e74916ddef967b26b8fb81349e7ee958ea9870a1dff5e72be1915ac283cdcd49b8b2d65a530a94ba6756bd3562973c7cecae2c69d9fa94ad1580fe9ccc589aed37af7e96fe5982e0f79e677e88411760d73374dbdf269943c3c19379da8fe847198aae134ee18a35299958c1995dbc6d293347ab0b1c374cf891103f09faaa236b2924160e182ecc12f008f78ae954cedd2d89d0281e54f13391044bbd678b95b1d32e4897e5f42615b70b1cff4eb41dc73b6dc6955cabd9470d94d306120c6892d67f3e4d22d2644b262a9a8da12b3661cac5d95dcc0ee453a91dfd82295d8e9996da17ffcda51fc4127ed28ecb5f369083a063f2edceb7c900c5465a40e0a2726ef684a2cf4db5a4e441b05963fb05dd579063deaaa7cba20291abd70daafe7b2d884054e8819e274570218d4811b92fae3b96374bf1802ebc7eb0211b784126338e27a1b51f50ff0b67b933f0528102cbd4396968f6c5a849022338d71082b08f40f8745d4d3f68223800b9c7dc243c47fb62e7cfeec00c75dc672e37be3396065791a08cff6359f3677945ebb485d8dcccc28de9ce50b903c0e6ae7ce30426b0bd90bb755bd3e2ee8cf89d3c58f2389ab827b9bc6fa4cd271605f5d84ab613b5c7c60ad9e7520c7da81b7b59104acbe02eea094e83288cdd580680c7212f18e64c31db7569dffb0d770d7f577adddcdf4f84c5c3885413e3903256125ffaf935497fa61c8b11714bb75f6fe906cc1c977e7a5b2c5b1d38bd06dcaaccab00b465e2f062fc1baa1227a51c8e35373de76f2d67432775569196ab0edf6e0ef60e4f60045cfa9e7b5f827e0a048808ab4856b4389cc42b197035a3611c9077d92f87cca54945ae3687b1d678cb388399a8b0cf54dc0f4a9dd508ed6c1248c67d5770c83c164c877a9058237172a4be0b22b4ffa5331859956a3d31b70ed3c05e1ce2a5845567936c325ec661a7c0abf7a3e4c7b86ebd33003ac7663dfda86711e56e563379192c7cdf6acd7c5427b944def73d46b61515c8487475df218711c2c8d8e9e80097e1a238245e121a8d32af8b8d006c0517a122846d2d9fb5127db3f4888784950c12f158b00b66838e2e78c4fecd5e3efb59609c9bed059c65236f4c74be1862ed62ca01f4b8a0eaec4993a4093837ab7ff67dfcc09eb240f99b99bd885c6fce2e3ce47c3cd022a240e739115c0af4866fd339d031f4bdf9c58b928d879670dc665842c7be8b1084a234d860e2de806d353c5f4e8973b060f5c9d8579784b7ec70b710d888316f86436ad6a71d4d032bdd165235d6e058e1a3efab15f1fcfaa39f33bfb0ab2fd39cd172aa32bfedf3386062b3b885812a636db2a76ce15e777c1a5d2022c6827f9774dc9ac7096e63fa0199d2301d7c7f8c38450525d937a8143653f55e3fffccd8803a22808cfa88c470e1dc37203b3a95a957c890d7995eb05c68b4b50d57bf0f054d64d0db28ba35f5160e00a19744aac2c2320b9f9e0676a18a3df639375f02bd031cb60f463e0c5e3c3760ddccf1a65cacb08472901a12a91d4bd183fae2d436b6d81a2505485840cd14e7aa2288712140b602a97b2650261dc842e2dcc12d83c3c5b1664eacdc29435d7ffd65eafc7ef8c533d350f55ecf5c46fbb16c5892345d9098220ef386707b0330ffcd939f3528ee97edc7a5ed33fd9507021b771c308fa75d56f0e4c80c2c4a20b8481432b09449bb23c0c24f3fa0f0f81d73a4f1a2e7a59bbed78aabcc07afc97543387fa48040d031c9b083f0dd6c3e31a2c3d3ef716324f054e57c3fd9d29a4e40242d20034cbe59c476a18188984e41accdd92190f3ba54769f4697450758417193d6da4d036765264ac084eb7e6eaafd1e10a1870880ac766d1f19a672fa886dc96dcd3f19d7a267917cd5fbd64da3fec7978050163fdce79e2468982420fa259a3457b3ac80f2110a983f930a83ebaee4b7b597fb8c54ae08dbd70518b409f72bf37f616ddcd548c1feb3babcbf7c6ac1cf34d2e0b8f3f90a2fab6779e6870dfb9daff7dc766b3661ded118ecfe1fc91f2a62bcd2d73586e1c16c649d02a0cd6ce05a984091859accdf7a450c672af80276d1e7dec5cfeb63570b307e504175525e639572ceec435862ef83d6d8e0222cba47752f6c1c10dc4dfe786835581482a00849ccaf81f8f3339491d48d2ca13dfd4f9df4c0c3808f9452132e76d7fa8e2e1989efb259415520b2758c0a624e98397cc52a55683a68080fe34b96b12ab50b5b1f1c85d29123abc374f14049454e5f1b92a7c3d19867b02a6a9a5226f0ab90be6643c7197f3e6bf4e9f780cd8cd51dee88d5664e03ab07266f1834ed1a7243639864d425b1f311bc7d3365265883a7225116ff578966276d903e1f5b50c36e5f4b1d2faeba4d90af7c707e2ddb6ac996af75851219a31bd4fcf7e488f30856de939d9182067a11874404dea1a00b29986a964d0172c5f67f86689f7654be1bedcf4d3a0781c663e8c090d84275c8b45b35b6c49853d29022380fc84f8cc51ba514a89922678c681cc91f1e578c7167961e77de6e1e6f13b7d2b30828e70d09e76812a163f4369f080028d05d2e2f104d396a81a7e5486229e2397965b62180ad8a49b91758bd4db14ff10b77e49bef3a82d948c6641b50248e29c5eabb58ff389a4fed78e2232862eefc4f31be23eac246048d1cf03d4a193f312086559c77fd204a886d2b0f2fab63923425fa24b09dc27a3a42d392481c172e575f2f3ffaf3d4761c8d1352a38f2b95d6dfb96d58081afe8bc5833eb7de1e3c8c8bde95ea1fd288a7685be631eb11c53815748a17dc971b8b75e5cc26329713c4f06e6b74e307abc09f0155029cbe37039bc543f3078988cfb02cf5beb6609d3ac8e208cd49f781eb424281ea9e1edd78f0972c156b92b513ba7a3833103326247e3c0d7e37256c3dfa967c56abb1785004a32d744c6d25328a3aa0d95f211bfca233f08241ba6a562b09da8539f990c91279b67206e973cdadfd47305a5dd1e91fbbc16d76d83a2bd20ab0c3587994857e3288febcd1b229d9e08d85a0dc4d7f1a4dfc0fb737057b1798ec36874a23e7d0955f21467f4daec28e92eb8be68a52fc3e5bf312e8f687081428769f2161184081b7d3aee430fa06ee42656df854b58f7a142105fe644cdfd3b81c0c74dd6336b3d2d967b618fd3671916203d8bc4c1cb36b6bd6a7630b6b26e5cec86fa41b673b3ed9e068c9b4255ecfd6baf1fefb5d2620d3b7e77d8ac74e7e94467f334bc49cec4406891a2367c64d62e98dedf6f8f2b7296e09472368b02b1c37f05a78b0a9726b936770f12e68f884d70633b5168665f8bc0759212a697811cdb7f285db248a5efba1660def24bf9e37e0f958efbde91cc8561b26af05ab25350a3f0a2a225dba2d6018c58cdb035f9d958422ed16089b9e817c061c19976cafaa71c0aec05bb6ef0f3a21bf6adeb05ad34cc30b88d424cfa7fe36c9e052f8d92563fb64fde209ca0c8ab99ed3d3d8d3ebe616fb1fd5c58da94ee705eb6d1cd72d0c364cead526d9172825e7b5f5c4fd8697c8a43d07aede4928525fb2959eef29feef92f5c10d538840f90044c304ec64917838483e8b866ec13933423c0ff119e82e6b1e90a2d96e0ae691658c0f2d3d535c3bd9e6b90f170a4a90eefb86a103d75bf695762b6f10a8656c0bf96fed8e39aedec30e0bd035ed5596edbaca916999ddb8b4d6957541e7a4430a17ba54de12ee5d5a18f25aa73defb995876c4ec4f3e0ecb995618482944b718ce76be9300ed6140099afa9a662e1e60e40ef675218451830a311964fb660dc0ca804aaf1dc5558c98f1772ce8cd31e727c95fa8bf43f72c5c1d980524951bbce3bd00467c8d8e239a9f6e9f4579a8d2add2c3598ff7a716c1bc9ce209486496f48531a45827e5765bc07350ace30be8d9fa71161b320dd312cc87a7f3023bb3d43b7051cd45e6f0b74de6904b0cd6d414dc859c2fb42f7746546655505bcbf172eeb938c9e3cd0bd2d8a656d8a5f504162bb334454b1ee207e4f054a0b11b58cc9ddea978c1a41caf75250a87dbeece29370c0bc636d7dce33b73c64dfe4eb06c0d8cdefb078a61bf1e43d322585919b99ccb0e345f60940c512725a2e3d12e9f925fb59d97b77efbc85b9f69b993b878d17af1048cbee3164a90986b6e07d0c74d4facced02303935f5689f9d081688d61a7e1c20bd265f07466542586eb41485ff52605347e6d0393cb8d32662ed29ad9e42f9b192fe708d2b5186f26657ef94764465bfd61c32ab7dbaeb51c2816d1680ceb81cdee9740526f8a306a71c91ea4e70988a58dcfd5c6ab8d61cde8ba4f9361635f607442545e3bd4cf17df418945549fdb7bfbf3559c90b101e3b90d7a81b850e8014de3762b35d77ce6e6ed0e0cb61bc125de2aa986cfb5c318cf1a47b2899535435ca487af2a000d4a4649bbbcc016f8c376ad08e5ac5a253347b63709e0996196e2f362199fd67f7940cf31656f6260ace983bbe13f73d7816e35e3646702fa8feb0171b2053880c24ca5dc724c7041f2c6f96b622b294a305a9513d32c9cd77b7b851ceb98be5178601510525a3358ffd5ca9ed6d4087be833ba53c7eee84a5b2ad4c3af03125d821cdc9cf5506aa706dd2543db48b7d6df8ad7c6271a2ed4484bdf31cc17188d845f55d2363f81ab42eedc9f56bcfc0c874c66432087bef502bdda52a7918e309f592a8a35b6c6407e9534b2d936ba7befd79985ee54897c36ae83c6b44e3a420ce47a0c98525649bc55fafda3cd51dc24766b7cae0a8d99f85c7f258e481f1fbcd46952114bae1b604f3dec2fddc277c010334fefacd86cb030b1643d782d9ebe73024d6818ff9e53afa2da6ee418e1dd4d48371f4387ad48d679dadadd1cf6a905b058be2612ad6a67815a3d7cd37f52c66ea55afc272621f22f12b2ec3de0d1909547bfcafb2b0cbc53654f255f3e29a31fb075ab5a511d7a36058265cc73e4f5d3229a4822534da065ec8f42d47067c0daac62df74809fb5c834fdd56f7f9ce5e9302f5049c96e1aea142e7047d4af682197a05456fd9878b7cbe8c23b84bd5f82f0e5e7284fdacabb201a279e0c8f05fb5d252471f3a276c2a9de2c68e2e72951c216e86f966e0d62005fb5fdc1cf47ea4e6a556e9b49f1dd8d21013270600b9177305c2b7dfa575397547ea1021721cb5feff0d21c52119bffd6180a624dc80ec4754091731aa870228a71017ee67ecada8ea4c4ed4f403b42b01ed5cbbcf90714c4252d888abe6ec9c16a86379a937b61069390fe312203b9550c7addba04629cc4e2fa03e25cb2c5992b9e33f7a2c346f25139c8051361dc707b42b3683a96fb66a134410fa49d4944287132569be5d5e67a605a7032f39c19f0642406177594e896d0d03dbd66242bb2fb8fcaf280ec68b0d5976eac3d39b4be5dfb3e2bd06210ecf44fb81c8e18c25124a77d02432f68398bd7030d83f615471052548696f5f7fd78354575ecc05e8fcbf6035c4bc5610faa6d5dc20d1a337f28ac690f4b1bcadd454a93ecaa5bf6c5e24fb5f248965e9c2fe5ae71bc2cabe1adb3eb513c8fbc0ad72413089c188f5c6e6f5c38471d69267907ba396adf7c76260b2397f5d9637d8be071e48de7e2230dbe8db14029d20c90889847197b95e846f95b61d4f6ff60525cd9321935dc1f40fd7aa22ed76afc0d0460d891bf457acdc59340c1a1161a38d211a1e9215c1efc81f6e033f41abdc13c5e374e0bfac54484e2386908a0f4ec83f241a4929f89f7990339145077bc28e8ca9026565655a749b1ac487dc93c5a3af28bdc921b9155771da680c6c41cf3e3dced76e4a8e3d0e51a35fcd591bc5b809509eebbce97fca7b00be45fa64e66b901e6df881d14a0c3d8d480ba4028e115732f9ebea4e93ec516d0c336e5400d2f785345e4de8256da70fab70512ae04bb578b699298725aa80813dffee5d74a6dd1ab3c4cb82305470ca079baf1fe38016dc28f0f8339dc790065e339dbb3873d8f4785dacb96b17952203b7fc1e74dc82075b97ed1ac84bc10e1c1cdc20a2d3390643dff9e62b1554019cd55d505e305d79cada83d8601e2725acd178cdec4297c64051e1f9ebef983a28008e4f7655ffbf5b081e14d582be5dd83f45ce90ca83e8ea3d57a1bba8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
